var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
(function() {
  "use strict";
  function plainObject$8(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$8(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$8(newObj[key]) && plainObject$8(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __assign = function() {
    __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function lowerCase(str) {
    return str.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    while (result.charAt(start) === "\0")
      start++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re, value) {
    if (re instanceof RegExp)
      return input.replace(re, value);
    return re.reduce(function(input2, re2) {
      return input2.replace(re2, value);
    }, input);
  }
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({delimiter: "."}, options));
  }
  function paramCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign({delimiter: "-"}, options));
  }
  function dashCase(text) {
    return paramCase(text);
  }
  function wait$1(timeout = 0) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, timeout);
    });
  }
  function autoCast$1(string) {
    if (typeof string !== "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
      return string.substr(1, string.length - 2);
    }
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber)) {
      if (presumedNumber.toString() === string) {
        return presumedNumber;
      }
    }
    if (window[string]) {
      return string;
    }
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e) {
      return string;
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var a = Object.defineProperty({}, "__esModule", {value: true});
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var isClass = {exports: {}};
  (function(module2, exports) {
    (function(root) {
      const toString = Function.prototype.toString;
      function fnBody(fn) {
        return toString.call(fn).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
      }
      function isClass(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (/^class[\s{]/.test(toString.call(fn))) {
          return true;
        }
        const body = fnBody(fn);
        return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
      }
      {
        if (module2.exports) {
          exports = module2.exports = isClass;
        }
        exports.isClass = isClass;
      }
    })();
  })(isClass, isClass.exports);
  var __isClass = isClass.exports;
  function cls(cls) {
    if (!Array.isArray(cls))
      cls = [cls];
    for (let i = 0; i < cls.length; i++) {
      if (!__isClass(cls[i]))
        return false;
    }
    return true;
  }
  const fn$7 = function(cls$1, settings = {}) {
    const stack = {};
    if (!cls(cls$1)) {
      cls$1 = cls$1.constructor;
    }
    if (settings.includeBaseClass === true) {
      stack[cls$1.name] = cls$1;
    }
    let baseClass = cls$1;
    while (baseClass) {
      const newBaseClass = Object.getPrototypeOf(baseClass);
      if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
        stack[newBaseClass.name] = newBaseClass;
        baseClass = newBaseClass;
      } else {
        break;
      }
    }
    return stack;
  };
  function unique(array) {
    const a = array.concat();
    for (let i = 0; i < a.length; ++i) {
      for (let j2 = i + 1; j2 < a.length; ++j2) {
        if (a[i] === a[j2])
          a.splice(j2--, 1);
      }
    }
    return a;
  }
  var lodash_clone = {exports: {}};
  (function(module2, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function clone(value) {
      return baseClone(value, false, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = clone;
  })(lodash_clone, lodash_clone.exports);
  var __clone = lodash_clone.exports;
  var lodash_clonedeep = {exports: {}};
  (function(module2, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = cloneDeep;
  })(lodash_clonedeep, lodash_clonedeep.exports);
  var __deepClone = lodash_clonedeep.exports;
  function clone$2(object, settings = {}) {
    settings = Object.assign({deep: false}, settings);
    if (settings.deep) {
      return __deepClone(object);
    }
    return __clone(object);
  }
  function deepAssign(referenceObj, ...objects) {
    const settings = {
      array: false,
      object: true,
      cloneChilds: true
    };
    function merge(refObj, mixWithObj) {
      for (const key of Object.keys(mixWithObj)) {
        if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
          const newArray = unique([...refObj[key], ...mixWithObj[key]]);
          refObj[key] = newArray;
          continue;
        }
        if (settings.object === true && plainObject$8(refObj[key]) && plainObject$8(mixWithObj[key])) {
          refObj[key] = merge(refObj[key], mixWithObj[key]);
          continue;
        }
        if (plainObject$8(mixWithObj[key]) && settings.cloneChilds) {
          refObj[key] = clone$2(mixWithObj[key], {
            deep: true
          });
        } else {
          refObj[key] = mixWithObj[key];
        }
      }
      return refObj;
    }
    const potentialSettingsObj = objects[objects.length - 1] || {};
    if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
      if (potentialSettingsObj.array !== void 0)
        settings.array = potentialSettingsObj.array;
      if (potentialSettingsObj.object !== void 0)
        settings.object = potentialSettingsObj.object;
      objects.pop();
    }
    for (let i = 0; i < objects.length; i++) {
      const toMergeObj = objects[i] || {};
      merge(referenceObj, toMergeObj);
    }
    return referenceObj;
  }
  function unquote(string, quotesToRemove = ['"', "'", "\u201D", "`"]) {
    string = string.trim();
    quotesToRemove.forEach((quote) => {
      if (string.substr(0, 1) === quote && string.substr(-1) === quote) {
        string = string.substr(1);
        string = string.substr(0, string.length - 1);
        return;
      }
    });
    return string;
  }
  function get$3(obj, path, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj[path] !== void 0)
      return obj[path];
    if (!path || path === "" || path === ".")
      return obj;
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    let potentialPaths = [path.replace(/\?/gm, "")];
    const parts = path.split(".");
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      if (part.match(/\?$/)) {
        const before = parts.slice(0, i);
        const after = parts.slice(i + 1);
        potentialPaths.push([...before, ...after].join("."));
        potentialPaths.push([...before, ...after.filter((a) => !a.match(/\?$/))].join("."));
      }
    }
    potentialPaths = unique(potentialPaths.map((s) => s.replace(/\?/gm, "")));
    for (let i = 0; i < potentialPaths.length; i++) {
      const path2 = potentialPaths[i];
      const result = __get(obj, path2, settings);
      if (result !== void 0)
        return result;
    }
  }
  function __get(obj, path, settings = {}) {
    settings = Object.assign({}, settings);
    if (obj[path] !== void 0)
      return obj[path];
    if (!path || path === "" || path === ".")
      return obj;
    const a = path.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => unquote(p));
    let o = obj;
    while (a.length) {
      const n = a.shift().replace(/\?$/, "");
      if (typeof o !== "object" || !(n in o)) {
        return;
      }
      o = o[n];
    }
    return o;
  }
  var md5$1 = {exports: {}};
  var core$1 = {exports: {}};
  var __viteBrowserExternal_crypto = new Proxy({}, {
    get() {
      throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_crypto$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_crypto});
  var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_crypto$1);
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof require === "function") {
          try {
            crypto2 = require$$0$2;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core$1);
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(core$1.exports);
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5$1);
  var md5 = md5$1.exports;
  var ansiStyles$1 = {exports: {}};
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  const cssKeywords = colorName;
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert$2 = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  var conversions$2 = convert$2;
  for (const model of Object.keys(convert$2)) {
    if (!("channels" in convert$2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$2[model].labels.length !== convert$2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert$2[model];
    delete convert$2[model].channels;
    delete convert$2[model].labels;
    Object.defineProperty(convert$2[model], "channels", {value: channels});
    Object.defineProperty(convert$2[model], "labels", {value: labels});
  }
  convert$2.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert$2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert$2.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert$2.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert$2.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return __pow(x[0] - y[0], 2) + __pow(x[1] - y[1], 2) + __pow(x[2] - y[2], 2);
  }
  convert$2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert$2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert$2.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? __pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? __pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? __pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert$2.rgb.lab = function(rgb) {
    const xyz = convert$2.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$2.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert$2.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert$2.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert$2.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert$2.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert$2.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert$2.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * __pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * __pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * __pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert$2.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$2.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = __pow(y, 3);
    const x2 = __pow(x, 3);
    const z2 = __pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert$2.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert$2.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert$2.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert$2.hsv.ansi16 = function(args) {
    return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
  };
  convert$2.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert$2.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert$2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert$2.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$2.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert$2.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert$2.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert$2.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert$2.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert$2.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert$2.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert$2.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert$2.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert$2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert$2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert$2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert$2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert$2.gray.hsv = convert$2.gray.hsl;
  convert$2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert$2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert$2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert$2.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$2.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions$1);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions$1[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions$1[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions$1[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  var route$1 = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  const conversions = conversions$2;
  const route = route$1;
  const convert$1 = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert$1[fromModel] = {};
    Object.defineProperty(convert$1[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert$1[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert$1[fromModel][toModel] = wrapRounded(fn);
      convert$1[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert$1;
  (function(module2) {
    const wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    const wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    const wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    const setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    let colorConvert$1;
    const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert$1 === void 0) {
        colorConvert$1 = colorConvert;
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  })(ansiStyles$1);
  var browser = {
    stdout: false,
    stderr: false
  };
  const stringReplaceAll$1 = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var util = {
    stringReplaceAll: stringReplaceAll$1,
    stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
  };
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape$1(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape$1(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  var templates = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape$1(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  const ansiStyles = ansiStyles$1.exports;
  const {stdout: stdoutColor, stderr: stderrColor} = browser;
  const {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = util;
  const {isArray: isArray$8} = Array;
  const levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles = Object.create(null);
  const applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  class ChalkClass {
    constructor(options) {
      return chalkFactory(options);
    }
  }
  const chalkFactory = (options) => {
    const chalk = {};
    applyOptions(chalk, options);
    chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk.template.Instance = ChalkClass;
    return chalk.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  const proto$3 = Object.defineProperties(() => {
  }, __spreadProps(__spreadValues({}, styles), {
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  }));
  const createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  const createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray$8(arguments_[0]) && isArray$8(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto$3);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  const applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  let template;
  const chalkTag = (chalk, ...strings) => {
    const [firstString] = strings;
    if (!isArray$8(firstString) || !isArray$8(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = templates;
    }
    return template(chalk, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  const chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk.stderr.supportsColor = stderrColor;
  var source$5 = chalk;
  function classInstance(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name === "Object")
      return false;
    if (Object.prototype.toString.call(object) === "[object Object]")
      return false;
    if (object.constructor === Object)
      return false;
    return true;
  }
  function deepMap(objectOrArray, processor, settings = {}, _path = []) {
    settings = __deepMerge$8({
      classInstances: false,
      array: true,
      privateProps: false,
      cloneFirst: true
    }, settings);
    const isArray = Array.isArray(objectOrArray);
    let newObject = isArray ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
    Object.keys(objectOrArray).forEach((prop) => {
      if (!settings.privateProps && prop.match(/^_/))
        return;
      if (plainObject$8(objectOrArray[prop]) || classInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
        const res2 = deepMap(objectOrArray[prop], processor, settings, [
          ..._path,
          prop
        ]);
        if (isArray) {
          newObject.push(res2);
        } else {
          if (prop === "..." && plainObject$8(res2)) {
            newObject = Object.assign(Object.assign({}, newObject), res2);
          } else {
            newObject[prop] = res2;
          }
        }
        return;
      }
      const res = processor({
        object: objectOrArray,
        prop,
        value: objectOrArray[prop],
        path: [..._path, prop].join(".")
      });
      if (res === -1) {
        delete objectOrArray[prop];
        return;
      }
      if (isArray)
        newObject.push(res);
      else {
        if (prop === "..." && plainObject$8(res)) {
          newObject = Object.assign(Object.assign({}, newObject), res);
        } else {
          newObject[prop] = res;
        }
      }
    });
    return newObject;
  }
  function isMap(value) {
    return value instanceof Map;
  }
  function isArray$7(value) {
    return value && typeof value === "object" && value.constructor === Array;
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isFunction$2(value) {
    return value && {}.toString.call(value) === "[object Function]";
  }
  function isJson(value) {
    try {
      const res = JSON.parse(value);
      if (Object.keys(res).length)
        return true;
      return false;
    } catch (e) {
      return false;
    }
    return true;
  }
  function isObject$3(value) {
    return value && typeof value === "object" && value.constructor === Object;
  }
  function mapToObject(map) {
    const obj = {};
    for (const [k, v] of map)
      obj[k] = v;
    return obj;
  }
  var decycle_1;
  const isArray$6 = (e) => Array.isArray(e), isObject$2 = (e) => Object.prototype.toString.call(e).slice(8, -1) === "Object", validate$1 = (e) => {
    if (e === void 0)
      throw new Error("This method requires one parameter");
    if (!isArray$6(e) && !isObject$2(e))
      throw new TypeError("This method only accepts arrays and objects");
  }, isRef = (e) => isObject$2(e) && e.hasOwnProperty("$ref") && Object.keys(e).length === 1 && !!e.$ref && e.$ref.charAt(0) === "$", encycle = (arg) => {
    validate$1(arg);
    const recurs = (value) => isArray$6(value) || isObject$2(value) ? isArray$6(value) ? value.map((elem, i) => isRef(elem) ? (value[i] = eval("arg" + elem.$ref.slice(1)), value) : recurs(elem)) : Object.keys(value).reduce((accum, key) => (accum[key] = isRef(value[key]) ? eval("arg" + value[key].$ref.slice(1)) : recurs(value[key]), accum), value) : value;
    return recurs(arg);
  }, findRef = (e, r) => Object.keys(r).find((a) => r[a] === e), decycle = (e) => {
    validate$1(e);
    let r = {};
    const a = (e2, c = "$") => {
      const s = findRef(e2, r);
      return s ? {$ref: s} : isArray$6(e2) || isObject$2(e2) ? (r[c] = e2, isArray$6(e2) ? e2.map((e3, r2) => a(e3, `${c}[${r2}]`)) : Object.keys(e2).reduce((r2, s2) => (r2[s2] = a(e2[s2], `${c}.${s2}`), r2), {})) : e2;
    };
    return a(e);
  };
  decycle_1 = decycle, encycle;
  function fn$6(value, settings = {}) {
    settings = __deepMerge$8({
      beautify: true,
      highlight: true,
      verbose: true,
      theme: {
        number: source$5.yellow,
        default: source$5.white,
        keyword: source$5.blue,
        regexp: source$5.red,
        string: source$5.whiteBright,
        class: source$5.yellow,
        function: source$5.yellow,
        comment: source$5.gray,
        variable: source$5.red,
        attr: source$5.green
      }
    }, settings);
    if (typeof value === "string")
      return value;
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (value instanceof Error) {
      const errorStr = value.toString();
      const stackStr = value.stack;
      const messageStr = value.message;
      if (settings.verbose) {
        return [
          `<red>${value.constructor.name || "Error"}</red>`,
          "",
          messageStr,
          "",
          stackStr
        ].join("\n");
      }
      return errorStr;
    }
    if (isMap(value)) {
      value = mapToObject(value);
    }
    if (isObject$3(value) || isArray$7(value) || isJson(value)) {
      try {
        value = decycle_1(value);
      } catch (e) {
      }
      value = deepMap(value, ({value: value2}) => {
        if (value2 instanceof Map)
          return mapToObject(value2);
        return value2;
      });
      let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
      prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
      if (settings.highlight)
        ;
      return prettyString;
    }
    if (isBoolean(value)) {
      if (value)
        return "true";
      else
        return "false";
    }
    if (isFunction$2(value)) {
      return "" + value;
    }
    let returnString = "";
    try {
      value = decycle_1(value);
      returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    } catch (e) {
      try {
        returnString = value.toString();
      } catch (e2) {
        returnString = value;
      }
    }
    return returnString;
  }
  var __parse = (value) => {
    if (typeof value !== "string")
      return value;
    value = value.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${value});
    `)();
    } catch (e) {
      return value;
    }
  };
  const __encryptedMessages = {};
  var __md5 = {
    encrypt: function(message) {
      if (typeof message !== "string")
        message = fn$6(message);
      const string = md5(message).toString();
      __encryptedMessages[string] = message;
      return string;
    },
    decrypt: function(message) {
      if (!__encryptedMessages[message]) {
        console.warn(`The message "${message}" cannot be decrypted...`);
        return;
      }
      const string = __encryptedMessages[message];
      delete __encryptedMessages[message];
      return __parse(string);
    }
  };
  function availableColors(settings) {
    settings = Object.assign({excludeBasics: false}, settings !== null && settings !== void 0 ? settings : {});
    const _colors = [
      "yellow",
      "cyan",
      "green",
      "magenta",
      "red",
      "blue",
      "grey",
      "gray"
    ];
    let colors = _colors;
    if (settings.excludeBasics) {
      colors = _colors.filter((c) => {
        return c !== "white" && c !== "black" && c !== "grey" && c !== "gray";
      });
    }
    return colors;
  }
  function pickRandom(array) {
    return array[Math.round(Math.random() * (array.length - 1))];
  }
  const _colorUsedByScope = {};
  const _colorsStack = {};
  function getColorFor(ref, settings) {
    settings = __deepMerge$8({
      scope: "default",
      excludeBasics: true
    }, settings !== null && settings !== void 0 ? settings : {});
    const availableColors$1 = availableColors(settings);
    const scopeId = __md5.encrypt(settings.scope);
    const refId = __md5.encrypt(ref);
    if (_colorsStack[`${scopeId}.${refId}`])
      return _colorsStack[`${scopeId}.${refId}`];
    if (!_colorUsedByScope[scopeId])
      _colorUsedByScope[scopeId] = [];
    if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
      const color = pickRandom(availableColors$1);
      _colorsStack[`${scopeId}.${refId}`] = color;
      return color;
    } else {
      for (let i = 0; i < availableColors$1.length; i++) {
        if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i]) === -1) {
          _colorUsedByScope[scopeId].push(availableColors$1[i]);
          _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i];
          return availableColors$1[i];
        }
      }
    }
  }
  var __set = (obj, path, value, settings = {}) => {
    settings = Object.assign({}, settings);
    if (!path || path === "" || path === ".") {
      obj = value;
      return;
    }
    path = path.replace(/\[(\w+)\]/g, ".[$1]");
    const a = unquote(path).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => unquote(p));
    let o = obj;
    while (a.length - 1) {
      const n = a.shift();
      if (!(n in o)) {
        if (a[0].match(/^\[[0-9]+\]$/))
          o[n] = [];
        else
          o[n] = {};
      }
      o = o[n];
    }
    if (a[0].match(/^\[[0-9]+\]$/)) {
      if (!Array.isArray(o))
        o = [];
      o.push(value);
    } else {
      o[a[0]] = value;
    }
    return get$3(obj, path);
  };
  function toJson(object) {
    const newObj = {};
    deepMap(object, ({value, path}) => {
      __set(newObj, path, value);
      return value;
    }, {
      privateProps: false,
      classInstances: true
    });
    return newObj;
  }
  class SClass {
    constructor(settings = {}) {
      this._settings = {};
      this._interfacesStack = {};
      generateInterfacesStack(this);
      setSettings(this, settings);
      applyInterfaces(this);
      this.metas = getMetas(this);
      Object.defineProperty(this, "metas", {
        enumerable: true,
        value: getMetas(this)
      });
    }
    get formattedName() {
      var _a, _b, _c;
      let name = `<yellow>${((_a = this.metas) === null || _a === void 0 ? void 0 : _a.name) || ""}</yellow>`;
      if ((_b = this.metas) === null || _b === void 0 ? void 0 : _b.id) {
        name += ` <cyan>${(_c = this.metas) === null || _c === void 0 ? void 0 : _c.id}</cyan>`;
      }
      return name;
    }
    static extends(Cls) {
      class SClass extends Cls {
        constructor(settings, ...args) {
          super(...args);
          this._settings = {};
          this._interfacesStack = {};
          generateInterfacesStack(this);
          setSettings(this, settings);
          applyInterfaces(this);
          this.metas = getMetas(this);
          Object.defineProperty(this, "metas", {
            enumerable: true,
            value: getMetas(this)
          });
        }
        get formattedName() {
          let name = `<yellow>${this.name || ""}</yellow>`;
          if (this.id) {
            name += ` <cyan>${this.id}</cyan>`;
          }
          return name;
        }
        expose(instance, settings) {
          return expose(this, instance, settings);
        }
        applyInterface(name, on) {
          return applyInterface(this, name, on);
        }
        getInterface(name) {
          return getInterface(this, name);
        }
        toPlainObject() {
          return toPlainObject(this);
        }
      }
      return SClass;
    }
    expose(instance, settings) {
      return expose(this, instance, settings);
    }
    applyInterface(name, on) {
      return applyInterface(this, name, on);
    }
    getInterface(name) {
      return getInterface(this, name);
    }
    toPlainObject() {
      return toPlainObject(this);
    }
  }
  function getMetas(ctx) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let name = `<yellow>${((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.name) || ""}</yellow>`;
    if ((_b = ctx._settings.metas) === null || _b === void 0 ? void 0 : _b.id) {
      name += ` <cyan>${ctx._settings.metas.id}</cyan>`;
    }
    const metasObj = {
      id: (_d = (_c = ctx._settings.metas) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0 ? _d : ctx.constructor.name,
      name: (_f = (_e = ctx._settings.metas) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : ctx.constructor.name,
      formattedName: name,
      color: (_h = (_g = ctx._settings.metas) === null || _g === void 0 ? void 0 : _g.color) !== null && _h !== void 0 ? _h : "yellow"
    };
    return metasObj;
  }
  function generateInterfacesStack(ctx) {
    const extendsStack = fn$7(ctx, {
      includeBaseClass: true
    });
    Object.keys(extendsStack).forEach((className) => {
      const cls = extendsStack[className];
      if (cls.interfaces) {
        ctx._interfacesStack[className] = cls.interfaces;
      }
    });
  }
  function expose(ctx, instance, settings) {
    settings = __deepMerge$8({
      as: void 0,
      props: []
    }, settings);
    if (settings.as && typeof settings.as === "string") {
      ctx[settings.as] = instance;
    }
    if (settings.props) {
      settings.props.forEach((prop) => {
        if (instance[prop].bind && typeof instance[prop].bind === "function") {
          ctx[prop] = instance[prop].bind(instance);
        } else {
          ctx[prop] = instance[prop];
        }
      });
    }
  }
  function getInterfaceObj(ctx, name) {
    let interfaceObj = get$3(ctx._interfacesStack, name);
    if (!interfaceObj) {
      const keys = Object.keys(ctx._interfacesStack);
      for (let i = 0; i < keys.length; i++) {
        const interfacesObj = ctx._interfacesStack[keys[i]];
        if (interfacesObj[name] !== void 0) {
          if (plainObject$8(interfacesObj[name])) {
            interfaceObj = interfacesObj[name];
          } else {
            interfaceObj = {
              apply: true,
              on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0,
              class: interfacesObj[name]
            };
          }
          break;
        }
      }
    }
    if (name === "settings" && interfaceObj.on === void 0) {
      if (ctx.settings !== void 0)
        interfaceObj.on = "settings";
      else if (ctx._settings !== void 0)
        interfaceObj.on = "_settings";
    }
    return interfaceObj;
  }
  function toPlainObject(ctx) {
    return toJson(ctx);
  }
  function getInterface(ctx, name) {
    const interfaceObj = getInterfaceObj(ctx, name);
    if (plainObject$8(interfaceObj))
      return interfaceObj.class;
    return interfaceObj;
  }
  function applyInterfaces(ctx) {
    const keys = Object.keys(ctx._interfacesStack);
    for (let i = keys.length - 1; i >= 0; i--) {
      const interfacesObj = ctx._interfacesStack[keys[i]];
      const className = keys[i];
      Object.keys(interfacesObj).forEach((name) => {
        const interfaceObj = interfacesObj[name];
        let settings;
        if (plainObject$8(interfaceObj)) {
          settings = Object.assign({}, Object.assign({apply: true, on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0}, interfaceObj));
        } else {
          settings = Object.assign({}, {
            apply: true,
            on: name === "settings" ? "_settings" : name === "this" ? ctx : void 0,
            class: interfaceObj
          });
        }
        if (settings.apply !== true)
          return;
        if (settings.on) {
          if (typeof settings.on === "string" && get$3(ctx, settings.on) !== void 0) {
            applyInterface(ctx, `${className}.${name}`, settings.on);
          } else if (typeof settings.on === "object") {
            applyInterface(ctx, `${className}.${name}`, settings.on);
          } else if (ctx[name] !== void 0) {
            applyInterface(ctx, `${className}.${name}`);
          }
        }
      });
    }
  }
  function applyInterface(ctx, name, on = null) {
    const interfaceObj = getInterfaceObj(ctx, `${name}`);
    if (!interfaceObj) {
      throw new Error(`You try to apply the interface named "<yellow>${name}</yellow>" on the context "<cyan>${ctx.name}</cyan>" but it does not exists...`);
    }
    if (on !== void 0)
      interfaceObj.on = on;
    if (!interfaceObj) {
      throw `Sorry the the asked interface "<yellow>${name}</yellow>" does not exists on the class "<cyan>${ctx.constructor.name}</cyan>"`;
    }
    if (name.includes(".")) {
      name = name.split(".").slice(1).join(".");
    }
    if (plainObject$8(interfaceObj)) {
      let onValue;
      if (interfaceObj.on && typeof interfaceObj.on === "string") {
        onValue = get$3(ctx, interfaceObj.on);
      } else if (interfaceObj.on && typeof interfaceObj.on === "object") {
        onValue = interfaceObj.on;
      } else {
        onValue = get$3(ctx, name);
      }
      let applyId = ctx.constructor.name;
      if (ctx.id)
        applyId += `(${ctx.id})`;
      if (name)
        applyId += `.${name}`;
      if (interfaceObj.on && interfaceObj.on.constructor)
        applyId += `.${interfaceObj.on.constructor.name}`;
      if (interfaceObj.on && interfaceObj.on.id)
        applyId += `(${interfaceObj.on.id})`;
      let res;
      if (name === "this") {
        res = interfaceObj.class.apply(onValue || {}, {
          id: applyId,
          throw: true
        });
        deepAssign(ctx, res.value);
        return ctx;
      } else {
        res = interfaceObj.class.apply(onValue, {
          id: applyId,
          throw: true
        });
        if (interfaceObj.on && typeof interfaceObj.on === "object") {
          const returnValue = deepAssign(interfaceObj.on, res);
          return returnValue;
        } else if (interfaceObj.on && typeof interfaceObj.on === "string") {
          return deepAssign(get$3(ctx, interfaceObj.on), res);
        } else if (ctx[name] !== void 0) {
          return ctx[name];
        } else {
          return res;
        }
      }
    }
  }
  function setSettings(ctx, settings = {}) {
    var _a;
    ctx._settings = settings;
    if (!ctx._settings.metas)
      ctx._settings.metas = {};
    if (!((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.id))
      ctx._settings.metas.id = ctx.constructor.name;
    if (!ctx.constructor.name.match(/^SConfig/)) {
      if (!ctx._settings.metas.color)
        ctx._settings.metas.color = getColorFor(ctx.constructor.name, {
          scope: "class"
        });
    } else if (!ctx._settings.metas.color)
      ctx._settings.metas.color = "yellow";
  }
  function isInteger(data) {
    return typeof data === "number" && !isNaN(data) && function(x) {
      return (x | 0) === x;
    }(parseFloat(data));
  }
  function upperFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  function typeOf(value, settings = {}) {
    settings = __deepMerge$8({
      of: false,
      customClass: true
    }, settings);
    let type;
    if (Array.isArray(value))
      type = "Array";
    else if (value instanceof Map)
      type = "Map";
    else if (value === null)
      type = "Null";
    else if (value === void 0)
      type = "Undefined";
    else if (typeof value === "string")
      type = "String";
    else if (isInteger(value))
      type = "Integer";
    else if (typeof value === "number")
      type = "Number";
    else if (typeof value === "boolean")
      type = "Boolean";
    else if (value instanceof RegExp)
      type = "RegExp";
    else if (settings.customClass === true && cls(value) && value.name !== void 0) {
      type = upperFirst(value.name);
    } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
      type = upperFirst(value.constructor.name);
    } else if (settings.customClass === false && cls(value)) {
      type = "Class";
    } else if (typeof value === "function")
      type = "Function";
    else if (typeof value === "object")
      type = "Object";
    else
      type = "Unknown";
    const avoidTypes = [
      "Null",
      "Undefined",
      "String",
      "Integer",
      "Number",
      "Boolean",
      "Unknown"
    ];
    if (settings.of === true && !avoidTypes.includes(type)) {
      const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
      const receivedTypes = [];
      loopOn.forEach((valueIndex) => {
        const valueToCheck = value[valueIndex];
        const childType = typeOf(valueToCheck, {
          of: false,
          customClass: settings.customClass
        });
        if (!receivedTypes.includes(childType)) {
          receivedTypes.push(childType);
        }
      });
      type += `<${receivedTypes.join("|")}>`;
    }
    return type;
  }
  const fn$5 = function(stack, callback, settings = {}) {
    settings = Object.assign({newStack: false}, settings);
    const stackType = typeOf(stack).toLowerCase();
    let loopOnKeys;
    if (stackType === "object")
      loopOnKeys = Object.keys(stack);
    else if (stackType === "array")
      loopOnKeys = Array.from(Array(stack.length).keys());
    else if (stackType === "number" || stackType === "integer")
      loopOnKeys = Array.from(Array(Math.round(stack)).keys());
    else if (stackType === "string")
      loopOnKeys = Array.from(stack);
    else if (stackType === "set")
      loopOnKeys = Array.from(stack);
    else
      loopOnKeys = Array.from(stack.keys());
    if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
      settings.newStack = true;
    let newStack = [];
    if (stackType === "object")
      newStack = {};
    else if (stackType === "map")
      newStack = new Map();
    else if (stackType === "set")
      newStack = new Set();
    let value;
    let newValue;
    const _get = (s, k) => {
      switch (typeOf(s).toLowerCase()) {
        case "array":
        case "object":
          return s[k];
        case "string":
          return k;
        case "number":
        case "integer":
          return k;
        case "map":
          return s.get(k);
        case "set":
          return k;
      }
    };
    const _set = (s, k, v) => {
      switch (typeOf(s).toLowerCase()) {
        case "array":
          if (settings.newStack === true)
            s.push(v);
          else
            s[k] = v;
          break;
        case "object":
          s[k] = v;
          break;
        case "number":
        case "integer":
        case "string":
          s.push(v);
          break;
        case "map":
          s.set(k, v);
          break;
        case "set":
          s.add(v);
          break;
      }
    };
    for (let i = 0; i < loopOnKeys.length; i++) {
      const key = loopOnKeys[i];
      value = _get(stack, key);
      newValue = callback({key, prop: key, value, i, idx: i});
      if (newValue === -1)
        break;
      _set(settings.newStack ? newStack : stack, key, newValue);
    }
    if (stackType === "string") {
      return newStack.join("");
    }
    return settings.newStack ? newStack : stack;
  };
  source$5.level = 3;
  const tagsMap = {
    black: (tag, content) => source$5.black(content),
    red: (tag, content) => source$5.red(content),
    green: (tag, content) => source$5.green(content),
    yellow: (tag, content) => source$5.yellow(content),
    blue: (tag, content) => source$5.blue(content),
    magenta: (tag, content) => source$5.magenta(content),
    cyan: (tag, content) => source$5.cyan(content),
    white: (tag, content) => source$5.white(content),
    grey: (tag, content) => source$5.grey(content),
    bgBlack: (tag, content) => source$5.bgBlack(content),
    bgRed: (tag, content) => source$5.bgRed(content),
    bgGreen: (tag, content) => source$5.bgGreen(content),
    bgYellow: (tag, content) => source$5.bgYellow(content),
    bgBlue: (tag, content) => source$5.bgBlue(content),
    bgMagenta: (tag, content) => source$5.bgMagenta(content),
    bgCyan: (tag, content) => source$5.bgCyan(content),
    bgWhite: (tag, content) => source$5.bgWhite(content),
    bold: (tag, content) => source$5.bold(content),
    dim: (tag, content) => source$5.dim(content),
    italic: (tag, content) => source$5.italic(content),
    underline: (tag, content) => source$5.underline(content),
    strike: (tag, content) => source$5.strike(content),
    h1: (tag, content) => {
      return source$5.underline(source$5.bold(content)) + "\n\n";
    },
    h2: (tag, content) => {
      return source$5.bold(content) + "\n";
    },
    date: (tag, content) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2),
    time: (tag, content) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2),
    day: (tag, content) => new Date().getDate().toString().padStart("0", 2),
    days: (tag, content) => new Date().getDate().toString().padStart("0", 2),
    month: (tag, content) => new Date().getMonth().toString().padStart("0", 2),
    months: (tag, content) => new Date().getMonth().toString().padStart("0", 2),
    year: (tag, content) => new Date().getFullYear().toString().padStart("0", 2),
    years: (tag, content) => new Date().getFullYear().toString().padStart("0", 2),
    hour: (tag, content) => new Date().getHours().toString().padStart("0", 2),
    hours: (tag, content) => new Date().getHours().toString().padStart("0", 2),
    minute: (tag, content) => new Date().getMinutes().toString().padStart("0", 2),
    minutes: (tag, content) => new Date().getMinutes().toString().padStart("0", 2),
    second: (tag, content) => new Date().getSeconds().toString().padStart("0", 2),
    seconds: (tag, content) => new Date().getSeconds().toString().padStart("0", 2),
    br: (tag, content) => "\n"
  };
  function replaceTags(text, tags) {
    if (!text)
      text = "";
    text = fn$6(text);
    let oneLineText = text.replace(/\r\n/g, "|rn|");
    oneLineText = oneLineText.replace(/\n/g, "|n|");
    oneLineText = oneLineText.replace(/\r/g, "|r|");
    Object.keys(tags).forEach((tagName) => {
      const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
      const tagsArray = oneLineText.match(reg);
      const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
      const singleTagsArray = oneLineText.match(singleReg);
      if (tagsArray) {
        for (let i = 0; i < tagsArray.length; i++) {
          const t = tagsArray[i];
          const tagArgs = t.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = tagArgs[1];
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
      if (singleTagsArray) {
        for (let i = 0; i < singleTagsArray.length; i++) {
          const t = singleTagsArray[i];
          const tagArgs = t.match(`\\s?<${tagName}\\s?/>\\s?`);
          if (!tagArgs)
            continue;
          const tagToReplace = tagArgs[0];
          const tagContent = "";
          oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
        }
      }
    });
    oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
    oneLineText = oneLineText.replace(/\|n\|/g, "\n");
    oneLineText = oneLineText.replace(/\|r\|/g, "\r");
    return oneLineText;
  }
  function parseHtml(message) {
    let isArray = false;
    if (Array.isArray(message)) {
      isArray = true;
    } else {
      message = [message];
    }
    message = message.map((m) => {
      return replaceTags(m, tagsMap);
    });
    if (isArray)
      return message;
    return message[0];
  }
  function parseSingleTypeString(typeString) {
    let ofStr = "", typeStr = typeString;
    const ofPartsString = typeString.match(/<(.+)>$/gm);
    if (ofPartsString && ofPartsString.length) {
      ofStr = ofPartsString[0].replace("<", "").replace(">", "");
    }
    if (ofStr !== "") {
      typeStr = typeStr.replace(`<${ofStr}>`, "");
    }
    let ofTypes = ofStr !== "" ? [ofStr.toLowerCase()] : void 0;
    if (ofStr !== void 0 && ofStr.includes("|")) {
      ofTypes = ofStr.split("|").map((t) => t.trim().toLowerCase());
    }
    return {
      type: typeStr,
      of: ofTypes
    };
  }
  const fn$4 = function parseTypeString(typeString) {
    typeString = typeString.toLowerCase().trim();
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
      return part;
    }).join("|");
    typeString = typeString.split("|").map((part) => {
      part = part.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, "object<$1>");
      return part;
    }).join("|");
    let types = [], inGroup = false, currentStr = "";
    for (let i = 0; i < typeString.length; i++) {
      const char = typeString[i];
      if (char === "<") {
        inGroup = true;
        currentStr += char;
      } else if (char === ">") {
        inGroup = false;
        currentStr += char;
      } else if (char === "|") {
        if (inGroup === false) {
          types.push(currentStr);
          currentStr = "";
        } else {
          currentStr += char;
        }
      } else {
        currentStr += char;
      }
    }
    types.push(currentStr);
    const finalTypes = [];
    types.forEach((type) => {
      finalTypes.push(parseSingleTypeString(type));
    });
    const res = {
      raw: typeString,
      types: finalTypes
    };
    return res;
  };
  var __isNode$1 = () => {
    return typeof process !== "undefined" && process.release && process.release.name === "node";
  };
  class STypeResult {
    constructor(data) {
      this._data = data;
    }
    get typeString() {
      return this._data.typeString;
    }
    get value() {
      return this._data.value;
    }
    get received() {
      return this._data.received;
    }
    get expected() {
      return this._data.expected;
    }
    get issues() {
      return this._data.issues;
    }
    get settings() {
      return this._data.settings;
    }
    hasIssues() {
      if (this._data)
        return true;
      return false;
    }
    toString() {
      if (__isNode$1()) {
        return this.toConsole();
      } else {
        return `The method "toHtml" has not being integrated for now...`;
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
        "",
        "<underline>Received value</underline>",
        "",
        `${fn$6(this._data.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._data.issues).forEach((ruleId) => {
        const issueObj = this._data.issues[ruleId];
        const message = [];
        if (issueObj.expected.type) {
          message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
        }
        if (issueObj.received.type) {
          message.push(`- Received "<red>${issueObj.received.type}</red>"`);
        }
        if (issueObj.message) {
          message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
        }
        issuesArray.push(message.join("\n"));
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._data.settings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
    }
  }
  class SType {
    constructor(typeString, settings = {}) {
      this.typeString = typeString;
      typeString = typeString.toLowerCase().trim();
      if (this.constructor._instanciatedTypes[typeString] !== void 0)
        return this.constructor._instanciatedTypes[typeString];
      this.types = fn$4(typeString).types;
      this._settings = __deepMerge$8({
        id: this.constructor.name,
        name: this.constructor.name,
        customTypes: true,
        interfaces: true
      }, settings);
      this.constructor._instanciatedTypes[typeString] = this;
    }
    static registerType(type) {
      if (type.id === void 0 || typeof type.id !== "string") {
        throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
      }
      this._registeredTypes[type.id] = type;
    }
    is(value, settings = {}) {
      const res = this.check(value, settings);
      if (res === true)
        return true;
      else if (res instanceof STypeResult)
        return !res.hasIssues();
      return true;
    }
    check(value, settings = {}) {
      settings = __deepMerge$8(this._settings, settings);
      const issues = {};
      for (let i = 0; i < this.types.length; i++) {
        const typeObj = this.types[i], typeId = typeObj.type;
        const res2 = this._isType(value, typeId, settings);
        if (res2 === true) {
          if (typeObj.of === void 0)
            return true;
          const typeOf$1 = typeOf(value);
          if (typeOf$1 !== "Array" && typeOf$1 !== "Object" && typeOf$1 !== "Map") {
            throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf$1}</cyan>" that does not support "child" value(s)...`);
          }
          const loopOn = typeOf$1 === "Object" ? Object.keys(value) : Array.from(value.keys());
          if (!loopOn.length)
            return true;
          for (let k = 0; k < loopOn.length; k++) {
            for (let j2 = 0; j2 < typeObj.of.length; j2++) {
              const type = typeObj.of[j2];
              const idx = loopOn[k];
              const v = typeOf$1 === "Map" ? value.get(idx) : value[idx];
              const ofRes = this._isType(v, type, settings);
              if (ofRes !== true) {
                issues[typeObj.type] = {
                  expected: {
                    type: typeObj.type
                  },
                  received: {
                    type: typeOf(v),
                    value: v
                  }
                };
              } else {
                return true;
              }
            }
          }
        } else {
          const issueObj = {
            expected: {
              type: typeObj.type
            },
            received: {
              type: typeOf(value),
              value
            }
          };
          if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
            issueObj.message = res2.toString();
          }
          issues[typeObj.type] = issueObj;
        }
      }
      const res = new STypeResult({
        typeString: this.typeString,
        value,
        expected: {
          type: this.typeString
        },
        received: {
          type: typeOf(value)
        },
        issues,
        settings
      });
      return res;
    }
    _isType(value, type, settings = {}) {
      settings = __deepMerge$8(this._settings, settings);
      if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
        if (settings.interfaces === true) {
          const availableInterfaceTypes = SInterface.getAvailableTypes();
          if (availableInterfaceTypes[type] !== void 0) {
            const res = availableInterfaceTypes[type].apply(value, {});
            return res;
          }
        }
        if (settings.customTypes === true) {
          const typeOf$1 = typeOf(value).toLowerCase();
          const extendsStack = Object.keys(fn$7(value)).map((s) => s.toLowerCase());
          if (type === typeOf$1 || extendsStack.indexOf(type) !== -1)
            return true;
        }
        throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
      }
      return this.constructor._registeredTypes[type.toLowerCase()].is(value);
    }
    cast(value, params, settings) {
      settings = __deepMerge$8(this._settings, settings);
      const verboseObj = {
        value,
        issues: {},
        settings,
        toString() {
          const strAr = Object.entries(this.issues);
          return strAr.map((l) => l[1]).join("\n");
        }
      };
      if (this.is(value)) {
        return value;
      }
      for (let i = 0; i < this.types.length; i++) {
        const typeObj = this.types[i], typeId = typeObj.type;
        const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
        if (descriptorObj === void 0) {
          continue;
        }
        if (descriptorObj.cast === void 0)
          continue;
        let castedValue;
        castedValue = descriptorObj.cast(value, params);
        if (castedValue instanceof Error) {
          verboseObj.issues[typeId] = castedValue.toString();
          continue;
        }
        if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
          const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
          throw new Error(parseHtml(issueStr));
        } else if (typeObj.of !== void 0) {
          const sTypeInstance = new SType(typeObj.of.join("|"));
          castedValue = fn$5(castedValue, ({value: value2}) => {
            return sTypeInstance.cast(value2, params, settings);
          });
        }
        if (castedValue === null && descriptorObj.id === "null")
          return null;
        if (castedValue === void 0 && descriptorObj.id === "undefined")
          return void 0;
        if (castedValue !== null && castedValue !== void 0)
          return castedValue;
        verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
      }
      const stack = [
        `Sorry but the value of type "<cyan>${typeOf(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
      ];
      Object.keys(verboseObj.issues).forEach((descriptorId) => {
        stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
      });
      throw new Error(parseHtml(stack.join("\n")));
    }
    canHaveChilds(value) {
      const type = typeOf(value);
      return type === "Array" || type === "Object" || type === "Map";
    }
    get name() {
      return this._settings.name;
    }
    get id() {
      return this._settings.id;
    }
  }
  SType._instanciatedTypes = {};
  SType._registeredTypes = {};
  function isString$2(value) {
    return typeof value === "string" || value instanceof String;
  }
  const descriptor$g = {
    name: "String",
    id: "string",
    is: (value) => isString$2(value),
    cast: (value) => fn$6(value, {
      beautify: true
    })
  };
  const descriptor$f = {
    name: "Map",
    id: "map",
    is: (value) => isMap(value),
    cast: (value) => {
      if (isMap(value))
        return value;
      const map = new Map();
      map.set("value", value);
      return map;
    }
  };
  const descriptor$e = {
    name: "Object",
    id: "object",
    is: (value) => isObject$3(value),
    cast: (value) => {
      if (isObject$3(value))
        return value;
      return {
        value
      };
    }
  };
  const descriptor$d = {
    name: "Array",
    id: "array",
    is: (value) => {
      return Array.isArray(value);
    },
    cast: (value, params = {}) => {
      if (!value)
        return [];
      if (params.splitChars && Array.isArray(params.splitChars)) {
        value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l) => l.trim() !== "" && params.splitChars.indexOf(l) === -1);
      }
      if (Array.isArray(value))
        return value;
      return [value];
    }
  };
  const descriptor$c = {
    name: "Integer",
    id: "integer",
    is: (value) => Number.isInteger(value),
    cast: (value) => {
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
      }
      const res = parseInt(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
      return res;
    }
  };
  const descriptor$b = {
    name: "Number",
    id: "number",
    is: (value) => typeof value === "number",
    cast: (value) => {
      if (typeof value !== "string") {
        return new Error(`Sorry but only strings can be casted to numbers...`);
      }
      const res = parseFloat(value);
      if (isNaN(res))
        return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
      return res;
    }
  };
  const descriptor$a = {
    name: "Boolean",
    id: "boolean",
    is: (value) => typeof value === "boolean",
    cast: (value, params = {}) => {
      if (value !== false && params && params.nullishAsTrue && !value) {
        return true;
      }
      if (typeof value === "boolean")
        return value;
      if (value === null || value === void 0)
        return false;
      if (typeof value === "number") {
        if (value > 0)
          return true;
        return false;
      }
      if (typeof value === "string") {
        return value.length > 0 ? true : false;
      }
      if (Array.isArray(value)) {
        if (value.length > 0)
          return true;
        return false;
      }
      if (typeof value === "object") {
        return Object.keys(value).length > 0 ? true : false;
      }
      return new Error([
        `Sorry but for now only these types can be casted to boolean:`,
        "- <yellow>null</yellow>: Will be casted as <red>false</red>",
        "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
        "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
        "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
        "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
        "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
      ].join("\n"));
    }
  };
  const descriptor$9 = {
    name: "Undefined",
    id: "undefined",
    is: (value) => value === void 0,
    cast: (value) => {
      return void 0;
    }
  };
  const descriptor$8 = {
    name: "Null",
    id: "null",
    is: (value) => value === null,
    cast: (value) => {
      return null;
    }
  };
  const descriptor$7 = {
    name: "Symbol",
    id: "symbol",
    is: (value) => typeof value === "symbol",
    cast: (value) => {
      if (typeof value === "symbol")
        return value;
      return Symbol(value);
    }
  };
  const descriptor$6 = {
    name: "Bigint",
    id: "bigint",
    is: (value) => typeof value === "bigint",
    cast: (value) => {
      if (typeof value === "bigint")
        return value;
      if (typeof value !== "string" && typeof value !== "number") {
        return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
      }
      let res;
      try {
        res = BigInt(value);
      } catch (e) {
        res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
      }
      return res;
    }
  };
  const descriptor$5 = {
    name: "Date",
    id: "date",
    is: (value) => value instanceof Date,
    cast: (value) => {
      if (typeof value === "string") {
        return new Date(value);
      }
      if (typeof value === "number") {
        return new Date(Math.round(value));
      }
      if (plainObject$8(value)) {
        const now = new Date();
        let year = now.getFullYear(), month = 0, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
        if (value.year && typeof value.year === "number") {
          year = value.year;
        }
        if (value.month && typeof value.month === "number") {
          month = value.month;
        }
        if (value.day && typeof value.day === "number") {
          day = value.day;
        }
        if (value.hours && typeof value.hours === "number") {
          hours = value.hours;
        }
        if (value.minutes && typeof value.minutes === "number") {
          minutes = value.minutes;
        }
        if (value.seconds && typeof value.seconds === "number") {
          seconds = value.seconds;
        }
        if (value.milliseconds && typeof value.milliseconds === "number") {
          milliseconds = value.milliseconds;
        }
        return new Date(year, month, day, hours, minutes, seconds, milliseconds);
      }
      return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
    }
  };
  const descriptor$4 = {
    name: "Function",
    id: "function",
    is: (value) => typeof value === "function",
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Function`);
    }
  };
  const descriptor$3 = {
    name: "WeakMap",
    id: "weakmap",
    is: (value) => value instanceof WeakMap,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
    }
  };
  const descriptor$2 = {
    name: "WeakSet",
    id: "weakset",
    is: (value) => value instanceof WeakSet,
    cast: (value) => {
      return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
    }
  };
  const descriptor$1 = {
    name: "Set",
    id: "set",
    is: (value) => value instanceof Set,
    cast: (value) => {
      if (value instanceof Set)
        return value;
      const set = new Set();
      set.add(value);
      return set;
    }
  };
  const descriptor = {
    name: "Class",
    id: "class",
    is: (value) => cls(value),
    cast: (value) => {
      return new Error(`Sorry but nothing is castable to a Class`);
    }
  };
  SType.registerType(descriptor$g);
  SType.registerType(descriptor$f);
  SType.registerType(descriptor$e);
  SType.registerType(descriptor$d);
  SType.registerType(descriptor$c);
  SType.registerType(descriptor$b);
  SType.registerType(descriptor$a);
  SType.registerType(descriptor$9);
  SType.registerType(descriptor$8);
  SType.registerType(descriptor$7);
  SType.registerType(descriptor$6);
  SType.registerType(descriptor$5);
  SType.registerType(descriptor$4);
  SType.registerType(descriptor$3);
  SType.registerType(descriptor$2);
  SType.registerType(descriptor$1);
  SType.registerType(descriptor);
  function ofType(value, typeString, settings = {}) {
    settings = Object.assign({verbose: false}, settings);
    const typeInstance = new SType(typeString, settings);
    const res = typeInstance.is(value);
    return res;
  }
  class SDescriptorResult extends SClass {
    constructor(descriptor, value, descriptorSettings) {
      super({});
      this._issues = {};
      this._descriptor = descriptor;
      this._descriptorSettings = descriptorSettings;
      try {
        this._originalValue = clone$2(value, {deep: true});
      } catch (e) {
        this._originalValue = value;
      }
      this.value = value;
    }
    hasIssues() {
      return Object.keys(this._issues).length >= 1;
    }
    add(ruleResult) {
      if (!ruleResult.__ruleObj.id)
        return;
      this._issues[ruleResult.__ruleObj.id] = ruleResult;
    }
    toString() {
      if (__isNode$1()) {
        return this.toConsole();
      } else {
        return this.toConsole();
      }
    }
    toConsole() {
      const headerArray = [
        `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
        "",
        `${fn$6(this.value, {
          beautify: true
        })}`,
        ""
      ];
      const issuesArray = [];
      Object.keys(this._issues).forEach((ruleId) => {
        const ruleResult = this._issues[ruleId];
        let message = "";
        if (ruleResult.__error && ruleResult.__error instanceof Error) {
          message = ruleResult.__error.message;
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
          message = ruleResult.__ruleObj.message(ruleResult);
        } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
          message = ruleResult.__ruleObj.message;
        }
        issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
      });
      const settingsArray = [
        "",
        `<underline>Settings</underline>`,
        "",
        `${fn$6(this._descriptorSettings, {
          beautify: true
        })}`
      ];
      return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
    }
  }
  /*!
  * is-extglob <https://github.com/jonschlinkert/is-extglob>
  *
  * Copyright (c) 2014-2016, Jon Schlinkert.
  * Licensed under the MIT License.
  */
  var isExtglob$1 = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
  /*!
  * is-glob <https://github.com/jonschlinkert/is-glob>
  *
  * Copyright (c) 2014-2017, Jon Schlinkert.
  * Released under the MIT License.
  */
  var isExtglob = isExtglob$1;
  var chars = {"{": "}", "(": ")", "[": "]"};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
  var isGlob = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var regex = strictRegex;
    var match;
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      var idx = match.index + match[0].length;
      var open = match[1];
      var close = open ? chars[open] : null;
      if (open && close) {
        var n = str.indexOf(close, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  };
  var __isGlob = (string) => {
    return isGlob(string);
  };
  class SDescriptor extends SClass {
    constructor(settings) {
      super(__deepMerge$8({
        descriptor: {
          rules: {},
          type: "Object",
          arrayAsValue: false,
          throwOnMissingRule: false,
          defaults: true
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
    }
    static registerRule(rule) {
      if (rule.id === void 0 || typeof rule.id !== "string") {
        throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
      }
      this._registeredRules[rule.id] = rule;
    }
    get descriptorSettings() {
      return this._settings.descriptor;
    }
    apply(value, settings) {
      const set = __deepMerge$8(this.descriptorSettings, settings || {});
      if (value === void 0 || value === null)
        value = {};
      const valuesObjToProcess = {}, finalValuesObj = {};
      this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set));
      const rules = set.rules;
      if (!ofType(value, set.type)) {
        throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${typeOf(value)}</cyan>" but only "<green>${set.type}</green>"...`);
      }
      if (Array.isArray(value) && !set.arrayAsValue) {
        throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
      } else if (typeof value === "object" && value !== null && value !== void 0) {
        Object.keys(rules).forEach((propName) => {
          if (__isGlob(propName) && value)
            ;
          else {
            valuesObjToProcess[propName] = get$3(value, propName);
          }
        });
        Object.keys(valuesObjToProcess).forEach((propName) => {
          const ruleObj = rules[propName];
          if (valuesObjToProcess[propName] === void 0 && set.defaults && ruleObj.default !== void 0) {
            valuesObjToProcess[propName] = ruleObj.default;
          }
          if (ruleObj.interface !== void 0) {
            const interfaceValue = valuesObjToProcess[propName];
            valuesObjToProcess[propName] = ruleObj.interface.apply(interfaceValue || {}, {});
          }
          const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj, set);
          if (validationResult !== void 0 && validationResult !== null) {
            __set(finalValuesObj, propName, validationResult);
          }
        });
      } else {
        console.warn(value);
        throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
      }
      if (this._descriptorResult.hasIssues()) {
        throw new Error(this._descriptorResult.toString());
      }
      return this._descriptorResult;
    }
    _validate(value, propName, rulesObj, settings) {
      if (rulesObj === void 0)
        return value;
      if (rulesObj.required === void 0 || rulesObj.required === false) {
        if (value === void 0 || value === null)
          return value;
      }
      let rulesNamesInOrder = Object.keys(rulesObj).filter((l) => l !== "default");
      rulesNamesInOrder = rulesNamesInOrder.sort((a, b) => {
        const objA = this.constructor._registeredRules[a];
        const objB = this.constructor._registeredRules[b];
        if (!objA)
          return -1;
        if (!objB)
          return 1;
        if (objA.priority === void 0)
          objA.priority = 9999999999;
        if (objB.priority === void 0)
          objB.priority = 9999999999;
        return objA.priotity - objB.priority;
      }).reverse();
      let resultValue = value;
      rulesNamesInOrder.forEach((ruleName) => {
        const ruleValue = rulesObj[ruleName];
        if (this.constructor._registeredRules[ruleName] === void 0) {
          if (settings.throwOnMissingRule) {
            throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
          }
        } else {
          const ruleObj = this.constructor._registeredRules[ruleName];
          const params = ruleObj.processParams !== void 0 ? ruleObj.processParams(ruleValue) : ruleValue;
          const ruleSettings = ruleObj.settings !== void 0 ? ruleObj.settings : {};
          if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
            let newResultValue = [];
            resultValue.forEach((v) => {
              const processedValue = this._processRule(v, ruleObj, propName, params, ruleSettings, settings);
              if (Array.isArray(processedValue)) {
                newResultValue = [
                  ...newResultValue,
                  ...processedValue
                ];
              } else {
                newResultValue.push(processedValue);
              }
            });
            resultValue = newResultValue;
          } else {
            const processedValue = this._processRule(resultValue, ruleObj, propName, params, ruleSettings, settings);
            resultValue = processedValue;
          }
        }
      });
      return resultValue;
    }
    _processRule(value, ruleObj, propName, params, ruleSettings, settings) {
      const ruleResult = ruleObj.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), {propName, name: `${settings.name}.${propName}`}));
      if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
        return true;
      }
      if (ruleResult instanceof Error) {
        const obj = {
          __error: ruleResult,
          __ruleObj: ruleObj,
          __propName: propName
        };
        if (this._descriptorResult) {
          this._descriptorResult.add(obj);
          throw new Error(this._descriptorResult.toString());
        }
      } else {
        return ruleResult;
      }
    }
  }
  SDescriptor._registeredRules = {};
  SDescriptor.rules = {};
  SDescriptor.type = "Object";
  const ruleObj$3 = {
    priority: 1,
    name: "Required",
    id: "required",
    settings: {
      when: [void 0, null]
    },
    message: "This value is required",
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (params.value === true) {
        if (ruleSettings.when.indexOf(value) !== -1) {
          return new Error("This property is <yellow>required</yellow>");
        }
      }
      return value;
    }
  };
  const ruleObj$2 = {
    prority: 10,
    name: "Type",
    id: "type",
    settings: {},
    processParams: (params) => {
      var _a, _b;
      if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
        throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
      }
      return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), {type: (_a = params.type) !== null && _a !== void 0 ? _a : params, cast: (_b = params.cast) !== null && _b !== void 0 ? _b : true});
    },
    apply: (value, params, ruleSettings, settings) => {
      const type = new SType(params.type, {
        metas: {
          id: settings.id
        }
      });
      if (params.cast && !type.is(value)) {
        value = type.cast(value, params);
      }
      if (!type.is(value)) {
        return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
      }
      return value;
    }
  };
  const ruleObj$1 = {
    name: "Min",
    id: "min",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value < params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  const ruleObj = {
    name: "Max",
    id: "max",
    settings: {},
    accept: "Number",
    message: (resultObj) => {
      return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
    },
    processParams: (params) => {
      return {value: params};
    },
    apply: (value, params, ruleSettings, settings) => {
      if (value > params.value) {
        return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
      }
      return value;
    }
  };
  SDescriptor.registerRule(ruleObj$3);
  SDescriptor.registerRule(ruleObj$2);
  SDescriptor.registerRule(ruleObj$1);
  SDescriptor.registerRule(ruleObj);
  function parseArgs(string, settings = {}) {
    settings = __deepMerge$8({
      throw: true,
      defaultObj: {},
      cast: true,
      valueQuote: void 0
    }, settings);
    string = string.trim();
    string = string.replace(/(["'`])--/gm, "$1--\xA7 --");
    let valueQuote = settings.valueQuote;
    if (!valueQuote) {
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        if (char === '"' || char === "`" || char === "'") {
          valueQuote = char;
          break;
        }
      }
      if (!valueQuote)
        valueQuote = '"';
    }
    let stringArray = [];
    let isFunctionStyle = false;
    if (string.match(/^\(/) && string.match(/\)$/)) {
      isFunctionStyle = true;
      string = string.slice(1, -1);
      let currentStr = "";
      let parenthesisCount = 0;
      let quotesCount = 0;
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        const previousChar = string[i - 1] || string[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount++;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount--;
        }
        if (!quotesCount && char === "(") {
          parenthesisCount++;
        } else if (!quotesCount && char === ")") {
          parenthesisCount--;
        }
        if (char === ",") {
          if (quotesCount || parenthesisCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      if (parenthesisCount)
        currentStr += ")".repeat(parenthesisCount);
      stringArray.push(currentStr.trim());
    } else {
      let currentStr = "";
      let quotesCount = false;
      for (let i = 0; i < string.length; i++) {
        const char = string[i];
        const previousChar = string[i - 1] || string[0];
        if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
          quotesCount = true;
        } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
          quotesCount = false;
        }
        if (char === " ") {
          if (quotesCount) {
            currentStr += char;
          } else {
            stringArray.push(currentStr.trim());
            currentStr = "";
          }
        } else {
          currentStr += char;
        }
      }
      stringArray.push(currentStr.trim());
    }
    stringArray = stringArray.map((item) => unquote(item));
    const argsObj = {};
    let currentArgName = void 0;
    let currentValue;
    stringArray = stringArray.forEach((part, i) => {
      if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
        if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
        currentArgName = part.replace(/^[-]{1,2}/, "");
        if (argsObj[currentArgName] === void 0) {
          argsObj[currentArgName] = true;
        }
      } else {
        let value;
        if (part && typeof part === "string") {
          value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
          if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
            const parts = part.split(":");
            currentArgName = parts[0].trim().replace(/^\$/, "");
            value = parts.slice(1).join(":").trim();
          }
        }
        currentValue = __parse(value);
        if (typeof currentValue === "string") {
          currentValue = currentValue.replace("--\xA7 ", "");
        }
        if (currentArgName !== void 0) {
          if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
            if (!Array.isArray(argsObj[currentArgName])) {
              argsObj[currentArgName] = [argsObj[currentArgName]];
            }
            argsObj[currentArgName].push(currentValue);
          } else {
            argsObj[currentArgName] = currentValue;
          }
          currentValue = void 0;
          currentArgName = void 0;
        } else {
          argsObj[i] = currentValue;
        }
      }
    });
    Object.keys(argsObj).forEach((key) => {
      const value = argsObj[key];
      if (value === void 0)
        delete argsObj[key];
    });
    return argsObj;
  }
  function getAvailableInterfaceTypes() {
    if (global !== void 0)
      return global._registeredInterfacesTypes || {};
    else if (window !== void 0)
      return window._registeredInterfacesTypes || {};
    else
      return {};
  }
  if (__isNode$1())
    global._registeredInterfacesTypes = {};
  else
    window._registeredInterfacesTypes = {};
  class SInterface extends SClass {
    constructor(settings) {
      super(__deepMerge$8({
        interface: {
          stripUnkown: false
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._definition = {};
      this._definition = this.constructor.definition;
    }
    static get definition() {
      if (this._cachedDefinition)
        return this._cachedDefinition;
      this._cachedDefinition = this._definition;
      return this._cachedDefinition;
    }
    static set definition(value) {
      this._cachedDefinition = value;
    }
    get interfaceSettings() {
      return this._settings.interface;
    }
    static registerRenderer(rendererClass) {
      if (!rendererClass.id) {
        throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
      }
      this._registeredRenderers[rendererClass.id] = rendererClass;
    }
    static override(definition) {
      const _this = this;
      class SInterfaceOverrided extends this {
      }
      SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
      SInterfaceOverrided.definition = __deepMerge$8(_this.definition, definition);
      return SInterfaceOverrided;
    }
    static getAvailableTypes() {
      return getAvailableInterfaceTypes();
    }
    static makeAvailableAsType(name = null) {
      const n = (name || this.name).toLowerCase();
      if (global !== void 0) {
        global._registeredInterfacesTypes[n] = this;
        global._registeredInterfacesTypes[n.replace("interface", "")] = this;
      } else if (window !== void 0) {
        window._registeredInterfacesTypes[n] = this;
        window._registeredInterfacesTypes[n.replace("interface", "")] = this;
      }
    }
    static toObject() {
      var _a;
      return {
        name: this.name,
        description: (_a = this.description) !== null && _a !== void 0 ? _a : "",
        definition: Object.assign({}, this.definition)
      };
    }
    static defaults() {
      const defaults = {};
      Object.keys(this.definition).forEach((key) => {
        const propObj = this.definition[key];
        if (propObj.default !== void 0) {
          defaults[key] = propObj.default;
        }
      });
      return defaults;
    }
    static apply(objectOrString, settings) {
      const int = new this({
        interface: settings !== null && settings !== void 0 ? settings : {}
      });
      return int.apply(objectOrString);
    }
    static render(renderer = "terminal", settings) {
      const set = __deepMerge$8({
        renderer: "terminal",
        exclude: ["help"]
      }, settings);
      if (!this._registeredRenderers[renderer]) {
        throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
      }
      const rendererInstance = new this._registeredRenderers[renderer](this, set);
      return rendererInstance.render();
    }
    apply(objectOrString, settings) {
      var _a;
      const set = __deepMerge$8(this.interfaceSettings, settings !== null && settings !== void 0 ? settings : {});
      let objectOnWhichToApplyInterface = objectOrString;
      if (typeof objectOrString === "string") {
        objectOnWhichToApplyInterface = parseArgs(objectOrString);
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i = 0; i < Object.keys(this._definition).length; i++) {
            const defArgName = Object.keys(this._definition)[i];
            const obj = this._definition[defArgName];
            if (obj.explicit) {
              if (obj.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj.alias}\\s`)))
                return;
              else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`)))
                return;
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
          for (let i = 0; i < Object.keys(this._definition).length; i++) {
            const defArgName = Object.keys(this._definition)[i];
            const obj = this._definition[defArgName];
            if (!obj.alias)
              continue;
            if (obj.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
              objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
              delete objectOnWhichToApplyInterface[argName];
            }
          }
        });
        Object.keys(objectOnWhichToApplyInterface).forEach((argName, i) => {
          if (argName === `${i}`) {
            const definitionKeys = Object.keys(this._definition);
            if (definitionKeys[i]) {
              objectOnWhichToApplyInterface[definitionKeys[i]] = objectOnWhichToApplyInterface[argName];
            }
            delete objectOnWhichToApplyInterface[argName];
          }
        });
      }
      const descriptor = new SDescriptor({
        descriptor: Object.assign({type: "Object", rules: this._definition}, (_a = set.descriptor) !== null && _a !== void 0 ? _a : {})
      });
      if (set.baseObj) {
        objectOnWhichToApplyInterface = __deepMerge$8(set.baseObj, objectOnWhichToApplyInterface);
      }
      const descriptorResult = descriptor.apply(objectOnWhichToApplyInterface);
      if (descriptorResult.hasIssues()) {
        throw new Error(descriptorResult.toString());
      }
      let resultObj = descriptorResult.value;
      if (!set.stripUnkown) {
        resultObj = __deepMerge$8(objectOnWhichToApplyInterface, resultObj);
      }
      return resultObj;
    }
  }
  SInterface.description = "";
  SInterface._registeredRenderers = {};
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i$4 = 0; i$4 < 256; ++i$4) {
    byteToHex.push((i$4 + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify(rnds);
  }
  function uniqid() {
    return v4();
  }
  var __awaiter$f = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const _links = {}, _stylesheets = {};
  function adoptStyleInShadowRoot($shadowRoot, $context = document) {
    return __awaiter$f(this, void 0, void 0, function* () {
      const _styleNodes = [];
      const $links = $context.querySelectorAll('link[rel="stylesheet"]');
      if ($links && $shadowRoot) {
        Array.from($links).forEach(($link) => __awaiter$f(this, void 0, void 0, function* () {
          if (!$link.id)
            $link.id = `link-${uniqid()}`;
          const stylesheetId = $link.id;
          if (_links[stylesheetId]) {
            $shadowRoot.adoptedStyleSheets = [
              ...$shadowRoot.adoptedStyleSheets,
              _links[stylesheetId].stylesheet
            ];
            return;
          }
          $shadowRoot === null || $shadowRoot === void 0 ? void 0 : $shadowRoot.appendChild($link.cloneNode());
          if (_styleNodes.indexOf($link) !== -1)
            return;
          _styleNodes.push($link);
          const res = yield fetch($link.href, {
            headers: {
              Accept: "text/css,*/*;q=0.1"
            }
          });
          let cssStr = yield res.text();
          const stylesheet = new CSSStyleSheet();
          stylesheet.replace(cssStr);
          _links[stylesheetId] = {
            stylesheet
          };
        }));
      }
      const $styles = $context.querySelectorAll("style");
      if ($styles && $shadowRoot) {
        Array.from($styles).forEach(($style) => {
          if (!$style.id)
            $style.id = `stylesheet-${uniqid()}`;
          const stylesheetId = $style.id;
          if (_stylesheets[stylesheetId]) {
            $shadowRoot.adoptedStyleSheets = [
              ...$shadowRoot.adoptedStyleSheets,
              _stylesheets[stylesheetId].stylesheet
            ];
            return;
          }
          if (_styleNodes.indexOf($style) !== -1)
            return;
          _styleNodes.push($style);
          const stylesheet = new CSSStyleSheet();
          stylesheet.replace($style.innerHTML);
          _stylesheets[stylesheetId] = {
            stylesheet
          };
          $shadowRoot.adoptedStyleSheets = [
            ...$shadowRoot.adoptedStyleSheets,
            _stylesheets[stylesheetId].stylesheet
          ];
        });
      }
      return true;
    });
  }
  function injectStyle(style, id = `injected-style-${uniqid()}`, node = document.head) {
    const $tag = document.createElement("style");
    $tag.type = "text/css";
    $tag.setAttribute("id", `injected-style-${id.toLowerCase()}`);
    $tag.innerHTML = style;
    node.appendChild($tag);
    return $tag;
  }
  var __awaiter$e = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function whenInViewport(elm, settings = {}) {
    settings = Object.assign({offset: 250}, settings);
    return new Promise((resolve) => __awaiter$e(this, void 0, void 0, function* () {
      const options = {
        root: null,
        rootMargin: `${settings.offset}px`,
        threshold: 1
      };
      function onChange(changes, observer2) {
        changes.forEach((change) => {
          if (change.intersectionRatio > 0) {
            observer2.disconnect();
            resolve(elm);
          }
        });
      }
      const observer = new IntersectionObserver(onChange, options);
      observer.observe(elm);
    }));
  }
  function camelize$1(text) {
    let res = "";
    const reg = /(?:^|[_-\s])(\w)/g;
    res = text.replace(reg, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
    res = res.substr(0, 1).toLowerCase() + res.slice(1);
    return res.trim();
  }
  function camelCase(text) {
    return camelize$1(text);
  }
  var __awaiter$d = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SComponentDefaultInterface extends SInterface {
    static get _definition() {
      return {
        id: {
          type: "String",
          physical: true
        },
        mounted: {
          type: "Boolean",
          default: false,
          physical: true
        },
        mountWhen: {
          type: "String",
          values: ["directly", "inViewport"],
          default: "directly"
        },
        adoptStyle: {
          type: "Boolean",
          default: true,
          physical: true
        },
        bare: {
          type: "Boolean",
          default: false,
          physical: true
        }
      };
    }
  }
  class SComponent extends SClass {
    constructor(node, props, settings = {}) {
      var _a, _b;
      var _c;
      super(__deepMerge$8({
        componentUtils: {}
      }, settings));
      this.state = "pending";
      this.node = node;
      this._props = props;
      let InterfaceToApply = (_c = class InlineSComponentUtilsInterface extends SInterface {
      }, _c.definition = {}, _c);
      InterfaceToApply.definition = Object.assign(Object.assign({}, Object.assign({}, SComponentDefaultInterface.definition)), (_b = (_a = this.componentUtilsSettings.interface) === null || _a === void 0 ? void 0 : _a.definition) !== null && _b !== void 0 ? _b : {});
      this.InterfaceToApply = InterfaceToApply;
      const styleStr = this.componentUtilsSettings.style;
      this.injectStyle(styleStr !== null && styleStr !== void 0 ? styleStr : "");
      this._whenMountedPromise = new Promise((resolveMounted) => __awaiter$d(this, void 0, void 0, function* () {
        this._whenMountPromise = new Promise((resolveMount) => __awaiter$d(this, void 0, void 0, function* () {
          switch (this.props.mountWhen) {
            case "inViewport":
              (() => __awaiter$d(this, void 0, void 0, function* () {
                yield whenInViewport(this.node);
              }))();
              break;
          }
          resolveMount(() => {
            this.state = "mounted";
            resolveMounted();
          });
        }));
      }));
    }
    get name() {
      var _a;
      return (_a = this.componentUtilsSettings.name) !== null && _a !== void 0 ? _a : this.node.tagName.toLowerCase();
    }
    static setDefaultProps(selector, props) {
      selector = Array.isArray(selector) ? selector : [selector];
      selector.forEach((sel) => {
        var _a;
        this._defaultProps[sel] = Object.assign(Object.assign({}, (_a = this._defaultProps[sel]) !== null && _a !== void 0 ? _a : {}), props);
      });
    }
    static getDefaultProps(selector) {
      var _a;
      return (_a = this._defaultProps[selector]) !== null && _a !== void 0 ? _a : {};
    }
    get componentUtilsSettings() {
      return this._settings.componentUtils;
    }
    whenMountState() {
      return this._whenMountPromise;
    }
    whenMountedState() {
      return this._whenMountedPromise;
    }
    adoptStyleInShadowRoot($shadowRoot, $context) {
      return adoptStyleInShadowRoot($shadowRoot, $context);
    }
    get props() {
      if (this._finalProps)
        return this._finalProps;
      const props = this._props;
      let passedProps = {};
      if (props.constructor.name === "NamedNodeMap") {
        Object.keys(props).forEach((key) => {
          var _a, _b, _c;
          let value;
          if (((_a = props[key]) === null || _a === void 0 ? void 0 : _a.nodeValue) !== void 0) {
            if (props[key].nodeValue === "")
              value = true;
            else
              value = props[key].nodeValue;
          }
          if (!value)
            return;
          passedProps[camelCase((_c = (_b = props[key]) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : key)] = autoCast$1(value);
        });
      } else {
        j;
        passedProps = props;
      }
      this._finalProps = __deepMerge$8(this.defaultProps, this.InterfaceToApply.apply(passedProps, {
        descriptor: {
          defaults: false
        }
      }));
      const _this = this;
      this._finalProps = new Proxy(this._finalProps, {
        get(target, prop, receiver) {
          return target[prop];
        },
        set(obj, prop, value) {
          const propDef = _this.InterfaceToApply.definition[prop];
          if (propDef === null || propDef === void 0 ? void 0 : propDef.physical) {
            if (value === false || value === void 0 || value === null) {
              _this.node.removeAttribute(dashCase(prop));
            } else {
              _this.node.setAttribute(dashCase(prop), String(value));
            }
          }
          obj[prop] = value;
          return true;
        }
      });
      Object.keys(this._finalProps).forEach((prop) => {
        this._finalProps[prop] = this._finalProps[prop];
      });
      return this._finalProps;
    }
    get defaultProps() {
      var _a, _b, _c;
      if (this._defaultProps)
        return Object.assign({}, this._defaultProps);
      this._defaultProps = Object.assign({}, __deepMerge$8(this.InterfaceToApply.defaults(), (_a = this.componentUtilsSettings.defaultProps) !== null && _a !== void 0 ? _a : {}, (_b = this.constructor._defaultProps["*"]) !== null && _b !== void 0 ? _b : {}, (_c = this.constructor._defaultProps[this.name]) !== null && _c !== void 0 ? _c : {}));
      return this._defaultProps;
    }
    static getFinalInterface(int) {
      class InlineSComponentUtilsInterface extends SInterface {
      }
      InlineSComponentUtilsInterface.definition = SComponentDefaultInterface.definition;
      if (int) {
        InlineSComponentUtilsInterface.definition = Object.assign(Object.assign({}, SComponentDefaultInterface.definition), int.definition);
      }
      return InlineSComponentUtilsInterface;
    }
    injectStyle(css, id = this.tagName) {
      if (this.constructor._injectedStyles.indexOf(id) !== -1)
        return;
      this.constructor._injectedStyles.push(id);
      injectStyle(css, id);
    }
    exposeApi(apiObj, ctx = this.node) {
      setTimeout(() => {
        let $on = this.node;
        Object.keys(apiObj).forEach((apiFnName) => {
          const apiFn = apiObj[apiFnName].bind(ctx);
          $on[apiFnName] = apiFn;
        });
      });
    }
    className(cls = "", style = "") {
      let clsString = cls.split(" ").map((clsName) => `${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`).join(" ");
      if (style && !this.props.bare) {
        clsString += ` ${style}`;
      }
      return clsString;
    }
    isMounted() {
      var _a;
      return (_a = this.node) === null || _a === void 0 ? void 0 : _a.hasAttribute("mounted");
    }
  }
  SComponent._defaultProps = {};
  SComponent._injectedStyles = [];
  /**
  * @license
  * Copyright 2019 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  const constructionToken = Symbol();
  const styleSheetCache = new Map();
  class CSSResult {
    constructor(cssText, safeToken) {
      this["_$cssResult$"] = true;
      if (safeToken !== constructionToken) {
        throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      }
      this.cssText = cssText;
    }
    get styleSheet() {
      let styleSheet = styleSheetCache.get(this.cssText);
      if (supportsAdoptingStyleSheets && styleSheet === void 0) {
        styleSheetCache.set(this.cssText, styleSheet = new CSSStyleSheet());
        styleSheet.replaceSync(this.cssText);
      }
      return styleSheet;
    }
    toString() {
      return this.cssText;
    }
  }
  const textFromCSSResult = (value) => {
    if (value["_$cssResult$"] === true) {
      return value.cssText;
    } else if (typeof value === "number") {
      return value;
    } else {
      throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
    }
  };
  const unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), constructionToken);
  const css$1 = (strings, ...values) => {
    const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
  };
  const adoptStyles = (renderRoot, styles) => {
    if (supportsAdoptingStyleSheets) {
      renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    } else {
      styles.forEach((s) => {
        const style = document.createElement("style");
        style.textContent = s.cssText;
        renderRoot.appendChild(style);
      });
    }
  };
  const cssResultFromStyleSheet = (sheet) => {
    let cssText = "";
    for (const rule of sheet.cssRules) {
      cssText += rule.cssText;
    }
    return unsafeCSS(cssText);
  };
  const getCompatibleStyle = supportsAdoptingStyleSheets ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$6, _b$6, _c$6, _d$5;
  var _e$7;
  var _f$5;
  let requestUpdateThenable;
  {
    console.warn(`Running in dev mode. Do not use in production!`);
    if (((_a$6 = window.ShadyDOM) === null || _a$6 === void 0 ? void 0 : _a$6.inUse) && globalThis["reactiveElementPlatformSupport"] === void 0) {
      console.warn(`Shadow DOM is being polyfilled via ShadyDOM but the \`polyfill-support\` module has not been loaded.`);
    }
    requestUpdateThenable = {
      then: (onfulfilled, _onrejected) => {
        console.warn(`\`requestUpdate\` no longer returns a Promise.Use \`updateComplete\` instead.`);
        if (onfulfilled !== void 0) {
          onfulfilled(false);
        }
      }
    };
  }
  const JSCompiler_renameProperty = (prop, _obj) => prop;
  const defaultConverter = {
    toAttribute(value, type) {
      switch (type) {
        case Boolean:
          value = value ? "" : null;
          break;
        case Object:
        case Array:
          value = value == null ? value : JSON.stringify(value);
          break;
      }
      return value;
    },
    fromAttribute(value, type) {
      let fromValue = value;
      switch (type) {
        case Boolean:
          fromValue = value !== null;
          break;
        case Number:
          fromValue = value === null ? null : Number(value);
          break;
        case Object:
        case Array:
          try {
            fromValue = JSON.parse(value);
          } catch (e) {
            fromValue = null;
          }
          break;
      }
      return fromValue;
    }
  };
  const notEqual = (value, old) => {
    return old !== value && (old === old || value === value);
  };
  const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual
  };
  const finalized = "finalized";
  class ReactiveElement extends HTMLElement {
    constructor() {
      super();
      this.__instanceProperties = new Map();
      this.isUpdatePending = false;
      this.hasUpdated = false;
      this.__reflectingProperty = null;
      this._initialize();
    }
    static addInitializer(initializer) {
      var _a;
      (_a = this._initializers) !== null && _a !== void 0 ? _a : this._initializers = [];
      this._initializers.push(initializer);
    }
    static get observedAttributes() {
      this.finalize();
      const attributes = [];
      this.elementProperties.forEach((v, p) => {
        const attr = this.__attributeNameForProperty(p, v);
        if (attr !== void 0) {
          this.__attributeToPropertyMap.set(attr, p);
          attributes.push(attr);
        }
      });
      return attributes;
    }
    static createProperty(name, options = defaultPropertyDeclaration) {
      if (options.state) {
        options.attribute = false;
      }
      this.finalize();
      this.elementProperties.set(name, options);
      if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
        const key = typeof name === "symbol" ? Symbol() : `__${name}`;
        const descriptor = this.getPropertyDescriptor(name, key, options);
        if (descriptor !== void 0) {
          Object.defineProperty(this.prototype, name, descriptor);
        }
      }
    }
    static getPropertyDescriptor(name, key, options) {
      return {
        get() {
          return this[key];
        },
        set(value) {
          const oldValue = this[name];
          this[key] = value;
          this.requestUpdate(name, oldValue, options);
        },
        configurable: true,
        enumerable: true
      };
    }
    static getPropertyOptions(name) {
      return this.elementProperties.get(name) || defaultPropertyDeclaration;
    }
    static finalize() {
      if (this.hasOwnProperty(finalized)) {
        return false;
      }
      this[finalized] = true;
      const superCtor = Object.getPrototypeOf(this);
      superCtor.finalize();
      this.elementProperties = new Map(superCtor.elementProperties);
      this.__attributeToPropertyMap = new Map();
      if (this.hasOwnProperty(JSCompiler_renameProperty("properties"))) {
        const props = this.properties;
        const propKeys = [
          ...Object.getOwnPropertyNames(props),
          ...Object.getOwnPropertySymbols(props)
        ];
        for (const p of propKeys) {
          this.createProperty(p, props[p]);
        }
      }
      this.elementStyles = this.finalizeStyles(this.styles);
      {
        const warnRemoved = (obj, name) => {
          if (obj[name] !== void 0) {
            console.warn(`\`${name}\` is implemented. It has been removed from this version of ReactiveElement. See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`);
          }
        };
        [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach((name) => warnRemoved(this.prototype, name));
      }
      return true;
    }
    static finalizeStyles(styles) {
      const elementStyles = [];
      if (Array.isArray(styles)) {
        const set = new Set(styles.flat(Infinity).reverse());
        for (const s of set) {
          elementStyles.unshift(getCompatibleStyle(s));
        }
      } else if (styles !== void 0) {
        elementStyles.push(getCompatibleStyle(styles));
      }
      return elementStyles;
    }
    static __attributeNameForProperty(name, options) {
      const attribute = options.attribute;
      return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
    }
    _initialize() {
      var _a;
      this.__updatePromise = new Promise((res) => this.enableUpdating = res);
      this._$changedProperties = new Map();
      this.__saveInstanceProperties();
      this.requestUpdate();
      (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));
    }
    addController(controller) {
      var _a, _b;
      ((_a = this.__controllers) !== null && _a !== void 0 ? _a : this.__controllers = []).push(controller);
      if (this.renderRoot !== void 0 && this.isConnected) {
        (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);
      }
    }
    removeController(controller) {
      var _a;
      (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
    }
    __saveInstanceProperties() {
      this.constructor.elementProperties.forEach((_v, p) => {
        if (this.hasOwnProperty(p)) {
          this.__instanceProperties.set(p, this[p]);
          delete this[p];
        }
      });
    }
    createRenderRoot() {
      var _a;
      const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);
      adoptStyles(renderRoot, this.constructor.elementStyles);
      return renderRoot;
    }
    connectedCallback() {
      var _a;
      if (this.renderRoot === void 0) {
        this.renderRoot = this.createRenderRoot();
      }
      this.enableUpdating(true);
      (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
        var _a2;
        return (_a2 = c.hostConnected) === null || _a2 === void 0 ? void 0 : _a2.call(c);
      });
    }
    enableUpdating(_requestedUpdate) {
    }
    disconnectedCallback() {
      var _a;
      (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
        var _a2;
        return (_a2 = c.hostDisconnected) === null || _a2 === void 0 ? void 0 : _a2.call(c);
      });
    }
    attributeChangedCallback(name, _old, value) {
      this._$attributeToProperty(name, value);
    }
    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
      var _a, _b;
      const attr = this.constructor.__attributeNameForProperty(name, options);
      if (attr !== void 0 && options.reflect === true) {
        const toAttribute = (_b = (_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== null && _b !== void 0 ? _b : defaultConverter.toAttribute;
        const attrValue = toAttribute(value, options.type);
        if (this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
          console.warn(`The attribute value for the ${name} property is undefined. The attribute will be removed, but in the previous version of ReactiveElement, the attribute would not have changed.`);
        }
        this.__reflectingProperty = name;
        if (attrValue == null) {
          this.removeAttribute(attr);
        } else {
          this.setAttribute(attr, attrValue);
        }
        this.__reflectingProperty = null;
      }
    }
    _$attributeToProperty(name, value) {
      var _a, _b, _c;
      const ctor = this.constructor;
      const propName = ctor.__attributeToPropertyMap.get(name);
      if (propName !== void 0 && this.__reflectingProperty !== propName) {
        const options = ctor.getPropertyOptions(propName);
        const converter = options.converter;
        const fromAttribute = (_c = (_b = (_a = converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== null && _b !== void 0 ? _b : typeof converter === "function" ? converter : null) !== null && _c !== void 0 ? _c : defaultConverter.fromAttribute;
        this.__reflectingProperty = propName;
        this[propName] = fromAttribute(value, options.type);
        this.__reflectingProperty = null;
      }
    }
    requestUpdate(name, oldValue, options) {
      let shouldRequestUpdate = true;
      if (name !== void 0) {
        options = options || this.constructor.getPropertyOptions(name);
        const hasChanged = options.hasChanged || notEqual;
        if (hasChanged(this[name], oldValue)) {
          if (!this._$changedProperties.has(name)) {
            this._$changedProperties.set(name, oldValue);
          }
          if (options.reflect === true && this.__reflectingProperty !== name) {
            if (this.__reflectingProperties === void 0) {
              this.__reflectingProperties = new Map();
            }
            this.__reflectingProperties.set(name, options);
          }
        } else {
          shouldRequestUpdate = false;
        }
      }
      if (!this.isUpdatePending && shouldRequestUpdate) {
        this.__updatePromise = this.__enqueueUpdate();
      }
      return requestUpdateThenable;
    }
    __enqueueUpdate() {
      return __async(this, null, function* () {
        this.isUpdatePending = true;
        try {
          yield this.__updatePromise;
        } catch (e) {
          Promise.reject(e);
        }
        const result = this.performUpdate();
        if (result != null) {
          yield result;
        }
        return !this.isUpdatePending;
      });
    }
    performUpdate() {
      var _a;
      if (!this.isUpdatePending) {
        return;
      }
      if (!this.hasUpdated) {
        {
          const shadowedProperties = [];
          this.constructor.elementProperties.forEach((_v, p) => {
            var _a2;
            if (this.hasOwnProperty(p) && !((_a2 = this.__instanceProperties) === null || _a2 === void 0 ? void 0 : _a2.has(p))) {
              shadowedProperties.push(p);
            }
          });
          if (shadowedProperties.length) {
            console.warn(`The following properties will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. To fix this issue, either initialize properties in the constructor or adjust your compiler settings; for example, for TypeScript set \`useDefineForClassFields: false\` in your \`tsconfig.json\`.`);
          }
        }
      }
      if (this.__instanceProperties) {
        this.__instanceProperties.forEach((v, p) => this[p] = v);
        this.__instanceProperties = void 0;
      }
      let shouldUpdate = false;
      const changedProperties = this._$changedProperties;
      try {
        shouldUpdate = this.shouldUpdate(changedProperties);
        if (shouldUpdate) {
          this.willUpdate(changedProperties);
          (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
            var _a2;
            return (_a2 = c.hostUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(c);
          });
          this.update(changedProperties);
        } else {
          this.__markUpdated();
        }
      } catch (e) {
        shouldUpdate = false;
        this.__markUpdated();
        throw e;
      }
      if (shouldUpdate) {
        this._$didUpdate(changedProperties);
      }
    }
    willUpdate(_changedProperties) {
    }
    _$didUpdate(changedProperties) {
      var _a;
      (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
        var _a2;
        return (_a2 = c.hostUpdated) === null || _a2 === void 0 ? void 0 : _a2.call(c);
      });
      if (!this.hasUpdated) {
        this.hasUpdated = true;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
      if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
        console.warn(`An update was requested (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
      }
    }
    __markUpdated() {
      this._$changedProperties = new Map();
      this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this.__updatePromise;
    }
    shouldUpdate(_changedProperties) {
      return true;
    }
    update(_changedProperties) {
      if (this.__reflectingProperties !== void 0) {
        this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
        this.__reflectingProperties = void 0;
      }
      this.__markUpdated();
    }
    updated(_changedProperties) {
    }
    firstUpdated(_changedProperties) {
    }
  }
  _f$5 = finalized;
  ReactiveElement[_f$5] = true;
  ReactiveElement.elementProperties = new Map();
  ReactiveElement.elementStyles = [];
  ReactiveElement.shadowRootOptions = {mode: "open"};
  (_c$6 = (_b$6 = globalThis)["reactiveElementPlatformSupport"]) === null || _c$6 === void 0 ? void 0 : _c$6.call(_b$6, {ReactiveElement});
  {
    ReactiveElement.enabledWarnings = ["change-in-update"];
    const ensureOwnWarnings = function(ctor) {
      if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings"))) {
        ctor.enabledWarnings = ctor.enabledWarnings.slice();
      }
    };
    ReactiveElement.enableWarning = function(warning) {
      ensureOwnWarnings(this);
      if (this.enabledWarnings.indexOf(warning) < 0) {
        this.enabledWarnings.push(warning);
      }
    };
    ReactiveElement.disableWarning = function(warning) {
      ensureOwnWarnings(this);
      const i = this.enabledWarnings.indexOf(warning);
      if (i >= 0) {
        this.enabledWarnings.splice(i, 1);
      }
    };
  }
  ((_d$5 = (_e$7 = globalThis)["reactiveElementVersions"]) !== null && _d$5 !== void 0 ? _d$5 : _e$7["reactiveElementVersions"] = []).push("1.0.0-rc.3");
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$5, _b$5, _c$5, _d$4, _e$6;
  var _f$4;
  {
    console.warn("lit-html is in dev mode. Not recommended for production!");
  }
  const wrap$3 = ((_a$5 = window.ShadyDOM) === null || _a$5 === void 0 ? void 0 : _a$5.inUse) && ((_b$5 = window.ShadyDOM) === null || _b$5 === void 0 ? void 0 : _b$5.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
  const trustedTypes$2 = globalThis.trustedTypes;
  const policy$2 = trustedTypes$2 ? trustedTypes$2.createPolicy("lit-html", {
    createHTML: (s) => s
  }) : void 0;
  const identityFunction$2 = (value) => value;
  const noopSanitizer$2 = (_node, _name, _type) => identityFunction$2;
  const setSanitizer = (newSanitizer) => {
    if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
      throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
    }
    sanitizerFactoryInternal$2 = newSanitizer;
  };
  const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
    sanitizerFactoryInternal$2 = noopSanitizer$2;
  };
  const createSanitizer$2 = (node, name, type) => {
    return sanitizerFactoryInternal$2(node, name, type);
  };
  const boundAttributeSuffix$2 = "$lit$";
  const marker$2 = `lit$${String(Math.random()).slice(9)}$`;
  const markerMatch$2 = "?" + marker$2;
  const nodeMarker$2 = `<${markerMatch$2}>`;
  const d$5 = document;
  const createMarker$2 = (v = "") => d$5.createComment(v);
  const isPrimitive$2 = (value) => value === null || typeof value != "object" && typeof value != "function";
  const isArray$5 = Array.isArray;
  const isIterable$2 = (value) => {
    var _a;
    return isArray$5(value) || typeof ((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]) === "function";
  };
  const SPACE_CHAR$2 = `[ 	
\f\r]`;
  const ATTR_VALUE_CHAR$2 = `[^ 	
\f\r"'\`<>=]`;
  const NAME_CHAR$2 = `[^\\s"'>=/]`;
  const textEndRegex$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  const COMMENT_START$2 = 1;
  const TAG_NAME$2 = 2;
  const DYNAMIC_TAG_NAME$2 = 3;
  const commentEndRegex$2 = /-->/g;
  const comment2EndRegex$2 = />/g;
  const tagEndRegex$2 = new RegExp(`>|${SPACE_CHAR$2}(?:(${NAME_CHAR$2}+)(${SPACE_CHAR$2}*=${SPACE_CHAR$2}*(?:${ATTR_VALUE_CHAR$2}|("|')|))|$)`, "g");
  const ENTIRE_MATCH$2 = 0;
  const ATTRIBUTE_NAME$2 = 1;
  const SPACES_AND_EQUALS$2 = 2;
  const QUOTE_CHAR$2 = 3;
  const singleQuoteAttrEndRegex$2 = /'/g;
  const doubleQuoteAttrEndRegex$2 = /"/g;
  const rawTextElement$2 = /^(?:script|style|textarea)$/i;
  const HTML_RESULT$2 = 1;
  const SVG_RESULT$2 = 2;
  const ATTRIBUTE_PART$2 = 1;
  const CHILD_PART$2 = 2;
  const PROPERTY_PART$2 = 3;
  const BOOLEAN_ATTRIBUTE_PART$2 = 4;
  const EVENT_PART$2 = 5;
  const ELEMENT_PART$2 = 6;
  const COMMENT_PART$2 = 7;
  const tag$1 = (type) => (strings, ...values) => {
    if (strings.some((s) => s === void 0)) {
      console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
    }
    return {
      ["_$litType$"]: type,
      strings,
      values
    };
  };
  const html$2 = tag$1(HTML_RESULT$2);
  const noChange$2 = Symbol.for("lit-noChange");
  const nothing$2 = Symbol.for("lit-nothing");
  const templateCache$2 = new WeakMap();
  const render = (value, container, options) => {
    var _a, _b, _c;
    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;
    let part = partOwnerNode["_$litPart$"];
    if (part === void 0) {
      const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;
      if (((_c = options) === null || _c === void 0 ? void 0 : _c.clearContainerForLit2MigrationOnly) === true) {
        let n = container.firstChild;
        while (n && n !== endNode) {
          const next = n.nextSibling;
          n.remove();
          n = next;
        }
      }
      partOwnerNode["_$litPart$"] = part = new ChildPart$2(container.insertBefore(createMarker$2(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
    }
    part._$setValue(value);
    return part;
  };
  {
    render.setSanitizer = setSanitizer;
    render.createSanitizer = createSanitizer$2;
    {
      render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
    }
  }
  const walker$2 = d$5.createTreeWalker(d$5, 129, null, false);
  let sanitizerFactoryInternal$2 = noopSanitizer$2;
  const getTemplateHtml$2 = (strings, type) => {
    const l = strings.length - 1;
    const attrNames = [];
    let html = type === SVG_RESULT$2 ? "<svg>" : "";
    let rawTextEndRegex;
    let regex = textEndRegex$2;
    for (let i = 0; i < l; i++) {
      const s = strings[i];
      let attrNameEndIndex = -1;
      let attrName;
      let lastIndex = 0;
      let match;
      while (lastIndex < s.length) {
        regex.lastIndex = lastIndex;
        match = regex.exec(s);
        if (match === null) {
          break;
        }
        lastIndex = regex.lastIndex;
        if (regex === textEndRegex$2) {
          if (match[COMMENT_START$2] === "!--") {
            regex = commentEndRegex$2;
          } else if (match[COMMENT_START$2] !== void 0) {
            regex = comment2EndRegex$2;
          } else if (match[TAG_NAME$2] !== void 0) {
            if (rawTextElement$2.test(match[TAG_NAME$2])) {
              rawTextEndRegex = new RegExp(`</${match[TAG_NAME$2]}`, "g");
            }
            regex = tagEndRegex$2;
          } else if (match[DYNAMIC_TAG_NAME$2] !== void 0) {
            regex = tagEndRegex$2;
          }
        } else if (regex === tagEndRegex$2) {
          if (match[ENTIRE_MATCH$2] === ">") {
            regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$2;
            attrNameEndIndex = -1;
          } else if (match[ATTRIBUTE_NAME$2] === void 0) {
            attrNameEndIndex = -2;
          } else {
            attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS$2].length;
            attrName = match[ATTRIBUTE_NAME$2];
            regex = match[QUOTE_CHAR$2] === void 0 ? tagEndRegex$2 : match[QUOTE_CHAR$2] === '"' ? doubleQuoteAttrEndRegex$2 : singleQuoteAttrEndRegex$2;
          }
        } else if (regex === doubleQuoteAttrEndRegex$2 || regex === singleQuoteAttrEndRegex$2) {
          regex = tagEndRegex$2;
        } else if (regex === commentEndRegex$2 || regex === comment2EndRegex$2) {
          regex = textEndRegex$2;
        } else {
          regex = tagEndRegex$2;
          rawTextEndRegex = void 0;
        }
      }
      {
        console.assert(attrNameEndIndex === -1 || regex === tagEndRegex$2 || regex === singleQuoteAttrEndRegex$2 || regex === doubleQuoteAttrEndRegex$2, "unexpected parse state B");
      }
      const end = regex === tagEndRegex$2 && strings[i + 1].startsWith("/>") ? " " : "";
      html += regex === textEndRegex$2 ? s + nodeMarker$2 : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix$2 + s.slice(attrNameEndIndex)) + marker$2 + end : s + marker$2 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
    }
    const htmlResult = html + (strings[l] || "<?>") + (type === SVG_RESULT$2 ? "</svg>" : "");
    return [
      policy$2 !== void 0 ? policy$2.createHTML(htmlResult) : htmlResult,
      attrNames
    ];
  };
  class Template$2 {
    constructor({strings, ["_$litType$"]: type}, options) {
      this.parts = [];
      let node;
      let nodeIndex = 0;
      let attrNameIndex = 0;
      const partCount = strings.length - 1;
      const parts = this.parts;
      const [html, attrNames] = getTemplateHtml$2(strings, type);
      this.el = Template$2.createElement(html, options);
      walker$2.currentNode = this.el.content;
      if (type === SVG_RESULT$2) {
        const content = this.el.content;
        const svgElement = content.firstChild;
        svgElement.remove();
        content.append(...svgElement.childNodes);
      }
      while ((node = walker$2.nextNode()) !== null && parts.length < partCount) {
        if (node.nodeType === 1) {
          if (node.hasAttributes()) {
            const attrsToRemove = [];
            for (const name of node.getAttributeNames()) {
              if (name.endsWith(boundAttributeSuffix$2) || name.startsWith(marker$2)) {
                const realName = attrNames[attrNameIndex++];
                attrsToRemove.push(name);
                if (realName !== void 0) {
                  const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$2);
                  const statics = value.split(marker$2);
                  const m = /([.?@])?(.*)/.exec(realName);
                  parts.push({
                    type: ATTRIBUTE_PART$2,
                    index: nodeIndex,
                    name: m[2],
                    strings: statics,
                    ctor: m[1] === "." ? PropertyPart$2 : m[1] === "?" ? BooleanAttributePart$2 : m[1] === "@" ? EventPart$2 : AttributePart$2
                  });
                } else {
                  parts.push({
                    type: ELEMENT_PART$2,
                    index: nodeIndex
                  });
                }
              }
            }
            for (const name of attrsToRemove) {
              node.removeAttribute(name);
            }
          }
          if (rawTextElement$2.test(node.tagName)) {
            const strings2 = node.textContent.split(marker$2);
            const lastIndex = strings2.length - 1;
            if (lastIndex > 0) {
              node.textContent = trustedTypes$2 ? trustedTypes$2.emptyScript : "";
              for (let i = 0; i < lastIndex; i++) {
                node.append(strings2[i], createMarker$2());
                walker$2.nextNode();
                parts.push({type: CHILD_PART$2, index: ++nodeIndex});
              }
              node.append(strings2[lastIndex], createMarker$2());
            }
          }
        } else if (node.nodeType === 8) {
          const data = node.data;
          if (data === markerMatch$2) {
            parts.push({type: CHILD_PART$2, index: nodeIndex});
          } else {
            let i = -1;
            while ((i = node.data.indexOf(marker$2, i + 1)) !== -1) {
              parts.push({type: COMMENT_PART$2, index: nodeIndex});
              i += marker$2.length - 1;
            }
          }
        }
        nodeIndex++;
      }
    }
    static createElement(html, _options) {
      const el = d$5.createElement("template");
      el.innerHTML = html;
      return el;
    }
  }
  function resolveDirective$2(part, value, parent = part, attributeIndex) {
    var _a, _b, _c;
    var _d;
    if (value === noChange$2) {
      return value;
    }
    let currentDirective = attributeIndex !== void 0 ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex] : parent.__directive;
    const nextDirectiveConstructor = isPrimitive$2(value) ? void 0 : value["_$litDirective$"];
    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
      (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);
      if (nextDirectiveConstructor === void 0) {
        currentDirective = void 0;
      } else {
        currentDirective = new nextDirectiveConstructor(part);
        currentDirective._$initialize(part, parent, attributeIndex);
      }
      if (attributeIndex !== void 0) {
        ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : _d.__directives = [])[attributeIndex] = currentDirective;
      } else {
        parent.__directive = currentDirective;
      }
    }
    if (currentDirective !== void 0) {
      value = resolveDirective$2(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
    }
    return value;
  }
  class TemplateInstance$2 {
    constructor(template, parent) {
      this._parts = [];
      this._$disconnectableChildren = void 0;
      this._$template = template;
      this._$parent = parent;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(options) {
      var _a;
      const {el: {content}, parts} = this._$template;
      const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d$5).importNode(content, true);
      walker$2.currentNode = fragment;
      let node = walker$2.nextNode();
      let nodeIndex = 0;
      let partIndex = 0;
      let templatePart = parts[0];
      while (templatePart !== void 0) {
        if (nodeIndex === templatePart.index) {
          let part;
          if (templatePart.type === CHILD_PART$2) {
            part = new ChildPart$2(node, node.nextSibling, this, options);
          } else if (templatePart.type === ATTRIBUTE_PART$2) {
            part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
          } else if (templatePart.type === ELEMENT_PART$2) {
            part = new ElementPart$2(node, this, options);
          }
          this._parts.push(part);
          templatePart = parts[++partIndex];
        }
        if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
          node = walker$2.nextNode();
          nodeIndex++;
        }
      }
      return fragment;
    }
    _update(values) {
      let i = 0;
      for (const part of this._parts) {
        if (part !== void 0) {
          if (part.strings !== void 0) {
            part._$setValue(values, part, i);
            i += part.strings.length - 2;
          } else {
            part._$setValue(values[i]);
          }
        }
        i++;
      }
    }
  }
  class ChildPart$2 {
    constructor(startNode, endNode, parent, options) {
      this.type = CHILD_PART$2;
      this.__isConnected = true;
      this._$disconnectableChildren = void 0;
      this._$startNode = startNode;
      this._$endNode = endNode;
      this._$parent = parent;
      this.options = options;
      {
        this._textSanitizer = void 0;
      }
    }
    get _$isConnected() {
      var _a, _b;
      return (_b = (_a = this._$parent) === null || _a === void 0 ? void 0 : _a._$isConnected) !== null && _b !== void 0 ? _b : this.__isConnected;
    }
    get parentNode() {
      return wrap$3(this._$startNode).parentNode;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
      value = resolveDirective$2(this, value, directiveParent);
      if (isPrimitive$2(value)) {
        if (value === nothing$2 || value == null || value === "") {
          if (this._$committedValue !== nothing$2) {
            this._$clear();
          }
          this._$committedValue = nothing$2;
        } else if (value !== this._$committedValue && value !== noChange$2) {
          this._commitText(value);
        }
      } else if (value["_$litType$"] !== void 0) {
        this._commitTemplateResult(value);
      } else if (value.nodeType !== void 0) {
        this._commitNode(value);
      } else if (isIterable$2(value)) {
        this._commitIterable(value);
      } else {
        this._commitText(value);
      }
    }
    _insert(node, ref = this._$endNode) {
      return wrap$3(wrap$3(this._$startNode).parentNode).insertBefore(node, ref);
    }
    _commitNode(value) {
      var _a;
      if (this._$committedValue !== value) {
        this._$clear();
        if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
          const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;
          if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
            this._insert(new Text("/* lit-html will not write TemplateResults to scripts and styles */"));
            return;
          }
        }
        this._$committedValue = this._insert(value);
      }
    }
    _commitText(value) {
      const node = wrap$3(this._$startNode).nextSibling;
      if (node !== null && node.nodeType === 3 && (this._$endNode === null ? wrap$3(node).nextSibling === null : node === wrap$3(this._$endNode).previousSibling)) {
        {
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer$2(node, "data", "property");
          }
          value = this._textSanitizer(value);
        }
        node.data = value;
      } else {
        {
          const textNode = document.createTextNode("");
          this._commitNode(textNode);
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer$2(textNode, "data", "property");
          }
          value = this._textSanitizer(value);
          textNode.data = value;
        }
      }
      this._$committedValue = value;
    }
    _commitTemplateResult(result) {
      var _a;
      const {values, ["_$litType$"]: type} = result;
      const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template$2.createElement(type.h, this.options)), type);
      if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {
        this._$committedValue._update(values);
      } else {
        const instance = new TemplateInstance$2(template, this);
        const fragment = instance._clone(this.options);
        instance._update(values);
        this._commitNode(fragment);
        this._$committedValue = instance;
      }
    }
    _$getTemplate(result) {
      let template = templateCache$2.get(result.strings);
      if (template === void 0) {
        templateCache$2.set(result.strings, template = new Template$2(result));
      }
      return template;
    }
    _commitIterable(value) {
      if (!isArray$5(this._$committedValue)) {
        this._$committedValue = [];
        this._$clear();
      }
      const itemParts = this._$committedValue;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        if (partIndex === itemParts.length) {
          itemParts.push(itemPart = new ChildPart$2(this._insert(createMarker$2()), this._insert(createMarker$2()), this, this.options));
        } else {
          itemPart = itemParts[partIndex];
        }
        itemPart._$setValue(item);
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        this._$clear(itemPart && wrap$3(itemPart._$endNode).nextSibling, partIndex);
        itemParts.length = partIndex;
      }
    }
    _$clear(start = wrap$3(this._$startNode).nextSibling, from) {
      var _a;
      (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);
      while (start && start !== this._$endNode) {
        const n = wrap$3(start).nextSibling;
        wrap$3(start).remove();
        start = n;
      }
    }
    setConnected(isConnected) {
      var _a;
      if (this._$parent === void 0) {
        this.__isConnected = isConnected;
        (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);
      } else {
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      }
    }
  }
  class AttributePart$2 {
    constructor(element, name, strings, parent, options) {
      this.type = ATTRIBUTE_PART$2;
      this._$committedValue = nothing$2;
      this._$disconnectableChildren = void 0;
      this.element = element;
      this.name = name;
      this._$parent = parent;
      this.options = options;
      if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
        this._$committedValue = new Array(strings.length - 1).fill(nothing$2);
        this.strings = strings;
      } else {
        this._$committedValue = nothing$2;
      }
      {
        this._sanitizer = void 0;
      }
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
      const strings = this.strings;
      let change = false;
      if (strings === void 0) {
        value = resolveDirective$2(this, value, directiveParent, 0);
        change = !isPrimitive$2(value) || value !== this._$committedValue && value !== noChange$2;
        if (change) {
          this._$committedValue = value;
        }
      } else {
        const values = value;
        value = strings[0];
        let i, v;
        for (i = 0; i < strings.length - 1; i++) {
          v = resolveDirective$2(this, values[valueIndex + i], directiveParent, i);
          if (v === noChange$2) {
            v = this._$committedValue[i];
          }
          change || (change = !isPrimitive$2(v) || v !== this._$committedValue[i]);
          if (v === nothing$2) {
            value = nothing$2;
          } else if (value !== nothing$2) {
            value += (v !== null && v !== void 0 ? v : "") + strings[i + 1];
          }
          this._$committedValue[i] = v;
        }
      }
      if (change && !noCommit) {
        this._commitValue(value);
      }
    }
    _commitValue(value) {
      if (value === nothing$2) {
        wrap$3(this.element).removeAttribute(this.name);
      } else {
        {
          if (this._sanitizer === void 0) {
            this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, "attribute");
          }
          value = this._sanitizer(value !== null && value !== void 0 ? value : "");
        }
        wrap$3(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
      }
    }
  }
  class PropertyPart$2 extends AttributePart$2 {
    constructor() {
      super(...arguments);
      this.type = PROPERTY_PART$2;
    }
    _commitValue(value) {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, "property");
        }
        value = this._sanitizer(value);
      }
      this.element[this.name] = value === nothing$2 ? void 0 : value;
    }
  }
  class BooleanAttributePart$2 extends AttributePart$2 {
    constructor() {
      super(...arguments);
      this.type = BOOLEAN_ATTRIBUTE_PART$2;
    }
    _commitValue(value) {
      if (value && value !== nothing$2) {
        wrap$3(this.element).setAttribute(this.name, "");
      } else {
        wrap$3(this.element).removeAttribute(this.name);
      }
    }
  }
  class EventPart$2 extends AttributePart$2 {
    constructor() {
      super(...arguments);
      this.type = EVENT_PART$2;
    }
    _$setValue(newListener, directiveParent = this) {
      var _a;
      newListener = (_a = resolveDirective$2(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing$2;
      if (newListener === noChange$2) {
        return;
      }
      const oldListener = this._$committedValue;
      const shouldRemoveListener = newListener === nothing$2 && oldListener !== nothing$2 || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
      const shouldAddListener = newListener !== nothing$2 && (oldListener === nothing$2 || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.name, this, oldListener);
      }
      if (shouldAddListener) {
        this.element.addEventListener(this.name, this, newListener);
      }
      this._$committedValue = newListener;
    }
    handleEvent(event) {
      var _a, _b;
      if (typeof this._$committedValue === "function") {
        this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);
      } else {
        this._$committedValue.handleEvent(event);
      }
    }
  }
  class ElementPart$2 {
    constructor(element, parent, options) {
      this.element = element;
      this.type = ELEMENT_PART$2;
      this._$disconnectableChildren = void 0;
      this._$parent = parent;
      this.options = options;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value) {
      resolveDirective$2(this, value);
    }
  }
  (_d$4 = (_c$5 = globalThis)["litHtmlPlatformSupport"]) === null || _d$4 === void 0 ? void 0 : _d$4.call(_c$5, Template$2, ChildPart$2);
  ((_e$6 = (_f$4 = globalThis)["litHtmlVersions"]) !== null && _e$6 !== void 0 ? _e$6 : _f$4["litHtmlVersions"] = []).push("2.0.0-rc.4");
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$4, _b$4, _c$4, _d$3, _e$5;
  var _f$3;
  class LitElement extends ReactiveElement {
    constructor() {
      super(...arguments);
      this.renderOptions = {host: this};
      this.__childPart = void 0;
    }
    createRenderRoot() {
      var _a;
      var _b;
      const renderRoot = super.createRenderRoot();
      (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0 ? _a : _b.renderBefore = renderRoot.firstChild;
      return renderRoot;
    }
    update(changedProperties) {
      const value = this.render();
      super.update(changedProperties);
      this.__childPart = render(value, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var _a;
      super.connectedCallback();
      (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);
    }
    disconnectedCallback() {
      var _a;
      super.disconnectedCallback();
      (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);
    }
    render() {
      return noChange$2;
    }
  }
  LitElement["finalized"] = true;
  LitElement["_$litElement$"] = true;
  (_b$4 = (_a$4 = globalThis)["litElementHydrateSupport"]) === null || _b$4 === void 0 ? void 0 : _b$4.call(_a$4, {LitElement});
  (_d$3 = (_c$4 = globalThis)["litElementPlatformSupport"]) === null || _d$3 === void 0 ? void 0 : _d$3.call(_c$4, {LitElement});
  {
    LitElement["finalize"] = function() {
      const finalized = ReactiveElement.finalize.call(this);
      if (!finalized) {
        return false;
      }
      const warnRemoved = (obj, name) => {
        if (obj[name] !== void 0) {
          console.warn(`\`${name}\` is implemented. It has been removed from this version of LitElement. `);
        }
      };
      [`render`, `getStyles`].forEach((name) => warnRemoved(this, name));
      [`adoptStyles`].forEach((name) => warnRemoved(this.prototype, name));
      return true;
    };
  }
  ((_e$5 = (_f$3 = globalThis)["litElementVersions"]) !== null && _e$5 !== void 0 ? _e$5 : _f$3["litElementVersions"] = []).push("3.0.0-rc.3");
  var __awaiter$c = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SLitComponent extends LitElement {
    constructor(settings = {}) {
      var _a, _b, _c, _d, _e, _f, _g;
      super();
      this._settings = {};
      this._shouldUpdate = false;
      this._settings = __deepMerge$8({
        componentUtils: {},
        litComponent: {
          shadowDom: true,
          get rootNode() {
            var _a2;
            return (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("*:first-child");
          }
        }
      }, settings);
      this.componentUtils = new SComponent(this, this.attributes, {
        componentUtils: Object.assign(Object.assign({}, (_a = this._settings.componentUtils) !== null && _a !== void 0 ? _a : {}), {style: (_e = (_c = (_b = this.constructor.styles) === null || _b === void 0 ? void 0 : _b.cssText) !== null && _c !== void 0 ? _c : (_d = this._settings.componentUtils) === null || _d === void 0 ? void 0 : _d.style) !== null && _e !== void 0 ? _e : ""})
      });
      this.props = this.componentUtils.props;
      if (this.litComponentSettings.shadowDom === false) {
        this.createRenderRoot = () => {
          return this;
        };
      }
      Object.keys(this.componentUtils.props).forEach((prop) => {
        this[prop] = this.componentUtils.props[prop];
      });
      const nodeFirstUpdated = (_f = this.firstUpdated) === null || _f === void 0 ? void 0 : _f.bind(this);
      this.firstUpdated = () => __awaiter$c(this, void 0, void 0, function* () {
        if (nodeFirstUpdated) {
          yield nodeFirstUpdated();
        }
        this.mounted = true;
      });
      const nodeShouldUpdate = (_g = this.shouldUpdate) === null || _g === void 0 ? void 0 : _g.bind(this);
      this.shouldUpdate = () => {
        if (nodeShouldUpdate) {
          const res = nodeShouldUpdate();
          if (!res)
            return false;
        }
        return this._shouldUpdate;
      };
      (() => __awaiter$c(this, void 0, void 0, function* () {
        const mountedCallback = yield this.componentUtils.whenMountState();
        yield this.mount();
        mountedCallback();
      }))();
    }
    static setDefaultProps(selector, props) {
      SComponent.setDefaultProps(selector, props);
    }
    get litComponentSettings() {
      return this._settings.litComponent;
    }
    static properties(properties, int) {
      const propertiesObj = {};
      const InterfaceToApply = SComponent.getFinalInterface(int);
      Object.keys(InterfaceToApply.definition).forEach((prop) => {
        var _a, _b, _c, _d, _e, _f;
        const definition = InterfaceToApply.definition[prop];
        propertiesObj[prop] = Object.assign({}, (_a = definition.lit) !== null && _a !== void 0 ? _a : {});
        if (definition.physical || ((_c = (_b = definition.type) === null || _b === void 0 ? void 0 : _b.toLowerCase) === null || _c === void 0 ? void 0 : _c.call(_b)) === "boolean" || ((_f = (_e = (_d = definition.type) === null || _d === void 0 ? void 0 : _d.type) === null || _e === void 0 ? void 0 : _e.toLowerCase) === null || _f === void 0 ? void 0 : _f.call(_e)) === "boolean") {
          propertiesObj[prop].reflect = true;
          propertiesObj[prop].attribute = dashCase(prop);
          propertiesObj[prop].converter = {
            toAttribute(value) {
              if (value === false || value === null)
                return null;
              return String(value);
            }
          };
        }
      });
      const props = Object.assign(Object.assign({}, propertiesObj), properties !== null && properties !== void 0 ? properties : {});
      return props;
    }
    mount() {
      var _a, _b;
      return __awaiter$c(this, void 0, void 0, function* () {
        this._shouldUpdate = true;
        this.requestUpdate();
        this.componentUtils.injectStyle((_b = (_a = this.constructor.styles) === null || _a === void 0 ? void 0 : _a.cssText) !== null && _b !== void 0 ? _b : "", this.tagName);
        yield wait$1();
        if (this.componentUtils.props.adoptStyle && this.shadowRoot) {
          yield this.componentUtils.adoptStyleInShadowRoot(this.shadowRoot);
        }
        return true;
      });
    }
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const standardProperty$3 = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty$3 = (options, proto, name) => {
    proto.constructor.createProperty(name, options);
  };
  function property$3(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty$3(options, protoOrDescriptor, name) : standardProperty$3(options, protoOrDescriptor);
  }
  var axios$2 = {exports: {}};
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString$2 = Object.prototype.toString;
  function isArray$4(val) {
    return toString$2.call(val) === "[object Array]";
  }
  function isUndefined$1(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString$2.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString$1(val) {
    return typeof val === "string";
  }
  function isNumber$1(val) {
    return typeof val === "number";
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString$2.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate$1(val) {
    return toString$2.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString$2.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString$2.call(val) === "[object Blob]";
  }
  function isFunction$1(val) {
    return toString$2.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject$1(val) && isFunction$1(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$4(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray$4(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend$1(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  var utils$d = {
    isArray: isArray$4,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isObject: isObject$1,
    isPlainObject,
    isUndefined: isUndefined$1,
    isDate: isDate$1,
    isFile,
    isBlob,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend: extend$1,
    trim,
    stripBOM
  };
  var utils$c = utils$d;
  function encode$1(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$c.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$c.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$c.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$c.forEach(val, function parseValue(v) {
          if (utils$c.isDate(v)) {
            v = v.toISOString();
          } else if (utils$c.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode$1(key) + "=" + encode$1(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$b = utils$d;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach(fn) {
    utils$b.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$a = utils$d;
  var transformData$1 = function transformData(data, headers, fns) {
    utils$a.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$9 = utils$d;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$9.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  var enhanceError$1 = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  var enhanceError = enhanceError$1;
  var createError$2 = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };
  var createError$1 = createError$2;
  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
  var utils$8 = utils$d;
  var cookies$1 = utils$8.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$8.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$8.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$8.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL = isAbsoluteURL$1;
  var combineURLs = combineURLs$1;
  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$7 = utils$d;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$7.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$7.trim(line.substr(0, i)).toLowerCase();
      val = utils$7.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$6 = utils$d;
  var isURLSameOrigin$1 = utils$6.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils$6.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
  var utils$5 = utils$d;
  var settle = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath = buildFullPath$1;
  var parseHeaders = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError = createError$2;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils$5.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(resolve, reject, response);
        request = null;
      };
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(createError("Request aborted", config, "ECONNABORTED", request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(createError("Network Error", config, null, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
        request = null;
      };
      if (utils$5.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils$5.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$5.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }
          request.abort();
          reject(cancel);
          request = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request.send(requestData);
    });
  };
  var utils$4 = utils$d;
  var normalizeHeaderName = normalizeHeaderName$1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$4.isUndefined(headers) && utils$4.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  var defaults$3 = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils$4.isFormData(data) || utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data)) {
        return data;
      }
      if (utils$4.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$4.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils$4.isObject(data)) {
        setContentTypeIfUnset(headers, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$3.headers = {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  };
  utils$4.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$4.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$3 = utils$d;
  var transformData = transformData$1;
  var isCancel = isCancel$1;
  var defaults$2 = defaults_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$2.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$2 = utils$d;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
        return utils$2.merge(target, source);
      } else if (utils$2.isPlainObject(source)) {
        return utils$2.merge({}, source);
      } else if (utils$2.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
  var utils$1 = utils$d;
  var buildURL = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest, void 0];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios$1.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  var Axios_1 = Axios$1;
  function Cancel$1(message) {
    this.message = message;
  }
  Cancel$1.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;
  var Cancel = Cancel_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var isAxiosError = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  var utils = utils$d;
  var bind = bind$2;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults$1 = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    return instance;
  }
  var axios$1 = createInstance(defaults$1);
  axios$1.Axios = Axios;
  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
  };
  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  function strToHtml(string) {
    if (document !== void 0 && document.createElement !== void 0) {
      const cont = document.createElement("div");
      cont.innerHTML = string;
      if (cont.children.length === 1) {
        return cont.children[0];
      } else {
        return cont;
      }
    }
    return string;
  }
  function toStringFn(html, deep = true) {
    if (document !== void 0 && document.createElement !== void 0) {
      const cont = document.createElement("div");
      cont.appendChild(html.cloneNode(deep));
      return cont.innerHTML;
    }
    return html;
  }
  function convert(from, to = "ms") {
    let fromMs = from;
    if (typeof from === "string") {
      const fromNumber = parseFloat(from);
      const fromLength = fromNumber.toString().length;
      const fromString = from.slice(fromLength);
      if (fromString === "ms" || fromString === "millisecond" || fromString === "milliseconds") {
        fromMs = fromNumber;
      } else if (fromString === "s" || fromString === "second" || fromString === "seconds") {
        fromMs = fromNumber * 1e3;
      } else if (fromString === "m" || fromString === "minute" || fromString === "minutes") {
        fromMs = fromNumber * 60 * 1e3;
      } else if (fromString === "h" || fromString === "hour" || fromString === "hours") {
        fromMs = fromNumber * 60 * 60 * 1e3;
      } else if (fromString === "d" || fromString === "day" || fromString === "days") {
        fromMs = fromNumber * 24 * 60 * 60 * 1e3;
      } else if (fromString === "w" || fromString === "week" || fromString === "weeks") {
        fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "month" || fromString === "months") {
        fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
      } else if (fromString === "y" || fromString === "year" || fromString === "years") {
        fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
      }
    }
    switch (to) {
      case "ms":
      case "millisecond":
      case "milliseconds":
        return fromMs;
      case "s":
      case "second":
      case "seconds":
        return fromMs / 1e3;
      case "m":
      case "minute":
      case "minutes":
        return fromMs / 1e3 / 60;
      case "h":
      case "hour":
      case "hours":
        return fromMs / 1e3 / 60 / 60;
      case "d":
      case "day":
      case "days":
        return fromMs / 1e3 / 60 / 60 / 24;
      case "w":
      case "week":
      case "weeks":
        return fromMs / 1e3 / 60 / 60 / 24 / 7;
      case "month":
      case "months":
        return fromMs / 1e3 / 60 / 60 / 24 / 31;
      case "y":
      case "year":
      case "years":
        return fromMs / 1e3 / 60 / 60 / 24 / 365;
      default:
        throw new Error(`You try to convert "${from}" to "${to}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
    }
  }
  convert.MILLISECOND = "ms";
  convert.SECOND = "s";
  convert.MINUTE = "m";
  convert.HOUR = "h";
  convert.DAY = "d";
  convert.WEEK = "w";
  convert.MONTH = "month";
  convert.YEAR = "y";
  class SRequestConfig {
    constructor(params) {
      this.url = null;
      this.baseURL = null;
      this.method = "GET";
      this.headers = {};
      this.params = {};
      this.data = {};
      this.timeout = 0;
      this.sendInterval = 1e3;
      this.sendCount = 1;
      this.everyResponse = null;
      this.responseType = "json";
      if (params.timeout && typeof params.timeout === "string")
        params.timeout = convert(params.timeout, "ms");
      if (params.sendInterval && typeof params.sendInterval === "string")
        params.sendInterval = convert(params.sendInterval, "ms");
      Object.assign(this, params);
    }
  }
  class SRequest extends SClass {
    constructor(request, settings) {
      super(__deepMerge$8({
        request: {}
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._defaultRequestSettings = {};
      this._currentRequestSettings = {};
      this._requestsCount = 0;
      if (!(request instanceof SRequestConfig)) {
        this._defaultRequestSettings = new SRequestConfig(request);
      } else {
        this._defaultRequestSettings = request;
      }
    }
    get requestSettings() {
      return this._settings.request;
    }
    _onSuccess(response) {
      let finalResponse = response.data;
      const contentType = response.headers["content-type"] || "text/plain";
      const hash = this._currentRequestSettings.url.indexOf("#") !== -1 ? this._currentRequestSettings.url.split("#")[1] : false;
      if (contentType === "text/html" && hash !== false && document !== void 0 && document.querySelector !== void 0) {
        const $html = strToHtml(response.data);
        if ($html.id === hash) {
          finalResponse = toStringFn($html);
        } else {
          const $part = $html.querySelector(`#${hash}`);
          if ($part) {
            finalResponse = toStringFn($part);
          }
        }
      } else if (contentType === "application/json") {
        finalResponse = JSON.parse(response.data);
      }
      response.data = finalResponse;
      delete response.config;
      delete response.request;
      this._responsesArray.push(response);
      if (this._currentRequestSettings.everyResponse) {
        this._currentRequestSettings.everyResponse(Object.assign({}, response), this._requestsCount);
      }
      const lastResponse = this._responsesArray.slice(-1)[0];
      if (this._requestsCount >= this._currentRequestSettings.sendCount) {
        this._resolve({
          status: lastResponse.status,
          statusText: lastResponse.statusText,
          data: lastResponse.data,
          count: this._responsesArray.length,
          response: lastResponse,
          responses: this._responsesArray
        });
      } else {
        this._send();
      }
    }
    _onError(error) {
      this._reject(error);
    }
    _send(requestSettings = {}) {
      this._requestsCount++;
      requestSettings = __deepMerge$8(this._defaultRequestSettings, requestSettings);
      if (requestSettings.beforeSend) {
        requestSettings = requestSettings.beforeSend(requestSettings, this._requestsCount);
      }
      this._currentRequestSettings = Object.assign(requestSettings);
      axios(requestSettings).then(this._onSuccess.bind(this)).catch(this._onError.bind(this));
    }
    retry() {
      return this.send();
    }
    send(requestSettings = {}) {
      return new Promise((resolve, reject) => {
        this._requestsCount = 0;
        this._responsesArray = [];
        this._resolve = resolve;
        this._reject = reject;
        this._send(requestSettings);
      });
    }
  }
  function filter$3(object, filter) {
    const result = {};
    Object.keys(object).forEach((propertyName) => {
      if (filter(propertyName, object[propertyName])) {
        result[propertyName] = object[propertyName];
      }
    });
    return result;
  }
  var __defProp$1 = Object.defineProperty;
  var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
  var __decorateClass$1 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp$1(target, key, result);
    return result;
  };
  class ApiNav extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {}
      });
      this._openedNamespaces = [];
      this._menuStack = {};
      this._menuStates = {};
      this._loaded = false;
    }
    firstUpdated() {
      return __async(this, null, function* () {
        var _a, _b;
        const request = new SRequest({
          url: "/docmap.json",
          method: "get"
        });
        this._menuStates = JSON.parse((_a = window.localStorage.getItem("apiNavStates")) != null ? _a : "{}");
        const cachedNav = JSON.parse((_b = window.localStorage.getItem("apiNav")) != null ? _b : "{}");
        if (Object.keys(cachedNav).length) {
          this._menuStack = cachedNav;
          this._loaded = true;
        }
        const res = yield request.send();
        const types = [];
        res.data.map = filter$3(res.data.map, (key, item) => {
          const supportedTypes = [
            "function",
            "class",
            "cssmixin",
            "cssfunction",
            "object",
            "customelement",
            "feature"
          ];
          if (types.indexOf(item.type) === -1)
            types.push(item.type);
          if (supportedTypes.indexOf(item.type.toLowerCase()) === -1)
            return false;
          return true;
        });
        console.log(types);
        this._menuStack = {};
        Object.keys(res.data.map).forEach((namespace) => {
          __set(this._menuStack, namespace, res.data.map[namespace]);
        });
        window.localStorage.setItem("apiNav", JSON.stringify(this._menuStack));
        this._loaded = true;
        this.requestUpdate();
      });
    }
    _isAcive(namespace) {
      var _a;
      return (_a = this._menuStates[namespace]) == null ? void 0 : _a.opened;
    }
    _toggle(namespace) {
      if (!this._menuStates[namespace]) {
        this._menuStates[namespace] = {
          opened: true
        };
      } else {
        this._menuStates[namespace].opened = !this._menuStates[namespace].opened;
      }
      window.localStorage.setItem("apiNavStates", JSON.stringify(this._menuStates));
      this.requestUpdate();
    }
    _renderList(obj, currentNamespace = "") {
      const items = Object.keys(obj).map((itemName) => {
        var _a;
        const itemObj = obj[itemName];
        const itemNamespace = `${currentNamespace ? `${currentNamespace}.` : ""}${itemName}`;
        if (itemObj.name && itemObj.namespace) {
          let icon = itemObj.platform[0].name;
          return html$2`
                    <li>
                        <i
                            class="s-icon:file-${icon} s-tc:extension-${icon}"
                        ></i>
                        <a href="/api/${itemNamespace}">${itemObj.name}</a>
                    </li>
                `;
        } else {
          return html$2`
                    <li class="${this._isAcive(itemNamespace) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
            this._toggle(itemNamespace);
          }}
                        >
                            ${itemName}
                        </span>
                        ${((_a = this._menuStates[itemNamespace]) == null ? void 0 : _a.opened) ? html$2`
                                  ${this._renderList(get$3(this._menuStack, itemNamespace), itemNamespace)}
                              ` : ""}
                    </li>
                `;
        }
      });
      return html$2`
            <ul class="${!currentNamespace ? "s-fs-tree" : ""}">
                ${items}
            </ul>
        `;
    }
    render() {
      if (!this._loaded) {
        return html$2`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
      }
      return html$2`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        `;
    }
  }
  __decorateClass$1([
    property$3()
  ], ApiNav.prototype, "_loaded", 2);
  if (!customElements.get("api-nav")) {
    customElements.define("api-nav", ApiNav);
  }
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  class ConfigExplorerNav extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {}
      });
      this._openedNamespaces = [];
      this._menuStack = {};
      this._menuStates = {};
      this._loaded = false;
    }
    firstUpdated() {
      return __async(this, null, function* () {
        var _a, _b;
        const request = new SRequest({
          url: "/api/docmap",
          method: "get"
        });
        this._menuStates = JSON.parse((_a = window.localStorage.getItem("ConfigExplorerNavStates")) != null ? _a : "{}");
        const cachedNav = JSON.parse((_b = window.localStorage.getItem("ConfigExplorerNav")) != null ? _b : "{}");
        if (Object.keys(cachedNav).length) {
          this._menuStack = cachedNav;
          this._loaded = true;
        }
        const res = yield request.send();
        res.data.map = filter$3(res.data.map, (key, item) => {
          if (key.includes("imagesBuilder"))
            console.log("S", key);
          if (!key.match(/[a-zA-Z0-9]+\.config\.[a-zA-Z0-9]+/))
            return false;
          key.replace(/.*\.config\./, "");
          return true;
        });
        return;
      });
    }
    _isAcive(namespace) {
      var _a;
      return (_a = this._menuStates[namespace]) == null ? void 0 : _a.opened;
    }
    _toggle(namespace) {
      if (!this._menuStates[namespace]) {
        this._menuStates[namespace] = {
          opened: true
        };
      } else {
        this._menuStates[namespace].opened = !this._menuStates[namespace].opened;
      }
      window.localStorage.setItem("ConfigExplorerNavStates", JSON.stringify(this._menuStates));
      this.requestUpdate();
    }
    _renderList(obj, currentNamespace = "") {
      const items = Object.keys(obj).map((itemName) => {
        var _a;
        const itemObj = obj[itemName];
        const itemNamespace = `${currentNamespace ? `${currentNamespace}.` : ""}${itemName}`;
        if (itemObj.name && itemObj.namespace) {
          let icon = itemObj.platform[0].name;
          return html$2`
                    <li>
                        <i
                            class="s-icon:file-${icon} s-tc:extension-${icon}"
                        ></i>
                        <a href="/api/${itemNamespace}">${itemObj.name}</a>
                    </li>
                `;
        } else {
          return html$2`
                    <li class="${this._isAcive(itemNamespace) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
            this._toggle(itemNamespace);
          }}
                        >
                            ${itemName}
                        </span>
                        ${((_a = this._menuStates[itemNamespace]) == null ? void 0 : _a.opened) ? html$2`
                                  ${this._renderList(get$3(this._menuStack, itemNamespace), itemNamespace)}
                              ` : ""}
                    </li>
                `;
        }
      });
      return html$2`
            <ul class="${!currentNamespace ? "s-fs-tree" : ""}">
                ${items}
            </ul>
        `;
    }
    render() {
      if (!this._loaded) {
        return html$2`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
      }
      return html$2`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        `;
    }
  }
  __decorateClass([
    property$3()
  ], ConfigExplorerNav.prototype, "_loaded", 2);
  if (!customElements.get("config-explorer-nav")) {
    customElements.define("config-explorer-nav", ConfigExplorerNav);
  }
  class SDuration {
    constructor(settings = {}) {
      this._settings = {};
      this.startTime = null;
      this.endTime = null;
      this.duration = null;
      this._settings = __deepMerge$8({
        format: "s",
        suffix: true
      }, settings);
      this.start();
    }
    toObject(settings = {}) {
      settings = __deepMerge$8(this._settings, settings);
      if (!this.endTime || !this.startTime)
        this.end();
      const durationMs = this.endTime - this.startTime;
      this.duration = durationMs;
      const convertedDuration = convert(durationMs, settings.format);
      const formatedDuration = settings.suffix ? convertedDuration + (settings.suffix === true ? settings.format : settings.suffix) : parseFloat(convertedDuration);
      return {
        startTime: this.startTime || -1,
        endTime: this.endTime || -1,
        duration: this.duration || -1,
        convertedDuration,
        formatedDuration
      };
    }
    start(startTime = null) {
      this.startTime = startTime || Date.now();
      return this;
    }
    end(settings = {}) {
      settings = __deepMerge$8(this._settings, settings);
      this.endTime = Date.now();
      return this.toObject(settings);
    }
  }
  /*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var clipboardCopy_1 = clipboardCopy;
  function makeError() {
    return new DOMException("The request is not allowed", "NotAllowedError");
  }
  function copyClipboardApi(text) {
    return __async(this, null, function* () {
      if (!navigator.clipboard) {
        throw makeError();
      }
      return navigator.clipboard.writeText(text);
    });
  }
  function copyExecCommand(text) {
    return __async(this, null, function* () {
      const span = document.createElement("span");
      span.textContent = text;
      span.style.whiteSpace = "pre";
      span.style.webkitUserSelect = "auto";
      span.style.userSelect = "all";
      document.body.appendChild(span);
      const selection = window.getSelection();
      const range = window.document.createRange();
      selection.removeAllRanges();
      range.selectNode(span);
      selection.addRange(range);
      let success = false;
      try {
        success = window.document.execCommand("copy");
      } finally {
        selection.removeAllRanges();
        window.document.body.removeChild(span);
      }
      if (!success)
        throw makeError();
    });
  }
  function clipboardCopy(text) {
    return __async(this, null, function* () {
      try {
        yield copyClipboardApi(text);
      } catch (err) {
        try {
          yield copyExecCommand(text);
        } catch (err2) {
          throw err2 || err || makeError();
        }
      }
    });
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const standardProperty$2 = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty$2 = (options, proto, name) => {
    proto.constructor.createProperty(name, options);
  };
  function property$2(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty$2(options, protoOrDescriptor, name) : standardProperty$2(options, protoOrDescriptor);
  }
  class SHighlightJsComponentInterface$1 extends SInterface {
  }
  SHighlightJsComponentInterface$1.definition = {
    successTimeout: {
      type: "Number",
      default: 1500
    },
    errorTimeout: {
      type: "Number",
      default: 3e3
    }
  };
  function copy(text) {
    return clipboardCopy_1(text);
  }
  function plainObject$7(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$7(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$7(newObj[key]) && plainObject$7(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  var __css$7 = ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0) + var(--s-theme-color-success-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-success-l, 0) + var(--s-theme-color-success-lightness-offset, 0)) * 1%),var(--s-theme-color-success-a, 1));\n    }\n\n    .s-clipboard-copy[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + var(--s-theme-color-error-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + var(--s-theme-color-error-lightness-offset, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    }\n\n    .s-clipboard-copy[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n";
  var __decorate$4 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  class SClipboardCopy extends SLitComponent {
    constructor() {
      super(__deepMerge$7({
        litComponent: {
          interface: SHighlightJsComponentInterface$1
        }
      }));
      this._state = "pending";
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css$7)}
        `;
    }
    copy(text) {
      this._state = "copy";
      copy(text).then(() => {
        this._state = "success";
        setTimeout(() => {
          this._state = "pending";
        }, this.props.successTimeout);
      }).catch((e) => {
        this._state = "error";
        setTimeout(() => {
          this._state = "pending";
        }, this.props.errorTimeout);
      });
    }
    render() {
      return html$2`
            <div class="${this.componentUtils.className("")}" state="${this._state}">
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z" fill="currentColor" />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z" fill="currentColor" />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
    }
  }
  __decorate$4([
    property$2()
  ], SClipboardCopy.prototype, "_state", void 0);
  function define$9(props = {}, tagName = "s-clipboard-copy") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SClipboardCopy);
  }
  function plainObject$6(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$6(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$6(newObj[key]) && plainObject$6(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMergeObj = args[i2];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function wait(timeout = 0) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, timeout);
    });
  }
  var deepFreezeEs6 = {exports: {}};
  function deepFreeze(obj) {
    if (obj instanceof Map) {
      obj.clear = obj.delete = obj.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj instanceof Set) {
      obj.add = obj.clear = obj.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(function(name) {
      var prop = obj[name];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj;
  }
  deepFreezeEs6.exports = deepFreeze;
  deepFreezeEs6.exports.default = deepFreeze;
  var deepFreeze$1 = deepFreezeEs6.exports;
  class Response {
    constructor(mode) {
      if (mode.data === void 0)
        mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit$1(original, ...objects) {
    const result = Object.create(null);
    for (const key in original) {
      result[key] = original[key];
    }
    objects.forEach(function(obj) {
      for (const key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }
  const SPAN_CLOSE = "</span>";
  const emitsWrappingTags = (node) => {
    return !!node.kind;
  };
  const expandScopeName = (name, {prefix}) => {
    if (name.includes(".")) {
      const pieces = name.split(".");
      return [
        `${prefix}${pieces.shift()}`,
        ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
      ].join(" ");
    }
    return `${prefix}${name}`;
  };
  class HTMLRenderer {
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(node) {
      if (!emitsWrappingTags(node))
        return;
      let scope = node.kind;
      if (node.sublanguage) {
        scope = `language-${scope}`;
      } else {
        scope = expandScopeName(scope, {prefix: this.classPrefix});
      }
      this.span(scope);
    }
    closeNode(node) {
      if (!emitsWrappingTags(node))
        return;
      this.buffer += SPAN_CLOSE;
    }
    value() {
      return this.buffer;
    }
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = {children: []};
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(node) {
      this.top.children.push(node);
    }
    openNode(kind) {
      const node = {kind, children: []};
      this.add(node);
      this.stack.push(node);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return void 0;
    }
    closeAllNodes() {
      while (this.closeNode())
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    static _walk(builder, node) {
      if (typeof node === "string") {
        builder.addText(node);
      } else if (node.children) {
        builder.openNode(node);
        node.children.forEach((child) => this._walk(builder, child));
        builder.closeNode(node);
      }
      return builder;
    }
    static _collapse(node) {
      if (typeof node === "string")
        return;
      if (!node.children)
        return;
      if (node.children.every((el2) => typeof el2 === "string")) {
        node.children = [node.children.join("")];
      } else {
        node.children.forEach((child) => {
          TokenTree._collapse(child);
        });
      }
    }
  }
  class TokenTreeEmitter extends TokenTree {
    constructor(options) {
      super();
      this.options = options;
    }
    addKeyword(text, kind) {
      if (text === "") {
        return;
      }
      this.openNode(kind);
      this.addText(text);
      this.closeNode();
    }
    addText(text) {
      if (text === "") {
        return;
      }
      this.add(text);
    }
    addSublanguage(emitter, name) {
      const node = emitter.root;
      node.kind = name;
      node.sublanguage = true;
      this.add(node);
    }
    toHTML() {
      const renderer = new HTMLRenderer(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  }
  function source$4(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function lookahead$3(re2) {
    return concat$4("(?=", re2, ")");
  }
  function concat$4(...args) {
    const joined = args.map((x2) => source$4(x2)).join("");
    return joined;
  }
  function stripOptionsFromArgs$1(args) {
    const opts = args[args.length - 1];
    if (typeof opts === "object" && opts.constructor === Object) {
      args.splice(args.length - 1, 1);
      return opts;
    } else {
      return {};
    }
  }
  function either$1(...args) {
    const opts = stripOptionsFromArgs$1(args);
    const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source$4(x2)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re2) {
    return new RegExp(re2.toString() + "|").exec("").length - 1;
  }
  function startsWith(re2, lexeme) {
    const match = re2 && re2.exec(lexeme);
    return match && match.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function _rewriteBackreferences(regexps, {joinWith}) {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset = numCaptures;
      let re2 = source$4(regex);
      let out = "";
      while (re2.length > 0) {
        const match = BACKREF_RE.exec(re2);
        if (!match) {
          out += re2;
          break;
        }
        out += re2.substring(0, match.index);
        re2 = re2.substring(match.index + match[0].length);
        if (match[0][0] === "\\" && match[1]) {
          out += "\\" + String(Number(match[1]) + offset);
        } else {
          out += match[0];
          if (match[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re2) => `(${re2})`).join(joinWith);
  }
  const MATCH_NOTHING_RE = /\b\B/;
  const IDENT_RE$1 = "[a-zA-Z]\\w*";
  const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  const BINARY_NUMBER_RE = "\\b(0b[01]+)";
  const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  const SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat$4(beginShebang, /.*\b/, opts.binary, /\b.*/);
    }
    return inherit$1({
      scope: "meta",
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      "on:begin": (m2, resp) => {
        if (m2.index !== 0)
          resp.ignoreMatch();
      }
    }, opts);
  };
  const BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  const APOS_STRING_MODE = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const QUOTE_STRING_MODE = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  const COMMENT = function(begin, end, modeOptions = {}) {
    const mode = inherit$1({
      scope: "comment",
      begin,
      end,
      contains: []
    }, modeOptions);
    mode.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: true,
      relevance: 0
    });
    const ENGLISH_WORD = either$1("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
    mode.contains.push({
      begin: concat$4(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
    });
    return mode;
  };
  const C_LINE_COMMENT_MODE = COMMENT("//", "$");
  const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
  const HASH_COMMENT_MODE = COMMENT("#", "$");
  const NUMBER_MODE = {
    scope: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  const C_NUMBER_MODE = {
    scope: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  const BINARY_NUMBER_MODE = {
    scope: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  const REGEXP_MODE = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      scope: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  const TITLE_MODE = {
    scope: "title",
    begin: IDENT_RE$1,
    relevance: 0
  };
  const UNDERSCORE_TITLE_MODE = {
    scope: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const METHOD_GUARD = {
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(mode, {
      "on:begin": (m2, resp) => {
        resp.data._beginMatch = m2[1];
      },
      "on:end": (m2, resp) => {
        if (resp.data._beginMatch !== m2[1])
          resp.ignoreMatch();
      }
    });
  };
  var MODES$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE$1,
    UNDERSCORE_IDENT_RE,
    NUMBER_RE,
    C_NUMBER_RE,
    BINARY_NUMBER_RE,
    RE_STARTERS_RE,
    SHEBANG,
    BACKSLASH_ESCAPE,
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE,
    COMMENT,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE,
    NUMBER_MODE,
    C_NUMBER_MODE,
    BINARY_NUMBER_MODE,
    REGEXP_MODE,
    TITLE_MODE,
    UNDERSCORE_TITLE_MODE,
    METHOD_GUARD,
    END_SAME_AS_BEGIN
  });
  function skipIfHasPrecedingDot(match, response) {
    const before = match.input[match.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function scopeClassName(mode, _parent) {
    if (mode.className !== void 0) {
      mode.scope = mode.className;
      delete mode.className;
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent)
      return;
    if (!mode.beginKeywords)
      return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfHasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0)
      mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal))
      return;
    mode.illegal = either$1(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match)
      return;
    if (mode.begin || mode.end)
      throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0)
      mode.relevance = 1;
  }
  const beforeMatchExt = (mode, parent) => {
    if (!mode.beforeMatch)
      return;
    if (mode.starts)
      throw new Error("beforeMatch cannot be used with starts");
    const originalMode = Object.assign({}, mode);
    Object.keys(mode).forEach((key) => {
      delete mode[key];
    });
    mode.keywords = originalMode.keywords;
    mode.begin = concat$4(originalMode.beforeMatch, lookahead$3(originalMode.begin));
    mode.starts = {
      relevance: 0,
      contains: [
        Object.assign(originalMode, {endsParent: true})
      ]
    };
    mode.relevance = 0;
    delete originalMode.beforeMatch;
  };
  const COMMON_KEYWORDS = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value"
  ];
  const DEFAULT_KEYWORD_SCOPE = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
    const compiledKeywords = Object.create(null);
    if (typeof rawKeywords === "string") {
      compileList(scopeName, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(scopeName, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(scopeName2) {
        Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
      });
    }
    return compiledKeywords;
    function compileList(scopeName2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x2) => x2.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  const seenDeprecations = {};
  const error = (message) => {
    console.error(message);
  };
  const warn$1 = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  const deprecated = (version2, message) => {
    if (seenDeprecations[`${version2}/${message}`])
      return;
    console.log(`Deprecated as of ${version2}. ${message}`);
    seenDeprecations[`${version2}/${message}`] = true;
  };
  const MultiClassError = new Error();
  function remapScopeNames(mode, regexes, {key}) {
    let offset = 0;
    const scopeNames = mode[key];
    const emit = {};
    const positions = {};
    for (let i2 = 1; i2 <= regexes.length; i2++) {
      positions[i2 + offset] = scopeNames[i2];
      emit[i2 + offset] = true;
      offset += countMatchGroups(regexes[i2 - 1]);
    }
    mode[key] = positions;
    mode[key]._emit = emit;
    mode[key]._multi = true;
  }
  function beginMultiClass(mode) {
    if (!Array.isArray(mode.begin))
      return;
    if (mode.skip || mode.excludeBegin || mode.returnBegin) {
      error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
      error("beginScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.begin, {key: "beginScope"});
    mode.begin = _rewriteBackreferences(mode.begin, {joinWith: ""});
  }
  function endMultiClass(mode) {
    if (!Array.isArray(mode.end))
      return;
    if (mode.skip || mode.excludeEnd || mode.returnEnd) {
      error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.endScope !== "object" || mode.endScope === null) {
      error("endScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.end, {key: "endScope"});
    mode.end = _rewriteBackreferences(mode.end, {joinWith: ""});
  }
  function scopeSugar(mode) {
    if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
      mode.beginScope = mode.scope;
      delete mode.scope;
    }
  }
  function MultiClass(mode) {
    scopeSugar(mode);
    if (typeof mode.beginScope === "string") {
      mode.beginScope = {_wrap: mode.beginScope};
    }
    if (typeof mode.endScope === "string") {
      mode.endScope = {_wrap: mode.endScope};
    }
    beginMultiClass(mode);
    endMultiClass(mode);
  }
  function compileLanguage(language) {
    function langRe(value, global2) {
      return new RegExp(source$4(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      addRule(re2, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re2]);
        this.matchAt += countMatchGroups(re2) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el2) => el2[1]);
        this.matcherRe = langRe(_rewriteBackreferences(terminators, {joinWith: "|"}), true);
        this.lastIndex = 0;
      }
      exec(s2) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match = this.matcherRe.exec(s2);
        if (!match) {
          return null;
        }
        const i2 = match.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
        const matchData = this.matchIndexes[i2];
        match.splice(0, i2);
        return Object.assign(match, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      getMatcher(index) {
        if (this.multiRegexes[index])
          return this.multiRegexes[index];
        const matcher = new MultiRegex();
        this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
        matcher.compile();
        this.multiRegexes[index] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(re2, opts) {
        this.rules.push([re2, opts]);
        if (opts.type === "begin")
          this.count++;
      }
      exec(s2) {
        const m2 = this.getMatcher(this.regexIndex);
        m2.lastIndex = this.lastIndex;
        let result = m2.exec(s2);
        if (this.resumingScanAtSamePosition()) {
          if (result && result.index === this.lastIndex)
            ;
          else {
            const m22 = this.getMatcher(0);
            m22.lastIndex = this.lastIndex + 1;
            result = m22.exec(s2);
          }
        }
        if (result) {
          this.regexIndex += result.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result;
      }
    }
    function buildModeRegex(mode) {
      const mm2 = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm2.addRule(term.begin, {rule: term, type: "begin"}));
      if (mode.terminatorEnd) {
        mm2.addRule(mode.terminatorEnd, {type: "end"});
      }
      if (mode.illegal) {
        mm2.addRule(mode.illegal, {type: "illegal"});
      }
      return mm2;
    }
    function compileMode(mode, parent) {
      const cmode = mode;
      if (mode.isCompiled)
        return cmode;
      [
        scopeClassName,
        compileMatch,
        MultiClass,
        beforeMatchExt
      ].forEach((ext) => ext(mode, parent));
      language.compilerExtensions.forEach((ext) => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        compileIllegal,
        compileRelevance
      ].forEach((ext) => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
        mode.keywords = Object.assign({}, mode.keywords);
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      keywordPattern = keywordPattern || /\w+/;
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin)
          mode.begin = /\B|\b/;
        cmode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          cmode.endRe = langRe(mode.end);
        cmode.terminatorEnd = source$4(mode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal)
        cmode.illegalRe = langRe(mode.illegal);
      if (!mode.contains)
        mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c2) {
        return expandOrCloneMode(c2 === "self" ? mode : c2);
      }));
      mode.contains.forEach(function(c2) {
        compileMode(c2, cmode);
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions)
      language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit$1(language.classNameAliases || {});
    return compileMode(language);
  }
  function dependencyOnParent(mode) {
    if (!mode)
      return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit$1(mode, {variants: null}, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit$1(mode, {starts: mode.starts ? inherit$1(mode.starts) : null});
    }
    if (Object.isFrozen(mode)) {
      return inherit$1(mode);
    }
    return mode;
  }
  var version = "11.1.0";
  const escape$1 = escapeHTML;
  const inherit = inherit$1;
  const NO_MATCH = Symbol("nomatch");
  const MAX_KEYWORD_HITS = 7;
  const HLJS = function(hljs) {
    const languages = Object.create(null);
    const aliases = Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = {disableAutodetect: true, name: "Plain text", contains: []};
    let options = {
      ignoreUnescapedHTML: false,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + " ";
      classes += block.parentNode ? block.parentNode.className : "";
      const match = options.languageDetectRe.exec(classes);
      if (match) {
        const language = getLanguage(match[1]);
        if (!language) {
          warn$1(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
          warn$1("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match[1] : "no-highlight";
      }
      return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrLanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrLanguageName;
        code = optionsOrCode;
      }
      if (ignoreIllegals === void 0) {
        ignoreIllegals = true;
      }
      const context = {
        code,
        language: languageName
      };
      fire("before:highlight", context);
      const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
      result.code = context.code;
      fire("after:highlight", result);
      return result;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      const keywordHits = Object.create(null);
      function keywordData(mode, matchText) {
        return mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top.keywordPatternRe.lastIndex = 0;
        let match = top.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match) {
          buf += modeBuffer.substring(lastIndex, match.index);
          const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
          const data = keywordData(top, word);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            keywordHits[word] = (keywordHits[word] || 0) + 1;
            if (keywordHits[word] <= MAX_KEYWORD_HITS)
              relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match[0], cssClass);
            }
          } else {
            buf += match[0];
          }
          lastIndex = top.keywordPatternRe.lastIndex;
          match = top.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "")
          return;
        let result2 = null;
        if (typeof top.subLanguage === "string") {
          if (!languages[top.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
          continuations[top.subLanguage] = result2._top;
        } else {
          result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
        }
        if (top.relevance > 0) {
          relevance += result2.relevance;
        }
        emitter.addSublanguage(result2._emitter, result2.language);
      }
      function processBuffer() {
        if (top.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = "";
      }
      function emitMultiClass(scope, match) {
        let i2 = 1;
        while (match[i2] !== void 0) {
          if (!scope._emit[i2]) {
            i2++;
            continue;
          }
          const klass = language.classNameAliases[scope[i2]] || scope[i2];
          const text = match[i2];
          if (klass) {
            emitter.addKeyword(text, klass);
          } else {
            modeBuffer = text;
            processKeywords();
            modeBuffer = "";
          }
          i2++;
        }
      }
      function startNewMode(mode, match) {
        if (mode.scope && typeof mode.scope === "string") {
          emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
        }
        if (mode.beginScope) {
          if (mode.beginScope._wrap) {
            emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
            modeBuffer = "";
          } else if (mode.beginScope._multi) {
            emitMultiClass(mode.beginScope, match);
            modeBuffer = "";
          }
        }
        top = Object.create(mode, {parent: {value: top}});
        return top;
      }
      function endOfMode(mode, match, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match, resp);
            if (resp.isMatchIgnored)
              matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match) {
        const lexeme = match[0];
        const newMode = match.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb2 of beforeCallbacks) {
          if (!cb2)
            continue;
          cb2(match, resp);
          if (resp.isMatchIgnored)
            return doIgnore(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode, match);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match) {
        const lexeme = match[0];
        const matchPlusRemainder = codeToHighlight.substr(match.index);
        const endMode = endOfMode(top, match, matchPlusRemainder);
        if (!endMode) {
          return NO_MATCH;
        }
        const origin = top;
        if (top.endScope && top.endScope._wrap) {
          processBuffer();
          emitter.addKeyword(lexeme, top.endScope._wrap);
        } else if (top.endScope && top.endScope._multi) {
          processBuffer();
          emitMultiClass(top.endScope, match);
        } else if (origin.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top.scope && !top.isMultiClass) {
            emitter.closeNode();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== endMode.parent);
        if (endMode.starts) {
          startNewMode(endMode.starts, match);
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top; current !== language; current = current.parent) {
          if (current.scope) {
            list.unshift(current.scope);
          }
        }
        list.forEach((item) => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match) {
        const lexeme = match && match[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
          if (!SAFE_MODE) {
            const err = new Error(`0 width match regex (${languageName})`);
            err.languageName = languageName;
            err.badRule = lastMatch.rule;
            throw err;
          }
          return 1;
        }
        lastMatch = match;
        if (match.type === "begin") {
          return doBeginMatch(match);
        } else if (match.type === "illegal" && !ignoreIllegals) {
          const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
          err.mode = top;
          throw err;
        } else if (match.type === "end") {
          const processed = doEndMatch(match);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 1e5 && iterations > match.index * 3) {
          const err = new Error("potential infinite loop, way more iterations than matches");
          throw err;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md2 = compileLanguage(language);
      let result = "";
      let top = continuation || md2;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = "";
      let relevance = 0;
      let index = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match = top.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index));
        emitter.closeAllNodes();
        emitter.finalize();
        result = emitter.toHTML();
        return {
          language: languageName,
          value: result,
          relevance,
          illegal: false,
          _emitter: emitter,
          _top: top
        };
      } catch (err) {
        if (err.message && err.message.includes("Illegal")) {
          return {
            language: languageName,
            value: escape$1(codeToHighlight),
            illegal: true,
            relevance: 0,
            _illegalBy: {
              message: err.message,
              index,
              context: codeToHighlight.slice(index - 100, index + 100),
              mode: err.mode,
              resultSoFar: result
            },
            _emitter: emitter
          };
        } else if (SAFE_MODE) {
          return {
            language: languageName,
            value: escape$1(codeToHighlight),
            illegal: false,
            relevance: 0,
            errorRaised: err,
            _emitter: emitter,
            _top: top
          };
        } else {
          throw err;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result = {
        value: escape$1(code),
        illegal: false,
        relevance: 0,
        _top: PLAINTEXT_LANGUAGE,
        _emitter: new options.__emitter(options)
      };
      result._emitter.addText(code);
      return result;
    }
    function highlightAuto(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
      results.unshift(plaintext);
      const sorted = results.sort((a2, b2) => {
        if (a2.relevance !== b2.relevance)
          return b2.relevance - a2.relevance;
        if (a2.language && b2.language) {
          if (getLanguage(a2.language).supersetOf === b2.language) {
            return 1;
          } else if (getLanguage(b2.language).supersetOf === a2.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result = best;
      result.secondBest = secondBest;
      return result;
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang && aliases[currentLang] || resultLang;
      element.classList.add("hljs");
      element.classList.add(`language-${language}`);
    }
    function highlightElement(element) {
      let node = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language))
        return;
      fire("before:highlightElement", {el: element, language});
      if (!options.ignoreUnescapedHTML && element.children.length > 0) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/issues/2886");
        console.warn(element);
      }
      node = element;
      const text = node.textContent;
      const result = language ? highlight2(text, {language, ignoreIllegals: true}) : highlightAuto(text);
      element.innerHTML = result.value;
      updateClassName(element, language, result.language);
      element.result = {
        language: result.language,
        re: result.relevance,
        relevance: result.relevance
      };
      if (result.secondBest) {
        element.secondBest = {
          language: result.secondBest.language,
          relevance: result.secondBest.relevance
        };
      }
      fire("after:highlightElement", {el: element, result, text});
    }
    function configure(userOptions) {
      options = inherit(options, userOptions);
    }
    const initHighlighting = () => {
      highlightAll();
      deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function initHighlightingOnLoad() {
      highlightAll();
      deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll(options.cssSelector);
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight)
        highlightAll();
    }
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", boot, false);
    }
    function registerLanguage(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs);
      } catch (error$1) {
        error("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) {
          throw error$1;
        } else {
          error(error$1);
        }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name)
        lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs);
      if (lang.aliases) {
        registerAliases(lang.aliases, {languageName});
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases)) {
        if (aliases[alias] === languageName) {
          delete aliases[alias];
        }
      }
    }
    function listLanguages() {
      return Object.keys(languages);
    }
    function getLanguage(name) {
      name = (name || "").toLowerCase();
      return languages[name] || languages[aliases[name]];
    }
    function registerAliases(aliasList, {languageName}) {
      if (typeof aliasList === "string") {
        aliasList = [aliasList];
      }
      aliasList.forEach((alias) => {
        aliases[alias.toLowerCase()] = languageName;
      });
    }
    function autoDetection(name) {
      const lang = getLanguage(name);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](Object.assign({block: data.el}, data));
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](Object.assign({block: data.el}, data));
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event, args) {
      const cb2 = event;
      plugins.forEach(function(plugin) {
        if (plugin[cb2]) {
          plugin[cb2](args);
        }
      });
    }
    function deprecateHighlightBlock(el2) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el2);
    }
    Object.assign(hljs, {
      highlight: highlight2,
      highlightAuto,
      highlightAll,
      highlightElement,
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage,
      unregisterLanguage,
      listLanguages,
      getLanguage,
      registerAliases,
      autoDetection,
      inherit,
      addPlugin
    });
    hljs.debugMode = function() {
      SAFE_MODE = false;
    };
    hljs.safeMode = function() {
      SAFE_MODE = true;
    };
    hljs.versionString = version;
    for (const key in MODES$1) {
      if (typeof MODES$1[key] === "object") {
        deepFreeze$1(MODES$1[key]);
      }
    }
    Object.assign(hljs, MODES$1);
    return hljs;
  };
  var highlight = HLJS({});
  var core = highlight;
  function source$3(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function concat$3(...args) {
    const joined = args.map((x2) => source$3(x2)).join("");
    return joined;
  }
  function bash(hljs) {
    const VAR = {};
    const BRACED_VAR = {
      begin: /\$\{/,
      end: /\}/,
      contains: [
        "self",
        {
          begin: /:-/,
          contains: [VAR]
        }
      ]
    };
    Object.assign(VAR, {
      className: "variable",
      variants: [
        {begin: concat$3(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`)},
        BRACED_VAR
      ]
    });
    const SUBST = {
      className: "subst",
      begin: /\$\(/,
      end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    };
    const HERE_DOC = {
      begin: /<<-?\s*(?=\w+)/,
      starts: {
        contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ]
      }
    };
    const QUOTE_STRING = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        VAR,
        SUBST
      ]
    };
    SUBST.contains.push(QUOTE_STRING);
    const ESCAPED_QUOTE = {
      className: "",
      begin: /\\"/
    };
    const APOS_STRING = {
      className: "string",
      begin: /'/,
      end: /'/
    };
    const ARITHMETIC = {
      begin: /\$\(\(/,
      end: /\)\)/,
      contains: [
        {begin: /\d+#[0-9a-f]+/, className: "number"},
        hljs.NUMBER_MODE,
        VAR
      ]
    };
    const SH_LIKE_SHELLS = [
      "fish",
      "bash",
      "zsh",
      "sh",
      "csh",
      "ksh",
      "tcsh",
      "dash",
      "scsh"
    ];
    const KNOWN_SHEBANG = hljs.SHEBANG({
      binary: `(${SH_LIKE_SHELLS.join("|")})`,
      relevance: 10
    });
    const FUNCTION = {
      className: "function",
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\w[\w\d_]*/})],
      relevance: 0
    };
    const KEYWORDS2 = [
      "if",
      "then",
      "else",
      "elif",
      "fi",
      "for",
      "while",
      "in",
      "do",
      "done",
      "case",
      "esac",
      "function"
    ];
    const LITERALS2 = [
      "true",
      "false"
    ];
    return {
      name: "Bash",
      aliases: ["sh"],
      keywords: {
        $pattern: /\b[a-z._-]+\b/,
        keyword: KEYWORDS2,
        literal: LITERALS2,
        built_in: "break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp"
      },
      contains: [
        KNOWN_SHEBANG,
        hljs.SHEBANG(),
        FUNCTION,
        ARITHMETIC,
        hljs.HASH_COMMENT_MODE,
        HERE_DOC,
        QUOTE_STRING,
        ESCAPED_QUOTE,
        APOS_STRING,
        VAR
      ]
    };
  }
  const MODES = (hljs) => {
    return {
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      HEXCOLOR: {
        scope: "number",
        begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z][A-Za-z0-9_-]*/
      }
    };
  };
  const TAGS = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "p",
    "q",
    "quote",
    "samp",
    "section",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video"
  ];
  const MEDIA_FEATURES = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ];
  const PSEUDO_CLASSES = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
  ];
  const PSEUDO_ELEMENTS = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ];
  const ATTRIBUTES = [
    "align-content",
    "align-items",
    "align-self",
    "animation",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timing-function",
    "auto",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-repeat",
    "background-size",
    "border",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "clear",
    "clip",
    "clip-path",
    "color",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "content",
    "counter-increment",
    "counter-reset",
    "cursor",
    "direction",
    "display",
    "empty-cells",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-size",
    "font-size-adjust",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-variant-ligatures",
    "font-variation-settings",
    "font-weight",
    "height",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "inherit",
    "initial",
    "justify-content",
    "left",
    "letter-spacing",
    "line-height",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "marks",
    "mask",
    "max-height",
    "max-width",
    "min-height",
    "min-width",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "perspective",
    "perspective-origin",
    "pointer-events",
    "position",
    "quotes",
    "resize",
    "right",
    "src",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-last",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-style",
    "text-indent",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-transform",
    "text-underline-position",
    "top",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "unicode-bidi",
    "vertical-align",
    "visibility",
    "white-space",
    "widows",
    "width",
    "word-break",
    "word-spacing",
    "word-wrap",
    "z-index"
  ].reverse();
  function source$2(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function lookahead$2(re2) {
    return concat$2("(?=", re2, ")");
  }
  function concat$2(...args) {
    const joined = args.map((x2) => source$2(x2)).join("");
    return joined;
  }
  function css(hljs) {
    const modes = MODES(hljs);
    const FUNCTION_DISPATCH = {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    };
    const VENDOR_PREFIX = {
      begin: /-(webkit|moz|ms|o)-(?=[a-z])/
    };
    const AT_MODIFIERS = "and or not only";
    const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
    const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
    const STRINGS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ];
    return {
      name: "CSS",
      case_insensitive: true,
      illegal: /[=|'\$]/,
      keywords: {
        keyframePosition: "from to"
      },
      classNameAliases: {
        keyframePosition: "selector-tag"
      },
      contains: [
        hljs.C_BLOCK_COMMENT_MODE,
        VENDOR_PREFIX,
        modes.CSS_NUMBER_MODE,
        {
          className: "selector-id",
          begin: /#[A-Za-z0-9_-]+/,
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\." + IDENT_RE2,
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-pseudo",
          variants: [
            {
              begin: ":(" + PSEUDO_CLASSES.join("|") + ")"
            },
            {
              begin: "::(" + PSEUDO_ELEMENTS.join("|") + ")"
            }
          ]
        },
        modes.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
        },
        {
          begin: ":",
          end: "[;}]",
          contains: [
            modes.HEXCOLOR,
            modes.IMPORTANT,
            modes.CSS_NUMBER_MODE,
            ...STRINGS,
            {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              keywords: {
                built_in: "url data-uri"
              },
              contains: [
                {
                  className: "string",
                  begin: /[^)]/,
                  endsWithParent: true,
                  excludeEnd: true
                }
              ]
            },
            FUNCTION_DISPATCH
          ]
        },
        {
          begin: lookahead$2(/@/),
          end: "[{;]",
          relevance: 0,
          illegal: /:/,
          contains: [
            {
              className: "keyword",
              begin: AT_PROPERTY_RE
            },
            {
              begin: /\s/,
              endsWithParent: true,
              excludeEnd: true,
              relevance: 0,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: AT_MODIFIERS,
                attribute: MEDIA_FEATURES.join(" ")
              },
              contains: [
                {
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                },
                ...STRINGS,
                modes.CSS_NUMBER_MODE
              ]
            }
          ]
        },
        {
          className: "selector-tag",
          begin: "\\b(" + TAGS.join("|") + ")\\b"
        }
      ]
    };
  }
  const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  const KEYWORDS = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES = [
    "Intl",
    "DataView",
    "Number",
    "Math",
    "Date",
    "String",
    "RegExp",
    "Object",
    "Function",
    "Boolean",
    "Error",
    "Symbol",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "Proxy",
    "Reflect",
    "JSON",
    "Promise",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Float32Array",
    "Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "ArrayBuffer",
    "BigInt64Array",
    "BigUint64Array",
    "BigInt"
  ];
  const ERROR_TYPES = [
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
  ];
  const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
  function source$1(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function lookahead$1(re2) {
    return concat$1("(?=", re2, ")");
  }
  function concat$1(...args) {
    const joined = args.map((x2) => source$1(x2)).join("");
    return joined;
  }
  function javascript(hljs) {
    const hasClosingTag = (match, {after}) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$12 = IDENT_RE;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (nextChar === "<") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, {after: afterMatchIndex})) {
            response.ignoreMatch();
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS,
      "variable.language": BUILT_IN_VARIABLES
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: "number",
      variants: [
        {begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`},
        {begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`},
        {begin: `\\b(0|[1-9](_?[0-9])*)n\\b`},
        {begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},
        {begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"},
        {begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"},
        {begin: "\\b0[0-7]+n?\\b"}
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
    };
    const HTML_TEMPLATE = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    });
    const COMMENT2 = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER,
      hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    const CLASS_OR_EXTENDS = {
      variants: [
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$12
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        },
        {
          match: [
            /extends/,
            /\s+/,
            concat$1(IDENT_RE$12, "(", concat$1(/\./, IDENT_RE$12), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class.inherited"
          }
        }
      ]
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: /\b[A-Z][a-z]+([A-Z][a-z]+)*/,
      className: "title.class",
      keywords: {
        _: [
          ...TYPES,
          ...ERROR_TYPES
        ]
      }
    };
    const USE_STRICT = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    };
    const FUNCTION_DEFINITION = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            IDENT_RE$12,
            /(?=\s*\()/
          ]
        },
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [PARAMS],
      illegal: /%/
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function noneOf(list) {
      return concat$1("(?!", list.join("|"), ")");
    }
    const FUNCTION_CALL = {
      match: concat$1(/\b/, noneOf([
        ...BUILT_IN_GLOBALS,
        "super"
      ]), IDENT_RE$12, lookahead$1(/\(/)),
      className: "title.function",
      relevance: 0
    };
    const PROPERTY_ACCESS = {
      begin: concat$1(/\./, lookahead$1(concat$1(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
      end: IDENT_RE$12,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    };
    const GETTER_OR_SETTER = {
      match: [
        /get|set/,
        /\s+/,
        IDENT_RE$12,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          begin: /\(\)/
        },
        PARAMS
      ]
    };
    const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
    const FUNCTION_VARIABLE = {
      match: [
        /const|var|let/,
        /\s+/,
        IDENT_RE$12,
        /\s*/,
        /=\s*/,
        lookahead$1(FUNC_LEAD_IN_RE)
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      exports: {PARAMS_CONTAINS},
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        USE_STRICT,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT2,
        NUMBER,
        CLASS_REFERENCE,
        {
          className: "attr",
          begin: IDENT_RE$12 + lookahead$1(":"),
          relevance: 0
        },
        FUNCTION_VARIABLE,
        {
          begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            COMMENT2,
            hljs.REGEXP_MODE,
            {
              className: "function",
              begin: FUNC_LEAD_IN_RE,
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              variants: [
                {begin: FRAGMENT.begin, end: FRAGMENT.end},
                {
                  begin: XML_TAG.begin,
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        FUNCTION_DEFINITION,
        {
          beginKeywords: "while if switch catch for"
        },
        {
          begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          returnBegin: true,
          label: "func.def",
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, {begin: IDENT_RE$12, className: "title.function"})
          ]
        },
        {
          match: /\.\.\./,
          relevance: 0
        },
        PROPERTY_ACCESS,
        {
          match: "\\$" + IDENT_RE$12,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: {1: "title.function"},
          contains: [PARAMS]
        },
        FUNCTION_CALL,
        UPPER_CASE_CONSTANT,
        CLASS_OR_EXTENDS,
        GETTER_OR_SETTER,
        {
          match: /\$[(.]/
        }
      ]
    };
  }
  function php(hljs) {
    const VARIABLE = {
      className: "variable",
      begin: `\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])`
    };
    const PREPROCESSOR = {
      className: "meta",
      variants: [
        {begin: /<\?php/, relevance: 10},
        {begin: /<\?[=]?/},
        {begin: /\?>/}
      ]
    };
    const SUBST = {
      className: "subst",
      variants: [
        {begin: /\$\w+/},
        {begin: /\{\$/, end: /\}/}
      ]
    };
    const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
      illegal: null
    });
    const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      illegal: null,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
    });
    const HEREDOC = hljs.END_SAME_AS_BEGIN({
      begin: /<<<[ \t]*(\w+)\n/,
      end: /[ \t]*(\w+)\b/,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
    });
    const STRING = {
      className: "string",
      contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
      variants: [
        hljs.inherit(SINGLE_QUOTED, {
          begin: "b'",
          end: "'"
        }),
        hljs.inherit(DOUBLE_QUOTED, {
          begin: 'b"',
          end: '"'
        }),
        DOUBLE_QUOTED,
        SINGLE_QUOTED,
        HEREDOC
      ]
    };
    const NUMBER = {
      className: "number",
      variants: [
        {begin: `\\b0b[01]+(?:_[01]+)*\\b`},
        {begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b`},
        {begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b`},
        {begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?`}
      ],
      relevance: 0
    };
    const KEYWORDS2 = {
      keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield",
      literal: "false null true",
      built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass"
    };
    return {
      case_insensitive: true,
      keywords: KEYWORDS2,
      contains: [
        hljs.HASH_COMMENT_MODE,
        hljs.COMMENT("//", "$", {contains: [PREPROCESSOR]}),
        hljs.COMMENT("/\\*", "\\*/", {
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }),
        hljs.COMMENT("__halt_compiler.+?;", false, {
          endsWithParent: true,
          keywords: "__halt_compiler"
        }),
        PREPROCESSOR,
        {
          className: "keyword",
          begin: /\$this\b/
        },
        VARIABLE,
        {
          begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
        },
        {
          className: "function",
          relevance: 0,
          beginKeywords: "fn function",
          end: /[;{]/,
          excludeEnd: true,
          illegal: "[$%\\[]",
          contains: [
            {
              beginKeywords: "use"
            },
            hljs.UNDERSCORE_TITLE_MODE,
            {
              begin: "=>",
              endsParent: true
            },
            {
              className: "params",
              begin: "\\(",
              end: "\\)",
              excludeBegin: true,
              excludeEnd: true,
              keywords: KEYWORDS2,
              contains: [
                "self",
                VARIABLE,
                hljs.C_BLOCK_COMMENT_MODE,
                STRING,
                NUMBER
              ]
            }
          ]
        },
        {
          className: "class",
          variants: [
            {beginKeywords: "enum", illegal: /[($"]/},
            {beginKeywords: "class interface trait", illegal: /[:($"]/}
          ],
          relevance: 0,
          end: /\{/,
          excludeEnd: true,
          contains: [
            {beginKeywords: "extends implements"},
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          beginKeywords: "namespace",
          relevance: 0,
          end: ";",
          illegal: /[.']/,
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        {
          beginKeywords: "use",
          relevance: 0,
          end: ";",
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        STRING,
        NUMBER
      ]
    };
  }
  function source(re2) {
    if (!re2)
      return null;
    if (typeof re2 === "string")
      return re2;
    return re2.source;
  }
  function lookahead(re2) {
    return concat("(?=", re2, ")");
  }
  function optional(re2) {
    return concat("(?:", re2, ")?");
  }
  function concat(...args) {
    const joined = args.map((x2) => source(x2)).join("");
    return joined;
  }
  function stripOptionsFromArgs(args) {
    const opts = args[args.length - 1];
    if (typeof opts === "object" && opts.constructor === Object) {
      args.splice(args.length - 1, 1);
      return opts;
    } else {
      return {};
    }
  }
  function either(...args) {
    const opts = stripOptionsFromArgs(args);
    const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
    return joined;
  }
  function xml(hljs) {
    const TAG_NAME_RE = concat(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
    const XML_ENTITIES = {
      className: "symbol",
      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
    };
    const XML_META_KEYWORDS = {
      begin: /\s/,
      contains: [
        {
          className: "keyword",
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }
      ]
    };
    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
      begin: /\(/,
      end: /\)/
    });
    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
      className: "string"
    });
    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      className: "string"
    });
    const TAG_INTERNALS = {
      endsWithParent: true,
      illegal: /</,
      relevance: 0,
      contains: [
        {
          className: "attr",
          begin: XML_IDENT_RE,
          relevance: 0
        },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: "string",
              endsParent: true,
              variants: [
                {
                  begin: /"/,
                  end: /"/,
                  contains: [XML_ENTITIES]
                },
                {
                  begin: /'/,
                  end: /'/,
                  contains: [XML_ENTITIES]
                },
                {
                  begin: /[^\s"'=<>`]+/
                }
              ]
            }
          ]
        }
      ]
    };
    return {
      name: "HTML, XML",
      aliases: [
        "html",
        "xhtml",
        "rss",
        "atom",
        "xjb",
        "xsd",
        "xsl",
        "plist",
        "wsf",
        "svg"
      ],
      case_insensitive: true,
      contains: [
        {
          className: "meta",
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            XML_META_KEYWORDS,
            QUOTE_META_STRING_MODE,
            APOS_META_STRING_MODE,
            XML_META_PAR_KEYWORDS,
            {
              begin: /\[/,
              end: /\]/,
              contains: [
                {
                  className: "meta",
                  begin: /<![a-z]/,
                  end: />/,
                  contains: [
                    XML_META_KEYWORDS,
                    XML_META_PAR_KEYWORDS,
                    QUOTE_META_STRING_MODE,
                    APOS_META_STRING_MODE
                  ]
                }
              ]
            }
          ]
        },
        hljs.COMMENT(/<!--/, /-->/, {
          relevance: 10
        }),
        {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        },
        XML_ENTITIES,
        {
          className: "meta",
          begin: /<\?xml/,
          end: /\?>/,
          relevance: 10
        },
        {
          className: "tag",
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: {
            name: "style"
          },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/style>/,
            returnEnd: true,
            subLanguage: [
              "css",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: {
            name: "script"
          },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/script>/,
            returnEnd: true,
            subLanguage: [
              "javascript",
              "handlebars",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          begin: /<>|<\/>/
        },
        {
          className: "tag",
          begin: concat(/</, lookahead(concat(TAG_NAME_RE, either(/\/>/, />/, /\s/)))),
          end: /\/?>/,
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0,
              starts: TAG_INTERNALS
            }
          ]
        },
        {
          className: "tag",
          begin: concat(/<\//, lookahead(concat(TAG_NAME_RE, />/))),
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0
            },
            {
              begin: />/,
              relevance: 0,
              endsParent: true
            }
          ]
        }
      ]
    };
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const standardProperty$1 = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty$1 = (options, proto, name) => {
    proto.constructor.createProperty(name, options);
  };
  function property$1(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty$1(options, protoOrDescriptor, name) : standardProperty$1(options, protoOrDescriptor);
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const decorateProperty$1 = ({finisher, descriptor}) => (protoOrDescriptor, name) => {
    var _a2;
    if (name !== void 0) {
      const ctor = protoOrDescriptor.constructor;
      if (descriptor !== void 0) {
        Object.defineProperty(protoOrDescriptor, name, descriptor(name));
      }
      finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
    } else {
      const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
      const info = descriptor != void 0 ? {
        kind: "method",
        placement: "prototype",
        key,
        descriptor: descriptor(protoOrDescriptor.key)
      } : __spreadProps(__spreadValues({}, protoOrDescriptor), {key});
      if (finisher != void 0) {
        info.finisher = function(ctor) {
          finisher(ctor, key);
        };
      }
      return info;
    }
  };
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  function query(selector, cache) {
    return decorateProperty$1({
      descriptor: (name) => {
        const descriptor = {
          get() {
            var _a2;
            return (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
          },
          enumerable: true,
          configurable: true
        };
        if (cache) {
          const key = typeof name === "symbol" ? Symbol() : `__${name}`;
          descriptor.get = function() {
            var _a2;
            if (this[key] === void 0) {
              this[key] = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
            }
            return this[key];
          };
        }
        return descriptor;
      }
    });
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const ElementProto = Element.prototype;
  const legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
  function queryAssignedNodes(slotName = "", flatten = false, selector = "") {
    return decorateProperty$1({
      descriptor: (_name) => ({
        get() {
          var _a2, _b2;
          const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
          const slot = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(slotSelector);
          let nodes = (_b2 = slot) === null || _b2 === void 0 ? void 0 : _b2.assignedNodes({flatten});
          if (nodes && selector) {
            nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && (node.matches ? node.matches(selector) : legacyMatches.call(node, selector)));
          }
          return nodes;
        },
        enumerable: true,
        configurable: true
      })
    });
  }
  function decodeHtmlEntities(string) {
    const txt = document.createElement("textarea");
    txt.innerHTML = string;
    return txt.value;
  }
  var __css$6 = ".hljs {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-ui-code-paddingBlock, 3rem) var(--s-theme-ui-code-paddingInline, 3rem);\n    background-color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-30-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-30-lightness-offset, 0)) * 1%),var(--s-theme-color-text-30-a, 1));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),1);\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n    z-index: 1;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n}\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    position: relative;\n    --paddingBlock: var(--s-theme-ui-code-paddingBlock, 3rem);\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(1.5em * var(--max-lines) + (var(--paddingBlock) * 2));\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n:not([bare]) .s-code-example__content {\n    transition: var(--s-theme-ui-code-transition, 0);\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);box-shadow: var(--s-theme-ui-code-depth, 0);\n}\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n:not([bare]) .s-code-example__more-bar {\n    text-align: center;\n    padding-inline: var(--s-theme-ui-default-paddingInline, 1.5em);\n    padding-block: var(--s-theme-ui-default-paddingBlock, 0.75em);\n    justify-content: center;\n}\n:not([bare]) .s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;background: linear-gradient(0deg, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1)) 0%, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-lightness-offset, 0)) * 1%),0) 100%);\n    }\n\n.s-code-example__code {\n    display: none;\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    /* transform: translate(0, -50%); */\n}\n";
  class SCodeExampleInterface extends SInterface {
  }
  SCodeExampleInterface.definition = {
    theme: {
      description: "Specify the theme you want to use for your code example",
      type: "String",
      default: "https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css"
    },
    active: {
      type: "String"
    },
    toolbar: {
      type: "Array<String>",
      values: ["copy"],
      default: ["copy"]
    },
    toolbarPosition: {
      type: "String",
      values: ["content", "nav"],
      default: "nav"
    },
    languages: {
      type: "Object",
      default: {}
    },
    lines: {
      type: "Number"
    },
    moreLabel: {
      type: "String",
      default: "Show more"
    },
    lessLabel: {
      type: "String",
      default: "Show less"
    },
    moreAction: {
      type: "String",
      default: "toggle"
    },
    more: {
      type: "Boolean",
      default: false
    }
  };
  var e$3 = {version: "2.4.1"}, t$3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function n$3(e20) {
    return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
  }
  function r$3(e20) {
    var t2 = {exports: {}};
    return e20(t2, t2.exports), t2.exports;
  }
  var i$3 = r$3(function(e20, t2) {
    function n2() {
    }
    function r2(e21, t3, n3, r3, i3) {
      for (var u2 = 0, o2 = t3.length, s2 = 0, a2 = 0; u2 < o2; u2++) {
        var c2 = t3[u2];
        if (c2.removed) {
          if (c2.value = e21.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, u2 && t3[u2 - 1].added) {
            var l2 = t3[u2 - 1];
            t3[u2 - 1] = t3[u2], t3[u2] = l2;
          }
        } else {
          if (!c2.added && i3) {
            var p2 = n3.slice(s2, s2 + c2.count);
            p2 = p2.map(function(e22, t4) {
              var n4 = r3[a2 + t4];
              return n4.length > e22.length ? n4 : e22;
            }), c2.value = e21.join(p2);
          } else
            c2.value = e21.join(n3.slice(s2, s2 + c2.count));
          s2 += c2.count, c2.added || (a2 += c2.count);
        }
      }
      var f2 = t3[o2 - 1];
      return o2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e21.equals("", f2.value) && (t3[o2 - 2].value += f2.value, t3.pop()), t3;
    }
    function i2(e21) {
      return {newPos: e21.newPos, components: e21.components.slice(0)};
    }
    Object.defineProperty(t2, "__esModule", {value: true}), t2.default = n2, n2.prototype = {diff: function(e21, t3) {
      var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = n3.callback;
      typeof n3 == "function" && (u2 = n3, n3 = {}), this.options = n3;
      var o2 = this;
      function s2(e22) {
        return u2 ? (setTimeout(function() {
          u2(void 0, e22);
        }, 0), true) : e22;
      }
      e21 = this.castInput(e21), t3 = this.castInput(t3), e21 = this.removeEmpty(this.tokenize(e21));
      var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e21.length, l2 = 1, p2 = a2 + c2, f2 = [{newPos: -1, components: []}], d2 = this.extractCommon(f2[0], t3, e21, 0);
      if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
        return s2([{value: this.join(t3), count: t3.length}]);
      function h2() {
        for (var n4 = -1 * l2; n4 <= l2; n4 += 2) {
          var u3 = void 0, p3 = f2[n4 - 1], d3 = f2[n4 + 1], h3 = (d3 ? d3.newPos : 0) - n4;
          p3 && (f2[n4 - 1] = void 0);
          var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
          if (g3 || m2) {
            if (!g3 || m2 && p3.newPos < d3.newPos ? (u3 = i2(d3), o2.pushComponent(u3.components, void 0, true)) : ((u3 = p3).newPos++, o2.pushComponent(u3.components, true, void 0)), h3 = o2.extractCommon(u3, t3, e21, n4), u3.newPos + 1 >= a2 && h3 + 1 >= c2)
              return s2(r2(o2, u3.components, t3, e21, o2.useLongestToken));
            f2[n4] = u3;
          } else
            f2[n4] = void 0;
        }
        l2++;
      }
      if (u2)
        !function e22() {
          setTimeout(function() {
            if (l2 > p2)
              return u2();
            h2() || e22();
          }, 0);
        }();
      else
        for (; l2 <= p2; ) {
          var g2 = h2();
          if (g2)
            return g2;
        }
    }, pushComponent: function(e21, t3, n3) {
      var r3 = e21[e21.length - 1];
      r3 && r3.added === t3 && r3.removed === n3 ? e21[e21.length - 1] = {count: r3.count + 1, added: t3, removed: n3} : e21.push({count: 1, added: t3, removed: n3});
    }, extractCommon: function(e21, t3, n3, r3) {
      for (var i3 = t3.length, u2 = n3.length, o2 = e21.newPos, s2 = o2 - r3, a2 = 0; o2 + 1 < i3 && s2 + 1 < u2 && this.equals(t3[o2 + 1], n3[s2 + 1]); )
        o2++, s2++, a2++;
      return a2 && e21.components.push({count: a2}), e21.newPos = o2, s2;
    }, equals: function(e21, t3) {
      return this.options.comparator ? this.options.comparator(e21, t3) : e21 === t3 || this.options.ignoreCase && e21.toLowerCase() === t3.toLowerCase();
    }, removeEmpty: function(e21) {
      for (var t3 = [], n3 = 0; n3 < e21.length; n3++)
        e21[n3] && t3.push(e21[n3]);
      return t3;
    }, castInput: function(e21) {
      return e21;
    }, tokenize: function(e21) {
      return e21.split("");
    }, join: function(e21) {
      return e21.join("");
    }};
  }), u$3 = r$3(function(e20, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffChars = function(e21, t3, n3) {
      return r2.diff(e21, t3, n3);
    }, t2.characterDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
    t2.characterDiff = r2;
  }), o$3 = function(e20, t2) {
    if (typeof e20 == "function")
      t2.callback = e20;
    else if (e20)
      for (var n2 in e20)
        e20.hasOwnProperty(n2) && (t2[n2] = e20[n2]);
    return t2;
  };
  var s$3, a$3, c$3 = Object.defineProperty({generateOptions: o$3}, "__esModule", {value: true}), l$3 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffWords = function(e21, t3, n3) {
      return n3 = (0, c$3.generateOptions)(n3, {ignoreWhitespace: true}), s2.diff(e21, t3, n3);
    }, t2.diffWordsWithSpace = function(e21, t3, n3) {
      return s2.diff(e21, t3, n3);
    }, t2.wordDiff = void 0;
    var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : {default: n2};
    var u2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o2 = /\S/, s2 = new r2.default();
    t2.wordDiff = s2, s2.equals = function(e21, t3) {
      return this.options.ignoreCase && (e21 = e21.toLowerCase(), t3 = t3.toLowerCase()), e21 === t3 || this.options.ignoreWhitespace && !o2.test(e21) && !o2.test(t3);
    }, s2.tokenize = function(e21) {
      for (var t3 = e21.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n3 = 0; n3 < t3.length - 1; n3++)
        !t3[n3 + 1] && t3[n3 + 2] && u2.test(t3[n3]) && u2.test(t3[n3 + 2]) && (t3[n3] += t3[n3 + 2], t3.splice(n3 + 1, 2), n3--);
      return t3;
    };
  }), p$3 = r$3(function(e20, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffLines = function(e21, t3, n3) {
      return r2.diff(e21, t3, n3);
    }, t2.diffTrimmedLines = function(e21, t3, n3) {
      var i2 = (0, c$3.generateOptions)(n3, {ignoreWhitespace: true});
      return r2.diff(e21, t3, i2);
    }, t2.lineDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
    t2.lineDiff = r2, r2.tokenize = function(e21) {
      var t3 = [], n3 = e21.split(/(\n|\r\n)/);
      n3[n3.length - 1] || n3.pop();
      for (var r3 = 0; r3 < n3.length; r3++) {
        var i2 = n3[r3];
        r3 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += i2 : (this.options.ignoreWhitespace && (i2 = i2.trim()), t3.push(i2));
      }
      return t3;
    };
  }), f$3 = r$3(function(e20, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffSentences = function(e21, t3, n3) {
      return r2.diff(e21, t3, n3);
    }, t2.sentenceDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
    t2.sentenceDiff = r2, r2.tokenize = function(e21) {
      return e21.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
  }), d$3 = r$3(function(e20, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffCss = function(e21, t3, n3) {
      return r2.diff(e21, t3, n3);
    }, t2.cssDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
    t2.cssDiff = r2, r2.tokenize = function(e21) {
      return e21.split(/([{}:;,]|\s+)/);
    };
  }), h$3 = function(e20) {
    return e20 && e20.Math == Math && e20;
  }, g$3 = h$3(typeof globalThis == "object" && globalThis) || h$3(typeof window == "object" && window) || h$3(typeof self == "object" && self) || h$3(typeof t$3 == "object" && t$3) || function() {
    return this;
  }() || Function("return this")(), m$3 = function(e20) {
    try {
      return !!e20();
    } catch (e21) {
      return true;
    }
  }, y$3 = !m$3(function() {
    return Object.defineProperty({}, 1, {get: function() {
      return 7;
    }})[1] != 7;
  }), D$3 = {}.propertyIsEnumerable, E$3 = Object.getOwnPropertyDescriptor, C$3 = {f: E$3 && !D$3.call({1: 2}, 1) ? function(e20) {
    var t2 = E$3(this, e20);
    return !!t2 && t2.enumerable;
  } : D$3}, b$3 = function(e20, t2) {
    return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
  }, A$3 = {}.toString, v$3 = function(e20) {
    return A$3.call(e20).slice(8, -1);
  }, F$3 = "".split, S$3 = m$3(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e20) {
    return v$3(e20) == "String" ? F$3.call(e20, "") : Object(e20);
  } : Object, x$3 = function(e20) {
    if (e20 == null)
      throw TypeError("Can't call method on " + e20);
    return e20;
  }, w$3 = function(e20) {
    return S$3(x$3(e20));
  }, T$3 = function(e20) {
    return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
  }, B$3 = function(e20) {
    return typeof e20 == "function" ? e20 : void 0;
  }, N$3 = function(e20, t2) {
    return arguments.length < 2 ? B$3(g$3[e20]) : g$3[e20] && g$3[e20][t2];
  }, k$3 = N$3("navigator", "userAgent") || "", P$3 = g$3.process, O$3 = g$3.Deno, I$3 = P$3 && P$3.versions || O$3 && O$3.version, L$3 = I$3 && I$3.v8;
  L$3 ? a$3 = (s$3 = L$3.split("."))[0] < 4 ? 1 : s$3[0] + s$3[1] : k$3 && (!(s$3 = k$3.match(/Edge\/(\d+)/)) || s$3[1] >= 74) && (s$3 = k$3.match(/Chrome\/(\d+)/)) && (a$3 = s$3[1]);
  var j$3 = a$3 && +a$3, _$3 = !!Object.getOwnPropertySymbols && !m$3(function() {
    var e20 = Symbol();
    return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && j$3 && j$3 < 41;
  }), M$3 = _$3 && !Symbol.sham && typeof Symbol.iterator == "symbol", R$3 = M$3 ? function(e20) {
    return typeof e20 == "symbol";
  } : function(e20) {
    var t2 = N$3("Symbol");
    return typeof t2 == "function" && Object(e20) instanceof t2;
  }, $$3 = function(e20, t2) {
    try {
      Object.defineProperty(g$3, e20, {value: t2, configurable: true, writable: true});
    } catch (n2) {
      g$3[e20] = t2;
    }
    return t2;
  }, V$3 = g$3["__core-js_shared__"] || $$3("__core-js_shared__", {}), W$3 = r$3(function(e20) {
    (e20.exports = function(e21, t2) {
      return V$3[e21] || (V$3[e21] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
  }), q$3 = function(e20) {
    return Object(x$3(e20));
  }, U$3 = {}.hasOwnProperty, z$3 = Object.hasOwn || function(e20, t2) {
    return U$3.call(q$3(e20), t2);
  }, G$3 = 0, H$3 = Math.random(), J$3 = function(e20) {
    return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++G$3 + H$3).toString(36);
  }, X$3 = W$3("wks"), Y$3 = g$3.Symbol, K$3 = M$3 ? Y$3 : Y$3 && Y$3.withoutSetter || J$3, Q$3 = function(e20) {
    return z$3(X$3, e20) && (_$3 || typeof X$3[e20] == "string") || (_$3 && z$3(Y$3, e20) ? X$3[e20] = Y$3[e20] : X$3[e20] = K$3("Symbol." + e20)), X$3[e20];
  }, Z$3 = Q$3("toPrimitive"), ee$3 = function(e20, t2) {
    if (!T$3(e20) || R$3(e20))
      return e20;
    var n2, r2 = e20[Z$3];
    if (r2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), n2 = r2.call(e20, t2), !T$3(n2) || R$3(n2))
        return n2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e21, t3) {
      var n3, r3;
      if (t3 === "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
        return r3;
      if (typeof (n3 = e21.valueOf) == "function" && !T$3(r3 = n3.call(e21)))
        return r3;
      if (t3 !== "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
        return r3;
      throw TypeError("Can't convert object to primitive value");
    }(e20, t2);
  }, te$3 = function(e20) {
    var t2 = ee$3(e20, "string");
    return R$3(t2) ? t2 : String(t2);
  }, ne$3 = g$3.document, re$3 = T$3(ne$3) && T$3(ne$3.createElement), ie$3 = !y$3 && !m$3(function() {
    return Object.defineProperty((e20 = "div", re$3 ? ne$3.createElement(e20) : {}), "a", {get: function() {
      return 7;
    }}).a != 7;
    var e20;
  }), ue$3 = Object.getOwnPropertyDescriptor, oe$3 = {f: y$3 ? ue$3 : function(e20, t2) {
    if (e20 = w$3(e20), t2 = te$3(t2), ie$3)
      try {
        return ue$3(e20, t2);
      } catch (e21) {
      }
    if (z$3(e20, t2))
      return b$3(!C$3.f.call(e20, t2), e20[t2]);
  }}, se$3 = function(e20) {
    if (!T$3(e20))
      throw TypeError(String(e20) + " is not an object");
    return e20;
  }, ae$3 = Object.defineProperty, ce$3 = {f: y$3 ? ae$3 : function(e20, t2, n2) {
    if (se$3(e20), t2 = te$3(t2), se$3(n2), ie$3)
      try {
        return ae$3(e20, t2, n2);
      } catch (e21) {
      }
    if ("get" in n2 || "set" in n2)
      throw TypeError("Accessors not supported");
    return "value" in n2 && (e20[t2] = n2.value), e20;
  }}, le$3 = y$3 ? function(e20, t2, n2) {
    return ce$3.f(e20, t2, b$3(1, n2));
  } : function(e20, t2, n2) {
    return e20[t2] = n2, e20;
  }, pe$3 = Function.toString;
  typeof V$3.inspectSource != "function" && (V$3.inspectSource = function(e20) {
    return pe$3.call(e20);
  });
  var fe$3, de$3, he$3, ge$3, me$3 = V$3.inspectSource, ye$3 = g$3.WeakMap, De$3 = typeof ye$3 == "function" && /native code/.test(me$3(ye$3)), Ee$3 = W$3("keys"), Ce$3 = {}, be$3 = g$3.WeakMap;
  if (De$3 || V$3.state) {
    var Ae$3 = V$3.state || (V$3.state = new be$3()), ve$3 = Ae$3.get, Fe$3 = Ae$3.has, Se$3 = Ae$3.set;
    fe$3 = function(e20, t2) {
      if (Fe$3.call(Ae$3, e20))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, Se$3.call(Ae$3, e20, t2), t2;
    }, de$3 = function(e20) {
      return ve$3.call(Ae$3, e20) || {};
    }, he$3 = function(e20) {
      return Fe$3.call(Ae$3, e20);
    };
  } else {
    var xe$3 = Ee$3[ge$3 = "state"] || (Ee$3[ge$3] = J$3(ge$3));
    Ce$3[xe$3] = true, fe$3 = function(e20, t2) {
      if (z$3(e20, xe$3))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, le$3(e20, xe$3, t2), t2;
    }, de$3 = function(e20) {
      return z$3(e20, xe$3) ? e20[xe$3] : {};
    }, he$3 = function(e20) {
      return z$3(e20, xe$3);
    };
  }
  var we$3, Te$3, Be$3 = {set: fe$3, get: de$3, has: he$3, enforce: function(e20) {
    return he$3(e20) ? de$3(e20) : fe$3(e20, {});
  }, getterFor: function(e20) {
    return function(t2) {
      var n2;
      if (!T$3(t2) || (n2 = de$3(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return n2;
    };
  }}, Ne$3 = r$3(function(e20) {
    var t2 = Be$3.get, n2 = Be$3.enforce, r2 = String(String).split("String");
    (e20.exports = function(e21, t3, i2, u2) {
      var o2, s2 = !!u2 && !!u2.unsafe, a2 = !!u2 && !!u2.enumerable, c2 = !!u2 && !!u2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || z$3(i2, "name") || le$3(i2, "name", t3), (o2 = n2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== g$3 ? (s2 ? !c2 && e21[t3] && (a2 = true) : delete e21[t3], a2 ? e21[t3] = i2 : le$3(e21, t3, i2)) : a2 ? e21[t3] = i2 : $$3(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || me$3(this);
    });
  }), ke$3 = Math.ceil, Pe$3 = Math.floor, Oe$3 = function(e20) {
    return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Pe$3 : ke$3)(e20);
  }, Ie$3 = Math.min, Le$3 = function(e20) {
    return e20 > 0 ? Ie$3(Oe$3(e20), 9007199254740991) : 0;
  }, je$3 = Math.max, _e$3 = Math.min, Me$3 = function(e20) {
    return function(t2, n2, r2) {
      var i2, u2 = w$3(t2), o2 = Le$3(u2.length), s2 = function(e21, t3) {
        var n3 = Oe$3(e21);
        return n3 < 0 ? je$3(n3 + t3, 0) : _e$3(n3, t3);
      }(r2, o2);
      if (e20 && n2 != n2) {
        for (; o2 > s2; )
          if ((i2 = u2[s2++]) != i2)
            return true;
      } else
        for (; o2 > s2; s2++)
          if ((e20 || s2 in u2) && u2[s2] === n2)
            return e20 || s2 || 0;
      return !e20 && -1;
    };
  }, Re$3 = {includes: Me$3(true), indexOf: Me$3(false)}.indexOf, $e$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ve$3 = {f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var n2, r2 = w$3(e21), i2 = 0, u2 = [];
      for (n2 in r2)
        !z$3(Ce$3, n2) && z$3(r2, n2) && u2.push(n2);
      for (; t2.length > i2; )
        z$3(r2, n2 = t2[i2++]) && (~Re$3(u2, n2) || u2.push(n2));
      return u2;
    }(e20, $e$3);
  }}, We$3 = {f: Object.getOwnPropertySymbols}, qe$3 = N$3("Reflect", "ownKeys") || function(e20) {
    var t2 = Ve$3.f(se$3(e20)), n2 = We$3.f;
    return n2 ? t2.concat(n2(e20)) : t2;
  }, Ue$3 = function(e20, t2) {
    for (var n2 = qe$3(t2), r2 = ce$3.f, i2 = oe$3.f, u2 = 0; u2 < n2.length; u2++) {
      var o2 = n2[u2];
      z$3(e20, o2) || r2(e20, o2, i2(t2, o2));
    }
  }, ze$3 = /#|\.prototype\./, Ge$3 = function(e20, t2) {
    var n2 = Je$3[He$3(e20)];
    return n2 == Ye$3 || n2 != Xe$3 && (typeof t2 == "function" ? m$3(t2) : !!t2);
  }, He$3 = Ge$3.normalize = function(e20) {
    return String(e20).replace(ze$3, ".").toLowerCase();
  }, Je$3 = Ge$3.data = {}, Xe$3 = Ge$3.NATIVE = "N", Ye$3 = Ge$3.POLYFILL = "P", Ke$3 = Ge$3, Qe$3 = oe$3.f, Ze$3 = function(e20, t2) {
    var n2, r2, i2, u2, o2, s2 = e20.target, a2 = e20.global, c2 = e20.stat;
    if (n2 = a2 ? g$3 : c2 ? g$3[s2] || $$3(s2, {}) : (g$3[s2] || {}).prototype)
      for (r2 in t2) {
        if (u2 = t2[r2], i2 = e20.noTargetGet ? (o2 = Qe$3(n2, r2)) && o2.value : n2[r2], !Ke$3(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
          if (typeof u2 == typeof i2)
            continue;
          Ue$3(u2, i2);
        }
        (e20.sham || i2 && i2.sham) && le$3(u2, "sham", true), Ne$3(n2, r2, u2, e20);
      }
  }, et$3 = function(e20) {
    if (typeof e20 != "function")
      throw TypeError(String(e20) + " is not a function");
    return e20;
  }, tt$3 = function(e20) {
    if (R$3(e20))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e20);
  }, nt$3 = Math.floor, rt$3 = function(e20, t2) {
    var n2 = e20.length, r2 = nt$3(n2 / 2);
    return n2 < 8 ? it$3(e20, t2) : ut$3(rt$3(e20.slice(0, r2), t2), rt$3(e20.slice(r2), t2), t2);
  }, it$3 = function(e20, t2) {
    for (var n2, r2, i2 = e20.length, u2 = 1; u2 < i2; ) {
      for (r2 = u2, n2 = e20[u2]; r2 && t2(e20[r2 - 1], n2) > 0; )
        e20[r2] = e20[--r2];
      r2 !== u2++ && (e20[r2] = n2);
    }
    return e20;
  }, ut$3 = function(e20, t2, n2) {
    for (var r2 = e20.length, i2 = t2.length, u2 = 0, o2 = 0, s2 = []; u2 < r2 || o2 < i2; )
      u2 < r2 && o2 < i2 ? s2.push(n2(e20[u2], t2[o2]) <= 0 ? e20[u2++] : t2[o2++]) : s2.push(u2 < r2 ? e20[u2++] : t2[o2++]);
    return s2;
  }, ot$3 = rt$3, st$3 = k$3.match(/firefox\/(\d+)/i), at$3 = !!st$3 && +st$3[1], ct$3 = /MSIE|Trident/.test(k$3), lt$3 = k$3.match(/AppleWebKit\/(\d+)\./), pt$3 = !!lt$3 && +lt$3[1], ft$3 = [], dt$3 = ft$3.sort, ht$3 = m$3(function() {
    ft$3.sort(void 0);
  }), gt$3 = m$3(function() {
    ft$3.sort(null);
  }), mt$3 = !!(Te$3 = []["sort"]) && m$3(function() {
    Te$3.call(null, we$3 || function() {
      throw 1;
    }, 1);
  }), yt$3 = !m$3(function() {
    if (j$3)
      return j$3 < 70;
    if (!(at$3 && at$3 > 3)) {
      if (ct$3)
        return true;
      if (pt$3)
        return pt$3 < 603;
      var e20, t2, n2, r2, i2 = "";
      for (e20 = 65; e20 < 76; e20++) {
        switch (t2 = String.fromCharCode(e20), e20) {
          case 66:
          case 69:
          case 70:
          case 72:
            n2 = 3;
            break;
          case 68:
          case 71:
            n2 = 4;
            break;
          default:
            n2 = 2;
        }
        for (r2 = 0; r2 < 47; r2++)
          ft$3.push({k: t2 + r2, v: n2});
      }
      for (ft$3.sort(function(e21, t3) {
        return t3.v - e21.v;
      }), r2 = 0; r2 < ft$3.length; r2++)
        t2 = ft$3[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  Ze$3({target: "Array", proto: true, forced: ht$3 || !gt$3 || !mt$3 || !yt$3}, {sort: function(e20) {
    e20 !== void 0 && et$3(e20);
    var t2 = q$3(this);
    if (yt$3)
      return e20 === void 0 ? dt$3.call(t2) : dt$3.call(t2, e20);
    var n2, r2, i2 = [], u2 = Le$3(t2.length);
    for (r2 = 0; r2 < u2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (n2 = (i2 = ot$3(i2, function(e21) {
      return function(t3, n3) {
        return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, n3) || 0 : tt$3(t3) > tt$3(n3) ? 1 : -1;
      };
    }(e20))).length, r2 = 0; r2 < n2; )
      t2[r2] = i2[r2++];
    for (; r2 < u2; )
      delete t2[r2++];
    return t2;
  }});
  var Dt$3 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffJson = function(e21, t3, n3) {
      return s2.diff(e21, t3, n3);
    }, t2.canonicalize = a2, t2.jsonDiff = void 0;
    var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : {default: n2};
    function u2(e21) {
      return (u2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e22) {
        return typeof e22;
      } : function(e22) {
        return e22 && typeof Symbol == "function" && e22.constructor === Symbol && e22 !== Symbol.prototype ? "symbol" : typeof e22;
      })(e21);
    }
    var o2 = Object.prototype.toString, s2 = new r2.default();
    function a2(e21, t3, n3, r3, i2) {
      var s3, c2;
      for (t3 = t3 || [], n3 = n3 || [], r3 && (e21 = r3(i2, e21)), s3 = 0; s3 < t3.length; s3 += 1)
        if (t3[s3] === e21)
          return n3[s3];
      if (o2.call(e21) === "[object Array]") {
        for (t3.push(e21), c2 = new Array(e21.length), n3.push(c2), s3 = 0; s3 < e21.length; s3 += 1)
          c2[s3] = a2(e21[s3], t3, n3, r3, i2);
        return t3.pop(), n3.pop(), c2;
      }
      if (e21 && e21.toJSON && (e21 = e21.toJSON()), u2(e21) === "object" && e21 !== null) {
        t3.push(e21), c2 = {}, n3.push(c2);
        var l2, p2 = [];
        for (l2 in e21)
          e21.hasOwnProperty(l2) && p2.push(l2);
        for (p2.sort(), s3 = 0; s3 < p2.length; s3 += 1)
          c2[l2 = p2[s3]] = a2(e21[l2], t3, n3, r3, l2);
        t3.pop(), n3.pop();
      } else
        c2 = e21;
      return c2;
    }
    t2.jsonDiff = s2, s2.useLongestToken = true, s2.tokenize = p$3.lineDiff.tokenize, s2.castInput = function(e21) {
      var t3 = this.options, n3 = t3.undefinedReplacement, r3 = t3.stringifyReplacer, i2 = r3 === void 0 ? function(e22, t4) {
        return t4 === void 0 ? n3 : t4;
      } : r3;
      return typeof e21 == "string" ? e21 : JSON.stringify(a2(e21, null, null, i2), i2, "  ");
    }, s2.equals = function(e21, t3) {
      return r2.default.prototype.equals.call(s2, e21.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
    };
  }), Et$3 = r$3(function(e20, t2) {
    var n2;
    Object.defineProperty(t2, "__esModule", {value: true}), t2.diffArrays = function(e21, t3, n3) {
      return r2.diff(e21, t3, n3);
    }, t2.arrayDiff = void 0;
    var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : {default: n2}).default();
    t2.arrayDiff = r2, r2.tokenize = function(e21) {
      return e21.slice();
    }, r2.join = r2.removeEmpty = function(e21) {
      return e21;
    };
  }), Ct$3 = function(e20) {
    var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e20.split(/\r\n|[\n\v\f\r\x85]/), r2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = [], u2 = 0;
    function o2() {
      var e21 = {};
      for (i2.push(e21); u2 < n2.length; ) {
        var r3 = n2[u2];
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
          break;
        var o3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
        o3 && (e21.index = o3[1]), u2++;
      }
      for (s2(e21), s2(e21), e21.hunks = []; u2 < n2.length; ) {
        var c2 = n2[u2];
        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
          break;
        if (/^@@/.test(c2))
          e21.hunks.push(a2());
        else {
          if (c2 && t2.strict)
            throw new Error("Unknown line " + (u2 + 1) + " " + JSON.stringify(c2));
          u2++;
        }
      }
    }
    function s2(e21) {
      var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u2]);
      if (t3) {
        var r3 = t3[1] === "---" ? "old" : "new", i3 = t3[2].split("	", 2), o3 = i3[0].replace(/\\\\/g, "\\");
        /^".*"$/.test(o3) && (o3 = o3.substr(1, o3.length - 2)), e21[r3 + "FileName"] = o3, e21[r3 + "Header"] = (i3[1] || "").trim(), u2++;
      }
    }
    function a2() {
      var e21 = u2, i3 = n2[u2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o3 = {oldStart: +i3[1], oldLines: i3[2] === void 0 ? 1 : +i3[2], newStart: +i3[3], newLines: i3[4] === void 0 ? 1 : +i3[4], lines: [], linedelimiters: []};
      o3.oldLines === 0 && (o3.oldStart += 1), o3.newLines === 0 && (o3.newStart += 1);
      for (var s3 = 0, a3 = 0; u2 < n2.length && !(n2[u2].indexOf("--- ") === 0 && u2 + 2 < n2.length && n2[u2 + 1].indexOf("+++ ") === 0 && n2[u2 + 2].indexOf("@@") === 0); u2++) {
        var c2 = n2[u2].length == 0 && u2 != n2.length - 1 ? " " : n2[u2][0];
        if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
          break;
        o3.lines.push(n2[u2]), o3.linedelimiters.push(r2[u2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
      }
      if (s3 || o3.newLines !== 1 || (o3.newLines = 0), a3 || o3.oldLines !== 1 || (o3.oldLines = 0), t2.strict) {
        if (s3 !== o3.newLines)
          throw new Error("Added line count did not match for hunk at line " + (e21 + 1));
        if (a3 !== o3.oldLines)
          throw new Error("Removed line count did not match for hunk at line " + (e21 + 1));
      }
      return o3;
    }
    for (; u2 < n2.length; )
      o2();
    return i2;
  };
  var bt$3, At$3 = Object.defineProperty({parsePatch: Ct$3}, "__esModule", {value: true}), vt$3 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), t2.default = function(e21, t3, n2) {
      var r2 = true, i2 = false, u2 = false, o2 = 1;
      return function s2() {
        if (r2 && !u2) {
          if (i2 ? o2++ : r2 = false, e21 + o2 <= n2)
            return o2;
          u2 = true;
        }
        if (!i2)
          return u2 || (r2 = true), t3 <= e21 - o2 ? -o2++ : (i2 = true, s2());
      };
    };
  }), Ft$3 = wt$3, St$2 = function(e20, t2) {
    typeof e20 == "string" && (e20 = (0, At$3.parsePatch)(e20));
    var n2 = 0;
    !function r2() {
      var i2 = e20[n2++];
      if (!i2)
        return t2.complete();
      t2.loadFile(i2, function(e21, n3) {
        if (e21)
          return t2.complete(e21);
        var u2 = wt$3(n3, i2, t2);
        t2.patched(i2, u2, function(e22) {
          if (e22)
            return t2.complete(e22);
          r2();
        });
      });
    }();
  }, xt$3 = (bt$3 = vt$3) && bt$3.__esModule ? bt$3 : {default: bt$3};
  function wt$3(e20, t2) {
    var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof t2 == "string" && (t2 = (0, At$3.parsePatch)(t2)), Array.isArray(t2)) {
      if (t2.length > 1)
        throw new Error("applyPatch only works with a single input.");
      t2 = t2[0];
    }
    var r2, i2, u2 = e20.split(/\r\n|[\n\v\f\r\x85]/), o2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e21, t3, n3, r3) {
      return t3 === r3;
    }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
    function d2(e21, t3) {
      for (var n3 = 0; n3 < e21.lines.length; n3++) {
        var r3 = e21.lines[n3], i3 = r3.length > 0 ? r3[0] : " ", o3 = r3.length > 0 ? r3.substr(1) : r3;
        if (i3 === " " || i3 === "-") {
          if (!a2(t3 + 1, u2[t3], i3, o3) && ++c2 > l2)
            return false;
          t3++;
        }
      }
      return true;
    }
    for (var h2 = 0; h2 < s2.length; h2++) {
      for (var g2 = s2[h2], m2 = u2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, xt$3.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
        if (d2(g2, D2 + y2)) {
          g2.offset = f2 += y2;
          break;
        }
      if (y2 === void 0)
        return false;
      p2 = g2.offset + g2.oldStart + g2.oldLines;
    }
    for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
      var A2 = s2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
      C2 += A2.newLines - A2.oldLines;
      for (var F2 = 0; F2 < A2.lines.length; F2++) {
        var S2 = A2.lines[F2], x2 = S2.length > 0 ? S2[0] : " ", w2 = S2.length > 0 ? S2.substr(1) : S2, T2 = A2.linedelimiters[F2];
        if (x2 === " ")
          v2++;
        else if (x2 === "-")
          u2.splice(v2, 1), o2.splice(v2, 1);
        else if (x2 === "+")
          u2.splice(v2, 0, w2), o2.splice(v2, 0, T2), v2++;
        else if (x2 === "\\") {
          var B2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
          B2 === "+" ? r2 = true : B2 === "-" && (i2 = true);
        }
      }
    }
    if (r2)
      for (; !u2[u2.length - 1]; )
        u2.pop(), o2.pop();
    else
      i2 && (u2.push(""), o2.push("\n"));
    for (var N2 = 0; N2 < u2.length - 1; N2++)
      u2[N2] = u2[N2] + o2[N2];
    return u2.join("");
  }
  var Tt$2 = Object.defineProperty({applyPatch: Ft$3, applyPatches: St$2}, "__esModule", {value: true}), Bt$2 = Lt$2, Nt$2 = jt$2, kt$3 = _t$2, Pt$2 = function(e20, t2, n2, r2, i2, u2) {
    return _t$2(e20, e20, t2, n2, r2, i2, u2);
  };
  function Ot$3(e20) {
    return function(e21) {
      if (Array.isArray(e21))
        return It$2(e21);
    }(e20) || function(e21) {
      if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
        return Array.from(e21);
    }(e20) || function(e21, t2) {
      if (!e21)
        return;
      if (typeof e21 == "string")
        return It$2(e21, t2);
      var n2 = Object.prototype.toString.call(e21).slice(8, -1);
      n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
      if (n2 === "Map" || n2 === "Set")
        return Array.from(e21);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return It$2(e21, t2);
    }(e20) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function It$2(e20, t2) {
    (t2 == null || t2 > e20.length) && (t2 = e20.length);
    for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
      r2[n2] = e20[n2];
    return r2;
  }
  function Lt$2(e20, t2, n2, r2, i2, u2, o2) {
    o2 || (o2 = {}), o2.context === void 0 && (o2.context = 4);
    var s2 = (0, p$3.diffLines)(n2, r2, o2);
    function a2(e21) {
      return e21.map(function(e22) {
        return " " + e22;
      });
    }
    s2.push({value: "", lines: []});
    for (var c2 = [], l2 = 0, f2 = 0, d2 = [], h2 = 1, g2 = 1, m2 = function(e21) {
      var t3 = s2[e21], i3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
      if (t3.lines = i3, t3.added || t3.removed) {
        var u3;
        if (!l2) {
          var p2 = s2[e21 - 1];
          l2 = h2, f2 = g2, p2 && (d2 = o2.context > 0 ? a2(p2.lines.slice(-o2.context)) : [], l2 -= d2.length, f2 -= d2.length);
        }
        (u3 = d2).push.apply(u3, Ot$3(i3.map(function(e22) {
          return (t3.added ? "+" : "-") + e22;
        }))), t3.added ? g2 += i3.length : h2 += i3.length;
      } else {
        if (l2)
          if (i3.length <= 2 * o2.context && e21 < s2.length - 2) {
            var m3;
            (m3 = d2).push.apply(m3, Ot$3(a2(i3)));
          } else {
            var y3, D2 = Math.min(i3.length, o2.context);
            (y3 = d2).push.apply(y3, Ot$3(a2(i3.slice(0, D2))));
            var E2 = {oldStart: l2, oldLines: h2 - l2 + D2, newStart: f2, newLines: g2 - f2 + D2, lines: d2};
            if (e21 >= s2.length - 2 && i3.length <= o2.context) {
              var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = i3.length == 0 && d2.length > E2.oldLines;
              !C2 && A2 && n2.length > 0 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
            }
            c2.push(E2), l2 = 0, f2 = 0, d2 = [];
          }
        h2 += i3.length, g2 += i3.length;
      }
    }, y2 = 0; y2 < s2.length; y2++)
      m2(y2);
    return {oldFileName: e20, newFileName: t2, oldHeader: i2, newHeader: u2, hunks: c2};
  }
  function jt$2(e20) {
    var t2 = [];
    e20.oldFileName == e20.newFileName && t2.push("Index: " + e20.oldFileName), t2.push("==================================================================="), t2.push("--- " + e20.oldFileName + (e20.oldHeader === void 0 ? "" : "	" + e20.oldHeader)), t2.push("+++ " + e20.newFileName + (e20.newHeader === void 0 ? "" : "	" + e20.newHeader));
    for (var n2 = 0; n2 < e20.hunks.length; n2++) {
      var r2 = e20.hunks[n2];
      r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
    }
    return t2.join("\n") + "\n";
  }
  function _t$2(e20, t2, n2, r2, i2, u2, o2) {
    return jt$2(Lt$2(e20, t2, n2, r2, i2, u2, o2));
  }
  var Mt$2 = Object.defineProperty({structuredPatch: Bt$2, formatPatch: Nt$2, createTwoFilesPatch: kt$3, createPatch: Pt$2}, "__esModule", {value: true}), Rt$2 = function(e20, t2) {
    if (e20.length !== t2.length)
      return false;
    return Vt$2(e20, t2);
  }, $t$2 = Vt$2;
  function Vt$2(e20, t2) {
    if (t2.length > e20.length)
      return false;
    for (var n2 = 0; n2 < t2.length; n2++)
      if (t2[n2] !== e20[n2])
        return false;
    return true;
  }
  var Wt$2 = Object.defineProperty({arrayEqual: Rt$2, arrayStartsWith: $t$2}, "__esModule", {value: true}), qt$2 = Ht$2, Ut$2 = function(e20, t2, n2) {
    e20 = Jt$2(e20, n2), t2 = Jt$2(t2, n2);
    var r2 = {};
    (e20.index || t2.index) && (r2.index = e20.index || t2.index);
    (e20.newFileName || t2.newFileName) && (Xt$2(e20) ? Xt$2(t2) ? (r2.oldFileName = Yt$2(r2, e20.oldFileName, t2.oldFileName), r2.newFileName = Yt$2(r2, e20.newFileName, t2.newFileName), r2.oldHeader = Yt$2(r2, e20.oldHeader, t2.oldHeader), r2.newHeader = Yt$2(r2, e20.newHeader, t2.newHeader)) : (r2.oldFileName = e20.oldFileName, r2.newFileName = e20.newFileName, r2.oldHeader = e20.oldHeader, r2.newHeader = e20.newHeader) : (r2.oldFileName = t2.oldFileName || e20.oldFileName, r2.newFileName = t2.newFileName || e20.newFileName, r2.oldHeader = t2.oldHeader || e20.oldHeader, r2.newHeader = t2.newHeader || e20.newHeader));
    r2.hunks = [];
    var i2 = 0, u2 = 0, o2 = 0, s2 = 0;
    for (; i2 < e20.hunks.length || u2 < t2.hunks.length; ) {
      var a2 = e20.hunks[i2] || {oldStart: 1 / 0}, c2 = t2.hunks[u2] || {oldStart: 1 / 0};
      if (Kt$2(a2, c2))
        r2.hunks.push(Qt$2(a2, o2)), i2++, s2 += a2.newLines - a2.oldLines;
      else if (Kt$2(c2, a2))
        r2.hunks.push(Qt$2(c2, s2)), u2++, o2 += c2.newLines - c2.oldLines;
      else {
        var l2 = {oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + o2, c2.oldStart + s2), newLines: 0, lines: []};
        Zt$2(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), u2++, i2++, r2.hunks.push(l2);
      }
    }
    return r2;
  };
  function zt$2(e20) {
    return function(e21) {
      if (Array.isArray(e21))
        return Gt$2(e21);
    }(e20) || function(e21) {
      if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
        return Array.from(e21);
    }(e20) || function(e21, t2) {
      if (!e21)
        return;
      if (typeof e21 == "string")
        return Gt$2(e21, t2);
      var n2 = Object.prototype.toString.call(e21).slice(8, -1);
      n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
      if (n2 === "Map" || n2 === "Set")
        return Array.from(e21);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return Gt$2(e21, t2);
    }(e20) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function Gt$2(e20, t2) {
    (t2 == null || t2 > e20.length) && (t2 = e20.length);
    for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
      r2[n2] = e20[n2];
    return r2;
  }
  function Ht$2(e20) {
    var t2 = cn$2(e20.lines), n2 = t2.oldLines, r2 = t2.newLines;
    n2 !== void 0 ? e20.oldLines = n2 : delete e20.oldLines, r2 !== void 0 ? e20.newLines = r2 : delete e20.newLines;
  }
  function Jt$2(e20, t2) {
    if (typeof e20 == "string") {
      if (/^@@/m.test(e20) || /^Index:/m.test(e20))
        return (0, At$3.parsePatch)(e20)[0];
      if (!t2)
        throw new Error("Must provide a base reference or pass in a patch");
      return (0, Mt$2.structuredPatch)(void 0, void 0, t2, e20);
    }
    return e20;
  }
  function Xt$2(e20) {
    return e20.newFileName && e20.newFileName !== e20.oldFileName;
  }
  function Yt$2(e20, t2, n2) {
    return t2 === n2 ? t2 : (e20.conflict = true, {mine: t2, theirs: n2});
  }
  function Kt$2(e20, t2) {
    return e20.oldStart < t2.oldStart && e20.oldStart + e20.oldLines < t2.oldStart;
  }
  function Qt$2(e20, t2) {
    return {oldStart: e20.oldStart, oldLines: e20.oldLines, newStart: e20.newStart + t2, newLines: e20.newLines, lines: e20.lines};
  }
  function Zt$2(e20, t2, n2, r2, i2) {
    var u2 = {offset: t2, lines: n2, index: 0}, o2 = {offset: r2, lines: i2, index: 0};
    for (rn$2(e20, u2, o2), rn$2(e20, o2, u2); u2.index < u2.lines.length && o2.index < o2.lines.length; ) {
      var s2 = u2.lines[u2.index], a2 = o2.lines[o2.index];
      if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
        if (s2[0] === "+" && a2[0] === " ") {
          var c2;
          (c2 = e20.lines).push.apply(c2, zt$2(on$2(u2)));
        } else if (a2[0] === "+" && s2[0] === " ") {
          var l2;
          (l2 = e20.lines).push.apply(l2, zt$2(on$2(o2)));
        } else
          s2[0] === "-" && a2[0] === " " ? tn$2(e20, u2, o2) : a2[0] === "-" && s2[0] === " " ? tn$2(e20, o2, u2, true) : s2 === a2 ? (e20.lines.push(s2), u2.index++, o2.index++) : nn$2(e20, on$2(u2), on$2(o2));
      else
        en$2(e20, u2, o2);
    }
    un$2(e20, u2), un$2(e20, o2), Ht$2(e20);
  }
  function en$2(e20, t2, n2) {
    var r2 = on$2(t2), i2 = on$2(n2);
    if (sn$2(r2) && sn$2(i2)) {
      var u2, o2;
      if ((0, Wt$2.arrayStartsWith)(r2, i2) && an$2(n2, r2, r2.length - i2.length))
        return void (u2 = e20.lines).push.apply(u2, zt$2(r2));
      if ((0, Wt$2.arrayStartsWith)(i2, r2) && an$2(t2, i2, i2.length - r2.length))
        return void (o2 = e20.lines).push.apply(o2, zt$2(i2));
    } else if ((0, Wt$2.arrayEqual)(r2, i2)) {
      var s2;
      return void (s2 = e20.lines).push.apply(s2, zt$2(r2));
    }
    nn$2(e20, r2, i2);
  }
  function tn$2(e20, t2, n2, r2) {
    var i2, u2 = on$2(t2), o2 = function(e21, t3) {
      var n3 = [], r3 = [], i3 = 0, u3 = false, o3 = false;
      for (; i3 < t3.length && e21.index < e21.lines.length; ) {
        var s2 = e21.lines[e21.index], a2 = t3[i3];
        if (a2[0] === "+")
          break;
        if (u3 = u3 || s2[0] !== " ", r3.push(a2), i3++, s2[0] === "+")
          for (o3 = true; s2[0] === "+"; )
            n3.push(s2), s2 = e21.lines[++e21.index];
        a2.substr(1) === s2.substr(1) ? (n3.push(s2), e21.index++) : o3 = true;
      }
      (t3[i3] || "")[0] === "+" && u3 && (o3 = true);
      if (o3)
        return n3;
      for (; i3 < t3.length; )
        r3.push(t3[i3++]);
      return {merged: r3, changes: n3};
    }(n2, u2);
    o2.merged ? (i2 = e20.lines).push.apply(i2, zt$2(o2.merged)) : nn$2(e20, r2 ? o2 : u2, r2 ? u2 : o2);
  }
  function nn$2(e20, t2, n2) {
    e20.conflict = true, e20.lines.push({conflict: true, mine: t2, theirs: n2});
  }
  function rn$2(e20, t2, n2) {
    for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
      var r2 = t2.lines[t2.index++];
      e20.lines.push(r2), t2.offset++;
    }
  }
  function un$2(e20, t2) {
    for (; t2.index < t2.lines.length; ) {
      var n2 = t2.lines[t2.index++];
      e20.lines.push(n2);
    }
  }
  function on$2(e20) {
    for (var t2 = [], n2 = e20.lines[e20.index][0]; e20.index < e20.lines.length; ) {
      var r2 = e20.lines[e20.index];
      if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
        break;
      t2.push(r2), e20.index++;
    }
    return t2;
  }
  function sn$2(e20) {
    return e20.reduce(function(e21, t2) {
      return e21 && t2[0] === "-";
    }, true);
  }
  function an$2(e20, t2, n2) {
    for (var r2 = 0; r2 < n2; r2++) {
      var i2 = t2[t2.length - n2 + r2].substr(1);
      if (e20.lines[e20.index + r2] !== " " + i2)
        return false;
    }
    return e20.index += n2, true;
  }
  function cn$2(e20) {
    var t2 = 0, n2 = 0;
    return e20.forEach(function(e21) {
      if (typeof e21 != "string") {
        var r2 = cn$2(e21.mine), i2 = cn$2(e21.theirs);
        t2 !== void 0 && (r2.oldLines === i2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === i2.newLines ? n2 += r2.newLines : n2 = void 0);
      } else
        n2 === void 0 || e21[0] !== "+" && e21[0] !== " " || n2++, t2 === void 0 || e21[0] !== "-" && e21[0] !== " " || t2++;
    }), {oldLines: t2, newLines: n2};
  }
  var ln$2 = Object.defineProperty({calcLineCount: qt$2, merge: Ut$2}, "__esModule", {value: true}), pn$2 = function(e20) {
    for (var t2, n2, r2 = [], i2 = 0; i2 < e20.length; i2++)
      t2 = e20[i2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
    return r2;
  };
  var fn$2 = Object.defineProperty({convertChangesToDMP: pn$2}, "__esModule", {value: true}), dn$2 = function(e20) {
    for (var t2 = [], n2 = 0; n2 < e20.length; n2++) {
      var r2 = e20[n2];
      r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(hn$2(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
    }
    return t2.join("");
  };
  function hn$2(e20) {
    var t2 = e20;
    return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
  }
  var gn$2 = Object.defineProperty({convertChangesToXML: dn$2}, "__esModule", {value: true}), mn$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), Object.defineProperty(t2, "Diff", {enumerable: true, get: function() {
      return n2.default;
    }}), Object.defineProperty(t2, "diffChars", {enumerable: true, get: function() {
      return u$3.diffChars;
    }}), Object.defineProperty(t2, "diffWords", {enumerable: true, get: function() {
      return l$3.diffWords;
    }}), Object.defineProperty(t2, "diffWordsWithSpace", {enumerable: true, get: function() {
      return l$3.diffWordsWithSpace;
    }}), Object.defineProperty(t2, "diffLines", {enumerable: true, get: function() {
      return p$3.diffLines;
    }}), Object.defineProperty(t2, "diffTrimmedLines", {enumerable: true, get: function() {
      return p$3.diffTrimmedLines;
    }}), Object.defineProperty(t2, "diffSentences", {enumerable: true, get: function() {
      return f$3.diffSentences;
    }}), Object.defineProperty(t2, "diffCss", {enumerable: true, get: function() {
      return d$3.diffCss;
    }}), Object.defineProperty(t2, "diffJson", {enumerable: true, get: function() {
      return Dt$3.diffJson;
    }}), Object.defineProperty(t2, "canonicalize", {enumerable: true, get: function() {
      return Dt$3.canonicalize;
    }}), Object.defineProperty(t2, "diffArrays", {enumerable: true, get: function() {
      return Et$3.diffArrays;
    }}), Object.defineProperty(t2, "applyPatch", {enumerable: true, get: function() {
      return Tt$2.applyPatch;
    }}), Object.defineProperty(t2, "applyPatches", {enumerable: true, get: function() {
      return Tt$2.applyPatches;
    }}), Object.defineProperty(t2, "parsePatch", {enumerable: true, get: function() {
      return At$3.parsePatch;
    }}), Object.defineProperty(t2, "merge", {enumerable: true, get: function() {
      return ln$2.merge;
    }}), Object.defineProperty(t2, "structuredPatch", {enumerable: true, get: function() {
      return Mt$2.structuredPatch;
    }}), Object.defineProperty(t2, "createTwoFilesPatch", {enumerable: true, get: function() {
      return Mt$2.createTwoFilesPatch;
    }}), Object.defineProperty(t2, "createPatch", {enumerable: true, get: function() {
      return Mt$2.createPatch;
    }}), Object.defineProperty(t2, "convertChangesToDMP", {enumerable: true, get: function() {
      return fn$2.convertChangesToDMP;
    }}), Object.defineProperty(t2, "convertChangesToXML", {enumerable: true, get: function() {
      return gn$2.convertChangesToXML;
    }});
    var n2 = function(e21) {
      return e21 && e21.__esModule ? e21 : {default: e21};
    }(i$3);
  });
  function yn$2(e20) {
    return {type: "concat", parts: e20};
  }
  function Dn$2(e20) {
    return {type: "indent", contents: e20};
  }
  function En$2(e20, t2) {
    return {type: "align", contents: t2, n: e20};
  }
  function Cn$2(e20, t2 = {}) {
    return {type: "group", id: t2.id, contents: e20, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates};
  }
  const bn$2 = {type: "break-parent"}, An$2 = {type: "line", hard: true}, vn$2 = {type: "line", hard: true, literal: true}, Fn$2 = yn$2([An$2, bn$2]), Sn$2 = yn$2([vn$2, bn$2]);
  var xn$2 = {concat: yn$2, join: function(e20, t2) {
    const n2 = [];
    for (let r2 = 0; r2 < t2.length; r2++)
      r2 !== 0 && n2.push(e20), n2.push(t2[r2]);
    return yn$2(n2);
  }, line: {type: "line"}, softline: {type: "line", soft: true}, hardline: Fn$2, literalline: Sn$2, group: Cn$2, conditionalGroup: function(e20, t2) {
    return Cn$2(e20[0], Object.assign(Object.assign({}, t2), {}, {expandedStates: e20}));
  }, fill: function(e20) {
    return {type: "fill", parts: e20};
  }, lineSuffix: function(e20) {
    return {type: "line-suffix", contents: e20};
  }, lineSuffixBoundary: {type: "line-suffix-boundary"}, cursor: {type: "cursor", placeholder: Symbol("cursor")}, breakParent: bn$2, ifBreak: function(e20, t2, n2 = {}) {
    return {type: "if-break", breakContents: e20, flatContents: t2, groupId: n2.groupId};
  }, trim: {type: "trim"}, indent: Dn$2, indentIfBreak: function(e20, t2) {
    return {type: "indent-if-break", contents: e20, groupId: t2.groupId, negate: t2.negate};
  }, align: En$2, addAlignmentToDoc: function(e20, t2, n2) {
    let r2 = e20;
    if (t2 > 0) {
      for (let e21 = 0; e21 < Math.floor(t2 / n2); ++e21)
        r2 = Dn$2(r2);
      r2 = En$2(t2 % n2, r2), r2 = En$2(Number.NEGATIVE_INFINITY, r2);
    }
    return r2;
  }, markAsRoot: function(e20) {
    return En$2({type: "root"}, e20);
  }, dedentToRoot: function(e20) {
    return En$2(Number.NEGATIVE_INFINITY, e20);
  }, dedent: function(e20) {
    return En$2(-1, e20);
  }, hardlineWithoutBreakParent: An$2, literallineWithoutBreakParent: vn$2, label: function(e20, t2) {
    return {type: "label", label: e20, contents: t2};
  }}, wn$2 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e21 ? void 0 : "g");
  })(), "") : e20;
  const Tn$2 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
  var Bn$2 = Tn$2, Nn$2 = Tn$2;
  Bn$2.default = Nn$2;
  const kn$2 = (e20) => {
    if (typeof e20 != "string" || e20.length === 0)
      return 0;
    if ((e20 = wn$2(e20)).length === 0)
      return 0;
    e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let n2 = 0; n2 < e20.length; n2++) {
      const r2 = e20.codePointAt(n2);
      r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += Bn$2(r2) ? 2 : 1));
    }
    return t2;
  };
  var Pn$2 = kn$2, On$2 = kn$2;
  Pn$2.default = On$2;
  var In$2 = (e20) => {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  var Ln$2 = (e20) => e20[e20.length - 1];
  function jn$2(e20, t2) {
    if (e20 == null)
      return {};
    var n2, r2, i2 = function(e21, t3) {
      if (e21 == null)
        return {};
      var n3, r3, i3 = {}, u3 = Object.keys(e21);
      for (r3 = 0; r3 < u3.length; r3++)
        n3 = u3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e21[n3]);
      return i3;
    }(e20, t2);
    if (Object.getOwnPropertySymbols) {
      var u2 = Object.getOwnPropertySymbols(e20);
      for (r2 = 0; r2 < u2.length; r2++)
        n2 = u2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, n2) && (i2[n2] = e20[n2]);
    }
    return i2;
  }
  var _n$2 = Array.isArray || function(e20) {
    return v$3(e20) == "Array";
  }, Mn$2 = function(e20, t2, n2) {
    if (et$3(e20), t2 === void 0)
      return e20;
    switch (n2) {
      case 0:
        return function() {
          return e20.call(t2);
        };
      case 1:
        return function(n3) {
          return e20.call(t2, n3);
        };
      case 2:
        return function(n3, r2) {
          return e20.call(t2, n3, r2);
        };
      case 3:
        return function(n3, r2, i2) {
          return e20.call(t2, n3, r2, i2);
        };
    }
    return function() {
      return e20.apply(t2, arguments);
    };
  }, Rn$2 = function(e20, t2, n2, r2, i2, u2, o2, s2) {
    for (var a2, c2 = i2, l2 = 0, p2 = !!o2 && Mn$2(o2, s2, 3); l2 < r2; ) {
      if (l2 in n2) {
        if (a2 = p2 ? p2(n2[l2], l2, t2) : n2[l2], u2 > 0 && _n$2(a2))
          c2 = Rn$2(e20, t2, a2, Le$3(a2.length), c2, u2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e20[c2] = a2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, $n$2 = Rn$2, Vn$2 = Q$3("species"), Wn$2 = function(e20, t2) {
    return new (function(e21) {
      var t3;
      return _n$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !_n$2(t3.prototype) ? T$3(t3) && (t3 = t3[Vn$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e20))(t2 === 0 ? 0 : t2);
  };
  Ze$3({target: "Array", proto: true}, {flatMap: function(e20) {
    var t2, n2 = q$3(this), r2 = Le$3(n2.length);
    return et$3(e20), (t2 = Wn$2(n2, 0)).length = $n$2(t2, n2, n2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }});
  var qn$2 = {}, Un$2 = Q$3("iterator"), zn$2 = Array.prototype, Gn$2 = {};
  Gn$2[Q$3("toStringTag")] = "z";
  var Hn$2 = String(Gn$2) === "[object z]", Jn$2 = Q$3("toStringTag"), Xn$2 = v$3(function() {
    return arguments;
  }()) == "Arguments", Yn$2 = Hn$2 ? v$3 : function(e20) {
    var t2, n2, r2;
    return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (n2 = function(e21, t3) {
      try {
        return e21[t3];
      } catch (e22) {
      }
    }(t2 = Object(e20), Jn$2)) == "string" ? n2 : Xn$2 ? v$3(t2) : (r2 = v$3(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
  }, Kn$2 = Q$3("iterator"), Qn$2 = function(e20) {
    if (e20 != null)
      return e20[Kn$2] || e20["@@iterator"] || qn$2[Yn$2(e20)];
  }, Zn$2 = function(e20, t2, n2) {
    var r2, i2;
    se$3(e20);
    try {
      if ((r2 = e20.return) === void 0) {
        if (t2 === "throw")
          throw n2;
        return n2;
      }
      r2 = r2.call(e20);
    } catch (e21) {
      i2 = true, r2 = e21;
    }
    if (t2 === "throw")
      throw n2;
    if (i2)
      throw r2;
    return se$3(r2), n2;
  }, er$2 = function(e20, t2) {
    this.stopped = e20, this.result = t2;
  }, tr$2 = function(e20, t2, n2) {
    var r2, i2, u2, o2, s2, a2, c2, l2, p2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), g2 = Mn$2(t2, p2, 1 + f2 + h2), m2 = function(e21) {
      return r2 && Zn$2(r2, "normal", e21), new er$2(true, e21);
    }, y2 = function(e21) {
      return f2 ? (se$3(e21), h2 ? g2(e21[0], e21[1], m2) : g2(e21[0], e21[1])) : h2 ? g2(e21, m2) : g2(e21);
    };
    if (d2)
      r2 = e20;
    else {
      if (typeof (i2 = Qn$2(e20)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = i2) !== void 0 && (qn$2.Array === l2 || zn$2[Un$2] === l2)) {
        for (u2 = 0, o2 = Le$3(e20.length); o2 > u2; u2++)
          if ((s2 = y2(e20[u2])) && s2 instanceof er$2)
            return s2;
        return new er$2(false);
      }
      r2 = function(e21, t3) {
        var n3 = arguments.length < 2 ? Qn$2(e21) : t3;
        if (typeof n3 != "function")
          throw TypeError(String(e21) + " is not iterable");
        return se$3(n3.call(e21));
      }(e20, i2);
    }
    for (a2 = r2.next; !(c2 = a2.call(r2)).done; ) {
      try {
        s2 = y2(c2.value);
      } catch (e21) {
        Zn$2(r2, "throw", e21);
      }
      if (typeof s2 == "object" && s2 && s2 instanceof er$2)
        return s2;
    }
    return new er$2(false);
  };
  Ze$3({target: "Object", stat: true}, {fromEntries: function(e20) {
    var t2 = {};
    return tr$2(e20, function(e21, n2) {
      !function(e22, t3, n3) {
        var r2 = te$3(t3);
        r2 in e22 ? ce$3.f(e22, r2, b$3(0, n3)) : e22[r2] = n3;
      }(t2, e21, n2);
    }, {AS_ENTRIES: true}), t2;
  }});
  var nr$2 = nr$2 !== void 0 ? nr$2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function rr$2() {
    throw new Error("setTimeout has not been defined");
  }
  function ir$2() {
    throw new Error("clearTimeout has not been defined");
  }
  var ur$2 = rr$2, or$2 = ir$2;
  function sr$2(e20) {
    if (ur$2 === setTimeout)
      return setTimeout(e20, 0);
    if ((ur$2 === rr$2 || !ur$2) && setTimeout)
      return ur$2 = setTimeout, setTimeout(e20, 0);
    try {
      return ur$2(e20, 0);
    } catch (t2) {
      try {
        return ur$2.call(null, e20, 0);
      } catch (t3) {
        return ur$2.call(this, e20, 0);
      }
    }
  }
  typeof nr$2.setTimeout == "function" && (ur$2 = setTimeout), typeof nr$2.clearTimeout == "function" && (or$2 = clearTimeout);
  var ar$2, cr$2 = [], lr$2 = false, pr$2 = -1;
  function fr$2() {
    lr$2 && ar$2 && (lr$2 = false, ar$2.length ? cr$2 = ar$2.concat(cr$2) : pr$2 = -1, cr$2.length && dr$2());
  }
  function dr$2() {
    if (!lr$2) {
      var e20 = sr$2(fr$2);
      lr$2 = true;
      for (var t2 = cr$2.length; t2; ) {
        for (ar$2 = cr$2, cr$2 = []; ++pr$2 < t2; )
          ar$2 && ar$2[pr$2].run();
        pr$2 = -1, t2 = cr$2.length;
      }
      ar$2 = null, lr$2 = false, function(e21) {
        if (or$2 === clearTimeout)
          return clearTimeout(e21);
        if ((or$2 === ir$2 || !or$2) && clearTimeout)
          return or$2 = clearTimeout, clearTimeout(e21);
        try {
          or$2(e21);
        } catch (t3) {
          try {
            return or$2.call(null, e21);
          } catch (t4) {
            return or$2.call(this, e21);
          }
        }
      }(e20);
    }
  }
  function hr$2(e20, t2) {
    this.fun = e20, this.array = t2;
  }
  hr$2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function gr$2() {
  }
  var mr$2 = gr$2, yr$2 = gr$2, Dr$2 = gr$2, Er$2 = gr$2, Cr$2 = gr$2, br$2 = gr$2, Ar$2 = gr$2;
  var vr$2 = nr$2.performance || {}, Fr$2 = vr$2.now || vr$2.mozNow || vr$2.msNow || vr$2.oNow || vr$2.webkitNow || function() {
    return new Date().getTime();
  };
  var Sr$2 = new Date();
  var xr$2 = {nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
    cr$2.push(new hr$2(e20, t2)), cr$2.length !== 1 || lr$2 || sr$2(dr$2);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: mr$2, addListener: yr$2, once: Dr$2, off: Er$2, removeListener: Cr$2, removeAllListeners: br$2, emit: Ar$2, binding: function(e20) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e20) {
    var t2 = 1e-3 * Fr$2.call(vr$2), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (n2 -= e20[0], (r2 -= e20[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - Sr$2) / 1e3;
  }};
  var wr$2 = typeof xr$2 == "object" && xr$2.env && xr$2.env.NODE_DEBUG && /\bsemver\b/i.test(xr$2.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
  };
  var Tr$2 = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, Br$2 = r$3(function(e20, t2) {
    const {MAX_SAFE_COMPONENT_LENGTH: n2} = Tr$2, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
    let o2 = 0;
    const s2 = (e21, t3, n3) => {
      const s3 = o2++;
      wr$2(s3, t3), u2[e21] = s3, i2[s3] = t3, r2[s3] = new RegExp(t3, n3 ? "g" : void 0);
    };
    s2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s2("MAINVERSION", `(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})`), s2("MAINVERSIONLOOSE", `(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})`), s2("PRERELEASEIDENTIFIER", `(?:${i2[u2.NUMERICIDENTIFIER]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[u2.NUMERICIDENTIFIERLOOSE]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASE", `(?:-(${i2[u2.PRERELEASEIDENTIFIER]}(?:\\.${i2[u2.PRERELEASEIDENTIFIER]})*))`), s2("PRERELEASELOOSE", `(?:-?(${i2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), s2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s2("BUILD", `(?:\\+(${i2[u2.BUILDIDENTIFIER]}(?:\\.${i2[u2.BUILDIDENTIFIER]})*))`), s2("FULLPLAIN", `v?${i2[u2.MAINVERSION]}${i2[u2.PRERELEASE]}?${i2[u2.BUILD]}?`), s2("FULL", `^${i2[u2.FULLPLAIN]}$`), s2("LOOSEPLAIN", `[v=\\s]*${i2[u2.MAINVERSIONLOOSE]}${i2[u2.PRERELEASELOOSE]}?${i2[u2.BUILD]}?`), s2("LOOSE", `^${i2[u2.LOOSEPLAIN]}$`), s2("GTLT", "((?:<|>)?=?)"), s2("XRANGEIDENTIFIERLOOSE", `${i2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s2("XRANGEIDENTIFIER", `${i2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), s2("XRANGEPLAIN", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:${i2[u2.PRERELEASE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:${i2[u2.PRERELEASELOOSE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAIN]}$`), s2("XRANGELOOSE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), s2("COERCERTL", i2[u2.COERCE], true), s2("LONETILDE", "(?:~>?)"), s2("TILDETRIM", `(\\s*)${i2[u2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", s2("TILDE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAIN]}$`), s2("TILDELOOSE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("LONECARET", "(?:\\^)"), s2("CARETTRIM", `(\\s*)${i2[u2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", s2("CARET", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAIN]}$`), s2("CARETLOOSE", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COMPARATORLOOSE", `^${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]})$|^$`), s2("COMPARATOR", `^${i2[u2.GTLT]}\\s*(${i2[u2.FULLPLAIN]})$|^$`), s2("COMPARATORTRIM", `(\\s*)${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]}|${i2[u2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", s2("HYPHENRANGE", `^\\s*(${i2[u2.XRANGEPLAIN]})\\s+-\\s+(${i2[u2.XRANGEPLAIN]})\\s*$`), s2("HYPHENRANGELOOSE", `^\\s*(${i2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[u2.XRANGEPLAINLOOSE]})\\s*$`), s2("STAR", "(<|>)?=?\\s*\\*"), s2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const Nr$2 = ["includePrerelease", "loose", "rtl"];
  var kr$2 = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : Nr$2.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
  const Pr$2 = /^[0-9]+$/, Or$2 = (e20, t2) => {
    const n2 = Pr$2.test(e20), r2 = Pr$2.test(t2);
    return n2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e20 < t2 ? -1 : 1;
  };
  var Ir$2 = {compareIdentifiers: Or$2, rcompareIdentifiers: (e20, t2) => Or$2(t2, e20)};
  const {MAX_LENGTH: Lr$2, MAX_SAFE_INTEGER: jr$2} = Tr$2, {re: _r$2, t: Mr$2} = Br$2, {compareIdentifiers: Rr$2} = Ir$2;
  class $r$2 {
    constructor(e20, t2) {
      if (t2 = kr$2(t2), e20 instanceof $r$2) {
        if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
          return e20;
        e20 = e20.version;
      } else if (typeof e20 != "string")
        throw new TypeError(`Invalid Version: ${e20}`);
      if (e20.length > Lr$2)
        throw new TypeError(`version is longer than ${Lr$2} characters`);
      wr$2("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const n2 = e20.trim().match(t2.loose ? _r$2[Mr$2.LOOSE] : _r$2[Mr$2.FULL]);
      if (!n2)
        throw new TypeError(`Invalid Version: ${e20}`);
      if (this.raw = e20, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > jr$2 || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > jr$2 || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > jr$2 || this.patch < 0)
        throw new TypeError("Invalid patch version");
      n2[4] ? this.prerelease = n2[4].split(".").map((e21) => {
        if (/^[0-9]+$/.test(e21)) {
          const t3 = +e21;
          if (t3 >= 0 && t3 < jr$2)
            return t3;
        }
        return e21;
      }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e20) {
      if (wr$2("SemVer.compare", this.version, this.options, e20), !(e20 instanceof $r$2)) {
        if (typeof e20 == "string" && e20 === this.version)
          return 0;
        e20 = new $r$2(e20, this.options);
      }
      return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
    }
    compareMain(e20) {
      return e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), Rr$2(this.major, e20.major) || Rr$2(this.minor, e20.minor) || Rr$2(this.patch, e20.patch);
    }
    comparePre(e20) {
      if (e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
        return -1;
      if (!this.prerelease.length && e20.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e20.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const n2 = this.prerelease[t2], r2 = e20.prerelease[t2];
        if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (n2 === void 0)
          return -1;
        if (n2 !== r2)
          return Rr$2(n2, r2);
      } while (++t2);
    }
    compareBuild(e20) {
      e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options));
      let t2 = 0;
      do {
        const n2 = this.build[t2], r2 = e20.build[t2];
        if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (n2 === void 0)
          return -1;
        if (n2 !== r2)
          return Rr$2(n2, r2);
      } while (++t2);
    }
    inc(e20, t2) {
      switch (e20) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e21 = this.prerelease.length;
            for (; --e21 >= 0; )
              typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
            e21 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e20}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var Vr$2 = $r$2;
  var Wr$2 = (e20, t2, n2) => new Vr$2(e20, n2).compare(new Vr$2(t2, n2));
  var qr$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) < 0;
  var Ur$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) >= 0, zr$2 = r$3(function(e20, t2) {
    function n2() {
      for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
        e21[t3] = arguments[t3];
    }
    function r2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : {add: n2, delete: n2, get: n2, set: n2, has: function(e21) {
        return false;
      }};
    }
    Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, u2 = function(e21, t3) {
      return i2.call(e21, t3);
    };
    function o2(e21, t3) {
      for (var n3 in t3)
        u2(t3, n3) && (e21[n3] = t3[n3]);
      return e21;
    }
    var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function f2(e21, t3, n3) {
      var r3 = 0, i3 = e21[0].match(l2);
      i3 && (r3 = i3[1].length);
      var u3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
      t3 && (e21 = e21.slice(1));
      var o3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof o3 == "string", d3 = e21.length;
      return e21.map(function(e22, t4) {
        return e22 = e22.replace(u3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(s2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(a2, "")), f3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
          return o3;
        })), e22;
      });
    }
    function d2(e21, t3) {
      for (var n3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
        n3 += e21[r3], r3 < i3 - 1 && (n3 += t3[r3]);
      return n3;
    }
    function h2(e21) {
      return u2(e21, "raw") && u2(e21, "length");
    }
    var g2 = function e21(t3) {
      var n3 = r2(), i3 = r2();
      return o2(function r3(u3) {
        for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
          s3[a3 - 1] = arguments[a3];
        if (h2(u3)) {
          var l3 = u3, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? i3 : n3, D2 = y2.get(l3);
          if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
            return D2[0];
          var E2 = d2(D2, m2 ? s3.slice(1) : s3);
          return E2;
        }
        return e21(o2(o2({}, t3), u3 || {}));
      }, {string: function(e22) {
        return f2([e22], false, t3)[0];
      }});
    }({trimLeadingNewline: true, trimTrailingNewline: true});
    t2.outdent = g2, t2.default = g2;
    try {
      e20.exports = g2, Object.defineProperty(g2, "__esModule", {value: true}), g2.default = g2, g2.outdent = g2;
    } catch (e21) {
    }
  });
  const {outdent: Gr$2} = zr$2, Hr$2 = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Gr$2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Gr$2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Gr$2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Gr$2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
  const Jr$2 = ["cliName", "cliCategory", "cliDescription"], Xr$2 = {compare: Wr$2, lt: qr$2, gte: Ur$2}, Yr$2 = e$3.version, Kr$2 = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Hr$2}.options;
  var Qr$2 = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: n2 = false, showInternal: r2 = false} = {}) {
    const i2 = Yr$2.split("-", 1)[0], u2 = e20.flatMap((e21) => e21.languages || []).filter(s2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, n3]) => Object.assign({[t3]: e22}, n3)))(Object.assign({}, ...e20.map(({options: e21}) => e21), Kr$2), "name").filter((e21) => s2(e21) && a2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (r2)
        return e21;
      return jn$2(e21, Jr$2);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e21, t4) => Xr$2.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => s2(e21) && a2(e21)), t3.name === "parser" && function(e21, t4, n4) {
        const r3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const u3 = n4.find((e22) => e22.parsers && e22.parsers[t5]);
                let o3 = i3.name;
                u3 && u3.name && (o3 += ` (plugin: ${u3.name})`), e21.choices.push({value: t5, description: o3});
              }
          }
      }(t3, u2, e20));
      const n3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: n3});
    });
    return {languages: u2, options: o2};
    function s2(e21) {
      return t2 || !("since" in e21) || e21.since && Xr$2.gte(i2, e21.since);
    }
    function a2(e21) {
      return n2 || !("deprecated" in e21) || e21.deprecated && Xr$2.lt(i2, e21.deprecated);
    }
  }};
  const {getSupportInfo: Zr$2} = Qr$2, ei$2 = /[^\x20-\x7F]/;
  function ti$2(e20) {
    return (t2, n2, r2) => {
      const i2 = r2 && r2.backwards;
      if (n2 === false)
        return false;
      const {length: u2} = t2;
      let o2 = n2;
      for (; o2 >= 0 && o2 < u2; ) {
        const n3 = t2.charAt(o2);
        if (e20 instanceof RegExp) {
          if (!e20.test(n3))
            return o2;
        } else if (!e20.includes(n3))
          return o2;
        i2 ? o2-- : o2++;
      }
      return (o2 === -1 || o2 === u2) && o2;
    };
  }
  const ni$2 = ti$2(/\s/), ri$2 = ti$2(" 	"), ii$2 = ti$2(",; 	"), ui$2 = ti$2(/[^\n\r]/);
  function oi$2(e20, t2) {
    if (t2 === false)
      return false;
    if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
      for (let n2 = t2 + 2; n2 < e20.length; ++n2)
        if (e20.charAt(n2) === "*" && e20.charAt(n2 + 1) === "/")
          return n2 + 2;
    }
    return t2;
  }
  function si$2(e20, t2) {
    return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? ui$2(e20, t2) : t2);
  }
  function ai$2(e20, t2, n2) {
    const r2 = n2 && n2.backwards;
    if (t2 === false)
      return false;
    const i2 = e20.charAt(t2);
    if (r2) {
      if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function ci$2(e20, t2, n2 = {}) {
    const r2 = ri$2(e20, n2.backwards ? t2 - 1 : t2, n2);
    return r2 !== ai$2(e20, r2, n2);
  }
  function li$2(e20, t2) {
    let n2 = null, r2 = t2;
    for (; r2 !== n2; )
      n2 = r2, r2 = ii$2(e20, r2), r2 = oi$2(e20, r2), r2 = ri$2(e20, r2);
    return r2 = si$2(e20, r2), r2 = ai$2(e20, r2), r2 !== false && ci$2(e20, r2);
  }
  function pi$2(e20, t2) {
    let n2 = null, r2 = t2;
    for (; r2 !== n2; )
      n2 = r2, r2 = ri$2(e20, r2), r2 = oi$2(e20, r2), r2 = si$2(e20, r2), r2 = ai$2(e20, r2);
    return r2;
  }
  function fi$2(e20, t2, n2) {
    return pi$2(e20, n2(t2));
  }
  function di$2(e20, t2, n2 = 0) {
    let r2 = 0;
    for (let i2 = n2; i2 < e20.length; ++i2)
      e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
    return r2;
  }
  function hi$2(e20, t2) {
    const n2 = e20.slice(1, -1), r2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, u2 = t2 === "'" ? i2 : r2, o2 = u2 === i2 ? r2 : i2;
    let s2 = u2.quote;
    if (n2.includes(u2.quote) || n2.includes(o2.quote)) {
      s2 = (n2.match(u2.regex) || []).length > (n2.match(o2.regex) || []).length ? o2.quote : u2.quote;
    }
    return s2;
  }
  function gi$2(e20, t2, n2) {
    const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, u2) => i3 === r2 ? i3 : u2 === t2 ? "\\" + u2 : u2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function mi$2(e20, t2) {
    (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
      const t3 = e21.type || e21.kind || "(unknown type)";
      let n2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
      n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
      return t3 + (n2 ? " " + n2 : "");
    }(e20);
  }
  var yi$2 = {inferParserByLanguage: function(e20, t2) {
    const {languages: n2} = Zr$2({plugins: t2.plugins}), r2 = n2.find(({name: t3}) => t3.toLowerCase() === e20) || n2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || n2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return r2 && r2.parsers[0];
  }, getStringWidth: function(e20) {
    return e20 ? ei$2.test(e20) ? Pn$2(e20) : e20.length : 0;
  }, getMaxContinuousCount: function(e20, t2) {
    const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
    return n2 === null ? 0 : n2.reduce((e21, n3) => Math.max(e21, n3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e20, t2) {
    const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
    if (n2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e21 of n2) {
      const n3 = e21.length / t2.length;
      r2.set(n3, true), n3 > i2 && (i2 = n3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!r2.get(e21))
        return e21;
    return i2 + 1;
  }, getPenultimate: (e20) => e20[e20.length - 2], getLast: Ln$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: pi$2, getNextNonSpaceNonCommentCharacterIndex: fi$2, getNextNonSpaceNonCommentCharacter: function(e20, t2, n2) {
    return e20.charAt(fi$2(e20, t2, n2));
  }, skip: ti$2, skipWhitespace: ni$2, skipSpaces: ri$2, skipToLineEnd: ii$2, skipEverythingButNewLine: ui$2, skipInlineComment: oi$2, skipTrailingComment: si$2, skipNewline: ai$2, isNextLineEmptyAfterIndex: li$2, isNextLineEmpty: function(e20, t2, n2) {
    return li$2(e20, n2(t2));
  }, isPreviousLineEmpty: function(e20, t2, n2) {
    let r2 = n2(t2) - 1;
    return r2 = ri$2(e20, r2, {backwards: true}), r2 = ai$2(e20, r2, {backwards: true}), r2 = ri$2(e20, r2, {backwards: true}), r2 !== ai$2(e20, r2, {backwards: true});
  }, hasNewline: ci$2, hasNewlineInRange: function(e20, t2, n2) {
    for (let r2 = t2; r2 < n2; ++r2)
      if (e20.charAt(r2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e20, t2, n2 = {}) {
    return ri$2(e20, n2.backwards ? t2 - 1 : t2, n2) !== t2;
  }, getAlignmentSize: di$2, getIndentSize: function(e20, t2) {
    const n2 = e20.lastIndexOf("\n");
    return n2 === -1 ? 0 : di$2(e20.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: hi$2, printString: function(e20, t2) {
    return gi$2(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : hi$2(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: gi$2, addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, mi$2(e20, t2);
  }, addDanglingComment: function(e20, t2, n2) {
    t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), mi$2(e20, t2);
  }, addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, mi$2(e20, t2);
  }, isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  }, getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  }, isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  }, createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(n2) {
      return t2.has(n2) || t2.set(n2, Symbol(e20)), t2.get(n2);
    };
  }};
  var Di$2 = {guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e20, t2) {
    let n2;
    if (t2 === "\n")
      n2 = /\n/g;
    else if (t2 === "\r")
      n2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      n2 = /\r\n/g;
    }
    const r2 = e20.match(n2);
    return r2 ? r2.length : 0;
  }, normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }};
  const {literalline: Ei$2, join: Ci$2} = xn$2, bi$2 = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", Ai$2 = (e20) => {
    if (Array.isArray(e20))
      return e20;
    if (e20.type !== "concat" && e20.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return e20.parts;
  }, vi$2 = {};
  function Fi$2(e20, t2, n2, r2) {
    const i2 = [e20];
    for (; i2.length > 0; ) {
      const e21 = i2.pop();
      if (e21 !== vi$2) {
        if (n2 && i2.push(e21, vi$2), !t2 || t2(e21) !== false)
          if (bi$2(e21) || e21.type === "fill") {
            const t3 = Ai$2(e21);
            for (let e22 = t3.length - 1; e22 >= 0; --e22)
              i2.push(t3[e22]);
          } else if (e21.type === "if-break")
            e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
          else if (e21.type === "group" && e21.expandedStates)
            if (r2)
              for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
                i2.push(e21.expandedStates[t3]);
            else
              i2.push(e21.contents);
          else
            e21.contents && i2.push(e21.contents);
      } else
        n2(i2.pop());
    }
  }
  function Si$2(e20, t2) {
    const n2 = new Map();
    return r2(e20);
    function r2(e21) {
      if (n2.has(e21))
        return n2.get(e21);
      const i2 = function(e22) {
        if (Array.isArray(e22))
          return t2(e22.map(r2));
        if (e22.type === "concat" || e22.type === "fill") {
          const n3 = e22.parts.map(r2);
          return t2(Object.assign(Object.assign({}, e22), {}, {parts: n3}));
        }
        if (e22.type === "if-break") {
          const n3 = e22.breakContents && r2(e22.breakContents), i3 = e22.flatContents && r2(e22.flatContents);
          return t2(Object.assign(Object.assign({}, e22), {}, {breakContents: n3, flatContents: i3}));
        }
        if (e22.type === "group" && e22.expandedStates) {
          const n3 = e22.expandedStates.map(r2), i3 = n3[0];
          return t2(Object.assign(Object.assign({}, e22), {}, {contents: i3, expandedStates: n3}));
        }
        if (e22.contents) {
          const n3 = r2(e22.contents);
          return t2(Object.assign(Object.assign({}, e22), {}, {contents: n3}));
        }
        return t2(e22);
      }(e21);
      return n2.set(e21, i2), i2;
    }
  }
  function xi$2(e20, t2, n2) {
    let r2 = n2, i2 = false;
    return Fi$2(e20, function(e21) {
      const n3 = t2(e21);
      if (n3 !== void 0 && (i2 = true, r2 = n3), i2)
        return false;
    }), r2;
  }
  function wi$2(e20) {
    return !(e20.type !== "group" || !e20.break) || (!(e20.type !== "line" || !e20.hard) || (e20.type === "break-parent" || void 0));
  }
  function Ti$2(e20) {
    if (e20.length > 0) {
      const t2 = Ln$2(e20);
      t2.expandedStates || t2.break || (t2.break = "propagated");
    }
    return null;
  }
  function Bi$2(e20) {
    return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
  }
  const Ni$2 = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
  function ki$2(e20) {
    if (!e20)
      return e20;
    if (bi$2(e20) || e20.type === "fill") {
      const t2 = Ai$2(e20);
      for (; t2.length > 1 && Ni$2(...t2.slice(-2)); )
        t2.length -= 2;
      if (t2.length > 0) {
        const e21 = ki$2(Ln$2(t2));
        t2[t2.length - 1] = e21;
      }
      return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, {parts: t2});
    }
    switch (e20.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        const t2 = ki$2(e20.contents);
        return Object.assign(Object.assign({}, e20), {}, {contents: t2});
      }
      case "if-break": {
        const t2 = ki$2(e20.breakContents), n2 = ki$2(e20.flatContents);
        return Object.assign(Object.assign({}, e20), {}, {breakContents: t2, flatContents: n2});
      }
    }
    return e20;
  }
  function Pi$2(e20) {
    return Si$2(e20, (e21) => function(e22) {
      switch (e22.type) {
        case "fill":
          if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
            return "";
          break;
        case "group":
          if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
            return "";
          if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
            return e22.contents;
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!e22.contents)
            return "";
          break;
        case "if-break":
          if (!e22.flatContents && !e22.breakContents)
            return "";
      }
      if (!bi$2(e22))
        return e22;
      const t2 = [];
      for (const n2 of Ai$2(e22)) {
        if (!n2)
          continue;
        const [e23, ...r2] = bi$2(n2) ? Ai$2(n2) : [n2];
        typeof e23 == "string" && typeof Ln$2(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...r2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, {parts: t2});
    }(e21));
  }
  function Oi$2(e20) {
    const t2 = [], n2 = e20.filter(Boolean);
    for (; n2.length > 0; ) {
      const e21 = n2.shift();
      e21 && (bi$2(e21) ? n2.unshift(...Ai$2(e21)) : t2.length > 0 && typeof Ln$2(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
    }
    return t2;
  }
  function Ii$2(e20, t2 = Ei$2) {
    return Ci$2(t2, e20.split("\n")).parts;
  }
  var Li$2 = {isConcat: bi$2, getDocParts: Ai$2, willBreak: function(e20) {
    return xi$2(e20, wi$2, false);
  }, traverseDoc: Fi$2, findInDoc: xi$2, mapDoc: Si$2, propagateBreaks: function(e20) {
    const t2 = new Set(), n2 = [];
    Fi$2(e20, function(e21) {
      if (e21.type === "break-parent" && Ti$2(n2), e21.type === "group") {
        if (n2.push(e21), t2.has(e21))
          return false;
        t2.add(e21);
      }
    }, function(e21) {
      if (e21.type === "group") {
        n2.pop().break && Ti$2(n2);
      }
    }, true);
  }, removeLines: function(e20) {
    return Si$2(e20, Bi$2);
  }, stripTrailingHardline: function(e20) {
    return ki$2(Pi$2(e20));
  }, normalizeParts: Oi$2, normalizeDoc: function(e20) {
    return Si$2(e20, (e21) => Array.isArray(e21) ? Oi$2(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, {parts: Oi$2(e21.parts)}) : e21);
  }, cleanDoc: Pi$2, replaceTextEndOfLine: Ii$2, replaceEndOfLine: function(e20) {
    return Si$2(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? Ii$2(e21) : e21);
  }};
  const {getStringWidth: ji$2, getLast: _i$2} = yi$2, {convertEndOfLineToChars: Mi$2} = Di$2, {fill: Ri$2, cursor: $i$2, indent: Vi$2} = xn$2, {isConcat: Wi$2, getDocParts: qi$2} = Li$2;
  let Ui$2;
  function zi$2(e20, t2) {
    return Hi$2(e20, {type: "indent"}, t2);
  }
  function Gi$2(e20, t2, n2) {
    if (t2 === Number.NEGATIVE_INFINITY)
      return e20.root || {value: "", length: 0, queue: []};
    if (t2 < 0)
      return Hi$2(e20, {type: "dedent"}, n2);
    if (!t2)
      return e20;
    if (t2.type === "root")
      return Object.assign(Object.assign({}, e20), {}, {root: e20});
    return Hi$2(e20, {type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2}, n2);
  }
  function Hi$2(e20, t2, n2) {
    const r2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
    let i2 = "", u2 = 0, o2 = 0, s2 = 0;
    for (const e21 of r2)
      switch (e21.type) {
        case "indent":
          l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
          break;
        case "stringAlign":
          l2(), i2 += e21.n, u2 += e21.n.length;
          break;
        case "numberAlign":
          o2 += 1, s2 += e21.n;
          break;
        default:
          throw new Error(`Unexpected type '${e21.type}'`);
      }
    return p2(), Object.assign(Object.assign({}, e20), {}, {value: i2, length: u2, queue: r2});
    function a2(e21) {
      i2 += "	".repeat(e21), u2 += n2.tabWidth * e21;
    }
    function c2(e21) {
      i2 += " ".repeat(e21), u2 += e21;
    }
    function l2() {
      n2.useTabs ? function() {
        o2 > 0 && a2(o2);
        f2();
      }() : p2();
    }
    function p2() {
      s2 > 0 && c2(s2), f2();
    }
    function f2() {
      o2 = 0, s2 = 0;
    }
  }
  function Ji$2(e20) {
    if (e20.length === 0)
      return 0;
    let t2 = 0;
    for (; e20.length > 0 && typeof _i$2(e20) == "string" && /^[\t ]*$/.test(_i$2(e20)); )
      t2 += e20.pop().length;
    if (e20.length > 0 && typeof _i$2(e20) == "string") {
      const n2 = _i$2(e20).replace(/[\t ]*$/, "");
      t2 += _i$2(e20).length - n2.length, e20[e20.length - 1] = n2;
    }
    return t2;
  }
  function Xi$2(e20, t2, n2, r2, i2, u2) {
    let o2 = t2.length;
    const s2 = [e20], a2 = [];
    for (; n2 >= 0; ) {
      if (s2.length === 0) {
        if (o2 === 0)
          return true;
        s2.push(t2[o2 - 1]), o2--;
        continue;
      }
      const [e21, c2, l2] = s2.pop();
      if (typeof l2 == "string")
        a2.push(l2), n2 -= ji$2(l2);
      else if (Wi$2(l2)) {
        const t3 = qi$2(l2);
        for (let n3 = t3.length - 1; n3 >= 0; n3--)
          s2.push([e21, c2, t3[n3]]);
      } else
        switch (l2.type) {
          case "indent":
            s2.push([zi$2(e21, r2), c2, l2.contents]);
            break;
          case "align":
            s2.push([Gi$2(e21, l2.n, r2), c2, l2.contents]);
            break;
          case "trim":
            n2 += Ji$2(a2);
            break;
          case "group": {
            if (u2 && l2.break)
              return false;
            const t3 = l2.break ? 1 : c2;
            s2.push([e21, t3, l2.expandedStates && t3 === 1 ? _i$2(l2.expandedStates) : l2.contents]), l2.id && (Ui$2[l2.id] = t3);
            break;
          }
          case "fill":
            for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
              s2.push([e21, c2, l2.parts[t3]]);
            break;
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Ui$2[l2.groupId] : c2;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
              t4 && s2.push([e21, c2, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
              t4 && s2.push([e21, c2, t4]);
            }
            break;
          }
          case "line":
            switch (c2) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (a2.push(" "), n2 -= 1);
                  break;
                }
                return true;
              case 1:
                return true;
            }
            break;
          case "line-suffix":
            i2 = true;
            break;
          case "line-suffix-boundary":
            if (i2)
              return false;
            break;
          case "label":
            s2.push([e21, c2, l2.contents]);
        }
    }
    return false;
  }
  var Yi$2 = {printDocToString: function(e20, t2) {
    Ui$2 = {};
    const n2 = t2.printWidth, r2 = Mi$2(t2.endOfLine);
    let i2 = 0;
    const u2 = [[{value: "", length: 0, queue: []}, 1, e20]], o2 = [];
    let s2 = false, a2 = [];
    for (; u2.length > 0; ) {
      const [e21, c3, l2] = u2.pop();
      if (typeof l2 == "string") {
        const e22 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
        o2.push(e22), i2 += ji$2(e22);
      } else if (Wi$2(l2)) {
        const t3 = qi$2(l2);
        for (let n3 = t3.length - 1; n3 >= 0; n3--)
          u2.push([e21, c3, t3[n3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push($i$2.placeholder);
            break;
          case "indent":
            u2.push([zi$2(e21, t2), c3, l2.contents]);
            break;
          case "align":
            u2.push([Gi$2(e21, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ji$2(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!s2) {
                  u2.push([e21, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                s2 = false;
                const r3 = [e21, 2, l2.contents], o3 = n2 - i2, c4 = a2.length > 0;
                if (!l2.break && Xi$2(r3, u2, o3, t2, c4))
                  u2.push(r3);
                else if (l2.expandedStates) {
                  const n3 = _i$2(l2.expandedStates);
                  if (l2.break) {
                    u2.push([e21, 1, n3]);
                    break;
                  }
                  for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                    if (r4 >= l2.expandedStates.length) {
                      u2.push([e21, 1, n3]);
                      break;
                    }
                    {
                      const n4 = [e21, 2, l2.expandedStates[r4]];
                      if (Xi$2(n4, u2, o3, t2, c4)) {
                        u2.push(n4);
                        break;
                      }
                    }
                  }
                } else
                  u2.push([e21, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Ui$2[l2.id] = _i$2(u2)[1]);
            break;
          case "fill": {
            const r3 = n2 - i2, {parts: o3} = l2;
            if (o3.length === 0)
              break;
            const [s3, p2] = o3, f2 = [e21, 2, s3], d2 = [e21, 1, s3], h2 = Xi$2(f2, [], r3, t2, a2.length > 0, true);
            if (o3.length === 1) {
              h2 ? u2.push(f2) : u2.push(d2);
              break;
            }
            const g2 = [e21, 2, p2], m2 = [e21, 1, p2];
            if (o3.length === 2) {
              h2 ? u2.push(g2, f2) : u2.push(m2, d2);
              break;
            }
            o3.splice(0, 2);
            const y2 = [e21, c3, Ri$2(o3)];
            Xi$2([e21, 2, [s3, p2, o3[0]]], [], r3, t2, a2.length > 0, true) ? u2.push(y2, g2, f2) : h2 ? u2.push(y2, m2, f2) : u2.push(y2, m2, d2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Ui$2[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
              t4 && u2.push([e21, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
              t4 && u2.push([e21, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            a2.push([e21, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            a2.length > 0 && u2.push([e21, c3, {type: "line", hard: true}]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                s2 = true;
              case 1:
                if (a2.length > 0) {
                  u2.push([e21, c3, l2], ...a2.reverse()), a2 = [];
                  break;
                }
                l2.literal ? e21.root ? (o2.push(r2, e21.root.value), i2 = e21.root.length) : (o2.push(r2), i2 = 0) : (i2 -= Ji$2(o2), o2.push(r2 + e21.value), i2 = e21.length);
            }
            break;
          case "label":
            u2.push([e21, c3, l2.contents]);
        }
      u2.length === 0 && a2.length > 0 && (u2.push(...a2.reverse()), a2 = []);
    }
    const c2 = o2.indexOf($i$2.placeholder);
    if (c2 !== -1) {
      const e21 = o2.indexOf($i$2.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), n3 = o2.slice(c2 + 1, e21).join("");
      return {formatted: t3 + n3 + o2.slice(e21 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3};
    }
    return {formatted: o2.join("")};
  }};
  const {isConcat: Ki$2, getDocParts: Qi$2} = Li$2;
  function Zi$2(e20) {
    if (!e20)
      return "";
    if (Ki$2(e20)) {
      const t2 = [];
      for (const n2 of Qi$2(e20))
        if (Ki$2(n2))
          t2.push(...Zi$2(n2).parts);
        else {
          const e21 = Zi$2(n2);
          e21 !== "" && t2.push(e21);
        }
      return {type: "concat", parts: t2};
    }
    return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {breakContents: Zi$2(e20.breakContents), flatContents: Zi$2(e20.flatContents)}) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {contents: Zi$2(e20.contents), expandedStates: e20.expandedStates && e20.expandedStates.map(Zi$2)}) : e20.type === "fill" ? {type: "fill", parts: e20.parts.map(Zi$2)} : e20.contents ? Object.assign(Object.assign({}, e20), {}, {contents: Zi$2(e20.contents)}) : e20;
  }
  var eu$1 = {builders: xn$2, printer: Yi$2, utils: Li$2, debug: {printDocToDebug: function(e20) {
    const t2 = Object.create(null), n2 = new Set();
    return function e21(t3, n3, i2) {
      if (typeof t3 == "string")
        return JSON.stringify(t3);
      if (Ki$2(t3)) {
        const n4 = Qi$2(t3).map(e21).filter(Boolean);
        return n4.length === 1 ? n4[0] : `[${n4.join(", ")}]`;
      }
      if (t3.type === "line") {
        const e22 = Array.isArray(i2) && i2[n3 + 1] && i2[n3 + 1].type === "break-parent";
        return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
      }
      if (t3.type === "break-parent") {
        return Array.isArray(i2) && i2[n3 - 1] && i2[n3 - 1].type === "line" && i2[n3 - 1].hard ? void 0 : "breakParent";
      }
      if (t3.type === "trim")
        return "trim";
      if (t3.type === "indent")
        return "indent(" + e21(t3.contents) + ")";
      if (t3.type === "align")
        return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
      if (t3.type === "if-break")
        return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${r2(t3.groupId)} }` : "") + ")";
      if (t3.type === "indent-if-break") {
        const n4 = [];
        t3.negate && n4.push("negate: true"), t3.groupId && n4.push(`groupId: ${r2(t3.groupId)}`);
        const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
        return `indentIfBreak(${e21(t3.contents)}${i3})`;
      }
      if (t3.type === "group") {
        const n4 = [];
        t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push(`id: ${r2(t3.id)}`);
        const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
        return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
      }
      if (t3.type === "fill")
        return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
      if (t3.type === "line-suffix")
        return "lineSuffix(" + e21(t3.contents) + ")";
      if (t3.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (t3.type === "label")
        return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
      throw new Error("Unknown doc type " + t3.type);
    }(Zi$2(e20));
    function r2(e21) {
      if (typeof e21 != "symbol")
        return JSON.stringify(String(e21));
      if (e21 in t2)
        return t2[e21];
      const r3 = String(e21).slice(7, -1) || "symbol";
      for (let i2 = 0; ; i2++) {
        const u2 = r3 + (i2 > 0 ? ` #${i2}` : "");
        if (!n2.has(u2))
          return n2.add(u2), t2[e21] = `Symbol.for(${JSON.stringify(u2)})`;
      }
    }
  }}}, tu$1 = Object.freeze({__proto__: null, default: {}});
  function nu$1(e20, t2) {
    for (var n2 = 0, r2 = e20.length - 1; r2 >= 0; r2--) {
      var i2 = e20[r2];
      i2 === "." ? e20.splice(r2, 1) : i2 === ".." ? (e20.splice(r2, 1), n2++) : n2 && (e20.splice(r2, 1), n2--);
    }
    if (t2)
      for (; n2--; n2)
        e20.unshift("..");
    return e20;
  }
  var ru$1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, iu$1 = function(e20) {
    return ru$1.exec(e20).slice(1);
  };
  function uu$1() {
    for (var e20 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
      var r2 = n2 >= 0 ? arguments[n2] : "/";
      if (typeof r2 != "string")
        throw new TypeError("Arguments to path.resolve must be strings");
      r2 && (e20 = r2 + "/" + e20, t2 = r2.charAt(0) === "/");
    }
    return (t2 ? "/" : "") + (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
      return !!e21;
    }), !t2).join("/")) || ".";
  }
  function ou$1(e20) {
    var t2 = su$1(e20), n2 = gu$1(e20, -1) === "/";
    return (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
      return !!e21;
    }), !t2).join("/")) || t2 || (e20 = "."), e20 && n2 && (e20 += "/"), (t2 ? "/" : "") + e20;
  }
  function su$1(e20) {
    return e20.charAt(0) === "/";
  }
  function au$1() {
    var e20 = Array.prototype.slice.call(arguments, 0);
    return ou$1(hu$1(e20, function(e21, t2) {
      if (typeof e21 != "string")
        throw new TypeError("Arguments to path.join must be strings");
      return e21;
    }).join("/"));
  }
  function cu$1(e20, t2) {
    function n2(e21) {
      for (var t3 = 0; t3 < e21.length && e21[t3] === ""; t3++)
        ;
      for (var n3 = e21.length - 1; n3 >= 0 && e21[n3] === ""; n3--)
        ;
      return t3 > n3 ? [] : e21.slice(t3, n3 - t3 + 1);
    }
    e20 = uu$1(e20).substr(1), t2 = uu$1(t2).substr(1);
    for (var r2 = n2(e20.split("/")), i2 = n2(t2.split("/")), u2 = Math.min(r2.length, i2.length), o2 = u2, s2 = 0; s2 < u2; s2++)
      if (r2[s2] !== i2[s2]) {
        o2 = s2;
        break;
      }
    var a2 = [];
    for (s2 = o2; s2 < r2.length; s2++)
      a2.push("..");
    return (a2 = a2.concat(i2.slice(o2))).join("/");
  }
  function lu$1(e20) {
    var t2 = iu$1(e20), n2 = t2[0], r2 = t2[1];
    return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
  }
  function pu$1(e20, t2) {
    var n2 = iu$1(e20)[2];
    return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
  }
  function fu$1(e20) {
    return iu$1(e20)[3];
  }
  var du$1 = {extname: fu$1, basename: pu$1, dirname: lu$1, sep: "/", delimiter: ":", relative: cu$1, join: au$1, isAbsolute: su$1, normalize: ou$1, resolve: uu$1};
  function hu$1(e20, t2) {
    if (e20.filter)
      return e20.filter(t2);
    for (var n2 = [], r2 = 0; r2 < e20.length; r2++)
      t2(e20[r2], r2, e20) && n2.push(e20[r2]);
    return n2;
  }
  var gu$1 = "ab".substr(-1) === "b" ? function(e20, t2, n2) {
    return e20.substr(t2, n2);
  } : function(e20, t2, n2) {
    return t2 < 0 && (t2 = e20.length + t2), e20.substr(t2, n2);
  }, mu$1 = Object.freeze({__proto__: null, resolve: uu$1, normalize: ou$1, isAbsolute: su$1, join: au$1, relative: cu$1, sep: "/", delimiter: ":", dirname: lu$1, basename: pu$1, extname: fu$1, default: du$1}), yu$1 = [], Du$1 = [], Eu$1 = typeof Uint8Array != "undefined" ? Uint8Array : Array, Cu$1 = false;
  function bu$1() {
    Cu$1 = true;
    for (var e20 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e20.length; t2 < n2; ++t2)
      yu$1[t2] = e20[t2], Du$1[e20.charCodeAt(t2)] = t2;
    Du$1["-".charCodeAt(0)] = 62, Du$1["_".charCodeAt(0)] = 63;
  }
  function Au$1(e20, t2, n2) {
    for (var r2, i2, u2 = [], o2 = t2; o2 < n2; o2 += 3)
      r2 = (e20[o2] << 16) + (e20[o2 + 1] << 8) + e20[o2 + 2], u2.push(yu$1[(i2 = r2) >> 18 & 63] + yu$1[i2 >> 12 & 63] + yu$1[i2 >> 6 & 63] + yu$1[63 & i2]);
    return u2.join("");
  }
  function vu$1(e20) {
    var t2;
    Cu$1 || bu$1();
    for (var n2 = e20.length, r2 = n2 % 3, i2 = "", u2 = [], o2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += o2)
      u2.push(Au$1(e20, s2, s2 + o2 > a2 ? a2 : s2 + o2));
    return r2 === 1 ? (t2 = e20[n2 - 1], i2 += yu$1[t2 >> 2], i2 += yu$1[t2 << 4 & 63], i2 += "==") : r2 === 2 && (t2 = (e20[n2 - 2] << 8) + e20[n2 - 1], i2 += yu$1[t2 >> 10], i2 += yu$1[t2 >> 4 & 63], i2 += yu$1[t2 << 2 & 63], i2 += "="), u2.push(i2), u2.join("");
  }
  function Fu$1(e20, t2, n2, r2, i2) {
    var u2, o2, s2 = 8 * i2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? i2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e20[t2 + p2];
    for (p2 += f2, u2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; u2 = 256 * u2 + e20[t2 + p2], p2 += f2, l2 -= 8)
      ;
    for (o2 = u2 & (1 << -l2) - 1, u2 >>= -l2, l2 += r2; l2 > 0; o2 = 256 * o2 + e20[t2 + p2], p2 += f2, l2 -= 8)
      ;
    if (u2 === 0)
      u2 = 1 - c2;
    else {
      if (u2 === a2)
        return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
      o2 += Math.pow(2, r2), u2 -= c2;
    }
    return (d2 ? -1 : 1) * o2 * Math.pow(2, u2 - r2);
  }
  function Su$1(e20, t2, n2, r2, i2, u2) {
    var o2, s2, a2, c2 = 8 * u2 - i2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : u2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -o2)) < 1 && (o2--, a2 *= 2), (t2 += o2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (o2++, a2 /= 2), o2 + p2 >= l2 ? (s2 = 0, o2 = l2) : o2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, i2), o2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e20[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, i2 -= 8)
      ;
    for (o2 = o2 << i2 | s2, c2 += i2; c2 > 0; e20[n2 + d2] = 255 & o2, d2 += h2, o2 /= 256, c2 -= 8)
      ;
    e20[n2 + d2 - h2] |= 128 * g2;
  }
  var xu$1 = {}.toString, wu$1 = Array.isArray || function(e20) {
    return xu$1.call(e20) == "[object Array]";
  };
  function Tu$1() {
    return Nu$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function Bu$1(e20, t2) {
    if (Tu$1() < t2)
      throw new RangeError("Invalid typed array length");
    return Nu$1.TYPED_ARRAY_SUPPORT ? (e20 = new Uint8Array(t2)).__proto__ = Nu$1.prototype : (e20 === null && (e20 = new Nu$1(t2)), e20.length = t2), e20;
  }
  function Nu$1(e20, t2, n2) {
    if (!(Nu$1.TYPED_ARRAY_SUPPORT || this instanceof Nu$1))
      return new Nu$1(e20, t2, n2);
    if (typeof e20 == "number") {
      if (typeof t2 == "string")
        throw new Error("If encoding is specified then the first argument must be a string");
      return Ou$1(this, e20);
    }
    return ku$1(this, e20, t2, n2);
  }
  function ku$1(e20, t2, n2, r2) {
    if (typeof t2 == "number")
      throw new TypeError('"value" argument must not be a number');
    return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e21, t3, n3, r3) {
      if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
        throw new RangeError("'offset' is out of bounds");
      if (t3.byteLength < n3 + (r3 || 0))
        throw new RangeError("'length' is out of bounds");
      t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
      Nu$1.TYPED_ARRAY_SUPPORT ? (e21 = t3).__proto__ = Nu$1.prototype : e21 = Iu$1(e21, t3);
      return e21;
    }(e20, t2, n2, r2) : typeof t2 == "string" ? function(e21, t3, n3) {
      typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
      if (!Nu$1.isEncoding(n3))
        throw new TypeError('"encoding" must be a valid string encoding');
      var r3 = 0 | _u$1(t3, n3), i2 = (e21 = Bu$1(e21, r3)).write(t3, n3);
      i2 !== r3 && (e21 = e21.slice(0, i2));
      return e21;
    }(e20, t2, n2) : function(e21, t3) {
      if (ju$1(t3)) {
        var n3 = 0 | Lu$1(t3.length);
        return (e21 = Bu$1(e21, n3)).length === 0 || t3.copy(e21, 0, 0, n3), e21;
      }
      if (t3) {
        if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
          return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Bu$1(e21, 0) : Iu$1(e21, t3);
        if (t3.type === "Buffer" && wu$1(t3.data))
          return Iu$1(e21, t3.data);
      }
      var r3;
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }(e20, t2);
  }
  function Pu$1(e20) {
    if (typeof e20 != "number")
      throw new TypeError('"size" argument must be a number');
    if (e20 < 0)
      throw new RangeError('"size" argument must not be negative');
  }
  function Ou$1(e20, t2) {
    if (Pu$1(t2), e20 = Bu$1(e20, t2 < 0 ? 0 : 0 | Lu$1(t2)), !Nu$1.TYPED_ARRAY_SUPPORT)
      for (var n2 = 0; n2 < t2; ++n2)
        e20[n2] = 0;
    return e20;
  }
  function Iu$1(e20, t2) {
    var n2 = t2.length < 0 ? 0 : 0 | Lu$1(t2.length);
    e20 = Bu$1(e20, n2);
    for (var r2 = 0; r2 < n2; r2 += 1)
      e20[r2] = 255 & t2[r2];
    return e20;
  }
  function Lu$1(e20) {
    if (e20 >= Tu$1())
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Tu$1().toString(16) + " bytes");
    return 0 | e20;
  }
  function ju$1(e20) {
    return !(e20 == null || !e20._isBuffer);
  }
  function _u$1(e20, t2) {
    if (ju$1(e20))
      return e20.length;
    if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e20) || e20 instanceof ArrayBuffer))
      return e20.byteLength;
    typeof e20 != "string" && (e20 = "" + e20);
    var n2 = e20.length;
    if (n2 === 0)
      return 0;
    for (var r2 = false; ; )
      switch (t2) {
        case "ascii":
        case "latin1":
        case "binary":
          return n2;
        case "utf8":
        case "utf-8":
        case void 0:
          return co$2(e20).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * n2;
        case "hex":
          return n2 >>> 1;
        case "base64":
          return lo$2(e20).length;
        default:
          if (r2)
            return co$2(e20).length;
          t2 = ("" + t2).toLowerCase(), r2 = true;
      }
  }
  function Mu$1(e20, t2, n2) {
    var r2 = false;
    if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
      return "";
    if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
      return "";
    if ((n2 >>>= 0) <= (t2 >>>= 0))
      return "";
    for (e20 || (e20 = "utf8"); ; )
      switch (e20) {
        case "hex":
          return Qu(this, t2, n2);
        case "utf8":
        case "utf-8":
          return Xu(this, t2, n2);
        case "ascii":
          return Yu(this, t2, n2);
        case "latin1":
        case "binary":
          return Ku(this, t2, n2);
        case "base64":
          return Ju(this, t2, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Zu(this, t2, n2);
        default:
          if (r2)
            throw new TypeError("Unknown encoding: " + e20);
          e20 = (e20 + "").toLowerCase(), r2 = true;
      }
  }
  function Ru$1(e20, t2, n2) {
    var r2 = e20[t2];
    e20[t2] = e20[n2], e20[n2] = r2;
  }
  function $u(e20, t2, n2, r2, i2) {
    if (e20.length === 0)
      return -1;
    if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e20.length - 1), n2 < 0 && (n2 = e20.length + n2), n2 >= e20.length) {
      if (i2)
        return -1;
      n2 = e20.length - 1;
    } else if (n2 < 0) {
      if (!i2)
        return -1;
      n2 = 0;
    }
    if (typeof t2 == "string" && (t2 = Nu$1.from(t2, r2)), ju$1(t2))
      return t2.length === 0 ? -1 : Vu(e20, t2, n2, r2, i2);
    if (typeof t2 == "number")
      return t2 &= 255, Nu$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e20, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e20, t2, n2) : Vu(e20, [t2], n2, r2, i2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Vu(e20, t2, n2, r2, i2) {
    var u2, o2 = 1, s2 = e20.length, a2 = t2.length;
    if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
      if (e20.length < 2 || t2.length < 2)
        return -1;
      o2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
    }
    function c2(e21, t3) {
      return o2 === 1 ? e21[t3] : e21.readUInt16BE(t3 * o2);
    }
    if (i2) {
      var l2 = -1;
      for (u2 = n2; u2 < s2; u2++)
        if (c2(e20, u2) === c2(t2, l2 === -1 ? 0 : u2 - l2)) {
          if (l2 === -1 && (l2 = u2), u2 - l2 + 1 === a2)
            return l2 * o2;
        } else
          l2 !== -1 && (u2 -= u2 - l2), l2 = -1;
    } else
      for (n2 + a2 > s2 && (n2 = s2 - a2), u2 = n2; u2 >= 0; u2--) {
        for (var p2 = true, f2 = 0; f2 < a2; f2++)
          if (c2(e20, u2 + f2) !== c2(t2, f2)) {
            p2 = false;
            break;
          }
        if (p2)
          return u2;
      }
    return -1;
  }
  function Wu(e20, t2, n2, r2) {
    n2 = Number(n2) || 0;
    var i2 = e20.length - n2;
    r2 ? (r2 = Number(r2)) > i2 && (r2 = i2) : r2 = i2;
    var u2 = t2.length;
    if (u2 % 2 != 0)
      throw new TypeError("Invalid hex string");
    r2 > u2 / 2 && (r2 = u2 / 2);
    for (var o2 = 0; o2 < r2; ++o2) {
      var s2 = parseInt(t2.substr(2 * o2, 2), 16);
      if (isNaN(s2))
        return o2;
      e20[n2 + o2] = s2;
    }
    return o2;
  }
  function qu(e20, t2, n2, r2) {
    return po$2(co$2(t2, e20.length - n2), e20, n2, r2);
  }
  function Uu$1(e20, t2, n2, r2) {
    return po$2(function(e21) {
      for (var t3 = [], n3 = 0; n3 < e21.length; ++n3)
        t3.push(255 & e21.charCodeAt(n3));
      return t3;
    }(t2), e20, n2, r2);
  }
  function zu(e20, t2, n2, r2) {
    return Uu$1(e20, t2, n2, r2);
  }
  function Gu(e20, t2, n2, r2) {
    return po$2(lo$2(t2), e20, n2, r2);
  }
  function Hu(e20, t2, n2, r2) {
    return po$2(function(e21, t3) {
      for (var n3, r3, i2, u2 = [], o2 = 0; o2 < e21.length && !((t3 -= 2) < 0); ++o2)
        r3 = (n3 = e21.charCodeAt(o2)) >> 8, i2 = n3 % 256, u2.push(i2), u2.push(r3);
      return u2;
    }(t2, e20.length - n2), e20, n2, r2);
  }
  function Ju(e20, t2, n2) {
    return t2 === 0 && n2 === e20.length ? vu$1(e20) : vu$1(e20.slice(t2, n2));
  }
  function Xu(e20, t2, n2) {
    n2 = Math.min(e20.length, n2);
    for (var r2 = [], i2 = t2; i2 < n2; ) {
      var u2, o2, s2, a2, c2 = e20[i2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
      if (i2 + p2 <= n2)
        switch (p2) {
          case 1:
            c2 < 128 && (l2 = c2);
            break;
          case 2:
            (192 & (u2 = e20[i2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & u2) > 127 && (l2 = a2);
            break;
          case 3:
            u2 = e20[i2 + 1], o2 = e20[i2 + 2], (192 & u2) == 128 && (192 & o2) == 128 && (a2 = (15 & c2) << 12 | (63 & u2) << 6 | 63 & o2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
            break;
          case 4:
            u2 = e20[i2 + 1], o2 = e20[i2 + 2], s2 = e20[i2 + 3], (192 & u2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
        }
      l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), i2 += p2;
    }
    return function(e21) {
      var t3 = e21.length;
      if (t3 <= 4096)
        return String.fromCharCode.apply(String, e21);
      var n3 = "", r3 = 0;
      for (; r3 < t3; )
        n3 += String.fromCharCode.apply(String, e21.slice(r3, r3 += 4096));
      return n3;
    }(r2);
  }
  Nu$1.TYPED_ARRAY_SUPPORT = nr$2.TYPED_ARRAY_SUPPORT === void 0 || nr$2.TYPED_ARRAY_SUPPORT, Nu$1.poolSize = 8192, Nu$1._augment = function(e20) {
    return e20.__proto__ = Nu$1.prototype, e20;
  }, Nu$1.from = function(e20, t2, n2) {
    return ku$1(null, e20, t2, n2);
  }, Nu$1.TYPED_ARRAY_SUPPORT && (Nu$1.prototype.__proto__ = Uint8Array.prototype, Nu$1.__proto__ = Uint8Array), Nu$1.alloc = function(e20, t2, n2) {
    return function(e21, t3, n3, r2) {
      return Pu$1(t3), t3 <= 0 ? Bu$1(e21, t3) : n3 !== void 0 ? typeof r2 == "string" ? Bu$1(e21, t3).fill(n3, r2) : Bu$1(e21, t3).fill(n3) : Bu$1(e21, t3);
    }(null, e20, t2, n2);
  }, Nu$1.allocUnsafe = function(e20) {
    return Ou$1(null, e20);
  }, Nu$1.allocUnsafeSlow = function(e20) {
    return Ou$1(null, e20);
  }, Nu$1.isBuffer = fo$2, Nu$1.compare = function(e20, t2) {
    if (!ju$1(e20) || !ju$1(t2))
      throw new TypeError("Arguments must be Buffers");
    if (e20 === t2)
      return 0;
    for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
      if (e20[i2] !== t2[i2]) {
        n2 = e20[i2], r2 = t2[i2];
        break;
      }
    return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
  }, Nu$1.isEncoding = function(e20) {
    switch (String(e20).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, Nu$1.concat = function(e20, t2) {
    if (!wu$1(e20))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e20.length === 0)
      return Nu$1.alloc(0);
    var n2;
    if (t2 === void 0)
      for (t2 = 0, n2 = 0; n2 < e20.length; ++n2)
        t2 += e20[n2].length;
    var r2 = Nu$1.allocUnsafe(t2), i2 = 0;
    for (n2 = 0; n2 < e20.length; ++n2) {
      var u2 = e20[n2];
      if (!ju$1(u2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      u2.copy(r2, i2), i2 += u2.length;
    }
    return r2;
  }, Nu$1.byteLength = _u$1, Nu$1.prototype._isBuffer = true, Nu$1.prototype.swap16 = function() {
    var e20 = this.length;
    if (e20 % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t2 = 0; t2 < e20; t2 += 2)
      Ru$1(this, t2, t2 + 1);
    return this;
  }, Nu$1.prototype.swap32 = function() {
    var e20 = this.length;
    if (e20 % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t2 = 0; t2 < e20; t2 += 4)
      Ru$1(this, t2, t2 + 3), Ru$1(this, t2 + 1, t2 + 2);
    return this;
  }, Nu$1.prototype.swap64 = function() {
    var e20 = this.length;
    if (e20 % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t2 = 0; t2 < e20; t2 += 8)
      Ru$1(this, t2, t2 + 7), Ru$1(this, t2 + 1, t2 + 6), Ru$1(this, t2 + 2, t2 + 5), Ru$1(this, t2 + 3, t2 + 4);
    return this;
  }, Nu$1.prototype.toString = function() {
    var e20 = 0 | this.length;
    return e20 === 0 ? "" : arguments.length === 0 ? Xu(this, 0, e20) : Mu$1.apply(this, arguments);
  }, Nu$1.prototype.equals = function(e20) {
    if (!ju$1(e20))
      throw new TypeError("Argument must be a Buffer");
    return this === e20 || Nu$1.compare(this, e20) === 0;
  }, Nu$1.prototype.inspect = function() {
    var e20 = "";
    return this.length > 0 && (e20 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e20 += " ... ")), "<Buffer " + e20 + ">";
  }, Nu$1.prototype.compare = function(e20, t2, n2, r2, i2) {
    if (!ju$1(e20))
      throw new TypeError("Argument must be a Buffer");
    if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e20 ? e20.length : 0), r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = this.length), t2 < 0 || n2 > e20.length || r2 < 0 || i2 > this.length)
      throw new RangeError("out of range index");
    if (r2 >= i2 && t2 >= n2)
      return 0;
    if (r2 >= i2)
      return -1;
    if (t2 >= n2)
      return 1;
    if (this === e20)
      return 0;
    for (var u2 = (i2 >>>= 0) - (r2 >>>= 0), o2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(u2, o2), a2 = this.slice(r2, i2), c2 = e20.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
      if (a2[l2] !== c2[l2]) {
        u2 = a2[l2], o2 = c2[l2];
        break;
      }
    return u2 < o2 ? -1 : o2 < u2 ? 1 : 0;
  }, Nu$1.prototype.includes = function(e20, t2, n2) {
    return this.indexOf(e20, t2, n2) !== -1;
  }, Nu$1.prototype.indexOf = function(e20, t2, n2) {
    return $u(this, e20, t2, n2, true);
  }, Nu$1.prototype.lastIndexOf = function(e20, t2, n2) {
    return $u(this, e20, t2, n2, false);
  }, Nu$1.prototype.write = function(e20, t2, n2, r2) {
    if (t2 === void 0)
      r2 = "utf8", n2 = this.length, t2 = 0;
    else if (n2 === void 0 && typeof t2 == "string")
      r2 = t2, n2 = this.length, t2 = 0;
    else {
      if (!isFinite(t2))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
    }
    var i2 = this.length - t2;
    if ((n2 === void 0 || n2 > i2) && (n2 = i2), e20.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    r2 || (r2 = "utf8");
    for (var u2 = false; ; )
      switch (r2) {
        case "hex":
          return Wu(this, e20, t2, n2);
        case "utf8":
        case "utf-8":
          return qu(this, e20, t2, n2);
        case "ascii":
          return Uu$1(this, e20, t2, n2);
        case "latin1":
        case "binary":
          return zu(this, e20, t2, n2);
        case "base64":
          return Gu(this, e20, t2, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Hu(this, e20, t2, n2);
        default:
          if (u2)
            throw new TypeError("Unknown encoding: " + r2);
          r2 = ("" + r2).toLowerCase(), u2 = true;
      }
  }, Nu$1.prototype.toJSON = function() {
    return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
  };
  function Yu(e20, t2, n2) {
    var r2 = "";
    n2 = Math.min(e20.length, n2);
    for (var i2 = t2; i2 < n2; ++i2)
      r2 += String.fromCharCode(127 & e20[i2]);
    return r2;
  }
  function Ku(e20, t2, n2) {
    var r2 = "";
    n2 = Math.min(e20.length, n2);
    for (var i2 = t2; i2 < n2; ++i2)
      r2 += String.fromCharCode(e20[i2]);
    return r2;
  }
  function Qu(e20, t2, n2) {
    var r2 = e20.length;
    (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
    for (var i2 = "", u2 = t2; u2 < n2; ++u2)
      i2 += ao$2(e20[u2]);
    return i2;
  }
  function Zu(e20, t2, n2) {
    for (var r2 = e20.slice(t2, n2), i2 = "", u2 = 0; u2 < r2.length; u2 += 2)
      i2 += String.fromCharCode(r2[u2] + 256 * r2[u2 + 1]);
    return i2;
  }
  function eo$2(e20, t2, n2) {
    if (e20 % 1 != 0 || e20 < 0)
      throw new RangeError("offset is not uint");
    if (e20 + t2 > n2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function to$2(e20, t2, n2, r2, i2, u2) {
    if (!ju$1(e20))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t2 > i2 || t2 < u2)
      throw new RangeError('"value" argument is out of bounds');
    if (n2 + r2 > e20.length)
      throw new RangeError("Index out of range");
  }
  function no$2(e20, t2, n2, r2) {
    t2 < 0 && (t2 = 65535 + t2 + 1);
    for (var i2 = 0, u2 = Math.min(e20.length - n2, 2); i2 < u2; ++i2)
      e20[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
  }
  function ro$2(e20, t2, n2, r2) {
    t2 < 0 && (t2 = 4294967295 + t2 + 1);
    for (var i2 = 0, u2 = Math.min(e20.length - n2, 4); i2 < u2; ++i2)
      e20[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
  }
  function io$2(e20, t2, n2, r2, i2, u2) {
    if (n2 + r2 > e20.length)
      throw new RangeError("Index out of range");
    if (n2 < 0)
      throw new RangeError("Index out of range");
  }
  function uo$2(e20, t2, n2, r2, i2) {
    return i2 || io$2(e20, 0, n2, 4), Su$1(e20, t2, n2, r2, 23, 4), n2 + 4;
  }
  function oo$2(e20, t2, n2, r2, i2) {
    return i2 || io$2(e20, 0, n2, 8), Su$1(e20, t2, n2, r2, 52, 8), n2 + 8;
  }
  Nu$1.prototype.slice = function(e20, t2) {
    var n2, r2 = this.length;
    if ((e20 = ~~e20) < 0 ? (e20 += r2) < 0 && (e20 = 0) : e20 > r2 && (e20 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e20 && (t2 = e20), Nu$1.TYPED_ARRAY_SUPPORT)
      (n2 = this.subarray(e20, t2)).__proto__ = Nu$1.prototype;
    else {
      var i2 = t2 - e20;
      n2 = new Nu$1(i2, void 0);
      for (var u2 = 0; u2 < i2; ++u2)
        n2[u2] = this[u2 + e20];
    }
    return n2;
  }, Nu$1.prototype.readUIntLE = function(e20, t2, n2) {
    e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
    for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
      r2 += this[e20 + u2] * i2;
    return r2;
  }, Nu$1.prototype.readUIntBE = function(e20, t2, n2) {
    e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
    for (var r2 = this[e20 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
      r2 += this[e20 + --t2] * i2;
    return r2;
  }, Nu$1.prototype.readUInt8 = function(e20, t2) {
    return t2 || eo$2(e20, 1, this.length), this[e20];
  }, Nu$1.prototype.readUInt16LE = function(e20, t2) {
    return t2 || eo$2(e20, 2, this.length), this[e20] | this[e20 + 1] << 8;
  }, Nu$1.prototype.readUInt16BE = function(e20, t2) {
    return t2 || eo$2(e20, 2, this.length), this[e20] << 8 | this[e20 + 1];
  }, Nu$1.prototype.readUInt32LE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), (this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16) + 16777216 * this[e20 + 3];
  }, Nu$1.prototype.readUInt32BE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), 16777216 * this[e20] + (this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3]);
  }, Nu$1.prototype.readIntLE = function(e20, t2, n2) {
    e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
    for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
      r2 += this[e20 + u2] * i2;
    return r2 >= (i2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
  }, Nu$1.prototype.readIntBE = function(e20, t2, n2) {
    e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
    for (var r2 = t2, i2 = 1, u2 = this[e20 + --r2]; r2 > 0 && (i2 *= 256); )
      u2 += this[e20 + --r2] * i2;
    return u2 >= (i2 *= 128) && (u2 -= Math.pow(2, 8 * t2)), u2;
  }, Nu$1.prototype.readInt8 = function(e20, t2) {
    return t2 || eo$2(e20, 1, this.length), 128 & this[e20] ? -1 * (255 - this[e20] + 1) : this[e20];
  }, Nu$1.prototype.readInt16LE = function(e20, t2) {
    t2 || eo$2(e20, 2, this.length);
    var n2 = this[e20] | this[e20 + 1] << 8;
    return 32768 & n2 ? 4294901760 | n2 : n2;
  }, Nu$1.prototype.readInt16BE = function(e20, t2) {
    t2 || eo$2(e20, 2, this.length);
    var n2 = this[e20 + 1] | this[e20] << 8;
    return 32768 & n2 ? 4294901760 | n2 : n2;
  }, Nu$1.prototype.readInt32LE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16 | this[e20 + 3] << 24;
  }, Nu$1.prototype.readInt32BE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), this[e20] << 24 | this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3];
  }, Nu$1.prototype.readFloatLE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, true, 23, 4);
  }, Nu$1.prototype.readFloatBE = function(e20, t2) {
    return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, false, 23, 4);
  }, Nu$1.prototype.readDoubleLE = function(e20, t2) {
    return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, true, 52, 8);
  }, Nu$1.prototype.readDoubleBE = function(e20, t2) {
    return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, false, 52, 8);
  }, Nu$1.prototype.writeUIntLE = function(e20, t2, n2, r2) {
    (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
    var i2 = 1, u2 = 0;
    for (this[t2] = 255 & e20; ++u2 < n2 && (i2 *= 256); )
      this[t2 + u2] = e20 / i2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeUIntBE = function(e20, t2, n2, r2) {
    (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
    var i2 = n2 - 1, u2 = 1;
    for (this[t2 + i2] = 255 & e20; --i2 >= 0 && (u2 *= 256); )
      this[t2 + i2] = e20 / u2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeUInt8 = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 255, 0), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), this[t2] = 255 & e20, t2 + 1;
  }, Nu$1.prototype.writeUInt16LE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
  }, Nu$1.prototype.writeUInt16BE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
  }, Nu$1.prototype.writeUInt32LE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e20 >>> 24, this[t2 + 2] = e20 >>> 16, this[t2 + 1] = e20 >>> 8, this[t2] = 255 & e20) : ro$2(this, e20, t2, true), t2 + 4;
  }, Nu$1.prototype.writeUInt32BE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
  }, Nu$1.prototype.writeIntLE = function(e20, t2, n2, r2) {
    if (e20 = +e20, t2 |= 0, !r2) {
      var i2 = Math.pow(2, 8 * n2 - 1);
      to$2(this, e20, t2, n2, i2 - 1, -i2);
    }
    var u2 = 0, o2 = 1, s2 = 0;
    for (this[t2] = 255 & e20; ++u2 < n2 && (o2 *= 256); )
      e20 < 0 && s2 === 0 && this[t2 + u2 - 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeIntBE = function(e20, t2, n2, r2) {
    if (e20 = +e20, t2 |= 0, !r2) {
      var i2 = Math.pow(2, 8 * n2 - 1);
      to$2(this, e20, t2, n2, i2 - 1, -i2);
    }
    var u2 = n2 - 1, o2 = 1, s2 = 0;
    for (this[t2 + u2] = 255 & e20; --u2 >= 0 && (o2 *= 256); )
      e20 < 0 && s2 === 0 && this[t2 + u2 + 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
    return t2 + n2;
  }, Nu$1.prototype.writeInt8 = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 127, -128), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), e20 < 0 && (e20 = 255 + e20 + 1), this[t2] = 255 & e20, t2 + 1;
  }, Nu$1.prototype.writeInt16LE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
  }, Nu$1.prototype.writeInt16BE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
  }, Nu$1.prototype.writeInt32LE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8, this[t2 + 2] = e20 >>> 16, this[t2 + 3] = e20 >>> 24) : ro$2(this, e20, t2, true), t2 + 4;
  }, Nu$1.prototype.writeInt32BE = function(e20, t2, n2) {
    return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), e20 < 0 && (e20 = 4294967295 + e20 + 1), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
  }, Nu$1.prototype.writeFloatLE = function(e20, t2, n2) {
    return uo$2(this, e20, t2, true, n2);
  }, Nu$1.prototype.writeFloatBE = function(e20, t2, n2) {
    return uo$2(this, e20, t2, false, n2);
  }, Nu$1.prototype.writeDoubleLE = function(e20, t2, n2) {
    return oo$2(this, e20, t2, true, n2);
  }, Nu$1.prototype.writeDoubleBE = function(e20, t2, n2) {
    return oo$2(this, e20, t2, false, n2);
  }, Nu$1.prototype.copy = function(e20, t2, n2, r2) {
    if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e20.length && (t2 = e20.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
      return 0;
    if (e20.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (r2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    r2 > this.length && (r2 = this.length), e20.length - t2 < r2 - n2 && (r2 = e20.length - t2 + n2);
    var i2, u2 = r2 - n2;
    if (this === e20 && n2 < t2 && t2 < r2)
      for (i2 = u2 - 1; i2 >= 0; --i2)
        e20[i2 + t2] = this[i2 + n2];
    else if (u2 < 1e3 || !Nu$1.TYPED_ARRAY_SUPPORT)
      for (i2 = 0; i2 < u2; ++i2)
        e20[i2 + t2] = this[i2 + n2];
    else
      Uint8Array.prototype.set.call(e20, this.subarray(n2, n2 + u2), t2);
    return u2;
  }, Nu$1.prototype.fill = function(e20, t2, n2, r2) {
    if (typeof e20 == "string") {
      if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e20.length === 1) {
        var i2 = e20.charCodeAt(0);
        i2 < 256 && (e20 = i2);
      }
      if (r2 !== void 0 && typeof r2 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof r2 == "string" && !Nu$1.isEncoding(r2))
        throw new TypeError("Unknown encoding: " + r2);
    } else
      typeof e20 == "number" && (e20 &= 255);
    if (t2 < 0 || this.length < t2 || this.length < n2)
      throw new RangeError("Out of range index");
    if (n2 <= t2)
      return this;
    var u2;
    if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e20 || (e20 = 0), typeof e20 == "number")
      for (u2 = t2; u2 < n2; ++u2)
        this[u2] = e20;
    else {
      var o2 = ju$1(e20) ? e20 : co$2(new Nu$1(e20, r2).toString()), s2 = o2.length;
      for (u2 = 0; u2 < n2 - t2; ++u2)
        this[u2 + t2] = o2[u2 % s2];
    }
    return this;
  };
  var so$2 = /[^+\/0-9A-Za-z-_]/g;
  function ao$2(e20) {
    return e20 < 16 ? "0" + e20.toString(16) : e20.toString(16);
  }
  function co$2(e20, t2) {
    var n2;
    t2 = t2 || 1 / 0;
    for (var r2 = e20.length, i2 = null, u2 = [], o2 = 0; o2 < r2; ++o2) {
      if ((n2 = e20.charCodeAt(o2)) > 55295 && n2 < 57344) {
        if (!i2) {
          if (n2 > 56319) {
            (t2 -= 3) > -1 && u2.push(239, 191, 189);
            continue;
          }
          if (o2 + 1 === r2) {
            (t2 -= 3) > -1 && u2.push(239, 191, 189);
            continue;
          }
          i2 = n2;
          continue;
        }
        if (n2 < 56320) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189), i2 = n2;
          continue;
        }
        n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
      } else
        i2 && (t2 -= 3) > -1 && u2.push(239, 191, 189);
      if (i2 = null, n2 < 128) {
        if ((t2 -= 1) < 0)
          break;
        u2.push(n2);
      } else if (n2 < 2048) {
        if ((t2 -= 2) < 0)
          break;
        u2.push(n2 >> 6 | 192, 63 & n2 | 128);
      } else if (n2 < 65536) {
        if ((t2 -= 3) < 0)
          break;
        u2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
      } else {
        if (!(n2 < 1114112))
          throw new Error("Invalid code point");
        if ((t2 -= 4) < 0)
          break;
        u2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
      }
    }
    return u2;
  }
  function lo$2(e20) {
    return function(e21) {
      var t2, n2, r2, i2, u2, o2;
      Cu$1 || bu$1();
      var s2 = e21.length;
      if (s2 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      u2 = e21[s2 - 2] === "=" ? 2 : e21[s2 - 1] === "=" ? 1 : 0, o2 = new Eu$1(3 * s2 / 4 - u2), r2 = u2 > 0 ? s2 - 4 : s2;
      var a2 = 0;
      for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
        i2 = Du$1[e21.charCodeAt(t2)] << 18 | Du$1[e21.charCodeAt(t2 + 1)] << 12 | Du$1[e21.charCodeAt(t2 + 2)] << 6 | Du$1[e21.charCodeAt(t2 + 3)], o2[a2++] = i2 >> 16 & 255, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2;
      return u2 === 2 ? (i2 = Du$1[e21.charCodeAt(t2)] << 2 | Du$1[e21.charCodeAt(t2 + 1)] >> 4, o2[a2++] = 255 & i2) : u2 === 1 && (i2 = Du$1[e21.charCodeAt(t2)] << 10 | Du$1[e21.charCodeAt(t2 + 1)] << 4 | Du$1[e21.charCodeAt(t2 + 2)] >> 2, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2), o2;
    }(function(e21) {
      if ((e21 = function(e22) {
        return e22.trim ? e22.trim() : e22.replace(/^\s+|\s+$/g, "");
      }(e21).replace(so$2, "")).length < 2)
        return "";
      for (; e21.length % 4 != 0; )
        e21 += "=";
      return e21;
    }(e20));
  }
  function po$2(e20, t2, n2, r2) {
    for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t2.length || i2 >= e20.length); ++i2)
      t2[i2 + n2] = e20[i2];
    return i2;
  }
  function fo$2(e20) {
    return e20 != null && (!!e20._isBuffer || ho$2(e20) || function(e21) {
      return typeof e21.readFloatLE == "function" && typeof e21.slice == "function" && ho$2(e21.slice(0, 0));
    }(e20));
  }
  function ho$2(e20) {
    return !!e20.constructor && typeof e20.constructor.isBuffer == "function" && e20.constructor.isBuffer(e20);
  }
  var go$2 = n$3(tu$1);
  var mo$2 = class {
    constructor(e20, t2) {
      (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e20 == "number" ? e20 : go$2.openSync(e20, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
    }
    _searchInBuffer(e20, t2) {
      let n2 = -1;
      for (let r2 = 0; r2 <= e20.length; r2++) {
        if (e20[r2] === t2) {
          n2 = r2;
          break;
        }
      }
      return n2;
    }
    reset() {
      this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
    }
    close() {
      go$2.closeSync(this.fd), this.fd = null;
    }
    _extractLines(e20) {
      let t2;
      const n2 = [];
      let r2 = 0, i2 = 0;
      for (; ; ) {
        let u3 = e20[r2++];
        if (u3 === this.newLineCharacter)
          t2 = e20.slice(i2, r2), n2.push(t2), i2 = r2;
        else if (u3 === void 0)
          break;
      }
      let u2 = e20.slice(i2, r2);
      return u2.length && n2.push(u2), n2;
    }
    _readChunk(e20) {
      let t2, n2 = 0;
      const r2 = [];
      do {
        const e21 = new Nu$1(this.options.readChunk);
        t2 = go$2.readSync(this.fd, e21, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e21);
      } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
      let i2 = Nu$1.concat(r2);
      return t2 < this.options.readChunk && (this.eofReached = true, i2 = i2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(i2), e20 && (this.linesCache[0] = Nu$1.concat([e20, this.linesCache[0]]))), n2;
    }
    next() {
      if (!this.fd)
        return false;
      let e20, t2 = false;
      if (this.eofReached && this.linesCache.length === 0)
        return t2;
      if (this.linesCache.length || (e20 = this._readChunk()), this.linesCache.length) {
        t2 = this.linesCache.shift();
        t2[t2.length - 1] !== this.newLineCharacter && (e20 = this._readChunk(t2), e20 && (t2 = this.linesCache.shift()));
      }
      return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
    }
  };
  class yo$2 extends Error {
  }
  class Do$2 extends Error {
  }
  class Eo$2 extends Error {
  }
  class Co$2 extends Error {
  }
  var bo$2 = {ConfigError: yo$2, DebugError: Do$2, UndefinedParserError: Eo$2, ArgExpansionBailout: Co$2}, Ao$2 = function(e20, t2) {
    return (Ao$2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e21, t3) {
      e21.__proto__ = t3;
    } || function(e21, t3) {
      for (var n2 in t3)
        t3.hasOwnProperty(n2) && (e21[n2] = t3[n2]);
    })(e20, t2);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var vo$2 = function() {
    return (vo$2 = Object.assign || function(e20) {
      for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in t2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e20[i2] = t2[i2]);
      return e20;
    }).apply(this, arguments);
  };
  function Fo$2(e20) {
    var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e20[t2], r2 = 0;
    if (n2)
      return n2.call(e20);
    if (e20 && typeof e20.length == "number")
      return {next: function() {
        return e20 && r2 >= e20.length && (e20 = void 0), {value: e20 && e20[r2++], done: !e20};
      }};
    throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function So$2(e20, t2) {
    var n2 = typeof Symbol == "function" && e20[Symbol.iterator];
    if (!n2)
      return e20;
    var r2, i2, u2 = n2.call(e20), o2 = [];
    try {
      for (; (t2 === void 0 || t2-- > 0) && !(r2 = u2.next()).done; )
        o2.push(r2.value);
    } catch (e21) {
      i2 = {error: e21};
    } finally {
      try {
        r2 && !r2.done && (n2 = u2.return) && n2.call(u2);
      } finally {
        if (i2)
          throw i2.error;
      }
    }
    return o2;
  }
  function xo$2(e20) {
    return this instanceof xo$2 ? (this.v = e20, this) : new xo$2(e20);
  }
  var wo$2 = Object.freeze({__proto__: null, __extends: function(e20, t2) {
    function n2() {
      this.constructor = e20;
    }
    Ao$2(e20, t2), e20.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
  }, get __assign() {
    return vo$2;
  }, __rest: function(e20, t2) {
    var n2 = {};
    for (var r2 in e20)
      Object.prototype.hasOwnProperty.call(e20, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e20[r2]);
    if (e20 != null && typeof Object.getOwnPropertySymbols == "function") {
      var i2 = 0;
      for (r2 = Object.getOwnPropertySymbols(e20); i2 < r2.length; i2++)
        t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e20, r2[i2]) && (n2[r2[i2]] = e20[r2[i2]]);
    }
    return n2;
  }, __decorate: function(e20, t2, n2, r2) {
    var i2, u2 = arguments.length, o2 = u2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e20, t2, n2, r2);
    else
      for (var s2 = e20.length - 1; s2 >= 0; s2--)
        (i2 = e20[s2]) && (o2 = (u2 < 3 ? i2(o2) : u2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return u2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }, __param: function(e20, t2) {
    return function(n2, r2) {
      t2(n2, r2, e20);
    };
  }, __metadata: function(e20, t2) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(e20, t2);
  }, __awaiter: function(e20, t2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, u2) {
      function o2(e21) {
        try {
          a2(r2.next(e21));
        } catch (e22) {
          u2(e22);
        }
      }
      function s2(e21) {
        try {
          a2(r2.throw(e21));
        } catch (e22) {
          u2(e22);
        }
      }
      function a2(e21) {
        var t3;
        e21.done ? i2(e21.value) : (t3 = e21.value, t3 instanceof n2 ? t3 : new n2(function(e22) {
          e22(t3);
        })).then(o2, s2);
      }
      a2((r2 = r2.apply(e20, t2 || [])).next());
    });
  }, __generator: function(e20, t2) {
    var n2, r2, i2, u2, o2 = {label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: []};
    return u2 = {next: s2(0), throw: s2(1), return: s2(2)}, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
      return this;
    }), u2;
    function s2(u3) {
      return function(s3) {
        return function(u4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; o2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & u4[0] ? r2.return : u4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, u4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (u4 = [2 & u4[0], i2.value]), u4[0]) {
                case 0:
                case 1:
                  i2 = u4;
                  break;
                case 4:
                  return o2.label++, {value: u4[1], done: false};
                case 5:
                  o2.label++, r2 = u4[1], u4 = [0];
                  continue;
                case 7:
                  u4 = o2.ops.pop(), o2.trys.pop();
                  continue;
                default:
                  if (!(i2 = o2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || u4[0] !== 6 && u4[0] !== 2)) {
                    o2 = 0;
                    continue;
                  }
                  if (u4[0] === 3 && (!i2 || u4[1] > i2[0] && u4[1] < i2[3])) {
                    o2.label = u4[1];
                    break;
                  }
                  if (u4[0] === 6 && o2.label < i2[1]) {
                    o2.label = i2[1], i2 = u4;
                    break;
                  }
                  if (i2 && o2.label < i2[2]) {
                    o2.label = i2[2], o2.ops.push(u4);
                    break;
                  }
                  i2[2] && o2.ops.pop(), o2.trys.pop();
                  continue;
              }
              u4 = t2.call(e20, o2);
            } catch (e21) {
              u4 = [6, e21], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & u4[0])
            throw u4[1];
          return {value: u4[0] ? u4[1] : void 0, done: true};
        }([u3, s3]);
      };
    }
  }, __createBinding: function(e20, t2, n2, r2) {
    r2 === void 0 && (r2 = n2), e20[r2] = t2[n2];
  }, __exportStar: function(e20, t2) {
    for (var n2 in e20)
      n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e20[n2]);
  }, __values: Fo$2, __read: So$2, __spread: function() {
    for (var e20 = [], t2 = 0; t2 < arguments.length; t2++)
      e20 = e20.concat(So$2(arguments[t2]));
    return e20;
  }, __spreadArrays: function() {
    for (var e20 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
      e20 += arguments[t2].length;
    var r2 = Array(e20), i2 = 0;
    for (t2 = 0; t2 < n2; t2++)
      for (var u2 = arguments[t2], o2 = 0, s2 = u2.length; o2 < s2; o2++, i2++)
        r2[i2] = u2[o2];
    return r2;
  }, __await: xo$2, __asyncGenerator: function(e20, t2, n2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var r2, i2 = n2.apply(e20, t2 || []), u2 = [];
    return r2 = {}, o2("next"), o2("throw"), o2("return"), r2[Symbol.asyncIterator] = function() {
      return this;
    }, r2;
    function o2(e21) {
      i2[e21] && (r2[e21] = function(t3) {
        return new Promise(function(n3, r3) {
          u2.push([e21, t3, n3, r3]) > 1 || s2(e21, t3);
        });
      });
    }
    function s2(e21, t3) {
      try {
        (n3 = i2[e21](t3)).value instanceof xo$2 ? Promise.resolve(n3.value.v).then(a2, c2) : l2(u2[0][2], n3);
      } catch (e22) {
        l2(u2[0][3], e22);
      }
      var n3;
    }
    function a2(e21) {
      s2("next", e21);
    }
    function c2(e21) {
      s2("throw", e21);
    }
    function l2(e21, t3) {
      e21(t3), u2.shift(), u2.length && s2(u2[0][0], u2[0][1]);
    }
  }, __asyncDelegator: function(e20) {
    var t2, n2;
    return t2 = {}, r2("next"), r2("throw", function(e21) {
      throw e21;
    }), r2("return"), t2[Symbol.iterator] = function() {
      return this;
    }, t2;
    function r2(r3, i2) {
      t2[r3] = e20[r3] ? function(t3) {
        return (n2 = !n2) ? {value: xo$2(e20[r3](t3)), done: r3 === "return"} : i2 ? i2(t3) : t3;
      } : i2;
    }
  }, __asyncValues: function(e20) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var t2, n2 = e20[Symbol.asyncIterator];
    return n2 ? n2.call(e20) : (e20 = Fo$2(e20), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
      return this;
    }, t2);
    function r2(n3) {
      t2[n3] = e20[n3] && function(t3) {
        return new Promise(function(r3, i2) {
          (function(e21, t4, n4, r4) {
            Promise.resolve(r4).then(function(t5) {
              e21({value: t5, done: n4});
            }, t4);
          })(r3, i2, (t3 = e20[n3](t3)).done, t3.value);
        });
      };
    }
  }, __makeTemplateObject: function(e20, t2) {
    return Object.defineProperty ? Object.defineProperty(e20, "raw", {value: t2}) : e20.raw = t2, e20;
  }, __importStar: function(e20) {
    if (e20 && e20.__esModule)
      return e20;
    var t2 = {};
    if (e20 != null)
      for (var n2 in e20)
        Object.hasOwnProperty.call(e20, n2) && (t2[n2] = e20[n2]);
    return t2.default = e20, t2;
  }, __importDefault: function(e20) {
    return e20 && e20.__esModule ? e20 : {default: e20};
  }, __classPrivateFieldGet: function(e20, t2) {
    if (!t2.has(e20))
      throw new TypeError("attempted to get private field on non-instance");
    return t2.get(e20);
  }, __classPrivateFieldSet: function(e20, t2, n2) {
    if (!t2.has(e20))
      throw new TypeError("attempted to set private field on non-instance");
    return t2.set(e20, n2), n2;
  }}), To$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), t2.apiDescriptor = {key: (e21) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e21) ? e21 : JSON.stringify(e21), value(e21) {
      if (e21 === null || typeof e21 != "object")
        return JSON.stringify(e21);
      if (Array.isArray(e21))
        return `[${e21.map((e22) => t2.apiDescriptor.value(e22)).join(", ")}]`;
      const n2 = Object.keys(e21);
      return n2.length === 0 ? "{}" : `{ ${n2.map((n3) => `${t2.apiDescriptor.key(n3)}: ${t2.apiDescriptor.value(e21[n3])}`).join(", ")} }`;
    }, pair: ({key: e21, value: n2}) => t2.apiDescriptor.value({[e21]: n2})};
  }), Bo$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(To$2, t2);
  }), No$2 = /[|\\{}()[\]^$+*?.]/g, ko$2 = function(e20) {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    return e20.replace(No$2, "\\$&");
  }, Po$2 = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]}, Oo$2 = r$3(function(e20) {
    var t2 = {};
    for (var n2 in Po$2)
      Po$2.hasOwnProperty(n2) && (t2[Po$2[n2]] = n2);
    var r2 = e20.exports = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
    for (var i2 in r2)
      if (r2.hasOwnProperty(i2)) {
        if (!("channels" in r2[i2]))
          throw new Error("missing channels property: " + i2);
        if (!("labels" in r2[i2]))
          throw new Error("missing channel labels property: " + i2);
        if (r2[i2].labels.length !== r2[i2].channels)
          throw new Error("channel and label counts mismatch: " + i2);
        var u2 = r2[i2].channels, o2 = r2[i2].labels;
        delete r2[i2].channels, delete r2[i2].labels, Object.defineProperty(r2[i2], "channels", {value: u2}), Object.defineProperty(r2[i2], "labels", {value: o2});
      }
    r2.rgb.hsl = function(e21) {
      var t3, n3, r3 = e21[0] / 255, i3 = e21[1] / 255, u3 = e21[2] / 255, o3 = Math.min(r3, i3, u3), s2 = Math.max(r3, i3, u3), a2 = s2 - o3;
      return s2 === o3 ? t3 = 0 : r3 === s2 ? t3 = (i3 - u3) / a2 : i3 === s2 ? t3 = 2 + (u3 - r3) / a2 : u3 === s2 && (t3 = 4 + (r3 - i3) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (o3 + s2) / 2, [t3, 100 * (s2 === o3 ? 0 : n3 <= 0.5 ? a2 / (s2 + o3) : a2 / (2 - s2 - o3)), 100 * n3];
    }, r2.rgb.hsv = function(e21) {
      var t3, n3, r3, i3, u3, o3 = e21[0] / 255, s2 = e21[1] / 255, a2 = e21[2] / 255, c2 = Math.max(o3, s2, a2), l2 = c2 - Math.min(o3, s2, a2), p2 = function(e22) {
        return (c2 - e22) / 6 / l2 + 0.5;
      };
      return l2 === 0 ? i3 = u3 = 0 : (u3 = l2 / c2, t3 = p2(o3), n3 = p2(s2), r3 = p2(a2), o3 === c2 ? i3 = r3 - n3 : s2 === c2 ? i3 = 1 / 3 + t3 - r3 : a2 === c2 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c2];
    }, r2.rgb.hwb = function(e21) {
      var t3 = e21[0], n3 = e21[1], i3 = e21[2];
      return [r2.rgb.hsl(e21)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, i3))), 100 * (i3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, i3)))];
    }, r2.rgb.cmyk = function(e21) {
      var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255;
      return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - i3 - t3) / (1 - t3) || 0), 100 * t3];
    }, r2.rgb.keyword = function(e21) {
      var n3 = t2[e21];
      if (n3)
        return n3;
      var r3, i3, u3, o3 = 1 / 0;
      for (var s2 in Po$2)
        if (Po$2.hasOwnProperty(s2)) {
          var a2 = Po$2[s2], c2 = (i3 = e21, u3 = a2, Math.pow(i3[0] - u3[0], 2) + Math.pow(i3[1] - u3[1], 2) + Math.pow(i3[2] - u3[2], 2));
          c2 < o3 && (o3 = c2, r3 = s2);
        }
      return r3;
    }, r2.keyword.rgb = function(e21) {
      return Po$2[e21];
    }, r2.rgb.xyz = function(e21) {
      var t3 = e21[0] / 255, n3 = e21[1] / 255, r3 = e21[2] / 255;
      return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
    }, r2.rgb.lab = function(e21) {
      var t3 = r2.rgb.xyz(e21), n3 = t3[0], i3 = t3[1], u3 = t3[2];
      return i3 /= 100, u3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16, 500 * (n3 - i3), 200 * (i3 - (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116))];
    }, r2.hsl.rgb = function(e21) {
      var t3, n3, r3, i3, u3, o3 = e21[0] / 360, s2 = e21[1] / 100, a2 = e21[2] / 100;
      if (s2 === 0)
        return [u3 = 255 * a2, u3, u3];
      t3 = 2 * a2 - (n3 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), i3 = [0, 0, 0];
      for (var c2 = 0; c2 < 3; c2++)
        (r3 = o3 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, u3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i3[c2] = 255 * u3;
      return i3;
    }, r2.hsl.hsv = function(e21) {
      var t3 = e21[0], n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = n3, u3 = Math.max(r3, 0.01);
      return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3, [t3, 100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
    }, r2.hsv.rgb = function(e21) {
      var t3 = e21[0] / 60, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s2 = 255 * r3 * (1 - n3 * u3), a2 = 255 * r3 * (1 - n3 * (1 - u3));
      switch (r3 *= 255, i3) {
        case 0:
          return [r3, a2, o3];
        case 1:
          return [s2, r3, o3];
        case 2:
          return [o3, r3, a2];
        case 3:
          return [o3, s2, r3];
        case 4:
          return [a2, o3, r3];
        case 5:
          return [r3, o3, s2];
      }
    }, r2.hsv.hsl = function(e21) {
      var t3, n3, r3, i3 = e21[0], u3 = e21[1] / 100, o3 = e21[2] / 100, s2 = Math.max(o3, 0.01);
      return r3 = (2 - u3) * o3, n3 = u3 * s2, [i3, 100 * (n3 = (n3 /= (t3 = (2 - u3) * s2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
    }, r2.hwb.rgb = function(e21) {
      var t3, n3, r3, i3, u3, o3, s2, a2 = e21[0] / 360, c2 = e21[1] / 100, l2 = e21[2] / 100, p2 = c2 + l2;
      switch (p2 > 1 && (c2 /= p2, l2 /= p2), r3 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r3 = 1 - r3), i3 = c2 + r3 * ((n3 = 1 - l2) - c2), t3) {
        default:
        case 6:
        case 0:
          u3 = n3, o3 = i3, s2 = c2;
          break;
        case 1:
          u3 = i3, o3 = n3, s2 = c2;
          break;
        case 2:
          u3 = c2, o3 = n3, s2 = i3;
          break;
        case 3:
          u3 = c2, o3 = i3, s2 = n3;
          break;
        case 4:
          u3 = i3, o3 = c2, s2 = n3;
          break;
        case 5:
          u3 = n3, o3 = c2, s2 = i3;
      }
      return [255 * u3, 255 * o3, 255 * s2];
    }, r2.cmyk.rgb = function(e21) {
      var t3 = e21[0] / 100, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = e21[3] / 100;
      return [255 * (1 - Math.min(1, t3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, r3 * (1 - i3) + i3))];
    }, r2.xyz.rgb = function(e21) {
      var t3, n3, r3, i3 = e21[0] / 100, u3 = e21[1] / 100, o3 = e21[2] / 100;
      return n3 = -0.9689 * i3 + 1.8758 * u3 + 0.0415 * o3, r3 = 0.0557 * i3 + -0.204 * u3 + 1.057 * o3, t3 = (t3 = 3.2406 * i3 + -1.5372 * u3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
    }, r2.xyz.lab = function(e21) {
      var t3 = e21[0], n3 = e21[1], r3 = e21[2];
      return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
    }, r2.lab.xyz = function(e21) {
      var t3, n3, r3, i3 = e21[0];
      t3 = e21[1] / 500 + (n3 = (i3 + 16) / 116), r3 = n3 - e21[2] / 200;
      var u3 = Math.pow(n3, 3), o3 = Math.pow(t3, 3), s2 = Math.pow(r3, 3);
      return n3 = u3 > 8856e-6 ? u3 : (n3 - 16 / 116) / 7.787, t3 = o3 > 8856e-6 ? o3 : (t3 - 16 / 116) / 7.787, r3 = s2 > 8856e-6 ? s2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
    }, r2.lab.lch = function(e21) {
      var t3, n3 = e21[0], r3 = e21[1], i3 = e21[2];
      return (t3 = 360 * Math.atan2(i3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i3 * i3), t3];
    }, r2.lch.lab = function(e21) {
      var t3, n3 = e21[0], r3 = e21[1];
      return t3 = e21[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
    }, r2.rgb.ansi16 = function(e21) {
      var t3 = e21[0], n3 = e21[1], i3 = e21[2], u3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e21)[2];
      if ((u3 = Math.round(u3 / 50)) === 0)
        return 30;
      var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
      return u3 === 2 && (o3 += 60), o3;
    }, r2.hsv.ansi16 = function(e21) {
      return r2.rgb.ansi16(r2.hsv.rgb(e21), e21[2]);
    }, r2.rgb.ansi256 = function(e21) {
      var t3 = e21[0], n3 = e21[1], r3 = e21[2];
      return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e21) {
      var t3 = e21 % 10;
      if (t3 === 0 || t3 === 7)
        return e21 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
      var n3 = 0.5 * (1 + ~~(e21 > 50));
      return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
    }, r2.ansi256.rgb = function(e21) {
      if (e21 >= 232) {
        var t3 = 10 * (e21 - 232) + 8;
        return [t3, t3, t3];
      }
      var n3;
      return e21 -= 16, [Math.floor(e21 / 36) / 5 * 255, Math.floor((n3 = e21 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
    }, r2.rgb.hex = function(e21) {
      var t3 = (((255 & Math.round(e21[0])) << 16) + ((255 & Math.round(e21[1])) << 8) + (255 & Math.round(e21[2]))).toString(16).toUpperCase();
      return "000000".substring(t3.length) + t3;
    }, r2.hex.rgb = function(e21) {
      var t3 = e21.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!t3)
        return [0, 0, 0];
      var n3 = t3[0];
      t3[0].length === 3 && (n3 = n3.split("").map(function(e22) {
        return e22 + e22;
      }).join(""));
      var r3 = parseInt(n3, 16);
      return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
    }, r2.rgb.hcg = function(e21) {
      var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255, u3 = Math.max(Math.max(n3, r3), i3), o3 = Math.min(Math.min(n3, r3), i3), s2 = u3 - o3;
      return t3 = s2 <= 0 ? 0 : u3 === n3 ? (r3 - i3) / s2 % 6 : u3 === r3 ? 2 + (i3 - n3) / s2 : 4 + (n3 - r3) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? o3 / (1 - s2) : 0)];
    }, r2.hsl.hcg = function(e21) {
      var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = 1, i3 = 0;
      return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
    }, r2.hsv.hcg = function(e21) {
      var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = t3 * n3, i3 = 0;
      return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
    }, r2.hcg.rgb = function(e21) {
      var t3 = e21[0] / 360, n3 = e21[1] / 100, r3 = e21[2] / 100;
      if (n3 === 0)
        return [255 * r3, 255 * r3, 255 * r3];
      var i3, u3 = [0, 0, 0], o3 = t3 % 1 * 6, s2 = o3 % 1, a2 = 1 - s2;
      switch (Math.floor(o3)) {
        case 0:
          u3[0] = 1, u3[1] = s2, u3[2] = 0;
          break;
        case 1:
          u3[0] = a2, u3[1] = 1, u3[2] = 0;
          break;
        case 2:
          u3[0] = 0, u3[1] = 1, u3[2] = s2;
          break;
        case 3:
          u3[0] = 0, u3[1] = a2, u3[2] = 1;
          break;
        case 4:
          u3[0] = s2, u3[1] = 0, u3[2] = 1;
          break;
        default:
          u3[0] = 1, u3[1] = 0, u3[2] = a2;
      }
      return i3 = (1 - n3) * r3, [255 * (n3 * u3[0] + i3), 255 * (n3 * u3[1] + i3), 255 * (n3 * u3[2] + i3)];
    }, r2.hcg.hsv = function(e21) {
      var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3), r3 = 0;
      return n3 > 0 && (r3 = t3 / n3), [e21[0], 100 * r3, 100 * n3];
    }, r2.hcg.hsl = function(e21) {
      var t3 = e21[1] / 100, n3 = e21[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
      return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e21[0], 100 * r3, 100 * n3];
    }, r2.hcg.hwb = function(e21) {
      var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3);
      return [e21[0], 100 * (n3 - t3), 100 * (1 - n3)];
    }, r2.hwb.hcg = function(e21) {
      var t3 = e21[1] / 100, n3 = 1 - e21[2] / 100, r3 = n3 - t3, i3 = 0;
      return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
    }, r2.apple.rgb = function(e21) {
      return [e21[0] / 65535 * 255, e21[1] / 65535 * 255, e21[2] / 65535 * 255];
    }, r2.rgb.apple = function(e21) {
      return [e21[0] / 255 * 65535, e21[1] / 255 * 65535, e21[2] / 255 * 65535];
    }, r2.gray.rgb = function(e21) {
      return [e21[0] / 100 * 255, e21[0] / 100 * 255, e21[0] / 100 * 255];
    }, r2.gray.hsl = r2.gray.hsv = function(e21) {
      return [0, 0, e21[0]];
    }, r2.gray.hwb = function(e21) {
      return [0, 100, e21[0]];
    }, r2.gray.cmyk = function(e21) {
      return [0, 0, 0, e21[0]];
    }, r2.gray.lab = function(e21) {
      return [e21[0], 0, 0];
    }, r2.gray.hex = function(e21) {
      var t3 = 255 & Math.round(e21[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
      return "000000".substring(n3.length) + n3;
    }, r2.rgb.gray = function(e21) {
      return [(e21[0] + e21[1] + e21[2]) / 3 / 255 * 100];
    };
  });
  function Io$2(e20) {
    var t2 = function() {
      for (var e21 = {}, t3 = Object.keys(Oo$2), n3 = t3.length, r3 = 0; r3 < n3; r3++)
        e21[t3[r3]] = {distance: -1, parent: null};
      return e21;
    }(), n2 = [e20];
    for (t2[e20].distance = 0; n2.length; )
      for (var r2 = n2.pop(), i2 = Object.keys(Oo$2[r2]), u2 = i2.length, o2 = 0; o2 < u2; o2++) {
        var s2 = i2[o2], a2 = t2[s2];
        a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
      }
    return t2;
  }
  function Lo$2(e20, t2) {
    return function(n2) {
      return t2(e20(n2));
    };
  }
  function jo$1(e20, t2) {
    for (var n2 = [t2[e20].parent, e20], r2 = Oo$2[t2[e20].parent][e20], i2 = t2[e20].parent; t2[i2].parent; )
      n2.unshift(t2[i2].parent), r2 = Lo$2(Oo$2[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
    return r2.conversion = n2, r2;
  }
  var _o$2 = {};
  Object.keys(Oo$2).forEach(function(e20) {
    _o$2[e20] = {}, Object.defineProperty(_o$2[e20], "channels", {value: Oo$2[e20].channels}), Object.defineProperty(_o$2[e20], "labels", {value: Oo$2[e20].labels});
    var t2 = function(e21) {
      for (var t3 = Io$2(e21), n2 = {}, r2 = Object.keys(t3), i2 = r2.length, u2 = 0; u2 < i2; u2++) {
        var o2 = r2[u2];
        t3[o2].parent !== null && (n2[o2] = jo$1(o2, t3));
      }
      return n2;
    }(e20);
    Object.keys(t2).forEach(function(n2) {
      var r2 = t2[n2];
      _o$2[e20][n2] = function(e21) {
        var t3 = function(t4) {
          if (t4 == null)
            return t4;
          arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
          var n3 = e21(t4);
          if (typeof n3 == "object")
            for (var r3 = n3.length, i2 = 0; i2 < r3; i2++)
              n3[i2] = Math.round(n3[i2]);
          return n3;
        };
        return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
      }(r2), _o$2[e20][n2].raw = function(e21) {
        var t3 = function(t4) {
          return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e21(t4));
        };
        return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
      }(r2);
    });
  });
  var Mo$1, Ro$2 = _o$2, $o$1 = r$3(function(e20) {
    const t2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${n3 + t3}m`;
    }, n2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${38 + t3};5;${n3}m`;
    }, r2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
    };
    Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
      const e21 = new Map(), i2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, {value: n3, enumerable: false}), Object.defineProperty(i2, "codes", {value: e21, enumerable: false});
      }
      const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = {ansi: t2(u2, 0)}, i2.color.ansi256 = {ansi256: n2(u2, 0)}, i2.color.ansi16m = {rgb: r2(o2, 0)}, i2.bgColor.ansi = {ansi: t2(u2, 10)}, i2.bgColor.ansi256 = {ansi256: n2(u2, 10)}, i2.bgColor.ansi16m = {rgb: r2(o2, 10)};
      for (let e22 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e22] != "object")
          continue;
        const u3 = Ro$2[e22];
        e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
      }
      return i2;
    }});
  });
  function Vo$1() {
    if (Mo$1 === void 0) {
      var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), n2 = new Uint16Array(e20);
      if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
        Mo$1 = "BE";
      else {
        if (n2[0] !== 513)
          throw new Error("unable to figure out endianess");
        Mo$1 = "LE";
      }
    }
    return Mo$1;
  }
  function Wo$1() {
    return nr$2.location !== void 0 ? nr$2.location.hostname : "";
  }
  function qo$1() {
    return [];
  }
  function Uo$1() {
    return 0;
  }
  function zo$1() {
    return Number.MAX_VALUE;
  }
  function Go$1() {
    return Number.MAX_VALUE;
  }
  function Ho$1() {
    return [];
  }
  function Jo$1() {
    return "Browser";
  }
  function Xo$1() {
    return nr$2.navigator !== void 0 ? nr$2.navigator.appVersion : "";
  }
  function Yo$1() {
  }
  function Ko$1() {
  }
  function Qo$1() {
    return "javascript";
  }
  function Zo$1() {
    return "browser";
  }
  function es$2() {
    return "/tmp";
  }
  var ts$2 = es$2, ns$2 = {EOL: "\n", arch: Qo$1, platform: Zo$1, tmpdir: ts$2, tmpDir: es$2, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, release: Xo$1, type: Jo$1, cpus: Ho$1, totalmem: Go$1, freemem: zo$1, uptime: Uo$1, loadavg: qo$1, hostname: Wo$1, endianness: Vo$1}, rs$2 = (e20, t2) => {
    t2 = t2 || xr$2.argv;
    const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  }, is$2 = n$3(Object.freeze({__proto__: null, endianness: Vo$1, hostname: Wo$1, loadavg: qo$1, uptime: Uo$1, freemem: zo$1, totalmem: Go$1, cpus: Ho$1, type: Jo$1, release: Xo$1, networkInterfaces: Yo$1, getNetworkInterfaces: Ko$1, arch: Qo$1, platform: Zo$1, tmpDir: es$2, tmpdir: ts$2, EOL: "\n", default: ns$2}));
  const us$2 = xr$2.env;
  let os$2;
  function ss$2(e20) {
    return function(e21) {
      return e21 !== 0 && {level: e21, hasBasic: true, has256: e21 >= 2, has16m: e21 >= 3};
    }(function(e21) {
      if (os$2 === false)
        return 0;
      if (rs$2("color=16m") || rs$2("color=full") || rs$2("color=truecolor"))
        return 3;
      if (rs$2("color=256"))
        return 2;
      if (e21 && !e21.isTTY && os$2 !== true)
        return 0;
      const t2 = os$2 ? 1 : 0;
      if (xr$2.platform === "win32") {
        const e22 = is$2.release().split(".");
        return Number(xr$2.versions.node.split(".")[0]) >= 8 && Number(e22[0]) >= 10 && Number(e22[2]) >= 10586 ? Number(e22[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in us$2)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in us$2) || us$2.CI_NAME === "codeship" ? 1 : t2;
      if ("TEAMCITY_VERSION" in us$2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(us$2.TEAMCITY_VERSION) ? 1 : 0;
      if (us$2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in us$2) {
        const e22 = parseInt((us$2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (us$2.TERM_PROGRAM) {
          case "iTerm.app":
            return e22 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(us$2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(us$2.TERM) || "COLORTERM" in us$2 ? 1 : (us$2.TERM, t2);
    }(e20));
  }
  rs$2("no-color") || rs$2("no-colors") || rs$2("color=false") ? os$2 = false : (rs$2("color") || rs$2("colors") || rs$2("color=true") || rs$2("color=always")) && (os$2 = true), "FORCE_COLOR" in us$2 && (os$2 = us$2.FORCE_COLOR.length === 0 || parseInt(us$2.FORCE_COLOR, 10) !== 0);
  var as$2 = {supportsColor: ss$2, stdout: ss$2(xr$2.stdout), stderr: ss$2(xr$2.stderr)};
  const cs$2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, ls$2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, ps$2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, fs$2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ds$2 = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function hs$2(e20) {
    return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : ds$2.get(e20) || e20;
  }
  function gs$2(e20, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2)
      if (isNaN(t3)) {
        if (!(i2 = t3.match(ps$2)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
        n2.push(i2[2].replace(fs$2, (e21, t4, n3) => t4 ? hs$2(t4) : n3));
      } else
        n2.push(Number(t3));
    return n2;
  }
  function ms$2(e20) {
    ls$2.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = ls$2.exec(e20)) !== null; ) {
      const e21 = n2[1];
      if (n2[2]) {
        const r2 = gs$2(e21, n2[2]);
        t2.push([e21].concat(r2));
      } else
        t2.push([e21]);
    }
    return t2;
  }
  function ys$2(e20, t2) {
    const n2 = {};
    for (const e21 of t2)
      for (const t3 of e21.styles)
        n2[t3[0]] = e21.inverse ? null : t3.slice(1);
    let r2 = e20;
    for (const e21 of Object.keys(n2))
      if (Array.isArray(n2[e21])) {
        if (!(e21 in r2))
          throw new Error(`Unknown Chalk style: ${e21}`);
        r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
      }
    return r2;
  }
  var Ds$2 = (e20, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(cs$2, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(hs$2(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : ys$2(e20, n2)(t4)), n2.push({inverse: o2, styles: ms$2(s2)});
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(ys$2(e20, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e21);
    }
    return r2.join("");
  }, Es$2 = r$3(function(e20) {
    const t2 = as$2.stdout, n2 = xr$2.platform === "win32" && !(xr$2.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
    function o2(e21, n3) {
      n3 = n3 || {};
      const r3 = t2 ? t2.level : 0;
      e21.level = n3.level === void 0 ? r3 : n3.level, e21.enabled = "enabled" in n3 ? n3.enabled : e21.level > 0;
    }
    function s2(e21) {
      if (!this || !(this instanceof s2) || this.template) {
        const t3 = {};
        return o2(t3, e21), t3.template = function() {
          const e22 = [].slice.call(arguments);
          return p2.apply(null, [t3.template].concat(e22));
        }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
      }
      o2(this, e21);
    }
    n2 && ($o$1.blue.open = "[94m");
    for (const e21 of Object.keys($o$1))
      $o$1[e21].closeRe = new RegExp(ko$2($o$1[e21].close), "g"), u2[e21] = {get() {
        const t3 = $o$1[e21];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
      }};
    u2.visible = {get() {
      return c2.call(this, this._styles || [], true, "visible");
    }}, $o$1.color.closeRe = new RegExp(ko$2($o$1.color.close), "g");
    for (const e21 of Object.keys($o$1.color.ansi))
      i2.has(e21) || (u2[e21] = {get() {
        const t3 = this.level;
        return function() {
          const n3 = $o$1.color[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: $o$1.color.close, closeRe: $o$1.color.closeRe};
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }});
    $o$1.bgColor.closeRe = new RegExp(ko$2($o$1.bgColor.close), "g");
    for (const e21 of Object.keys($o$1.bgColor.ansi)) {
      if (i2.has(e21))
        continue;
      u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {get() {
        const t3 = this.level;
        return function() {
          const n3 = $o$1.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: $o$1.bgColor.close, closeRe: $o$1.bgColor.closeRe};
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }};
    }
    const a2 = Object.defineProperties(() => {
    }, u2);
    function c2(e21, t3, n3) {
      const r3 = function() {
        return l2.apply(r3, arguments);
      };
      r3._styles = e21, r3._empty = t3;
      const i3 = this;
      return Object.defineProperty(r3, "level", {enumerable: true, get: () => i3.level, set(e22) {
        i3.level = e22;
      }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => i3.enabled, set(e22) {
        i3.enabled = e22;
      }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
    }
    function l2() {
      const e21 = arguments, t3 = e21.length;
      let r3 = String(arguments[0]);
      if (t3 === 0)
        return "";
      if (t3 > 1)
        for (let n3 = 1; n3 < t3; n3++)
          r3 += " " + e21[n3];
      if (!this.enabled || this.level <= 0 || !r3)
        return this._empty ? "" : r3;
      const i3 = $o$1.dim.open;
      n2 && this.hasGrey && ($o$1.dim.open = "");
      for (const e22 of this._styles.slice().reverse())
        r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
      return $o$1.dim.open = i3, r3;
    }
    function p2(e21, t3) {
      if (!Array.isArray(t3))
        return [].slice.call(arguments, 1).join(" ");
      const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
      for (let e22 = 1; e22 < t3.length; e22++)
        r3.push(String(n3[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
      return Ds$2(e21, r3.join(""));
    }
    Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
  }), Cs$2 = Object.defineProperty({commonDeprecatedHandler: (e20, t2, {descriptor: n2}) => {
    const r2 = [`${Es$2.default.yellow(typeof e20 == "string" ? n2.key(e20) : n2.pair(e20))} is deprecated`];
    return t2 && r2.push(`we now treat it as ${Es$2.default.blue(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))}`), r2.join("; ") + ".";
  }}, "__esModule", {value: true}), bs$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Cs$2, t2);
  }), As$2 = Object.defineProperty({commonInvalidHandler: (e20, t2, n2) => [`Invalid ${Es$2.default.red(n2.descriptor.key(e20))} value.`, `Expected ${Es$2.default.blue(n2.schemas[e20].expected(n2))},`, `but received ${Es$2.default.red(n2.descriptor.value(t2))}.`].join(" ")}, "__esModule", {value: true}), vs$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(As$2, t2);
  }), Fs$2 = [], Ss$2 = [], xs$2 = Object.defineProperty({levenUnknownHandler: (e20, t2, {descriptor: n2, logger: r2, schemas: i2}) => {
    const u2 = [`Ignored unknown option ${Es$2.default.yellow(n2.pair({key: e20, value: t2}))}.`], o2 = Object.keys(i2).sort().find((t3) => function(e21, t4) {
      if (e21 === t4)
        return 0;
      var n3 = e21;
      e21.length > t4.length && (e21 = t4, t4 = n3);
      var r3 = e21.length, i3 = t4.length;
      if (r3 === 0)
        return i3;
      if (i3 === 0)
        return r3;
      for (; r3 > 0 && e21.charCodeAt(~-r3) === t4.charCodeAt(~-i3); )
        r3--, i3--;
      if (r3 === 0)
        return i3;
      for (var u3, o3, s2, a2, c2 = 0; c2 < r3 && e21.charCodeAt(c2) === t4.charCodeAt(c2); )
        c2++;
      if (i3 -= c2, (r3 -= c2) == 0)
        return i3;
      for (var l2 = 0, p2 = 0; l2 < r3; )
        Ss$2[c2 + l2] = e21.charCodeAt(c2 + l2), Fs$2[l2] = ++l2;
      for (; p2 < i3; )
        for (u3 = t4.charCodeAt(c2 + p2), s2 = p2++, o3 = p2, l2 = 0; l2 < r3; l2++)
          a2 = u3 === Ss$2[c2 + l2] ? s2 : s2 + 1, s2 = Fs$2[l2], o3 = Fs$2[l2] = s2 > o3 ? a2 > o3 ? o3 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
      return o3;
    }(e20, t3) < 3);
    o2 && u2.push(`Did you mean ${Es$2.default.blue(n2.key(o2))}?`), r2.warn(u2.join(" "));
  }}, "__esModule", {value: true}), ws$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(xs$2, t2);
  }), Ts$2 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(bs$2, t2), wo$2.__exportStar(vs$2, t2), wo$2.__exportStar(ws$2, t2);
  });
  const Bs$2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  function Ns$2(e20, t2) {
    const n2 = new e20(t2), r2 = Object.create(n2);
    for (const e21 of Bs$2)
      e21 in t2 && (r2[e21] = Is$2(t2[e21], n2, Ps$2.prototype[e21].length));
    return r2;
  }
  var ks$2 = Ns$2;
  class Ps$2 {
    constructor(e20) {
      this.name = e20.name;
    }
    static create(e20) {
      return Ns$2(this, e20);
    }
    default(e20) {
    }
    expected(e20) {
      return "nothing";
    }
    validate(e20, t2) {
      return false;
    }
    deprecated(e20, t2) {
      return false;
    }
    forward(e20, t2) {
    }
    redirect(e20, t2) {
    }
    overlap(e20, t2, n2) {
      return e20;
    }
    preprocess(e20, t2) {
      return e20;
    }
    postprocess(e20, t2) {
      return e20;
    }
  }
  var Os$2 = Ps$2;
  function Is$2(e20, t2, n2) {
    return typeof e20 == "function" ? (...r2) => e20(...r2.slice(0, n2 - 1), t2, ...r2.slice(n2 - 1)) : () => e20;
  }
  var Ls$2 = Object.defineProperty({createSchema: ks$2, Schema: Os$2}, "__esModule", {value: true});
  class js$2 extends Ls$2.Schema {
    constructor(e20) {
      super(e20), this._sourceName = e20.sourceName;
    }
    expected(e20) {
      return e20.schemas[this._sourceName].expected(e20);
    }
    validate(e20, t2) {
      return t2.schemas[this._sourceName].validate(e20, t2);
    }
    redirect(e20, t2) {
      return this._sourceName;
    }
  }
  var _s$2 = js$2, Ms$2 = Object.defineProperty({AliasSchema: _s$2}, "__esModule", {value: true});
  class Rs$2 extends Ls$2.Schema {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  }
  var $s$2 = Rs$2, Vs$2 = Object.defineProperty({AnySchema: $s$2}, "__esModule", {value: true});
  class Ws$2 extends Ls$2.Schema {
    constructor(e20) {
      var {valueSchema: t2, name: n2 = t2.name} = e20, r2 = wo$2.__rest(e20, ["valueSchema", "name"]);
      super(Object.assign({}, r2, {name: n2})), this._valueSchema = t2;
    }
    expected(e20) {
      return `an array of ${this._valueSchema.expected(e20)}`;
    }
    validate(e20, t2) {
      if (!Array.isArray(e20))
        return false;
      const n2 = [];
      for (const r2 of e20) {
        const e21 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
        e21 !== true && n2.push(e21.value);
      }
      return n2.length === 0 || {value: n2};
    }
    deprecated(e20, t2) {
      const n2 = [];
      for (const r2 of e20) {
        const e21 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
        e21 !== false && n2.push(...e21.map(({value: e22}) => ({value: [e22]})));
      }
      return n2;
    }
    forward(e20, t2) {
      const n2 = [];
      for (const r2 of e20) {
        const e21 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
        n2.push(...e21.map(Us$2));
      }
      return n2;
    }
    redirect(e20, t2) {
      const n2 = [], r2 = [];
      for (const i2 of e20) {
        const e21 = t2.normalizeRedirectResult(this._valueSchema.redirect(i2, t2), i2);
        "remain" in e21 && n2.push(e21.remain), r2.push(...e21.redirect.map(Us$2));
      }
      return n2.length === 0 ? {redirect: r2} : {redirect: r2, remain: n2};
    }
    overlap(e20, t2) {
      return e20.concat(t2);
    }
  }
  var qs$2 = Ws$2;
  function Us$2({from: e20, to: t2}) {
    return {from: [e20], to: t2};
  }
  var zs$2 = Object.defineProperty({ArraySchema: qs$2}, "__esModule", {value: true});
  class Gs$2 extends Ls$2.Schema {
    expected() {
      return "true or false";
    }
    validate(e20) {
      return typeof e20 == "boolean";
    }
  }
  var Hs$2 = Gs$2, Js$2 = Object.defineProperty({BooleanSchema: Hs$2}, "__esModule", {value: true});
  var Xs$2 = function(e20, t2) {
    const n2 = Object.create(null);
    for (const r2 of e20) {
      const e21 = r2[t2];
      if (n2[e21])
        throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
      n2[e21] = r2;
    }
    return n2;
  };
  var Ys$2 = function(e20, t2) {
    const n2 = new Map();
    for (const r2 of e20) {
      const e21 = r2[t2];
      if (n2.has(e21))
        throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
      n2.set(e21, r2);
    }
    return n2;
  };
  var Ks$2 = function() {
    const e20 = Object.create(null);
    return (t2) => {
      const n2 = JSON.stringify(t2);
      return !!e20[n2] || (e20[n2] = true, false);
    };
  };
  var Qs$2 = function(e20, t2) {
    const n2 = [], r2 = [];
    for (const i2 of e20)
      t2(i2) ? n2.push(i2) : r2.push(i2);
    return [n2, r2];
  };
  var Zs$2 = function(e20) {
    return e20 === Math.floor(e20);
  };
  var ea$1 = function(e20, t2) {
    if (e20 === t2)
      return 0;
    const n2 = typeof e20, r2 = typeof t2, i2 = ["undefined", "object", "boolean", "number", "string"];
    return n2 !== r2 ? i2.indexOf(n2) - i2.indexOf(r2) : n2 !== "string" ? Number(e20) - Number(t2) : e20.localeCompare(t2);
  };
  var ta$1 = function(e20) {
    return e20 === void 0 ? {} : e20;
  };
  var na$1 = function(e20, t2) {
    return e20 === true || (e20 === false ? {value: t2} : e20);
  };
  var ra$1 = function(e20, t2, n2 = false) {
    return e20 !== false && (e20 === true ? !!n2 || [{value: t2}] : "value" in e20 ? [e20] : e20.length !== 0 && e20);
  };
  function ia$1(e20, t2) {
    return typeof e20 == "string" || "key" in e20 ? {from: t2, to: e20} : "from" in e20 ? {from: e20.from, to: e20.to} : {from: t2, to: e20.to};
  }
  var ua$1 = ia$1;
  function oa$1(e20, t2) {
    return e20 === void 0 ? [] : Array.isArray(e20) ? e20.map((e21) => ia$1(e21, t2)) : [ia$1(e20, t2)];
  }
  var sa$1 = oa$1;
  var aa$1 = function(e20, t2) {
    const n2 = oa$1(typeof e20 == "object" && "redirect" in e20 ? e20.redirect : e20, t2);
    return n2.length === 0 ? {remain: t2, redirect: n2} : typeof e20 == "object" && "remain" in e20 ? {remain: e20.remain, redirect: n2} : {redirect: n2};
  }, ca$1 = Object.defineProperty({recordFromArray: Xs$2, mapFromArray: Ys$2, createAutoChecklist: Ks$2, partition: Qs$2, isInt: Zs$2, comparePrimitive: ea$1, normalizeDefaultResult: ta$1, normalizeValidateResult: na$1, normalizeDeprecatedResult: ra$1, normalizeTransferResult: ua$1, normalizeForwardResult: sa$1, normalizeRedirectResult: aa$1}, "__esModule", {value: true});
  class la$1 extends Ls$2.Schema {
    constructor(e20) {
      super(e20), this._choices = ca$1.mapFromArray(e20.choices.map((e21) => e21 && typeof e21 == "object" ? e21 : {value: e21}), "value");
    }
    expected({descriptor: e20}) {
      const t2 = Array.from(this._choices.keys()).map((e21) => this._choices.get(e21)).filter((e21) => !e21.deprecated).map((e21) => e21.value).sort(ca$1.comparePrimitive).map(e20.value), n2 = t2.slice(0, -2), r2 = t2.slice(-2);
      return n2.concat(r2.join(" or ")).join(", ");
    }
    validate(e20) {
      return this._choices.has(e20);
    }
    deprecated(e20) {
      const t2 = this._choices.get(e20);
      return !(!t2 || !t2.deprecated) && {value: e20};
    }
    forward(e20) {
      const t2 = this._choices.get(e20);
      return t2 ? t2.forward : void 0;
    }
    redirect(e20) {
      const t2 = this._choices.get(e20);
      return t2 ? t2.redirect : void 0;
    }
  }
  var pa$1 = la$1, fa$1 = Object.defineProperty({ChoiceSchema: pa$1}, "__esModule", {value: true});
  class da$1 extends Ls$2.Schema {
    expected() {
      return "a number";
    }
    validate(e20, t2) {
      return typeof e20 == "number";
    }
  }
  var ha$1 = da$1, ga$1 = Object.defineProperty({NumberSchema: ha$1}, "__esModule", {value: true});
  class ma$1 extends ga$1.NumberSchema {
    expected() {
      return "an integer";
    }
    validate(e20, t2) {
      return t2.normalizeValidateResult(super.validate(e20, t2), e20) === true && ca$1.isInt(e20);
    }
  }
  var ya$1 = ma$1, Da$1 = Object.defineProperty({IntegerSchema: ya$1}, "__esModule", {value: true});
  class Ea$1 extends Ls$2.Schema {
    expected() {
      return "a string";
    }
    validate(e20) {
      return typeof e20 == "string";
    }
  }
  var Ca$1 = Ea$1, ba$1 = Object.defineProperty({StringSchema: Ca$1}, "__esModule", {value: true}), Aa$1 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Ms$2, t2), wo$2.__exportStar(Vs$2, t2), wo$2.__exportStar(zs$2, t2), wo$2.__exportStar(Js$2, t2), wo$2.__exportStar(fa$1, t2), wo$2.__exportStar(Da$1, t2), wo$2.__exportStar(ga$1, t2), wo$2.__exportStar(ba$1, t2);
  }), va$1 = To$2.apiDescriptor, Fa$1 = xs$2.levenUnknownHandler, Sa$1 = vs$2.commonInvalidHandler, xa$1 = Cs$2.commonDeprecatedHandler, wa$1 = Object.defineProperty({defaultDescriptor: va$1, defaultUnknownHandler: Fa$1, defaultInvalidHandler: Sa$1, defaultDeprecatedHandler: xa$1}, "__esModule", {value: true});
  class Ta$1 {
    constructor(e20, t2) {
      const {logger: n2 = console, descriptor: r2 = wa$1.defaultDescriptor, unknown: i2 = wa$1.defaultUnknownHandler, invalid: u2 = wa$1.defaultInvalidHandler, deprecated: o2 = wa$1.defaultDeprecatedHandler} = t2 || {};
      this._utils = {descriptor: r2, logger: n2 || {warn: () => {
      }}, schemas: ca$1.recordFromArray(e20, "name"), normalizeDefaultResult: ca$1.normalizeDefaultResult, normalizeDeprecatedResult: ca$1.normalizeDeprecatedResult, normalizeForwardResult: ca$1.normalizeForwardResult, normalizeRedirectResult: ca$1.normalizeRedirectResult, normalizeValidateResult: ca$1.normalizeValidateResult}, this._unknownHandler = i2, this._invalidHandler = u2, this._deprecatedHandler = o2, this.cleanHistory();
    }
    cleanHistory() {
      this._hasDeprecationWarned = ca$1.createAutoChecklist();
    }
    normalize(e20) {
      const t2 = {}, n2 = [e20], r2 = () => {
        for (; n2.length !== 0; ) {
          const e21 = n2.shift(), r3 = this._applyNormalization(e21, t2);
          n2.push(...r3);
        }
      };
      r2();
      for (const e21 of Object.keys(this._utils.schemas)) {
        const r3 = this._utils.schemas[e21];
        if (!(e21 in t2)) {
          const t3 = ca$1.normalizeDefaultResult(r3.default(this._utils));
          "value" in t3 && n2.push({[e21]: t3.value});
        }
      }
      r2();
      for (const e21 of Object.keys(this._utils.schemas)) {
        const n3 = this._utils.schemas[e21];
        e21 in t2 && (t2[e21] = n3.postprocess(t2[e21], this._utils));
      }
      return t2;
    }
    _applyNormalization(e20, t2) {
      const n2 = [], [r2, i2] = ca$1.partition(Object.keys(e20), (e21) => e21 in this._utils.schemas);
      for (const i3 of r2) {
        const r3 = this._utils.schemas[i3], u2 = r3.preprocess(e20[i3], this._utils), o2 = ca$1.normalizeValidateResult(r3.validate(u2, this._utils), u2);
        if (o2 !== true) {
          const {value: e21} = o2, t3 = this._invalidHandler(i3, e21, this._utils);
          throw typeof t3 == "string" ? new Error(t3) : t3;
        }
        const s2 = ({from: e21, to: t3}) => {
          n2.push(typeof t3 == "string" ? {[t3]: e21} : {[t3.key]: t3.value});
        }, a2 = ({value: e21, redirectTo: t3}) => {
          const n3 = ca$1.normalizeDeprecatedResult(r3.deprecated(e21, this._utils), u2, true);
          if (n3 !== false)
            if (n3 === true)
              this._hasDeprecationWarned(i3) || this._utils.logger.warn(this._deprecatedHandler(i3, t3, this._utils));
            else
              for (const {value: e22} of n3) {
                const n4 = {key: i3, value: e22};
                if (!this._hasDeprecationWarned(n4)) {
                  const r4 = typeof t3 == "string" ? {key: t3, value: e22} : t3;
                  this._utils.logger.warn(this._deprecatedHandler(n4, r4, this._utils));
                }
              }
        };
        ca$1.normalizeForwardResult(r3.forward(u2, this._utils), u2).forEach(s2);
        const c2 = ca$1.normalizeRedirectResult(r3.redirect(u2, this._utils), u2);
        if (c2.redirect.forEach(s2), "remain" in c2) {
          const e21 = c2.remain;
          t2[i3] = i3 in t2 ? r3.overlap(t2[i3], e21, this._utils) : e21, a2({value: e21});
        }
        for (const {from: e21, to: t3} of c2.redirect)
          a2({value: e21, redirectTo: t3});
      }
      for (const r3 of i2) {
        const i3 = e20[r3], u2 = this._unknownHandler(r3, i3, this._utils);
        if (u2)
          for (const e21 of Object.keys(u2)) {
            const r4 = {[e21]: u2[e21]};
            e21 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
          }
      }
      return n2;
    }
  }
  var Ba$1 = Ta$1, Na$1 = Object.defineProperty({normalize: (e20, t2, n2) => new Ta$1(t2, n2).normalize(e20), Normalizer: Ba$1}, "__esModule", {value: true}), ka$1 = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), wo$2.__exportStar(Bo$2, t2), wo$2.__exportStar(Ts$2, t2), wo$2.__exportStar(Aa$1, t2), wo$2.__exportStar(Na$1, t2), wo$2.__exportStar(Ls$2, t2);
  });
  const Pa$1 = [], Oa$1 = [], Ia$1 = (e20, t2) => {
    if (e20 === t2)
      return 0;
    const n2 = e20;
    e20.length > t2.length && (e20 = t2, t2 = n2);
    let r2 = e20.length, i2 = t2.length;
    for (; r2 > 0 && e20.charCodeAt(~-r2) === t2.charCodeAt(~-i2); )
      r2--, i2--;
    let u2, o2, s2, a2, c2 = 0;
    for (; c2 < r2 && e20.charCodeAt(c2) === t2.charCodeAt(c2); )
      c2++;
    if (r2 -= c2, i2 -= c2, r2 === 0)
      return i2;
    let l2 = 0, p2 = 0;
    for (; l2 < r2; )
      Oa$1[l2] = e20.charCodeAt(c2 + l2), Pa$1[l2] = ++l2;
    for (; p2 < i2; )
      for (u2 = t2.charCodeAt(c2 + p2), s2 = p2++, o2 = p2, l2 = 0; l2 < r2; l2++)
        a2 = u2 === Oa$1[l2] ? s2 : s2 + 1, s2 = Pa$1[l2], o2 = Pa$1[l2] = s2 > o2 ? a2 > o2 ? o2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
    return o2;
  };
  var La$1 = Ia$1, ja$1 = Ia$1;
  La$1.default = ja$1;
  var _a$1$1 = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]};
  const Ma$1 = {};
  for (const e20 of Object.keys(_a$1$1))
    Ma$1[_a$1$1[e20]] = e20;
  const Ra$1 = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
  var $a$1 = Ra$1;
  for (const e20 of Object.keys(Ra$1)) {
    if (!("channels" in Ra$1[e20]))
      throw new Error("missing channels property: " + e20);
    if (!("labels" in Ra$1[e20]))
      throw new Error("missing channel labels property: " + e20);
    if (Ra$1[e20].labels.length !== Ra$1[e20].channels)
      throw new Error("channel and label counts mismatch: " + e20);
    const {channels: t2, labels: n2} = Ra$1[e20];
    delete Ra$1[e20].channels, delete Ra$1[e20].labels, Object.defineProperty(Ra$1[e20], "channels", {value: t2}), Object.defineProperty(Ra$1[e20], "labels", {value: n2});
  }
  function Va$1(e20) {
    const t2 = function() {
      const e21 = {}, t3 = Object.keys($a$1);
      for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
        e21[t3[r2]] = {distance: -1, parent: null};
      return e21;
    }(), n2 = [e20];
    for (t2[e20].distance = 0; n2.length; ) {
      const e21 = n2.pop(), r2 = Object.keys($a$1[e21]);
      for (let i2 = r2.length, u2 = 0; u2 < i2; u2++) {
        const i3 = r2[u2], o2 = t2[i3];
        o2.distance === -1 && (o2.distance = t2[e21].distance + 1, o2.parent = e21, n2.unshift(i3));
      }
    }
    return t2;
  }
  function Wa$1(e20, t2) {
    return function(n2) {
      return t2(e20(n2));
    };
  }
  function qa$1(e20, t2) {
    const n2 = [t2[e20].parent, e20];
    let r2 = $a$1[t2[e20].parent][e20], i2 = t2[e20].parent;
    for (; t2[i2].parent; )
      n2.unshift(t2[i2].parent), r2 = Wa$1($a$1[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
    return r2.conversion = n2, r2;
  }
  Ra$1.rgb.hsl = function(e20) {
    const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(t2, n2, r2), u2 = Math.max(t2, n2, r2), o2 = u2 - i2;
    let s2, a2;
    u2 === i2 ? s2 = 0 : t2 === u2 ? s2 = (n2 - r2) / o2 : n2 === u2 ? s2 = 2 + (r2 - t2) / o2 : r2 === u2 && (s2 = 4 + (t2 - n2) / o2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
    const c2 = (i2 + u2) / 2;
    return a2 = u2 === i2 ? 0 : c2 <= 0.5 ? o2 / (u2 + i2) : o2 / (2 - u2 - i2), [s2, 100 * a2, 100 * c2];
  }, Ra$1.rgb.hsv = function(e20) {
    let t2, n2, r2, i2, u2;
    const o2 = e20[0] / 255, s2 = e20[1] / 255, a2 = e20[2] / 255, c2 = Math.max(o2, s2, a2), l2 = c2 - Math.min(o2, s2, a2), p2 = function(e21) {
      return (c2 - e21) / 6 / l2 + 0.5;
    };
    return l2 === 0 ? (i2 = 0, u2 = 0) : (u2 = l2 / c2, t2 = p2(o2), n2 = p2(s2), r2 = p2(a2), o2 === c2 ? i2 = r2 - n2 : s2 === c2 ? i2 = 1 / 3 + t2 - r2 : a2 === c2 && (i2 = 2 / 3 + n2 - t2), i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1)), [360 * i2, 100 * u2, 100 * c2];
  }, Ra$1.rgb.hwb = function(e20) {
    const t2 = e20[0], n2 = e20[1];
    let r2 = e20[2];
    const i2 = Ra$1.rgb.hsl(e20)[0], u2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
    return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [i2, 100 * u2, 100 * r2];
  }, Ra$1.rgb.cmyk = function(e20) {
    const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(1 - t2, 1 - n2, 1 - r2);
    return [100 * ((1 - t2 - i2) / (1 - i2) || 0), 100 * ((1 - n2 - i2) / (1 - i2) || 0), 100 * ((1 - r2 - i2) / (1 - i2) || 0), 100 * i2];
  }, Ra$1.rgb.keyword = function(e20) {
    const t2 = Ma$1[e20];
    if (t2)
      return t2;
    let n2, r2 = 1 / 0;
    for (const t3 of Object.keys(_a$1$1)) {
      const o2 = (u2 = _a$1$1[t3], __pow((i2 = e20)[0] - u2[0], 2) + __pow(i2[1] - u2[1], 2) + __pow(i2[2] - u2[2], 2));
      o2 < r2 && (r2 = o2, n2 = t3);
    }
    var i2, u2;
    return n2;
  }, Ra$1.keyword.rgb = function(e20) {
    return _a$1$1[e20];
  }, Ra$1.rgb.xyz = function(e20) {
    let t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255;
    t2 = t2 > 0.04045 ? __pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92, n2 = n2 > 0.04045 ? __pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92, r2 = r2 > 0.04045 ? __pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
    return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
  }, Ra$1.rgb.lab = function(e20) {
    const t2 = Ra$1.rgb.xyz(e20);
    let n2 = t2[0], r2 = t2[1], i2 = t2[2];
    n2 /= 95.047, r2 /= 100, i2 /= 108.883, n2 = n2 > 8856e-6 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116, i2 = i2 > 8856e-6 ? __pow(i2, 1 / 3) : 7.787 * i2 + 16 / 116;
    return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - i2)];
  }, Ra$1.hsl.rgb = function(e20) {
    const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
    let i2, u2, o2;
    if (n2 === 0)
      return o2 = 255 * r2, [o2, o2, o2];
    i2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
    const s2 = 2 * r2 - i2, a2 = [0, 0, 0];
    for (let e21 = 0; e21 < 3; e21++)
      u2 = t2 + 1 / 3 * -(e21 - 1), u2 < 0 && u2++, u2 > 1 && u2--, o2 = 6 * u2 < 1 ? s2 + 6 * (i2 - s2) * u2 : 2 * u2 < 1 ? i2 : 3 * u2 < 2 ? s2 + (i2 - s2) * (2 / 3 - u2) * 6 : s2, a2[e21] = 255 * o2;
    return a2;
  }, Ra$1.hsl.hsv = function(e20) {
    const t2 = e20[0];
    let n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = n2;
    const u2 = Math.max(r2, 0.01);
    r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, i2 *= u2 <= 1 ? u2 : 2 - u2;
    return [t2, 100 * (r2 === 0 ? 2 * i2 / (u2 + i2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
  }, Ra$1.hsv.rgb = function(e20) {
    const t2 = e20[0] / 60, n2 = e20[1] / 100;
    let r2 = e20[2] / 100;
    const i2 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), o2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * u2), a2 = 255 * r2 * (1 - n2 * (1 - u2));
    switch (r2 *= 255, i2) {
      case 0:
        return [r2, a2, o2];
      case 1:
        return [s2, r2, o2];
      case 2:
        return [o2, r2, a2];
      case 3:
        return [o2, s2, r2];
      case 4:
        return [a2, o2, r2];
      case 5:
        return [r2, o2, s2];
    }
  }, Ra$1.hsv.hsl = function(e20) {
    const t2 = e20[0], n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = Math.max(r2, 0.01);
    let u2, o2;
    o2 = (2 - n2) * r2;
    const s2 = (2 - n2) * i2;
    return u2 = n2 * i2, u2 /= s2 <= 1 ? s2 : 2 - s2, u2 = u2 || 0, o2 /= 2, [t2, 100 * u2, 100 * o2];
  }, Ra$1.hwb.rgb = function(e20) {
    const t2 = e20[0] / 360;
    let n2 = e20[1] / 100, r2 = e20[2] / 100;
    const i2 = n2 + r2;
    let u2;
    i2 > 1 && (n2 /= i2, r2 /= i2);
    const o2 = Math.floor(6 * t2), s2 = 1 - r2;
    u2 = 6 * t2 - o2, (1 & o2) != 0 && (u2 = 1 - u2);
    const a2 = n2 + u2 * (s2 - n2);
    let c2, l2, p2;
    switch (o2) {
      default:
      case 6:
      case 0:
        c2 = s2, l2 = a2, p2 = n2;
        break;
      case 1:
        c2 = a2, l2 = s2, p2 = n2;
        break;
      case 2:
        c2 = n2, l2 = s2, p2 = a2;
        break;
      case 3:
        c2 = n2, l2 = a2, p2 = s2;
        break;
      case 4:
        c2 = a2, l2 = n2, p2 = s2;
        break;
      case 5:
        c2 = s2, l2 = n2, p2 = a2;
    }
    return [255 * c2, 255 * l2, 255 * p2];
  }, Ra$1.cmyk.rgb = function(e20) {
    const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = e20[3] / 100;
    return [255 * (1 - Math.min(1, t2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, n2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, r2 * (1 - i2) + i2))];
  }, Ra$1.xyz.rgb = function(e20) {
    const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100;
    let i2, u2, o2;
    return i2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, o2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, i2 = i2 > 31308e-7 ? 1.055 * __pow(i2, 1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * __pow(u2, 1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * __pow(o2, 1 / 2.4) - 0.055 : 12.92 * o2, i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), [255 * i2, 255 * u2, 255 * o2];
  }, Ra$1.xyz.lab = function(e20) {
    let t2 = e20[0], n2 = e20[1], r2 = e20[2];
    t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? __pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116;
    return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
  }, Ra$1.lab.xyz = function(e20) {
    let t2, n2, r2;
    n2 = (e20[0] + 16) / 116, t2 = e20[1] / 500 + n2, r2 = n2 - e20[2] / 200;
    const i2 = __pow(n2, 3), u2 = __pow(t2, 3), o2 = __pow(r2, 3);
    return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = o2 > 8856e-6 ? o2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
  }, Ra$1.lab.lch = function(e20) {
    const t2 = e20[0], n2 = e20[1], r2 = e20[2];
    let i2;
    i2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, i2 < 0 && (i2 += 360);
    return [t2, Math.sqrt(n2 * n2 + r2 * r2), i2];
  }, Ra$1.lch.lab = function(e20) {
    const t2 = e20[0], n2 = e20[1], r2 = e20[2] / 360 * 2 * Math.PI;
    return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
  }, Ra$1.rgb.ansi16 = function(e20, t2 = null) {
    const [n2, r2, i2] = e20;
    let u2 = t2 === null ? Ra$1.rgb.hsv(e20)[2] : t2;
    if (u2 = Math.round(u2 / 50), u2 === 0)
      return 30;
    let o2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
    return u2 === 2 && (o2 += 60), o2;
  }, Ra$1.hsv.ansi16 = function(e20) {
    return Ra$1.rgb.ansi16(Ra$1.hsv.rgb(e20), e20[2]);
  }, Ra$1.rgb.ansi256 = function(e20) {
    const t2 = e20[0], n2 = e20[1], r2 = e20[2];
    if (t2 === n2 && n2 === r2)
      return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
    return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
  }, Ra$1.ansi16.rgb = function(e20) {
    let t2 = e20 % 10;
    if (t2 === 0 || t2 === 7)
      return e20 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
    const n2 = 0.5 * (1 + ~~(e20 > 50));
    return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
  }, Ra$1.ansi256.rgb = function(e20) {
    if (e20 >= 232) {
      const t3 = 10 * (e20 - 232) + 8;
      return [t3, t3, t3];
    }
    let t2;
    e20 -= 16;
    return [Math.floor(e20 / 36) / 5 * 255, Math.floor((t2 = e20 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
  }, Ra$1.rgb.hex = function(e20) {
    const t2 = (((255 & Math.round(e20[0])) << 16) + ((255 & Math.round(e20[1])) << 8) + (255 & Math.round(e20[2]))).toString(16).toUpperCase();
    return "000000".substring(t2.length) + t2;
  }, Ra$1.hex.rgb = function(e20) {
    const t2 = e20.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t2)
      return [0, 0, 0];
    let n2 = t2[0];
    t2[0].length === 3 && (n2 = n2.split("").map((e21) => e21 + e21).join(""));
    const r2 = parseInt(n2, 16);
    return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
  }, Ra$1.rgb.hcg = function(e20) {
    const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), o2 = i2 - u2;
    let s2, a2;
    return s2 = o2 < 1 ? u2 / (1 - o2) : 0, a2 = o2 <= 0 ? 0 : i2 === t2 ? (n2 - r2) / o2 % 6 : i2 === n2 ? 2 + (r2 - t2) / o2 : 4 + (t2 - n2) / o2, a2 /= 6, a2 %= 1, [360 * a2, 100 * o2, 100 * s2];
  }, Ra$1.hsl.hcg = function(e20) {
    const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - 0.5 * r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
  }, Ra$1.hsv.hcg = function(e20) {
    const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = t2 * n2;
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
  }, Ra$1.hcg.rgb = function(e20) {
    const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
    if (n2 === 0)
      return [255 * r2, 255 * r2, 255 * r2];
    const i2 = [0, 0, 0], u2 = t2 % 1 * 6, o2 = u2 % 1, s2 = 1 - o2;
    let a2 = 0;
    switch (Math.floor(u2)) {
      case 0:
        i2[0] = 1, i2[1] = o2, i2[2] = 0;
        break;
      case 1:
        i2[0] = s2, i2[1] = 1, i2[2] = 0;
        break;
      case 2:
        i2[0] = 0, i2[1] = 1, i2[2] = o2;
        break;
      case 3:
        i2[0] = 0, i2[1] = s2, i2[2] = 1;
        break;
      case 4:
        i2[0] = o2, i2[1] = 0, i2[2] = 1;
        break;
      default:
        i2[0] = 1, i2[1] = 0, i2[2] = s2;
    }
    return a2 = (1 - n2) * r2, [255 * (n2 * i2[0] + a2), 255 * (n2 * i2[1] + a2), 255 * (n2 * i2[2] + a2)];
  }, Ra$1.hcg.hsv = function(e20) {
    const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
    let r2 = 0;
    return n2 > 0 && (r2 = t2 / n2), [e20[0], 100 * r2, 100 * n2];
  }, Ra$1.hcg.hsl = function(e20) {
    const t2 = e20[1] / 100, n2 = e20[2] / 100 * (1 - t2) + 0.5 * t2;
    let r2 = 0;
    return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e20[0], 100 * r2, 100 * n2];
  }, Ra$1.hcg.hwb = function(e20) {
    const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
    return [e20[0], 100 * (n2 - t2), 100 * (1 - n2)];
  }, Ra$1.hwb.hcg = function(e20) {
    const t2 = e20[1] / 100, n2 = 1 - e20[2] / 100, r2 = n2 - t2;
    let i2 = 0;
    return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
  }, Ra$1.apple.rgb = function(e20) {
    return [e20[0] / 65535 * 255, e20[1] / 65535 * 255, e20[2] / 65535 * 255];
  }, Ra$1.rgb.apple = function(e20) {
    return [e20[0] / 255 * 65535, e20[1] / 255 * 65535, e20[2] / 255 * 65535];
  }, Ra$1.gray.rgb = function(e20) {
    return [e20[0] / 100 * 255, e20[0] / 100 * 255, e20[0] / 100 * 255];
  }, Ra$1.gray.hsl = function(e20) {
    return [0, 0, e20[0]];
  }, Ra$1.gray.hsv = Ra$1.gray.hsl, Ra$1.gray.hwb = function(e20) {
    return [0, 100, e20[0]];
  }, Ra$1.gray.cmyk = function(e20) {
    return [0, 0, 0, e20[0]];
  }, Ra$1.gray.lab = function(e20) {
    return [e20[0], 0, 0];
  }, Ra$1.gray.hex = function(e20) {
    const t2 = 255 & Math.round(e20[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
    return "000000".substring(n2.length) + n2;
  }, Ra$1.rgb.gray = function(e20) {
    return [(e20[0] + e20[1] + e20[2]) / 3 / 255 * 100];
  };
  const Ua$1 = {};
  Object.keys($a$1).forEach((e20) => {
    Ua$1[e20] = {}, Object.defineProperty(Ua$1[e20], "channels", {value: $a$1[e20].channels}), Object.defineProperty(Ua$1[e20], "labels", {value: $a$1[e20].labels});
    const t2 = function(e21) {
      const t3 = Va$1(e21), n2 = {}, r2 = Object.keys(t3);
      for (let e22 = r2.length, i2 = 0; i2 < e22; i2++) {
        const e23 = r2[i2];
        t3[e23].parent !== null && (n2[e23] = qa$1(e23, t3));
      }
      return n2;
    }(e20);
    Object.keys(t2).forEach((n2) => {
      const r2 = t2[n2];
      Ua$1[e20][n2] = function(e21) {
        const t3 = function(...t4) {
          const n3 = t4[0];
          if (n3 == null)
            return n3;
          n3.length > 1 && (t4 = n3);
          const r3 = e21(t4);
          if (typeof r3 == "object")
            for (let e22 = r3.length, t5 = 0; t5 < e22; t5++)
              r3[t5] = Math.round(r3[t5]);
          return r3;
        };
        return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
      }(r2), Ua$1[e20][n2].raw = function(e21) {
        const t3 = function(...t4) {
          const n3 = t4[0];
          return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e21(t4));
        };
        return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
      }(r2);
    });
  });
  var za$1 = Ua$1, Ga$1 = r$3(function(e20) {
    const t2 = (e21, t3) => (...n3) => `[${e21(...n3) + t3}m`, n2 = (e21, t3) => (...n3) => {
      const r3 = e21(...n3);
      return `[${38 + t3};5;${r3}m`;
    }, r2 = (e21, t3) => (...n3) => {
      const r3 = e21(...n3);
      return `[${38 + t3};2;${r3[0]};${r3[1]};${r3[2]}m`;
    }, i2 = (e21) => e21, u2 = (e21, t3, n3) => [e21, t3, n3], o2 = (e21, t3, n3) => {
      Object.defineProperty(e21, t3, {get: () => {
        const r3 = n3();
        return Object.defineProperty(e21, t3, {value: r3, enumerable: true, configurable: true}), r3;
      }, enumerable: true, configurable: true});
    };
    let s2;
    const a2 = (e21, t3, n3, r3) => {
      s2 === void 0 && (s2 = za$1);
      const i3 = r3 ? 10 : 0, u3 = {};
      for (const [r4, o3] of Object.entries(s2)) {
        const s3 = r4 === "ansi16" ? "ansi" : r4;
        r4 === t3 ? u3[s3] = e21(n3, i3) : typeof o3 == "object" && (u3[s3] = e21(o3[t3], i3));
      }
      return u3;
    };
    Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
      const e21 = new Map(), s3 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
      s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
      for (const [t3, n3] of Object.entries(s3)) {
        for (const [t4, r3] of Object.entries(n3))
          s3[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = s3[t4], e21.set(r3[0], r3[1]);
        Object.defineProperty(s3, t3, {value: n3, enumerable: false});
      }
      return Object.defineProperty(s3, "codes", {value: e21, enumerable: false}), s3.color.close = "[39m", s3.bgColor.close = "[49m", o2(s3.color, "ansi", () => a2(t2, "ansi16", i2, false)), o2(s3.color, "ansi256", () => a2(n2, "ansi256", i2, false)), o2(s3.color, "ansi16m", () => a2(r2, "rgb", u2, false)), o2(s3.bgColor, "ansi", () => a2(t2, "ansi16", i2, true)), o2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", i2, true)), o2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", u2, true)), s3;
    }});
  });
  function Ha$1() {
    return false;
  }
  function Ja$1() {
    throw new Error("tty.ReadStream is not implemented");
  }
  function Xa$1() {
    throw new Error("tty.ReadStream is not implemented");
  }
  var Ya$1 = {isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1}, Ka$1 = (e20, t2 = xr$2.argv) => {
    const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  }, Qa$1 = n$3(Object.freeze({__proto__: null, isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1, default: Ya$1}));
  const {env: Za$1} = xr$2;
  let ec;
  function tc(e20) {
    return e20 !== 0 && {level: e20, hasBasic: true, has256: e20 >= 2, has16m: e20 >= 3};
  }
  function nc(e20, t2) {
    if (ec === 0)
      return 0;
    if (Ka$1("color=16m") || Ka$1("color=full") || Ka$1("color=truecolor"))
      return 3;
    if (Ka$1("color=256"))
      return 2;
    if (e20 && !t2 && ec === void 0)
      return 0;
    const n2 = ec || 0;
    if (Za$1.TERM === "dumb")
      return n2;
    if (xr$2.platform === "win32") {
      const e21 = is$2.release().split(".");
      return Number(e21[0]) >= 10 && Number(e21[2]) >= 10586 ? Number(e21[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Za$1)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e21) => e21 in Za$1) || Za$1.CI_NAME === "codeship" ? 1 : n2;
    if ("TEAMCITY_VERSION" in Za$1)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Za$1.TEAMCITY_VERSION) ? 1 : 0;
    if (Za$1.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Za$1) {
      const e21 = parseInt((Za$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Za$1.TERM_PROGRAM) {
        case "iTerm.app":
          return e21 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Za$1.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Za$1.TERM) || "COLORTERM" in Za$1 ? 1 : n2;
  }
  Ka$1("no-color") || Ka$1("no-colors") || Ka$1("color=false") || Ka$1("color=never") ? ec = 0 : (Ka$1("color") || Ka$1("colors") || Ka$1("color=true") || Ka$1("color=always")) && (ec = 1), "FORCE_COLOR" in Za$1 && (ec = Za$1.FORCE_COLOR === "true" ? 1 : Za$1.FORCE_COLOR === "false" ? 0 : Za$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Za$1.FORCE_COLOR, 10), 3));
  var rc = {supportsColor: function(e20) {
    return tc(nc(e20, e20 && e20.isTTY));
  }, stdout: tc(nc(true, Qa$1.isatty(1))), stderr: tc(nc(true, Qa$1.isatty(2)))};
  var ic = {stringReplaceAll: (e20, t2, n2) => {
    let r2 = e20.indexOf(t2);
    if (r2 === -1)
      return e20;
    const i2 = t2.length;
    let u2 = 0, o2 = "";
    do {
      o2 += e20.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + i2, r2 = e20.indexOf(t2, u2);
    } while (r2 !== -1);
    return o2 += e20.substr(u2), o2;
  }, stringEncaseCRLFWithFirstIndex: (e20, t2, n2, r2) => {
    let i2 = 0, u2 = "";
    do {
      const o2 = e20[r2 - 1] === "\r";
      u2 += e20.substr(i2, (o2 ? r2 - 1 : r2) - i2) + t2 + (o2 ? "\r\n" : "\n") + n2, i2 = r2 + 1, r2 = e20.indexOf("\n", i2);
    } while (r2 !== -1);
    return u2 += e20.substr(i2), u2;
  }};
  const uc = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, oc = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, sc = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ac = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, cc = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function lc(e20) {
    const t2 = e20[0] === "u", n2 = e20[1] === "{";
    return t2 && !n2 && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e20.slice(2, -1), 16)) : cc.get(e20) || e20;
  }
  function pc(e20, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2) {
      const r3 = Number(t3);
      if (Number.isNaN(r3)) {
        if (!(i2 = t3.match(sc)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
        n2.push(i2[2].replace(ac, (e21, t4, n3) => t4 ? lc(t4) : n3));
      } else
        n2.push(r3);
    }
    return n2;
  }
  function fc(e20) {
    oc.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = oc.exec(e20)) !== null; ) {
      const e21 = n2[1];
      if (n2[2]) {
        const r2 = pc(e21, n2[2]);
        t2.push([e21].concat(r2));
      } else
        t2.push([e21]);
    }
    return t2;
  }
  function dc(e20, t2) {
    const n2 = {};
    for (const e21 of t2)
      for (const t3 of e21.styles)
        n2[t3[0]] = e21.inverse ? null : t3.slice(1);
    let r2 = e20;
    for (const [e21, t3] of Object.entries(n2))
      if (Array.isArray(t3)) {
        if (!(e21 in r2))
          throw new Error(`Unknown Chalk style: ${e21}`);
        r2 = t3.length > 0 ? r2[e21](...t3) : r2[e21];
      }
    return r2;
  }
  var hc = (e20, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(uc, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(lc(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : dc(e20, n2)(t4)), n2.push({inverse: o2, styles: fc(s2)});
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(dc(e20, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e21);
    }
    return r2.join("");
  };
  const {stdout: gc, stderr: mc} = rc, {stringReplaceAll: yc, stringEncaseCRLFWithFirstIndex: Dc} = ic, {isArray: Ec} = Array, Cc = ["ansi", "ansi", "ansi256", "ansi16m"], bc = Object.create(null);
  class Ac {
    constructor(e20) {
      return vc(e20);
    }
  }
  const vc = (e20) => {
    const t2 = {};
    return ((e21, t3 = {}) => {
      if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
        throw new Error("The `level` option should be an integer from 0 to 3");
      const n2 = gc ? gc.level : 0;
      e21.level = t3.level === void 0 ? n2 : t3.level;
    })(t2, e20), t2.template = (...e21) => kc(t2.template, ...e21), Object.setPrototypeOf(t2, Fc.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t2.template.Instance = Ac, t2.template;
  };
  function Fc(e20) {
    return vc(e20);
  }
  for (const [e20, t2] of Object.entries(Ga$1))
    bc[e20] = {get() {
      const n2 = Tc(this, wc(t2.open, t2.close, this._styler), this._isEmpty);
      return Object.defineProperty(this, e20, {value: n2}), n2;
    }};
  bc.visible = {get() {
    const e20 = Tc(this, this._styler, true);
    return Object.defineProperty(this, "visible", {value: e20}), e20;
  }};
  const Sc = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const e20 of Sc)
    bc[e20] = {get() {
      const {level: t2} = this;
      return function(...n2) {
        const r2 = wc(Ga$1.color[Cc[t2]][e20](...n2), Ga$1.color.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    }};
  for (const e20 of Sc) {
    bc["bg" + e20[0].toUpperCase() + e20.slice(1)] = {get() {
      const {level: t2} = this;
      return function(...n2) {
        const r2 = wc(Ga$1.bgColor[Cc[t2]][e20](...n2), Ga$1.bgColor.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    }};
  }
  const xc = Object.defineProperties(() => {
  }, Object.assign(Object.assign({}, bc), {}, {level: {enumerable: true, get() {
    return this._generator.level;
  }, set(e20) {
    this._generator.level = e20;
  }}})), wc = (e20, t2, n2) => {
    let r2, i2;
    return n2 === void 0 ? (r2 = e20, i2 = t2) : (r2 = n2.openAll + e20, i2 = t2 + n2.closeAll), {open: e20, close: t2, openAll: r2, closeAll: i2, parent: n2};
  }, Tc = (e20, t2, n2) => {
    const r2 = (...e21) => Ec(e21[0]) && Ec(e21[0].raw) ? Bc(r2, kc(r2, ...e21)) : Bc(r2, e21.length === 1 ? "" + e21[0] : e21.join(" "));
    return Object.setPrototypeOf(r2, xc), r2._generator = e20, r2._styler = t2, r2._isEmpty = n2, r2;
  }, Bc = (e20, t2) => {
    if (e20.level <= 0 || !t2)
      return e20._isEmpty ? "" : t2;
    let n2 = e20._styler;
    if (n2 === void 0)
      return t2;
    const {openAll: r2, closeAll: i2} = n2;
    if (t2.indexOf("") !== -1)
      for (; n2 !== void 0; )
        t2 = yc(t2, n2.close, n2.open), n2 = n2.parent;
    const u2 = t2.indexOf("\n");
    return u2 !== -1 && (t2 = Dc(t2, i2, r2, u2)), r2 + t2 + i2;
  };
  let Nc;
  const kc = (e20, ...t2) => {
    const [n2] = t2;
    if (!Ec(n2) || !Ec(n2.raw))
      return t2.join(" ");
    const r2 = t2.slice(1), i2 = [n2.raw[0]];
    for (let e21 = 1; e21 < n2.length; e21++)
      i2.push(String(r2[e21 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e21]));
    return Nc === void 0 && (Nc = hc), Nc(e20, i2.join(""));
  };
  Object.defineProperties(Fc.prototype, bc);
  const Pc = Fc();
  Pc.supportsColor = gc, Pc.stderr = Fc({level: mc ? mc.level : 0}), Pc.stderr.supportsColor = mc;
  var Oc = Pc;
  const Ic = ["_"], Lc = {key: (e20) => e20.length === 1 ? `-${e20}` : `--${e20}`, value: (e20) => ka$1.apiDescriptor.value(e20), pair: ({key: e20, value: t2}) => t2 === false ? `--no-${e20}` : t2 === true ? Lc.key(e20) : t2 === "" ? `${Lc.key(e20)} without an argument` : `${Lc.key(e20)}=${t2}`};
  class jc extends ka$1.ChoiceSchema {
    constructor({name: e20, flags: t2}) {
      super({name: e20, choices: t2}), this._flags = [...t2].sort();
    }
    preprocess(e20, t2) {
      if (typeof e20 == "string" && e20.length > 0 && !this._flags.includes(e20)) {
        const n2 = this._flags.find((t3) => La$1(t3, e20) < 3);
        if (n2)
          return t2.logger.warn([`Unknown flag ${Oc.yellow(t2.descriptor.value(e20))},`, `did you mean ${Oc.blue(t2.descriptor.value(n2))}?`].join(" ")), n2;
      }
      return e20;
    }
    expected() {
      return "a flag";
    }
  }
  let _c$3;
  function Mc(e20, t2, {logger: n2, isCLI: r2 = false, passThrough: i2 = false} = {}) {
    const u2 = i2 ? Array.isArray(i2) ? (e21, t3) => i2.includes(e21) ? {[e21]: t3} : void 0 : (e21, t3) => ({[e21]: t3}) : (e21, t3, n3) => {
      const r3 = jn$2(n3.schemas, Ic);
      return ka$1.levenUnknownHandler(e21, t3, Object.assign(Object.assign({}, n3), {}, {schemas: r3}));
    }, o2 = r2 ? Lc : ka$1.apiDescriptor, s2 = function(e21, {isCLI: t3}) {
      const n3 = [];
      t3 && n3.push(ka$1.AnySchema.create({name: "_"}));
      for (const r3 of e21)
        n3.push(Rc(r3, {isCLI: t3, optionInfos: e21})), r3.alias && t3 && n3.push(ka$1.AliasSchema.create({name: r3.alias, sourceName: r3.name}));
      return n3;
    }(t2, {isCLI: r2}), a2 = new ka$1.Normalizer(s2, {logger: n2, unknown: u2, descriptor: o2}), c2 = n2 !== false;
    c2 && _c$3 && (a2._hasDeprecationWarned = _c$3);
    const l2 = a2.normalize(e20);
    return c2 && (_c$3 = a2._hasDeprecationWarned), l2;
  }
  function Rc(e20, {isCLI: t2, optionInfos: n2}) {
    let r2;
    const i2 = {name: e20.name}, u2 = {};
    switch (e20.type) {
      case "int":
        r2 = ka$1.IntegerSchema, t2 && (i2.preprocess = (e21) => Number(e21));
        break;
      case "string":
        r2 = ka$1.StringSchema;
        break;
      case "choice":
        r2 = ka$1.ChoiceSchema, i2.choices = e20.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, {redirect: {to: {key: e20.name, value: t3.redirect}}}) : t3);
        break;
      case "boolean":
        r2 = ka$1.BooleanSchema;
        break;
      case "flag":
        r2 = jc, i2.flags = n2.flatMap((e21) => [e21.alias, e21.description && e21.name, e21.oppositeDescription && `no-${e21.name}`].filter(Boolean));
        break;
      case "path":
        r2 = ka$1.StringSchema;
        break;
      default:
        throw new Error(`Unexpected type ${e20.type}`);
    }
    if (e20.exception ? i2.validate = (t3, n3, r3) => e20.exception(t3) || n3.validate(t3, r3) : i2.validate = (e21, t3, n3) => e21 === void 0 || t3.validate(e21, n3), e20.redirect && (u2.redirect = (t3) => t3 ? {to: {key: e20.redirect.option, value: e20.redirect.value}} : void 0), e20.deprecated && (u2.deprecated = true), t2 && !e20.array) {
      const e21 = i2.preprocess || ((e22) => e22);
      i2.preprocess = (t3, n3, r3) => n3.preprocess(e21(Array.isArray(t3) ? Ln$2(t3) : t3), r3);
    }
    return e20.array ? ka$1.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t2 ? {preprocess: (e21) => Array.isArray(e21) ? e21 : [e21]} : {}), u2), {}, {valueSchema: r2.create(i2)})) : r2.create(Object.assign(Object.assign({}, i2), u2));
  }
  var $c = {normalizeApiOptions: function(e20, t2, n2) {
    return Mc(e20, t2, n2);
  }, normalizeCliOptions: function(e20, t2, n2) {
    return Mc(e20, t2, Object.assign({isCLI: true}, n2));
  }};
  const {isNonEmptyArray: Vc} = yi$2;
  function Wc(e20, t2) {
    const {ignoreDecorators: n2} = t2 || {};
    if (!n2) {
      const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
      if (Vc(t3))
        return Wc(t3[0]);
    }
    return e20.range ? e20.range[0] : e20.start;
  }
  function qc(e20) {
    return e20.range ? e20.range[1] : e20.end;
  }
  function Uc(e20, t2) {
    return Wc(e20) === Wc(t2);
  }
  var zc = {locStart: Wc, locEnd: qc, hasSameLocStart: Uc, hasSameLoc: function(e20, t2) {
    return Uc(e20, t2) && function(e21, t3) {
      return qc(e21) === qc(t3);
    }(e20, t2);
  }}, Gc = Object.defineProperty({default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, matchToToken: function(e20) {
    var t2 = {type: "invalid", value: e20[0], closed: void 0};
    return e20[1] ? (t2.type = "string", t2.closed = !(!e20[3] && !e20[4])) : e20[5] ? t2.type = "comment" : e20[6] ? (t2.type = "comment", t2.closed = !!e20[7]) : e20[8] ? t2.type = "regex" : e20[9] ? t2.type = "number" : e20[10] ? t2.type = "name" : e20[11] ? t2.type = "punctuator" : e20[12] && (t2.type = "whitespace"), t2;
  }}, "__esModule", {value: true}), Hc = rl, Jc = il, Xc = function(e20) {
    let t2 = true;
    for (let n2 = 0; n2 < e20.length; n2++) {
      let r2 = e20.charCodeAt(n2);
      if ((64512 & r2) == 55296 && n2 + 1 < e20.length) {
        const t3 = e20.charCodeAt(++n2);
        (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
      }
      if (t2) {
        if (t2 = false, !rl(r2))
          return false;
      } else if (!il(r2))
        return false;
    }
    return !t2;
  };
  let Yc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Kc = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  const Qc = new RegExp("[" + Yc + "]"), Zc = new RegExp("[" + Yc + Kc + "]");
  Yc = Kc = null;
  const el = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], tl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function nl(e20, t2) {
    let n2 = 65536;
    for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
      if (n2 += t2[r2], n2 > e20)
        return false;
      if (n2 += t2[r2 + 1], n2 >= e20)
        return true;
    }
    return false;
  }
  function rl(e20) {
    return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Qc.test(String.fromCharCode(e20)) : nl(e20, el)));
  }
  function il(e20) {
    return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Zc.test(String.fromCharCode(e20)) : nl(e20, el) || nl(e20, tl))));
  }
  var ul = Object.defineProperty({isIdentifierStart: Hc, isIdentifierChar: Jc, isIdentifierName: Xc}, "__esModule", {value: true}), ol = ml, sl = yl, al = Dl, cl = function(e20, t2) {
    return yl(e20, t2) || Dl(e20);
  }, ll = function(e20) {
    return dl.has(e20);
  };
  const pl = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], fl = ["eval", "arguments"], dl = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), hl = new Set(pl), gl = new Set(fl);
  function ml(e20, t2) {
    return t2 && e20 === "await" || e20 === "enum";
  }
  function yl(e20, t2) {
    return ml(e20, t2) || hl.has(e20);
  }
  function Dl(e20) {
    return gl.has(e20);
  }
  var El = Object.defineProperty({isReservedWord: ol, isStrictReservedWord: sl, isStrictBindOnlyReservedWord: al, isStrictBindReservedWord: cl, isKeyword: ll}, "__esModule", {value: true}), Cl = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true}), Object.defineProperty(t2, "isIdentifierName", {enumerable: true, get: function() {
      return ul.isIdentifierName;
    }}), Object.defineProperty(t2, "isIdentifierChar", {enumerable: true, get: function() {
      return ul.isIdentifierChar;
    }}), Object.defineProperty(t2, "isIdentifierStart", {enumerable: true, get: function() {
      return ul.isIdentifierStart;
    }}), Object.defineProperty(t2, "isReservedWord", {enumerable: true, get: function() {
      return El.isReservedWord;
    }}), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", {enumerable: true, get: function() {
      return El.isStrictBindOnlyReservedWord;
    }}), Object.defineProperty(t2, "isStrictBindReservedWord", {enumerable: true, get: function() {
      return El.isStrictBindReservedWord;
    }}), Object.defineProperty(t2, "isStrictReservedWord", {enumerable: true, get: function() {
      return El.isStrictReservedWord;
    }}), Object.defineProperty(t2, "isKeyword", {enumerable: true, get: function() {
      return El.isKeyword;
    }});
  }), bl = /[|\\{}()[\]^$+*?.]/g, Al = function(e20) {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    return e20.replace(bl, "\\$&");
  }, vl = r$3(function(e20) {
    const t2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${n3 + t3}m`;
    }, n2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${38 + t3};5;${n3}m`;
    }, r2 = (e21, t3) => function() {
      const n3 = e21.apply(Ro$2, arguments);
      return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
    };
    Object.defineProperty(e20, "exports", {enumerable: true, get: function() {
      const e21 = new Map(), i2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = {open: `[${r3[0]}m`, close: `[${r3[1]}m`}, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, {value: n3, enumerable: false}), Object.defineProperty(i2, "codes", {value: e21, enumerable: false});
      }
      const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = {ansi: t2(u2, 0)}, i2.color.ansi256 = {ansi256: n2(u2, 0)}, i2.color.ansi16m = {rgb: r2(o2, 0)}, i2.bgColor.ansi = {ansi: t2(u2, 10)}, i2.bgColor.ansi256 = {ansi256: n2(u2, 10)}, i2.bgColor.ansi16m = {rgb: r2(o2, 10)};
      for (let e22 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e22] != "object")
          continue;
        const u3 = Ro$2[e22];
        e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
      }
      return i2;
    }});
  }), Fl = (e20, t2) => {
    t2 = t2 || xr$2.argv;
    const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
    return r2 !== -1 && (i2 === -1 || r2 < i2);
  };
  const Sl = xr$2.env;
  let xl;
  function wl(e20) {
    return function(e21) {
      return e21 !== 0 && {level: e21, hasBasic: true, has256: e21 >= 2, has16m: e21 >= 3};
    }(function(e21) {
      if (xl === false)
        return 0;
      if (Fl("color=16m") || Fl("color=full") || Fl("color=truecolor"))
        return 3;
      if (Fl("color=256"))
        return 2;
      if (e21 && !e21.isTTY && xl !== true)
        return 0;
      const t2 = xl ? 1 : 0;
      if (xr$2.platform === "win32") {
        const e22 = is$2.release().split(".");
        return Number(xr$2.versions.node.split(".")[0]) >= 8 && Number(e22[0]) >= 10 && Number(e22[2]) >= 10586 ? Number(e22[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in Sl)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in Sl) || Sl.CI_NAME === "codeship" ? 1 : t2;
      if ("TEAMCITY_VERSION" in Sl)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Sl.TEAMCITY_VERSION) ? 1 : 0;
      if (Sl.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in Sl) {
        const e22 = parseInt((Sl.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (Sl.TERM_PROGRAM) {
          case "iTerm.app":
            return e22 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(Sl.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Sl.TERM) || "COLORTERM" in Sl ? 1 : (Sl.TERM, t2);
    }(e20));
  }
  Fl("no-color") || Fl("no-colors") || Fl("color=false") ? xl = false : (Fl("color") || Fl("colors") || Fl("color=true") || Fl("color=always")) && (xl = true), "FORCE_COLOR" in Sl && (xl = Sl.FORCE_COLOR.length === 0 || parseInt(Sl.FORCE_COLOR, 10) !== 0);
  var Tl = {supportsColor: wl, stdout: wl(xr$2.stdout), stderr: wl(xr$2.stderr)};
  const Bl = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Nl = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, kl = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Pl = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ol = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function Il(e20) {
    return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : Ol.get(e20) || e20;
  }
  function Ll(e20, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let i2;
    for (const t3 of r2)
      if (isNaN(t3)) {
        if (!(i2 = t3.match(kl)))
          throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
        n2.push(i2[2].replace(Pl, (e21, t4, n3) => t4 ? Il(t4) : n3));
      } else
        n2.push(Number(t3));
    return n2;
  }
  function jl(e20) {
    Nl.lastIndex = 0;
    const t2 = [];
    let n2;
    for (; (n2 = Nl.exec(e20)) !== null; ) {
      const e21 = n2[1];
      if (n2[2]) {
        const r2 = Ll(e21, n2[2]);
        t2.push([e21].concat(r2));
      } else
        t2.push([e21]);
    }
    return t2;
  }
  function _l(e20, t2) {
    const n2 = {};
    for (const e21 of t2)
      for (const t3 of e21.styles)
        n2[t3[0]] = e21.inverse ? null : t3.slice(1);
    let r2 = e20;
    for (const e21 of Object.keys(n2))
      if (Array.isArray(n2[e21])) {
        if (!(e21 in r2))
          throw new Error(`Unknown Chalk style: ${e21}`);
        r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
      }
    return r2;
  }
  var Ml = (e20, t2) => {
    const n2 = [], r2 = [];
    let i2 = [];
    if (t2.replace(Bl, (t3, u2, o2, s2, a2, c2) => {
      if (u2)
        i2.push(Il(u2));
      else if (s2) {
        const t4 = i2.join("");
        i2 = [], r2.push(n2.length === 0 ? t4 : _l(e20, n2)(t4)), n2.push({inverse: o2, styles: jl(s2)});
      } else if (a2) {
        if (n2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        r2.push(_l(e20, n2)(i2.join(""))), i2 = [], n2.pop();
      } else
        i2.push(c2);
    }), r2.push(i2.join("")), n2.length > 0) {
      const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e21);
    }
    return r2.join("");
  }, Rl = r$3(function(e20) {
    const t2 = Tl.stdout, n2 = xr$2.platform === "win32" && !(xr$2.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
    function o2(e21, n3) {
      n3 = n3 || {};
      const r3 = t2 ? t2.level : 0;
      e21.level = n3.level === void 0 ? r3 : n3.level, e21.enabled = "enabled" in n3 ? n3.enabled : e21.level > 0;
    }
    function s2(e21) {
      if (!this || !(this instanceof s2) || this.template) {
        const t3 = {};
        return o2(t3, e21), t3.template = function() {
          const e22 = [].slice.call(arguments);
          return p2.apply(null, [t3.template].concat(e22));
        }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
      }
      o2(this, e21);
    }
    n2 && (vl.blue.open = "[94m");
    for (const e21 of Object.keys(vl))
      vl[e21].closeRe = new RegExp(Al(vl[e21].close), "g"), u2[e21] = {get() {
        const t3 = vl[e21];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
      }};
    u2.visible = {get() {
      return c2.call(this, this._styles || [], true, "visible");
    }}, vl.color.closeRe = new RegExp(Al(vl.color.close), "g");
    for (const e21 of Object.keys(vl.color.ansi))
      i2.has(e21) || (u2[e21] = {get() {
        const t3 = this.level;
        return function() {
          const n3 = vl.color[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: vl.color.close, closeRe: vl.color.closeRe};
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }});
    vl.bgColor.closeRe = new RegExp(Al(vl.bgColor.close), "g");
    for (const e21 of Object.keys(vl.bgColor.ansi)) {
      if (i2.has(e21))
        continue;
      u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {get() {
        const t3 = this.level;
        return function() {
          const n3 = vl.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {open: n3, close: vl.bgColor.close, closeRe: vl.bgColor.closeRe};
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }};
    }
    const a2 = Object.defineProperties(() => {
    }, u2);
    function c2(e21, t3, n3) {
      const r3 = function() {
        return l2.apply(r3, arguments);
      };
      r3._styles = e21, r3._empty = t3;
      const i3 = this;
      return Object.defineProperty(r3, "level", {enumerable: true, get: () => i3.level, set(e22) {
        i3.level = e22;
      }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => i3.enabled, set(e22) {
        i3.enabled = e22;
      }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
    }
    function l2() {
      const e21 = arguments, t3 = e21.length;
      let r3 = String(arguments[0]);
      if (t3 === 0)
        return "";
      if (t3 > 1)
        for (let n3 = 1; n3 < t3; n3++)
          r3 += " " + e21[n3];
      if (!this.enabled || this.level <= 0 || !r3)
        return this._empty ? "" : r3;
      const i3 = vl.dim.open;
      n2 && this.hasGrey && (vl.dim.open = "");
      for (const e22 of this._styles.slice().reverse())
        r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
      return vl.dim.open = i3, r3;
    }
    function p2(e21, t3) {
      if (!Array.isArray(t3))
        return [].slice.call(arguments, 1).join(" ");
      const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
      for (let e22 = 1; e22 < t3.length; e22++)
        r3.push(String(n3[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
      return Ml(e21, r3.join(""));
    }
    Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
  }), $l = Hl, Vl = Jl, Wl = function(e20, t2 = {}) {
    if (Hl(t2)) {
      const n2 = Jl(t2);
      return function(e21, t3) {
        let n3 = "";
        for (const {type: r2, value: i2} of Gl(t3)) {
          const t4 = e21[r2];
          n3 += t4 ? i2.split(Ul).map((e22) => t4(e22)).join("\n") : i2;
        }
        return n3;
      }(function(e21) {
        return {keyword: e21.cyan, capitalized: e21.yellow, jsxIdentifier: e21.yellow, punctuator: e21.yellow, number: e21.magenta, string: e21.green, regex: e21.magenta, comment: e21.grey, invalid: e21.white.bgRed.bold};
      }(n2), e20);
    }
    return e20;
  };
  const ql = new Set(["as", "async", "from", "get", "of", "set"]);
  const Ul = /\r\n|[\n\r\u2028\u2029]/, zl = /^[()[\]{}]$/;
  let Gl;
  {
    const e20 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
      if (t3.type === "name") {
        if ((0, Cl.isKeyword)(t3.value) || (0, Cl.isStrictReservedWord)(t3.value, true) || ql.has(t3.value))
          return "keyword";
        if (e20.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
          return "jsxIdentifier";
        if (t3.value[0] !== t3.value[0].toLowerCase())
          return "capitalized";
      }
      return t3.type === "punctuator" && zl.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
    };
    Gl = function* (e21) {
      let n2;
      for (; n2 = Gc.default.exec(e21); ) {
        const r2 = Gc.matchToToken(n2);
        yield {type: t2(r2, n2.index, e21), value: r2.value};
      }
    };
  }
  function Hl(e20) {
    return !!Rl.supportsColor || e20.forceColor;
  }
  function Jl(e20) {
    return e20.forceColor ? new Rl.constructor({enabled: true, level: 1}) : Rl;
  }
  var Xl = Object.defineProperty({shouldHighlight: $l, getChalk: Vl, default: Wl}, "__esModule", {value: true}), Yl = ep, Kl = function(e20, t2, n2, r2 = {}) {
    if (!Ql) {
      Ql = true;
      const e21 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (xr$2.emitWarning)
        xr$2.emitWarning(e21, "DeprecationWarning");
      else {
        new Error(e21).name = "DeprecationWarning", console.warn(new Error(e21));
      }
    }
    n2 = Math.max(n2, 0);
    return ep(e20, {start: {column: n2, line: t2}}, r2);
  };
  let Ql = false;
  const Zl = /\r\n|[\n\r\u2028\u2029]/;
  function ep(e20, t2, n2 = {}) {
    const r2 = (n2.highlightCode || n2.forceColor) && (0, Xl.shouldHighlight)(n2), i2 = (0, Xl.getChalk)(n2), u2 = function(e21) {
      return {gutter: e21.grey, marker: e21.red.bold, message: e21.red.bold};
    }(i2), o2 = (e21, t3) => r2 ? e21(t3) : t3, s2 = e20.split(Zl), {start: a2, end: c2, markerLines: l2} = function(e21, t3, n3) {
      const r3 = Object.assign({column: 0, line: -1}, e21.start), i3 = Object.assign({}, r3, e21.end), {linesAbove: u3 = 2, linesBelow: o3 = 3} = n3 || {}, s3 = r3.line, a3 = r3.column, c3 = i3.line, l3 = i3.column;
      let p3 = Math.max(s3 - (u3 + 1), 0), f3 = Math.min(t3.length, c3 + o3);
      s3 === -1 && (p3 = 0), c3 === -1 && (f3 = t3.length);
      const d3 = c3 - s3, h2 = {};
      if (d3)
        for (let e22 = 0; e22 <= d3; e22++) {
          const n4 = e22 + s3;
          if (a3)
            if (e22 === 0) {
              const e23 = t3[n4 - 1].length;
              h2[n4] = [a3, e23 - a3 + 1];
            } else if (e22 === d3)
              h2[n4] = [0, l3];
            else {
              const r4 = t3[n4 - e22].length;
              h2[n4] = [0, r4];
            }
          else
            h2[n4] = true;
        }
      else
        h2[s3] = a3 === l3 ? !a3 || [a3, 0] : [a3, l3 - a3];
      return {start: p3, end: f3, markerLines: h2};
    }(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length;
    let d2 = (r2 ? (0, Xl.default)(e20, n2) : e20).split(Zl).slice(a2, c2).map((e21, t3) => {
      const r3 = a2 + 1 + t3, i3 = ` ${` ${r3}`.slice(-f2)} |`, s3 = l2[r3], c3 = !l2[r3 + 1];
      if (s3) {
        let t4 = "";
        if (Array.isArray(s3)) {
          const r4 = e21.slice(0, Math.max(s3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = s3[1] || 1;
          t4 = ["\n ", o2(u2.gutter, i3.replace(/\d/g, " ")), " ", r4, o2(u2.marker, "^").repeat(a3)].join(""), c3 && n2.message && (t4 += " " + o2(u2.message, n2.message));
        }
        return [o2(u2.marker, ">"), o2(u2.gutter, i3), e21.length > 0 ? ` ${e21}` : "", t4].join("");
      }
      return ` ${o2(u2.gutter, i3)}${e21.length > 0 ? ` ${e21}` : ""}`;
    }).join("\n");
    return n2.message && !p2 && (d2 = `${" ".repeat(f2 + 1)}${n2.message}
${d2}`), r2 ? i2.reset(d2) : d2;
  }
  var tp = Object.defineProperty({codeFrameColumns: Yl, default: Kl}, "__esModule", {value: true}), np = n$3(mu$1);
  const {ConfigError: rp} = bo$2, {locStart: ip, locEnd: up} = zc, op = Object.getOwnPropertyNames, sp = Object.getOwnPropertyDescriptor;
  function ap(e20) {
    const t2 = {};
    for (const n2 of e20.plugins)
      if (n2.parsers)
        for (const e21 of op(n2.parsers))
          Object.defineProperty(t2, e21, sp(n2.parsers, e21));
    return t2;
  }
  function cp(e20, t2 = ap(e20)) {
    if (typeof e20.parser == "function")
      return {parse: e20.parser, astFormat: "estree", locStart: ip, locEnd: up};
    if (typeof e20.parser == "string") {
      if (Object.prototype.hasOwnProperty.call(t2, e20.parser))
        return t2[e20.parser];
      throw new rp(`Couldn't resolve parser "${e20.parser}". Parsers must be explicitly added to the standalone bundle.`);
    }
  }
  var lp = {parse: function(e20, t2) {
    const n2 = ap(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e21) => [e21, {enumerable: true, get: () => n2[e21].parse}]))), i2 = cp(t2, n2);
    try {
      return i2.preprocess && (e20 = i2.preprocess(e20, t2)), {text: e20, ast: i2.parse(e20, r2, t2)};
    } catch (t3) {
      const {loc: n3} = t3;
      if (n3) {
        const {codeFrameColumns: r3} = tp;
        throw t3.codeFrame = r3(e20, n3, {highlightCode: true}), t3.message += "\n" + t3.codeFrame, t3;
      }
      throw t3.stack;
    }
  }, resolveParser: cp};
  const {UndefinedParserError: pp} = bo$2, {getSupportInfo: fp} = Qr$2, {resolveParser: dp} = lp, hp = {astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null};
  function gp(e20, t2) {
    const n2 = np.basename(e20).toLowerCase(), r2 = fp({plugins: t2}).languages.filter((e21) => e21.since !== null);
    let i2 = r2.find((e21) => e21.extensions && e21.extensions.some((e22) => n2.endsWith(e22)) || e21.filenames && e21.filenames.some((e22) => e22.toLowerCase() === n2));
    if (!i2 && !n2.includes(".")) {
      const t3 = function(e21) {
        if (typeof e21 != "string")
          return "";
        let t4;
        try {
          t4 = go$2.openSync(e21, "r");
        } catch (e) {
          return "";
        }
        try {
          const e22 = new mo$2(t4).next().toString("utf8"), n3 = e22.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
          if (n3)
            return n3[1];
          const r3 = e22.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
          return r3 ? r3[1] : "";
        } catch (e) {
          return "";
        } finally {
          try {
            go$2.closeSync(t4);
          } catch (e) {
          }
        }
      }(e20);
      i2 = r2.find((e21) => e21.interpreters && e21.interpreters.includes(t3));
    }
    return i2 && i2.parsers[0];
  }
  var mp = {normalize: function(e20, t2 = {}) {
    const n2 = Object.assign({}, e20), r2 = fp({plugins: e20.plugins, showUnreleased: true, showDeprecated: true}).options, i2 = Object.assign(Object.assign({}, hp), Object.fromEntries(r2.filter((e21) => e21.default !== void 0).map((e21) => [e21.name, e21.default])));
    if (!n2.parser)
      if (n2.filepath) {
        if (n2.parser = gp(n2.filepath, n2.plugins), !n2.parser)
          throw new pp(`No parser could be inferred for file: ${n2.filepath}`);
      } else {
        (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
      }
    const u2 = dp($c.normalizeApiOptions(n2, [r2.find((e21) => e21.name === "parser")], {passThrough: true, logger: false}));
    n2.astFormat = u2.astFormat, n2.locEnd = u2.locEnd, n2.locStart = u2.locStart;
    const o2 = function(e21) {
      const {astFormat: t3} = e21;
      if (!t3)
        throw new Error("getPlugin() requires astFormat to be set");
      const n3 = e21.plugins.find((e22) => e22.printers && e22.printers[t3]);
      if (!n3)
        throw new Error(`Couldn't find plugin for AST format "${t3}"`);
      return n3;
    }(n2);
    n2.printer = o2.printers[n2.astFormat];
    const s2 = Object.fromEntries(r2.filter((e21) => e21.pluginDefaults && e21.pluginDefaults[o2.name] !== void 0).map((e21) => [e21.name, e21.pluginDefaults[o2.name]])), a2 = Object.assign(Object.assign({}, i2), s2);
    for (const [e21, t3] of Object.entries(a2))
      n2[e21] !== null && n2[e21] !== void 0 || (n2[e21] = t3);
    return n2.parser === "json" && (n2.trailingComma = "none"), $c.normalizeApiOptions(n2, r2, Object.assign({passThrough: Object.keys(hp)}, t2));
  }, hiddenDefaults: hp, inferParser: gp};
  var yp = function e(t2, n2, r2) {
    if (Array.isArray(t2))
      return t2.map((t3) => e(t3, n2, r2)).filter(Boolean);
    if (!t2 || typeof t2 != "object")
      return t2;
    const i2 = n2.printer.massageAstNode;
    let u2;
    u2 = i2 && i2.ignoredProperties ? i2.ignoredProperties : new Set();
    const o2 = {};
    for (const [r3, i3] of Object.entries(t2))
      u2.has(r3) || typeof i3 == "function" || (o2[r3] = e(i3, n2, t2));
    if (i2) {
      const e20 = i2(t2, o2, r2);
      if (e20 === null)
        return;
      if (e20)
        return e20;
    }
    return o2;
  }, Dp = typeof Object.create == "function" ? function(e20, t2) {
    e20.super_ = t2, e20.prototype = Object.create(t2.prototype, {constructor: {value: e20, enumerable: false, writable: true, configurable: true}});
  } : function(e20, t2) {
    e20.super_ = t2;
    var n2 = function() {
    };
    n2.prototype = t2.prototype, e20.prototype = new n2(), e20.prototype.constructor = e20;
  };
  function Ep(e20, t2) {
    var n2 = {seen: [], stylize: bp};
    return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Sp(t2) ? n2.showHidden = t2 : t2 && jp(n2, t2), Tp(n2.showHidden) && (n2.showHidden = false), Tp(n2.depth) && (n2.depth = 2), Tp(n2.colors) && (n2.colors = false), Tp(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Cp), Ap(n2, e20, n2.depth);
  }
  function Cp(e20, t2) {
    var n2 = Ep.styles[t2];
    return n2 ? "[" + Ep.colors[n2][0] + "m" + e20 + "[" + Ep.colors[n2][1] + "m" : e20;
  }
  function bp(e20, t2) {
    return e20;
  }
  function Ap(e20, t2, n2) {
    if (e20.customInspect && t2 && Op(t2.inspect) && t2.inspect !== Ep && (!t2.constructor || t2.constructor.prototype !== t2)) {
      var r2 = t2.inspect(n2, e20);
      return wp(r2) || (r2 = Ap(e20, r2, n2)), r2;
    }
    var i2 = function(e21, t3) {
      if (Tp(t3))
        return e21.stylize("undefined", "undefined");
      if (wp(t3)) {
        var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e21.stylize(n3, "string");
      }
      if (r3 = t3, typeof r3 == "number")
        return e21.stylize("" + t3, "number");
      var r3;
      if (Sp(t3))
        return e21.stylize("" + t3, "boolean");
      if (xp(t3))
        return e21.stylize("null", "null");
    }(e20, t2);
    if (i2)
      return i2;
    var u2 = Object.keys(t2), o2 = function(e21) {
      var t3 = {};
      return e21.forEach(function(e22, n3) {
        t3[e22] = true;
      }), t3;
    }(u2);
    if (e20.showHidden && (u2 = Object.getOwnPropertyNames(t2)), Pp(t2) && (u2.indexOf("message") >= 0 || u2.indexOf("description") >= 0))
      return vp(t2);
    if (u2.length === 0) {
      if (Op(t2)) {
        var s2 = t2.name ? ": " + t2.name : "";
        return e20.stylize("[Function" + s2 + "]", "special");
      }
      if (Bp(t2))
        return e20.stylize(RegExp.prototype.toString.call(t2), "regexp");
      if (kp(t2))
        return e20.stylize(Date.prototype.toString.call(t2), "date");
      if (Pp(t2))
        return vp(t2);
    }
    var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
    (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Op(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
    return Bp(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), kp(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), Pp(t2) && (l2 = " " + vp(t2)), u2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? Bp(t2) ? e20.stylize(RegExp.prototype.toString.call(t2), "regexp") : e20.stylize("[Object]", "special") : (e20.seen.push(t2), c2 = p2 ? function(e21, t3, n3, r3, i3) {
      for (var u3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
        _p(t3, String(o3)) ? u3.push(Fp(e21, t3, n3, r3, String(o3), true)) : u3.push("");
      return i3.forEach(function(i4) {
        i4.match(/^\d+$/) || u3.push(Fp(e21, t3, n3, r3, i4, true));
      }), u3;
    }(e20, t2, n2, o2, u2) : u2.map(function(r3) {
      return Fp(e20, t2, n2, o2, r3, p2);
    }), e20.seen.pop(), function(e21, t3, n3) {
      if (e21.reduce(function(e22, t4) {
        return t4.indexOf("\n"), e22 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e21.join(",\n  ") + " " + n3[1];
      return n3[0] + t3 + " " + e21.join(", ") + " " + n3[1];
    }(c2, l2, f2)) : f2[0] + l2 + f2[1];
  }
  function vp(e20) {
    return "[" + Error.prototype.toString.call(e20) + "]";
  }
  function Fp(e20, t2, n2, r2, i2, u2) {
    var o2, s2, a2;
    if ((a2 = Object.getOwnPropertyDescriptor(t2, i2) || {value: t2[i2]}).get ? s2 = a2.set ? e20.stylize("[Getter/Setter]", "special") : e20.stylize("[Getter]", "special") : a2.set && (s2 = e20.stylize("[Setter]", "special")), _p(r2, i2) || (o2 = "[" + i2 + "]"), s2 || (e20.seen.indexOf(a2.value) < 0 ? (s2 = xp(n2) ? Ap(e20, a2.value, null) : Ap(e20, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = u2 ? s2.split("\n").map(function(e21) {
      return "  " + e21;
    }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e21) {
      return "   " + e21;
    }).join("\n")) : s2 = e20.stylize("[Circular]", "special")), Tp(o2)) {
      if (u2 && i2.match(/^\d+$/))
        return s2;
      (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e20.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e20.stylize(o2, "string"));
    }
    return o2 + ": " + s2;
  }
  function Sp(e20) {
    return typeof e20 == "boolean";
  }
  function xp(e20) {
    return e20 === null;
  }
  function wp(e20) {
    return typeof e20 == "string";
  }
  function Tp(e20) {
    return e20 === void 0;
  }
  function Bp(e20) {
    return Np(e20) && Lp(e20) === "[object RegExp]";
  }
  function Np(e20) {
    return typeof e20 == "object" && e20 !== null;
  }
  function kp(e20) {
    return Np(e20) && Lp(e20) === "[object Date]";
  }
  function Pp(e20) {
    return Np(e20) && (Lp(e20) === "[object Error]" || e20 instanceof Error);
  }
  function Op(e20) {
    return typeof e20 == "function";
  }
  function Ip(e20) {
    return e20 === null || typeof e20 == "boolean" || typeof e20 == "number" || typeof e20 == "string" || typeof e20 == "symbol" || e20 === void 0;
  }
  function Lp(e20) {
    return Object.prototype.toString.call(e20);
  }
  function jp(e20, t2) {
    if (!t2 || !Np(t2))
      return e20;
    for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
      e20[n2[r2]] = t2[n2[r2]];
    return e20;
  }
  function _p(e20, t2) {
    return Object.prototype.hasOwnProperty.call(e20, t2);
  }
  function Mp(e20, t2) {
    if (e20 === t2)
      return 0;
    for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
      if (e20[i2] !== t2[i2]) {
        n2 = e20[i2], r2 = t2[i2];
        break;
      }
    return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
  }
  Ep.colors = {bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39]}, Ep.styles = {special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red"};
  var Rp, $p = Object.prototype.hasOwnProperty, Vp = Object.keys || function(e20) {
    var t2 = [];
    for (var n2 in e20)
      $p.call(e20, n2) && t2.push(n2);
    return t2;
  }, Wp = Array.prototype.slice;
  function qp() {
    return Rp !== void 0 ? Rp : Rp = function() {
    }.name === "foo";
  }
  function Up(e20) {
    return Object.prototype.toString.call(e20);
  }
  function zp(e20) {
    return !fo$2(e20) && (typeof nr$2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e20) : !!e20 && (e20 instanceof DataView || !!(e20.buffer && e20.buffer instanceof ArrayBuffer))));
  }
  function Gp(e20, t2) {
    e20 || Qp(e20, true, t2, "==", Zp);
  }
  var Hp = /\s*function\s+([^\(\s]*)\s*/;
  function Jp(e20) {
    if (Op(e20)) {
      if (qp())
        return e20.name;
      var t2 = e20.toString().match(Hp);
      return t2 && t2[1];
    }
  }
  function Xp(e20) {
    this.name = "AssertionError", this.actual = e20.actual, this.expected = e20.expected, this.operator = e20.operator, e20.message ? (this.message = e20.message, this.generatedMessage = false) : (this.message = function(e21) {
      return Yp(Kp(e21.actual), 128) + " " + e21.operator + " " + Yp(Kp(e21.expected), 128);
    }(this), this.generatedMessage = true);
    var t2 = e20.stackStartFunction || Qp;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, t2);
    else {
      var n2 = new Error();
      if (n2.stack) {
        var r2 = n2.stack, i2 = Jp(t2), u2 = r2.indexOf("\n" + i2);
        if (u2 >= 0) {
          var o2 = r2.indexOf("\n", u2 + 1);
          r2 = r2.substring(o2 + 1);
        }
        this.stack = r2;
      }
    }
  }
  function Yp(e20, t2) {
    return typeof e20 == "string" ? e20.length < t2 ? e20 : e20.slice(0, t2) : e20;
  }
  function Kp(e20) {
    if (qp() || !Op(e20))
      return Ep(e20);
    var t2 = Jp(e20);
    return "[Function" + (t2 ? ": " + t2 : "") + "]";
  }
  function Qp(e20, t2, n2, r2, i2) {
    throw new Xp({message: n2, actual: e20, expected: t2, operator: r2, stackStartFunction: i2});
  }
  function Zp(e20, t2) {
    e20 || Qp(e20, true, t2, "==", Zp);
  }
  function ef(e20, t2, n2) {
    e20 != t2 && Qp(e20, t2, n2, "==", ef);
  }
  function tf(e20, t2, n2) {
    e20 == t2 && Qp(e20, t2, n2, "!=", tf);
  }
  function nf(e20, t2, n2) {
    uf(e20, t2, false) || Qp(e20, t2, n2, "deepEqual", nf);
  }
  function rf(e20, t2, n2) {
    uf(e20, t2, true) || Qp(e20, t2, n2, "deepStrictEqual", rf);
  }
  function uf(e20, t2, n2, r2) {
    if (e20 === t2)
      return true;
    if (fo$2(e20) && fo$2(t2))
      return Mp(e20, t2) === 0;
    if (kp(e20) && kp(t2))
      return e20.getTime() === t2.getTime();
    if (Bp(e20) && Bp(t2))
      return e20.source === t2.source && e20.global === t2.global && e20.multiline === t2.multiline && e20.lastIndex === t2.lastIndex && e20.ignoreCase === t2.ignoreCase;
    if (e20 !== null && typeof e20 == "object" || t2 !== null && typeof t2 == "object") {
      if (zp(e20) && zp(t2) && Up(e20) === Up(t2) && !(e20 instanceof Float32Array || e20 instanceof Float64Array))
        return Mp(new Uint8Array(e20.buffer), new Uint8Array(t2.buffer)) === 0;
      if (fo$2(e20) !== fo$2(t2))
        return false;
      var i2 = (r2 = r2 || {actual: [], expected: []}).actual.indexOf(e20);
      return i2 !== -1 && i2 === r2.expected.indexOf(t2) || (r2.actual.push(e20), r2.expected.push(t2), function(e21, t3, n3, r3) {
        if (e21 == null || t3 == null)
          return false;
        if (Ip(e21) || Ip(t3))
          return e21 === t3;
        if (n3 && Object.getPrototypeOf(e21) !== Object.getPrototypeOf(t3))
          return false;
        var i3 = of(e21), u2 = of(t3);
        if (i3 && !u2 || !i3 && u2)
          return false;
        if (i3)
          return uf(e21 = Wp.call(e21), t3 = Wp.call(t3), n3);
        var o2, s2, a2 = Vp(e21), c2 = Vp(t3);
        if (a2.length !== c2.length)
          return false;
        for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
          if (a2[s2] !== c2[s2])
            return false;
        for (s2 = a2.length - 1; s2 >= 0; s2--)
          if (!uf(e21[o2 = a2[s2]], t3[o2], n3, r3))
            return false;
        return true;
      }(e20, t2, n2, r2));
    }
    return n2 ? e20 === t2 : e20 == t2;
  }
  function of(e20) {
    return Object.prototype.toString.call(e20) == "[object Arguments]";
  }
  function sf(e20, t2, n2) {
    uf(e20, t2, false) && Qp(e20, t2, n2, "notDeepEqual", sf);
  }
  function af(e20, t2, n2) {
    uf(e20, t2, true) && Qp(e20, t2, n2, "notDeepStrictEqual", af);
  }
  function cf(e20, t2, n2) {
    e20 !== t2 && Qp(e20, t2, n2, "===", cf);
  }
  function lf(e20, t2, n2) {
    e20 === t2 && Qp(e20, t2, n2, "!==", lf);
  }
  function pf(e20, t2) {
    if (!e20 || !t2)
      return false;
    if (Object.prototype.toString.call(t2) == "[object RegExp]")
      return t2.test(e20);
    try {
      if (e20 instanceof t2)
        return true;
    } catch (e21) {
    }
    return !Error.isPrototypeOf(t2) && t2.call({}, e20) === true;
  }
  function ff(e20, t2, n2, r2) {
    var i2;
    if (typeof t2 != "function")
      throw new TypeError('"block" argument must be a function');
    typeof n2 == "string" && (r2 = n2, n2 = null), i2 = function(e21) {
      var t3;
      try {
        e21();
      } catch (e22) {
        t3 = e22;
      }
      return t3;
    }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e20 && !i2 && Qp(i2, n2, "Missing expected exception" + r2);
    var u2 = typeof r2 == "string", o2 = !e20 && i2 && !n2;
    if ((!e20 && Pp(i2) && u2 && pf(i2, n2) || o2) && Qp(i2, n2, "Got unwanted exception" + r2), e20 && i2 && n2 && !pf(i2, n2) || !e20 && i2)
      throw i2;
  }
  function df(e20, t2, n2) {
    ff(true, e20, t2, n2);
  }
  function hf(e20, t2, n2) {
    ff(false, e20, t2, n2);
  }
  function gf(e20) {
    if (e20)
      throw e20;
  }
  Gp.AssertionError = Xp, Dp(Xp, Error), Gp.fail = Qp, Gp.ok = Zp, Gp.equal = ef, Gp.notEqual = tf, Gp.deepEqual = nf, Gp.deepStrictEqual = rf, Gp.notDeepEqual = sf, Gp.notDeepStrictEqual = af, Gp.strictEqual = cf, Gp.notStrictEqual = lf, Gp.throws = df, Gp.doesNotThrow = hf, Gp.ifError = gf;
  var mf = n$3(Object.freeze({__proto__: null, default: Gp, AssertionError: Xp, fail: Qp, ok: Zp, assert: Zp, equal: ef, notEqual: tf, deepEqual: nf, deepStrictEqual: rf, notDeepEqual: sf, notDeepStrictEqual: af, strictEqual: cf, notStrictEqual: lf, throws: df, doesNotThrow: hf, ifError: gf}));
  const {builders: {line: yf, hardline: Df, breakParent: Ef, indent: Cf, lineSuffix: bf, join: Af, cursor: vf}} = eu$1, {hasNewline: Ff, skipNewline: Sf, skipSpaces: xf, isPreviousLineEmpty: wf, addLeadingComment: Tf, addDanglingComment: Bf, addTrailingComment: Nf} = yi$2, kf = new WeakMap();
  function Pf(e20, t2, n2) {
    if (!e20)
      return;
    const {printer: r2, locStart: i2, locEnd: u2} = t2;
    if (n2) {
      if (r2.canAttachComment && r2.canAttachComment(e20)) {
        let t3;
        for (t3 = n2.length - 1; t3 >= 0 && !(i2(n2[t3]) <= i2(e20) && u2(n2[t3]) <= u2(e20)); --t3)
          ;
        return void n2.splice(t3 + 1, 0, e20);
      }
    } else if (kf.has(e20))
      return kf.get(e20);
    const o2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e20, t2) || typeof e20 == "object" && Object.entries(e20).filter(([e21]) => e21 !== "enclosingNode" && e21 !== "precedingNode" && e21 !== "followingNode" && e21 !== "tokens" && e21 !== "comments").map(([, e21]) => e21);
    if (o2) {
      n2 || (n2 = [], kf.set(e20, n2));
      for (const e21 of o2)
        Pf(e21, t2, n2);
      return n2;
    }
  }
  function Of(e20, t2, n2, r2) {
    const {locStart: i2, locEnd: u2} = n2, o2 = i2(t2), s2 = u2(t2), a2 = Pf(e20, n2);
    let c2, l2, p2 = 0, f2 = a2.length;
    for (; p2 < f2; ) {
      const e21 = p2 + f2 >> 1, r3 = a2[e21], d2 = i2(r3), h2 = u2(r3);
      if (d2 <= o2 && s2 <= h2)
        return Of(r3, t2, n2, r3);
      if (h2 <= o2)
        c2 = r3, p2 = e21 + 1;
      else {
        if (!(s2 <= d2))
          throw new Error("Comment location overlaps with node location");
        l2 = r3, f2 = e21;
      }
    }
    if (r2 && r2.type === "TemplateLiteral") {
      const {quasis: e21} = r2, i3 = $f(e21, t2, n2);
      c2 && $f(e21, c2, n2) !== i3 && (c2 = null), l2 && $f(e21, l2, n2) !== i3 && (l2 = null);
    }
    return {enclosingNode: r2, precedingNode: c2, followingNode: l2};
  }
  const If = () => false;
  const Lf = (e20) => !/[\S\n\u2028\u2029]/.test(e20);
  function jf(e20, t2, n2, r2) {
    const {comment: i2, precedingNode: u2} = n2[r2], {locStart: o2, locEnd: s2} = t2;
    let a2 = o2(i2);
    if (u2)
      for (let t3 = r2 - 1; t3 >= 0; t3--) {
        const {comment: r3, precedingNode: i3} = n2[t3];
        if (i3 !== u2 || !Lf(e20.slice(s2(r3), a2)))
          break;
        a2 = o2(r3);
      }
    return Ff(e20, a2, {backwards: true});
  }
  function _f$2(e20, t2, n2, r2) {
    const {comment: i2, followingNode: u2} = n2[r2], {locStart: o2, locEnd: s2} = t2;
    let a2 = s2(i2);
    if (u2)
      for (let t3 = r2 + 1; t3 < n2.length; t3++) {
        const {comment: r3, followingNode: i3} = n2[t3];
        if (i3 !== u2 || !Lf(e20.slice(a2, o2(r3))))
          break;
        a2 = s2(r3);
      }
    return Ff(e20, a2);
  }
  function Mf(e20, t2, n2) {
    const r2 = e20.length;
    if (r2 === 0)
      return;
    const {precedingNode: i2, followingNode: u2, enclosingNode: o2} = e20[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(o2) || /^[\s(]*$/;
    let a2, c2 = n2.locStart(u2);
    for (a2 = r2; a2 > 0; --a2) {
      const {comment: r3, precedingNode: o3, followingNode: l2} = e20[a2 - 1];
      mf.strictEqual(o3, i2), mf.strictEqual(l2, u2);
      const p2 = t2.slice(n2.locEnd(r3), c2);
      if (!s2.test(p2))
        break;
      c2 = n2.locStart(r3);
    }
    for (const [t3, {comment: n3}] of e20.entries())
      t3 < a2 ? Nf(i2, n3) : Tf(u2, n3);
    for (const e21 of [i2, u2])
      e21.comments && e21.comments.length > 1 && e21.comments.sort((e22, t3) => n2.locStart(e22) - n2.locStart(t3));
    e20.length = 0;
  }
  function Rf(e20, t2) {
    return e20.getValue().printed = true, t2.printer.printComment(e20, t2);
  }
  function $f(e20, t2, n2) {
    const r2 = n2.locStart(t2) - 1;
    for (let t3 = 1; t3 < e20.length; ++t3)
      if (r2 < n2.locStart(e20[t3]))
        return t3 - 1;
    return 0;
  }
  function Vf(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return {};
    let i2 = r2.comments || [];
    n2 && (i2 = i2.filter((e21) => !n2.has(e21)));
    const u2 = r2 === t2.cursorNode;
    if (i2.length === 0) {
      const e21 = u2 ? vf : "";
      return {leading: e21, trailing: e21};
    }
    const o2 = [], s2 = [];
    return e20.each(() => {
      const r3 = e20.getValue();
      if (n2 && n2.has(r3))
        return;
      const {leading: i3, trailing: u3} = r3;
      i3 ? o2.push(function(e21, t3) {
        const n3 = e21.getValue(), r4 = [Rf(e21, t3)], {printer: i4, originalText: u4, locStart: o3, locEnd: s3} = t3;
        if (i4.isBlockComment && i4.isBlockComment(n3)) {
          const e22 = Ff(u4, s3(n3)) ? Ff(u4, o3(n3), {backwards: true}) ? Df : yf : " ";
          r4.push(e22);
        } else
          r4.push(Df);
        const a2 = Sf(u4, xf(u4, s3(n3)));
        return a2 !== false && Ff(u4, a2) && r4.push(Df), r4;
      }(e20, t2)) : u3 && s2.push(function(e21, t3) {
        const n3 = e21.getValue(), r4 = Rf(e21, t3), {printer: i4, originalText: u4, locStart: o3} = t3, s3 = i4.isBlockComment && i4.isBlockComment(n3);
        if (Ff(u4, o3(n3), {backwards: true})) {
          const e22 = wf(u4, n3, o3);
          return bf([Df, e22 ? Df : "", r4]);
        }
        let a2 = [" ", r4];
        return s3 || (a2 = [bf(a2), Ef]), a2;
      }(e20, t2));
    }, "comments"), u2 && (o2.unshift(vf), s2.push(vf)), {leading: o2, trailing: s2};
  }
  var Wf = {attach: function(e20, t2, n2, r2) {
    if (!Array.isArray(e20))
      return;
    const i2 = [], {locStart: u2, locEnd: o2, printer: {handleComments: s2 = {}}} = r2, {avoidAstMutation: a2, ownLine: c2 = If, endOfLine: l2 = If, remaining: p2 = If} = s2, f2 = e20.map((i3, u3) => Object.assign(Object.assign({}, Of(t2, i3, r2)), {}, {comment: i3, text: n2, options: r2, ast: t2, isLastComment: e20.length - 1 === u3}));
    for (const [e21, t3] of f2.entries()) {
      const {comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2} = t3;
      if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
        if (u2(n3) - u2(m2) <= 0) {
          Tf(m2, n3);
          continue;
        }
        if (o2(n3) - o2(m2) >= 0) {
          Nf(m2, n3);
          continue;
        }
      }
      let D2;
      if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), jf(h2, g2, f2, e21))
        n3.placement = "ownLine", c2(...D2) || (d2 ? Tf(d2, n3) : r3 ? Nf(r3, n3) : Bf(s3 || m2, n3));
      else if (_f$2(h2, g2, f2, e21))
        n3.placement = "endOfLine", l2(...D2) || (r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3));
      else if (n3.placement = "remaining", p2(...D2))
        ;
      else if (r3 && d2) {
        const e22 = i2.length;
        if (e22 > 0) {
          i2[e22 - 1].followingNode !== d2 && Mf(i2, h2, g2);
        }
        i2.push(t3);
      } else
        r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3);
    }
    if (Mf(i2, n2, r2), !a2)
      for (const t3 of e20)
        delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
  }, printComments: function(e20, t2, n2, r2) {
    const {leading: i2, trailing: u2} = Vf(e20, n2, r2);
    return i2 || u2 ? [i2, t2, u2] : t2;
  }, printCommentsSeparately: Vf, printDanglingComments: function(e20, t2, n2, r2) {
    const i2 = [], u2 = e20.getValue();
    return u2 && u2.comments ? (e20.each(() => {
      const n3 = e20.getValue();
      n3.leading || n3.trailing || r2 && !r2(n3) || i2.push(Rf(e20, t2));
    }, "comments"), i2.length === 0 ? "" : n2 ? Af(Df, i2) : Cf([Df, Af(Df, i2)])) : "";
  }, getSortedChildNodes: Pf, ensureAllCommentsPrinted: function(e20) {
    if (e20)
      for (const t2 of e20) {
        if (!t2.printed)
          throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
        delete t2.printed;
      }
  }};
  function qf(e20, t2) {
    const n2 = Uf(e20.stack, t2);
    return n2 === -1 ? null : e20.stack[n2];
  }
  function Uf(e20, t2) {
    for (let n2 = e20.length - 1; n2 >= 0; n2 -= 2) {
      const r2 = e20[n2];
      if (r2 && !Array.isArray(r2) && --t2 < 0)
        return n2;
    }
    return -1;
  }
  var zf = class {
    constructor(e20) {
      this.stack = [e20];
    }
    getName() {
      const {stack: e20} = this, {length: t2} = e20;
      return t2 > 1 ? e20[t2 - 2] : null;
    }
    getValue() {
      return Ln$2(this.stack);
    }
    getNode(e20 = 0) {
      return qf(this, e20);
    }
    getParentNode(e20 = 0) {
      return qf(this, e20 + 1);
    }
    call(e20, ...t2) {
      const {stack: n2} = this, {length: r2} = n2;
      let i2 = Ln$2(n2);
      for (const e21 of t2)
        i2 = i2[e21], n2.push(e21, i2);
      const u2 = e20(this);
      return n2.length = r2, u2;
    }
    callParent(e20, t2 = 0) {
      const n2 = Uf(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), i2 = e20(this);
      return this.stack.push(...r2), i2;
    }
    each(e20, ...t2) {
      const {stack: n2} = this, {length: r2} = n2;
      let i2 = Ln$2(n2);
      for (const e21 of t2)
        i2 = i2[e21], n2.push(e21, i2);
      for (let t3 = 0; t3 < i2.length; ++t3)
        n2.push(t3, i2[t3]), e20(this, t3, i2), n2.length -= 2;
      n2.length = r2;
    }
    map(e20, ...t2) {
      const n2 = [];
      return this.each((t3, r2, i2) => {
        n2[r2] = e20(t3, r2, i2);
      }, ...t2), n2;
    }
    try(e20) {
      const {stack: t2} = this, n2 = [...t2];
      try {
        return e20();
      } finally {
        t2.length = 0, t2.push(...n2);
      }
    }
    match(...e20) {
      let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
      for (const i2 of e20) {
        if (r2 === void 0)
          return false;
        let e21 = null;
        if (typeof n2 == "number" && (e21 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), i2 && !i2(r2, n2, e21))
          return false;
        n2 = this.stack[t2--], r2 = this.stack[t2--];
      }
      return true;
    }
    findAncestor(e20) {
      let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
      for (; r2; ) {
        let i2 = null;
        if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e20(r2, n2, i2))
          return r2;
        n2 = this.stack[t2--], r2 = this.stack[t2--];
      }
    }
  };
  const {utils: {stripTrailingHardline: Gf}} = eu$1, {normalize: Hf} = mp;
  var Jf = {printSubtree: function(e20, t2, n2, r2) {
    if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
      return n2.printer.embed(e20, t2, (e21, t3, i2) => function(e22, t4, n3, r3, {stripTrailingHardline: i3 = false} = {}) {
        const u2 = Hf(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, {parentParser: n3.parser, originalText: e22}), {passThrough: true}), o2 = lp.parse(e22, u2), {ast: s2} = o2;
        e22 = o2.text;
        const a2 = s2.comments;
        delete s2.comments, Wf.attach(a2, s2, e22, u2), u2[Symbol.for("comments")] = a2 || [], u2[Symbol.for("tokens")] = s2.tokens || [];
        const c2 = r3(s2, u2);
        if (Wf.ensureAllCommentsPrinted(a2), i3)
          return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : Gf(c2);
        return c2;
      }(e21, t3, n2, r2, i2), n2);
  }};
  const {builders: {hardline: Xf, addAlignmentToDoc: Yf}, utils: {propagateBreaks: Kf}} = eu$1, {printComments: Qf} = Wf;
  function Zf(e20, n2, r2 = 0) {
    const {printer: i2} = n2;
    i2.preprocess && (e20 = i2.preprocess(e20, n2));
    const u2 = new Map(), o2 = new zf(e20);
    let s2 = a2();
    return r2 > 0 && (s2 = Yf([Xf, s2], r2, n2.tabWidth)), Kf(s2), s2;
    function a2(e21, t2) {
      return e21 === void 0 || e21 === o2 ? c2(t2) : Array.isArray(e21) ? o2.call(() => c2(t2), ...e21) : o2.call(() => c2(t2), e21);
    }
    function c2(e21) {
      const r3 = o2.getValue(), i3 = r3 && typeof r3 == "object" && e21 === void 0;
      if (i3 && u2.has(r3))
        return u2.get(r3);
      const s3 = function(e22, n3, r4, i4) {
        const u3 = e22.getValue(), {printer: o3} = n3;
        let s4, a3;
        if (o3.hasPrettierIgnore && o3.hasPrettierIgnore(e22))
          ({doc: s4, printedComments: a3} = function(e23, t2) {
            const {originalText: n4, [Symbol.for("comments")]: r5, locStart: i5, locEnd: u4} = t2, o4 = i5(e23), s5 = u4(e23), a4 = new Set();
            for (const e24 of r5)
              i5(e24) >= o4 && u4(e24) <= s5 && (e24.printed = true, a4.add(e24));
            return {doc: n4.slice(o4, s5), printedComments: a4};
          }(u3, n3));
        else {
          if (u3)
            try {
              s4 = Jf.printSubtree(e22, r4, n3, Zf);
            } catch (e23) {
              if (t$3.PRETTIER_DEBUG)
                throw e23;
            }
          s4 || (s4 = o3.print(e22, n3, r4, i4));
        }
        o3.willPrintOwnComments && o3.willPrintOwnComments(e22, n3) || (s4 = Qf(e22, s4, n3, a3));
        return s4;
      }(o2, n2, a2, e21);
      return i3 && u2.set(r3, s3), s3;
    }
  }
  var ed = Zf;
  function td(e20) {
    let t2 = e20.length - 1;
    for (; ; ) {
      const n2 = e20[t2];
      if (!n2 || n2.type !== "Program" && n2.type !== "File")
        break;
      t2--;
    }
    return e20.slice(0, t2 + 1);
  }
  function nd(e20, t2, n2, r2, i2 = [], u2) {
    const {locStart: o2, locEnd: s2} = n2, a2 = o2(e20), c2 = s2(e20);
    if (!(t2 > c2 || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === c2)) {
      for (const o3 of Wf.getSortedChildNodes(e20, n2)) {
        const s3 = nd(o3, t2, n2, r2, [e20, ...i2], u2);
        if (s3)
          return s3;
      }
      return !r2 || r2(e20, i2[0]) ? {node: e20, parentNodes: i2} : void 0;
    }
  }
  const rd = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), id = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  function ud(e20, t2, n2) {
    if (!t2)
      return false;
    switch (e20.parser) {
      case "flow":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "espree":
      case "meriyah":
      case "__babel_estree":
        return function(e21, t3) {
          return t3 !== "DeclareExportDeclaration" && e21 !== "TypeParameterDeclaration" && (e21 === "Directive" || e21 === "TypeAlias" || e21 === "TSExportAssignment" || e21.startsWith("Declare") || e21.startsWith("TSDeclare") || e21.endsWith("Statement") || e21.endsWith("Declaration"));
        }(t2.type, n2 && n2.type);
      case "json":
      case "json5":
      case "json-stringify":
        return rd.has(t2.type);
      case "graphql":
        return id.has(t2.kind);
      case "vue":
        return t2.tag !== "root";
    }
    return false;
  }
  var od = {calculateRange: function(e20, t2, n2) {
    let {rangeStart: r2, rangeEnd: i2, locStart: u2, locEnd: o2} = t2;
    mf.ok(i2 > r2);
    const s2 = e20.slice(r2, i2).search(/\S/), a2 = s2 === -1;
    if (!a2)
      for (r2 += s2; i2 > r2 && !/\S/.test(e20[i2 - 1]); --i2)
        ;
    const c2 = nd(n2, r2, t2, (e21, n3) => ud(t2, e21, n3), [], "rangeStart"), l2 = a2 ? c2 : nd(n2, i2, t2, (e21) => ud(t2, e21), [], "rangeEnd");
    if (!c2 || !l2)
      return {rangeStart: 0, rangeEnd: 0};
    let p2, f2;
    if ((({parser: e21}) => e21 === "json" || e21 === "json5" || e21 === "json-stringify")(t2)) {
      const e21 = function(e22, t3) {
        const n3 = [e22.node, ...e22.parentNodes], r3 = new Set([t3.node, ...t3.parentNodes]);
        return n3.find((e23) => rd.has(e23.type) && r3.has(e23));
      }(c2, l2);
      p2 = e21, f2 = e21;
    } else
      ({startNode: p2, endNode: f2} = function(e21, t3, {locStart: n3, locEnd: r3}) {
        let i3 = e21.node, u3 = t3.node;
        if (i3 === u3)
          return {startNode: i3, endNode: u3};
        const o3 = n3(e21.node);
        for (const e22 of td(t3.parentNodes)) {
          if (!(n3(e22) >= o3))
            break;
          u3 = e22;
        }
        const s3 = r3(t3.node);
        for (const t4 of td(e21.parentNodes)) {
          if (!(r3(t4) <= s3))
            break;
          i3 = t4;
        }
        return {startNode: i3, endNode: u3};
      }(c2, l2, t2));
    return {rangeStart: Math.min(u2(p2), u2(f2)), rangeEnd: Math.max(o2(p2), o2(f2))};
  }, findNodeAtOffset: nd};
  const {printer: {printDocToString: sd}, debug: {printDocToDebug: ad}} = eu$1, {getAlignmentSize: cd} = yi$2, {guessEndOfLine: ld, convertEndOfLineToChars: pd, countEndOfLineChars: fd, normalizeEndOfLine: dd} = Di$2, hd = mp.normalize, gd = Symbol("cursor");
  function md(e20, t2, n2) {
    const r2 = t2.comments;
    return r2 && (delete t2.comments, Wf.attach(r2, t2, e20, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e20, r2;
  }
  function yd(e20, t2, n2 = 0) {
    if (!e20 || e20.trim().length === 0)
      return {formatted: "", cursorOffset: -1, comments: []};
    const {ast: r2, text: i2} = lp.parse(e20, t2);
    if (t2.cursorOffset >= 0) {
      const e21 = od.findNodeAtOffset(r2, t2.cursorOffset, t2);
      e21 && e21.node && (t2.cursorNode = e21.node);
    }
    const u2 = md(i2, r2, t2), o2 = ed(r2, t2, n2), s2 = sd(o2, t2);
    if (Wf.ensureAllCommentsPrinted(u2), n2 > 0) {
      const e21 = s2.formatted.trim();
      s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e21)), s2.formatted = e21 + pd(t2.endOfLine);
    }
    if (t2.cursorOffset >= 0) {
      let e21, n3, r3, o3, a2;
      if (t2.cursorNode && s2.cursorNodeText ? (e21 = t2.locStart(t2.cursorNode), n3 = i2.slice(e21, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e21, o3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e21 = 0, n3 = i2, r3 = t2.cursorOffset, o3 = 0, a2 = s2.formatted), n3 === a2)
        return {formatted: s2.formatted, cursorOffset: o3 + r3, comments: u2};
      const c2 = [...n3];
      c2.splice(r3, 0, gd);
      const l2 = [...a2], p2 = mn$2.diffArrays(c2, l2);
      let f2 = o3;
      for (const e22 of p2)
        if (e22.removed) {
          if (e22.value.includes(gd))
            break;
        } else
          f2 += e22.count;
      return {formatted: s2.formatted, cursorOffset: f2, comments: u2};
    }
    return {formatted: s2.formatted, cursorOffset: -1, comments: u2};
  }
  function Dd(e20, t2, n2) {
    return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e20.length ? n2 : t2;
  }
  function Ed(e20, t2) {
    let {cursorOffset: n2, rangeStart: r2, rangeEnd: i2} = t2;
    return n2 = Dd(e20, n2, -1), r2 = Dd(e20, r2, 0), i2 = Dd(e20, i2, e20.length), Object.assign(Object.assign({}, t2), {}, {cursorOffset: n2, rangeStart: r2, rangeEnd: i2});
  }
  function Cd(e20, t2) {
    let {cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2} = Ed(e20, t2);
    const o2 = e20.charAt(0) === "\uFEFF";
    if (o2 && (e20 = e20.slice(1), n2--, r2--, i2--), u2 === "auto" && (u2 = ld(e20)), e20.includes("\r")) {
      const t3 = (t4) => fd(e20.slice(0, Math.max(t4, 0)), "\r\n");
      n2 -= t3(n2), r2 -= t3(r2), i2 -= t3(i2), e20 = dd(e20);
    }
    return {hasBOM: o2, text: e20, options: Ed(e20, Object.assign(Object.assign({}, t2), {}, {cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2}))};
  }
  function bd(e20, t2) {
    const n2 = lp.resolveParser(t2);
    return !n2.hasPragma || n2.hasPragma(e20);
  }
  function Ad(e20, t2) {
    let n2, {hasBOM: r2, text: i2, options: u2} = Cd(e20, hd(t2));
    return u2.rangeStart >= u2.rangeEnd && i2 !== "" || u2.requirePragma && !bd(i2, u2) ? {formatted: e20, cursorOffset: t2.cursorOffset, comments: []} : (u2.rangeStart > 0 || u2.rangeEnd < i2.length ? n2 = function(e21, t3) {
      const {ast: n3, text: r3} = lp.parse(e21, t3), {rangeStart: i3, rangeEnd: u3} = od.calculateRange(r3, t3, n3), o2 = r3.slice(i3, u3), s2 = Math.min(i3, r3.lastIndexOf("\n", i3) + 1), a2 = r3.slice(s2, i3).match(/^\s*/)[0], c2 = cd(a2, t3.tabWidth), l2 = yd(o2, Object.assign(Object.assign({}, t3), {}, {rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t3.cursorOffset > i3 && t3.cursorOffset <= u3 ? t3.cursorOffset - i3 : -1, endOfLine: "lf"}), c2), p2 = l2.formatted.trimEnd();
      let {cursorOffset: f2} = t3;
      f2 > u3 ? f2 += p2.length - o2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + i3);
      let d2 = r3.slice(0, i3) + p2 + r3.slice(u3);
      if (t3.endOfLine !== "lf") {
        const e22 = pd(t3.endOfLine);
        f2 >= 0 && e22 === "\r\n" && (f2 += fd(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e22);
      }
      return {formatted: d2, cursorOffset: f2, comments: l2.comments};
    }(i2, u2) : (!u2.requirePragma && u2.insertPragma && u2.printer.insertPragma && !bd(i2, u2) && (i2 = u2.printer.insertPragma(i2)), n2 = yd(i2, u2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
  }
  var vd = {formatWithCursor: Ad, parse(e20, t2, n2) {
    const {text: r2, options: i2} = Cd(e20, hd(t2)), u2 = lp.parse(r2, i2);
    return n2 && (u2.ast = yp(u2.ast, i2)), u2;
  }, formatAST(e20, t2) {
    t2 = hd(t2);
    const n2 = ed(e20, t2);
    return sd(n2, t2);
  }, formatDoc: (e20, t2) => Ad(ad(e20), Object.assign(Object.assign({}, t2), {}, {parser: "__js_expression"})).formatted, printToDoc(e20, t2) {
    t2 = hd(t2);
    const {ast: n2, text: r2} = lp.parse(e20, t2);
    return md(r2, n2, t2), ed(n2, t2);
  }, printDocToString: (e20, t2) => sd(e20, hd(t2))};
  const {getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d$2, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd} = yi$2;
  var Hd = {getMaxContinuousCount: Fd, getStringWidth: Sd, getAlignmentSize: xd, getIndentSize: wd, skip: Td, skipWhitespace: Bd, skipSpaces: Nd, skipNewline: kd, skipToLineEnd: Pd, skipEverythingButNewLine: Od, skipInlineComment: Id, skipTrailingComment: Ld, hasNewline: jd, hasNewlineInRange: _d$2, hasSpaces: Md, isNextLineEmpty: Rd, isNextLineEmptyAfterIndex: $d, isPreviousLineEmpty: Vd, getNextNonSpaceNonCommentCharacterIndex: Wd, makeString: qd, addLeadingComment: Ud, addDanglingComment: zd, addTrailingComment: Gd};
  const Jd = ["languageId"];
  var Xd = function(e20, t2) {
    const {languageId: n2} = e20, r2 = jn$2(e20, Jd);
    return Object.assign(Object.assign({linguistLanguageId: n2}, r2), t2(e20));
  }, Yd = r$3(function(e20) {
    !function() {
      function t2(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function n2(e21) {
        switch (e21.type) {
          case "IfStatement":
            return e21.alternate != null ? e21.alternate : e21.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return e21.body;
        }
        return null;
      }
      e20.exports = {isExpression: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }, isStatement: t2, isIterationStatement: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }, isSourceElement: function(e21) {
        return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
      }, isProblematicIfStatement: function(e21) {
        var t3;
        if (e21.type !== "IfStatement")
          return false;
        if (e21.alternate == null)
          return false;
        t3 = e21.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = n2(t3);
        } while (t3);
        return false;
      }, trailingStatement: n2};
    }();
  }), Kd = r$3(function(e20) {
    !function() {
      var t2, n2, r2, i2, u2, o2;
      function s2(e21) {
        return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
      }
      for (n2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/}, t2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), o2 = 0; o2 < 128; ++o2)
        i2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 === 36 || o2 === 95;
      for (u2 = new Array(128), o2 = 0; o2 < 128; ++o2)
        u2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 >= 48 && o2 <= 57 || o2 === 36 || o2 === 95;
      e20.exports = {isDecimalDigit: function(e21) {
        return 48 <= e21 && e21 <= 57;
      }, isHexDigit: function(e21) {
        return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
      }, isOctalDigit: function(e21) {
        return e21 >= 48 && e21 <= 55;
      }, isWhiteSpace: function(e21) {
        return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
      }, isLineTerminator: function(e21) {
        return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
      }, isIdentifierStartES5: function(e21) {
        return e21 < 128 ? i2[e21] : n2.NonAsciiIdentifierStart.test(s2(e21));
      }, isIdentifierPartES5: function(e21) {
        return e21 < 128 ? u2[e21] : n2.NonAsciiIdentifierPart.test(s2(e21));
      }, isIdentifierStartES6: function(e21) {
        return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(s2(e21));
      }, isIdentifierPartES6: function(e21) {
        return e21 < 128 ? u2[e21] : t2.NonAsciiIdentifierPart.test(s2(e21));
      }};
    }();
  }), Qd = r$3(function(e20) {
    !function() {
      var t2 = Kd;
      function n2(e21, t3) {
        return !(!t3 && e21 === "yield") && r2(e21, t3);
      }
      function r2(e21, t3) {
        if (t3 && function(e22) {
          switch (e22) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "let":
              return true;
            default:
              return false;
          }
        }(e21))
          return true;
        switch (e21.length) {
          case 2:
            return e21 === "if" || e21 === "in" || e21 === "do";
          case 3:
            return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
          case 4:
            return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
          case 5:
            return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
          case 6:
            return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
          case 7:
            return e21 === "default" || e21 === "finally" || e21 === "extends";
          case 8:
            return e21 === "function" || e21 === "continue" || e21 === "debugger";
          case 10:
            return e21 === "instanceof";
          default:
            return false;
        }
      }
      function i2(e21, t3) {
        return e21 === "null" || e21 === "true" || e21 === "false" || n2(e21, t3);
      }
      function u2(e21, t3) {
        return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
      }
      function o2(e21) {
        var n3, r3, i3;
        if (e21.length === 0)
          return false;
        if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
          return false;
        for (n3 = 1, r3 = e21.length; n3 < r3; ++n3)
          if (i3 = e21.charCodeAt(n3), !t2.isIdentifierPartES5(i3))
            return false;
        return true;
      }
      function s2(e21) {
        var n3, r3, i3, u3, o3;
        if (e21.length === 0)
          return false;
        for (o3 = t2.isIdentifierStartES6, n3 = 0, r3 = e21.length; n3 < r3; ++n3) {
          if (55296 <= (i3 = e21.charCodeAt(n3)) && i3 <= 56319) {
            if (++n3 >= r3)
              return false;
            if (!(56320 <= (u3 = e21.charCodeAt(n3)) && u3 <= 57343))
              return false;
            i3 = 1024 * (i3 - 55296) + (u3 - 56320) + 65536;
          }
          if (!o3(i3))
            return false;
          o3 = t2.isIdentifierPartES6;
        }
        return true;
      }
      e20.exports = {isKeywordES5: n2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: u2, isRestrictedWord: function(e21) {
        return e21 === "eval" || e21 === "arguments";
      }, isIdentifierNameES5: o2, isIdentifierNameES6: s2, isIdentifierES5: function(e21, t3) {
        return o2(e21) && !i2(e21, t3);
      }, isIdentifierES6: function(e21, t3) {
        return s2(e21) && !u2(e21, t3);
      }};
    }();
  });
  const Zd = r$3(function(e20, t2) {
    t2.ast = Yd, t2.code = Kd, t2.keyword = Qd;
  }).keyword.isIdentifierNameES5, {getLast: eh, hasNewline: th, skipWhitespace: nh, isNonEmptyArray: rh, isNextLineEmptyAfterIndex: ih, getStringWidth: uh} = yi$2, {locStart: oh, locEnd: sh, hasSameLocStart: ah} = zc, ch = new RegExp("^(?:(?=.)\\s)*:"), lh = new RegExp("^(?:(?=.)\\s)*::");
  function ph(e20) {
    return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
  }
  function fh(e20) {
    return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
  }
  const dh = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function hh(e20) {
    return e20 && dh.has(e20.type);
  }
  function gh(e20) {
    return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
  }
  function mh(e20) {
    return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
  }
  function yh(e20) {
    return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
  }
  function Dh(e20) {
    return Sh(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
  }
  function Eh(e20) {
    return e20.type === "JSXElement" || e20.type === "JSXFragment";
  }
  function Ch(e20) {
    return e20.kind === "get" || e20.kind === "set";
  }
  function bh(e20) {
    return Ch(e20) || ah(e20, e20.value);
  }
  const Ah = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  const vh = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  const Fh = /^(?:skip|[fx]?(?:it|describe|test))$/;
  function Sh(e20) {
    return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
  }
  function xh(e20) {
    return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
  }
  function wh(e20) {
    return /^(?:\d+|\d+\.\d+)$/.test(e20);
  }
  function Th(e20) {
    return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
  }
  function Bh(e20) {
    return e20.extra ? e20.extra.raw : e20.raw;
  }
  const Nh = {"==": true, "!=": true, "===": true, "!==": true}, kh = {"*": true, "/": true, "%": true}, Ph = {">>": true, ">>>": true, "<<": true};
  const Oh = {};
  for (const [e20, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
    for (const n2 of t2)
      Oh[n2] = e20;
  function Ih(e20) {
    return Oh[e20];
  }
  const Lh = new WeakMap();
  function jh(e20) {
    if (Lh.has(e20))
      return Lh.get(e20);
    const t2 = [];
    return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Lh.set(e20, t2), t2;
  }
  const _h = new WeakMap();
  function Mh(e20) {
    if (_h.has(e20))
      return _h.get(e20);
    let t2 = e20.arguments;
    return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), _h.set(e20, t2), t2;
  }
  function Rh(e20) {
    return e20.value.trim() === "prettier-ignore" && !e20.unignore;
  }
  function $h(e20) {
    return e20 && (e20.prettierIgnore || qh(e20, Vh.PrettierIgnore));
  }
  const Vh = {Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256}, Wh = (e20, t2) => {
    if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
      return (n2, r2, i2) => !(e20 & Vh.Leading && !n2.leading || e20 & Vh.Trailing && !n2.trailing || e20 & Vh.Dangling && (n2.leading || n2.trailing) || e20 & Vh.Block && !ph(n2) || e20 & Vh.Line && !fh(n2) || e20 & Vh.First && r2 !== 0 || e20 & Vh.Last && r2 !== i2.length - 1 || e20 & Vh.PrettierIgnore && !Rh(n2) || t2 && !t2(n2));
  };
  function qh(e20, t2, n2) {
    if (!e20 || !rh(e20.comments))
      return false;
    const r2 = Wh(t2, n2);
    return !r2 || e20.comments.some(r2);
  }
  function Uh(e20, t2, n2) {
    if (!e20 || !Array.isArray(e20.comments))
      return [];
    const r2 = Wh(t2, n2);
    return r2 ? e20.comments.filter(r2) : e20.comments;
  }
  function zh(e20) {
    return Sh(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
  }
  var Gh = {getFunctionParameters: jh, iterateFunctionParametersPath: function(e20, t2) {
    const n2 = e20.getValue();
    let r2 = 0;
    const i2 = (e21) => t2(e21, r2++);
    n2.this && e20.call(i2, "this"), Array.isArray(n2.parameters) ? e20.each(i2, "parameters") : Array.isArray(n2.params) && e20.each(i2, "params"), n2.rest && e20.call(i2, "rest");
  }, getCallArguments: Mh, iterateCallArgumentsPath: function(e20, t2) {
    const n2 = e20.getValue();
    n2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), n2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
  }, hasRestParameter: function(e20) {
    if (e20.rest)
      return true;
    const t2 = jh(e20);
    return t2.length > 0 && eh(t2).type === "RestElement";
  }, getLeftSide: function(e20) {
    return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
  }, getLeftSidePathName: function(e20, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }, getParentExportDeclaration: function(e20) {
    const t2 = e20.getParentNode();
    return e20.getName() === "declaration" && hh(t2) ? t2 : null;
  }, getTypeScriptMappedTypeModifier: function(e20, t2) {
    return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
  }, hasFlowAnnotationComment: function(e20) {
    return rh(e20) && ph(e20[0]) && lh.test(e20[0].value);
  }, hasFlowShorthandAnnotationComment: function(e20) {
    return e20.extra && e20.extra.parenthesized && rh(e20.trailingComments) && ph(e20.trailingComments[0]) && ch.test(e20.trailingComments[0].value);
  }, hasLeadingOwnLineComment: function(e20, t2) {
    return Eh(t2) ? $h(t2) : qh(t2, Vh.Leading, (t3) => th(e20, sh(t3)));
  }, hasNakedLeftSide: function(e20) {
    return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Sh(e20) || xh(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
  }, hasNode: function e2(t2, n2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e2(t3, n2));
    const r2 = n2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, n2));
  }, hasIgnoreComment: function(e20) {
    return $h(e20.getValue());
  }, hasNodeIgnoreComment: $h, identity: function(e20) {
    return e20;
  }, isBinaryish: function(e20) {
    return Ah.has(e20.type);
  }, isBlockComment: ph, isCallLikeExpression: zh, isLineComment: fh, isPrettierIgnoreComment: Rh, isCallExpression: Sh, isMemberExpression: xh, isExportDeclaration: hh, isFlowAnnotationComment: function(e20, t2) {
    const n2 = oh(t2), r2 = nh(e20, sh(t2));
    return r2 !== false && e20.slice(n2, n2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
  }, isFunctionCompositionArgs: function(e20) {
    if (e20.length <= 1)
      return false;
    let t2 = 0;
    for (const n2 of e20)
      if (yh(n2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Sh(n2)) {
        for (const e21 of n2.arguments)
          if (yh(e21))
            return true;
      }
    return false;
  }, isFunctionNotation: bh, isFunctionOrArrowExpression: yh, isGetterOrSetter: Ch, isJestEachTemplateLiteral: function(e20, t2) {
    const n2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
  }, isJsxNode: Eh, isLiteral: function(e20) {
    return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
  }, isLongCurriedCallExpression: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    return Sh(t2) && Sh(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
  }, isSimpleCallArgument: function e3(t2, n2) {
    if (n2 >= 2)
      return false;
    const r2 = (t3) => e3(t3, n2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && uh(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : zh(t2) ? (t2.type === "ImportExpression" || e3(t2.callee, n2)) && Mh(t2).every(r2) : xh(t2) ? e3(t2.object, n2) && e3(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e3(t2.expression, n2) : e3(t2.argument, n2)));
  }, isMemberish: function(e20) {
    return xh(e20) || e20.type === "BindExpression" && Boolean(e20.object);
  }, isNumericLiteral: gh, isSignedNumericLiteral: function(e20) {
    return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && gh(e20.argument);
  }, isObjectProperty: function(e20) {
    return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
  }, isObjectType: function(e20) {
    return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
  }, isObjectTypePropertyAFunction: function(e20) {
    return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || bh(e20));
  }, isSimpleType: function(e20) {
    return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!vh.has(e20.type));
  }, isSimpleNumber: wh, isSimpleTemplateLiteral: function(e20) {
    let t2 = "expressions";
    e20.type === "TSTemplateLiteralType" && (t2 = "types");
    const n2 = e20[t2];
    return n2.length !== 0 && n2.every((e21) => {
      if (qh(e21))
        return false;
      if (e21.type === "Identifier" || e21.type === "ThisExpression")
        return true;
      if (xh(e21)) {
        let t3 = e21;
        for (; xh(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, qh(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  }, isStringLiteral: mh, isStringPropSafeToUnquote: function(e20, t2) {
    return t2.parser !== "json" && mh(e20.key) && Bh(e20.key).slice(1, -1) === e20.key.value && (Zd(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || wh(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  }, isTemplateOnItsOwnLine: function(e20, t2) {
    return (e20.type === "TemplateLiteral" && Th(e20) || e20.type === "TaggedTemplateExpression" && Th(e20.quasi)) && !th(t2, oh(e20), {backwards: true});
  }, isTestCall: function e4(t2, n2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Dh(t2) && n2 && e4(n2))
        return yh(t2.arguments[0]);
      if (function(e20) {
        return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
      }(t2))
        return Dh(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Fh.test(t2.callee.name) || function(e20) {
      return xh(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Fh.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
    }(t2)) && (function(e20) {
      return e20.type === "TemplateLiteral";
    }(t2.arguments[0]) || mh(t2.arguments[0])))
      return !(t2.arguments[2] && !gh(t2.arguments[2])) && ((t2.arguments.length === 2 ? yh(t2.arguments[1]) : function(e20) {
        return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
      }(t2.arguments[1]) && jh(t2.arguments[1]).length <= 1) || Dh(t2.arguments[1]));
    return false;
  }, isTheOnlyJsxElementInMarkdown: function(e20, t2) {
    if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
      return false;
    const n2 = t2.getNode();
    if (!n2.expression || !Eh(n2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  }, isTSXFile: function(e20) {
    return e20.filepath && /\.tsx$/i.test(e20.filepath);
  }, isTypeAnnotationAFunction: function(e20) {
    return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || ah(e20, e20.typeAnnotation));
  }, isNextLineEmpty: (e20, {originalText: t2}) => ih(t2, sh(e20)), needsHardlineAfterDanglingComment: function(e20) {
    if (!qh(e20))
      return false;
    const t2 = eh(Uh(e20, Vh.Dangling));
    return t2 && !ph(t2);
  }, rawText: Bh, shouldPrintComma: function(e20, t2 = "es5") {
    return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  }, isBitwiseOperator: function(e20) {
    return Boolean(Ph[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
  }, shouldFlatten: function(e20, t2) {
    return Ih(t2) === Ih(e20) && (e20 !== "**" && ((!Nh[e20] || !Nh[t2]) && (!(t2 === "%" && kh[e20] || e20 === "%" && kh[t2]) && ((t2 === e20 || !kh[t2] || !kh[e20]) && (!Ph[e20] || !Ph[t2])))));
  }, startsWithNoLookaheadToken: function e5(t2, n2) {
    switch ((t2 = function(e20) {
      for (; e20.left; )
        e20 = e20.left;
      return e20;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return n2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e5(t2.object, n2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e5(t2.tag, n2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e5(t2.callee, n2);
      case "ConditionalExpression":
        return e5(t2.test, n2);
      case "UpdateExpression":
        return !t2.prefix && e5(t2.argument, n2);
      case "BindExpression":
        return t2.object && e5(t2.object, n2);
      case "SequenceExpression":
        return e5(t2.expressions[0], n2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e5(t2.expression, n2);
      default:
        return false;
    }
  }, getPrecedence: Ih, hasComment: qh, getComments: Uh, CommentCheckFlags: Vh};
  const {getStringWidth: Hh, getIndentSize: Jh} = yi$2, {builders: {join: Xh, hardline: Yh, softline: Kh, group: Qh, indent: Zh, align: eg, lineSuffixBoundary: tg, addAlignmentToDoc: ng}, printer: {printDocToString: rg}, utils: {mapDoc: ig}} = eu$1, {isBinaryish: ug, isJestEachTemplateLiteral: og, isSimpleTemplateLiteral: sg, hasComment: ag, isMemberExpression: cg} = Gh;
  function lg(e20) {
    return e20.replace(/([\\`]|\${)/g, "\\$1");
  }
  var pg = {printTemplateLiteral: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type === "TemplateLiteral" && og(r2, e20.getParentNode())) {
      const r3 = function(e21, t3, n3) {
        const r4 = e21.getNode(), i3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
        if (i3.length > 1 || i3.some((e22) => e22.length > 0)) {
          t3.__inJestEach = true;
          const u3 = e21.map(n3, "expressions");
          t3.__inJestEach = false;
          const o3 = [], s3 = u3.map((e22) => "${" + rg(e22, Object.assign(Object.assign({}, t3), {}, {printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf"})).formatted + "}"), a2 = [{hasLineBreak: false, cells: []}];
          for (let e22 = 1; e22 < r4.quasis.length; e22++) {
            const t4 = Ln$2(a2), n4 = s3[e22 - 1];
            t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e22].value.raw.includes("\n") && a2.push({hasLineBreak: false, cells: []});
          }
          const c2 = Math.max(i3.length, ...a2.map((e22) => e22.cells.length)), l2 = Array.from({length: c2}).fill(0), p2 = [{cells: i3}, ...a2.filter((e22) => e22.cells.length > 0)];
          for (const {cells: e22} of p2.filter((e23) => !e23.hasLineBreak))
            for (const [t4, n4] of e22.entries())
              l2[t4] = Math.max(l2[t4], Hh(n4));
          return o3.push(tg, "`", Zh([Yh, Xh(Yh, p2.map((e22) => Xh(" | ", e22.cells.map((t4, n4) => e22.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - Hh(t4))))))]), Yh, "`"), o3;
        }
      }(e20, n2, t2);
      if (r3)
        return r3;
    }
    let i2 = "expressions";
    r2.type === "TSTemplateLiteralType" && (i2 = "types");
    const u2 = [];
    let o2 = e20.map(t2, i2);
    const s2 = sg(r2);
    return s2 && (o2 = o2.map((e21) => rg(e21, Object.assign(Object.assign({}, n2), {}, {printWidth: Number.POSITIVE_INFINITY})).formatted)), u2.push(tg, "`"), e20.each((e21) => {
      const a2 = e21.getName();
      if (u2.push(t2()), a2 < o2.length) {
        const {tabWidth: t3} = n2, c2 = e21.getValue(), l2 = Jh(c2.value.raw, t3);
        let p2 = o2[a2];
        if (!s2) {
          const e22 = r2[i2][a2];
          (ag(e22) || cg(e22) || e22.type === "ConditionalExpression" || e22.type === "SequenceExpression" || e22.type === "TSAsExpression" || ug(e22)) && (p2 = [Zh([Kh, p2]), Kh]);
        }
        const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? eg(Number.NEGATIVE_INFINITY, p2) : ng(p2, l2, t3);
        u2.push(Qh(["${", f2, tg, "}"]));
      }
    }, "quasis"), u2.push("`"), u2;
  }, printTemplateExpressions: function(e20, t2) {
    return e20.map((e21) => function(e22, t3) {
      const n2 = e22.getValue();
      let r2 = t3();
      return ag(n2) && (r2 = Qh([Zh([Kh, r2]), Kh])), ["${", r2, tg, "}"];
    }(e21, t2), "expressions");
  }, escapeTemplateCharacters: function(e20, t2) {
    return ig(e20, (e21) => typeof e21 == "string" ? t2 ? e21.replace(/(\\*)`/g, "$1$1\\`") : lg(e21) : e21);
  }, uncookTemplateElementValue: lg};
  const {builders: {indent: fg, softline: dg, literalline: hg, dedentToRoot: gg}} = eu$1, {escapeTemplateCharacters: mg} = pg;
  var yg = function(e20, t2, n2) {
    let r2 = e20.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e21, t3) => "\\".repeat(t3.length / 2) + "`");
    const i2 = function(e21) {
      const t3 = e21.match(/^([^\S\n]*)\S/m);
      return t3 === null ? "" : t3[1];
    }(r2), u2 = i2 !== "";
    u2 && (r2 = r2.replace(new RegExp(`^${i2}`, "gm"), ""));
    const o2 = mg(n2(r2, {parser: "markdown", __inJsTemplate: true}, {stripTrailingHardline: true}), true);
    return ["`", u2 ? fg([dg, o2]) : [hg, gg(o2)], dg, "`"];
  };
  const {isNonEmptyArray: Dg} = yi$2, {builders: {indent: Eg, hardline: Cg, softline: bg}, utils: {mapDoc: Ag, replaceEndOfLine: vg, cleanDoc: Fg}} = eu$1, {printTemplateExpressions: Sg} = pg;
  var xg = function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.quasis.map((e21) => e21.value.raw);
    let u2 = 0;
    return function(e21, t3, n3) {
      if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
        return "``";
      const r3 = function(e22, t4) {
        if (!Dg(t4))
          return e22;
        let n4 = 0;
        const r4 = Ag(Fg(e22), (e23) => typeof e23 == "string" && e23.includes("@prettier-placeholder") ? e23.split(/@prettier-placeholder-(\d+)-id/).map((e24, r5) => r5 % 2 == 0 ? vg(e24) : (n4++, t4[e24])) : e23);
        return t4.length === n4 ? r4 : null;
      }(e21, n3);
      if (!r3)
        throw new Error("Couldn't insert all the expressions");
      return ["`", Eg([Cg, r3]), bg, "`"];
    }(n2(i2.reduce((e21, t3, n3) => n3 === 0 ? t3 : e21 + "@prettier-placeholder-" + u2++ + "-id" + t3, ""), {parser: "scss"}, {stripTrailingHardline: true}), r2, Sg(e20, t2));
  };
  const {builders: {indent: wg, join: Tg, hardline: Bg}} = eu$1, {escapeTemplateCharacters: Ng, printTemplateExpressions: kg} = pg;
  function Pg(e20) {
    const t2 = [];
    let n2 = false;
    const r2 = e20.map((e21) => e21.trim());
    for (const [e21, i2] of r2.entries())
      i2 !== "" && (r2[e21 - 1] === "" && n2 ? t2.push([Bg, i2]) : t2.push(i2), n2 = true);
    return t2.length === 0 ? null : Tg(Bg, t2);
  }
  var Og = function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.quasis.length;
    if (i2 === 1 && r2.quasis[0].value.raw.trim() === "")
      return "``";
    const u2 = kg(e20, t2), o2 = [];
    for (let e21 = 0; e21 < i2; e21++) {
      const t3 = e21 === 0, s2 = e21 === i2 - 1, a2 = r2.quasis[e21].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = u2[e21], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e22) => /^\s*(?:#[^\n\r]*)?$/.test(e22));
      if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
        return null;
      let g2 = null;
      g2 = h2 ? Pg(c2) : n2(a2, {parser: "graphql"}, {stripTrailingHardline: true}), g2 ? (g2 = Ng(g2, false), !t3 && f2 && o2.push(""), o2.push(g2), !s2 && d2 && o2.push("")) : t3 || s2 || !f2 || o2.push(""), p2 && o2.push(p2);
    }
    return ["`", wg([Bg, Tg(Bg, o2)]), Bg, "`"];
  };
  const {builders: {indent: Ig, line: Lg, hardline: jg, group: _g}, utils: {mapDoc: Mg}} = eu$1, {printTemplateExpressions: Rg, uncookTemplateElementValue: $g} = pg;
  let Vg = 0;
  var Wg = function(e20, t2, n2, r2, {parser: i2}) {
    const u2 = e20.getValue(), o2 = Vg;
    Vg = Vg + 1 >>> 0;
    const s2 = (e21) => `PRETTIER_HTML_PLACEHOLDER_${e21}_${o2}_IN_JS`, a2 = u2.quasis.map((e21, t3, n3) => t3 === n3.length - 1 ? e21.value.cooked : e21.value.cooked + s2(t3)).join(""), c2 = Rg(e20, t2);
    if (c2.length === 0 && a2.trim().length === 0)
      return "``";
    const l2 = new RegExp(s2("(\\d+)"), "g");
    let p2 = 0;
    const f2 = n2(a2, {parser: i2, __onHtmlRoot(e21) {
      p2 = e21.children.length;
    }}, {stripTrailingHardline: true}), d2 = Mg(f2, (e21) => {
      if (typeof e21 != "string")
        return e21;
      const t3 = [], n3 = e21.split(l2);
      for (let e22 = 0; e22 < n3.length; e22++) {
        let i3 = n3[e22];
        if (e22 % 2 == 0) {
          i3 && (i3 = $g(i3), r2.__embeddedInHtml && (i3 = i3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(i3));
          continue;
        }
        const u3 = Number(i3);
        t3.push(c2[u3]);
      }
      return t3;
    }), h2 = /^\s/.test(a2) ? " " : "", g2 = /\s$/.test(a2) ? " " : "", m2 = r2.htmlWhitespaceSensitivity === "ignore" ? jg : h2 && g2 ? Lg : null;
    return _g(m2 ? ["`", Ig([m2, _g(d2)]), m2, "`"] : ["`", h2, p2 > 1 ? Ig(_g(d2)) : _g(d2), g2, "`"]);
  };
  const {hasComment: qg, CommentCheckFlags: Ug, isObjectProperty: zg} = Gh;
  function Gg(e20) {
    return function(e21) {
      const t2 = e21.getValue(), n2 = e21.getParentNode(), r2 = e21.getParentNode(1);
      return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e22) => e22.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
    }(e20) || function(e21) {
      const t2 = e21.getParentNode();
      if (!t2 || t2.type !== "TaggedTemplateExpression")
        return false;
      const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
      switch (n2.type) {
        case "MemberExpression":
          return Jg(n2.object) || Xg(n2);
        case "CallExpression":
          return Jg(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (Jg(n2.callee.object.object) || Xg(n2.callee.object)) || n2.callee.object.type === "CallExpression" && Jg(n2.callee.object.callee));
        case "Identifier":
          return n2.name === "css";
        default:
          return false;
      }
    }(e20) || function(e21) {
      const t2 = e21.getParentNode(), n2 = e21.getParentNode(1);
      return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
    }(e20) || function(e21) {
      return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "ArrayExpression" && t2 === "elements", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "styles" && t2 === "value", ...Hg);
    }(e20) ? "css" : function(e21) {
      const t2 = e21.getValue(), n2 = e21.getParentNode();
      return Yg(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
    }(e20) ? "graphql" : function(e21) {
      return Yg(e21.getValue(), "HTML") || e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "TaggedTemplateExpression" && e22.tag.type === "Identifier" && e22.tag.name === "html" && t2 === "quasi");
    }(e20) ? "html" : function(e21) {
      return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "template" && t2 === "value", ...Hg);
    }(e20) ? "angular" : function(e21) {
      const t2 = e21.getValue(), n2 = e21.getParentNode();
      return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
    }(e20) ? "markdown" : void 0;
  }
  const Hg = [(e20, t2) => e20.type === "ObjectExpression" && t2 === "properties", (e20, t2) => e20.type === "CallExpression" && e20.callee.type === "Identifier" && e20.callee.name === "Component" && t2 === "arguments", (e20, t2) => e20.type === "Decorator" && t2 === "expression"];
  function Jg(e20) {
    return e20.type === "Identifier" && e20.name === "styled";
  }
  function Xg(e20) {
    return /^[A-Z]/.test(e20.object.name) && e20.property.name === "extend";
  }
  function Yg(e20, t2) {
    return qg(e20, Ug.Block | Ug.Leading, ({value: e21}) => e21 === ` ${t2} `);
  }
  var Kg = function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    if (i2.type !== "TemplateLiteral" || function({quasis: e21}) {
      return e21.some(({value: {cooked: e22}}) => e22 === null);
    }(i2))
      return;
    const u2 = Gg(e20);
    return u2 ? u2 === "markdown" ? yg(e20, t2, n2) : u2 === "css" ? xg(e20, t2, n2) : u2 === "graphql" ? Og(e20, t2, n2) : u2 === "html" || u2 === "angular" ? Wg(e20, t2, n2, r2, {parser: u2}) : void 0 : void 0;
  };
  const {isBlockComment: Qg} = Gh, Zg = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), em = (e20) => {
    for (const t2 of e20.quasis)
      delete t2.value;
  };
  function tm(e20, t2, n2) {
    if (e20.type === "Program" && delete t2.sourceType, e20.type !== "BigIntLiteral" && e20.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e20.type !== "BigIntLiteral" && e20.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e20.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e20.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e20.type === "EmptyStatement")
      return null;
    if (e20.type === "JSXText")
      return null;
    if (e20.type === "JSXExpressionContainer" && (e20.expression.type === "Literal" || e20.expression.type === "StringLiteral") && e20.expression.value === " ")
      return null;
    if (e20.type !== "Property" && e20.type !== "ObjectProperty" && e20.type !== "MethodDefinition" && e20.type !== "ClassProperty" && e20.type !== "ClassMethod" && e20.type !== "PropertyDefinition" && e20.type !== "TSDeclareMethod" && e20.type !== "TSPropertySignature" && e20.type !== "ObjectTypeProperty" || typeof e20.key != "object" || !e20.key || e20.key.type !== "Literal" && e20.key.type !== "NumericLiteral" && e20.key.type !== "StringLiteral" && e20.key.type !== "Identifier" || delete t2.key, e20.type === "JSXElement" && e20.openingElement.name.name === "style" && e20.openingElement.attributes.some((e21) => e21.name.name === "jsx"))
      for (const {type: e21, expression: n3} of t2.children)
        e21 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && em(n3);
    e20.type === "JSXAttribute" && e20.name.name === "css" && e20.value.type === "JSXExpressionContainer" && e20.value.expression.type === "TemplateLiteral" && em(t2.value.expression), e20.type === "JSXAttribute" && e20.value && e20.value.type === "Literal" && /["']|&quot;|&apos;/.test(e20.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    const r2 = e20.expression || e20.callee;
    if (e20.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
      const n3 = e20.expression.arguments[0].properties;
      for (const [e21, r3] of t2.expression.arguments[0].properties.entries())
        switch (n3[e21].key.name) {
          case "styles":
            r3.value.type === "ArrayExpression" && em(r3.value.elements[0]);
            break;
          case "template":
            r3.value.type === "TemplateLiteral" && em(r3.value);
        }
    }
    if (e20.type !== "TaggedTemplateExpression" || e20.tag.type !== "MemberExpression" && (e20.tag.type !== "Identifier" || e20.tag.name !== "gql" && e20.tag.name !== "graphql" && e20.tag.name !== "css" && e20.tag.name !== "md" && e20.tag.name !== "markdown" && e20.tag.name !== "html") && e20.tag.type !== "CallExpression" || em(t2.quasi), e20.type === "TemplateLiteral") {
      (e20.leadingComments && e20.leadingComments.some((e21) => Qg(e21) && ["GraphQL", "HTML"].some((t3) => e21.value === ` ${t3} `)) || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e20.leadingComments) && em(t2);
    }
    return e20.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e20.type !== "TSIntersectionType" && e20.type !== "TSUnionType" || e20.types.length !== 1 ? void 0 : t2.types[0];
  }
  tm.ignoredProperties = Zg;
  var nm = tm;
  const rm = (e20) => {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    const t2 = e20.match(/(?:\r?\n)/g) || [];
    if (t2.length === 0)
      return;
    const n2 = t2.filter((e21) => e21 === "\r\n").length;
    return n2 > t2.length - n2 ? "\r\n" : "\n";
  };
  var im = rm;
  im.graceful = (e20) => typeof e20 == "string" && rm(e20) || "\n";
  var um = function(e20) {
    const t2 = e20.match(hm);
    return t2 ? t2[0].trimLeft() : "";
  }, om = function(e20) {
    const t2 = e20.match(hm);
    return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
  }, sm = function(e20) {
    return bm(e20).pragmas;
  }, am = bm, cm = function({comments: e20 = "", pragmas: t2 = {}}) {
    const n2 = (0, pm().default)(e20) || lm().EOL, r2 = " *", i2 = Object.keys(t2), u2 = i2.map((e21) => Am(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + n2).join("");
    if (!e20) {
      if (i2.length === 0)
        return "";
      if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
        const e21 = t2[i2[0]];
        return `/** ${Am(i2[0], e21)[0]} */`;
      }
    }
    const o2 = e20.split(n2).map((e21) => ` * ${e21}`).join(n2) + n2;
    return "/**" + n2 + (e20 ? o2 : "") + (e20 && i2.length ? r2 + n2 : "") + u2 + " */";
  };
  function lm() {
    const e20 = is$2;
    return lm = function() {
      return e20;
    }, e20;
  }
  function pm() {
    const e20 = function(e21) {
      return e21 && e21.__esModule ? e21 : {default: e21};
    }(im);
    return pm = function() {
      return e20;
    }, e20;
  }
  const fm = /\*\/$/, dm = /^\/\*\*/, hm = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, gm = /(^|\s+)\/\/([^\r\n]*)/g, mm = /^(\r?\n)+/, ym = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Dm = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Em = /(\r?\n|^) *\* ?/g, Cm = [];
  function bm(e20) {
    const t2 = (0, pm().default)(e20) || lm().EOL;
    e20 = e20.replace(dm, "").replace(fm, "").replace(Em, "$1");
    let n2 = "";
    for (; n2 !== e20; )
      n2 = e20, e20 = e20.replace(ym, `${t2}$1 $2${t2}`);
    e20 = e20.replace(mm, "").trimRight();
    const r2 = Object.create(null), i2 = e20.replace(Dm, "").replace(mm, "").trimRight();
    let u2;
    for (; u2 = Dm.exec(e20); ) {
      const e21 = u2[2].replace(gm, "");
      typeof r2[u2[1]] == "string" || Array.isArray(r2[u2[1]]) ? r2[u2[1]] = Cm.concat(r2[u2[1]], e21) : r2[u2[1]] = e21;
    }
    return {comments: i2, pragmas: r2};
  }
  function Am(e20, t2) {
    return Cm.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
  }
  var vm = Object.defineProperty({extract: um, strip: om, parse: sm, parseWithComments: am, print: cm}, "__esModule", {value: true});
  const {parseWithComments: Fm, strip: Sm, extract: xm, print: wm} = vm, {getShebang: Tm} = yi$2, {normalizeEndOfLine: Bm} = Di$2;
  function Nm(e20) {
    const t2 = Tm(e20);
    t2 && (e20 = e20.slice(t2.length + 1));
    const n2 = xm(e20), {pragmas: r2, comments: i2} = Fm(n2);
    return {shebang: t2, text: e20, pragmas: r2, comments: i2};
  }
  var km = {hasPragma: function(e20) {
    const t2 = Object.keys(Nm(e20).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  }, insertPragma: function(e20) {
    const {shebang: t2, text: n2, pragmas: r2, comments: i2} = Nm(e20), u2 = Sm(n2), o2 = wm({pragmas: Object.assign({format: ""}, r2), comments: i2.trimStart()});
    return (t2 ? `${t2}
` : "") + Bm(o2) + (u2.startsWith("\n") ? "\n" : "\n\n") + u2;
  }};
  const {getLast: Pm, hasNewline: Om, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Im, getNextNonSpaceNonCommentCharacter: Lm, hasNewlineInRange: jm, addLeadingComment: _m, addTrailingComment: Mm, addDanglingComment: Rm, getNextNonSpaceNonCommentCharacterIndex: $m, isNonEmptyArray: Vm} = yi$2, {isBlockComment: Wm, getFunctionParameters: qm, isPrettierIgnoreComment: Um, isJsxNode: zm, hasFlowShorthandAnnotationComment: Gm, hasFlowAnnotationComment: Hm, hasIgnoreComment: Jm, isCallLikeExpression: Xm, getCallArguments: Ym, isCallExpression: Km, isMemberExpression: Qm, isObjectProperty: Zm, getComments: ey, CommentCheckFlags: ty} = Gh, {locStart: ny, locEnd: ry} = zc;
  function iy(e20, t2) {
    const n2 = (e20.body || e20.properties).find(({type: e21}) => e21 !== "EmptyStatement");
    n2 ? _m(n2, t2) : Rm(e20, t2);
  }
  function uy(e20, t2) {
    e20.type === "BlockStatement" ? iy(e20, t2) : _m(e20, t2);
  }
  function oy({comment: e20, followingNode: t2}) {
    return !(!t2 || !Ly(e20)) && (_m(t2, e20), true);
  }
  function sy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
    if (!n2 || n2.type !== "IfStatement" || !r2)
      return false;
    return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? Mm(t2, e20) : Rm(n2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "IfStatement" ? (uy(r2.consequent, e20), true) : n2.consequent === r2 && (_m(r2, e20), true);
  }
  function ay({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
    if (!n2 || n2.type !== "WhileStatement" || !r2)
      return false;
    return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : n2.body === r2 && (_m(r2, e20), true);
  }
  function cy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
    return !(!n2 || n2.type !== "TryStatement" && n2.type !== "CatchClause" || !r2) && (n2.type === "CatchClause" && t2 ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "TryStatement" ? (uy(r2.finalizer, e20), true) : r2.type === "CatchClause" && (uy(r2.body, e20), true));
  }
  function ly({comment: e20, enclosingNode: t2, followingNode: n2}) {
    return !(!Qm(t2) || !n2 || n2.type !== "Identifier") && (_m(t2, e20), true);
  }
  function py({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
    const u2 = t2 && !jm(i2, ry(t2), ny(e20));
    return !(t2 && u2 || !n2 || n2.type !== "ConditionalExpression" && n2.type !== "TSConditionalType" || !r2) && (_m(r2, e20), true);
  }
  function fy({comment: e20, precedingNode: t2, enclosingNode: n2}) {
    return !(!Zm(n2) || !n2.shorthand || n2.key !== t2 || n2.value.type !== "AssignmentPattern") && (Mm(n2.value.left, e20), true);
  }
  function dy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
    if (n2 && (n2.type === "ClassDeclaration" || n2.type === "ClassExpression" || n2.type === "DeclareClass" || n2.type === "DeclareInterface" || n2.type === "InterfaceDeclaration" || n2.type === "TSInterfaceDeclaration")) {
      if (Vm(n2.decorators) && (!r2 || r2.type !== "Decorator"))
        return Mm(Pm(n2.decorators), e20), true;
      if (n2.body && r2 === n2.body)
        return iy(n2.body, e20), true;
      if (r2) {
        for (const i2 of ["implements", "extends", "mixins"])
          if (n2[i2] && r2 === n2[i2][0])
            return !t2 || t2 !== n2.id && t2 !== n2.typeParameters && t2 !== n2.superClass ? Rm(n2, e20, i2) : Mm(t2, e20), true;
      }
    }
    return false;
  }
  function hy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
    return (n2 && t2 && (n2.type === "Property" || n2.type === "TSDeclareMethod" || n2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && n2.key === t2 && Lm(r2, t2, ry) !== ":" || !(!t2 || !n2 || t2.type !== "Decorator" || n2.type !== "ClassMethod" && n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" && n2.type !== "TSAbstractClassProperty" && n2.type !== "TSAbstractMethodDefinition" && n2.type !== "TSDeclareMethod" && n2.type !== "MethodDefinition")) && (Mm(t2, e20), true);
  }
  function gy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
    return Lm(r2, e20, ry) === "(" && (!(!t2 || !n2 || n2.type !== "FunctionDeclaration" && n2.type !== "FunctionExpression" && n2.type !== "ClassMethod" && n2.type !== "MethodDefinition" && n2.type !== "ObjectMethod") && (Mm(t2, e20), true));
  }
  function my({comment: e20, enclosingNode: t2, text: n2}) {
    if (!t2 || t2.type !== "ArrowFunctionExpression")
      return false;
    const r2 = $m(n2, e20, ry);
    return r2 !== false && n2.slice(r2, r2 + 2) === "=>" && (Rm(t2, e20), true);
  }
  function yy({comment: e20, enclosingNode: t2, text: n2}) {
    return Lm(n2, e20, ry) === ")" && (t2 && (Iy(t2) && qm(t2).length === 0 || Xm(t2) && Ym(t2).length === 0) ? (Rm(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || qm(t2.value).length !== 0) && (Rm(t2.value, e20), true));
  }
  function Dy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2}) {
    if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
      return Mm(t2, e20), true;
    if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && Iy(n2) && Lm(i2, e20, ry) === ")")
      return Mm(t2, e20), true;
    if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
      const t3 = (() => {
        const e21 = qm(n2);
        if (e21.length > 0)
          return Im(i2, ry(Pm(e21)));
        const t4 = Im(i2, ry(n2.id));
        return t4 !== false && Im(i2, t4 + 1);
      })();
      if (ny(e20) > t3)
        return iy(r2, e20), true;
    }
    return false;
  }
  function Ey({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ImportSpecifier") && (_m(t2, e20), true);
  }
  function Cy({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "LabeledStatement") && (_m(t2, e20), true);
  }
  function by({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (Mm(t2, e20), true);
  }
  function Ay({comment: e20, precedingNode: t2, enclosingNode: n2}) {
    return !!(Km(n2) && t2 && n2.callee === t2 && n2.arguments.length > 0) && (_m(n2.arguments[0], e20), true);
  }
  function vy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
    return !n2 || n2.type !== "UnionTypeAnnotation" && n2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && Um(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (Um(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (Mm(t2, e20), true));
  }
  function Fy({comment: e20, enclosingNode: t2}) {
    return !!Zm(t2) && (_m(t2, e20), true);
  }
  function Sy({comment: e20, enclosingNode: t2, followingNode: n2, ast: r2, isLastComment: i2}) {
    return r2 && r2.body && r2.body.length === 0 ? (i2 ? Rm(r2, e20) : _m(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !Vm(t2.directives) ? (i2 ? Rm(t2, e20) : _m(t2, e20), true) : !(!n2 || n2.type !== "Program" || n2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (Rm(n2, e20), true);
  }
  function xy({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (_m(t2, e20), true);
  }
  function wy({comment: e20, precedingNode: t2, enclosingNode: n2, text: r2}) {
    return !!(t2 && t2.type === "ImportSpecifier" && n2 && n2.type === "ImportDeclaration" && Om(r2, ry(e20))) && (Mm(t2, e20), true);
  }
  function Ty({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "AssignmentPattern") && (_m(t2, e20), true);
  }
  function By({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "TypeAlias") && (_m(t2, e20), true);
  }
  function Ny({comment: e20, enclosingNode: t2, followingNode: n2}) {
    return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !n2 || n2.type !== "ObjectExpression" && n2.type !== "ArrayExpression" && n2.type !== "TemplateLiteral" && n2.type !== "TaggedTemplateExpression" && !Wm(e20)) && (_m(n2, e20), true);
  }
  function ky({comment: e20, enclosingNode: t2, followingNode: n2, text: r2}) {
    return !(n2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || Lm(r2, e20, ry) !== ";") && (Mm(t2, e20), true);
  }
  function Py({comment: e20, enclosingNode: t2, followingNode: n2}) {
    if (Um(e20) && t2 && t2.type === "TSMappedType" && n2 && n2.type === "TSTypeParameter" && n2.constraint)
      return t2.prettierIgnore = true, e20.unignore = true, true;
  }
  function Oy({comment: e20, precedingNode: t2, enclosingNode: n2, followingNode: r2}) {
    return !(!n2 || n2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (_m(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (Mm(t2.constraint, e20), true));
  }
  function Iy(e20) {
    return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
  }
  function Ly(e20) {
    return Wm(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
  }
  var jy = {handleOwnLineComment: function(e20) {
    return [Py, Dy, ly, sy, ay, cy, dy, Ey, xy, vy, Sy, wy, Ty, hy, Cy].some((t2) => t2(e20));
  }, handleEndOfLineComment: function(e20) {
    return [oy, Dy, py, Ey, sy, ay, cy, dy, Cy, Ay, Fy, Sy, By, Ny].some((t2) => t2(e20));
  }, handleRemainingComment: function(e20) {
    return [Py, sy, ay, fy, yy, hy, Sy, my, gy, Oy, by, ky].some((t2) => t2(e20));
  }, isTypeCastComment: Ly, getCommentChildNodes: function(e20, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && qm(e20.value).length === 0 && !e20.value.returnType && !Vm(e20.value.typeParameters) && e20.value.body)
      return [...e20.decorators || [], e20.key, e20.value.body];
  }, willPrintOwnComments: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    return (t2 && (zm(t2) || Gm(t2) || Km(n2) && ((e21) => Hm(ey(e21, ty.Leading)) || Hm(ey(e21, ty.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!Jm(e20) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
  }};
  const {getFunctionParameters: _y, getLeftSidePathName: My, hasFlowShorthandAnnotationComment: Ry, hasNakedLeftSide: $y, hasNode: Vy, isBitwiseOperator: Wy, startsWithNoLookaheadToken: qy, shouldFlatten: Uy, getPrecedence: zy, isCallExpression: Gy, isMemberExpression: Hy, isObjectProperty: Jy} = Gh;
  function Xy(e20, t2) {
    const n2 = e20.getParentNode();
    if (!n2)
      return false;
    const r2 = e20.getName(), i2 = e20.getNode();
    if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e21) {
      switch (e21.type) {
        case "ObjectExpression":
          return true;
        default:
          return false;
      }
    }(i2) && Yy(e20))
      return true;
    if (function(e21) {
      return e21.type === "BlockStatement" || e21.type === "BreakStatement" || e21.type === "ClassBody" || e21.type === "ClassDeclaration" || e21.type === "ClassMethod" || e21.type === "ClassProperty" || e21.type === "PropertyDefinition" || e21.type === "ClassPrivateProperty" || e21.type === "ContinueStatement" || e21.type === "DebuggerStatement" || e21.type === "DeclareClass" || e21.type === "DeclareExportAllDeclaration" || e21.type === "DeclareExportDeclaration" || e21.type === "DeclareFunction" || e21.type === "DeclareInterface" || e21.type === "DeclareModule" || e21.type === "DeclareModuleExports" || e21.type === "DeclareVariable" || e21.type === "DoWhileStatement" || e21.type === "EnumDeclaration" || e21.type === "ExportAllDeclaration" || e21.type === "ExportDefaultDeclaration" || e21.type === "ExportNamedDeclaration" || e21.type === "ExpressionStatement" || e21.type === "ForInStatement" || e21.type === "ForOfStatement" || e21.type === "ForStatement" || e21.type === "FunctionDeclaration" || e21.type === "IfStatement" || e21.type === "ImportDeclaration" || e21.type === "InterfaceDeclaration" || e21.type === "LabeledStatement" || e21.type === "MethodDefinition" || e21.type === "ReturnStatement" || e21.type === "SwitchStatement" || e21.type === "ThrowStatement" || e21.type === "TryStatement" || e21.type === "TSDeclareFunction" || e21.type === "TSEnumDeclaration" || e21.type === "TSImportEqualsDeclaration" || e21.type === "TSInterfaceDeclaration" || e21.type === "TSModuleDeclaration" || e21.type === "TSNamespaceExportDeclaration" || e21.type === "TypeAlias" || e21.type === "VariableDeclaration" || e21.type === "WhileStatement" || e21.type === "WithStatement";
    }(i2))
      return false;
    if (t2.parser !== "flow" && Ry(e20.getValue()))
      return true;
    if (i2.type === "Identifier")
      return !!(i2.extra && i2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i2.name)) || r2 === "left" && i2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
    switch (n2.type) {
      case "ParenthesizedExpression":
        return false;
      case "ClassDeclaration":
      case "ClassExpression":
        if (r2 === "superClass" && (i2.type === "ArrowFunctionExpression" || i2.type === "AssignmentExpression" || i2.type === "AwaitExpression" || i2.type === "BinaryExpression" || i2.type === "ConditionalExpression" || i2.type === "LogicalExpression" || i2.type === "NewExpression" || i2.type === "ObjectExpression" || i2.type === "ParenthesizedExpression" || i2.type === "SequenceExpression" || i2.type === "TaggedTemplateExpression" || i2.type === "UnaryExpression" || i2.type === "UpdateExpression" || i2.type === "YieldExpression" || i2.type === "TSNonNullExpression"))
          return true;
        break;
      case "ExportDefaultDeclaration":
        return Ky(e20, t2) || i2.type === "SequenceExpression";
      case "Decorator":
        if (r2 === "expression") {
          let e21 = false, t3 = false, n3 = i2;
          for (; n3; )
            switch (n3.type) {
              case "MemberExpression":
                t3 = true, n3 = n3.object;
                break;
              case "CallExpression":
                if (t3 || e21)
                  return true;
                e21 = true, n3 = n3.callee;
                break;
              case "Identifier":
                return false;
              default:
                return true;
            }
          return true;
        }
        break;
      case "ExpressionStatement":
        if (qy(i2, true))
          return true;
        break;
      case "ArrowFunctionExpression":
        if (r2 === "body" && i2.type !== "SequenceExpression" && qy(i2, false))
          return true;
    }
    switch (i2.type) {
      case "UpdateExpression":
        if (n2.type === "UnaryExpression")
          return i2.prefix && (i2.operator === "++" && n2.operator === "+" || i2.operator === "--" && n2.operator === "-");
      case "UnaryExpression":
        switch (n2.type) {
          case "UnaryExpression":
            return i2.operator === n2.operator && (i2.operator === "+" || i2.operator === "-");
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "TaggedTemplateExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "BinaryExpression":
            return r2 === "left" && n2.operator === "**";
          case "TSNonNullExpression":
            return true;
          default:
            return false;
        }
      case "BinaryExpression":
        if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && i2.operator === "|>")
          return true;
        if (i2.operator === "in" && function(e21) {
          let t3 = 0, n3 = e21.getValue();
          for (; n3; ) {
            const r3 = e21.getParentNode(t3++);
            if (r3 && r3.type === "ForStatement" && r3.init === n3)
              return true;
            n3 = r3;
          }
          return false;
        }(e20))
          return true;
        if (i2.operator === "|>" && i2.extra && i2.extra.parenthesized) {
          const t3 = e20.getParentNode(1);
          if (t3.type === "BinaryExpression" && t3.operator === "|>")
            return true;
        }
      case "TSTypeAssertion":
      case "TSAsExpression":
      case "LogicalExpression":
        switch (n2.type) {
          case "TSAsExpression":
            return i2.type !== "TSAsExpression";
          case "ConditionalExpression":
            return i2.type === "TSAsExpression";
          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ClassExpression":
          case "ClassDeclaration":
            return r2 === "superClass";
          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "AssignmentExpression":
          case "AssignmentPattern":
            return r2 === "left" && (i2.type === "TSTypeAssertion" || i2.type === "TSAsExpression");
          case "LogicalExpression":
            if (i2.type === "LogicalExpression")
              return n2.operator !== i2.operator;
          case "BinaryExpression": {
            const {operator: e21, type: t3} = i2;
            if (!e21 && t3 !== "TSTypeAssertion")
              return true;
            const u2 = zy(e21), o2 = n2.operator, s2 = zy(o2);
            return s2 > u2 || (r2 === "right" && s2 === u2 || (s2 === u2 && !Uy(o2, e21) || (s2 < u2 && e21 === "%" ? o2 === "+" || o2 === "-" : !!Wy(o2))));
          }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (n2.type) {
          case "ReturnStatement":
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return r2 !== "expression";
          case "ArrowFunctionExpression":
            return r2 !== "body";
          default:
            return true;
        }
      case "YieldExpression":
        if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
          return true;
        if (r2 === "expression" && i2.argument && i2.argument.type === "PipelinePrimaryTopicReference" && n2.type === "PipelineTopicExpression")
          return true;
      case "AwaitExpression":
        switch (n2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ConditionalExpression":
            return r2 === "test";
          case "BinaryExpression":
            return !(!i2.argument && n2.operator === "|>");
          default:
            return false;
        }
      case "TSConditionalType":
        if (r2 === "extendsType" && n2.type === "TSConditionalType")
          return true;
      case "TSFunctionType":
      case "TSConstructorType":
        if (r2 === "checkType" && n2.type === "TSConditionalType")
          return true;
      case "TSUnionType":
      case "TSIntersectionType":
        if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!i2.types || i2.types.length > 1))
          return true;
      case "TSInferType":
        if (i2.type === "TSInferType" && n2.type === "TSRestType")
          return false;
      case "TSTypeOperator":
        return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e20.getParentNode(1).type);
      case "ArrayTypeAnnotation":
        return n2.type === "NullableTypeAnnotation";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "NullableTypeAnnotation":
        return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "FunctionTypeAnnotation": {
        const t3 = n2.type === "NullableTypeAnnotation" ? e20.getParentNode(1) : n2;
        return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && _y(i2).some((e21) => e21.typeAnnotation && e21.typeAnnotation.type === "NullableTypeAnnotation");
      }
      case "OptionalIndexedAccessType":
        return r2 === "objectType" && n2.type === "IndexedAccessType";
      case "TypeofTypeAnnotation":
        return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof i2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
          const t3 = e20.getParentNode(1);
          return t3.type === "Program" || t3.type === "BlockStatement";
        }
        return r2 === "object" && n2.type === "MemberExpression" && typeof i2.value == "number";
      case "AssignmentExpression": {
        const t3 = e20.getParentNode(1);
        return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? i2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
      }
      case "ConditionalExpression":
        switch (n2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "ConditionalExpression":
            return r2 === "test";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          default:
            return false;
        }
      case "FunctionExpression":
        switch (n2.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "TaggedTemplateExpression":
            return true;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        switch (n2.type) {
          case "PipelineTopicExpression":
            return Boolean(i2.extra && i2.extra.parenthesized);
          case "BinaryExpression":
            return n2.operator !== "|>" || i2.extra && i2.extra.parenthesized;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return r2 === "callee";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return r2 === "object";
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;
          case "ConditionalExpression":
            return r2 === "test";
          default:
            return false;
        }
      case "ClassExpression":
        switch (n2.type) {
          case "NewExpression":
            return r2 === "callee";
          default:
            return false;
        }
      case "OptionalMemberExpression":
      case "OptionalCallExpression": {
        const t3 = e20.getParentNode(1);
        if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
          return true;
      }
      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
          let e21 = i2;
          for (; e21; )
            switch (e21.type) {
              case "CallExpression":
              case "OptionalCallExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
              case "BindExpression":
                e21 = e21.object;
                break;
              case "TaggedTemplateExpression":
                e21 = e21.tag;
                break;
              case "TSNonNullExpression":
                e21 = e21.expression;
                break;
              default:
                return false;
            }
        }
        return false;
      case "BindExpression":
        return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && Hy(n2);
      case "NGPipeExpression":
        return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!i2.extra || !i2.extra.parenthesized) || n2.type === "ArrayExpression" || Gy(n2) && n2.arguments[r2] === i2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
      case "JSXFragment":
      case "JSXElement":
        return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !Gy(n2) && !Jy(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
      case "TypeAnnotation":
        return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e21) {
          return Vy(e21, (e22) => e22.type === "ObjectTypeAnnotation" && Vy(e22, (e23) => e23.type === "FunctionTypeAnnotation" || void 0) || void 0);
        }(i2);
    }
    return false;
  }
  function Yy(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode(), r2 = e20.getName();
    switch (n2.type) {
      case "NGPipeExpression":
        if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
          return e20.callParent(Yy);
        break;
      case "ObjectProperty":
        if (r2 === "value") {
          const t3 = e20.getParentNode(1);
          return Ln$2(t3.properties) === n2;
        }
        break;
      case "BinaryExpression":
      case "LogicalExpression":
        if (r2 === "right")
          return e20.callParent(Yy);
        break;
      case "ConditionalExpression":
        if (r2 === "alternate")
          return e20.callParent(Yy);
        break;
      case "UnaryExpression":
        if (n2.prefix)
          return e20.callParent(Yy);
    }
    return false;
  }
  function Ky(e20, t2) {
    const n2 = e20.getValue(), r2 = e20.getParentNode();
    return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !Xy(e20, t2) : !(!$y(n2) || r2.type !== "ExportDefaultDeclaration" && Xy(e20, t2)) && e20.call((e21) => Ky(e21, t2), ...My(e20, n2));
  }
  var Qy = Xy;
  var Zy = function(e20, t2) {
    switch (t2.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
        return Object.assign(Object.assign({}, e20), {}, {type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e20, comments: [], rootMarker: t2.rootMarker});
      default:
        return e20;
    }
  };
  const {builders: {join: eD, line: tD, group: nD, softline: rD, indent: iD}} = eu$1;
  var uD = {isVueEventBindingExpression: function e6(t2) {
    switch (t2.type) {
      case "MemberExpression":
        switch (t2.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return e6(t2.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  }, printHtmlBinding: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (t2.__onHtmlBindingRoot && e20.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
      return t2.__isVueForBindingLeft ? e20.call((e21) => {
        const t3 = eD([",", tD], e21.map(n2, "params")), {params: r3} = e21.getValue();
        return r3.length === 1 ? t3 : ["(", iD([rD, nD(t3)]), rD, ")"];
      }, "program", "body", 0) : t2.__isVueBindings ? e20.call((e21) => eD([",", tD], e21.map(n2, "params")), "program", "body", 0) : void 0;
  }};
  const {printComments: oD} = Wf, {getLast: sD} = yi$2, {builders: {join: aD, line: cD, softline: lD, group: pD, indent: fD, align: dD, ifBreak: hD, indentIfBreak: gD}, utils: {cleanDoc: mD, getDocParts: yD, isConcat: DD}} = eu$1, {hasLeadingOwnLineComment: ED, isBinaryish: CD, isJsxNode: bD, shouldFlatten: AD, hasComment: vD, CommentCheckFlags: FD, isCallExpression: SD, isMemberExpression: xD, isObjectProperty: wD} = Gh;
  let TD = 0;
  function BD(e20, t2, n2, r2, i2) {
    let u2 = [];
    const o2 = e20.getValue();
    if (CD(o2)) {
      AD(o2.operator, o2.left.operator) ? u2 = [...u2, ...e20.call((e21) => BD(e21, t2, n2, true, i2), "left")] : u2.push(pD(t2("left")));
      const s2 = ND(o2), a2 = (o2.operator === "|>" || o2.type === "NGPipeExpression" || o2.operator === "|" && n2.parser === "__vue_expression") && !ED(n2.originalText, o2.right), c2 = o2.type === "NGPipeExpression" ? "|" : o2.operator, l2 = o2.type === "NGPipeExpression" && o2.arguments.length > 0 ? pD(fD([lD, ": ", aD([lD, ":", hD(" ")], e20.map(t2, "arguments").map((e21) => dD(2, pD(e21))))])) : "", p2 = s2 ? [c2, " ", t2("right"), l2] : [a2 ? cD : "", c2, a2 ? " " : cD, t2("right"), l2], f2 = e20.getParentNode(), d2 = vD(o2.left, FD.Trailing | FD.Line), h2 = d2 || !(i2 && o2.type === "LogicalExpression") && f2.type !== o2.type && o2.left.type !== o2.type && o2.right.type !== o2.type;
      if (u2.push(a2 ? "" : " ", h2 ? pD(p2, {shouldBreak: d2}) : p2), r2 && vD(o2)) {
        const t3 = mD(oD(e20, u2, n2));
        u2 = DD(t3) || t3.type === "fill" ? yD(t3) : [t3];
      }
    } else
      u2.push(pD(t2()));
    return u2;
  }
  function ND(e20) {
    return e20.type === "LogicalExpression" && (e20.right.type === "ObjectExpression" && e20.right.properties.length > 0 || (e20.right.type === "ArrayExpression" && e20.right.elements.length > 0 || !!bD(e20.right)));
  }
  var kD = {printBinaryishExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = e20.getParentNode(1), o2 = r2 !== i2.body && (i2.type === "IfStatement" || i2.type === "WhileStatement" || i2.type === "SwitchStatement" || i2.type === "DoWhileStatement"), s2 = BD(e20, n2, t2, false, o2);
    if (o2)
      return s2;
    if (SD(i2) && i2.callee === r2 || i2.type === "UnaryExpression" || xD(i2) && !i2.computed)
      return pD([fD([lD, ...s2]), lD]);
    const a2 = i2.type === "ReturnStatement" || i2.type === "ThrowStatement" || i2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || r2.operator !== "|" && i2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (i2.type === "NGRoot" && t2.parser === "__ng_binding" || i2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || r2 === i2.body && i2.type === "ArrowFunctionExpression" || r2 !== i2.body && i2.type === "ForStatement" || i2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !SD(u2) || i2.type === "TemplateLiteral", c2 = i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator" || i2.type === "ClassProperty" || i2.type === "PropertyDefinition" || i2.type === "TSAbstractClassProperty" || i2.type === "ClassPrivateProperty" || wD(i2), l2 = CD(r2.left) && AD(r2.operator, r2.left.operator);
    if (a2 || ND(r2) && !l2 || !ND(r2) && c2)
      return pD(s2);
    if (s2.length === 0)
      return "";
    const p2 = bD(r2.right), f2 = s2.findIndex((e21) => typeof e21 != "string" && !Array.isArray(e21) && e21.type === "group"), d2 = s2.slice(0, f2 === -1 ? 1 : f2 + 1), h2 = s2.slice(d2.length, p2 ? -1 : void 0), g2 = Symbol("logicalChain-" + ++TD), m2 = pD([...d2, fD(h2)], {id: g2});
    if (!p2)
      return m2;
    const y2 = sD(s2);
    return pD([m2, gD(y2, {groupId: g2})]);
  }, shouldInlineLogicalExpression: ND};
  const {builders: {join: PD, line: OD, group: ID}} = eu$1, {hasNode: LD, hasComment: jD, getComments: _D} = Gh, {printBinaryishExpression: MD} = kD;
  function RD(e20, t2, n2) {
    return e20.type === "NGMicrosyntaxKeyedExpression" && e20.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
  }
  var $D = {printAngular: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type.startsWith("NG"))
      switch (r2.type) {
        case "NGRoot":
          return [n2("node"), jD(r2.node) ? " //" + _D(r2.node)[0].value.trimEnd() : ""];
        case "NGPipeExpression":
          return MD(e20, t2, n2);
        case "NGChainedExpression":
          return ID(PD([";", OD], e20.map((e21) => function(e22) {
            return LD(e22.getValue(), (e23) => {
              switch (e23.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }(e21) ? n2() : ["(", n2(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [r2.prefix, ": ", r2.value.trim()];
        case "NGMicrosyntax":
          return e20.map((e21, t3) => [t3 === 0 ? "" : RD(e21.getValue(), t3, r2) ? " " : [";", OD], n2()], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
        case "NGMicrosyntaxExpression":
          return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
        case "NGMicrosyntaxKeyedExpression": {
          const t3 = e20.getName(), i2 = e20.getParentNode(), u2 = RD(r2, t3, i2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && i2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && i2.body[t3 - 1].key.name === "then") && i2.body[0].type === "NGMicrosyntaxExpression";
          return [n2("key"), u2 ? " " : ": ", n2("expression")];
        }
        case "NGMicrosyntaxLet":
          return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
        case "NGMicrosyntaxAs":
          return [n2("key"), " as ", n2("alias")];
        default:
          throw new Error(`Unknown Angular node type: ${JSON.stringify(r2.type)}.`);
      }
  }};
  const {printComments: VD, printDanglingComments: WD} = Wf, {builders: {line: qD, hardline: UD, softline: zD, group: GD, indent: HD, conditionalGroup: JD, fill: XD, ifBreak: YD, lineSuffixBoundary: KD, join: QD}, utils: {willBreak: ZD}} = eu$1, {getLast: eE, getPreferredQuote: tE} = yi$2, {isJsxNode: nE, rawText: rE, isLiteral: iE, isCallExpression: uE, isStringLiteral: oE, isBinaryish: sE, hasComment: aE, CommentCheckFlags: cE, hasNodeIgnoreComment: lE} = Gh, {willPrintOwnComments: pE} = jy, fE = (e20) => e20 === "" || e20 === qD || e20 === UD || e20 === zD;
  function dE(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type === "JSXElement" && function(e21) {
      if (e21.children.length === 0)
        return true;
      if (e21.children.length > 1)
        return false;
      const t3 = e21.children[0];
      return iE(t3) && !bE(t3);
    }(r2))
      return [n2("openingElement"), n2("closingElement")];
    const i2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), u2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
    if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
      return [i2, ...e20.map(n2, "children"), u2];
    r2.children = r2.children.map((e21) => function(e22) {
      return e22.type === "JSXExpressionContainer" && iE(e22.expression) && e22.expression.value === " " && !aE(e22.expression);
    }(e21) ? {type: "JSXText", value: " ", raw: " "} : e21);
    const o2 = r2.children.filter(nE).length > 0, s2 = r2.children.filter((e21) => e21.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
    let c2 = ZD(i2) || o2 || a2 || s2;
    const l2 = e20.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : YD([p2, zD], " "), d2 = function(e21, t3, n3, r3, i3) {
      const u3 = [];
      return e21.each((e22, t4, o3) => {
        const s3 = e22.getValue();
        if (iE(s3)) {
          const e23 = rE(s3);
          if (bE(s3)) {
            const n4 = e23.split(DE);
            if (n4[0] === "") {
              if (u3.push(""), n4.shift(), /\n/.test(n4[0])) {
                const e24 = o3[t4 + 1];
                u3.push(gE(i3, n4[1], s3, e24));
              } else
                u3.push(r3);
              n4.shift();
            }
            let a3;
            if (eE(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
              return;
            for (const [e24, t5] of n4.entries())
              e24 % 2 == 1 ? u3.push(qD) : u3.push(t5);
            if (a3 !== void 0)
              if (/\n/.test(a3)) {
                const e24 = o3[t4 + 1];
                u3.push(gE(i3, eE(u3), s3, e24));
              } else
                u3.push(r3);
            else {
              const e24 = o3[t4 + 1];
              u3.push(hE(i3, eE(u3), s3, e24));
            }
          } else
            /\n/.test(e23) ? e23.match(/\n/g).length > 1 && u3.push("", UD) : u3.push("", r3);
        } else {
          const e23 = n3();
          u3.push(e23);
          const r4 = o3[t4 + 1];
          if (r4 && bE(r4)) {
            const e24 = CE(rE(r4)).split(DE)[0];
            u3.push(hE(i3, e24, s3, r4));
          } else
            u3.push(UD);
        }
      }, "children"), u3;
    }(e20, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e21) => bE(e21));
    for (let e21 = d2.length - 2; e21 >= 0; e21--) {
      const t3 = d2[e21] === "" && d2[e21 + 1] === "", n3 = d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === UD, r3 = (d2[e21] === zD || d2[e21] === UD) && d2[e21 + 1] === "" && d2[e21 + 2] === f2, i3 = d2[e21] === f2 && d2[e21 + 1] === "" && (d2[e21 + 2] === zD || d2[e21 + 2] === UD), u3 = d2[e21] === f2 && d2[e21 + 1] === "" && d2[e21 + 2] === f2, o3 = d2[e21] === zD && d2[e21 + 1] === "" && d2[e21 + 2] === UD || d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === zD;
      n3 && h2 || t3 || r3 || u3 || o3 ? d2.splice(e21, 2) : i3 && d2.splice(e21 + 1, 2);
    }
    for (; d2.length > 0 && fE(eE(d2)); )
      d2.pop();
    for (; d2.length > 1 && fE(d2[0]) && fE(d2[1]); )
      d2.shift(), d2.shift();
    const g2 = [];
    for (const [e21, t3] of d2.entries()) {
      if (t3 === f2) {
        if (e21 === 1 && d2[e21 - 1] === "") {
          if (d2.length === 2) {
            g2.push(p2);
            continue;
          }
          g2.push([p2, UD]);
          continue;
        }
        if (e21 === d2.length - 1) {
          g2.push(p2);
          continue;
        }
        if (d2[e21 - 1] === "" && d2[e21 - 2] === UD) {
          g2.push(p2);
          continue;
        }
      }
      g2.push(t3), ZD(t3) && (c2 = true);
    }
    const m2 = h2 ? XD(g2) : GD(g2, {shouldBreak: true});
    if (l2)
      return m2;
    const y2 = GD([i2, HD([UD, m2]), UD, u2]);
    return c2 ? y2 : JD([GD([i2, ...d2, u2]), y2]);
  }
  function hE(e20, t2, n2, r2) {
    return e20 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? zD : UD : zD;
  }
  function gE(e20, t2, n2, r2) {
    return e20 ? UD : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? UD : zD : UD;
  }
  function mE(e20, t2, n2) {
    return function(e21, t3, n3) {
      const r2 = e21.getParentNode();
      if (!r2)
        return t3;
      if ({ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true}[r2.type])
        return t3;
      const i2 = e21.match(void 0, (e22) => e22.type === "ArrowFunctionExpression", uE, (e22) => e22.type === "JSXExpressionContainer"), u2 = Qy(e21, n3);
      return GD([u2 ? "" : YD("("), HD([zD, t3]), zD, u2 ? "" : YD(")")], {shouldBreak: i2});
    }(e20, VD(e20, dE(e20, t2, n2), t2), t2);
  }
  function yE(e20, t2, n2) {
    const r2 = e20.getValue();
    return ["{", e20.call((e21) => {
      const r3 = ["...", n2()], i2 = e21.getValue();
      return aE(i2) && pE(e21) ? [HD([zD, VD(e21, r3, t2)]), zD] : r3;
    }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
  }
  const DE = new RegExp("([ \n\r	]+)"), EE = new RegExp("[^ \n\r	]"), CE = (e20) => e20.replace(new RegExp("(?:^" + DE.source + "|" + DE.source + "$)"), "");
  function bE(e20) {
    return iE(e20) && (EE.test(rE(e20)) || !/\n/.test(rE(e20)));
  }
  var AE = {hasJsxIgnoreComment: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    if (!(n2 && t2 && nE(t2) && nE(n2)))
      return false;
    let r2 = null;
    for (let e21 = n2.children.indexOf(t2); e21 > 0; e21--) {
      const t3 = n2.children[e21 - 1];
      if (t3.type !== "JSXText" || bE(t3)) {
        r2 = t3;
        break;
      }
    }
    return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && lE(r2.expression);
  }, printJsx: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type.startsWith("JSX"))
      switch (r2.type) {
        case "JSXAttribute":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = [];
            if (i2.push(n3("name")), r3.value) {
              let e22;
              if (oE(r3.value)) {
                let n4 = rE(r3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                const i3 = tE(n4, t3.jsxSingleQuote ? "'" : '"'), u2 = i3 === "'" ? "&apos;" : "&quot;";
                n4 = n4.slice(1, -1).replace(new RegExp(i3, "g"), u2), e22 = [i3, n4, i3];
              } else
                e22 = n3("value");
              i2.push("=", e22);
            }
            return i2;
          }(e20, t2, n2);
        case "JSXIdentifier":
          return String(r2.name);
        case "JSXNamespacedName":
          return QD(":", [n2("namespace"), n2("name")]);
        case "JSXMemberExpression":
          return QD(".", [n2("object"), n2("property")]);
        case "JSXSpreadAttribute":
          return yE(e20, t2, n2);
        case "JSXSpreadChild":
          return yE(e20, t2, n2);
        case "JSXExpressionContainer":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = e21.getParentNode(0), u2 = r3.expression.type === "JSXEmptyExpression" || !aE(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || uE(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || nE(i2) && (r3.expression.type === "ConditionalExpression" || sE(r3.expression)));
            return GD(u2 ? ["{", n3("expression"), KD, "}"] : ["{", HD([zD, n3("expression")]), zD, KD, "}"]);
          }(e20, 0, n2);
        case "JSXFragment":
        case "JSXElement":
          return mE(e20, t2, n2);
        case "JSXOpeningElement":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = r3.name && aE(r3.name) || r3.typeParameters && aE(r3.typeParameters);
            if (r3.selfClosing && r3.attributes.length === 0 && !i2)
              return ["<", n3("name"), n3("typeParameters"), " />"];
            if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && oE(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !i2 && !aE(r3.attributes[0]))
              return GD(["<", n3("name"), n3("typeParameters"), " ", ...e21.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
            const u2 = r3.attributes.length > 0 && aE(eE(r3.attributes), cE.Trailing), o2 = r3.attributes.length === 0 && !i2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!i2 || r3.attributes.length > 0) && !u2, s2 = r3.attributes && r3.attributes.some((e22) => e22.value && oE(e22.value) && e22.value.value.includes("\n"));
            return GD(["<", n3("name"), n3("typeParameters"), HD(e21.map(() => [qD, n3()], "attributes")), r3.selfClosing ? qD : o2 ? ">" : zD, r3.selfClosing ? "/>" : o2 ? "" : ">"], {shouldBreak: s2});
          }(e20, t2, n2);
        case "JSXClosingElement":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = [];
            i2.push("</");
            const u2 = n3("name");
            return aE(r3.name, cE.Leading | cE.Line) ? i2.push(HD([UD, u2]), UD) : aE(r3.name, cE.Leading | cE.Block) ? i2.push(" ", u2) : i2.push(u2), i2.push(">"), i2;
          }(e20, 0, n2);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return function(e21, t3) {
            const n3 = e21.getValue(), r3 = aE(n3), i2 = aE(n3, cE.Line), u2 = n3.type === "JSXOpeningFragment";
            return [u2 ? "<" : "</", HD([i2 ? UD : r3 && !u2 ? " " : "", WD(e21, t3, true)]), i2 ? UD : "", ">"];
          }(e20, t2);
        case "JSXEmptyExpression":
          return function(e21, t3) {
            const n3 = e21.getValue(), r3 = aE(n3, cE.Line);
            return [WD(e21, t3, !r3), r3 ? UD : ""];
          }(e20, t2);
        case "JSXText":
          throw new Error("JSXTest should be handled by JSXElement");
        default:
          throw new Error(`Unknown JSX node type: ${JSON.stringify(r2.type)}.`);
      }
  }};
  Ze$3({target: "Array", proto: true}, {flat: function() {
    var e20 = arguments.length ? arguments[0] : void 0, t2 = q$3(this), n2 = Le$3(t2.length), r2 = Wn$2(t2, 0);
    return r2.length = $n$2(r2, t2, t2, n2, 0, e20 === void 0 ? 1 : Oe$3(e20)), r2;
  }});
  const {isNonEmptyArray: vE} = yi$2, {builders: {indent: FE, join: SE, line: xE}} = eu$1, {isFlowAnnotationComment: wE} = Gh;
  function TE(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2.typeAnnotation)
      return "";
    const i2 = e20.getParentNode(), u2 = r2.definite || i2 && i2.type === "VariableDeclarator" && i2.definite, o2 = i2.type === "DeclareFunction" && i2.id === r2;
    return wE(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [o2 ? "" : u2 ? "!: " : ": ", n2("typeAnnotation")];
  }
  var BE = {printOptionalToken: function(e20) {
    const t2 = e20.getValue();
    return !t2.optional || t2.type === "Identifier" && t2 === e20.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
  }, printFunctionTypeParameters: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
  }, printBindExpressionCallee: function(e20, t2, n2) {
    return ["::", n2("callee")];
  }, printTypeScriptModifiers: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return vE(r2.modifiers) ? [SE(" ", e20.map(n2, "modifiers")), " "] : "";
  }, printTypeAnnotation: TE, printRestSpread: function(e20, t2, n2) {
    return ["...", n2("argument"), TE(e20, t2, n2)];
  }, adjustClause: function(e20, t2, n2) {
    return e20.type === "EmptyStatement" ? ";" : e20.type === "BlockStatement" || n2 ? [" ", t2] : FE([xE, t2]);
  }};
  const {printDanglingComments: NE} = Wf, {builders: {line: kE, softline: PE, hardline: OE, group: IE, indent: LE, ifBreak: jE, fill: _E}} = eu$1, {getLast: ME, hasNewline: RE} = yi$2, {shouldPrintComma: $E, hasComment: VE, CommentCheckFlags: WE, isNextLineEmpty: qE, isNumericLiteral: UE, isSignedNumericLiteral: zE} = Gh, {locStart: GE} = zc, {printOptionalToken: HE, printTypeAnnotation: JE} = BE;
  function XE(e20, t2) {
    return e20.elements.length > 1 && e20.elements.every((e21) => e21 && (UE(e21) || zE(e21) && !VE(e21.argument)) && !VE(e21, WE.Trailing | WE.Line, (e22) => !RE(t2.originalText, GE(e22), {backwards: true})));
  }
  function YE(e20, t2, n2, r2) {
    const i2 = [];
    let u2 = [];
    return e20.each((e21) => {
      i2.push(u2, IE(r2())), u2 = [",", kE], e21.getValue() && qE(e21.getValue(), t2) && u2.push(PE);
    }, n2), i2;
  }
  function KE(e20, t2, n2, r2) {
    const i2 = [];
    return e20.each((e21, u2, o2) => {
      const s2 = u2 === o2.length - 1;
      i2.push([n2(), s2 ? r2 : ","]), s2 || i2.push(qE(e21.getValue(), t2) ? [OE, OE] : VE(o2[u2 + 1], WE.Leading | WE.Line) ? OE : kE);
    }, "elements"), _E(i2);
  }
  var QE = {printArray: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = r2.type === "TupleExpression" ? "#[" : "[";
    if (r2.elements.length === 0)
      VE(r2, WE.Dangling) ? i2.push(IE([u2, NE(e20, t2), PE, "]"])) : i2.push(u2, "]");
    else {
      const o2 = ME(r2.elements), s2 = !(o2 && o2.type === "RestElement"), a2 = o2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e21, t3, n3) => {
        const r3 = e21 && e21.type;
        if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
          return false;
        const i3 = n3[t3 + 1];
        if (i3 && r3 !== i3.type)
          return false;
        const u3 = r3 === "ArrayExpression" ? "elements" : "properties";
        return e21[u3] && e21[u3].length > 1;
      }), p2 = XE(r2, t2), f2 = s2 ? a2 ? "," : $E(t2) ? p2 ? jE(",", "", {groupId: c2}) : jE(",") : "" : "";
      i2.push(IE([u2, LE([PE, p2 ? KE(e20, t2, n2, f2) : [YE(e20, t2, "elements", n2), f2], NE(e20, t2, true)]), PE, "]"], {shouldBreak: l2, id: c2}));
    }
    return i2.push(HE(e20), JE(e20, t2, n2)), i2;
  }, printArrayItems: YE, isConciselyPrintedArray: XE};
  const {printDanglingComments: ZE} = Wf, {getLast: eC, getPenultimate: tC} = yi$2, {getFunctionParameters: nC, hasComment: rC, CommentCheckFlags: iC, isFunctionCompositionArgs: uC, isJsxNode: oC, isLongCurriedCallExpression: sC, shouldPrintComma: aC, getCallArguments: cC, iterateCallArgumentsPath: lC, isNextLineEmpty: pC, isCallExpression: fC, isStringLiteral: dC, isObjectProperty: hC} = Gh, {builders: {line: gC, hardline: mC, softline: yC, group: DC, indent: EC, conditionalGroup: CC, ifBreak: bC, breakParent: AC}, utils: {willBreak: vC}} = eu$1, {ArgExpansionBailout: FC} = bo$2, {isConciselyPrintedArray: SC} = QE;
  function xC(e20, t2 = false) {
    return e20.type === "ObjectExpression" && (e20.properties.length > 0 || rC(e20)) || e20.type === "ArrayExpression" && (e20.elements.length > 0 || rC(e20)) || e20.type === "TSTypeAssertion" && xC(e20.expression) || e20.type === "TSAsExpression" && xC(e20.expression) || e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && (!e20.returnType || !e20.returnType.typeAnnotation || e20.returnType.typeAnnotation.type !== "TSTypeReference" || (n2 = e20.body).type === "BlockStatement" && (n2.body.some((e21) => e21.type !== "EmptyStatement") || rC(n2, iC.Dangling))) && (e20.body.type === "BlockStatement" || e20.body.type === "ArrowFunctionExpression" && xC(e20.body, true) || e20.body.type === "ObjectExpression" || e20.body.type === "ArrayExpression" || !t2 && (fC(e20.body) || e20.body.type === "ConditionalExpression") || oC(e20.body)) || e20.type === "DoExpression" || e20.type === "ModuleExpression";
    var n2;
  }
  var wC = function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "ImportExpression", u2 = cC(r2);
    if (u2.length === 0)
      return ["(", ZE(e20, t2, true), ")"];
    if (function(e21) {
      return e21.length === 2 && e21[0].type === "ArrowFunctionExpression" && nC(e21[0]).length === 0 && e21[0].body.type === "BlockStatement" && e21[1].type === "ArrayExpression" && !e21.some((e22) => rC(e22));
    }(u2))
      return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
    let o2 = false, s2 = false;
    const a2 = u2.length - 1, c2 = [];
    lC(e20, (e21, r3) => {
      const i3 = e21.getNode(), u3 = [n2()];
      r3 === a2 || (pC(i3, t2) ? (r3 === 0 && (s2 = true), o2 = true, u3.push(",", mC, mC)) : u3.push(",", gC)), c2.push(u3);
    });
    const l2 = i2 || r2.callee && r2.callee.type === "Import" || !aC(t2, "all") ? "" : ",";
    function p2() {
      return DC(["(", EC([gC, ...c2]), l2, gC, ")"], {shouldBreak: true});
    }
    if (o2 || e20.getParentNode().type !== "Decorator" && uC(u2))
      return p2();
    const f2 = function(e21) {
      if (e21.length !== 2)
        return false;
      const [t3, n3] = e21;
      if (t3.type === "ModuleExpression" && function(e22) {
        return e22.type === "ObjectExpression" && e22.properties.length === 1 && hC(e22.properties[0]) && e22.properties[0].key.type === "Identifier" && e22.properties[0].key.name === "type" && dC(e22.properties[0].value) && e22.properties[0].value.value === "module";
      }(n3))
        return true;
      return !rC(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !xC(n3);
    }(u2), d2 = function(e21, t3) {
      const n3 = eC(e21), r3 = tC(e21);
      return !rC(n3, iC.Leading) && !rC(n3, iC.Trailing) && xC(n3) && (!r3 || r3.type !== n3.type) && (e21.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e21.length > 1 && n3.type === "ArrayExpression" && SC(n3, t3));
    }(u2, t2);
    if (f2 || d2) {
      if (f2 ? c2.slice(1).some(vC) : c2.slice(0, -1).some(vC))
        return p2();
      let t3 = [];
      try {
        e20.try(() => {
          lC(e20, (e21, r3) => {
            f2 && r3 === 0 && (t3 = [[n2([], {expandFirstArg: true}), c2.length > 1 ? "," : "", s2 ? mC : gC, s2 ? mC : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t3 = [...c2.slice(0, -1), n2([], {expandLastArg: true})]);
          });
        });
      } catch (e21) {
        if (e21 instanceof FC)
          return p2();
        throw e21;
      }
      return [c2.some(vC) ? AC : "", CC([["(", ...t3, ")"], f2 ? ["(", DC(t3[0], {shouldBreak: true}), ...t3.slice(1), ")"] : ["(", ...c2.slice(0, -1), DC(eC(t3), {shouldBreak: true}), ")"], p2()])];
    }
    const h2 = ["(", EC([yC, ...c2]), bC(l2), yC, ")"];
    return sC(e20) ? h2 : DC(h2, {shouldBreak: c2.some(vC) || o2});
  };
  const {builders: {softline: TC, group: BC, indent: NC, label: kC}} = eu$1, {isNumericLiteral: PC, isMemberExpression: OC, isCallExpression: IC} = Gh, {printOptionalToken: LC} = BE;
  function jC(e20, t2, n2) {
    const r2 = n2("property"), i2 = e20.getValue(), u2 = LC(e20);
    return i2.computed ? !i2.property || PC(i2.property) ? [u2, "[", r2, "]"] : BC([u2, "[", NC([TC, r2]), TC, "]"]) : [u2, ".", r2];
  }
  var _C = {printMemberExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode();
    let u2, o2 = 0;
    do {
      u2 = e20.getParentNode(o2), o2++;
    } while (u2 && (OC(u2) || u2.type === "TSNonNullExpression"));
    const s2 = n2("object"), a2 = jC(e20, t2, n2), c2 = u2 && (u2.type === "NewExpression" || u2.type === "BindExpression" || u2.type === "AssignmentExpression" && u2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !OC(i2) || (i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator") && (IC(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && IC(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
    return kC(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : BC(NC([TC, a2]))]);
  }, printMemberLookup: jC};
  const {printComments: MC} = Wf, {getLast: RC, isNextLineEmptyAfterIndex: $C, getNextNonSpaceNonCommentCharacterIndex: VC} = yi$2, {isCallExpression: WC, isMemberExpression: qC, isFunctionOrArrowExpression: UC, isLongCurriedCallExpression: zC, isMemberish: GC, isNumericLiteral: HC, isSimpleCallArgument: JC, hasComment: XC, CommentCheckFlags: YC, isNextLineEmpty: KC} = Gh, {locEnd: QC} = zc, {builders: {join: ZC, hardline: eb, group: tb, indent: nb, conditionalGroup: rb, breakParent: ib, label: ub}, utils: {willBreak: ob}} = eu$1, {printMemberLookup: sb} = _C, {printOptionalToken: ab, printFunctionTypeParameters: cb, printBindExpressionCallee: lb} = BE;
  var pb = function(e20, t2, n2) {
    const r2 = e20.getParentNode(), i2 = !r2 || r2.type === "ExpressionStatement", u2 = [];
    function o2(e21) {
      const {originalText: n3} = t2, r3 = VC(n3, e21, QC);
      return n3.charAt(r3) === ")" ? r3 !== false && $C(n3, r3 + 1) : KC(e21, t2);
    }
    function s2(e21) {
      const r3 = e21.getValue();
      WC(r3) && (GC(r3.callee) || WC(r3.callee)) ? (u2.unshift({node: r3, printed: [MC(e21, [ab(e21), cb(e21, t2, n2), wC(e21, t2, n2)], t2), o2(r3) ? eb : ""]}), e21.call((e22) => s2(e22), "callee")) : GC(r3) ? (u2.unshift({node: r3, needsParens: Qy(e21, t2), printed: MC(e21, qC(r3) ? sb(e21, t2, n2) : lb(e21, t2, n2), t2)}), e21.call((e22) => s2(e22), "object")) : r3.type === "TSNonNullExpression" ? (u2.unshift({node: r3, printed: MC(e21, "!", t2)}), e21.call((e22) => s2(e22), "expression")) : u2.unshift({node: r3, printed: n2()});
    }
    const a2 = e20.getValue();
    u2.unshift({node: a2, printed: [ab(e20), cb(e20, t2, n2), wC(e20, t2, n2)]}), a2.callee && e20.call((e21) => s2(e21), "callee");
    const c2 = [];
    let l2 = [u2[0]], p2 = 1;
    for (; p2 < u2.length && (u2[p2].node.type === "TSNonNullExpression" || WC(u2[p2].node) || qC(u2[p2].node) && u2[p2].node.computed && HC(u2[p2].node.property)); ++p2)
      l2.push(u2[p2]);
    if (!WC(u2[0].node))
      for (; p2 + 1 < u2.length && (GC(u2[p2].node) && GC(u2[p2 + 1].node)); ++p2)
        l2.push(u2[p2]);
    c2.push(l2), l2 = [];
    let f2 = false;
    for (; p2 < u2.length; ++p2) {
      if (f2 && GC(u2[p2].node)) {
        if (u2[p2].node.computed && HC(u2[p2].node.property)) {
          l2.push(u2[p2]);
          continue;
        }
        c2.push(l2), l2 = [], f2 = false;
      }
      (WC(u2[p2].node) || u2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(u2[p2]), XC(u2[p2].node, YC.Trailing) && (c2.push(l2), l2 = [], f2 = false);
    }
    function d2(e21) {
      return /^[A-Z]|^[$_]+$/.test(e21);
    }
    l2.length > 0 && c2.push(l2);
    const h2 = c2.length >= 2 && !XC(c2[1][0].node) && function(e21) {
      const n3 = e21[1].length > 0 && e21[1][0].node.computed;
      if (e21[0].length === 1) {
        const r4 = e21[0][0].node;
        return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || i2 && function(e22) {
          return e22.length <= t2.tabWidth;
        }(r4.name) || n3);
      }
      const r3 = RC(e21[0]).node;
      return qC(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
    }(c2);
    function g2(e21) {
      const t3 = e21.map((e22) => e22.printed);
      return e21.length > 0 && RC(e21).needsParens ? ["(", ...t3, ")"] : t3;
    }
    const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e21) => XC(e21.node, YC.Leading)) || E2.slice(0, -1).some((e21) => XC(e21.node, YC.Trailing)) || c2[D2] && XC(c2[D2][0].node, YC.Leading);
    if (c2.length <= D2 && !C2)
      return zC(e20) ? y2 : tb(y2);
    const b2 = RC(c2[h2 ? 1 : 0]).node, A2 = !WC(b2) && o2(b2), v2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", A2 ? eb : "", function(e21) {
      return e21.length === 0 ? "" : nb(tb([eb, ZC(eb, e21.map(g2))]));
    }(c2.slice(h2 ? 2 : 1))], F2 = u2.map(({node: e21}) => e21).filter(WC);
    let S2;
    return S2 = C2 || F2.length > 2 && F2.some((e21) => !e21.arguments.every((e22) => JC(e22, 0))) || m2.slice(0, -1).some(ob) || function() {
      const e21 = RC(RC(c2)).node, t3 = RC(m2);
      return WC(e21) && ob(t3) && F2.slice(0, -1).some((e22) => e22.arguments.some(UC));
    }() ? tb(v2) : [ob(y2) || A2 ? ib : "", rb([y2, v2])], ub("member-chain", S2);
  };
  const {builders: {join: fb, group: db}} = eu$1, {getCallArguments: hb, hasFlowAnnotationComment: gb, isCallExpression: mb, isMemberish: yb, isStringLiteral: Db, isTemplateOnItsOwnLine: Eb, isTestCall: Cb, iterateCallArgumentsPath: bb} = Gh, {printOptionalToken: Ab, printFunctionTypeParameters: vb} = BE;
  var Fb = {printCallExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = r2.type === "NewExpression", o2 = r2.type === "ImportExpression", s2 = Ab(e20), a2 = hb(r2);
    if (a2.length > 0 && (!o2 && !u2 && function(e21, t3) {
      if (e21.callee.type !== "Identifier")
        return false;
      if (e21.callee.name === "require")
        return true;
      if (e21.callee.name === "define") {
        const n3 = hb(e21);
        return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Db(n3[0]) && n3[1].type === "ArrayExpression");
      }
      return false;
    }(r2, i2) || a2.length === 1 && Eb(a2[0], t2.originalText) || !u2 && Cb(r2, i2))) {
      const r3 = [];
      return bb(e20, () => {
        r3.push(n2());
      }), [u2 ? "new " : "", n2("callee"), s2, vb(e20, t2, n2), "(", fb(", ", r3), ")"];
    }
    const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && gb(r2.callee.trailingComments);
    if (c2 && (r2.callee.trailingComments[0].printed = true), !o2 && !u2 && yb(r2.callee) && !e20.call((e21) => Qy(e21, t2), "callee"))
      return pb(e20, t2, n2);
    const l2 = [u2 ? "new " : "", o2 ? "import" : n2("callee"), s2, c2 ? `/*:: ${r2.callee.trailingComments[0].value.slice(2).trim()} */` : "", vb(e20, t2, n2), wC(e20, t2, n2)];
    return o2 || mb(r2.callee) ? db(l2) : l2;
  }};
  const {isNonEmptyArray: Sb, getStringWidth: xb} = yi$2, {builders: {line: wb, group: Tb, indent: Bb, indentIfBreak: Nb}, utils: {cleanDoc: kb, willBreak: Pb}} = eu$1, {hasLeadingOwnLineComment: Ob, isBinaryish: Ib, isStringLiteral: Lb, isLiteral: jb, isNumericLiteral: _b$3, isCallExpression: Mb, isMemberExpression: Rb, getCallArguments: $b, rawText: Vb, hasComment: Wb, isSignedNumericLiteral: qb, isObjectProperty: Ub} = Gh, {shouldInlineLogicalExpression: zb} = kD, {printCallExpression: Gb} = Fb;
  function Hb(e20, t2, n2, r2, i2, u2) {
    const o2 = function(e21, t3, n3, r3, i3) {
      const u3 = e21.getValue(), o3 = u3[i3];
      if (!o3)
        return "only-left";
      const s3 = !Jb(o3);
      if (e21.match(Jb, Xb, (e22) => !s3 || e22.type !== "ExpressionStatement" && e22.type !== "VariableDeclaration"))
        return s3 ? o3.type === "ArrowFunctionExpression" && o3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
      if (!s3 && Jb(o3.right) || Ob(t3.originalText, o3))
        return "break-after-operator";
      if (o3.type === "CallExpression" && o3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
        return "never-break-after-operator";
      if (function(e22) {
        if (Xb(e22)) {
          const t4 = e22.left || e22.id;
          return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e23) => Ub(e23) && (!e23.shorthand || e23.value && e23.value.type === "AssignmentPattern"));
        }
        return false;
      }(u3) || function(e22) {
        const t4 = function(e23) {
          if (function(e24) {
            return e24.type === "TSTypeAliasDeclaration" || e24.type === "TypeAlias";
          }(e23) && e23.typeParameters && e23.typeParameters.params)
            return e23.typeParameters.params;
          return null;
        }(e22);
        if (Sb(t4)) {
          const n4 = e22.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
          if (t4.length > 1 && t4.some((e23) => e23[n4] || e23.default))
            return true;
        }
        return false;
      }(u3) || function(e22) {
        if (e22.type !== "VariableDeclarator")
          return false;
        const {typeAnnotation: t4} = e22.id;
        if (!t4 || !t4.typeAnnotation)
          return false;
        const n4 = Yb(t4.typeAnnotation);
        return Sb(n4) && n4.length > 1 && n4.some((e23) => Sb(Yb(e23)) || e23.type === "TSConditionalType");
      }(u3))
        return "break-lhs";
      const a2 = function(e22, t4, n4) {
        if (!Ub(e22))
          return false;
        t4 = kb(t4);
        const r4 = 3;
        return typeof t4 == "string" && xb(t4) < n4.tabWidth + r4;
      }(u3, r3, t3);
      if (e21.call(() => function(e22, t4, n4, r4) {
        const i4 = e22.getValue();
        if (Ib(i4) && !zb(i4))
          return true;
        switch (i4.type) {
          case "StringLiteralTypeAnnotation":
          case "SequenceExpression":
            return true;
          case "ConditionalExpression": {
            const {test: e23} = i4;
            return Ib(e23) && !zb(e23);
          }
          case "ClassExpression":
            return Sb(i4.decorators);
        }
        if (r4)
          return false;
        let u4 = i4;
        const o4 = [];
        for (; ; )
          if (u4.type === "UnaryExpression")
            u4 = u4.argument, o4.push("argument");
          else {
            if (u4.type !== "TSNonNullExpression")
              break;
            u4 = u4.expression, o4.push("expression");
          }
        if (Lb(u4) || e22.call(() => Kb(e22, t4, n4), ...o4))
          return true;
        return false;
      }(e21, t3, n3, a2), i3))
        return "break-after-operator";
      if (a2 || o3.type === "TemplateLiteral" || o3.type === "TaggedTemplateExpression" || o3.type === "BooleanLiteral" || _b$3(o3) || o3.type === "ClassExpression")
        return "never-break-after-operator";
      return "fluid";
    }(e20, t2, n2, r2, u2), s2 = n2(u2, {assignmentLayout: o2});
    switch (o2) {
      case "break-after-operator":
        return Tb([Tb(r2), i2, Tb(Bb([wb, s2]))]);
      case "never-break-after-operator":
        return Tb([Tb(r2), i2, " ", s2]);
      case "fluid": {
        const e21 = Symbol("assignment");
        return Tb([Tb(r2), i2, Tb(Bb(wb), {id: e21}), Nb(s2, {groupId: e21})]);
      }
      case "break-lhs":
        return Tb([r2, i2, " ", Tb(s2)]);
      case "chain":
        return [Tb(r2), i2, wb, s2];
      case "chain-tail":
        return [Tb(r2), i2, Bb([wb, s2])];
      case "chain-tail-arrow-chain":
        return [Tb(r2), i2, s2];
      case "only-left":
        return r2;
    }
  }
  function Jb(e20) {
    return e20.type === "AssignmentExpression";
  }
  function Xb(e20) {
    return Jb(e20) || e20.type === "VariableDeclarator";
  }
  function Yb(e20) {
    return function(e21) {
      return e21.type === "TSTypeReference" || e21.type === "GenericTypeAnnotation";
    }(e20) && e20.typeParameters && e20.typeParameters.params ? e20.typeParameters.params : null;
  }
  function Kb(e20, t2, n2, r2 = false) {
    const i2 = e20.getValue(), u2 = () => Kb(e20, t2, n2, true);
    if (i2.type === "TSNonNullExpression")
      return e20.call(u2, "expression");
    if (Mb(i2)) {
      if (Gb(e20, t2, n2).label === "member-chain")
        return false;
      const r3 = $b(i2);
      return !!(r3.length === 0 || r3.length === 1 && function(e21, {printWidth: t3}) {
        if (Wb(e21))
          return false;
        const n3 = 0.25 * t3;
        if (e21.type === "ThisExpression" || e21.type === "Identifier" && e21.name.length <= n3 || qb(e21) && !Wb(e21.argument))
          return true;
        const r4 = e21.type === "Literal" && "regex" in e21 && e21.regex.pattern || e21.type === "RegExpLiteral" && e21.pattern;
        if (r4)
          return r4.length <= n3;
        if (Lb(e21))
          return Vb(e21).length <= n3;
        if (e21.type === "TemplateLiteral")
          return e21.expressions.length === 0 && e21.quasis[0].value.raw.length <= n3 && !e21.quasis[0].value.raw.includes("\n");
        return jb(e21);
      }(r3[0], t2)) && (!function(e21, t3) {
        const n3 = function(e22) {
          return e22.typeParameters && e22.typeParameters.params || e22.typeArguments && e22.typeArguments.params;
        }(e21);
        if (Sb(n3)) {
          if (n3.length > 1)
            return true;
          if (n3.length === 1) {
            const e22 = n3[0];
            if (e22.type === "TSUnionType" || e22.type === "UnionTypeAnnotation" || e22.type === "TSIntersectionType" || e22.type === "IntersectionTypeAnnotation")
              return true;
          }
          const r4 = e21.typeParameters ? "typeParameters" : "typeArguments";
          if (Pb(t3(r4)))
            return true;
        }
        return false;
      }(i2, n2) && e20.call(u2, "callee"));
    }
    return Rb(i2) ? e20.call(u2, "object") : r2 && (i2.type === "Identifier" || i2.type === "ThisExpression");
  }
  var Qb = {printVariableDeclarator: function(e20, t2, n2) {
    return Hb(e20, t2, n2, n2("id"), " =", "init");
  }, printAssignmentExpression: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return Hb(e20, t2, n2, n2("left"), [" ", r2.operator], "right");
  }, printAssignment: Hb};
  const {getNextNonSpaceNonCommentCharacter: Zb} = yi$2, {printDanglingComments: eA} = Wf, {builders: {line: tA, hardline: nA, softline: rA, group: iA, indent: uA, ifBreak: oA}, utils: {removeLines: sA, willBreak: aA}} = eu$1, {getFunctionParameters: cA, iterateFunctionParametersPath: lA, isSimpleType: pA, isTestCall: fA, isTypeAnnotationAFunction: dA, isObjectType: hA, isObjectTypePropertyAFunction: gA, hasRestParameter: mA, shouldPrintComma: yA, hasComment: DA, isNextLineEmpty: EA} = Gh, {locEnd: CA} = zc, {ArgExpansionBailout: bA} = bo$2, {printFunctionTypeParameters: AA} = BE;
  function vA(e20) {
    if (!e20)
      return false;
    const t2 = cA(e20);
    if (t2.length !== 1)
      return false;
    const [n2] = t2;
    return !DA(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && hA(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && hA(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
  }
  var FA = {printFunctionParameters: function(e20, t2, n2, r2, i2) {
    const u2 = e20.getValue(), o2 = cA(u2), s2 = i2 ? AA(e20, n2, t2) : "";
    if (o2.length === 0)
      return [s2, "(", eA(e20, n2, true, (e21) => Zb(n2.originalText, e21, CA) === ")"), ")"];
    const a2 = e20.getParentNode(), c2 = fA(a2), l2 = vA(u2), p2 = [];
    if (lA(e20, (e21, r3) => {
      const i3 = r3 === o2.length - 1;
      i3 && u2.rest && p2.push("..."), p2.push(t2()), i3 || (p2.push(","), c2 || l2 ? p2.push(" ") : EA(o2[r3], n2) ? p2.push(nA, nA) : p2.push(tA));
    }), r2) {
      if (aA(s2) || aA(p2))
        throw new bA();
      return iA([sA(s2), "(", sA(p2), ")"]);
    }
    const f2 = o2.every((e21) => !e21.decorators);
    return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (gA(a2) || dA(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === u2) && o2.length === 1 && o2[0].name === null && u2.this !== o2[0] && o2[0].typeAnnotation && u2.typeParameters === null && pA(o2[0].typeAnnotation) && !u2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", uA([rA, ...p2]), oA(!mA(u2) && yA(n2, "all") ? "," : ""), rA, ")"];
  }, shouldHugFunctionParameters: vA, shouldGroupFunctionParameters: function(e20, t2) {
    const n2 = function(e21) {
      let t3;
      return e21.returnType ? (t3 = e21.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e21.typeAnnotation && (t3 = e21.typeAnnotation), t3;
    }(e20);
    if (!n2)
      return false;
    const r2 = e20.typeParameters && e20.typeParameters.params;
    if (r2) {
      if (r2.length > 1)
        return false;
      if (r2.length === 1) {
        const e21 = r2[0];
        if (e21.constraint || e21.default)
          return false;
      }
    }
    return cA(e20).length === 1 && (hA(n2) || aA(t2));
  }};
  const {printComments: SA, printDanglingComments: xA} = Wf, {getLast: wA} = yi$2, {builders: {group: TA, join: BA, line: NA, softline: kA, indent: PA, align: OA, ifBreak: IA}} = eu$1, {locStart: LA} = zc, {isSimpleType: jA, isObjectType: _A, hasLeadingOwnLineComment: MA, isObjectTypePropertyAFunction: RA, shouldPrintComma: $A} = Gh, {printAssignment: VA} = Qb, {printFunctionParameters: WA, shouldGroupFunctionParameters: qA} = FA, {printArrayItems: UA} = QE;
  function zA(e20) {
    if (jA(e20) || _A(e20))
      return true;
    if (e20.type === "UnionTypeAnnotation" || e20.type === "TSUnionType") {
      const t2 = e20.types.filter((e21) => e21.type === "VoidTypeAnnotation" || e21.type === "TSVoidKeyword" || e21.type === "NullLiteralTypeAnnotation" || e21.type === "TSNullKeyword").length, n2 = e20.types.some((e21) => e21.type === "ObjectTypeAnnotation" || e21.type === "TSTypeLiteral" || e21.type === "GenericTypeAnnotation" || e21.type === "TSTypeReference");
      if (e20.types.length - 1 === t2 && n2)
        return true;
    }
    return false;
  }
  var GA = {printOpaqueType: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
    return u2.push("opaque type ", n2("id"), n2("typeParameters")), i2.supertype && u2.push(": ", n2("supertype")), i2.impltype && u2.push(" = ", n2("impltype")), u2.push(r2), u2;
  }, printTypeAlias: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
    i2.declare && u2.push("declare "), u2.push("type ", n2("id"), n2("typeParameters"));
    const o2 = i2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [VA(e20, t2, n2, u2, " =", o2), r2];
  }, printIntersectionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.map(n2, "types"), u2 = [];
    let o2 = false;
    for (let e21 = 0; e21 < i2.length; ++e21)
      e21 === 0 ? u2.push(i2[e21]) : _A(r2.types[e21 - 1]) && _A(r2.types[e21]) ? u2.push([" & ", o2 ? PA(i2[e21]) : i2[e21]]) : _A(r2.types[e21 - 1]) || _A(r2.types[e21]) ? (e21 > 1 && (o2 = true), u2.push(" & ", e21 > 1 ? PA(i2[e21]) : i2[e21])) : u2.push(PA([" &", NA, i2[e21]]));
    return TA(u2);
  }, printUnionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = !(i2.type === "TypeParameterInstantiation" || i2.type === "TSTypeParameterInstantiation" || i2.type === "GenericTypeAnnotation" || i2.type === "TSTypeReference" || i2.type === "TSTypeAssertion" || i2.type === "TupleTypeAnnotation" || i2.type === "TSTupleType" || i2.type === "FunctionTypeParam" && !i2.name && e20.getParentNode(1).this !== i2 || (i2.type === "TypeAlias" || i2.type === "VariableDeclarator" || i2.type === "TSTypeAliasDeclaration") && MA(t2.originalText, r2)), o2 = zA(r2), s2 = e20.map((e21) => {
      let r3 = n2();
      return o2 || (r3 = OA(2, r3)), SA(e21, r3, t2);
    }, "types");
    if (o2)
      return BA(" | ", s2);
    const a2 = u2 && !MA(t2.originalText, r2), c2 = [IA([a2 ? NA : "", "| "]), BA([NA, "| "], s2)];
    return Qy(e20, t2) ? TA([PA(c2), kA]) : i2.type === "TupleTypeAnnotation" && i2.types.length > 1 || i2.type === "TSTupleType" && i2.elementTypes.length > 1 ? TA([PA([IA(["(", kA]), c2]), kA, IA(")")]) : TA(u2 ? PA(c2) : c2);
  }, printFunctionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode(0), o2 = e20.getParentNode(1), s2 = e20.getParentNode(2);
    let a2 = r2.type === "TSFunctionType" || !((u2.type === "ObjectTypeProperty" || u2.type === "ObjectTypeInternalSlot") && !u2.variance && !u2.optional && LA(u2) === LA(r2) || u2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation");
    const l2 = c2 && a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation") && o2.type === "ArrowFunctionExpression";
    RA(u2) && (a2 = true, c2 = true), l2 && i2.push("(");
    const p2 = WA(e20, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = qA(r2, f2);
    return i2.push(d2 ? TA(p2) : p2), f2 && i2.push(f2), l2 && i2.push(")"), TA(i2);
  }, printTupleType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "TSTupleType" ? "elementTypes" : "types", u2 = r2[i2].length > 0 && wA(r2[i2]).type === "TSRestType";
    return TA(["[", PA([kA, UA(e20, t2, i2, n2)]), IA($A(t2, "all") && !u2 ? "," : ""), xA(e20, t2, true), kA, "]"]);
  }, printIndexedAccessType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
    return [n2("objectType"), i2, n2("indexType"), "]"];
  }, shouldHugType: zA};
  const {printDanglingComments: HA} = Wf, {builders: {join: JA, line: XA, hardline: YA, softline: KA, group: QA, indent: ZA, ifBreak: ev}} = eu$1, {isTestCall: tv, hasComment: nv, CommentCheckFlags: rv, isTSXFile: iv, shouldPrintComma: uv, getFunctionParameters: ov} = Gh, {createGroupIdMapper: sv} = yi$2, {shouldHugType: av} = GA, cv = sv("typeParameters");
  function lv(e20, t2) {
    const n2 = e20.getValue();
    if (!nv(n2, rv.Dangling))
      return "";
    const r2 = !nv(n2, rv.Line), i2 = HA(e20, t2, r2);
    return r2 ? i2 : [i2, YA];
  }
  var pv = {printTypeParameter: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode();
    return u2.type === "TSMappedType" ? (i2.push("[", n2("name")), r2.constraint && i2.push(" in ", n2("constraint")), u2.nameType && i2.push(" as ", e20.callParent(() => n2("nameType"))), i2.push("]"), i2) : (r2.variance && i2.push(n2("variance")), i2.push(n2("name")), r2.bound && i2.push(": ", n2("bound")), r2.constraint && i2.push(" extends ", n2("constraint")), r2.default && i2.push(" = ", n2("default")), i2);
  }, printTypeParameters: function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    if (!i2[r2])
      return "";
    if (!Array.isArray(i2[r2]))
      return n2(r2);
    const u2 = e20.getNode(2);
    if (u2 && tv(u2) || i2[r2].length === 0 || i2[r2].length === 1 && (av(i2[r2][0]) || i2[r2][0].type === "NullableTypeAnnotation"))
      return ["<", JA(", ", e20.map(n2, r2)), lv(e20, t2), ">"];
    const o2 = i2.type === "TSTypeParameterInstantiation" ? "" : ov(i2).length === 1 && iv(t2) && !i2[r2][0].constraint && e20.getParentNode().type === "ArrowFunctionExpression" ? "," : uv(t2, "all") ? ev(",") : "";
    return QA(["<", ZA([KA, JA([",", XA], e20.map(n2, r2))]), o2, KA, ">"], {id: cv(i2)});
  }, getTypeParametersGroupId: cv};
  const {printComments: fv} = Wf, {printString: dv, printNumber: hv} = yi$2, {isNumericLiteral: gv, isSimpleNumber: mv, isStringLiteral: yv, isStringPropSafeToUnquote: Dv, rawText: Ev} = Gh, {printAssignment: Cv} = Qb, bv = new WeakMap();
  function Av(e20, t2, n2) {
    const r2 = e20.getNode();
    if (r2.computed)
      return ["[", n2("key"), "]"];
    const i2 = e20.getParentNode(), {key: u2} = r2;
    if (r2.type === "ClassPrivateProperty" && u2.type === "Identifier")
      return ["#", n2("key")];
    if (t2.quoteProps === "consistent" && !bv.has(i2)) {
      const e21 = (i2.properties || i2.body || i2.members).some((e22) => !e22.computed && e22.key && yv(e22.key) && !Dv(e22, t2));
      bv.set(i2, e21);
    }
    if ((u2.type === "Identifier" || gv(u2) && mv(hv(Ev(u2))) && String(u2.value) === hv(Ev(u2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && bv.get(i2))) {
      const n3 = dv(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
      return e20.call((e21) => fv(e21, n3, t2), "key");
    }
    return Dv(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !bv.get(i2)) ? e20.call((e21) => fv(e21, /^\d/.test(u2.value) ? hv(u2.value) : u2.value, t2), "key") : n2("key");
  }
  var vv = {printProperty: function(e20, t2, n2) {
    return e20.getValue().shorthand ? n2("value") : Cv(e20, t2, n2, Av(e20, t2, n2), ":", "value");
  }, printPropertyKey: Av};
  const {printDanglingComments: Fv, printCommentsSeparately: Sv} = Wf, {getNextNonSpaceNonCommentCharacterIndex: xv} = yi$2, {builders: {line: wv, softline: Tv, group: Bv, indent: Nv, ifBreak: kv, hardline: Pv, join: Ov, indentIfBreak: Iv}, utils: {removeLines: Lv, willBreak: jv}} = eu$1, {ArgExpansionBailout: _v} = bo$2, {getFunctionParameters: Mv, hasLeadingOwnLineComment: Rv, isFlowAnnotationComment: $v, isJsxNode: Vv, isTemplateOnItsOwnLine: Wv, shouldPrintComma: qv, startsWithNoLookaheadToken: Uv, isBinaryish: zv, isLineComment: Gv, hasComment: Hv, getComments: Jv, CommentCheckFlags: Xv, isCallLikeExpression: Yv, isCallExpression: Kv, getCallArguments: Qv, hasNakedLeftSide: Zv, getLeftSide: eF} = Gh, {locEnd: tF} = zc, {printFunctionParameters: nF, shouldGroupFunctionParameters: rF} = FA, {printPropertyKey: iF} = vv, {printFunctionTypeParameters: uF} = BE;
  function oF(e20, t2, n2) {
    const r2 = e20.getNode(), i2 = nF(e20, n2, t2), u2 = aF(e20, n2, t2), o2 = rF(r2, u2), s2 = [uF(e20, t2, n2), Bv([o2 ? Bv(i2) : i2, u2])];
    return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
  }
  function sF(e20, t2) {
    if (t2.arrowParens === "always")
      return false;
    if (t2.arrowParens === "avoid") {
      return function(e21) {
        const t3 = Mv(e21);
        return !(t3.length !== 1 || e21.typeParameters || Hv(e21, Xv.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || Hv(t3[0]) || t3[0].optional || e21.predicate || e21.returnType);
      }(e20.getValue());
    }
    return false;
  }
  function aF(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2("returnType");
    if (r2.returnType && $v(n2.originalText, r2.returnType))
      return [" /*: ", i2, " */"];
    const u2 = [i2];
    return r2.returnType && r2.returnType.typeAnnotation && u2.unshift(": "), r2.predicate && u2.push(r2.returnType ? " " : ": ", t2("predicate")), u2;
  }
  function cF(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
    r2.argument && (!function(e21, t3) {
      if (Rv(e21.originalText, t3))
        return true;
      if (Zv(t3)) {
        let n3, r3 = t3;
        for (; n3 = eF(r3); )
          if (r3 = n3, Rv(e21.originalText, r3))
            return true;
      }
      return false;
    }(t2, r2.argument) ? zv(r2.argument) || r2.argument.type === "SequenceExpression" ? u2.push(Bv([kv(" (", " "), Nv([Tv, n2("argument")]), Tv, kv(")")])) : u2.push(" ", n2("argument")) : u2.push([" (", Nv([Pv, n2("argument")]), Pv, ")"]));
    const o2 = Jv(r2), s2 = Ln$2(o2), a2 = s2 && Gv(s2);
    return a2 && u2.push(i2), Hv(r2, Xv.Dangling) && u2.push(" ", Fv(e20, t2, true)), a2 || u2.push(i2), u2;
  }
  var lF = {printFunction: function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    let u2 = false;
    if ((i2.type === "FunctionDeclaration" || i2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
      const t3 = e20.getParentNode();
      Kv(t3) && Qv(t3).length > 1 && (u2 = true);
    }
    const o2 = [];
    i2.type === "TSDeclareFunction" && i2.declare && o2.push("declare "), i2.async && o2.push("async "), i2.generator ? o2.push("function* ") : o2.push("function "), i2.id && o2.push(t2("id"));
    const s2 = nF(e20, t2, n2, u2), a2 = aF(e20, t2, n2), c2 = rF(i2, a2);
    return o2.push(uF(e20, n2, t2), Bv([c2 ? Bv(s2) : s2, a2]), i2.body ? " " : "", t2("body")), !n2.semi || !i2.declare && i2.body || o2.push(";"), o2;
  }, printArrowFunction: function(e20, t2, n2, r2) {
    let i2 = e20.getValue();
    const u2 = [], o2 = [];
    let s2 = false;
    if (function a3() {
      const c3 = function(e21, t3, n3, r3) {
        const i3 = [];
        if (e21.getValue().async && i3.push("async "), sF(e21, t3))
          i3.push(n3(["params", 0]));
        else {
          const u4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
          let o3 = aF(e21, n3, t3);
          if (u4) {
            if (jv(o3))
              throw new _v();
            o3 = Bv(Lv(o3));
          }
          i3.push(Bv([nF(e21, n3, t3, u4, true), o3]));
        }
        const u3 = Fv(e21, t3, true, (e22) => {
          const n4 = xv(t3.originalText, e22, tF);
          return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
        });
        return u3 && i3.push(" ", u3), i3;
      }(e20, t2, n2, r2);
      if (u2.length === 0)
        u2.push(c3);
      else {
        const {leading: n3, trailing: r3} = Sv(e20, t2);
        u2.push([n3, c3]), o2.unshift(r3);
      }
      s2 = s2 || i2.returnType && Mv(i2).length > 0 || i2.typeParameters || Mv(i2).some((e21) => e21.type !== "Identifier"), i2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? o2.unshift(n2("body", r2)) : (i2 = i2.body, e20.call(a3, "body"));
    }(), u2.length > 1)
      return function(e21, t3, n3, r3, i3, u3) {
        const o3 = e21.getName(), s3 = e21.getParentNode(), a3 = Yv(s3) && o3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = u3.body.type !== "BlockStatement" && u3.body.type !== "ObjectExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
        return Bv([Bv(Nv([a3 || c3 ? Tv : "", Bv(Ov([" =>", wv], n3), {shouldBreak: r3})]), {id: f2, shouldBreak: p3}), " =>", Iv(l3 ? Nv([wv, i3]) : [" ", i3], {groupId: f2}), a3 ? kv(Tv, "", {groupId: f2}) : ""]);
      }(e20, r2, u2, s2, o2, i2);
    const a2 = u2;
    if (a2.push(" =>"), !Rv(t2.originalText, i2.body) && (i2.body.type === "ArrayExpression" || i2.body.type === "ObjectExpression" || i2.body.type === "BlockStatement" || Vv(i2.body) || Wv(i2.body, t2.originalText) || i2.body.type === "ArrowFunctionExpression" || i2.body.type === "DoExpression"))
      return Bv([...a2, " ", o2]);
    if (i2.body.type === "SequenceExpression")
      return Bv([...a2, Bv([" (", Nv([Tv, o2]), Tv, ")"])]);
    const c2 = (r2 && r2.expandLastArg || e20.getParentNode().type === "JSXExpressionContainer") && !Hv(i2), l2 = r2 && r2.expandLastArg && qv(t2, "all"), p2 = i2.body.type === "ConditionalExpression" && !Uv(i2.body, false);
    return Bv([...a2, Bv([Nv([wv, p2 ? kv("", "(") : "", o2, p2 ? kv("", ")") : ""]), c2 ? [kv(l2 ? "," : ""), Tv] : ""])]);
  }, printMethod: function(e20, t2, n2) {
    const r2 = e20.getNode(), {kind: i2} = r2, u2 = r2.value || r2, o2 = [];
    return i2 && i2 !== "init" && i2 !== "method" && i2 !== "constructor" ? (mf.ok(i2 === "get" || i2 === "set"), o2.push(i2, " ")) : u2.async && o2.push("async "), u2.generator && o2.push("*"), o2.push(iF(e20, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === u2 ? o2.push(oF(e20, t2, n2)) : u2.type === "FunctionExpression" ? o2.push(e20.call((e21) => oF(e21, t2, n2), "value")) : o2.push(n2("value")), o2;
  }, printReturnStatement: function(e20, t2, n2) {
    return ["return", cF(e20, t2, n2)];
  }, printThrowStatement: function(e20, t2, n2) {
    return ["throw", cF(e20, t2, n2)];
  }, printMethodInternal: oF, shouldPrintParamsWithoutParens: sF};
  const {isNonEmptyArray: pF, hasNewline: fF} = yi$2, {builders: {line: dF, hardline: hF, join: gF, breakParent: mF, group: yF}} = eu$1, {locStart: DF, locEnd: EF} = zc, {getParentExportDeclaration: CF} = Gh;
  function bF(e20, t2) {
    return e20.decorators.some((e21) => fF(t2.originalText, EF(e21)));
  }
  function AF(e20) {
    if (e20.type !== "ExportDefaultDeclaration" && e20.type !== "ExportNamedDeclaration" && e20.type !== "DeclareExportDeclaration")
      return false;
    const t2 = e20.declaration && e20.declaration.decorators;
    return pF(t2) && DF(e20, {ignoreDecorators: true}) > DF(t2[0]);
  }
  var vF = {printDecorators: function(e20, t2, n2) {
    const r2 = e20.getValue(), {decorators: i2} = r2;
    if (!pF(i2) || AF(e20.getParentNode()))
      return;
    const u2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || bF(r2, t2);
    return [CF(e20) ? hF : u2 ? mF : "", gF(dF, e20.map(n2, "decorators")), dF];
  }, printClassMemberDecorators: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return yF([gF(dF, e20.map(n2, "decorators")), bF(r2, t2) ? hF : dF]);
  }, printDecoratorsBeforeExport: function(e20, t2, n2) {
    return [gF(hF, e20.map(n2, "declaration", "decorators")), hF];
  }, hasDecoratorsBeforeExport: AF};
  const {isNonEmptyArray: FF, createGroupIdMapper: SF} = yi$2, {printComments: xF, printDanglingComments: wF} = Wf, {builders: {join: TF, line: BF, hardline: NF, softline: kF, group: PF, indent: OF, ifBreak: IF}} = eu$1, {hasComment: LF, CommentCheckFlags: jF} = Gh, {getTypeParametersGroupId: _F} = pv, {printMethod: MF} = lF, {printOptionalToken: RF, printTypeAnnotation: $F} = BE, {printPropertyKey: VF} = vv, {printAssignment: WF} = Qb, {printClassMemberDecorators: qF} = vF;
  const UF = SF("heritageGroup");
  function zF(e20) {
    return e20.typeParameters && !LF(e20.typeParameters, jF.Trailing | jF.Line) && !function(e21) {
      return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e21[t2])).length > 1;
    }(e20);
  }
  function GF(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    if (!FF(i2[r2]))
      return "";
    const u2 = wF(e20, t2, true, ({marker: e21}) => e21 === r2);
    return [zF(i2) ? IF(" ", BF, {groupId: _F(i2.typeParameters)}) : BF, u2, u2 && NF, r2, PF(OF([BF, TF([",", BF], e20.map(n2, r2))]))];
  }
  function HF(e20, t2, n2) {
    const r2 = n2("superClass");
    return e20.getParentNode().type === "AssignmentExpression" ? PF(IF(["(", OF([kF, r2]), kF, ")"], r2)) : r2;
  }
  var JF = {printClass: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.abstract && i2.push("abstract "), i2.push("class");
    const u2 = r2.id && LF(r2.id, jF.Trailing) || r2.superClass && LF(r2.superClass) || FF(r2.extends) || FF(r2.mixins) || FF(r2.implements), o2 = [], s2 = [];
    if (r2.id && o2.push(" ", n2("id")), o2.push(n2("typeParameters")), r2.superClass) {
      const r3 = ["extends ", HF(e20, t2, n2), n2("superTypeParameters")], i3 = e20.call((e21) => xF(e21, r3, t2), "superClass");
      u2 ? s2.push(BF, PF(i3)) : s2.push(" ", i3);
    } else
      s2.push(GF(e20, t2, n2, "extends"));
    if (s2.push(GF(e20, t2, n2, "mixins"), GF(e20, t2, n2, "implements")), u2) {
      let e21;
      e21 = zF(r2) ? [...o2, OF(s2)] : OF([...o2, s2]), i2.push(PF(e21, {id: UF(r2)}));
    } else
      i2.push(...o2, ...s2);
    return i2.push(" ", n2("body")), i2;
  }, printClassMethod: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.readonly && i2.push("readonly "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), i2.push(MF(e20, t2, n2)), i2;
  }, printClassProperty: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = t2.semi ? ";" : "";
    return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractClassProperty" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), r2.variance && i2.push(n2("variance")), i2.push(VF(e20, t2, n2), RF(e20), $F(e20, t2, n2)), [WF(e20, t2, n2, i2, " =", "value"), u2];
  }, printHardlineAfterHeritage: function(e20) {
    return IF(NF, "", {groupId: UF(e20)});
  }};
  const {isNonEmptyArray: XF} = yi$2, {builders: {join: YF, line: KF, group: QF, indent: ZF, ifBreak: eS}} = eu$1, {hasComment: tS, identity: nS, CommentCheckFlags: rS} = Gh, {getTypeParametersGroupId: iS} = pv, {printTypeScriptModifiers: uS} = BE;
  var oS = {printInterface: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.type === "TSInterfaceDeclaration" && i2.push(r2.abstract ? "abstract " : "", uS(e20, t2, n2)), i2.push("interface");
    const u2 = [], o2 = [];
    r2.type !== "InterfaceTypeAnnotation" && u2.push(" ", n2("id"), n2("typeParameters"));
    const s2 = r2.typeParameters && !tS(r2.typeParameters, rS.Trailing | rS.Line);
    return XF(r2.extends) && o2.push(s2 ? eS(" ", KF, {groupId: iS(r2.typeParameters)}) : KF, "extends ", (r2.extends.length === 1 ? nS : ZF)(YF([",", KF], e20.map(n2, "extends")))), r2.id && tS(r2.id, rS.Trailing) || XF(r2.extends) ? s2 ? i2.push(QF([...u2, ZF(o2)])) : i2.push(QF(ZF([...u2, ...o2]))) : i2.push(...u2, ...o2), i2.push(" ", n2("body")), QF(i2);
  }};
  const {isNonEmptyArray: sS} = yi$2, {builders: {softline: aS, group: cS, indent: lS, join: pS, line: fS, ifBreak: dS, hardline: hS}} = eu$1, {printDanglingComments: gS} = Wf, {hasComment: mS, CommentCheckFlags: yS, shouldPrintComma: DS, needsHardlineAfterDanglingComment: ES} = Gh, {locStart: CS, hasSameLoc: bS} = zc, {hasDecoratorsBeforeExport: AS, printDecoratorsBeforeExport: vS} = vF;
  function FS(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2.source)
      return "";
    const i2 = [];
    return xS(r2, t2) || i2.push(" from"), i2.push(" ", n2("source")), i2;
  }
  function SS(e20, t2, n2) {
    const r2 = e20.getValue();
    if (xS(r2, t2))
      return "";
    const i2 = [" "];
    if (sS(r2.specifiers)) {
      const u2 = [], o2 = [];
      if (e20.each(() => {
        const t3 = e20.getValue().type;
        if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
          u2.push(n2());
        else {
          if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
            throw new Error(`Unknown specifier type ${JSON.stringify(t3)}`);
          o2.push(n2());
        }
      }, "specifiers"), i2.push(pS(", ", u2)), o2.length > 0) {
        u2.length > 0 && i2.push(", ");
        o2.length > 1 || u2.length > 0 || r2.specifiers.some((e21) => mS(e21)) ? i2.push(cS(["{", lS([t2.bracketSpacing ? fS : aS, pS([",", fS], o2)]), dS(DS(t2) ? "," : ""), t2.bracketSpacing ? fS : aS, "}"])) : i2.push(["{", t2.bracketSpacing ? " " : "", ...o2, t2.bracketSpacing ? " " : "", "}"]);
      }
    } else
      i2.push("{}");
    return i2;
  }
  function xS(e20, t2) {
    const {type: n2, importKind: r2, source: i2, specifiers: u2} = e20;
    return n2 === "ImportDeclaration" && !sS(u2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(CS(e20), CS(i2)));
  }
  function wS(e20, t2, n2) {
    const r2 = e20.getNode();
    return sS(r2.assertions) ? [" assert {", t2.bracketSpacing ? " " : "", pS(", ", e20.map(n2, "assertions")), t2.bracketSpacing ? " " : "", "}"] : "";
  }
  var TS = {printImportDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], {importKind: o2} = r2;
    return u2.push("import"), o2 && o2 !== "value" && u2.push(" ", o2), u2.push(SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
  }, printExportDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    AS(r2) && i2.push(vS(e20, t2, n2));
    const {type: u2, exportKind: o2, declaration: s2} = r2;
    return i2.push("export"), (r2.default || u2 === "ExportDefaultDeclaration") && i2.push(" default"), mS(r2, yS.Dangling) && (i2.push(" ", gS(e20, t2, true)), ES(r2) && i2.push(hS)), s2 ? i2.push(" ", n2("declaration")) : i2.push(o2 === "type" ? " type" : "", SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2)), function(e21, t3) {
      if (!t3.semi)
        return false;
      const {type: n3, declaration: r3} = e21, i3 = e21.default || n3 === "ExportDefaultDeclaration";
      if (!r3)
        return true;
      const {type: u3} = r3;
      if (i3 && u3 !== "ClassDeclaration" && u3 !== "FunctionDeclaration" && u3 !== "TSInterfaceDeclaration" && u3 !== "DeclareClass" && u3 !== "DeclareFunction" && u3 !== "TSDeclareFunction" && u3 !== "EnumDeclaration")
        return true;
      return false;
    }(r2, t2) && i2.push(";"), i2;
  }, printExportAllDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], {exportKind: o2, exported: s2} = r2;
    return u2.push("export"), o2 === "type" && u2.push(" type"), u2.push(" *"), s2 && u2.push(" as ", n2("exported")), u2.push(FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
  }, printModuleSpecifier: function(e20, t2, n2) {
    const r2 = e20.getNode(), {type: i2, importKind: u2} = r2, o2 = [];
    i2 === "ImportSpecifier" && u2 && o2.push(u2, " ");
    const s2 = i2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
    let l2 = "", p2 = "";
    return i2 === "ExportNamespaceSpecifier" || i2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && bS(r2[a2], r2[c2]) || (p2 = n2(c2)), o2.push(l2, l2 && p2 ? " as " : "", p2), o2;
  }};
  const {printDanglingComments: BS} = Wf, {builders: {line: NS, softline: kS, group: PS, indent: OS, ifBreak: IS, hardline: LS}} = eu$1, {getLast: jS, hasNewlineInRange: _S, hasNewline: MS, isNonEmptyArray: RS} = yi$2, {shouldPrintComma: $S, hasComment: VS, getComments: WS, CommentCheckFlags: qS, isNextLineEmpty: US} = Gh, {locStart: zS, locEnd: GS} = zc, {printOptionalToken: HS, printTypeAnnotation: JS} = BE, {shouldHugFunctionParameters: XS} = FA, {shouldHugType: YS} = GA, {printHardlineAfterHeritage: KS} = JF;
  var QS = {printObject: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue();
    let u2;
    u2 = i2.type === "TSTypeLiteral" ? "members" : i2.type === "TSInterfaceBody" ? "body" : "properties";
    const o2 = i2.type === "ObjectTypeAnnotation", s2 = [u2];
    o2 && s2.push("indexers", "callProperties", "internalSlots");
    const a2 = s2.map((e21) => i2[e21][0]).sort((e21, t3) => zS(e21) - zS(t3))[0], c2 = e20.getParentNode(0), l2 = o2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e20.getName() === "body", p2 = i2.type === "TSInterfaceBody" || l2 || i2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && i2.properties.some((e21) => e21.value && (e21.value.type === "ObjectPattern" || e21.value.type === "ArrayPattern")) || i2.type !== "ObjectPattern" && a2 && _S(t2.originalText, zS(i2), zS(a2)), f2 = l2 ? ";" : i2.type === "TSInterfaceBody" || i2.type === "TSTypeLiteral" ? IS(r2, ";") : ",", d2 = i2.type === "RecordExpression" ? "#{" : i2.exact ? "{|" : "{", h2 = i2.exact ? "|}" : "}", g2 = [];
    for (const t3 of s2)
      e20.each((e21) => {
        const t4 = e21.getValue();
        g2.push({node: t4, printed: n2(), loc: zS(t4)});
      }, t3);
    s2.length > 1 && g2.sort((e21, t3) => e21.loc - t3.loc);
    let m2 = [];
    const y2 = g2.map((e21) => {
      const n3 = [...m2, PS(e21.printed)];
      return m2 = [f2, NS], e21.node.type !== "TSPropertySignature" && e21.node.type !== "TSMethodSignature" && e21.node.type !== "TSConstructSignatureDeclaration" || !VS(e21.node, qS.PrettierIgnore) || m2.shift(), US(e21.node, t2) && m2.push(LS), n3;
    });
    if (i2.inexact) {
      let n3;
      if (VS(i2, qS.Dangling)) {
        const r3 = VS(i2, qS.Line);
        n3 = [BS(e20, t2, true), r3 || MS(t2.originalText, GS(jS(WS(i2)))) ? LS : NS, "..."];
      } else
        n3 = ["..."];
      y2.push([...m2, ...n3]);
    }
    const D2 = jS(i2[u2]), E2 = !(i2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && VS(D2, qS.PrettierIgnore));
    let C2;
    if (y2.length === 0) {
      if (!VS(i2, qS.Dangling))
        return [d2, h2, JS(e20, t2, n2)];
      C2 = PS([d2, BS(e20, t2), kS, h2, HS(e20), JS(e20, t2, n2)]);
    } else
      C2 = [l2 && RS(i2.properties) ? KS(c2) : "", d2, OS([t2.bracketSpacing ? NS : kS, ...y2]), IS(E2 && (f2 !== "," || $S(t2)) ? f2 : ""), t2.bracketSpacing ? NS : kS, h2, HS(e20), JS(e20, t2, n2)];
    return e20.match((e21) => e21.type === "ObjectPattern" && !e21.decorators, (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e20.match(YS, (e21, t3) => t3 === "typeAnnotation", (e21, t3) => t3 === "typeAnnotation", (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e20.match((e21) => e21.type === "ObjectPattern", (e21) => e21.type === "AssignmentExpression" || e21.type === "VariableDeclarator") ? C2 : PS(C2, {shouldBreak: p2});
  }};
  const {printDanglingComments: ZS} = Wf, {printString: ex, printNumber: tx} = yi$2, {builders: {hardline: nx, softline: rx, group: ix, indent: ux}} = eu$1, {getParentExportDeclaration: ox, isFunctionNotation: sx, isGetterOrSetter: ax, rawText: cx, shouldPrintComma: lx} = Gh, {locStart: px, locEnd: fx} = zc, {printClass: dx} = JF, {printOpaqueType: hx, printTypeAlias: gx, printIntersectionType: mx, printUnionType: yx, printFunctionType: Dx, printTupleType: Ex, printIndexedAccessType: Cx} = GA, {printInterface: bx} = oS, {printTypeParameter: Ax, printTypeParameters: vx} = pv, {printExportDeclaration: Fx, printExportAllDeclaration: Sx} = TS, {printArrayItems: xx} = QE, {printObject: wx} = QS, {printPropertyKey: Tx} = vv, {printOptionalToken: Bx, printTypeAnnotation: Nx, printRestSpread: kx} = BE;
  function Px(e20, t2) {
    const n2 = ox(e20);
    return n2 ? (mf.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
  }
  var Ox = {printFlow: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "DeclareClass":
        return Px(e20, dx(e20, t2, n2));
      case "DeclareFunction":
        return Px(e20, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), i2]);
      case "DeclareModule":
        return Px(e20, ["module ", n2("id"), " ", n2("body")]);
      case "DeclareModuleExports":
        return Px(e20, ["module.exports", ": ", n2("typeAnnotation"), i2]);
      case "DeclareVariable":
        return Px(e20, ["var ", n2("id"), i2]);
      case "DeclareOpaqueType":
        return Px(e20, hx(e20, t2, n2));
      case "DeclareInterface":
        return Px(e20, bx(e20, t2, n2));
      case "DeclareTypeAlias":
        return Px(e20, gx(e20, t2, n2));
      case "DeclareExportDeclaration":
        return Px(e20, Fx(e20, t2, n2));
      case "DeclareExportAllDeclaration":
        return Px(e20, Sx(e20, t2, n2));
      case "OpaqueType":
        return hx(e20, t2, n2);
      case "TypeAlias":
        return gx(e20, t2, n2);
      case "IntersectionTypeAnnotation":
        return mx(e20, t2, n2);
      case "UnionTypeAnnotation":
        return yx(e20, t2, n2);
      case "FunctionTypeAnnotation":
        return Dx(e20, t2, n2);
      case "TupleTypeAnnotation":
        return Ex(e20, t2, n2);
      case "GenericTypeAnnotation":
        return [n2("id"), vx(e20, t2, n2, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return Cx(e20, t2, n2);
      case "TypeAnnotation":
        return n2("typeAnnotation");
      case "TypeParameter":
        return Ax(e20, t2, n2);
      case "TypeofTypeAnnotation":
        return ["typeof ", n2("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [n2("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(r2.value);
      case "EnumDeclaration":
        return ["enum ", n2("id"), " ", n2("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        if (r2.type === "EnumSymbolBody" || r2.explicitType) {
          let e21 = null;
          switch (r2.type) {
            case "EnumBooleanBody":
              e21 = "boolean";
              break;
            case "EnumNumberBody":
              e21 = "number";
              break;
            case "EnumStringBody":
              e21 = "string";
              break;
            case "EnumSymbolBody":
              e21 = "symbol";
          }
          u2.push("of ", e21, " ");
        }
        if (r2.members.length !== 0 || r2.hasUnknownMembers) {
          const i3 = r2.members.length > 0 ? [nx, xx(e20, t2, "members", n2), r2.hasUnknownMembers || lx(t2) ? "," : ""] : [];
          u2.push(ix(["{", ux([...i3, ...r2.hasUnknownMembers ? [nx, "..."] : []]), ZS(e20, t2, true), nx, "}"]));
        } else
          u2.push(ix(["{", ZS(e20, t2), rx, "}"]));
        return u2;
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
      case "EnumDefaultedMember":
        return n2("id");
      case "FunctionTypeParam": {
        const t3 = r2.name ? n2("name") : e20.getParentNode().this === r2 ? "this" : "";
        return [t3, Bx(e20), t3 ? ": " : "", n2("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return bx(e20, t2, n2);
      case "ClassImplements":
      case "InterfaceExtends":
        return [n2("id"), n2("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", n2("typeAnnotation")];
      case "Variance": {
        const {kind: e21} = r2;
        return mf.ok(e21 === "plus" || e21 === "minus"), e21 === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return r2.static && u2.push("static "), u2.push(n2("value")), u2;
      case "ObjectTypeIndexer":
        return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
      case "ObjectTypeProperty": {
        let i3 = "";
        return r2.proto ? i3 = "proto " : r2.static && (i3 = "static "), [i3, ax(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", Tx(e20, t2, n2), Bx(e20), sx(r2) ? "" : ": ", n2("value")];
      }
      case "ObjectTypeAnnotation":
        return wx(e20, t2, n2);
      case "ObjectTypeInternalSlot":
        return [r2.static ? "static " : "", "[[", n2("id"), "]]", Bx(e20), r2.method ? "" : ": ", n2("value")];
      case "ObjectTypeSpreadProperty":
        return kx(e20, t2, n2);
      case "QualifiedTypeIdentifier":
        return [n2("qualification"), ".", n2("id")];
      case "StringLiteralTypeAnnotation":
        return ex(cx(r2), t2);
      case "NumberLiteralTypeAnnotation":
        mf.strictEqual(typeof r2.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return r2.extra ? tx(r2.extra.raw) : tx(r2.raw);
      case "TypeCastExpression":
        return ["(", n2("expression"), Nx(e20, t2, n2), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        const i3 = vx(e20, t2, n2, "params");
        if (t2.parser === "flow") {
          const e21 = px(r2), n3 = fx(r2), u3 = t2.originalText.lastIndexOf("/*", e21), o2 = t2.originalText.indexOf("*/", n3);
          if (u3 !== -1 && o2 !== -1) {
            const e22 = t2.originalText.slice(u3 + 2, o2).trim();
            if (e22.startsWith("::") && !e22.includes("/*") && !e22.includes("*/"))
              return ["/*:: ", i3, " */"];
          }
        }
        return i3;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", n2("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(r2.type));
    }
  }};
  const {hasNewlineInRange: Ix} = yi$2, {isJsxNode: Lx, isBlockComment: jx, getComments: _x, isCallExpression: Mx, isMemberExpression: Rx} = Gh, {locStart: $x, locEnd: Vx} = zc, {builders: {line: Wx, softline: qx, group: Ux, indent: zx, align: Gx, ifBreak: Hx, dedent: Jx, breakParent: Xx}} = eu$1;
  function Yx(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "alternate" : "falseType", o2 = e20.getParentNode(), s2 = i2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
    return o2.type === r2.type && o2[u2] === r2 ? Gx(2, s2) : s2;
  }
  const Kx = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
  var Qx = {printTernary: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "consequent" : "trueType", o2 = i2 ? "alternate" : "falseType", s2 = i2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[u2], c2 = r2[o2], l2 = [];
    let p2 = false;
    const f2 = e20.getParentNode(), d2 = f2.type === r2.type && s2.some((e21) => f2[e21] === r2);
    let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
    do {
      g2 = h2 || r2, h2 = e20.getParentNode(y2), y2++;
    } while (h2 && h2.type === r2.type && s2.every((e21) => h2[e21] !== g2));
    const D2 = h2 || f2, E2 = g2;
    if (i2 && (Lx(r2[s2[0]]) || Lx(a2) || Lx(c2) || function(e21) {
      const t3 = [e21];
      for (let e22 = 0; e22 < t3.length; e22++) {
        const n3 = t3[e22];
        for (const e23 of ["test", "consequent", "alternate"]) {
          const r3 = n3[e23];
          if (Lx(r3))
            return true;
          r3.type === "ConditionalExpression" && t3.push(r3);
        }
      }
      return false;
    }(E2))) {
      p2 = true, m2 = true;
      const e21 = (e22) => [Hx("("), zx([qx, e22]), qx, Hx(")")], t3 = (e22) => e22.type === "NullLiteral" || e22.type === "Literal" && e22.value === null || e22.type === "Identifier" && e22.name === "undefined";
      l2.push(" ? ", t3(a2) ? n2(u2) : e21(n2(u2)), " : ", c2.type === r2.type || t3(c2) ? n2(o2) : e21(n2(o2)));
    } else {
      const e21 = [Wx, "? ", a2.type === r2.type ? Hx("", "(") : "", Gx(2, n2(u2)), a2.type === r2.type ? Hx("", ")") : "", Wx, ": ", c2.type === r2.type ? n2(o2) : Gx(2, n2(o2))];
      l2.push(f2.type !== r2.type || f2[o2] === r2 || d2 ? e21 : t2.useTabs ? Jx(zx(e21)) : Gx(Math.max(0, t2.tabWidth - 2), e21));
    }
    const C2 = [...s2.map((e21) => _x(r2[e21])), _x(a2), _x(c2)].flat().some((e21) => jx(e21) && Ix(t2.originalText, $x(e21), Vx(e21))), b2 = !p2 && (Rx(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, A2 = function(e21) {
      const t3 = e21.getValue();
      if (t3.type !== "ConditionalExpression")
        return false;
      let n3, r3 = t3;
      for (let t4 = 0; !n3; t4++) {
        const i3 = e21.getParentNode(t4);
        Mx(i3) && i3.callee === r3 || Rx(i3) && i3.object === r3 || i3.type === "TSNonNullExpression" && i3.expression === r3 ? r3 = i3 : i3.type === "NewExpression" && i3.callee === r3 || i3.type === "TSAsExpression" && i3.expression === r3 ? (n3 = e21.getParentNode(t4 + 1), r3 = i3) : n3 = i3;
      }
      return r3 !== t3 && n3[Kx.get(n3.type)] === r3;
    }(e20), v2 = (F2 = [Yx(e20, 0, n2), m2 ? l2 : zx(l2), i2 && b2 && !A2 ? qx : ""], f2 === D2 ? Ux(F2, {shouldBreak: C2}) : C2 ? [F2, Xx] : F2);
    var F2;
    return d2 || A2 ? Ux([zx([qx, v2]), qx]) : v2;
  }};
  const {builders: {hardline: Zx}} = eu$1, {getLeftSidePathName: ew, hasNakedLeftSide: tw, isJsxNode: nw, isTheOnlyJsxElementInMarkdown: rw, hasComment: iw, CommentCheckFlags: uw, isNextLineEmpty: ow} = Gh, {shouldPrintParamsWithoutParens: sw} = lF;
  function aw(e20, t2, n2, r2) {
    const i2 = e20.getValue(), u2 = [], o2 = i2.type === "ClassBody", s2 = function(e21) {
      for (let t3 = e21.length - 1; t3 >= 0; t3--) {
        const n3 = e21[t3];
        if (n3.type !== "EmptyStatement")
          return n3;
      }
    }(i2[r2]);
    return e20.each((e21, r3, i3) => {
      const a2 = e21.getValue();
      if (a2.type === "EmptyStatement")
        return;
      const c2 = n2();
      t2.semi || o2 || rw(t2, e21) || !function(e22, t3) {
        if (e22.getNode().type !== "ExpressionStatement")
          return false;
        return e22.call((e23) => cw(e23, t3), "expression");
      }(e21, t2) ? u2.push(c2) : iw(a2, uw.Leading) ? u2.push(n2([], {needsSemi: true})) : u2.push(";", c2), !t2.semi && o2 && lw(a2) && function(e22, t3) {
        const n3 = e22.key && e22.key.name;
        if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e22.value || e22.typeAnnotation))
          return true;
        if (!t3)
          return false;
        if (t3.static || t3.accessibility)
          return false;
        if (!t3.computed) {
          const e23 = t3.key && t3.key.name;
          if (e23 === "in" || e23 === "instanceof")
            return true;
        }
        if (lw(t3) && t3.variance && !t3.static && !t3.declare)
          return true;
        switch (t3.type) {
          case "ClassProperty":
          case "PropertyDefinition":
          case "TSAbstractClassProperty":
            return t3.computed;
          case "MethodDefinition":
          case "TSAbstractMethodDefinition":
          case "ClassMethod":
          case "ClassPrivateMethod": {
            if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
              return false;
            const e23 = t3.value ? t3.value.generator : t3.generator;
            return !(!t3.computed && !e23);
          }
          case "TSIndexSignature":
            return true;
        }
        return false;
      }(a2, i3[r3 + 1]) && u2.push(";"), a2 !== s2 && (u2.push(Zx), ow(a2, t2) && u2.push(Zx));
    }, r2), u2;
  }
  function cw(e20, t2) {
    const n2 = e20.getValue();
    switch (n2.type) {
      case "ParenthesizedExpression":
      case "TypeCastExpression":
      case "ArrayExpression":
      case "ArrayPattern":
      case "TemplateLiteral":
      case "TemplateElement":
      case "RegExpLiteral":
        return true;
      case "ArrowFunctionExpression":
        if (!sw(e20, t2))
          return true;
        break;
      case "UnaryExpression": {
        const {prefix: e21, operator: t3} = n2;
        if (e21 && (t3 === "+" || t3 === "-"))
          return true;
        break;
      }
      case "BindExpression":
        if (!n2.object)
          return true;
        break;
      case "Literal":
        if (n2.regex)
          return true;
        break;
      default:
        if (nw(n2))
          return true;
    }
    return !!Qy(e20, t2) || !!tw(n2) && e20.call((e21) => cw(e21, t2), ...ew(e20, n2));
  }
  const lw = ({type: e20}) => e20 === "ClassProperty" || e20 === "PropertyDefinition" || e20 === "ClassPrivateProperty";
  var pw = {printBody: function(e20, t2, n2) {
    return aw(e20, t2, n2, "body");
  }, printSwitchCaseConsequent: function(e20, t2, n2) {
    return aw(e20, t2, n2, "consequent");
  }};
  const {printDanglingComments: fw} = Wf, {isNonEmptyArray: dw} = yi$2, {builders: {hardline: hw, indent: gw}} = eu$1, {hasComment: mw, CommentCheckFlags: yw, isNextLineEmpty: Dw} = Gh, {printHardlineAfterHeritage: Ew} = JF, {printBody: Cw} = pw;
  function bw(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = dw(r2.directives), u2 = r2.body.some((e21) => e21.type !== "EmptyStatement"), o2 = mw(r2, yw.Dangling);
    if (!i2 && !u2 && !o2)
      return "";
    const s2 = [];
    if (i2 && e20.each((e21, r3, i3) => {
      s2.push(n2()), (r3 < i3.length - 1 || u2 || o2) && (s2.push(hw), Dw(e21.getValue(), t2) && s2.push(hw));
    }, "directives"), u2 && s2.push(Cw(e20, t2, n2)), o2 && s2.push(fw(e20, t2, true)), r2.type === "Program") {
      const t3 = e20.getParentNode();
      t3 && t3.type === "ModuleExpression" || s2.push(hw);
    }
    return s2;
  }
  var Aw = {printBlock: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    if (r2.type === "StaticBlock" && i2.push("static "), r2.type === "ClassBody" && dw(r2.body)) {
      const t3 = e20.getParentNode();
      i2.push(Ew(t3));
    }
    i2.push("{");
    const u2 = bw(e20, t2, n2);
    if (u2)
      i2.push(gw([hw, u2]), hw);
    else {
      const t3 = e20.getParentNode(), n3 = e20.getParentNode(1);
      t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || i2.push(hw);
    }
    return i2.push("}"), i2;
  }, printBlockBody: bw};
  const {printDanglingComments: vw} = Wf, {hasNewlineInRange: Fw} = yi$2, {builders: {join: Sw, line: xw, hardline: ww, softline: Tw, group: Bw, indent: Nw, conditionalGroup: kw, ifBreak: Pw}} = eu$1, {isLiteral: Ow, getTypeScriptMappedTypeModifier: Iw, shouldPrintComma: Lw, isCallExpression: jw, isMemberExpression: _w} = Gh, {locStart: Mw, locEnd: Rw} = zc, {printOptionalToken: $w, printTypeScriptModifiers: Vw} = BE, {printTernary: Ww} = Qx, {printFunctionParameters: qw, shouldGroupFunctionParameters: Uw} = FA, {printTemplateLiteral: zw} = pg, {printArrayItems: Gw} = QE, {printObject: Hw} = QS, {printClassProperty: Jw, printClassMethod: Xw} = JF, {printTypeParameter: Yw, printTypeParameters: Kw} = pv, {printPropertyKey: Qw} = vv, {printFunction: Zw, printMethodInternal: eT} = lF, {printInterface: tT} = oS, {printBlock: nT} = Aw, {printTypeAlias: rT, printIntersectionType: iT, printUnionType: uT, printFunctionType: oT, printTupleType: sT, printIndexedAccessType: aT} = GA;
  var cT = {printTypescript: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2.type.startsWith("TS"))
      return;
    if (r2.type.endsWith("Keyword"))
      return r2.type.slice(2, -7).toLowerCase();
    const i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        const e21 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = Bw(["<", Nw([Tw, n2("typeAnnotation")]), Tw, ">"]), i3 = [Pw("("), Nw([Tw, n2("expression")]), Tw, Pw(")")];
        return e21 ? kw([[t3, n2("expression")], [t3, Bw(i3, {shouldBreak: true})], [t3, n2("expression")]]) : Bw([t3, n2("expression")]);
      }
      case "TSDeclareFunction":
        return Zw(e20, n2, t2);
      case "TSExportAssignment":
        return ["export = ", n2("expression"), i2];
      case "TSModuleBlock":
        return nT(e20, t2, n2);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return Hw(e20, t2, n2);
      case "TSTypeAliasDeclaration":
        return rT(e20, t2, n2);
      case "TSQualifiedName":
        return Sw(".", [n2("left"), n2("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return Xw(e20, t2, n2);
      case "TSAbstractClassProperty":
        return Jw(e20, t2, n2);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return u2.push(n2("expression")), r2.typeParameters && u2.push(n2("typeParameters")), u2;
      case "TSTemplateLiteralType":
        return zw(e20, n2, t2);
      case "TSNamedTupleMember":
        return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
      case "TSRestType":
        return ["...", n2("typeAnnotation")];
      case "TSOptionalType":
        return [n2("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return tT(e20, t2, n2);
      case "TSClassImplements":
        return [n2("expression"), n2("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return Kw(e20, t2, n2, "params");
      case "TSTypeParameter":
        return Yw(e20, t2, n2);
      case "TSAsExpression": {
        u2.push(n2("expression"), " as ", n2("typeAnnotation"));
        const t3 = e20.getParentNode();
        return jw(t3) && t3.callee === r2 || _w(t3) && t3.object === r2 ? Bw([Nw([Tw, ...u2]), Tw]) : u2;
      }
      case "TSArrayType":
        return [n2("elementType"), "[]"];
      case "TSPropertySignature":
        return r2.readonly && u2.push("readonly "), u2.push(Qw(e20, t2, n2), $w(e20)), r2.typeAnnotation && u2.push(": ", n2("typeAnnotation")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSParameterProperty":
        return r2.accessibility && u2.push(r2.accessibility + " "), r2.export && u2.push("export "), r2.static && u2.push("static "), r2.override && u2.push("override "), r2.readonly && u2.push("readonly "), u2.push(n2("parameter")), u2;
      case "TSTypeQuery":
        return ["typeof ", n2("exprName")];
      case "TSIndexSignature": {
        const u3 = e20.getParentNode(), o2 = r2.parameters.length > 1 ? Pw(Lw(t2) ? "," : "") : "", s2 = Bw([Nw([Tw, Sw([", ", Tw], e20.map(n2, "parameters"))]), o2, Tw]);
        return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", u3.type === "ClassBody" ? i2 : ""];
      }
      case "TSTypePredicate":
        return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
      case "TSNonNullExpression":
        return [n2("expression"), "!"];
      case "TSImportType":
        return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", Kw(e20, t2, n2, "typeParameters")];
      case "TSLiteralType":
        return n2("literal");
      case "TSIndexedAccessType":
        return aT(e20, t2, n2);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
        if (r2.type === "TSConstructorType" && r2.abstract && u2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && u2.push("new "), u2.push(Bw(qw(e20, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
          const e21 = r2.type === "TSConstructorType";
          u2.push(e21 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
        }
        return u2;
      case "TSTypeOperator":
        return [r2.operator, " ", n2("typeAnnotation")];
      case "TSMappedType": {
        const u3 = Fw(t2.originalText, Mw(r2), Rw(r2));
        return Bw(["{", Nw([t2.bracketSpacing ? xw : Tw, r2.readonly ? [Iw(r2.readonly, "readonly"), " "] : "", Vw(e20, t2, n2), n2("typeParameter"), r2.optional ? Iw(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), Pw(i2)]), vw(e20, t2, true), t2.bracketSpacing ? xw : Tw, "}"], {shouldBreak: u3});
      }
      case "TSMethodSignature": {
        const i3 = r2.kind && r2.kind !== "method" ? `${r2.kind} ` : "";
        u2.push(r2.accessibility ? [r2.accessibility, " "] : "", i3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", $w(e20));
        const o2 = qw(e20, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = Uw(r2, c2);
        return u2.push(l2 ? Bw(o2) : o2), a2 && u2.push(": ", Bw(c2)), Bw(u2);
      }
      case "TSNamespaceExportDeclaration":
        return u2.push("export as namespace ", n2("id")), t2.semi && u2.push(";"), Bw(u2);
      case "TSEnumDeclaration":
        return r2.declare && u2.push("declare "), r2.modifiers && u2.push(Vw(e20, t2, n2)), r2.const && u2.push("const "), u2.push("enum ", n2("id"), " "), r2.members.length === 0 ? u2.push(Bw(["{", vw(e20, t2), Tw, "}"])) : u2.push(Bw(["{", Nw([ww, Gw(e20, t2, "members", n2), Lw(t2, "es5") ? "," : ""]), vw(e20, t2, true), ww, "}"])), u2;
      case "TSEnumMember":
        return u2.push(n2("id")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSImportEqualsDeclaration":
        return r2.isExport && u2.push("export "), u2.push("import "), r2.importKind && r2.importKind !== "value" && u2.push(r2.importKind, " "), u2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && u2.push(";"), Bw(u2);
      case "TSExternalModuleReference":
        return ["require(", n2("expression"), ")"];
      case "TSModuleDeclaration": {
        const o2 = e20.getParentNode(), s2 = Ow(r2.id), a2 = o2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
        if (a2)
          u2.push(".");
        else {
          r2.declare && u2.push("declare "), u2.push(Vw(e20, t2, n2));
          const i3 = t2.originalText.slice(Mw(r2), Mw(r2.id));
          r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(i3) || u2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(i3) ? "module " : "namespace ");
        }
        return u2.push(n2("id")), c2 ? u2.push(n2("body")) : r2.body ? u2.push(" ", Bw(n2("body"))) : u2.push(i2), u2;
      }
      case "TSPrivateIdentifier":
        return r2.escapedText;
      case "TSConditionalType":
        return Ww(e20, t2, n2);
      case "TSInferType":
        return ["infer", " ", n2("typeParameter")];
      case "TSIntersectionType":
        return iT(e20, t2, n2);
      case "TSUnionType":
        return uT(e20, t2, n2);
      case "TSFunctionType":
        return oT(e20, t2, n2);
      case "TSTupleType":
        return sT(e20, t2, n2);
      case "TSTypeReference":
        return [n2("typeName"), Kw(e20, t2, n2, "typeParameters")];
      case "TSTypeAnnotation":
        return n2("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return eT(e20, t2, n2);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return ["?", n2("typeAnnotation")];
      case "TSJSDocNonNullableType":
        return ["!", n2("typeAnnotation")];
      default:
        throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r2.type)}.`);
    }
  }};
  const {hasNewline: lT} = yi$2, {builders: {join: pT, hardline: fT}, utils: {replaceTextEndOfLine: dT}} = eu$1, {isLineComment: hT, isBlockComment: gT} = Gh, {locStart: mT, locEnd: yT} = zc;
  var DT = {printComment: function(e20, t2) {
    const n2 = e20.getValue();
    if (hT(n2))
      return t2.originalText.slice(mT(n2), yT(n2)).trimEnd();
    if (gT(n2)) {
      if (function(e22) {
        const t3 = `*${e22.value}*`.split("\n");
        return t3.length > 1 && t3.every((e23) => e23.trim()[0] === "*");
      }(n2)) {
        const e22 = function(e23) {
          const t3 = e23.value.split("\n");
          return ["/*", pT(fT, t3.map((e24, n3) => n3 === 0 ? e24.trimEnd() : " " + (n3 < t3.length - 1 ? e24.trim() : e24.trimStart()))), "*/"];
        }(n2);
        return n2.trailing && !lT(t2.originalText, mT(n2), {backwards: true}) ? [fT, e22] : e22;
      }
      const e21 = yT(n2), r2 = t2.originalText.slice(e21 - 3, e21) === "*-/";
      return ["/*", dT(n2.value), r2 ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(n2));
  }};
  const {printString: ET, printNumber: CT} = yi$2;
  function bT(e20) {
    return e20.toLowerCase();
  }
  function AT({pattern: e20, flags: t2}) {
    return `/${e20}/${t2 = [...t2].sort().join("")}`;
  }
  var vT = {printLiteral: function(e20, t2) {
    const n2 = e20.getNode();
    switch (n2.type) {
      case "RegExpLiteral":
        return AT(n2);
      case "BigIntLiteral":
        return bT(n2.bigint || n2.extra.raw);
      case "NumericLiteral":
        return CT(n2.extra.raw);
      case "StringLiteral":
        return ET(n2.extra.raw, t2);
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(n2.value);
      case "DecimalLiteral":
        return CT(n2.value) + "m";
      case "Literal": {
        if (n2.regex)
          return AT(n2.regex);
        if (n2.bigint)
          return bT(n2.raw);
        if (n2.decimal)
          return CT(n2.decimal) + "m";
        const {value: e21} = n2;
        return typeof e21 == "number" ? CT(n2.raw) : typeof e21 == "string" ? ET(n2.raw, t2) : String(e21);
      }
    }
  }};
  const {printDanglingComments: FT} = Wf, {hasNewline: ST} = yi$2, {builders: {join: xT, line: wT, hardline: TT, softline: BT, group: NT, indent: kT}, utils: {replaceTextEndOfLine: PT}} = eu$1, {insertPragma: OT} = km, {hasFlowShorthandAnnotationComment: IT, hasComment: LT, CommentCheckFlags: jT, isTheOnlyJsxElementInMarkdown: _T, isBlockComment: MT, isLineComment: RT, isNextLineEmpty: $T, needsHardlineAfterDanglingComment: VT, rawText: WT, hasIgnoreComment: qT, isCallExpression: UT, isMemberExpression: zT} = Gh, {locStart: GT, locEnd: HT} = zc, {printHtmlBinding: JT, isVueEventBindingExpression: XT} = uD, {printAngular: YT} = $D, {printJsx: KT, hasJsxIgnoreComment: QT} = AE, {printFlow: ZT} = Ox, {printTypescript: eB} = cT, {printOptionalToken: tB, printBindExpressionCallee: nB, printTypeAnnotation: rB, adjustClause: iB, printRestSpread: uB} = BE, {printImportDeclaration: oB, printExportDeclaration: sB, printExportAllDeclaration: aB, printModuleSpecifier: cB} = TS, {printTernary: lB} = Qx, {printTemplateLiteral: pB} = pg, {printArray: fB} = QE, {printObject: dB} = QS, {printClass: hB, printClassMethod: gB, printClassProperty: mB} = JF, {printProperty: yB} = vv, {printFunction: DB, printArrowFunction: EB, printMethod: CB, printReturnStatement: bB, printThrowStatement: AB} = lF, {printCallExpression: vB} = Fb, {printVariableDeclarator: FB, printAssignmentExpression: SB} = Qb, {printBinaryishExpression: xB} = kD, {printSwitchCaseConsequent: wB} = pw, {printMemberExpression: TB} = _C, {printBlock: BB, printBlockBody: NB} = Aw, {printComment: kB} = DT, {printLiteral: PB} = vT, {printDecorators: OB} = vF;
  function IB(e20, t2) {
    const n2 = WT(e20), r2 = n2.slice(1, -1);
    if (r2.includes('"') || r2.includes("'"))
      return n2;
    const i2 = t2.singleQuote ? "'" : '"';
    return i2 + r2 + i2;
  }
  var LB = {preprocess: Zy, print: function(e20, t2, n2, r2) {
    const i2 = function(e21, t3, n3, r3) {
      const i3 = e21.getValue(), u3 = t3.semi ? ";" : "";
      if (!i3)
        return "";
      if (typeof i3 == "string")
        return i3;
      for (const r4 of [PB, JT, YT, KT, ZT, eB]) {
        const i4 = r4(e21, t3, n3);
        if (i4 !== void 0)
          return i4;
      }
      let o3 = [];
      switch (i3.type) {
        case "JsExpressionRoot":
          return n3("node");
        case "JsonRoot":
          return [n3("node"), TT];
        case "File":
          return i3.program && i3.program.interpreter && o3.push(n3(["program", "interpreter"])), o3.push(n3("program")), o3;
        case "Program":
          return NB(e21, t3, n3);
        case "EmptyStatement":
          return "";
        case "ExpressionStatement":
          if (i3.directive)
            return [IB(i3.expression, t3), u3];
          if (t3.parser === "__vue_event_binding") {
            const t4 = e21.getParentNode();
            if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === i3)
              return [n3("expression"), XT(i3.expression) ? ";" : ""];
          }
          return [n3("expression"), _T(t3, e21) ? "" : u3];
        case "ParenthesizedExpression":
          return !LT(i3.expression) && (i3.expression.type === "ObjectExpression" || i3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : NT(["(", kT([BT, n3("expression")]), BT, ")"]);
        case "AssignmentExpression":
          return SB(e21, t3, n3);
        case "VariableDeclarator":
          return FB(e21, t3, n3);
        case "BinaryExpression":
        case "LogicalExpression":
          return xB(e21, t3, n3);
        case "AssignmentPattern":
          return [n3("left"), " = ", n3("right")];
        case "OptionalMemberExpression":
        case "MemberExpression":
          return TB(e21, t3, n3);
        case "MetaProperty":
          return [n3("meta"), ".", n3("property")];
        case "BindExpression":
          return i3.object && o3.push(n3("object")), o3.push(NT(kT([BT, nB(e21, t3, n3)]))), o3;
        case "Identifier":
          return [i3.name, tB(e21), rB(e21, t3, n3)];
        case "V8IntrinsicIdentifier":
          return ["%", i3.name];
        case "SpreadElement":
        case "SpreadElementPattern":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "RestElement":
          return uB(e21, t3, n3);
        case "FunctionDeclaration":
        case "FunctionExpression":
          return DB(e21, n3, t3, r3);
        case "ArrowFunctionExpression":
          return EB(e21, t3, n3, r3);
        case "YieldExpression":
          return o3.push("yield"), i3.delegate && o3.push("*"), i3.argument && o3.push(" ", n3("argument")), o3;
        case "AwaitExpression":
          if (o3.push("await"), i3.argument) {
            o3.push(" ", n3("argument"));
            const t4 = e21.getParentNode();
            if (UT(t4) && t4.callee === i3 || zT(t4) && t4.object === i3) {
              o3 = [kT([BT, ...o3]), BT];
              const t5 = e21.findAncestor((e22) => e22.type === "AwaitExpression" || e22.type === "BlockStatement");
              if (!t5 || t5.type !== "AwaitExpression")
                return NT(o3);
            }
          }
          return o3;
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return sB(e21, t3, n3);
        case "ExportAllDeclaration":
          return aB(e21, t3, n3);
        case "ImportDeclaration":
          return oB(e21, t3, n3);
        case "ImportSpecifier":
        case "ExportSpecifier":
        case "ImportNamespaceSpecifier":
        case "ExportNamespaceSpecifier":
        case "ImportDefaultSpecifier":
        case "ExportDefaultSpecifier":
          return cB(e21, t3, n3);
        case "ImportAttribute":
          return [n3("key"), ": ", n3("value")];
        case "Import":
          return "import";
        case "BlockStatement":
        case "StaticBlock":
        case "ClassBody":
          return BB(e21, t3, n3);
        case "ThrowStatement":
          return AB(e21, t3, n3);
        case "ReturnStatement":
          return bB(e21, t3, n3);
        case "NewExpression":
        case "ImportExpression":
        case "OptionalCallExpression":
        case "CallExpression":
          return vB(e21, t3, n3);
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          return dB(e21, t3, n3);
        case "ObjectProperty":
        case "Property":
          return i3.method || i3.kind === "get" || i3.kind === "set" ? CB(e21, t3, n3) : yB(e21, t3, n3);
        case "ObjectMethod":
          return CB(e21, t3, n3);
        case "Decorator":
          return ["@", n3("expression")];
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          return fB(e21, t3, n3);
        case "SequenceExpression": {
          const t4 = e21.getParentNode(0);
          if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
            const t5 = [];
            return e21.each((e22, r4) => {
              r4 === 0 ? t5.push(n3()) : t5.push(",", kT([wT, n3()]));
            }, "expressions"), NT(t5);
          }
          return NT(xT([",", wT], e21.map(n3, "expressions")));
        }
        case "ThisExpression":
          return "this";
        case "Super":
          return "super";
        case "Directive":
          return [n3("value"), u3];
        case "DirectiveLiteral":
          return IB(i3, t3);
        case "UnaryExpression":
          return o3.push(i3.operator), /[a-z]$/.test(i3.operator) && o3.push(" "), LT(i3.argument) ? o3.push(NT(["(", kT([BT, n3("argument")]), BT, ")"])) : o3.push(n3("argument")), o3;
        case "UpdateExpression":
          return o3.push(n3("argument"), i3.operator), i3.prefix && o3.reverse(), o3;
        case "ConditionalExpression":
          return lB(e21, t3, n3);
        case "VariableDeclaration": {
          const t4 = e21.map(n3, "declarations"), r4 = e21.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = i3.declarations.some((e22) => e22.init);
          let c2;
          return t4.length !== 1 || LT(i3.declarations[0]) ? t4.length > 0 && (c2 = kT(t4[0])) : c2 = t4[0], o3 = [i3.declare ? "declare " : "", i3.kind, c2 ? [" ", c2] : "", kT(t4.slice(1).map((e22) => [",", a3 && !s3 ? TT : wT, e22]))], s3 && r4.body !== i3 || o3.push(u3), NT(o3);
        }
        case "WithStatement":
          return NT(["with (", n3("object"), ")", iB(i3.body, n3("body"))]);
        case "IfStatement": {
          const r4 = iB(i3.consequent, n3("consequent")), u4 = NT(["if (", NT([kT([BT, n3("test")]), BT]), ")", r4]);
          if (o3.push(u4), i3.alternate) {
            const r5 = LT(i3.consequent, jT.Trailing | jT.Line) || VT(i3), u5 = i3.consequent.type === "BlockStatement" && !r5;
            o3.push(u5 ? " " : TT), LT(i3, jT.Dangling) && o3.push(FT(e21, t3, true), r5 ? TT : " "), o3.push("else", NT(iB(i3.alternate, n3("alternate"), i3.alternate.type === "IfStatement")));
          }
          return o3;
        }
        case "ForStatement": {
          const r4 = iB(i3.body, n3("body")), u4 = FT(e21, t3, true), o4 = u4 ? [u4, BT] : "";
          return i3.init || i3.test || i3.update ? [o4, NT(["for (", NT([kT([BT, n3("init"), ";", wT, n3("test"), ";", wT, n3("update")]), BT]), ")", r4])] : [o4, NT(["for (;;)", r4])];
        }
        case "WhileStatement":
          return NT(["while (", NT([kT([BT, n3("test")]), BT]), ")", iB(i3.body, n3("body"))]);
        case "ForInStatement":
          return NT(["for (", n3("left"), " in ", n3("right"), ")", iB(i3.body, n3("body"))]);
        case "ForOfStatement":
          return NT(["for", i3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", iB(i3.body, n3("body"))]);
        case "DoWhileStatement": {
          const e22 = iB(i3.body, n3("body"));
          return o3 = [NT(["do", e22])], i3.body.type === "BlockStatement" ? o3.push(" ") : o3.push(TT), o3.push("while (", NT([kT([BT, n3("test")]), BT]), ")", u3), o3;
        }
        case "DoExpression":
          return [i3.async ? "async " : "", "do ", n3("body")];
        case "BreakStatement":
          return o3.push("break"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "ContinueStatement":
          return o3.push("continue"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "LabeledStatement":
          return i3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
        case "TryStatement":
          return ["try ", n3("block"), i3.handler ? [" ", n3("handler")] : "", i3.finalizer ? [" finally ", n3("finalizer")] : ""];
        case "CatchClause":
          if (i3.param) {
            const e22 = LT(i3.param, (e23) => !MT(e23) || e23.leading && ST(t3.originalText, HT(e23)) || e23.trailing && ST(t3.originalText, GT(e23), {backwards: true})), r4 = n3("param");
            return ["catch ", e22 ? ["(", kT([BT, r4]), BT, ") "] : ["(", r4, ") "], n3("body")];
          }
          return ["catch ", n3("body")];
        case "SwitchStatement":
          return [NT(["switch (", kT([BT, n3("discriminant")]), BT, ")"]), " {", i3.cases.length > 0 ? kT([TT, xT(TT, e21.map((e22, r4, i4) => {
            const u4 = e22.getValue();
            return [n3(), r4 !== i4.length - 1 && $T(u4, t3) ? TT : ""];
          }, "cases"))]) : "", TT, "}"];
        case "SwitchCase": {
          i3.test ? o3.push("case ", n3("test"), ":") : o3.push("default:");
          const r4 = i3.consequent.filter((e22) => e22.type !== "EmptyStatement");
          if (r4.length > 0) {
            const i4 = wB(e21, t3, n3);
            o3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", i4] : kT([TT, i4]));
          }
          return o3;
        }
        case "DebuggerStatement":
          return ["debugger", u3];
        case "ClassDeclaration":
        case "ClassExpression":
          return hB(e21, t3, n3);
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "MethodDefinition":
          return gB(e21, t3, n3);
        case "ClassProperty":
        case "PropertyDefinition":
        case "ClassPrivateProperty":
          return mB(e21, t3, n3);
        case "TemplateElement":
          return PT(i3.value.raw);
        case "TemplateLiteral":
          return pB(e21, n3, t3);
        case "TaggedTemplateExpression":
          return [n3("tag"), n3("typeParameters"), n3("quasi")];
        case "PrivateIdentifier":
          return ["#", n3("name")];
        case "PrivateName":
          return ["#", n3("id")];
        case "InterpreterDirective":
          return o3.push("#!", i3.value, TT), $T(i3, t3) && o3.push(TT), o3;
        case "TopicReference":
          return "%";
        case "ArgumentPlaceholder":
          return "?";
        case "ModuleExpression": {
          o3.push("module {");
          const e22 = n3("body");
          return e22 && o3.push(kT([TT, e22]), TT), o3.push("}"), o3;
        }
        default:
          throw new Error("unknown type: " + JSON.stringify(i3.type));
      }
    }(e20, t2, n2, r2);
    if (!i2)
      return "";
    const u2 = e20.getValue(), {type: o2} = u2;
    if (o2 === "ClassMethod" || o2 === "ClassPrivateMethod" || o2 === "ClassProperty" || o2 === "PropertyDefinition" || o2 === "TSAbstractClassProperty" || o2 === "ClassPrivateProperty" || o2 === "MethodDefinition" || o2 === "TSAbstractMethodDefinition" || o2 === "TSDeclareMethod")
      return i2;
    const s2 = OB(e20, t2, n2);
    if (s2)
      return NT([...s2, i2]);
    if (!Qy(e20, t2))
      return r2 && r2.needsSemi ? [";", i2] : i2;
    const a2 = [r2 && r2.needsSemi ? ";(" : "(", i2];
    if (IT(u2)) {
      const [e21] = u2.trailingComments;
      a2.push(" /*", e21.value.trimStart(), "*/"), e21.printed = true;
    }
    return a2.push(")"), a2;
  }, embed: Kg, insertPragma: OT, massageAstNode: nm, hasPrettierIgnore: (e20) => qT(e20) || QT(e20), willPrintOwnComments: jy.willPrintOwnComments, canAttachComment: function(e20) {
    return e20.type && !MT(e20) && !RT(e20) && e20.type !== "EmptyStatement" && e20.type !== "TemplateElement" && e20.type !== "Import" && e20.type !== "TSEmptyBodyFunctionExpression";
  }, printComment: kB, isBlockComment: MT, handleComments: {avoidAstMutation: true, ownLine: jy.handleOwnLineComment, endOfLine: jy.handleEndOfLineComment, remaining: jy.handleRemainingComment}, getCommentChildNodes: jy.getCommentChildNodes};
  const {builders: {hardline: jB, indent: _B, join: MB}} = eu$1;
  const RB = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
  function $B(e20, t2) {
    const {type: n2} = e20;
    if (n2 !== "ObjectProperty" || e20.key.type !== "Identifier") {
      if (n2 === "UnaryExpression" && e20.operator === "+")
        return t2.argument;
      if (n2 !== "ArrayExpression")
        return n2 === "TemplateLiteral" ? {type: "StringLiteral", value: e20.quasis[0].value.cooked} : void 0;
      for (const [n3, r2] of e20.elements.entries())
        r2 === null && t2.elements.splice(n3, 0, {type: "NullLiteral"});
    } else
      t2.key = {type: "StringLiteral", value: e20.key.name};
  }
  $B.ignoredProperties = RB;
  var VB = {preprocess: Zy, print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    switch (r2.type) {
      case "JsonRoot":
        return [n2("node"), jB];
      case "ArrayExpression": {
        if (r2.elements.length === 0)
          return "[]";
        const t3 = e20.map(() => e20.getValue() === null ? "null" : n2(), "elements");
        return ["[", _B([jB, MB([",", jB], t3)]), jB, "]"];
      }
      case "ObjectExpression":
        return r2.properties.length === 0 ? "{}" : ["{", _B([jB, MB([",", jB], e20.map(n2, "properties"))]), jB, "}"];
      case "ObjectProperty":
        return [n2("key"), ": ", n2("value")];
      case "UnaryExpression":
        return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return r2.value ? "true" : "false";
      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(r2.value);
      case "Identifier": {
        const t3 = e20.getParentNode();
        return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
      }
      case "TemplateLiteral":
        return n2(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(r2.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(r2.type));
    }
  }, massageAstNode: $B};
  var WB = {bracketSpacing: {since: "0.0.0", category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets."}, singleQuote: {since: "0.0.0", category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes."}, proseWrap: {since: "1.8.2", category: "Common", type: "choice", default: [{since: "1.8.2", value: true}, {since: "1.9.0", value: "preserve"}], description: "How to wrap prose.", choices: [{since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width."}, {since: "1.9.0", value: "never", description: "Do not wrap prose."}, {since: "1.9.0", value: "preserve", description: "Wrap prose as-is."}]}, bracketSameLine: {since: "2.4.0", category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line."}};
  var qB = {arrowParens: {since: "1.9.0", category: "JavaScript", type: "choice", default: [{since: "1.9.0", value: "avoid"}, {since: "2.0.0", value: "always"}], description: "Include parentheses around a sole arrow function parameter.", choices: [{value: "always", description: "Always include parens. Example: `(x) => x`"}, {value: "avoid", description: "Omit parens when possible. Example: `x => x`"}]}, bracketSameLine: WB.bracketSameLine, bracketSpacing: WB.bracketSpacing, jsxBracketSameLine: {since: "0.17.0", category: "JavaScript", type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0"}, semi: {since: "1.0.0", category: "JavaScript", type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."}, singleQuote: WB.singleQuote, jsxSingleQuote: {since: "1.15.0", category: "JavaScript", type: "boolean", default: false, description: "Use single quotes in JSX."}, quoteProps: {since: "1.17.0", category: "JavaScript", type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{value: "as-needed", description: "Only add quotes around object properties where required."}, {value: "consistent", description: "If at least one property in an object requires quotes, quote all properties."}, {value: "preserve", description: "Respect the input use of quotes in object properties."}]}, trailingComma: {since: "0.0.0", category: "JavaScript", type: "choice", default: [{since: "0.0.0", value: false}, {since: "0.19.0", value: "none"}, {since: "2.0.0", value: "es5"}], description: "Print trailing commas wherever possible when multi-line.", choices: [{value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"}, {value: "none", description: "No trailing commas."}, {value: "all", description: "Trailing commas wherever possible (including function arguments)."}]}}, UB = {name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183}, zB = {name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378}, GB = {name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924}, HB = {name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174}, JB = {name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423}, XB = {name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175};
  var YB = {languages: [Xd(UB, (e20) => ({since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e20.interpreters, "zx"], extensions: [...e20.extensions.filter((e21) => e21 !== ".jsx"), ".wxs"]})), Xd(UB, () => ({name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"]})), Xd(UB, () => ({name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0})), Xd(zB, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"]})), Xd(GB, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"]})), Xd(HB, () => ({name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"]})), Xd(HB, (e20) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e20.extensions.filter((e21) => e21 !== ".jsonl")})), Xd(JB, (e20) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e20.filenames, ".eslintrc"]})), Xd(XB, () => ({since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"]}))], options: qB, printers: {estree: LB, "estree-json": VB}, parsers: void 0};
  const {isFrontMatterNode: KB} = yi$2, QB = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
  function ZB(e20, t2, n2) {
    if (KB(e20) && e20.lang === "yaml" && delete t2.value, e20.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
      if ((n2.nodes[0] === e20 || KB(n2.nodes[0]) && n2.nodes[1] === e20) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e20.text)))
        return null;
      if (n2.type === "css-root" && Ln$2(n2.nodes) === e20)
        return null;
    }
    if (e20.type === "value-root" && delete t2.text, e20.type !== "media-query" && e20.type !== "media-query-list" && e20.type !== "media-feature-expression" || delete t2.value, e20.type === "css-rule" && delete t2.params, e20.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e20.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e20.type === "value-word" && (e20.isColor && e20.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e20.type === "media-feature" || e20.type === "selector-root-invalid" || e20.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e20.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e20.type !== "css-atrule" && e20.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e20.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e20.type !== "media-feature" && e20.type !== "media-keyword" && e20.type !== "media-type" && e20.type !== "media-unknown" && e20.type !== "media-url" && e20.type !== "media-value" && e20.type !== "selector-attribute" && e20.type !== "selector-string" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e20.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e20.type !== "media-value" && e20.type !== "media-type" && e20.type !== "value-number" && e20.type !== "selector-root-invalid" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e21, t3, n3) => {
      const r2 = Number(t3);
      return Number.isNaN(r2) ? e21 : r2 + n3.toLowerCase();
    })), e20.type === "selector-tag") {
      const n3 = e20.value.toLowerCase();
      ["from", "to"].includes(n3) && (t2.value = n3);
    }
    e20.type === "css-atrule" && e20.name.toLowerCase() === "supports" && delete t2.value, e20.type === "selector-unknown" && delete t2.value;
  }
  ZB.ignoredProperties = QB;
  var eN = ZB;
  const {builders: {hardline: tN, markAsRoot: nN}} = eu$1;
  var rN = function(e20, t2) {
    if (e20.lang === "yaml") {
      const n2 = e20.value.trim(), r2 = n2 ? t2(n2, {parser: "yaml"}, {stripTrailingHardline: true}) : "";
      return nN([e20.startDelimiter, tN, r2, r2 ? tN : "", e20.endDelimiter]);
    }
  };
  const {builders: {hardline: iN}} = eu$1;
  var uN = function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type === "front-matter") {
      const e21 = rN(r2, n2);
      return e21 ? [e21, iN] : "";
    }
  };
  const oN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  var sN = function(e20) {
    const t2 = e20.match(oN);
    if (!t2)
      return {content: e20};
    const {startDelimiter: n2, language: r2, value: i2 = "", endDelimiter: u2} = t2.groups;
    let o2 = r2.trim() || "yaml";
    if (n2 === "+++" && (o2 = "toml"), o2 !== "yaml" && n2 !== u2)
      return {content: e20};
    const [s2] = t2;
    return {frontMatter: {type: "front-matter", lang: o2, value: i2, startDelimiter: n2, endDelimiter: u2, raw: s2.replace(/\n$/, "")}, content: s2.replace(/[^\n]/g, " ") + e20.slice(s2.length)};
  };
  var aN = {hasPragma: function(e20) {
    return km.hasPragma(sN(e20).content);
  }, insertPragma: function(e20) {
    const {frontMatter: t2, content: n2} = sN(e20);
    return (t2 ? t2.raw + "\n\n" : "") + km.insertPragma(n2);
  }};
  const {isNonEmptyArray: cN} = yi$2, lN = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), pN = new Set(["import", "use", "forward"]);
  function fN(e20, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2];
    let r2, i2 = -1;
    for (; r2 = e20.getParentNode(++i2); )
      if (n2.includes(r2.type))
        return i2;
    return -1;
  }
  function dN(e20, t2) {
    const n2 = fN(e20, t2);
    return n2 === -1 ? null : e20.getParentNode(n2);
  }
  function hN(e20) {
    return e20.type === "value-operator" && e20.value === "*";
  }
  function gN(e20) {
    return e20.type === "value-operator" && e20.value === "/";
  }
  function mN(e20) {
    return e20.type === "value-operator" && e20.value === "+";
  }
  function yN(e20) {
    return e20.type === "value-operator" && e20.value === "-";
  }
  function DN(e20) {
    return e20.type === "value-operator" && e20.value === "%";
  }
  function EN(e20) {
    return e20.type === "value-comma_group" && e20.groups && e20.groups[1] && e20.groups[1].type === "value-colon";
  }
  function CN(e20) {
    return e20.type === "value-paren_group" && e20.groups && e20.groups[0] && EN(e20.groups[0]);
  }
  function bN(e20) {
    return e20 && e20.type === "value-colon";
  }
  var AN = {getAncestorCounter: fN, getAncestorNode: dN, getPropOfDeclNode: function(e20) {
    const t2 = dN(e20, "css-decl");
    return t2 && t2.prop && t2.prop.toLowerCase();
  }, hasSCSSInterpolation: function(e20) {
    if (cN(e20)) {
      for (let t2 = e20.length - 1; t2 > 0; t2--)
        if (e20[t2].type === "word" && e20[t2].value === "{" && e20[t2 - 1].type === "word" && e20[t2 - 1].value.endsWith("#"))
          return true;
    }
    return false;
  }, hasStringOrFunction: function(e20) {
    if (cN(e20)) {
      for (let t2 = 0; t2 < e20.length; t2++)
        if (e20[t2].type === "string" || e20[t2].type === "func")
          return true;
    }
    return false;
  }, maybeToLowerCase: function(e20) {
    return e20.includes("$") || e20.includes("@") || e20.includes("#") || e20.startsWith("%") || e20.startsWith("--") || e20.startsWith(":--") || e20.includes("(") && e20.includes(")") ? e20 : e20.toLowerCase();
  }, insideValueFunctionNode: function(e20, t2) {
    const n2 = dN(e20, "value-func");
    return n2 && n2.value && n2.value.toLowerCase() === t2;
  }, insideICSSRuleNode: function(e20) {
    const t2 = dN(e20, "css-rule");
    return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
  }, insideAtRuleNode: function(e20, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2], r2 = dN(e20, "css-atrule");
    return r2 && n2.includes(r2.name.toLowerCase());
  }, insideURLFunctionInImportAtRuleNode: function(e20) {
    const t2 = e20.getValue(), n2 = dN(e20, "css-atrule");
    return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
  }, isKeyframeAtRuleKeywords: function(e20, t2) {
    const n2 = dN(e20, "css-atrule");
    return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
  }, isWideKeywords: function(e20) {
    return ["initial", "inherit", "unset", "revert"].includes(e20.toLowerCase());
  }, isSCSS: function(e20, t2) {
    return e20 === "less" || e20 === "scss" ? e20 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
  }, isSCSSVariable: function(e20) {
    return Boolean(e20 && e20.type === "word" && e20.value.startsWith("$"));
  }, isLastNode: function(e20, t2) {
    const n2 = e20.getParentNode();
    if (!n2)
      return false;
    const {nodes: r2} = n2;
    return r2 && r2.indexOf(t2) === r2.length - 1;
  }, isLessParser: function(e20) {
    return e20.parser === "css" || e20.parser === "less";
  }, isSCSSControlDirectiveNode: function(e20) {
    return e20.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e20.name);
  }, isDetachedRulesetDeclarationNode: function(e20) {
    return !!e20.selector && (typeof e20.selector == "string" && /^@.+:.*$/.test(e20.selector) || e20.selector.value && /^@.+:.*$/.test(e20.selector.value));
  }, isRelationalOperatorNode: function(e20) {
    return e20.type === "value-word" && ["<", ">", "<=", ">="].includes(e20.value);
  }, isEqualityOperatorNode: function(e20) {
    return e20.type === "value-word" && ["==", "!="].includes(e20.value);
  }, isMultiplicationNode: hN, isDivisionNode: gN, isAdditionNode: mN, isSubtractionNode: yN, isModuloNode: DN, isMathOperatorNode: function(e20) {
    return hN(e20) || gN(e20) || mN(e20) || yN(e20) || DN(e20);
  }, isEachKeywordNode: function(e20) {
    return e20.type === "value-word" && e20.value === "in";
  }, isForKeywordNode: function(e20) {
    return e20.type === "value-word" && ["from", "through", "end"].includes(e20.value);
  }, isURLFunctionNode: function(e20) {
    return e20.type === "value-func" && e20.value.toLowerCase() === "url";
  }, isIfElseKeywordNode: function(e20) {
    return e20.type === "value-word" && ["and", "or", "not"].includes(e20.value);
  }, hasComposesNode: function(e20) {
    return e20.value && e20.value.type === "value-root" && e20.value.group && e20.value.group.type === "value-value" && e20.prop.toLowerCase() === "composes";
  }, hasParensAroundNode: function(e20) {
    return e20.value && e20.value.group && e20.value.group.group && e20.value.group.group.type === "value-paren_group" && e20.value.group.group.open !== null && e20.value.group.group.close !== null;
  }, hasEmptyRawBefore: function(e20) {
    return e20.raws && e20.raws.before === "";
  }, isSCSSNestedPropertyNode: function(e20) {
    return !!e20.selector && e20.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
  }, isDetachedRulesetCallNode: function(e20) {
    return e20.raws && e20.raws.params && /^\(\s*\)$/.test(e20.raws.params);
  }, isTemplatePlaceholderNode: function(e20) {
    return e20.name.startsWith("prettier-placeholder");
  }, isTemplatePropNode: function(e20) {
    return e20.prop.startsWith("@prettier-placeholder");
  }, isPostcssSimpleVarNode: function(e20, t2) {
    return e20.value === "$$" && e20.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
  }, isKeyValuePairNode: EN, isKeyValuePairInParenGroupNode: CN, isKeyInValuePairNode: function(e20, t2) {
    if (!EN(t2))
      return false;
    const {groups: n2} = t2, r2 = n2.indexOf(e20);
    return r2 !== -1 && bN(n2[r2 + 1]);
  }, isSCSSMapItemNode: function(e20) {
    const t2 = e20.getValue();
    if (t2.groups.length === 0)
      return false;
    const n2 = e20.getParentNode(1);
    if (!(CN(t2) || n2 && CN(n2)))
      return false;
    const r2 = dN(e20, "css-decl");
    return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!CN(n2) || n2.type === "value-func");
  }, isInlineValueCommentNode: function(e20) {
    return e20.type === "value-comment" && e20.inline;
  }, isHashNode: function(e20) {
    return e20.type === "value-word" && e20.value === "#";
  }, isLeftCurlyBraceNode: function(e20) {
    return e20.type === "value-word" && e20.value === "{";
  }, isRightCurlyBraceNode: function(e20) {
    return e20.type === "value-word" && e20.value === "}";
  }, isWordNode: function(e20) {
    return ["value-word", "value-atword"].includes(e20.type);
  }, isColonNode: bN, isMediaAndSupportsKeywords: function(e20) {
    return e20.value && ["not", "and", "or"].includes(e20.value.toLowerCase());
  }, isColorAdjusterFuncNode: function(e20) {
    return e20.type === "value-func" && lN.has(e20.value.toLowerCase());
  }, lastLineHasInlineComment: function(e20) {
    return /\/\//.test(e20.split(/[\n\r]/).pop());
  }, stringifyNode: function e7(t2) {
    if (t2.groups) {
      return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, i2) => n3 + e7(r3) + (t2.groups[0].type === "comma_group" && i2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
    }
    const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
    return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e7(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
  }, isAtWordPlaceholderNode: function(e20) {
    return e20 && e20.type === "value-atword" && e20.value.startsWith("prettier-placeholder-");
  }, isModuleRuleName: function(e20) {
    return pN.has(e20);
  }}, vN = function(e20, t2) {
    let n2 = 0;
    for (let r2 = 0; r2 < e20.line - 1; ++r2)
      n2 = t2.indexOf("\n", n2) + 1;
    return n2 + e20.column;
  };
  const {getLast: FN, skipEverythingButNewLine: SN} = yi$2;
  function xN(e20, t2) {
    return typeof e20.sourceIndex == "number" ? e20.sourceIndex : e20.source ? vN(e20.source.start, t2) - 1 : null;
  }
  function wN(e20, t2) {
    if (e20.type === "css-comment" && e20.inline)
      return SN(t2, e20.source.startOffset);
    const n2 = e20.nodes && FN(e20.nodes);
    return n2 && e20.source && !e20.source.end && (e20 = n2), e20.source && e20.source.end ? vN(e20.source.end, t2) : null;
  }
  function TN(e20, t2, n2) {
    e20.source && (e20.source.startOffset = xN(e20, n2) + t2, e20.source.endOffset = wN(e20, n2) + t2);
    for (const r2 in e20) {
      const i2 = e20[r2];
      r2 !== "source" && i2 && typeof i2 == "object" && TN(i2, t2, n2);
    }
  }
  function BN(e20) {
    let t2 = e20.source.startOffset;
    return typeof e20.prop == "string" && (t2 += e20.prop.length), e20.type === "css-atrule" && typeof e20.name == "string" && (t2 += 1 + e20.name.length + e20.raws.afterName.match(/^\s*:?\s*/)[0].length), e20.type !== "css-atrule" && e20.raws && typeof e20.raws.between == "string" && (t2 += e20.raws.between.length), t2;
  }
  var NN = {locStart: function(e20) {
    return e20.source.startOffset;
  }, locEnd: function(e20) {
    return e20.source.endOffset;
  }, calculateLoc: function e8(t2, n2) {
    t2.source && (t2.source.startOffset = xN(t2, n2), t2.source.endOffset = wN(t2, n2));
    for (const r2 in t2) {
      const i2 = t2[r2];
      r2 !== "source" && i2 && typeof i2 == "object" && (i2.type === "value-root" || i2.type === "value-unknown" ? TN(i2, BN(t2), i2.text || i2.value) : e8(i2, n2));
    }
  }, replaceQuotesInInlineComments: function(e20) {
    let t2, n2 = "initial", r2 = "initial", i2 = false;
    const u2 = [];
    for (let o2 = 0; o2 < e20.length; o2++) {
      const s2 = e20[o2];
      switch (n2) {
        case "initial":
          if (s2 === "'") {
            n2 = "single-quotes";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes";
            continue;
          }
          if ((s2 === "u" || s2 === "U") && e20.slice(o2, o2 + 4).toLowerCase() === "url(") {
            n2 = "url", o2 += 3;
            continue;
          }
          if (s2 === "*" && e20[o2 - 1] === "/") {
            n2 = "comment-block";
            continue;
          }
          if (s2 === "/" && e20[o2 - 1] === "/") {
            n2 = "comment-inline", t2 = o2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (s2 === "'" && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          continue;
        case "double-quotes":
          if (s2 === '"' && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          continue;
        case "url":
          if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          if (s2 === "'") {
            n2 = "single-quotes", r2 = "url";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes", r2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          s2 === "/" && e20[o2 - 1] === "*" && (n2 = "initial");
          continue;
        case "comment-inline":
          s2 !== '"' && s2 !== "'" && s2 !== "*" || (i2 = true), s2 !== "\n" && s2 !== "\r" || (i2 && u2.push([t2, o2]), n2 = "initial", i2 = false);
          continue;
      }
    }
    for (const [t3, n3] of u2)
      e20 = e20.slice(0, t3) + e20.slice(t3, n3).replace(/["'*]/g, " ") + e20.slice(n3);
    return e20;
  }};
  const {printNumber: kN, printString: PN, hasNewline: ON, isFrontMatterNode: IN, isNextLineEmpty: LN, isNonEmptyArray: jN} = yi$2, {builders: {join: _N, line: MN, hardline: RN, softline: $N, group: VN, fill: WN, indent: qN, dedent: UN, ifBreak: zN, breakParent: GN}, utils: {removeLines: HN, getDocParts: JN}} = eu$1, {insertPragma: XN} = aN, {getAncestorNode: YN, getPropOfDeclNode: KN, maybeToLowerCase: QN, insideValueFunctionNode: ZN, insideICSSRuleNode: ek, insideAtRuleNode: tk, insideURLFunctionInImportAtRuleNode: nk, isKeyframeAtRuleKeywords: rk, isWideKeywords: ik, isSCSS: uk, isLastNode: ok, isLessParser: sk, isSCSSControlDirectiveNode: ak, isDetachedRulesetDeclarationNode: ck, isRelationalOperatorNode: lk, isEqualityOperatorNode: pk, isMultiplicationNode: fk, isDivisionNode: dk, isAdditionNode: hk, isSubtractionNode: gk, isMathOperatorNode: mk, isEachKeywordNode: yk, isForKeywordNode: Dk, isURLFunctionNode: Ek, isIfElseKeywordNode: Ck, hasComposesNode: bk, hasParensAroundNode: Ak, hasEmptyRawBefore: vk, isKeyValuePairNode: Fk, isKeyInValuePairNode: Sk, isDetachedRulesetCallNode: xk, isTemplatePlaceholderNode: wk, isTemplatePropNode: Tk, isPostcssSimpleVarNode: Bk, isSCSSMapItemNode: Nk, isInlineValueCommentNode: kk, isHashNode: Pk, isLeftCurlyBraceNode: Ok, isRightCurlyBraceNode: Ik, isWordNode: Lk, isColonNode: jk, isMediaAndSupportsKeywords: _k, isColorAdjusterFuncNode: Mk, lastLineHasInlineComment: Rk, isAtWordPlaceholderNode: $k} = AN, {locStart: Vk, locEnd: Wk} = NN;
  function qk(e20) {
    return e20.trailingComma === "es5" || e20.trailingComma === "all";
  }
  function Uk(e20, t2, n2) {
    const r2 = [];
    return e20.each((e21, i2, u2) => {
      const o2 = u2[i2 - 1];
      if (o2 && o2.type === "css-comment" && o2.text.trim() === "prettier-ignore") {
        const n3 = e21.getValue();
        r2.push(t2.originalText.slice(Vk(n3), Wk(n3)));
      } else
        r2.push(n2());
      i2 !== u2.length - 1 && (u2[i2 + 1].type === "css-comment" && !ON(t2.originalText, Vk(u2[i2 + 1]), {backwards: true}) && !IN(u2[i2]) || u2[i2 + 1].type === "css-atrule" && u2[i2 + 1].name === "else" && u2[i2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? MN : RN), LN(t2.originalText, e21.getValue(), Wk) && !IN(u2[i2]) && r2.push(RN)));
    }, "nodes"), r2;
  }
  const zk = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Gk = new RegExp(zk.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
  function Hk(e20, t2) {
    return e20.replace(zk, (e21) => PN(e21, t2));
  }
  function Jk(e20, t2) {
    const n2 = t2.singleQuote ? "'" : '"';
    return e20.includes('"') || e20.includes("'") ? e20 : n2 + e20 + n2;
  }
  function Xk(e20) {
    return e20.replace(Gk, (e21, t2, n2, r2, i2) => !n2 && r2 ? Yk(r2) + QN(i2 || "") : e21);
  }
  function Yk(e20) {
    return kN(e20).replace(/\.0(?=$|e)/, "");
  }
  var Kk = {print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.type) {
      case "front-matter":
        return [r2.raw, RN];
      case "css-root": {
        const i2 = Uk(e20, t2, n2), u2 = r2.raws.after.trim();
        return [i2, u2 ? ` ${u2}` : "", JN(i2).length > 0 ? RN : ""];
      }
      case "css-comment": {
        const e21 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(Vk(r2), Wk(r2));
        return e21 ? n3.trimEnd() : n3;
      }
      case "css-rule":
        return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && Rk(r2.selector.value) ? MN : " ", "{", r2.nodes.length > 0 ? qN([RN, Uk(e20, t2, n2)]) : "", RN, "}", ck(r2) ? ";" : ""] : ";"];
      case "css-decl": {
        const i2 = e20.getParentNode(), {between: u2} = r2.raws, o2 = u2.trim(), s2 = o2 === ":";
        let a2 = bk(r2) ? HN(n2("value")) : n2("value");
        return !s2 && Rk(o2) && (a2 = qN([RN, UN(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), ek(e20) ? r2.prop : QN(r2.prop), o2.startsWith("//") ? " " : "", o2, r2.extend ? "" : " ", sk(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", qN([$N, Uk(e20, t2, n2)]), $N, "}"] : Tk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && ok(e20, r2) ? zN(";") : ";"];
      }
      case "css-atrule": {
        const i2 = e20.getParentNode(), u2 = wk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";";
        if (sk(t2)) {
          if (r2.mixin)
            return [n2("selector"), r2.important ? " !important" : "", u2 ? "" : ";"];
          if (r2.function)
            return [r2.name, n2("params"), u2 ? "" : ";"];
          if (r2.variable)
            return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", qN([r2.nodes.length > 0 ? $N : "", Uk(e20, t2, n2)]), $N, "}"] : "", u2 ? "" : ";"];
        }
        return ["@", xk(r2) || r2.name.endsWith(":") ? r2.name : QN(r2.name), r2.params ? [xk(r2) ? "" : wk(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [RN, RN] : /^\s*\n/.test(r2.raws.afterName) ? RN : " " : " ", n2("params")] : "", r2.selector ? qN([" ", n2("selector")]) : "", r2.value ? VN([" ", n2("value"), ak(r2) ? Ak(r2) ? " " : MN : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [ak(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Rk(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Rk(r2.params) ? MN : " ", "{", qN([r2.nodes.length > 0 ? $N : "", Uk(e20, t2, n2)]), $N, "}"] : u2 ? "" : ";"];
      }
      case "media-query-list": {
        const t3 = [];
        return e20.each((e21) => {
          const r3 = e21.getValue();
          r3.type === "media-query" && r3.value === "" || t3.push(n2());
        }, "nodes"), VN(qN(_N(MN, t3)));
      }
      case "media-query":
        return [_N(" ", e20.map(n2, "nodes")), ok(e20, r2) ? "" : ","];
      case "media-type":
        return Xk(Hk(r2.value, t2));
      case "media-feature-expression":
        return r2.nodes ? ["(", ...e20.map(n2, "nodes"), ")"] : r2.value;
      case "media-feature":
        return QN(Hk(r2.value.replace(/ +/g, " "), t2));
      case "media-colon":
        return [r2.value, " "];
      case "media-value":
        return Xk(Hk(r2.value, t2));
      case "media-keyword":
        return Hk(r2.value, t2);
      case "media-url":
        return Hk(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
      case "media-unknown":
        return r2.value;
      case "selector-root":
        return VN([tk(e20, "custom-selector") ? [YN(e20, "css-atrule").customSelector, MN] : "", _N([",", tk(e20, ["extend", "custom-selector", "nest"]) ? MN : RN], e20.map(n2, "nodes"))]);
      case "selector-selector":
        return VN(qN(e20.map(n2, "nodes")));
      case "selector-comment":
        return r2.value;
      case "selector-string":
        return Hk(r2.value, t2);
      case "selector-tag": {
        const t3 = e20.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), i2 = n3 && t3.nodes[n3 - 1];
        return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", i2.type === "selector-nesting" ? r2.value : Xk(rk(e20, r2.value) ? r2.value.toLowerCase() : r2.value)];
      }
      case "selector-id":
        return ["#", r2.value];
      case "selector-class":
        return [".", Xk(Hk(r2.value, t2))];
      case "selector-attribute":
        return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? Jk(Hk(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"];
      case "selector-combinator":
        if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
          const t3 = e20.getParentNode();
          return [t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : MN, r2.value, ok(e20, r2) ? "" : " "];
        }
        return [r2.value.trim().startsWith("(") ? MN : "", Xk(Hk(r2.value.trim(), t2)) || MN];
      case "selector-universal":
        return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
      case "selector-pseudo":
        return [QN(r2.value), jN(r2.nodes) ? ["(", _N(", ", e20.map(n2, "nodes")), ")"] : ""];
      case "selector-nesting":
        return r2.value;
      case "selector-unknown": {
        const n3 = YN(e20, "css-rule");
        if (n3 && n3.isSCSSNesterProperty)
          return Xk(Hk(QN(r2.value), t2));
        const i2 = e20.getParentNode();
        if (i2.raws && i2.raws.selector) {
          const e21 = Vk(i2), n4 = e21 + i2.raws.selector.length;
          return t2.originalText.slice(e21, n4).trim();
        }
        const u2 = e20.getParentNode(1);
        if (i2.type === "value-paren_group" && u2 && u2.type === "value-func" && u2.value === "selector") {
          const e21 = Vk(i2.open) + 1, n4 = Wk(i2.close) - 1, r3 = t2.originalText.slice(e21, n4).trim();
          return Rk(r3) ? [GN, r3] : r3;
        }
        return r2.value;
      }
      case "value-value":
      case "value-root":
        return n2("group");
      case "value-comment":
        return t2.originalText.slice(Vk(r2), Wk(r2));
      case "value-comma_group": {
        const t3 = e20.getParentNode(), i2 = e20.getParentNode(1), u2 = KN(e20), o2 = u2 && t3.type === "value-value" && (u2 === "grid" || u2.startsWith("grid-template")), s2 = YN(e20, "css-atrule"), a2 = s2 && ak(s2), c2 = r2.groups.some((e21) => kk(e21)), l2 = e20.map(n2, "groups"), p2 = [], f2 = ZN(e20, "url");
        let d2 = false, h2 = false;
        for (let n3 = 0; n3 < r2.groups.length; ++n3) {
          p2.push(l2[n3]);
          const u3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
          if (f2) {
            (g2 && hk(g2) || hk(c3)) && p2.push(" ");
            continue;
          }
          if (tk(e20, "forward") && c3.type === "value-word" && c3.value && u3.type === "value-word" && u3.value === "as" && g2.type === "value-operator" && g2.value === "*")
            continue;
          if (!g2)
            continue;
          if (c3.type === "value-word" && c3.value.endsWith("-") && $k(g2))
            continue;
          const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
          if (y2 || D2) {
            d2 = !d2;
            continue;
          }
          if (d2)
            continue;
          if (jk(c3) || jk(g2))
            continue;
          if (c3.type === "value-atword" && c3.value === "")
            continue;
          if (c3.value === "~")
            continue;
          if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
            continue;
          if (u3 && u3.value && u3.value.indexOf("\\") === u3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
            continue;
          if (c3.value === "\\")
            continue;
          if (Bk(c3, g2))
            continue;
          if (Pk(c3) || Ok(c3) || Ik(g2) || Ok(g2) && vk(g2) || Ik(c3) && vk(g2))
            continue;
          if (c3.value === "--" && Pk(g2))
            continue;
          const E2 = mk(c3), C2 = mk(g2);
          if ((E2 && Pk(g2) || C2 && Ik(c3)) && vk(g2))
            continue;
          if (!u3 && dk(c3))
            continue;
          if (ZN(e20, "calc") && (hk(c3) || hk(g2) || gk(c3) || gk(g2)) && vk(g2))
            continue;
          const b2 = (hk(c3) || gk(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && i2 && Mk(i2) && !vk(g2), A2 = m2 && m2.type === "value-func" || m2 && Lk(m2) || c3.type === "value-func" || Lk(c3), v2 = g2.type === "value-func" || Lk(g2) || u3 && u3.type === "value-func" || u3 && Lk(u3);
          if (fk(g2) || fk(c3) || ZN(e20, "calc") || b2 || !(dk(g2) && !A2 || dk(c3) && !v2 || hk(g2) && !A2 || hk(c3) && !v2 || gk(g2) || gk(c3)) || !(vk(g2) || E2 && (!u3 || u3 && mk(u3))))
            if (kk(c3)) {
              if (t3.type === "value-paren_group") {
                p2.push(UN(RN));
                continue;
              }
              p2.push(RN);
            } else
              a2 && (pk(g2) || lk(g2) || Ck(g2) || yk(c3) || Dk(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : o2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(RN), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || $k(c3) && $k(g2) && Wk(c3) === Vk(g2) || p2.push(MN);
        }
        return c2 && p2.push(GN), h2 && p2.unshift(RN), a2 ? VN(qN(p2)) : nk(e20) ? VN(WN(p2)) : VN(qN(WN(p2)));
      }
      case "value-paren_group": {
        const i2 = e20.getParentNode();
        if (i2 && Ek(i2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
          return [r2.open ? n2("open") : "", _N(",", e20.map(n2, "groups")), r2.close ? n2("close") : ""];
        if (!r2.open) {
          const t3 = e20.map(n2, "groups"), r3 = [];
          for (let e21 = 0; e21 < t3.length; e21++)
            e21 !== 0 && r3.push([",", MN]), r3.push(t3[e21]);
          return VN(qN(WN(r3)));
        }
        const u2 = Nk(e20), o2 = Ln$2(r2.groups), s2 = o2 && o2.type === "value-comment", a2 = Sk(r2, i2), c2 = VN([r2.open ? n2("open") : "", qN([$N, _N([",", MN], e20.map((e21) => {
          const t3 = e21.getValue(), r3 = n2();
          if (Fk(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
            const e22 = JN(r3.contents.contents);
            return e22[1] = VN(e22[1]), VN(UN(r3));
          }
          return r3;
        }, "groups"))]), zN(!s2 && uk(t2.parser, t2.originalText) && u2 && qk(t2) ? "," : ""), $N, r2.close ? n2("close") : ""], {shouldBreak: u2 && !a2});
        return a2 ? UN(c2) : c2;
      }
      case "value-func":
        return [r2.value, tk(e20, "supports") && _k(r2) ? " " : "", n2("group")];
      case "value-paren":
        return r2.value;
      case "value-number":
        return [Yk(r2.value), QN(r2.unit)];
      case "value-operator":
        return r2.value;
      case "value-word":
        return r2.isColor && r2.isHex || ik(r2.value) ? r2.value.toLowerCase() : r2.value;
      case "value-colon": {
        const t3 = e20.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), i2 = n3 && t3.groups[n3 - 1];
        return [r2.value, i2 && typeof i2.value == "string" && Ln$2(i2.value) === "\\" || ZN(e20, "url") ? "" : MN];
      }
      case "value-comma":
        return [r2.value, " "];
      case "value-string":
        return PN(r2.raws.quote + r2.value + r2.raws.quote, t2);
      case "value-atword":
        return ["@", r2.value];
      case "value-unicode-range":
      case "value-unknown":
        return r2.value;
      default:
        throw new Error(`Unknown postcss type ${JSON.stringify(r2.type)}`);
    }
  }, embed: uN, insertPragma: XN, massageAstNode: eN}, Qk = {singleQuote: WB.singleQuote}, Zk = {name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437}, eP = {name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198}, tP = {name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329};
  var nP = {languages: [Xd({name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50}, (e20) => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e20.extensions, ".wxss"]})), Xd(Zk, () => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"]})), Xd(eP, () => ({since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"]})), Xd(tP, () => ({since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"]}))], options: Qk, printers: {postcss: Kk}, parsers: void 0};
  var rP = {locStart: function(e20) {
    return e20.loc.start.offset;
  }, locEnd: function(e20) {
    return e20.loc.end.offset;
  }};
  function iP(e20, t2) {
    if (e20.type === "TextNode") {
      const n2 = e20.chars.trim();
      if (!n2)
        return null;
      t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
    }
    e20.type === "AttrNode" && e20.name.toLowerCase() === "class" && delete t2.value;
  }
  iP.ignoredProperties = new Set(["loc", "selfClosing"]);
  var uP = iP;
  const oP = new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
  function sP(e20) {
    return aP(e20, ["TextNode"]) && !/\S/.test(e20.chars);
  }
  function aP(e20, t2) {
    return e20 && t2.includes(e20.type);
  }
  function cP(e20, t2) {
    return aP(e20.getParentNode(0), t2);
  }
  function lP(e20, t2) {
    const n2 = e20.getValue(), r2 = e20.getParentNode(0) || {}, i2 = r2.children || r2.body || r2.parts || [], u2 = i2.indexOf(n2);
    return u2 !== -1 && i2[u2 + t2];
  }
  function pP(e20, t2 = 1) {
    return lP(e20, -t2);
  }
  function fP(e20) {
    return lP(e20, 1);
  }
  function dP(e20) {
    return aP(e20, ["MustacheCommentStatement"]) && typeof e20.value == "string" && e20.value.trim() === "prettier-ignore";
  }
  var hP = {getNextNode: fP, getPreviousNode: pP, hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue(), n2 = pP(e20, 2);
    return dP(t2) || dP(n2);
  }, isLastNodeOfSiblings: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode(0);
    return !(!cP(e20, ["ElementNode"]) || Ln$2(n2.children) !== t2) || !(!cP(e20, ["Block"]) || Ln$2(n2.body) !== t2);
  }, isNextNodeOfSomeType: function(e20, t2) {
    return aP(fP(e20), t2);
  }, isNodeOfSomeType: aP, isParentOfSomeType: cP, isPreviousNodeOfSomeType: function(e20, t2) {
    return aP(pP(e20), t2);
  }, isVoid: function(e20) {
    return function(e21) {
      return aP(e21, ["ElementNode"]) && typeof e21.tag == "string" && (function(e22) {
        return e22.toUpperCase() === e22;
      }(e21.tag[0]) || e21.tag.includes("."));
    }(e20) && e20.children.every((e21) => sP(e21)) || oP.has(e20.tag);
  }, isWhitespaceNode: sP};
  const {builders: {dedent: gP, fill: mP, group: yP, hardline: DP, ifBreak: EP, indent: CP, join: bP, line: AP, softline: vP}, utils: {getDocParts: FP, replaceTextEndOfLine: SP}} = eu$1, {isNonEmptyArray: xP} = yi$2, {locStart: wP, locEnd: TP} = rP, {getNextNode: BP, getPreviousNode: NP, hasPrettierIgnore: kP, isLastNodeOfSiblings: PP, isNextNodeOfSomeType: OP, isNodeOfSomeType: IP, isParentOfSomeType: LP, isPreviousNodeOfSomeType: jP, isVoid: _P, isWhitespaceNode: MP} = hP;
  function RP(e20, t2) {
    return wP(e20) - wP(t2);
  }
  function $P(e20, t2, n2) {
    const r2 = e20.getValue().children.every((e21) => MP(e21));
    return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e20.map((e21, r3) => {
      const i2 = n2();
      return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [vP, i2] : i2;
    }, "children");
  }
  function VP(e20) {
    return _P(e20) ? EP([vP, "/>"], [" />", vP]) : EP([vP, ">"], ">");
  }
  function WP(e20) {
    return [e20.escaped === false ? "{{{" : "{{", e20.strip && e20.strip.open ? "~" : ""];
  }
  function qP(e20) {
    const t2 = e20.escaped === false ? "}}}" : "}}";
    return [e20.strip && e20.strip.close ? "~" : "", t2];
  }
  function UP(e20) {
    return [WP(e20), e20.closeStrip.open ? "~" : "", "/"];
  }
  function zP(e20) {
    const t2 = qP(e20);
    return [e20.closeStrip.close ? "~" : "", t2];
  }
  function GP(e20) {
    return [WP(e20), e20.inverseStrip.open ? "~" : ""];
  }
  function HP(e20) {
    const t2 = qP(e20);
    return [e20.inverseStrip.close ? "~" : "", t2];
  }
  function JP(e20, t2) {
    const n2 = e20.getValue(), r2 = function(e21) {
      return [WP(e21), e21.openStrip.open ? "~" : "", "#"];
    }(n2), i2 = function(e21) {
      const t3 = qP(e21);
      return [e21.openStrip.close ? "~" : "", t3];
    }(n2), u2 = [aO(e20, t2)], o2 = cO(e20, t2);
    if (o2 && u2.push(AP, o2), xP(n2.program.blockParams)) {
      const e21 = lO(n2.program);
      u2.push(AP, e21);
    }
    return yP([r2, CP(u2), vP, i2]);
  }
  function XP(e20, t2) {
    return [t2.htmlWhitespaceSensitivity === "ignore" ? DP : "", GP(e20), "else", HP(e20)];
  }
  function YP(e20, t2) {
    const n2 = e20.getParentNode(1);
    return [GP(n2), "else if ", cO(e20, t2), HP(n2)];
  }
  function KP(e20, t2, n2) {
    const r2 = e20.getValue();
    if (n2.htmlWhitespaceSensitivity === "ignore") {
      return [QP(r2) ? vP : DP, UP(r2), t2("path"), zP(r2)];
    }
    return [UP(r2), t2("path"), zP(r2)];
  }
  function QP(e20) {
    return IP(e20, ["BlockStatement"]) && e20.program.body.every((e21) => MP(e21));
  }
  function ZP(e20) {
    return IP(e20, ["BlockStatement"]) && e20.inverse;
  }
  function eO(e20, t2, n2) {
    if (QP(e20.getValue()))
      return "";
    const r2 = t2("program");
    return n2.htmlWhitespaceSensitivity === "ignore" ? CP([DP, r2]) : CP(r2);
  }
  function tO(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2("inverse"), u2 = n2.htmlWhitespaceSensitivity === "ignore" ? [DP, i2] : i2;
    return function(e21) {
      return ZP(e21) && e21.inverse.body.length === 1 && IP(e21.inverse.body[0], ["BlockStatement"]) && e21.inverse.body[0].path.parts[0] === "if";
    }(r2) ? u2 : ZP(r2) ? [XP(r2, n2), CP(u2)] : "";
  }
  function nO(e20) {
    return FP(bP(AP, function(e21) {
      return e21.split(/[\t\n\f\r ]+/);
    }(e20)));
  }
  function rO(e20) {
    return (e20 = typeof e20 == "string" ? e20 : "").split("\n").length - 1;
  }
  function iO(e20 = 0) {
    return new Array(Math.min(e20, 2)).fill(DP);
  }
  function uO(e20, t2) {
    const n2 = {quote: '"', regex: /"/g}, r2 = {quote: "'", regex: /'/g}, i2 = e20.singleQuote ? r2 : n2, u2 = i2 === r2 ? n2 : r2;
    let o2 = false;
    if (t2.includes(i2.quote) || t2.includes(u2.quote)) {
      o2 = (t2.match(i2.regex) || []).length > (t2.match(u2.regex) || []).length;
    }
    return o2 ? u2 : i2;
  }
  function oO(e20, t2) {
    const n2 = aO(e20, t2), r2 = cO(e20, t2);
    return r2 ? CP([n2, AP, yP(r2)]) : n2;
  }
  function sO(e20, t2) {
    const n2 = aO(e20, t2), r2 = cO(e20, t2);
    return r2 ? [CP([n2, AP, r2]), vP] : n2;
  }
  function aO(e20, t2) {
    return t2("path");
  }
  function cO(e20, t2) {
    const n2 = e20.getValue(), r2 = [];
    if (n2.params.length > 0) {
      const n3 = e20.map(t2, "params");
      r2.push(...n3);
    }
    if (n2.hash && n2.hash.pairs.length > 0) {
      const e21 = t2("hash");
      r2.push(e21);
    }
    return r2.length === 0 ? "" : bP(AP, r2);
  }
  function lO(e20) {
    return ["as |", e20.blockParams.join(" "), "|"];
  }
  var pO = {print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (kP(e20))
      return t2.originalText.slice(wP(r2), TP(r2));
    switch (r2.type) {
      case "Block":
      case "Program":
      case "Template":
        return yP(e20.map(n2, "body"));
      case "ElementNode": {
        const i2 = yP(function(e21, t3) {
          const n3 = e21.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e22) => xP(n3[e22])), i3 = r3.flatMap((e22) => n3[e22]).sort(RP);
          for (const n4 of r3)
            e21.each((e22) => {
              const n5 = i3.indexOf(e22.getValue());
              i3.splice(n5, 1, [AP, t3()]);
            }, n4);
          xP(n3.blockParams) && i3.push(AP, lO(n3));
          return ["<", n3.tag, CP(i3), VP(n3)];
        }(e20, n2)), u2 = t2.htmlWhitespaceSensitivity === "ignore" && OP(e20, ["ElementNode"]) ? vP : "";
        if (_P(r2))
          return [i2, u2];
        const o2 = ["</", r2.tag, ">"];
        return r2.children.length === 0 ? [i2, CP(o2), u2] : t2.htmlWhitespaceSensitivity === "ignore" ? [i2, CP($P(e20, t2, n2)), DP, CP(o2), u2] : [i2, CP(yP($P(e20, t2, n2))), CP(o2), u2];
      }
      case "BlockStatement": {
        const i2 = e20.getParentNode(1);
        return i2 && i2.inverse && i2.inverse.body.length === 1 && i2.inverse.body[0] === r2 && i2.inverse.body[0].path.parts[0] === "if" ? [YP(e20, n2), eO(e20, n2, t2), tO(e20, n2, t2)] : [JP(e20, n2), yP([eO(e20, n2, t2), tO(e20, n2, t2), KP(e20, n2, t2)])];
      }
      case "ElementModifierStatement":
        return yP(["{{", sO(e20, n2), "}}"]);
      case "MustacheStatement":
        return yP([WP(r2), sO(e20, n2), qP(r2)]);
      case "SubExpression":
        return yP(["(", oO(e20, n2), vP, ")"]);
      case "AttrNode": {
        const e21 = r2.value.type === "TextNode";
        if (e21 && r2.value.chars === "" && wP(r2.value) === TP(r2.value))
          return r2.name;
        const i2 = e21 ? uO(t2, r2.value.chars).quote : r2.value.type === "ConcatStatement" ? uO(t2, r2.value.parts.filter((e22) => e22.type === "TextNode").map((e22) => e22.chars).join("")).quote : "", u2 = n2("value");
        return [r2.name, "=", i2, r2.name === "class" && i2 ? yP(CP(u2)) : u2, i2];
      }
      case "ConcatStatement":
        return e20.map(n2, "parts");
      case "Hash":
        return bP(AP, e20.map(n2, "pairs"));
      case "HashPair":
        return [r2.key, "=", n2("value")];
      case "TextNode": {
        let n3 = r2.chars.replace(/{{/g, "\\{{");
        const i2 = function(e21) {
          for (let t3 = 0; t3 < 2; t3++) {
            const n4 = e21.getParentNode(t3);
            if (n4 && n4.type === "AttrNode")
              return n4.name.toLowerCase();
          }
        }(e20);
        if (i2) {
          if (i2 === "class") {
            const t3 = n3.trim().split(/\s+/).join(" ");
            let r3 = false, i3 = false;
            return LP(e20, ["ConcatStatement"]) && (jP(e20, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), OP(e20, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (i3 = true)), [r3 ? AP : "", t3, i3 ? AP : ""];
          }
          return SP(n3);
        }
        const u2 = /^[\t\n\f\r ]*$/.test(n3), o2 = !NP(e20), s2 = !BP(e20);
        if (t2.htmlWhitespaceSensitivity !== "ignore") {
          const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, i3 = s2 && LP(e20, ["Template"]), a3 = o2 && LP(e20, ["Template"]);
          if (u2) {
            if (a3 || i3)
              return "";
            let t4 = [AP];
            const r4 = rO(n3);
            return r4 && (t4 = iO(r4)), PP(e20) && (t4 = t4.map((e21) => gP(e21))), t4;
          }
          const [c3] = n3.match(t3), [l3] = n3.match(r3);
          let p3 = [];
          if (c3) {
            p3 = [AP];
            const e21 = rO(c3);
            e21 && (p3 = iO(e21)), n3 = n3.replace(t3, "");
          }
          let f3 = [];
          if (l3) {
            if (!i3) {
              f3 = [AP];
              const t4 = rO(l3);
              t4 && (f3 = iO(t4)), PP(e20) && (f3 = f3.map((e21) => gP(e21)));
            }
            n3 = n3.replace(r3, "");
          }
          return [...p3, mP(nO(n3)), ...f3];
        }
        const a2 = rO(n3);
        let c2 = function(e21) {
          return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
        }(n3), l2 = function(e21) {
          return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
        }(n3);
        if ((o2 || s2) && u2 && LP(e20, ["Block", "ElementNode", "Template"]))
          return "";
        u2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (OP(e20, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), jP(e20, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
        let p2 = "", f2 = "";
        return l2 === 0 && OP(e20, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && jP(e20, ["MustacheStatement"]) && (p2 = " "), o2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...iO(c2), mP(nO(n3)), ...iO(l2)];
      }
      case "MustacheCommentStatement": {
        const e21 = wP(r2), n3 = TP(r2), i2 = t2.originalText.charAt(e21 + 2) === "~", u2 = t2.originalText.charAt(n3 - 3) === "~", o2 = r2.value.includes("}}") ? "--" : "";
        return ["{{", i2 ? "~" : "", "!", o2, r2.value, o2, u2 ? "~" : "", "}}"];
      }
      case "PathExpression":
        return r2.original;
      case "BooleanLiteral":
        return String(r2.value);
      case "CommentStatement":
        return ["<!--", r2.value, "-->"];
      case "StringLiteral":
        return function(e21, t3) {
          const {quote: n3, regex: r3} = uO(t3, e21);
          return [n3, e21.replace(r3, `\\${n3}`), n3];
        }(r2.value, t2);
      case "NumberLiteral":
        return String(r2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
    }
  }, massageAstNode: uP};
  var fO = {languages: [Xd({name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155}, () => ({since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"]}))], printers: {glimmer: pO}, parsers: void 0};
  var dO = {hasPragma: function(e20) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e20);
  }, insertPragma: function(e20) {
    return "# @format\n\n" + e20;
  }};
  var hO = {locStart: function(e20) {
    return typeof e20.start == "number" ? e20.start : e20.loc && e20.loc.start;
  }, locEnd: function(e20) {
    return typeof e20.end == "number" ? e20.end : e20.loc && e20.loc.end;
  }};
  const {builders: {join: gO, hardline: mO, line: yO, softline: DO, group: EO, indent: CO, ifBreak: bO}} = eu$1, {isNextLineEmpty: AO, isNonEmptyArray: vO} = yi$2, {insertPragma: FO} = dO, {locStart: SO, locEnd: xO} = hO;
  function wO(e20, t2, n2) {
    if (n2.directives.length === 0)
      return "";
    const r2 = gO(yO, e20.map(t2, "directives"));
    return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EO([yO, r2]) : [" ", EO(CO([DO, r2]))];
  }
  function TO(e20, t2, n2) {
    const r2 = e20.getValue().length;
    return e20.map((e21, i2) => {
      const u2 = n2();
      return AO(t2.originalText, e21.getValue(), xO) && i2 < r2 - 1 ? [u2, mO] : u2;
    });
  }
  function BO(e20, t2, n2) {
    const r2 = e20.getNode(), i2 = [], {interfaces: u2} = r2, o2 = e20.map((e21) => n2(e21), "interfaces");
    for (let e21 = 0; e21 < u2.length; e21++) {
      const n3 = u2[e21];
      i2.push(o2[e21]);
      const r3 = u2[e21 + 1];
      if (r3) {
        const e22 = t2.originalText.slice(n3.loc.end, r3.loc.start), u3 = e22.includes("#"), o3 = e22.replace(/#.*/g, "").trim();
        i2.push(o3 === "," ? "," : " &", u3 ? yO : " ");
      }
    }
    return i2;
  }
  function NO() {
  }
  NO.ignoredProperties = new Set(["loc", "comments"]);
  var kO = {print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.kind) {
      case "Document": {
        const r3 = [];
        return e20.each((e21, i2, u2) => {
          r3.push(n2()), i2 !== u2.length - 1 && (r3.push(mO), AO(t2.originalText, e21.getValue(), xO) && r3.push(mO));
        }, "definitions"), [...r3, mO];
      }
      case "OperationDefinition": {
        const i2 = t2.originalText[SO(r2)] !== "{", u2 = Boolean(r2.name);
        return [i2 ? r2.operation : "", i2 && u2 ? [" ", n2("name")] : "", i2 && !u2 && vO(r2.variableDefinitions) ? " " : "", vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))]), DO, ")"]) : "", wO(e20, n2, r2), r2.selectionSet && (i2 || u2) ? " " : "", n2("selectionSet")];
      }
      case "FragmentDefinition":
        return ["fragment ", n2("name"), vO(r2.variableDefinitions) ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))]), DO, ")"]) : "", " on ", n2("typeCondition"), wO(e20, n2, r2), " ", n2("selectionSet")];
      case "SelectionSet":
        return ["{", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "selections"))]), mO, "}"];
      case "Field":
        return EO([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", wO(e20, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
      case "Name":
        return r2.value;
      case "StringValue":
        return r2.block ? ['"""', mO, gO(mO, r2.value.replace(/"""/g, "\\$&").split("\n")), mO, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return r2.value;
      case "BooleanValue":
        return r2.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", n2("name")];
      case "ListValue":
        return EO(["[", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "values"))]), DO, "]"]);
      case "ObjectValue":
        return EO(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", CO([DO, gO([bO("", ", "), DO], e20.map(n2, "fields"))]), DO, bO("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
      case "ObjectField":
      case "Argument":
        return [n2("name"), ": ", n2("value")];
      case "Directive":
        return ["@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : ""];
      case "NamedType":
        return n2("name");
      case "VariableDefinition":
        return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e20, n2, r2)];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "", wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
      case "FieldDefinition":
        return [n2("description"), r2.description ? mO : "", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", ": ", n2("type"), wO(e20, n2, r2)];
      case "DirectiveDefinition":
        return [n2("description"), r2.description ? mO : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? EO(["(", CO([DO, gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))]), DO, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", gO(" | ", e20.map(n2, "locations"))];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), wO(e20, n2, r2), r2.values.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "values"))]), mO, "}"] : ""];
      case "EnumValueDefinition":
        return [n2("description"), r2.description ? mO : "", n2("name"), wO(e20, n2, r2)];
      case "InputValueDefinition":
        return [n2("description"), r2.description ? r2.description.block ? mO : yO : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wO(e20, n2, r2)];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
      case "SchemaDefinition":
        return ["schema", wO(e20, n2, r2), " {", r2.operationTypes.length > 0 ? CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "operationTypes"))]) : "", mO, "}"];
      case "OperationTypeDefinition":
        return [n2("operation"), ": ", n2("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "", wO(e20, n2, r2), r2.fields.length > 0 ? [" {", CO([mO, gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))]), mO, "}"] : ""];
      case "FragmentSpread":
        return ["...", n2("name"), wO(e20, n2, r2)];
      case "InlineFragment":
        return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", wO(e20, n2, r2), " ", n2("selectionSet")];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return EO([n2("description"), r2.description ? mO : "", EO([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), wO(e20, n2, r2), r2.types.length > 0 ? [" =", bO("", " "), CO([bO([yO, "  "]), gO([yO, "| "], e20.map(n2, "types"))])] : ""])]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [n2("description"), r2.description ? mO : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), wO(e20, n2, r2)];
      case "NonNullType":
        return [n2("type"), "!"];
      case "ListType":
        return ["[", n2("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
    }
  }, massageAstNode: NO, hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue();
    return t2 && Array.isArray(t2.comments) && t2.comments.some((e21) => e21.value.trim() === "prettier-ignore");
  }, insertPragma: FO, printComment: function(e20) {
    const t2 = e20.getValue();
    if (t2.kind === "Comment")
      return "#" + t2.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify(t2));
  }, canAttachComment: function(e20) {
    return e20.kind && e20.kind !== "Comment";
  }}, PO = {bracketSpacing: WB.bracketSpacing};
  var OO = {languages: [Xd({name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139}, () => ({since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"]}))], options: PO, printers: {graphql: kO}, parsers: void 0};
  var IO = {locStart: function(e20) {
    return e20.position.start.offset;
  }, locEnd: function(e20) {
    return e20.position.end.offset;
  }};
  const {getLast: LO} = yi$2, {locStart: jO, locEnd: _O} = IO, {cjkPattern: MO, kPattern: RO, punctuationPattern: $O} = {cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"}, VO = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], WO = [...VO, "tableCell", "paragraph", "heading"], qO = new RegExp(RO), UO = new RegExp($O);
  function zO(e20, t2) {
    const [, n2, r2, i2] = t2.slice(e20.position.start.offset, e20.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return {numberText: n2, marker: r2, leadingSpaces: i2};
  }
  var GO = {mapAst: function(e20, t2) {
    return function e21(n2, r2, i2) {
      const u2 = Object.assign({}, t2(n2, r2, i2));
      return u2.children && (u2.children = u2.children.map((t3, n3) => e21(t3, n3, [u2, ...i2]))), u2;
    }(e20, null, []);
  }, splitText: function(e20, t2) {
    const n2 = "non-cjk", r2 = "cj-letter", i2 = "cjk-punctuation", u2 = [], o2 = (t2.proseWrap === "preserve" ? e20 : e20.replace(new RegExp(`(${MO})
(${MO})`, "g"), "$1$2")).split(/([\t\n ]+)/);
    for (const [e21, t3] of o2.entries()) {
      if (e21 % 2 == 1) {
        u2.push({type: "whitespace", value: /\n/.test(t3) ? "\n" : " "});
        continue;
      }
      if ((e21 === 0 || e21 === o2.length - 1) && t3 === "")
        continue;
      const a2 = t3.split(new RegExp(`(${MO})`));
      for (const [e22, t4] of a2.entries())
        (e22 !== 0 && e22 !== a2.length - 1 || t4 !== "") && (e22 % 2 != 0 ? s2(UO.test(t4) ? {type: "word", value: t4, kind: i2, hasLeadingPunctuation: true, hasTrailingPunctuation: true} : {type: "word", value: t4, kind: qO.test(t4) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false}) : t4 !== "" && s2({type: "word", value: t4, kind: n2, hasLeadingPunctuation: UO.test(t4[0]), hasTrailingPunctuation: UO.test(LO(t4))}));
    }
    return u2;
    function s2(e21) {
      const t3 = LO(u2);
      var o3, s3;
      t3 && t3.type === "word" && (t3.kind === n2 && e21.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e21.kind === n2 && !e21.hasLeadingPunctuation ? u2.push({type: "whitespace", value: " "}) : (o3 = n2, s3 = i2, t3.kind === o3 && e21.kind === s3 || t3.kind === s3 && e21.kind === o3 || [t3.value, e21.value].some((e22) => /\u3000/.test(e22)) || u2.push({type: "whitespace", value: ""}))), u2.push(e21);
    }
  }, punctuationPattern: $O, getFencedCodeBlockValue: function(e20, t2) {
    const {value: n2} = e20;
    return e20.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
  }, getOrderedListItemInfo: zO, hasGitDiffFriendlyOrderedList: function(e20, t2) {
    if (!e20.ordered)
      return false;
    if (e20.children.length < 2)
      return false;
    const n2 = Number(zO(e20.children[0], t2.originalText).numberText), r2 = Number(zO(e20.children[1], t2.originalText).numberText);
    if (n2 === 0 && e20.children.length > 2) {
      const n3 = Number(zO(e20.children[2], t2.originalText).numberText);
      return r2 === 1 && n3 === 1;
    }
    return r2 === 1;
  }, INLINE_NODE_TYPES: VO, INLINE_NODE_WRAPPER_TYPES: WO, isAutolink: function(e20) {
    if (!e20 || e20.type !== "link" || e20.children.length !== 1)
      return false;
    const t2 = e20.children[0];
    return t2 && jO(e20) === jO(t2) && _O(e20) === _O(t2);
  }};
  const {inferParserByLanguage: HO, getMaxContinuousCount: JO} = yi$2, {builders: {hardline: XO, markAsRoot: YO}, utils: {replaceEndOfLine: KO}} = eu$1, {getFencedCodeBlockValue: QO} = GO;
  var ZO = function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    if (i2.type === "code" && i2.lang !== null) {
      const e21 = HO(i2.lang, r2);
      if (e21) {
        const t3 = r2.__inJsTemplate ? "~" : "`", u2 = t3.repeat(Math.max(3, JO(i2.value, t3) + 1)), o2 = n2(QO(i2, r2.originalText), {parser: e21}, {stripTrailingHardline: true});
        return YO([u2, i2.lang, i2.meta ? " " + i2.meta : "", XO, KO(o2), XO, u2]);
      }
    }
    switch (i2.type) {
      case "front-matter":
        return rN(i2, n2);
      case "importExport":
        return [n2(i2.value, {parser: "babel"}, {stripTrailingHardline: true}), XO];
      case "jsx":
        return n2(`<$>${i2.value}</$>`, {parser: "__js_expression", rootMarker: "mdx"}, {stripTrailingHardline: true});
    }
    return null;
  };
  const eI = ["format", "prettier"];
  function tI(e20) {
    const t2 = `@(${eI.join("|")})`, n2 = new RegExp([`<!--\\s*${t2}\\s*-->`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t2}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), r2 = e20.match(n2);
    return r2 && r2.index === 0;
  }
  var nI = {startWithPragma: tI, hasPragma: (e20) => tI(sN(e20).content.trimStart()), insertPragma: (e20) => {
    const t2 = sN(e20), n2 = `<!-- @${eI[0]} -->`;
    return t2.frontMatter ? `${t2.frontMatter.raw}

${n2}

${t2.content}` : `${n2}

${t2.content}`;
  }};
  const {getOrderedListItemInfo: rI, mapAst: iI, splitText: uI} = GO, oI = /^.$/us;
  function sI(e20, t2, n2) {
    return iI(e20, (e21) => {
      if (!e21.children)
        return e21;
      const r2 = e21.children.reduce((e22, r3) => {
        const i2 = Ln$2(e22);
        return i2 && t2(i2, r3) ? e22.splice(-1, 1, n2(i2, r3)) : e22.push(r3), e22;
      }, []);
      return Object.assign(Object.assign({}, e21), {}, {children: r2});
    });
  }
  var aI = function(e20, t2) {
    return e20 = function(e21) {
      return sI(e21, (e22, t3) => e22.type === "importExport" && t3.type === "importExport", (e22, t3) => ({type: "importExport", value: e22.value + "\n\n" + t3.value, position: {start: e22.position.start, end: t3.position.end}}));
    }(e20 = function(e21) {
      return iI(e21, (e22) => e22.type !== "import" && e22.type !== "export" ? e22 : Object.assign(Object.assign({}, e22), {}, {type: "importExport"}));
    }(e20 = function(e21, t3) {
      return iI(e21, (e22, n2, [r2]) => {
        if (e22.type !== "text")
          return e22;
        let {value: i2} = e22;
        return r2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === r2.children.length - 1 && (i2 = i2.trimEnd())), {type: "sentence", position: e22.position, children: uI(i2, t3)};
      });
    }(e20 = function(e21, t3) {
      return iI(e21, (e22, t4, n3) => {
        if (e22.type === "list" && e22.children.length > 0) {
          for (let t5 = 0; t5 < n3.length; t5++) {
            const r3 = n3[t5];
            if (r3.type === "list" && !r3.isAligned)
              return e22.isAligned = false, e22;
          }
          e22.isAligned = r2(e22);
        }
        return e22;
      });
      function n2(e22) {
        return e22.children.length === 0 ? -1 : e22.children[0].position.start.column - 1;
      }
      function r2(e22) {
        if (!e22.ordered)
          return true;
        const [r3, i2] = e22.children;
        if (rI(r3, t3.originalText).leadingSpaces.length > 1)
          return true;
        const u2 = n2(r3);
        if (u2 === -1)
          return false;
        if (e22.children.length === 1)
          return u2 % t3.tabWidth == 0;
        if (u2 !== n2(i2))
          return false;
        if (u2 % t3.tabWidth == 0)
          return true;
        return rI(i2, t3.originalText).leadingSpaces.length > 1;
      }
    }(e20 = function(e21, t3) {
      return iI(e21, (e22, n2, r2) => {
        if (e22.type === "code") {
          const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e22.position.start.offset, e22.position.end.offset));
          if (e22.isIndented = n3, n3)
            for (let e23 = 0; e23 < r2.length; e23++) {
              const t4 = r2[e23];
              if (t4.hasIndentedCodeblock)
                break;
              t4.type === "list" && (t4.hasIndentedCodeblock = true);
            }
        }
        return e22;
      });
    }(e20 = function(e21) {
      return iI(e21, (e22) => e22.type !== "inlineCode" ? e22 : Object.assign(Object.assign({}, e22), {}, {value: e22.value.replace(/\s+/g, " ")}));
    }(e20 = function(e21) {
      return sI(e21, (e22, t3) => e22.type === "text" && t3.type === "text", (e22, t3) => ({type: "text", value: e22.value + t3.value, position: {start: e22.position.start, end: t3.position.end}}));
    }(e20 = function(e21, t3) {
      return iI(e21, (e22) => e22.type === "text" && e22.value !== "*" && e22.value !== "_" && oI.test(e22.value) && e22.position.end.offset - e22.position.start.offset !== e22.value.length ? Object.assign(Object.assign({}, e22), {}, {value: t3.originalText.slice(e22.position.start.offset, e22.position.end.offset)}) : e22);
    }(e20, t2))), t2), t2), t2)));
  };
  const {isFrontMatterNode: cI} = yi$2, {startWithPragma: lI} = nI, pI = new Set(["position", "raw"]);
  function fI(e20, t2, n2) {
    return e20.type !== "front-matter" && e20.type !== "code" && e20.type !== "yaml" && e20.type !== "import" && e20.type !== "export" && e20.type !== "jsx" || delete t2.value, e20.type === "list" && delete t2.isAligned, e20.type !== "list" && e20.type !== "listItem" || (delete t2.spread, delete t2.loose), e20.type === "text" ? null : (e20.type === "inlineCode" && (t2.value = e20.value.replace(/[\t\n ]+/g, " ")), e20.type === "wikiLink" && (t2.value = e20.value.trim().replace(/[\t\n]+/g, " ")), e20.type !== "definition" && e20.type !== "linkReference" || (t2.label = e20.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e20.type !== "definition" && e20.type !== "link" && e20.type !== "image" || !e20.title || (t2.title = e20.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e20 || cI(n2.children[0]) && n2.children[1] === e20) && e20.type === "html" && lI(e20.value) ? null : void 0);
  }
  fI.ignoredProperties = pI;
  var dI = fI;
  const {getLast: hI, getMinNotPresentContinuousCount: gI, getMaxContinuousCount: mI, getStringWidth: yI, isNonEmptyArray: DI} = yi$2, {builders: {breakParent: EI, join: CI, line: bI, literalline: AI, markAsRoot: vI, hardline: FI, softline: SI, ifBreak: xI, fill: wI, align: TI, indent: BI, group: NI, hardlineWithoutBreakParent: kI}, utils: {normalizeDoc: PI, replaceTextEndOfLine: OI}, printer: {printDocToString: II}} = eu$1, {insertPragma: LI} = nI, {locStart: jI, locEnd: _I} = IO, {getFencedCodeBlockValue: MI, hasGitDiffFriendlyOrderedList: RI, splitText: $I, punctuationPattern: VI, INLINE_NODE_TYPES: WI, INLINE_NODE_WRAPPER_TYPES: qI, isAutolink: UI} = GO, zI = new Set(["importExport"]), GI = ["heading", "tableCell", "link", "wikiLink"], HI = new Set(["listItem", "definition", "footnoteDefinition"]);
  function JI(e20, t2, n2, r2) {
    const i2 = e20.getValue(), u2 = i2.checked === null ? "" : i2.checked ? "[x] " : "[ ] ";
    return [u2, eL(e20, t2, n2, {processor: (e21, i3) => {
      if (i3 === 0 && e21.getValue().type !== "list")
        return TI(" ".repeat(u2.length), n2());
      const o2 = " ".repeat(function(e22, t3, n3) {
        return e22 < t3 ? t3 : e22 > n3 ? n3 : e22;
      }(t2.tabWidth - r2.length, 0, 3));
      return [o2, TI(o2, n2())];
    }})];
  }
  function XI(e20, t2) {
    return function(e21, t3, n2) {
      let r2 = -1;
      for (const i2 of t3.children)
        if (i2.type === e21.type && n2(i2) ? r2++ : r2 = -1, i2 === e21)
          return r2;
    }(e20, t2, (t3) => t3.ordered === e20.ordered);
  }
  function YI(e20, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2];
    let r2, i2 = -1;
    for (; r2 = e20.getParentNode(++i2); )
      if (n2.includes(r2.type))
        return i2;
    return -1;
  }
  function KI(e20, t2) {
    const n2 = YI(e20, t2);
    return n2 === -1 ? null : e20.getParentNode(n2);
  }
  function QI(e20, t2, n2) {
    if (n2.proseWrap === "preserve" && t2 === "\n")
      return FI;
    const r2 = n2.proseWrap === "always" && !KI(e20, GI);
    return t2 !== "" ? r2 ? bI : " " : r2 ? SI : "";
  }
  function ZI(e20, t2, n2) {
    const r2 = [];
    let i2 = null;
    const {children: u2} = e20.getValue();
    for (const [e21, t3] of u2.entries())
      switch (nL(t3)) {
        case "start":
          i2 === null && (i2 = {index: e21, offset: t3.position.end.offset});
          break;
        case "end":
          i2 !== null && (r2.push({start: i2, end: {index: e21, offset: t3.position.start.offset}}), i2 = null);
      }
    return eL(e20, t2, n2, {processor: (e21, i3) => {
      if (r2.length > 0) {
        const e22 = r2[0];
        if (i3 === e22.start.index)
          return [u2[e22.start.index].value, t2.originalText.slice(e22.start.offset, e22.end.offset), u2[e22.end.index].value];
        if (e22.start.index < i3 && i3 < e22.end.index)
          return false;
        if (i3 === e22.end.index)
          return r2.shift(), false;
      }
      return n2();
    }});
  }
  function eL(e20, t2, n2, r2 = {}) {
    const {postprocessor: i2} = r2, u2 = r2.processor || (() => n2()), o2 = e20.getValue(), s2 = [];
    let a2;
    return e20.each((e21, n3) => {
      const r3 = e21.getValue(), i3 = u2(e21, n3);
      if (i3 !== false) {
        const e22 = {parts: s2, prevNode: a2, parentNode: o2, options: t2};
        (function(e23, t3) {
          const n4 = t3.parts.length === 0, r4 = WI.includes(e23.type), i4 = e23.type === "html" && qI.includes(t3.parentNode.type);
          return !n4 && !r4 && !i4;
        })(r3, e22) && (s2.push(FI), a2 && zI.has(a2.type) || (function(e23, t3) {
          const n4 = (t3.prevNode && t3.prevNode.type) === e23.type && HI.has(e23.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, i4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, u3 = nL(t3.prevNode) === "next", o3 = e23.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e23.position.start.line, s3 = e23.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e23.position.start.line;
          return i4 || !(n4 || r4 || u3 || o3 || s3);
        }(r3, e22) || rL(r3, e22)) && s2.push(FI), rL(r3, e22) && s2.push(FI)), s2.push(i3), a2 = r3;
      }
    }, "children"), i2 ? i2(s2) : s2;
  }
  function tL(e20) {
    let t2 = e20;
    for (; DI(t2.children); )
      t2 = hI(t2.children);
    return t2;
  }
  function nL(e20) {
    if (e20.type !== "html")
      return false;
    const t2 = e20.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return t2 !== null && (t2[1] ? t2[1] : "next");
  }
  function rL(e20, t2) {
    const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e20.type === "code" && e20.isIndented;
    return n2 && r2;
  }
  function iL(e20, t2 = []) {
    const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
    return new RegExp(n2.map((e21) => `\\${e21}`).join("|")).test(e20) ? `<${e20}>` : e20;
  }
  function uL(e20, t2, n2 = true) {
    if (!e20)
      return "";
    if (n2)
      return " " + uL(e20, t2, false);
    if ((e20 = e20.replace(/\\(["')])/g, "$1")).includes('"') && e20.includes("'") && !e20.includes(")"))
      return `(${e20})`;
    const r2 = e20.split("'").length - 1, i2 = e20.split('"').length - 1, u2 = r2 > i2 ? '"' : i2 > r2 || t2.singleQuote ? "'" : '"';
    return `${u2}${e20 = (e20 = e20.replace(/\\/, "\\\\")).replace(new RegExp(`(${u2})`, "g"), "\\$1")}${u2}`;
  }
  var oL = {preprocess: aI, print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (function(e21) {
      const t3 = KI(e21, ["linkReference", "imageReference"]);
      return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
    }(e20))
      return $I(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : QI(e20, n3.value, t2));
    switch (r2.type) {
      case "front-matter":
        return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
      case "root":
        return r2.children.length === 0 ? "" : [PI(ZI(e20, t2, n2)), zI.has(tL(r2).type) ? "" : FI];
      case "paragraph":
        return eL(e20, t2, n2, {postprocessor: wI});
      case "sentence":
        return eL(e20, t2, n2);
      case "word": {
        let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${VI})(_+)`, `(_+)(${VI}|$)`].join("|"), "g"), (e21, t4, n4, r3, i3) => (n4 ? `${t4}${n4}` : `${r3}${i3}`).replace(/_/g, "\\_"));
        const n3 = (e21, t4, n4) => e21.type === "sentence" && n4 === 0, i2 = (e21, t4, n4) => UI(e21.children[n4 - 1]);
        return t3 !== r2.value && (e20.match(void 0, n3, i2) || e20.match(void 0, n3, (e21, t4, n4) => e21.type === "emphasis" && n4 === 0, i2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e21) => e21.replace(/\\/g, ""))), t3;
      }
      case "whitespace": {
        const n3 = e20.getParentNode(), i2 = n3.children.indexOf(r2), u2 = n3.children[i2 + 1], o2 = u2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u2.value) ? "never" : t2.proseWrap;
        return QI(e20, r2.value, {proseWrap: o2});
      }
      case "emphasis": {
        let i2;
        if (UI(r2.children[0]))
          i2 = t2.originalText[r2.position.start.offset];
        else {
          const t3 = e20.getParentNode(), n3 = t3.children.indexOf(r2), u2 = t3.children[n3 - 1], o2 = t3.children[n3 + 1];
          i2 = u2 && u2.type === "sentence" && u2.children.length > 0 && hI(u2.children).type === "word" && !hI(u2.children).hasTrailingPunctuation || o2 && o2.type === "sentence" && o2.children.length > 0 && o2.children[0].type === "word" && !o2.children[0].hasLeadingPunctuation || KI(e20, "emphasis") ? "*" : "_";
        }
        return [i2, eL(e20, t2, n2), i2];
      }
      case "strong":
        return ["**", eL(e20, t2, n2), "**"];
      case "delete":
        return ["~~", eL(e20, t2, n2), "~~"];
      case "inlineCode": {
        const e21 = gI(r2.value, "`"), t3 = "`".repeat(e21 || 1), n3 = e21 && !/^\s/.test(r2.value) ? " " : "";
        return [t3, n3, r2.value, n3, t3];
      }
      case "wikiLink": {
        let e21 = "";
        return e21 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e21, "]]"];
      }
      case "link":
        switch (t2.originalText[r2.position.start.offset]) {
          case "<": {
            const e21 = "mailto:";
            return ["<", r2.url.startsWith(e21) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e21.length) !== e21 ? r2.url.slice(e21.length) : r2.url, ">"];
          }
          case "[":
            return ["[", eL(e20, t2, n2), "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
          default:
            return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
        }
      case "image":
        return ["![", r2.alt || "", "](", iL(r2.url, ")"), uL(r2.title, t2), ")"];
      case "blockquote":
        return ["> ", TI("> ", eL(e20, t2, n2))];
      case "heading":
        return ["#".repeat(r2.depth) + " ", eL(e20, t2, n2)];
      case "code": {
        if (r2.isIndented) {
          const e22 = " ".repeat(4);
          return TI(e22, [e22, ...OI(r2.value, FI)]);
        }
        const e21 = t2.__inJsTemplate ? "~" : "`", n3 = e21.repeat(Math.max(3, mI(r2.value, e21) + 1));
        return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", FI, ...OI(MI(r2, t2.originalText), FI), FI, n3];
      }
      case "html": {
        const t3 = e20.getParentNode(), n3 = t3.type === "root" && hI(t3.children) === r2 ? r2.value.trimEnd() : r2.value, i2 = /^<!--.*-->$/s.test(n3);
        return OI(n3, i2 ? FI : vI(AI));
      }
      case "list": {
        const i2 = XI(r2, e20.getParentNode()), u2 = RI(r2, t2);
        return eL(e20, t2, n2, {processor: (e21, o2) => {
          const s2 = function() {
            const e22 = r2.ordered ? (o2 === 0 ? r2.start : u2 ? 1 : r2.start + o2) + (i2 % 2 == 0 ? ". " : ") ") : i2 % 2 == 0 ? "- " : "* ";
            return r2.isAligned || r2.hasIndentedCodeblock ? function(e23, t3) {
              const n3 = r3();
              return e23 + " ".repeat(n3 >= 4 ? 0 : n3);
              function r3() {
                const n4 = e23.length % t3.tabWidth;
                return n4 === 0 ? 0 : t3.tabWidth - n4;
              }
            }(e22, t2) : e22;
          }(), a2 = e21.getValue();
          return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, JI(e21, t2, n2, s2)] : [s2, TI(" ".repeat(s2.length), JI(e21, t2, n2, s2))];
        }});
      }
      case "thematicBreak": {
        const t3 = YI(e20, "list");
        if (t3 === -1)
          return "---";
        return XI(e20.getParentNode(t3), e20.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
      }
      case "linkReference":
        return ["[", eL(e20, t2, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
      case "imageReference":
        switch (r2.referenceType) {
          case "full":
            return ["![", r2.alt || "", "][", r2.identifier, "]"];
          default:
            return ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
        }
      case "definition": {
        const e21 = t2.proseWrap === "always" ? bI : " ";
        return NI(["[", r2.identifier, "]:", BI([e21, iL(r2.url), r2.title === null ? "" : [e21, uL(r2.title, t2, false)]])]);
      }
      case "footnote":
        return ["[^", eL(e20, t2, n2), "]"];
      case "footnoteReference":
        return ["[^", r2.identifier, "]"];
      case "footnoteDefinition": {
        const i2 = e20.getParentNode().children[e20.getName() + 1], u2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
        return ["[^", r2.identifier, "]: ", u2 ? eL(e20, t2, n2) : NI([TI(" ".repeat(4), eL(e20, t2, n2, {processor: (e21, t3) => t3 === 0 ? NI([SI, n2()]) : n2()})), i2 && i2.type === "footnoteDefinition" ? SI : ""])];
      }
      case "table":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = [], u2 = e21.map((e22) => e22.map((e23, r4) => {
            const u3 = II(n3(), t3).formatted, o3 = yI(u3);
            return i2[r4] = Math.max(i2[r4] || 3, o3), {text: u3, width: o3};
          }, "children"), "children"), o2 = a2(false);
          if (t3.proseWrap !== "never")
            return [EI, o2];
          const s2 = a2(true);
          return [EI, NI(xI(s2, o2))];
          function a2(e22) {
            const t4 = [l2(u2[0], e22), c2(e22)];
            return u2.length > 1 && t4.push(CI(kI, u2.slice(1).map((t5) => l2(t5, e22)))), CI(kI, t4);
          }
          function c2(e22) {
            return `| ${i2.map((t4, n4) => {
              const i3 = r3.align[n4], u3 = i3 === "center" || i3 === "right" ? ":" : "-";
              return `${i3 === "center" || i3 === "left" ? ":" : "-"}${e22 ? "-" : "-".repeat(t4 - 2)}${u3}`;
            }).join(" | ")} |`;
          }
          function l2(e22, t4) {
            return `| ${e22.map(({text: e23, width: n4}, u3) => {
              if (t4)
                return e23;
              const o3 = i2[u3] - n4, s3 = r3.align[u3];
              let a3 = 0;
              s3 === "right" ? a3 = o3 : s3 === "center" && (a3 = Math.floor(o3 / 2));
              const c3 = o3 - a3;
              return `${" ".repeat(a3)}${e23}${" ".repeat(c3)}`;
            }).join(" | ")} |`;
          }
        }(e20, t2, n2);
      case "tableCell":
        return eL(e20, t2, n2);
      case "break":
        return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", vI(AI)] : ["\\", FI];
      case "liquidNode":
        return OI(r2.value, FI);
      case "importExport":
        return [r2.value, FI];
      case "jsx":
        return r2.value;
      case "math":
        return ["$$", FI, r2.value ? [...OI(r2.value, FI), FI] : "", "$$"];
      case "inlineMath":
        return t2.originalText.slice(jI(r2), _I(r2));
      case "tableRow":
      case "listItem":
      default:
        throw new Error(`Unknown markdown type ${JSON.stringify(r2.type)}`);
    }
  }, embed: ZO, massageAstNode: dI, hasPrettierIgnore: function(e20) {
    const t2 = Number(e20.getName());
    return t2 !== 0 && nL(e20.getParentNode().children[t2 - 1]) === "next";
  }, insertPragma: LI}, sL = {proseWrap: WB.proseWrap, singleQuote: WB.singleQuote}, aL = {name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222};
  var cL = {languages: [Xd(aL, (e20) => ({since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e20.filenames, "README"], extensions: e20.extensions.filter((e21) => e21 !== ".mdx")})), Xd(aL, () => ({name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"]}))], options: sL, printers: {mdast: oL}, parsers: void 0};
  const {isFrontMatterNode: lL} = yi$2, pL = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
  function fL(e20, t2) {
    return e20.type === "text" || e20.type === "comment" || lL(e20) || e20.type === "yaml" || e20.type === "toml" ? null : (e20.type === "attribute" && delete t2.value, void (e20.type === "docType" && delete t2.value));
  }
  fL.ignoredProperties = pL;
  var dL = fL, hL = {"*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"]};
  const {inferParserByLanguage: gL, isFrontMatterNode: mL} = yi$2, {builders: {line: yL, hardline: DL, join: EL}, utils: {getDocParts: CL, replaceTextEndOfLine: bL}} = eu$1, {CSS_DISPLAY_TAGS: AL, CSS_DISPLAY_DEFAULT: vL, CSS_WHITE_SPACE_TAGS: FL, CSS_WHITE_SPACE_DEFAULT: SL} = {CSS_DISPLAY_TAGS: {area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block"}, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: {listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap"}, CSS_WHITE_SPACE_DEFAULT: "normal"}, xL = PL(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), wL = function(e20, t2) {
    const n2 = Object.create(null);
    for (const [r2, i2] of Object.entries(e20))
      n2[r2] = t2(i2, r2);
    return n2;
  }(hL, PL), TL = new Set(["	", "\n", "\f", "\r", " "]), BL = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), NL = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(BL(e20)), kL = (e20) => e20.match(/^[\t\n\f\r ]*/)[0];
  function PL(e20) {
    const t2 = Object.create(null);
    for (const n2 of e20)
      t2[n2] = true;
    return t2;
  }
  function OL(e20) {
    return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || UL(e20) && (e20.name === "script" || e20.name === "style"));
  }
  function IL(e20) {
    return zL(e20).startsWith("pre");
  }
  function LL(e20) {
    return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
  }
  function jL(e20) {
    return $L(e20) || e20.type === "element" && e20.fullName === "br" || _L(e20);
  }
  function _L(e20) {
    return ML(e20) && RL(e20);
  }
  function ML(e20) {
    return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
  }
  function RL(e20) {
    return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
  }
  function $L(e20) {
    switch (e20.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(e20.name);
    }
    return false;
  }
  function VL(e20) {
    const {type: t2, lang: n2} = e20.attrMap;
    return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
  }
  function WL(e20) {
    return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
  }
  function qL(e20) {
    return zL(e20).startsWith("pre");
  }
  function UL(e20) {
    return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
  }
  function zL(e20) {
    return e20.type === "element" && (!e20.namespace || UL(e20)) && FL[e20.name] || SL;
  }
  function GL(e20, t2 = function(e21) {
    let t3 = Number.POSITIVE_INFINITY;
    for (const n2 of e21.split("\n")) {
      if (n2.length === 0)
        continue;
      if (!TL.has(n2[0]))
        return 0;
      const e22 = kL(n2).length;
      n2.length !== e22 && e22 < t3 && (t3 = e22);
    }
    return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
  }(e20)) {
    return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
  }
  const HL = new Set(["template", "style", "script"]);
  function JL(e20, t2) {
    return XL(e20, t2) && !HL.has(e20.fullName);
  }
  function XL(e20, t2) {
    return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
  }
  function YL(e20, t2) {
    return XL(e20, t2) && (JL(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
  }
  var KL = {HTML_ELEMENT_ATTRIBUTES: wL, HTML_TAGS: xL, htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(BL(e20)), htmlTrimPreserveIndentation: NL, hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20), getLeadingAndTrailingHtmlWhitespace: (e20) => {
    const [, t2, n2, r2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return {leadingWhitespace: t2, trailingWhitespace: r2, text: n2};
  }, canHaveInterpolation: function(e20) {
    return e20.children && !OL(e20);
  }, countChars: function(e20, t2) {
    let n2 = 0;
    for (let r2 = 0; r2 < e20.length; r2++)
      e20[r2] === t2 && n2++;
    return n2;
  }, countParents: function(e20, t2) {
    let n2 = 0;
    for (let r2 = e20.stack.length - 1; r2 >= 0; r2--) {
      const i2 = e20.stack[r2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && n2++;
    }
    return n2;
  }, dedentString: GL, forceBreakChildren: LL, forceBreakContent: function(e20) {
    return LL(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
      return e22.children && e22.children.some((e23) => e23.type !== "text");
    }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ML(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || RL(e20.lastChild));
  }, forceNextEmptyLine: function(e20) {
    return mL(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
  }, getLastDescendant: function e9(t2) {
    return t2.lastChild ? e9(t2.lastChild) : t2;
  }, getNodeCssStyleDisplay: function(e20, t2) {
    if (e20.prev && e20.prev.type === "comment") {
      const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let n2 = false;
    if (e20.type === "element" && e20.namespace === "svg") {
      if (!function(e21, t3) {
        let n3 = e21;
        for (; n3; ) {
          if (t3(n3))
            return true;
          n3 = n3.parent;
        }
        return false;
      }(e20, (e21) => e21.fullName === "svg:foreignObject"))
        return e20.name === "svg" ? "inline-block" : "block";
      n2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || n2 || UL(e20)) && AL[e20.name] || vL;
    }
  }, getNodeCssStyleWhiteSpace: zL, hasPrettierIgnore: function(e20) {
    return e20.type !== "attribute" && (!!e20.parent && (typeof e20.index == "number" && e20.index !== 0 && function(e21) {
      return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
    }(e20.parent.children[e20.index - 1])));
  }, inferScriptParser: function(e20, t2) {
    return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
      const {lang: t3} = e21.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e20) : t2 && YL(e20, t2) ? VL(e20) || !("src" in e20.attrMap) && gL(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? VL(e20) : "babel";
  }, isVueCustomBlock: JL, isVueNonHtmlBlock: YL, isVueSlotAttribute: function(e20) {
    const t2 = e20.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  }, isVueSfcBindingsAttribute: function(e20, t2) {
    const n2 = e20.parent;
    if (!XL(n2, t2))
      return false;
    const r2 = n2.fullName, i2 = e20.fullName;
    return r2 === "script" && i2 === "setup" || r2 === "style" && i2 === "vars";
  }, isDanglingSpaceSensitiveNode: function(e20) {
    return !(t2 = e20.cssDisplay, WL(t2) || t2 === "inline-block" || OL(e20));
    var t2;
  }, isIndentationSensitiveNode: IL, isLeadingSpaceSensitiveNode: function(e20, t2) {
    const n2 = function() {
      if (mL(e20))
        return false;
      if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
        return true;
      if (!e20.parent || e20.parent.cssDisplay === "none")
        return false;
      if (qL(e20.parent))
        return true;
      if (!e20.prev && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n3 = e20.parent.cssDisplay, WL(n3) || n3 === "inline-block")))
        return false;
      var n3;
      if (e20.prev && !function(e21) {
        return !WL(e21);
      }(e20.prev.cssDisplay))
        return false;
      return true;
    }();
    return n2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : n2;
  }, isPreLikeNode: qL, isScriptLikeTag: OL, isTextLikeNode: function(e20) {
    return e20.type === "text" || e20.type === "comment";
  }, isTrailingSpaceSensitiveNode: function(e20, t2) {
    return !mL(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!qL(e20.parent) || !(!e20.next && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n2 = e20.parent.cssDisplay, WL(n2) || n2 === "inline-block"))) && !(e20.next && !function(e21) {
      return !WL(e21);
    }(e20.next.cssDisplay))));
    var n2;
  }, isWhitespaceSensitiveNode: function(e20) {
    return OL(e20) || e20.type === "interpolation" || IL(e20);
  }, isUnknownNamespace: UL, preferHardlineAsLeadingSpaces: function(e20) {
    return $L(e20) || e20.prev && jL(e20.prev) || _L(e20);
  }, preferHardlineAsTrailingSpaces: jL, shouldPreserveContent: function(e20, t2) {
    return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || (e20.type === "ieConditionalComment" && !e20.complete || (!(!qL(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!YL(e20, t2) || OL(e20) || e20.type === "interpolation")));
  }, unescapeQuoteEntities: function(e20) {
    return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }, getTextValueParts: function(e20, t2 = e20.value) {
    return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? bL(t2) : bL(GL(NL(t2)), DL) : CL(EL(yL, ((e21) => e21.split(/[\t\n\f\r ]+/))(t2)));
  }}, QL = r$3(function(e20, t2) {
    function n2(e21) {
      return t2.$0 <= e21 && e21 <= t2.$9;
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true}), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
      return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
    }, t2.isDigit = n2, t2.isAsciiLetter = function(e21) {
      return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
    }, t2.isAsciiHexDigit = function(e21) {
      return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || n2(e21);
    }, t2.isNewLine = function(e21) {
      return e21 === t2.$LF || e21 === t2.$CR;
    }, t2.isOctalDigit = function(e21) {
      return t2.$0 <= e21 && e21 <= t2.$7;
    };
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ZL {
    constructor(e20, t2, n2) {
      this.filePath = e20, this.name = t2, this.members = n2;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  }
  var ej = ZL;
  var tj = class {
    constructor() {
      this.cache = new Map();
    }
    get(e20, t2, n2) {
      const r2 = `"${e20}".${t2}${(n2 = n2 || []).length ? `.${n2.join(".")}` : ""}`;
      let i2 = this.cache.get(r2);
      return i2 || (i2 = new ZL(e20, t2, n2), this.cache.set(r2, i2)), i2;
    }
  }, nj = Object.defineProperty({StaticSymbol: ej, StaticSymbolCache: tj}, "__esModule", {value: true});
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const rj = /-+([a-z0-9])/g;
  var ij = function(e20) {
    return e20.replace(rj, (...e21) => e21[1].toUpperCase());
  };
  var uj = function(e20, t2) {
    return sj(e20, ":", t2);
  };
  var oj = function(e20, t2) {
    return sj(e20, ".", t2);
  };
  function sj(e20, t2, n2) {
    const r2 = e20.indexOf(t2);
    return r2 == -1 ? n2 : [e20.slice(0, r2).trim(), e20.slice(r2 + 1).trim()];
  }
  function aj(e20, t2, n2) {
    return Array.isArray(e20) ? t2.visitArray(e20, n2) : function(e21) {
      return typeof e21 == "object" && e21 !== null && Object.getPrototypeOf(e21) === bj;
    }(e20) ? t2.visitStringMap(e20, n2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, n2) : t2.visitOther(e20, n2);
  }
  var cj = aj;
  var lj = function(e20) {
    return e20 != null;
  };
  var pj = function(e20) {
    return e20 === void 0 ? null : e20;
  };
  var fj = class {
    visitArray(e20, t2) {
      return e20.map((e21) => aj(e21, this, t2));
    }
    visitStringMap(e20, t2) {
      const n2 = {};
      return Object.keys(e20).forEach((r2) => {
        n2[r2] = aj(e20[r2], this, t2);
      }), n2;
    }
    visitPrimitive(e20, t2) {
      return e20;
    }
    visitOther(e20, t2) {
      return e20;
    }
  }, dj = {assertSync: (e20) => {
    if (Sj(e20))
      throw new Error("Illegal state: value cannot be a promise");
    return e20;
  }, then: (e20, t2) => Sj(e20) ? e20.then(t2) : t2(e20), all: (e20) => e20.some(Sj) ? Promise.all(e20) : e20};
  var hj = function(e20) {
    throw new Error(`Internal Error: ${e20}`);
  };
  var gj = function(e20, t2) {
    const n2 = Error(e20);
    return n2[mj] = true, t2 && (n2[yj] = t2), n2;
  };
  const mj = "ngSyntaxError", yj = "ngParseErrors";
  var Dj = function(e20) {
    return e20[mj];
  };
  var Ej = function(e20) {
    return e20[yj] || [];
  };
  var Cj = function(e20) {
    return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  };
  const bj = Object.getPrototypeOf({});
  var Aj = function(e20) {
    let t2 = "";
    for (let n2 = 0; n2 < e20.length; n2++) {
      let r2 = e20.charCodeAt(n2);
      if (r2 >= 55296 && r2 <= 56319 && e20.length > n2 + 1) {
        const t3 = e20.charCodeAt(n2 + 1);
        t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
      }
      r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
    }
    return t2;
  };
  var vj = function e10(t2) {
    if (typeof t2 == "string")
      return t2;
    if (t2 instanceof Array)
      return "[" + t2.map(e10).join(", ") + "]";
    if (t2 == null)
      return "" + t2;
    if (t2.overriddenName)
      return `${t2.overriddenName}`;
    if (t2.name)
      return `${t2.name}`;
    if (!t2.toString)
      return "object";
    const n2 = t2.toString();
    if (n2 == null)
      return "" + n2;
    const r2 = n2.indexOf("\n");
    return r2 === -1 ? n2 : n2.substring(0, r2);
  };
  var Fj = function(e20) {
    return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
  };
  function Sj(e20) {
    return !!e20 && typeof e20.then == "function";
  }
  var xj = Sj;
  var wj = class {
    constructor(e20) {
      this.full = e20;
      const t2 = e20.split(".");
      this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
    }
  };
  const Tj = typeof window != "undefined" && window, Bj = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
  var Nj = t$3 !== void 0 && t$3 || Tj || Bj, kj = Object.defineProperty({dashCaseToCamelCase: ij, splitAtColon: uj, splitAtPeriod: oj, visitValue: cj, isDefined: lj, noUndefined: pj, ValueTransformer: fj, SyncAsync: dj, error: hj, syntaxError: gj, isSyntaxError: Dj, getParseErrors: Ej, escapeRegExp: Cj, utf8Encode: Aj, stringify: vj, resolveForwardRef: Fj, isPromise: xj, Version: wj, global: Nj}, "__esModule", {value: true}), Pj = r$3(function(e20, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true});
    const n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function r2(e21) {
      return e21.replace(/\W/g, "_");
    }
    t2.sanitizeIdentifier = r2;
    let i2 = 0;
    function u2(e21) {
      if (!e21 || !e21.reference)
        return null;
      const t3 = e21.reference;
      if (t3 instanceof nj.StaticSymbol)
        return t3.name;
      if (t3.__anonymousType)
        return t3.__anonymousType;
      let n3 = kj.stringify(t3);
      return n3.indexOf("(") >= 0 ? (n3 = "anonymous_" + i2++, t3.__anonymousType = n3) : n3 = r2(n3), n3;
    }
    var o2;
    t2.identifierName = u2, t2.identifierModuleUrl = function(e21) {
      const t3 = e21.reference;
      return t3 instanceof nj.StaticSymbol ? t3.filePath : `./${kj.stringify(t3)}`;
    }, t2.viewClassName = function(e21, t3) {
      return `View_${u2({reference: e21})}_${t3}`;
    }, t2.rendererTypeName = function(e21) {
      return `RenderType_${u2({reference: e21})}`;
    }, t2.hostViewClassName = function(e21) {
      return `HostView_${u2({reference: e21})}`;
    }, t2.componentFactoryName = function(e21) {
      return `${u2({reference: e21})}NgFactory`;
    }, function(e21) {
      e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
    }(o2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
      return e21.value != null ? r2(e21.value) : u2(e21.identifier);
    }, t2.tokenReference = function(e21) {
      return e21.identifier != null ? e21.identifier.reference : e21.value;
    };
    t2.CompileStylesheetMetadata = class {
      constructor({moduleUrl: e21, styles: t3, styleUrls: n3} = {}) {
        this.moduleUrl = e21 || null, this.styles = a2(t3), this.styleUrls = a2(n3);
      }
    };
    t2.CompileTemplateMetadata = class {
      constructor({encapsulation: e21, template: t3, templateUrl: n3, htmlAst: r3, styles: i3, styleUrls: u3, externalStylesheets: o3, animations: s3, ngContentSelectors: l3, interpolation: p2, isInline: f2, preserveWhitespaces: d2}) {
        if (this.encapsulation = e21, this.template = t3, this.templateUrl = n3, this.htmlAst = r3, this.styles = a2(i3), this.styleUrls = a2(u3), this.externalStylesheets = a2(o3), this.animations = s3 ? c2(s3) : [], this.ngContentSelectors = l3 || [], p2 && p2.length != 2)
          throw new Error("'interpolation' should have a start and an end symbol.");
        this.interpolation = p2, this.isInline = f2, this.preserveWhitespaces = d2;
      }
      toSummary() {
        return {ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations};
      }
    };
    class s2 {
      static create({isHost: e21, type: t3, isComponent: r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: a3, outputs: c3, host: l3, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2}) {
        const b2 = {}, A2 = {}, v2 = {};
        l3 != null && Object.keys(l3).forEach((e22) => {
          const t4 = l3[e22], r4 = e22.match(n2);
          r4 === null ? v2[e22] = t4 : r4[1] != null ? A2[r4[1]] = t4 : r4[2] != null && (b2[r4[2]] = t4);
        });
        const F2 = {};
        a3 != null && a3.forEach((e22) => {
          const t4 = kj.splitAtColon(e22, [e22, e22]);
          F2[t4[0]] = t4[1];
        });
        const S2 = {};
        return c3 != null && c3.forEach((e22) => {
          const t4 = kj.splitAtColon(e22, [e22, e22]);
          S2[t4[0]] = t4[1];
        }), new s2({isHost: e21, type: t3, isComponent: !!r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: F2, outputs: S2, hostListeners: b2, hostProperties: A2, hostAttributes: v2, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2});
      }
      constructor({isHost: e21, type: t3, isComponent: n3, selector: r3, exportAs: i3, changeDetection: u3, inputs: o3, outputs: s3, hostListeners: c3, hostProperties: l3, hostAttributes: p2, providers: f2, viewProviders: d2, queries: h2, guards: g2, viewQueries: m2, entryComponents: y2, template: D2, componentViewType: E2, rendererType: C2, componentFactory: b2}) {
        this.isHost = !!e21, this.type = t3, this.isComponent = n3, this.selector = r3, this.exportAs = i3, this.changeDetection = u3, this.inputs = o3, this.outputs = s3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = p2, this.providers = a2(f2), this.viewProviders = a2(d2), this.queries = a2(h2), this.guards = g2, this.viewQueries = a2(m2), this.entryComponents = a2(y2), this.template = D2, this.componentViewType = E2, this.rendererType = C2, this.componentFactory = b2;
      }
      toSummary() {
        return {summaryKind: o2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory};
      }
    }
    t2.CompileDirectiveMetadata = s2;
    t2.CompilePipeMetadata = class {
      constructor({type: e21, name: t3, pure: n3}) {
        this.type = e21, this.name = t3, this.pure = !!n3;
      }
      toSummary() {
        return {summaryKind: o2.Pipe, type: this.type, name: this.name, pure: this.pure};
      }
    };
    t2.CompileShallowModuleMetadata = class {
    };
    t2.CompileNgModuleMetadata = class {
      constructor({type: e21, providers: t3, declaredDirectives: n3, exportedDirectives: r3, declaredPipes: i3, exportedPipes: u3, entryComponents: o3, bootstrapComponents: s3, importedModules: c3, exportedModules: l3, schemas: p2, transitiveModule: f2, id: d2}) {
        this.type = e21 || null, this.declaredDirectives = a2(n3), this.exportedDirectives = a2(r3), this.declaredPipes = a2(i3), this.exportedPipes = a2(u3), this.providers = a2(t3), this.entryComponents = a2(o3), this.bootstrapComponents = a2(s3), this.importedModules = a2(c3), this.exportedModules = a2(l3), this.schemas = a2(p2), this.id = d2 || null, this.transitiveModule = f2 || null;
      }
      toSummary() {
        const e21 = this.transitiveModule;
        return {summaryKind: o2.NgModule, type: this.type, entryComponents: e21.entryComponents, providers: e21.providers, modules: e21.modules, exportedDirectives: e21.exportedDirectives, exportedPipes: e21.exportedPipes};
      }
    };
    function a2(e21) {
      return e21 || [];
    }
    t2.TransitiveCompileNgModuleMetadata = class {
      constructor() {
        this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
      }
      addProvider(e21, t3) {
        this.providers.push({provider: e21, module: t3});
      }
      addDirective(e21) {
        this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
      }
      addExportedDirective(e21) {
        this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
      }
      addPipe(e21) {
        this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
      }
      addExportedPipe(e21) {
        this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
      }
      addModule(e21) {
        this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
      }
      addEntryComponent(e21) {
        this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
      }
    };
    function c2(e21) {
      return e21.reduce((e22, t3) => {
        const n3 = Array.isArray(t3) ? c2(t3) : t3;
        return e22.concat(n3);
      }, []);
    }
    function l2(e21) {
      return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t2.ProviderMeta = class {
      constructor(e21, {useClass: t3, useValue: n3, useExisting: r3, useFactory: i3, deps: u3, multi: o3}) {
        this.token = e21, this.useClass = t3 || null, this.useValue = n3, this.useExisting = r3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!o3;
      }
    }, t2.flatten = c2, t2.templateSourceUrl = function(e21, t3, n3) {
      let r3;
      return r3 = n3.isInline ? t3.type.reference instanceof nj.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${u2(e21)}/${u2(t3.type)}.html` : n3.templateUrl, t3.type.reference instanceof nj.StaticSymbol ? r3 : l2(r3);
    }, t2.sharedStylesheetJitUrl = function(e21, t3) {
      const n3 = e21.moduleUrl.split(/\/\\/g);
      return l2(`css/${t3}${n3[n3.length - 1]}.ngstyle.js`);
    }, t2.ngModuleJitUrl = function(e21) {
      return l2(`${u2(e21.type)}/module.ngfactory.js`);
    }, t2.templateJitUrl = function(e21, t3) {
      return l2(`${u2(e21)}/${u2(t3.type)}.ngfactory.js`);
    };
  }), Oj = r$3(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true});
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    class n2 {
      constructor(e21, t3, n3, r3) {
        this.file = e21, this.offset = t3, this.line = n3, this.col = r3;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(e21) {
        const t3 = this.file.content, r3 = t3.length;
        let i3 = this.offset, u3 = this.line, o2 = this.col;
        for (; i3 > 0 && e21 < 0; ) {
          i3--, e21++;
          if (t3.charCodeAt(i3) == QL.$LF) {
            u3--;
            const e22 = t3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(QL.$LF));
            o2 = e22 > 0 ? i3 - e22 : i3;
          } else
            o2--;
        }
        for (; i3 < r3 && e21 > 0; ) {
          const n3 = t3.charCodeAt(i3);
          i3++, e21--, n3 == QL.$LF ? (u3++, o2 = 0) : o2++;
        }
        return new n2(this.file, i3, u3, o2);
      }
      getContext(e21, t3) {
        const n3 = this.file.content;
        let r3 = this.offset;
        if (r3 != null) {
          r3 > n3.length - 1 && (r3 = n3.length - 1);
          let i3 = r3, u3 = 0, o2 = 0;
          for (; u3 < e21 && r3 > 0 && (r3--, u3++, n3[r3] != "\n" || ++o2 != t3); )
            ;
          for (u3 = 0, o2 = 0; u3 < e21 && i3 < n3.length - 1 && (i3++, u3++, n3[i3] != "\n" || ++o2 != t3); )
            ;
          return {before: n3.substring(r3, this.offset), after: n3.substring(this.offset, i3 + 1)};
        }
        return null;
      }
    }
    t2.ParseLocation = n2;
    class r2 {
      constructor(e21, t3) {
        this.content = e21, this.url = t3;
      }
    }
    t2.ParseSourceFile = r2;
    class i2 {
      constructor(e21, t3, n3 = null) {
        this.start = e21, this.end = t3, this.details = n3;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    }
    var u2;
    t2.ParseSourceSpan = i2, t2.EMPTY_PARSE_LOCATION = new n2(new r2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new i2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
      e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
    }(u2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
    t2.ParseError = class {
      constructor(e21, t3, n3 = u2.ERROR) {
        this.span = e21, this.msg = t3, this.level = n3;
      }
      contextualMessage() {
        const e21 = this.span.start.getContext(100, 3);
        return e21 ? `${this.msg} ("${e21.before}[${u2[this.level]} ->]${e21.after}")` : this.msg;
      }
      toString() {
        const e21 = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${e21}`;
      }
    }, t2.typeSourceSpan = function(e21, t3) {
      const u3 = Pj.identifierModuleUrl(t3), o2 = u3 != null ? `in ${e21} ${Pj.identifierName(t3)} in ${u3}` : `in ${e21} ${Pj.identifierName(t3)}`, s2 = new r2("", o2);
      return new i2(new n2(s2, -1, -1, -1), new n2(s2, -1, -1, -1));
    }, t2.r3JitTypeSourceSpan = function(e21, t3, u3) {
      const o2 = new r2("", `in ${e21} ${t3} in ${u3}`);
      return new i2(new n2(o2, -1, -1, -1), new n2(o2, -1, -1, -1));
    };
  });
  const {ParseSourceSpan: Ij} = Oj, {htmlTrim: Lj, getLeadingAndTrailingHtmlWhitespace: jj, hasHtmlWhitespace: _j, canHaveInterpolation: Mj, getNodeCssStyleDisplay: Rj, isDanglingSpaceSensitiveNode: $j, isIndentationSensitiveNode: Vj, isLeadingSpaceSensitiveNode: Wj, isTrailingSpaceSensitiveNode: qj, isWhitespaceSensitiveNode: Uj} = KL, zj = [function(e20) {
    e20.walk((e21) => {
      if (e21.type === "element" && e21.tagDefinition.ignoreFirstLf && e21.children.length > 0 && e21.children[0].type === "text" && e21.children[0].value[0] === "\n") {
        const [t2, ...n2] = e21.children;
        e21.setChildren(t2.value.length === 1 ? n2 : [t2.clone({value: t2.value.slice(1)}), ...n2]);
      }
    });
  }, function(e20) {
    const t2 = (e21) => e21.type === "element" && e21.prev && e21.prev.type === "ieConditionalStartComment" && e21.prev.sourceSpan.end.offset === e21.startSourceSpan.start.offset && e21.firstChild && e21.firstChild.type === "ieConditionalEndComment" && e21.firstChild.sourceSpan.start.offset === e21.startSourceSpan.end.offset;
    e20.walk((e21) => {
      if (e21.children) {
        const n2 = e21.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e21.children.length; r2++) {
            const i2 = e21.children[r2];
            if (!n2[r2 + 1])
              if (n2[r2]) {
                const e22 = i2.prev, n3 = i2.firstChild, r3 = new Ij(e22.sourceSpan.start, n3.sourceSpan.end), u2 = new Ij(r3.start, i2.sourceSpan.end);
                t3.push(i2.clone({condition: e22.condition, sourceSpan: u2, startSourceSpan: r3, children: i2.children.slice(1)}));
              } else
                t3.push(i2);
          }
          e21.setChildren(t3);
        }
      }
    });
  }, function(e20) {
    return function(e21, t2, n2) {
      e21.walk((e22) => {
        if (e22.children) {
          const r2 = e22.children.map(t2);
          if (r2.some(Boolean)) {
            const t3 = [];
            for (let i2 = 0; i2 < e22.children.length; i2++) {
              const u2 = e22.children[i2];
              if (u2.type !== "text" && !r2[i2]) {
                t3.push(u2);
                continue;
              }
              const o2 = u2.type === "text" ? u2 : u2.clone({type: "text", value: n2(u2)});
              if (t3.length === 0 || Ln$2(t3).type !== "text") {
                t3.push(o2);
                continue;
              }
              const s2 = t3.pop();
              t3.push(s2.clone({value: s2.value + o2.value, sourceSpan: new Ij(s2.sourceSpan.start, o2.sourceSpan.end)}));
            }
            e22.setChildren(t3);
          }
        }
      });
    }(e20, (e21) => e21.type === "cdata", (e21) => `<![CDATA[${e21.value}]]>`);
  }, function(e20, t2) {
    if (t2.parser === "html")
      return;
    const n2 = /{{(.+?)}}/s;
    e20.walk((e21) => {
      if (!Mj(e21))
        return;
      const t3 = [];
      for (const r2 of e21.children) {
        if (r2.type !== "text") {
          t3.push(r2);
          continue;
        }
        let e22 = r2.sourceSpan.start, i2 = null;
        const u2 = r2.value.split(n2);
        for (let n3 = 0; n3 < u2.length; n3++, e22 = i2) {
          const r3 = u2[n3];
          n3 % 2 != 0 ? (i2 = e22.moveBy(r3.length + 4), t3.push({type: "interpolation", sourceSpan: new Ij(e22, i2), children: r3.length === 0 ? [] : [{type: "text", value: r3, sourceSpan: new Ij(e22.moveBy(2), i2.moveBy(-2))}]})) : (i2 = e22.moveBy(r3.length), r3.length > 0 && t3.push({type: "text", value: r3, sourceSpan: new Ij(e22, i2)}));
        }
      }
      e21.setChildren(t3);
    });
  }, function(e20) {
    e20.walk((e21) => {
      if (!e21.children)
        return;
      if (e21.children.length === 0 || e21.children.length === 1 && e21.children[0].type === "text" && Lj(e21.children[0].value).length === 0)
        return e21.hasDanglingSpaces = e21.children.length > 0, void (e21.children = []);
      const t2 = Uj(e21), n2 = Vj(e21);
      e21.setChildren(e21.children.flatMap((e22) => {
        if (e22.type !== "text" || t2)
          return e22;
        const n3 = [], {leadingWhitespace: r2, text: i2, trailingWhitespace: u2} = jj(e22.value);
        return r2 && n3.push(Gj), i2 && n3.push({type: "text", value: i2, sourceSpan: new Ij(e22.sourceSpan.start.moveBy(r2.length), e22.sourceSpan.end.moveBy(-u2.length))}), u2 && n3.push(Gj), n3;
      }).map((e22, t3, n3) => {
        if (e22 !== Gj)
          return Object.assign(Object.assign({}, e22), {}, {hasLeadingSpaces: n3[t3 - 1] === Gj, hasTrailingSpaces: n3[t3 + 1] === Gj});
      }).filter(Boolean)), e21.isWhitespaceSensitive = t2, e21.isIndentationSensitive = n2;
    });
  }, function(e20, t2) {
    e20.walk((e21) => Object.assign(e21, {cssDisplay: Rj(e21, t2)}));
  }, function(e20) {
    e20.walk((e21) => Object.assign(e21, {isSelfClosing: !e21.children || e21.type === "element" && (e21.tagDefinition.isVoid || e21.startSourceSpan === e21.endSourceSpan)}));
  }, function(e20, t2) {
    e20.walk((e21) => e21.type !== "element" ? e21 : Object.assign(e21, {hasHtmComponentClosingTag: e21.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e21.endSourceSpan.start.offset, e21.endSourceSpan.end.offset))}));
  }, function(e20, t2) {
    e20.walk((e21) => {
      e21.children && (e21.children.length !== 0 ? e21.setChildren(e21.children.map((e22) => Object.assign(Object.assign({}, e22), {}, {isLeadingSpaceSensitive: Wj(e22, t2), isTrailingSpaceSensitive: qj(e22, t2)})).map((e22, t3, n2) => Object.assign(Object.assign({}, e22), {}, {isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e22.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e22.isTrailingSpaceSensitive}))) : e21.isDanglingSpaceSensitive = $j(e21));
    });
  }, function(e20) {
    const t2 = (e21) => e21.type === "element" && e21.attrs.length === 0 && e21.children.length === 1 && e21.firstChild.type === "text" && !_j(e21.children[0].value) && !e21.firstChild.hasLeadingSpaces && !e21.firstChild.hasTrailingSpaces && e21.isLeadingSpaceSensitive && !e21.hasLeadingSpaces && e21.isTrailingSpaceSensitive && !e21.hasTrailingSpaces && e21.prev && e21.prev.type === "text" && e21.next && e21.next.type === "text";
    e20.walk((e21) => {
      if (e21.children) {
        const n2 = e21.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e21.children.length; r2++) {
            const i2 = e21.children[r2];
            if (n2[r2]) {
              const n3 = t3.pop(), u2 = e21.children[++r2], {isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2} = u2;
              t3.push(n3.clone({value: n3.value + `<${i2.rawName}>` + i2.firstChild.value + `</${i2.rawName}>` + u2.value, sourceSpan: new Ij(n3.sourceSpan.start, u2.sourceSpan.end), isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2}));
            } else
              t3.push(i2);
          }
          e21.setChildren(t3);
        }
      }
    });
  }];
  const Gj = {type: "whitespace"};
  var Hj = function(e20, t2) {
    const n2 = e20.map((e21) => e21);
    for (const e21 of zj)
      e21(n2, t2);
    return n2;
  };
  var Jj = {hasPragma: function(e20) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
  }, insertPragma: function(e20) {
    return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
  }};
  var Xj = {locStart: function(e20) {
    return e20.sourceSpan.start.offset;
  }, locEnd: function(e20) {
    return e20.sourceSpan.end.offset;
  }};
  const {isNonEmptyArray: Yj} = yi$2, {builders: {indent: Kj, join: Qj, line: Zj, softline: e_}, utils: {replaceTextEndOfLine: t_}} = eu$1, {locStart: n_, locEnd: r_} = Xj, {isTextLikeNode: i_, getLastDescendant: u_, isPreLikeNode: o_, hasPrettierIgnore: s_, shouldPreserveContent: a_} = KL;
  function c_(e20, t2) {
    return e20.lastChild && D_(e20.lastChild) ? "" : [p_(e20, t2), d_(e20, t2)];
  }
  function l_(e20, t2) {
    return (e20.next ? m_(e20.next) : y_(e20.parent)) ? "" : [h_(e20, t2), f_(e20, t2)];
  }
  function p_(e20, t2) {
    return y_(e20) ? h_(e20.lastChild, t2) : "";
  }
  function f_(e20, t2) {
    return D_(e20) ? d_(e20.parent, t2) : E_(e20) ? S_(e20.next) : "";
  }
  function d_(e20, t2) {
    if (mf(!e20.isSelfClosing), g_(e20, t2))
      return "";
    switch (e20.type) {
      case "ieConditionalComment":
        return "<!";
      case "element":
        if (e20.hasHtmComponentClosingTag)
          return "<//";
      default:
        return `</${e20.rawName}`;
    }
  }
  function h_(e20, t2) {
    if (g_(e20, t2))
      return "";
    switch (e20.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";
      case "ieConditionalStartComment":
        return "]><!-->";
      case "interpolation":
        return "}}";
      case "element":
        if (e20.isSelfClosing)
          return "/>";
      default:
        return ">";
    }
  }
  function g_(e20, t2) {
    return !e20.isSelfClosing && !e20.endSourceSpan && (s_(e20) || a_(e20.parent, t2));
  }
  function m_(e20) {
    return e20.prev && e20.prev.type !== "docType" && !i_(e20.prev) && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
  }
  function y_(e20) {
    return e20.lastChild && e20.lastChild.isTrailingSpaceSensitive && !e20.lastChild.hasTrailingSpaces && !i_(u_(e20.lastChild)) && !o_(e20);
  }
  function D_(e20) {
    return !e20.next && !e20.hasTrailingSpaces && e20.isTrailingSpaceSensitive && i_(u_(e20));
  }
  function E_(e20) {
    return e20.next && !i_(e20.next) && i_(e20) && e20.isTrailingSpaceSensitive && !e20.hasTrailingSpaces;
  }
  function C_(e20) {
    return !e20.prev && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
  }
  function b_(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!Yj(r2.attrs))
      return r2.isSelfClosing ? " " : "";
    const i2 = r2.prev && r2.prev.type === "comment" && function(e21) {
      const t3 = e21.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
      return !!t3 && (!t3[1] || t3[1].split(/\s+/));
    }(r2.prev.value), u2 = typeof i2 == "boolean" ? () => i2 : Array.isArray(i2) ? (e21) => i2.includes(e21.rawName) : () => false, o2 = e20.map((e21) => {
      const r3 = e21.getValue();
      return u2(r3) ? t_(t2.originalText.slice(n_(r3), r_(r3))) : n2();
    }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Kj([s2 ? " " : Zj, Qj(Zj, o2)])];
    return r2.firstChild && C_(r2.firstChild) || r2.isSelfClosing && y_(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Zj : e_), a2;
  }
  function A_(e20) {
    return e20.firstChild && C_(e20.firstChild) ? "" : x_(e20);
  }
  function v_(e20, t2) {
    return e20.prev && E_(e20.prev) ? "" : [F_(e20, t2), S_(e20)];
  }
  function F_(e20, t2) {
    return C_(e20) ? x_(e20.parent) : m_(e20) ? h_(e20.prev, t2) : "";
  }
  function S_(e20) {
    switch (e20.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return `<!--[if ${e20.condition}`;
      case "ieConditionalEndComment":
        return "<!--<!";
      case "interpolation":
        return "{{";
      case "docType":
        return "<!DOCTYPE";
      case "element":
        if (e20.condition)
          return `<!--[if ${e20.condition}]><!--><${e20.rawName}`;
      default:
        return `<${e20.rawName}`;
    }
  }
  function x_(e20) {
    switch (mf(!e20.isSelfClosing), e20.type) {
      case "ieConditionalComment":
        return "]>";
      case "element":
        if (e20.condition)
          return "><!--<![endif]-->";
      default:
        return ">";
    }
  }
  var w_ = {printClosingTag: function(e20, t2) {
    return [e20.isSelfClosing ? "" : c_(e20, t2), l_(e20, t2)];
  }, printClosingTagStart: c_, printClosingTagStartMarker: d_, printClosingTagEndMarker: h_, printClosingTagSuffix: f_, printClosingTagEnd: l_, needsToBorrowLastChildClosingTagEndMarker: y_, needsToBorrowParentClosingTagStartMarker: D_, needsToBorrowPrevClosingTagEndMarker: m_, printOpeningTag: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return [v_(r2, t2), b_(e20, t2, n2), r2.isSelfClosing ? "" : A_(r2)];
  }, printOpeningTagStart: v_, printOpeningTagPrefix: F_, printOpeningTagStartMarker: S_, printOpeningTagEndMarker: x_, needsToBorrowNextOpeningTagStartMarker: E_, needsToBorrowParentOpeningTagEndMarker: C_}, T_ = r$3(function(e20) {
    var n2, r2;
    n2 = t$3, r2 = function() {
      return function(e21, t2) {
        var n3 = t2 && t2.logger || console;
        function r3(e22) {
          return e22 === " " || e22 === "	" || e22 === "\n" || e22 === "\f" || e22 === "\r";
        }
        function i2(t3) {
          var n4, r4 = t3.exec(e21.substring(y2));
          if (r4)
            return n4 = r4[0], y2 += n4.length, n4;
        }
        for (var u2, o2, s2, a2, c2, l2 = e21.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
          if (i2(f2), y2 >= l2)
            return D2;
          u2 = i2(d2), o2 = [], u2.slice(-1) === "," ? (u2 = u2.replace(h2, ""), C2()) : E2();
        }
        function E2() {
          for (i2(p2), s2 = "", a2 = "in descriptor"; ; ) {
            if (c2 = e21.charAt(y2), a2 === "in descriptor")
              if (r3(c2))
                s2 && (o2.push(s2), s2 = "", a2 = "after descriptor");
              else {
                if (c2 === ",")
                  return y2 += 1, s2 && o2.push(s2), void C2();
                if (c2 === "(")
                  s2 += c2, a2 = "in parens";
                else {
                  if (c2 === "")
                    return s2 && o2.push(s2), void C2();
                  s2 += c2;
                }
              }
            else if (a2 === "in parens")
              if (c2 === ")")
                s2 += c2, a2 = "in descriptor";
              else {
                if (c2 === "")
                  return o2.push(s2), void C2();
                s2 += c2;
              }
            else if (a2 === "after descriptor")
              if (r3(c2))
                ;
              else {
                if (c2 === "")
                  return void C2();
                a2 = "in descriptor", y2 -= 1;
              }
            y2 += 1;
          }
        }
        function C2() {
          var t3, r4, i3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
          for (s3 = 0; s3 < o2.length; s3++)
            c3 = (a3 = o2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t3 || r4) && (d3 = true), p3 === 0 ? d3 = true : t3 = p3) : m2.test(l3) && c3 === "x" ? ((t3 || r4 || i3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((i3 || r4) && (d3 = true), p3 === 0 ? d3 = true : i3 = p3) : d3 = true;
          d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e21 + "' at '" + a3 + "'.") : (h3.url = u2, t3 && (h3.w = t3), r4 && (h3.d = r4), i3 && (h3.h = i3), D2.push(h3));
        }
      };
    }, e20.exports ? e20.exports = r2() : n2.parseSrcset = r2();
  });
  const {builders: {group: B_, ifBreak: N_, indent: k_, join: P_, line: O_, softline: I_}} = eu$1;
  const L_ = [":", "__", "--", "_", "-"];
  function j_(e20) {
    const t2 = e20.search(/[^_-]/);
    if (t2 !== -1)
      for (const n2 of L_) {
        const r2 = e20.indexOf(n2, t2);
        if (r2 !== -1)
          return e20.slice(0, r2);
      }
    return e20;
  }
  var __ = {printImgSrcset: function(e20) {
    const t2 = T_(e20, {logger: {error(e21) {
      throw new Error(e21);
    }}}), n2 = t2.some(({w: e21}) => e21), r2 = t2.some(({h: e21}) => e21);
    if (n2 + r2 + t2.some(({d: e21}) => e21) > 1)
      throw new Error("Mixed descriptor in srcset is not supported");
    const i2 = n2 ? "w" : r2 ? "h" : "d", u2 = n2 ? "w" : r2 ? "h" : "x", o2 = (e21) => Math.max(...e21), s2 = t2.map((e21) => e21.url), a2 = o2(s2.map((e21) => e21.length)), c2 = t2.map((e21) => e21[i2]).map((e21) => e21 ? e21.toString() : ""), l2 = c2.map((e21) => {
      const t3 = e21.indexOf(".");
      return t3 === -1 ? e21.length : t3;
    }), p2 = o2(l2);
    return P_([",", O_], s2.map((e21, t3) => {
      const n3 = [e21], r3 = c2[t3];
      if (r3) {
        const i3 = a2 - e21.length + 1, o3 = p2 - l2[t3], s3 = " ".repeat(i3 + o3);
        n3.push(N_(s3, " "), r3 + u2);
      }
      return n3;
    }));
  }, printClassNames: function(e20) {
    const t2 = e20.trim().split(/\s+/), n2 = [];
    let r2;
    for (let e21 = 0; e21 < t2.length; e21++) {
      const i2 = j_(t2[e21]);
      i2 !== r2 && i2 !== t2[e21 - 1] && n2.push([]), Ln$2(n2).push(t2[e21]), r2 = i2;
    }
    return [k_([I_, P_(O_, n2.map((e21) => B_(P_(O_, e21))))]), I_];
  }};
  const {builders: {group: M_}} = eu$1;
  var R_ = {isVueEventBindingExpression: function(e20) {
    const t2 = e20.trim();
    return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
  }, printVueFor: function(e20, t2) {
    const {left: n2, operator: r2, right: i2} = function(e21) {
      const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, i3 = e21.match(t3);
      if (!i3)
        return;
      const u2 = {};
      u2.for = i3[3].trim();
      const o2 = i3[1].trim().replace(r3, ""), s2 = o2.match(n3);
      s2 ? (u2.alias = o2.replace(n3, ""), u2.iterator1 = s2[1].trim(), s2[2] && (u2.iterator2 = s2[2].trim())) : u2.alias = o2;
      return {left: `${[u2.alias, u2.iterator1, u2.iterator2].filter(Boolean).join(",")}`, operator: i3[2], right: u2.for};
    }(e20);
    return [M_(t2(`function _(${n2}) {}`, {parser: "babel", __isVueForBindingLeft: true})), " ", r2, " ", t2(i2, {parser: "__js_expression"}, {stripTrailingHardline: true})];
  }, printVueBindings: function(e20, t2) {
    return t2(`function _(${e20}) {}`, {parser: "babel", __isVueBindings: true});
  }};
  const {needsToBorrowParentClosingTagStartMarker: $_, printClosingTagStartMarker: V_, needsToBorrowLastChildClosingTagEndMarker: W_, printClosingTagEndMarker: q_, needsToBorrowParentOpeningTagEndMarker: U_, printOpeningTagEndMarker: z_} = w_;
  var G_ = function(e20, t2) {
    let n2 = e20.startSourceSpan.end.offset;
    e20.firstChild && U_(e20.firstChild) && (n2 -= z_(e20).length);
    let r2 = e20.endSourceSpan.start.offset;
    return e20.lastChild && $_(e20.lastChild) ? r2 += V_(e20, t2).length : W_(e20) && (r2 -= q_(e20.lastChild, t2).length), t2.originalText.slice(n2, r2);
  };
  const {builders: {breakParent: H_, group: J_, hardline: X_, indent: Y_, line: K_, fill: Q_, softline: Z_}, utils: {mapDoc: eM, replaceTextEndOfLine: tM}} = eu$1, {printClosingTag: nM, printClosingTagSuffix: rM, needsToBorrowPrevClosingTagEndMarker: iM, printOpeningTagPrefix: uM, printOpeningTag: oM} = w_, {printImgSrcset: sM, printClassNames: aM} = __, {printVueFor: cM, printVueBindings: lM, isVueEventBindingExpression: pM} = R_, {isScriptLikeTag: fM, isVueNonHtmlBlock: dM, inferScriptParser: hM, htmlTrimPreserveIndentation: gM, dedentString: mM, unescapeQuoteEntities: yM, isVueSlotAttribute: DM, isVueSfcBindingsAttribute: EM, getTextValueParts: CM} = KL;
  function bM(e20, t2, n2) {
    const r2 = (t3) => new RegExp(t3.join("|")).test(e20.fullName), i2 = () => yM(e20.value);
    let u2 = false;
    const o2 = (e21, t3) => {
      const n3 = e21.type === "NGRoot" ? e21.node.type === "NGMicrosyntax" && e21.node.body.length === 1 && e21.node.body[0].type === "NGMicrosyntaxExpression" ? e21.node.body[0].expression : e21.node : e21.type === "JsExpressionRoot" ? e21.node : e21;
      !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (u2 = true);
    }, s2 = (e21, t3 = true) => J_([Y_([Z_, e21]), t3 ? Z_ : ""]), a2 = (e21) => u2 ? ((e22) => J_(e22))(e21) : s2(e21), c2 = (e21, n3) => t2(e21, Object.assign({__onHtmlBindingRoot: o2, __embeddedInHtml: true}, n3), {stripTrailingHardline: true});
    if (e20.fullName === "srcset" && (e20.parent.fullName === "img" || e20.parent.fullName === "source"))
      return s2(sM(i2()));
    if (e20.fullName === "class" && !n2.parentParser) {
      const e21 = i2();
      if (!e21.includes("{{"))
        return aM(e21);
    }
    if (e20.fullName === "style" && !n2.parentParser) {
      const e21 = i2();
      if (!e21.includes("{{"))
        return s2(c2(e21, {parser: "css", __isHTMLStyleAttribute: true}));
    }
    if (n2.parser === "vue") {
      if (e20.fullName === "v-for")
        return cM(i2(), c2);
      if (DM(e20) || EM(e20, n2))
        return lM(i2(), c2);
      const t3 = ["^:", "^v-bind:"], u3 = ["^v-"];
      if (r2(["^@", "^v-on:"])) {
        const e21 = i2();
        return a2(c2(e21, {parser: pM(e21) ? "__js_expression" : "__vue_event_binding"}));
      }
      if (r2(t3))
        return a2(c2(i2(), {parser: "__vue_expression"}));
      if (r2(u3))
        return a2(c2(i2(), {parser: "__js_expression"}));
    }
    if (n2.parser === "angular") {
      const t3 = (e21, t4) => c2(e21, Object.assign(Object.assign({}, t4), {}, {trailingComma: "none"})), n3 = ["^\\*"], u3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], o3 = ["^i18n(-.+)?$"];
      if (r2(["^\\(.+\\)$", "^on-"]))
        return a2(t3(i2(), {parser: "__ng_action"}));
      if (r2(u3))
        return a2(t3(i2(), {parser: "__ng_binding"}));
      if (r2(o3)) {
        const t4 = i2().trim();
        return s2(Q_(CM(e20, t4)), !t4.includes("@@"));
      }
      if (r2(n3))
        return a2(t3(i2(), {parser: "__ng_directive"}));
      const l2 = /{{(.+?)}}/s, p2 = i2();
      if (l2.test(p2)) {
        const e21 = [];
        for (const [n4, r3] of p2.split(l2).entries())
          if (n4 % 2 == 0)
            e21.push(tM(r3));
          else
            try {
              e21.push(J_(["{{", Y_([K_, t3(r3, {parser: "__ng_interpolation", __isInHtmlInterpolation: true})]), K_, "}}"]));
            } catch (e) {
              e21.push("{{", tM(r3), "}}");
            }
        return J_(e21);
      }
    }
    return null;
  }
  var AM = function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    switch (i2.type) {
      case "element":
        if (fM(i2) || i2.type === "interpolation")
          return;
        if (!i2.isSelfClosing && dM(i2, r2)) {
          const u2 = hM(i2, r2);
          if (!u2)
            return;
          const o2 = G_(i2, r2);
          let s2 = /^\s*$/.test(o2), a2 = "";
          return s2 || (a2 = n2(gM(o2), {parser: u2, __embeddedInHtml: true}, {stripTrailingHardline: true}), s2 = a2 === ""), [uM(i2, r2), J_(oM(e20, r2, t2)), s2 ? "" : X_, a2, s2 ? "" : X_, nM(i2, r2), rM(i2, r2)];
        }
        break;
      case "text":
        if (fM(i2.parent)) {
          const e21 = hM(i2.parent);
          if (e21) {
            const t3 = e21 === "markdown" ? mM(i2.value.replace(/^[^\S\n]*?\n/, "")) : i2.value, u2 = {parser: e21, __embeddedInHtml: true};
            if (r2.parser === "html" && e21 === "babel") {
              let e22 = "script";
              const {attrMap: t4} = i2.parent;
              t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e22 = "module"), u2.__babelSourceType = e22;
            }
            return [H_, uM(i2, r2), n2(t3, u2, {stripTrailingHardline: true}), rM(i2, r2)];
          }
        } else if (i2.parent.type === "interpolation") {
          const e21 = {__isInHtmlInterpolation: true, __embeddedInHtml: true};
          return r2.parser === "angular" ? (e21.parser = "__ng_interpolation", e21.trailingComma = "none") : r2.parser === "vue" ? e21.parser = "__vue_expression" : e21.parser = "__js_expression", [Y_([K_, n2(i2.value, e21, {stripTrailingHardline: true})]), i2.parent.next && iM(i2.parent.next) ? " " : K_];
        }
        break;
      case "attribute": {
        if (!i2.value)
          break;
        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
          return [i2.rawName, "=", i2.value];
        if (r2.parser === "lwc") {
          if (/^{.*}$/s.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
            return [i2.rawName, "=", i2.value];
        }
        const e21 = bM(i2, (e22, t3) => n2(e22, Object.assign({__isInHtmlAttribute: true, __embeddedInHtml: true}, t3), {stripTrailingHardline: true}), r2);
        if (e21)
          return [i2.rawName, '="', J_(eM(e21, (e22) => typeof e22 == "string" ? e22.replace(/"/g, "&quot;") : e22)), '"'];
        break;
      }
      case "front-matter":
        return rN(i2, n2);
    }
  };
  const {builders: {breakParent: vM, group: FM, ifBreak: SM, line: xM, softline: wM, hardline: TM}, utils: {replaceTextEndOfLine: BM}} = eu$1, {locStart: NM, locEnd: kM} = Xj, {forceBreakChildren: PM, forceNextEmptyLine: OM, isTextLikeNode: IM, hasPrettierIgnore: LM, preferHardlineAsLeadingSpaces: jM} = KL, {printOpeningTagPrefix: _M, needsToBorrowNextOpeningTagStartMarker: MM, printOpeningTagStartMarker: RM, needsToBorrowPrevClosingTagEndMarker: $M, printClosingTagEndMarker: VM, printClosingTagSuffix: WM, needsToBorrowParentClosingTagStartMarker: qM} = w_;
  function UM(e20, t2, n2) {
    const r2 = e20.getValue();
    return LM(r2) ? [_M(r2, t2), ...BM(t2.originalText.slice(NM(r2) + (r2.prev && MM(r2.prev) ? RM(r2).length : 0), kM(r2) - (r2.next && $M(r2.next) ? VM(r2, t2).length : 0))), WM(r2, t2)] : n2();
  }
  function zM(e20, t2) {
    return IM(e20) && IM(t2) ? e20.isTrailingSpaceSensitive ? e20.hasTrailingSpaces ? jM(t2) ? TM : xM : "" : jM(t2) ? TM : wM : MM(e20) && (LM(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e20.type === "element" && e20.isSelfClosing && $M(t2) ? "" : !t2.isLeadingSpaceSensitive || jM(t2) || $M(t2) && e20.lastChild && qM(e20.lastChild) && e20.lastChild.lastChild && qM(e20.lastChild.lastChild) ? TM : t2.hasLeadingSpaces ? xM : wM;
  }
  var GM = {printChildren: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (PM(r2))
      return [vM, ...e20.map((e21) => {
        const r3 = e21.getValue(), i3 = r3.prev ? zM(r3.prev, r3) : "";
        return [i3 ? [i3, OM(r3.prev) ? TM : ""] : "", UM(e21, t2, n2)];
      }, "children")];
    const i2 = r2.children.map(() => Symbol(""));
    return e20.map((e21, r3) => {
      const u2 = e21.getValue();
      if (IM(u2)) {
        if (u2.prev && IM(u2.prev)) {
          const r4 = zM(u2.prev, u2);
          if (r4)
            return OM(u2.prev) ? [TM, TM, UM(e21, t2, n2)] : [r4, UM(e21, t2, n2)];
        }
        return UM(e21, t2, n2);
      }
      const o2 = [], s2 = [], a2 = [], c2 = [], l2 = u2.prev ? zM(u2.prev, u2) : "", p2 = u2.next ? zM(u2, u2.next) : "";
      return l2 && (OM(u2.prev) ? o2.push(TM, TM) : l2 === TM ? o2.push(TM) : IM(u2.prev) ? s2.push(l2) : s2.push(SM("", wM, {groupId: i2[r3 - 1]}))), p2 && (OM(u2) ? IM(u2.next) && c2.push(TM, TM) : p2 === TM ? IM(u2.next) && c2.push(TM) : a2.push(p2)), [...o2, FM([...s2, FM([UM(e21, t2, n2), ...a2], {id: i2[r3]})]), ...c2];
    }, "children");
  }};
  const {builders: {breakParent: HM, dedentToRoot: JM, group: XM, ifBreak: YM, indentIfBreak: KM, indent: QM, line: ZM, softline: eR}, utils: {replaceTextEndOfLine: tR}} = eu$1, {shouldPreserveContent: nR, isScriptLikeTag: rR, isVueCustomBlock: iR, countParents: uR, forceBreakContent: oR} = KL, {printOpeningTagPrefix: sR, printOpeningTag: aR, printClosingTagSuffix: cR, printClosingTag: lR, needsToBorrowPrevClosingTagEndMarker: pR, needsToBorrowLastChildClosingTagEndMarker: fR} = w_, {printChildren: dR} = GM;
  var hR = {printElement: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (nR(r2, t2))
      return [sR(r2, t2), XM(aR(e20, t2, n2)), ...tR(G_(r2, t2)), ...lR(r2, t2), cR(r2, t2)];
    const i2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, u2 = Symbol("element-attr-group-id"), o2 = (i3) => XM([XM(aR(e20, t2, n2), {id: u2}), i3, lR(r2, t2)]);
    return r2.children.length === 0 ? o2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? ZM : "") : o2([oR(r2) ? HM : "", (s2 = [i2 ? YM(eR, "", {groupId: u2}) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? ZM : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? JM(eR) : eR, dR(e20, t2, n2)], i2 ? KM(s2, {groupId: u2}) : !rR(r2) && !iR(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? QM(s2) : s2), (r2.next ? pR(r2.next) : fR(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : i2 ? YM(eR, "", {groupId: u2}) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? ZM : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t2.tabWidth * uR(e20, (e21) => e21.parent && e21.parent.type !== "root")}}$`).test(r2.lastChild.value) ? "" : eR]);
    var s2;
  }};
  const {builders: {fill: gR, group: mR, hardline: yR, literalline: DR}, utils: {cleanDoc: ER, getDocParts: CR, isConcat: bR, replaceTextEndOfLine: AR}} = eu$1, {countChars: vR, unescapeQuoteEntities: FR, getTextValueParts: SR} = KL, {insertPragma: xR} = Jj, {locStart: wR, locEnd: TR} = Xj, {printClosingTagSuffix: BR, printClosingTagEnd: NR, printOpeningTagPrefix: kR, printOpeningTagStart: PR} = w_, {printElement: OR} = hR, {printChildren: IR} = GM;
  var LR = {preprocess: Hj, print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    switch (r2.type) {
      case "front-matter":
        return AR(r2.raw);
      case "root":
        return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [mR(IR(e20, t2, n2)), yR];
      case "element":
      case "ieConditionalComment":
        return OR(e20, t2, n2);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [PR(r2), NR(r2)];
      case "interpolation":
        return [PR(r2, t2), ...e20.map(n2, "children"), NR(r2, t2)];
      case "text": {
        if (r2.parent.type === "interpolation") {
          const e22 = /\n[^\S\n]*?$/, t3 = e22.test(r2.value), n3 = t3 ? r2.value.replace(e22, "") : r2.value;
          return [...AR(n3), t3 ? yR : ""];
        }
        const e21 = ER([kR(r2, t2), ...SR(r2), BR(r2, t2)]);
        return bR(e21) || e21.type === "fill" ? gR(CR(e21)) : e21;
      }
      case "docType":
        return [mR([PR(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), NR(r2, t2)];
      case "comment":
        return [kR(r2, t2), ...AR(t2.originalText.slice(wR(r2), TR(r2)), DR), BR(r2, t2)];
      case "attribute": {
        if (r2.value === null)
          return r2.rawName;
        const e21 = FR(r2.value), t3 = vR(e21, "'") < vR(e21, '"') ? "'" : '"';
        return [r2.rawName, "=", t3, ...AR(t3 === '"' ? e21.replace(/"/g, "&quot;") : e21.replace(/'/g, "&apos;")), t3];
      }
      default:
        throw new Error(`Unexpected node type ${r2.type}`);
    }
  }, insertPragma: xR, massageAstNode: dL, embed: AM};
  var jR = {bracketSameLine: WB.bracketSameLine, htmlWhitespaceSensitivity: {since: "1.15.0", category: "HTML", type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{value: "css", description: "Respect the default value of CSS display property."}, {value: "strict", description: "Whitespaces are considered sensitive."}, {value: "ignore", description: "Whitespaces are considered insensitive."}]}, vueIndentScriptAndStyle: {since: "1.19.0", category: "HTML", type: "boolean", default: false, description: "Indent script and style tags in Vue files."}}, _R = {name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146}, MR = {name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391};
  var RR = {languages: [Xd(_R, () => ({name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: []})), Xd(_R, (e20) => ({since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e20.extensions, ".mjml"]})), Xd(_R, () => ({name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: []})), Xd(MR, () => ({since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"]}))], printers: {html: LR}, options: jR, parsers: void 0};
  var $R = {isPragma: function(e20) {
    return /^\s*@(?:prettier|format)\s*$/.test(e20);
  }, hasPragma: function(e20) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e20);
  }, insertPragma: function(e20) {
    return `# @format

${e20}`;
  }};
  var VR = {locStart: function(e20) {
    return e20.position.start.offset;
  }, locEnd: function(e20) {
    return e20.position.end.offset;
  }};
  var WR = function(e20, t2, n2, r2) {
    if (e20.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
      return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, {parser: "json"}));
  };
  const {getLast: qR, isNonEmptyArray: UR} = yi$2;
  function zR(e20, t2) {
    return e20 && typeof e20.type == "string" && (!t2 || t2.includes(e20.type));
  }
  function GR(e20) {
    return e20.value.trim() === "prettier-ignore";
  }
  function HR(e20) {
    return e20 && UR(e20.leadingComments);
  }
  function JR(e20) {
    return e20 && UR(e20.middleComments);
  }
  function XR(e20) {
    return e20 && e20.indicatorComment;
  }
  function YR(e20) {
    return e20 && e20.trailingComment;
  }
  function KR(e20) {
    return e20 && UR(e20.endComments);
  }
  function QR(e20) {
    const t2 = [];
    let n2;
    for (const r2 of e20.split(/( +)/))
      r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
    return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
  }
  var ZR = {getLast: qR, getAncestorCount: function(e20, t2) {
    let n2 = 0;
    const r2 = e20.stack.length - 1;
    for (let i2 = 0; i2 < r2; i2++) {
      const r3 = e20.stack[i2];
      zR(r3) && t2(r3) && n2++;
    }
    return n2;
  }, isNode: zR, isEmptyNode: function(e20) {
    return !UR(e20.children) && !function(e21) {
      return HR(e21) || JR(e21) || XR(e21) || YR(e21) || KR(e21);
    }(e20);
  }, isInlineNode: function(e20) {
    if (!e20)
      return true;
    switch (e20.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  }, mapNode: function e11(t2, n2, r2) {
    return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, {children: t2.children.map((r3) => e11(r3, n2, t2))}) : t2, r2);
  }, defineShortcut: function(e20, t2, n2) {
    Object.defineProperty(e20, t2, {get: n2, enumerable: false});
  }, isNextLineEmpty: function(e20, t2) {
    let n2 = 0;
    const r2 = t2.length;
    for (let i2 = e20.position.end.offset - 1; i2 < r2; i2++) {
      const e21 = t2[i2];
      if (e21 === "\n" && n2++, n2 === 1 && /\S/.test(e21))
        return false;
      if (n2 === 2)
        return true;
    }
    return false;
  }, isLastDescendantNode: function(e20) {
    switch (e20.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    const t2 = e20.stack.length;
    for (let n2 = 1; n2 < t2; n2++) {
      const t3 = e20.stack[n2], r2 = e20.stack[n2 - 1];
      if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
        return false;
    }
    return true;
  }, getBlockValueLineContents: function(e20, {parentIndent: t2, isLastDescendant: n2, options: r2}) {
    const i2 = e20.position.start.line === e20.position.end.line ? "" : r2.originalText.slice(e20.position.start.offset, e20.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e20.indent === null ? ((e21) => e21 ? e21[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e20.indent - 1 + t2, o2 = i2.split("\n").map((e21) => e21.slice(u2));
    return r2.proseWrap === "preserve" || e20.type === "blockLiteral" ? s2(o2.map((e21) => e21.length === 0 ? [] : [e21])) : s2(o2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((e21, t3, n3) => n3 !== 0 && o2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(qR(e21)) ? [...e21.slice(0, -1), [...qR(e21), ...t3]] : [...e21, t3], []).map((e21) => e21.reduce((e22, t3) => e22.length > 0 && /\s$/.test(qR(e22)) ? [...e22.slice(0, -1), qR(e22) + " " + t3] : [...e22, t3], [])).map((e21) => r2.proseWrap === "never" ? [e21.join(" ")] : e21));
    function s2(t3) {
      if (e20.chomping === "keep")
        return qR(t3).length === 0 ? t3.slice(0, -1) : t3;
      let r3 = 0;
      for (let e21 = t3.length - 1; e21 >= 0 && t3[e21].length === 0; e21--)
        r3++;
      return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
    }
  }, getFlowScalarLineContents: function(e20, t2, n2) {
    const r2 = t2.split("\n").map((e21, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e21 : t3 !== 0 && t3 !== n3.length - 1 ? e21.trim() : t3 === 0 ? e21.trimEnd() : e21.trimStart());
    return n2.proseWrap === "preserve" ? r2.map((e21) => e21.length === 0 ? [] : [e21]) : r2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((t3, n3, i2) => i2 !== 0 && r2[i2 - 1].length > 0 && n3.length > 0 && (e20 !== "quoteDouble" || !qR(qR(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...qR(t3), ...n3]] : [...t3, n3], []).map((e21) => n2.proseWrap === "never" ? [e21.join(" ")] : e21);
  }, getLastDescendantNode: function e12(t2) {
    return UR(t2.children) ? e12(qR(t2.children)) : t2;
  }, hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue();
    if (t2.type === "documentBody") {
      const t3 = e20.getParentNode();
      return KR(t3.head) && GR(qR(t3.head.endComments));
    }
    return HR(t2) && GR(qR(t2.leadingComments));
  }, hasLeadingComments: HR, hasMiddleComments: JR, hasIndicatorComment: XR, hasTrailingComment: YR, hasEndComments: KR};
  const {defineShortcut: e$, mapNode: t$} = ZR;
  function n$(e20) {
    switch (e20.type) {
      case "document":
        e$(e20, "head", () => e20.children[0]), e$(e20, "body", () => e20.children[1]);
        break;
      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        e$(e20, "content", () => e20.children[0]);
        break;
      case "mappingItem":
      case "flowMappingItem":
        e$(e20, "key", () => e20.children[0]), e$(e20, "value", () => e20.children[1]);
    }
    return e20;
  }
  var r$ = function(e20) {
    return t$(e20, n$);
  };
  const {builders: {softline: i$, align: u$}} = eu$1, {hasEndComments: o$, isNextLineEmpty: s$, isNode: a$} = ZR, c$ = new WeakMap();
  function l$(e20) {
    return o$(e20) && !a$(e20, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
  }
  var p$ = {alignWithSpaces: function(e20, t2) {
    return u$(" ".repeat(e20), t2);
  }, shouldPrintEndComments: l$, printNextEmptyLine: function(e20, t2) {
    const n2 = e20.getValue(), r2 = e20.stack[0];
    let i2;
    return c$.has(r2) ? i2 = c$.get(r2) : (i2 = new Set(), c$.set(r2, i2)), i2.has(n2.position.end.line) || (i2.add(n2.position.end.line), !s$(n2, t2) || l$(e20.getParentNode())) ? "" : i$;
  }};
  const {builders: {ifBreak: f$, line: d$, softline: h$, hardline: g$, join: m$}} = eu$1, {isEmptyNode: y$, getLast: D$, hasEndComments: E$} = ZR, {printNextEmptyLine: C$, alignWithSpaces: b$} = p$;
  function A$(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "flowMapping", u2 = i2 ? "{" : "[", o2 = i2 ? "}" : "]";
    let s2 = h$;
    i2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = d$);
    const a2 = D$(r2.children), c2 = a2 && a2.type === "flowMappingItem" && y$(a2.key) && y$(a2.value);
    return [u2, b$(n2.tabWidth, [s2, v$(e20, t2, n2), n2.trailingComma === "none" ? "" : f$(","), E$(r2) ? [g$, m$(g$, e20.map(t2, "endComments"))] : ""]), c2 ? "" : s2, o2];
  }
  function v$(e20, t2, n2) {
    const r2 = e20.getValue();
    return e20.map((e21, i2) => [t2(), i2 === r2.children.length - 1 ? "" : [",", d$, r2.children[i2].position.start.line !== r2.children[i2 + 1].position.start.line ? C$(e21, n2.originalText) : ""]], "children");
  }
  var F$ = {printFlowMapping: A$, printFlowSequence: A$};
  const {builders: {conditionalGroup: S$, group: x$, hardline: w$, ifBreak: T$, join: B$, line: N$}} = eu$1, {hasLeadingComments: k$, hasMiddleComments: P$, hasTrailingComment: O$, hasEndComments: I$, isNode: L$, isEmptyNode: j$, isInlineNode: _$} = ZR, {alignWithSpaces: M$} = p$;
  function R$(e20, t2) {
    if (!e20)
      return true;
    switch (e20.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;
      case "alias":
        return true;
      default:
        return false;
    }
    if (t2.proseWrap === "preserve")
      return e20.position.start.line === e20.position.end.line;
    if (/\\$/m.test(t2.originalText.slice(e20.position.start.offset, e20.position.end.offset)))
      return false;
    switch (t2.proseWrap) {
      case "never":
        return !e20.value.includes("\n");
      case "always":
        return !/[\n ]/.test(e20.value);
      default:
        return false;
    }
  }
  var $$ = function(e20, t2, n2, r2, i2) {
    const {key: u2, value: o2} = e20, s2 = j$(u2), a2 = j$(o2);
    if (s2 && a2)
      return ": ";
    const c2 = r2("key"), l2 = function(e21) {
      return e21.key.content && e21.key.content.type === "alias";
    }(e20) ? " " : "";
    if (a2)
      return e20.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e20.type !== "mappingItem" || !R$(u2.content, i2) || O$(u2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", M$(2, c2)] : [c2, l2, ":"];
    const p2 = r2("value");
    if (s2)
      return [": ", M$(2, p2)];
    if (k$(o2) || !_$(u2.content))
      return ["? ", M$(2, c2), w$, B$("", n2.map(r2, "value", "leadingComments").map((e21) => [e21, w$])), ": ", M$(2, p2)];
    if (function(e21) {
      if (!e21)
        return true;
      switch (e21.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
          return e21.position.start.line === e21.position.end.line;
        case "alias":
          return true;
        default:
          return false;
      }
    }(u2.content) && !k$(u2.content) && !P$(u2.content) && !O$(u2.content) && !I$(u2) && !k$(o2.content) && !P$(o2.content) && !I$(o2) && R$(o2.content, i2))
      return [c2, l2, ": ", p2];
    const f2 = Symbol("mappingKey"), d2 = x$([T$("? "), x$(M$(2, c2), {id: f2})]), h2 = [w$, ": ", M$(2, p2)], g2 = [l2, ":"];
    k$(o2.content) || I$(o2) && o2.content && !L$(o2.content, ["mapping", "sequence"]) || t2.type === "mapping" && O$(u2.content) && _$(o2.content) || L$(o2.content, ["mapping", "sequence"]) && o2.content.tag === null && o2.content.anchor === null ? g2.push(w$) : o2.content && g2.push(N$), g2.push(p2);
    const m2 = M$(i2.tabWidth, g2);
    return !R$(u2.content, i2) || k$(u2.content) || P$(u2.content) || I$(u2) ? S$([[d2, T$(h2, m2, {groupId: f2})]]) : S$([[c2, m2]]);
  };
  const {builders: {dedent: V$, dedentToRoot: W$, fill: q$, hardline: U$, join: z$, line: G$, literalline: H$, markAsRoot: J$}, utils: {getDocParts: X$}} = eu$1, {getAncestorCount: Y$, getBlockValueLineContents: K$, hasIndicatorComment: Q$, isLastDescendantNode: Z$, isNode: eV} = ZR, {alignWithSpaces: tV} = p$;
  var nV = function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = Y$(e20, (e21) => eV(e21, ["sequence", "mapping"])), u2 = Z$(e20), o2 = [r2.type === "blockFolded" ? ">" : "|"];
    r2.indent !== null && o2.push(r2.indent.toString()), r2.chomping !== "clip" && o2.push(r2.chomping === "keep" ? "+" : "-"), Q$(r2) && o2.push(" ", t2("indicatorComment"));
    const s2 = K$(r2, {parentIndent: i2, isLastDescendant: u2, options: n2}), a2 = [];
    for (const [e21, t3] of s2.entries())
      e21 === 0 && a2.push(U$), a2.push(q$(X$(z$(G$, t3)))), e21 !== s2.length - 1 ? a2.push(t3.length === 0 ? U$ : J$(H$)) : r2.chomping === "keep" && u2 && a2.push(W$(t3.length === 0 ? U$ : H$));
    return r2.indent === null ? o2.push(V$(tV(n2.tabWidth, a2))) : o2.push(W$(tV(r2.indent - 1 + i2, a2))), o2;
  };
  const {builders: {breakParent: rV, fill: iV, group: uV, hardline: oV, join: sV, line: aV, lineSuffix: cV, literalline: lV}, utils: {getDocParts: pV, replaceTextEndOfLine: fV}} = eu$1, {isPreviousLineEmpty: dV} = yi$2, {insertPragma: hV, isPragma: gV} = $R, {locStart: mV} = VR, {getFlowScalarLineContents: yV, getLastDescendantNode: DV, hasLeadingComments: EV, hasMiddleComments: CV, hasTrailingComment: bV, hasEndComments: AV, hasPrettierIgnore: vV, isLastDescendantNode: FV, isNode: SV, isInlineNode: xV} = ZR, {alignWithSpaces: wV, printNextEmptyLine: TV, shouldPrintEndComments: BV} = p$, {printFlowMapping: NV, printFlowSequence: kV} = F$;
  function PV(e20, t2) {
    return bV(e20) || t2 && (t2.head.children.length > 0 || AV(t2.head));
  }
  function OV(e20, t2, n2) {
    const r2 = yV(e20, t2, n2);
    return sV(oV, r2.map((e21) => iV(pV(sV(aV, e21)))));
  }
  var IV = {preprocess: r$, embed: WR, print: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.type !== "mappingValue" && EV(r2) && i2.push([sV(oV, e20.map(n2, "leadingComments")), oV]);
    const {tag: u2, anchor: o2} = r2;
    u2 && i2.push(n2("tag")), u2 && o2 && i2.push(" "), o2 && i2.push(n2("anchor"));
    let s2 = "";
    SV(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !FV(e20) && (s2 = TV(e20, t2.originalText)), (u2 || o2) && (SV(r2, ["sequence", "mapping"]) && !CV(r2) ? i2.push(oV) : i2.push(" ")), CV(r2) && i2.push([r2.middleComments.length === 1 ? "" : oV, sV(oV, e20.map(n2, "middleComments")), oV]);
    const a2 = e20.getParentNode();
    return vV(e20) ? i2.push(fV(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), lV)) : i2.push(uV(function(e21, t3, n3, r3, i3) {
      switch (e21.type) {
        case "root": {
          const {children: t4} = e21, r4 = [];
          n3.each((e22, n4) => {
            const u4 = t4[n4], o3 = t4[n4 + 1];
            n4 !== 0 && r4.push(oV), r4.push(i3()), PV(u4, o3) ? (r4.push(oV, "..."), bV(u4) && r4.push(" ", i3("trailingComment"))) : o3 && !bV(o3.head) && r4.push(oV, "---");
          }, "children");
          const u3 = DV(e21);
          return SV(u3, ["blockLiteral", "blockFolded"]) && u3.chomping === "keep" || r4.push(oV), r4;
        }
        case "document": {
          const u3 = [];
          return function(e22, t4, n4, r4) {
            if (n4.children[0] === e22 && /---(?:\s|$)/.test(r4.originalText.slice(mV(e22), mV(e22) + 4)) || e22.head.children.length > 0 || AV(e22.head) || bV(e22.head))
              return "head";
            if (PV(e22, t4))
              return false;
            return !!t4 && "root";
          }(e21, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e21.head.children.length > 0 || e21.head.endComments.length > 0) && u3.push(i3("head")), bV(e21.head) ? u3.push(["---", " ", i3(["head", "trailingComment"])]) : u3.push("---")), function(e22) {
            return e22.body.children.length > 0 || AV(e22.body);
          }(e21) && u3.push(i3("body")), sV(oV, u3);
        }
        case "documentHead":
          return sV(oV, [...n3.map(i3, "children"), ...n3.map(i3, "endComments")]);
        case "documentBody": {
          const {children: t4, endComments: r4} = e21;
          let u3 = "";
          if (t4.length > 0 && r4.length > 0) {
            const t5 = DV(e21);
            SV(t5, ["blockFolded", "blockLiteral"]) ? t5.chomping !== "keep" && (u3 = [oV, oV]) : u3 = oV;
          }
          return [sV(oV, n3.map(i3, "children")), u3, sV(oV, n3.map(i3, "endComments"))];
        }
        case "directive":
          return ["%", sV(" ", [e21.name, ...e21.parameters])];
        case "comment":
          return ["#", e21.value];
        case "alias":
          return ["*", e21.value];
        case "tag":
          return r3.originalText.slice(e21.position.start.offset, e21.position.end.offset);
        case "anchor":
          return ["&", e21.value];
        case "plain":
          return OV(e21.type, r3.originalText.slice(e21.position.start.offset, e21.position.end.offset), r3);
        case "quoteDouble":
        case "quoteSingle": {
          const t4 = "'", n4 = '"', i4 = r3.originalText.slice(e21.position.start.offset + 1, e21.position.end.offset - 1);
          if (e21.type === "quoteSingle" && i4.includes("\\") || e21.type === "quoteDouble" && /\\[^"]/.test(i4)) {
            const u4 = e21.type === "quoteDouble" ? n4 : t4;
            return [u4, OV(e21.type, i4, r3), u4];
          }
          if (i4.includes(n4))
            return [t4, OV(e21.type, e21.type === "quoteDouble" ? i4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : i4, r3), t4];
          if (i4.includes(t4))
            return [n4, OV(e21.type, e21.type === "quoteSingle" ? i4.replace(/''/g, t4) : i4, r3), n4];
          const u3 = r3.singleQuote ? t4 : n4;
          return [u3, OV(e21.type, i4, r3), u3];
        }
        case "blockFolded":
        case "blockLiteral":
          return nV(n3, i3, r3);
        case "mapping":
        case "sequence":
          return sV(oV, n3.map(i3, "children"));
        case "sequenceItem":
          return ["- ", wV(2, e21.content ? i3("content") : "")];
        case "mappingKey":
        case "mappingValue":
          return e21.content ? i3("content") : "";
        case "mappingItem":
        case "flowMappingItem":
          return $$(e21, t3, n3, i3, r3);
        case "flowMapping":
          return NV(n3, i3, r3);
        case "flowSequence":
          return kV(n3, i3, r3);
        case "flowSequenceItem":
          return i3("content");
        default:
          throw new Error(`Unexpected node type ${e21.type}`);
      }
    }(r2, a2, e20, t2, n2))), bV(r2) && !SV(r2, ["document", "documentHead"]) && i2.push(cV([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e20.getParentNode(2).type === "mapping" && xV(r2) ? "" : rV, n2("trailingComment")])), BV(r2) && i2.push(wV(r2.type === "sequenceItem" ? 2 : 0, [oV, sV(oV, e20.map((e21) => [dV(t2.originalText, e21.getValue(), mV) ? oV : "", n2()], "endComments"))])), i2.push(s2), i2;
  }, massageAstNode: function(e20, t2) {
    if (SV(t2))
      switch (delete t2.position, t2.type) {
        case "comment":
          if (gV(t2.value))
            return null;
          break;
        case "quoteDouble":
        case "quoteSingle":
          t2.type = "quote";
      }
  }, insertPragma: hV}, LV = {bracketSpacing: WB.bracketSpacing, singleQuote: WB.singleQuote, proseWrap: WB.proseWrap};
  var jV = [YB, nP, fO, OO, cL, RR, {languages: [Xd({name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407}, (e20) => ({since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e20.filenames.filter((e21) => e21 !== "yarn.lock"), ".prettierrc", ".stylelintrc"]}))], printers: {yaml: IV}, options: LV, parsers: void 0}];
  const {version: _V} = e$3, {getSupportInfo: MV} = Qr$2;
  function RV(e20, t2 = 1) {
    return (...n2) => {
      const r2 = n2[t2] || {}, i2 = r2.plugins || [];
      return n2[t2] = Object.assign(Object.assign({}, r2), {}, {plugins: [...jV, ...Array.isArray(i2) ? i2 : Object.values(i2)]}), e20(...n2);
    };
  }
  const $V = RV(vd.formatWithCursor);
  var VV = {formatWithCursor: $V, format: (e20, t2) => $V(e20, t2).formatted, check(e20, t2) {
    const {formatted: n2} = $V(e20, t2);
    return n2 === e20;
  }, doc: eu$1, getSupportInfo: RV(MV, 0), version: _V, util: Hd, __debug: {parse: RV(vd.parse), formatAST: RV(vd.formatAST), formatDoc: RV(vd.formatDoc), printToDoc: RV(vd.printToDoc), printDocToString: RV(vd.printDocToString)}};
  var e$2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t$2(e20) {
    return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
  }
  function s$2(e20) {
    var t2 = {exports: {}};
    return e20(t2, t2.exports), t2.exports;
  }
  var r$2, i$2, a$2 = function(e20) {
    return e20 && e20.Math == Math && e20;
  }, n$2 = a$2(typeof globalThis == "object" && globalThis) || a$2(typeof window == "object" && window) || a$2(typeof self == "object" && self) || a$2(typeof e$2 == "object" && e$2) || function() {
    return this;
  }() || Function("return this")(), o$2 = function(e20) {
    try {
      return !!e20();
    } catch (e21) {
      return true;
    }
  }, u$2 = !o$2(function() {
    return Object.defineProperty({}, 1, {get: function() {
      return 7;
    }})[1] != 7;
  }), h$2 = {}.propertyIsEnumerable, c$2 = Object.getOwnPropertyDescriptor, p$2 = {f: c$2 && !h$2.call({1: 2}, 1) ? function(e20) {
    var t2 = c$2(this, e20);
    return !!t2 && t2.enumerable;
  } : h$2}, l$2 = function(e20, t2) {
    return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
  }, d$2 = {}.toString, D$2 = function(e20) {
    return d$2.call(e20).slice(8, -1);
  }, m$2 = "".split, f$2 = o$2(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e20) {
    return D$2(e20) == "String" ? m$2.call(e20, "") : Object(e20);
  } : Object, y$2 = function(e20) {
    if (e20 == null)
      throw TypeError("Can't call method on " + e20);
    return e20;
  }, A$2 = function(e20) {
    return f$2(y$2(e20));
  }, E$2 = function(e20) {
    return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
  }, C$2 = function(e20) {
    return typeof e20 == "function" ? e20 : void 0;
  }, x$2 = function(e20, t2) {
    return arguments.length < 2 ? C$2(n$2[e20]) : n$2[e20] && n$2[e20][t2];
  }, F$2 = x$2("navigator", "userAgent") || "", g$2 = n$2.process, b$2 = n$2.Deno, P$2 = g$2 && g$2.versions || b$2 && b$2.version, T$2 = P$2 && P$2.v8;
  T$2 ? i$2 = (r$2 = T$2.split("."))[0] < 4 ? 1 : r$2[0] + r$2[1] : F$2 && (!(r$2 = F$2.match(/Edge\/(\d+)/)) || r$2[1] >= 74) && (r$2 = F$2.match(/Chrome\/(\d+)/)) && (i$2 = r$2[1]);
  var w$2 = i$2 && +i$2, S$2 = !!Object.getOwnPropertySymbols && !o$2(function() {
    var e20 = Symbol();
    return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && w$2 && w$2 < 41;
  }), B$2 = S$2 && !Symbol.sham && typeof Symbol.iterator == "symbol", N$2 = B$2 ? function(e20) {
    return typeof e20 == "symbol";
  } : function(e20) {
    var t2 = x$2("Symbol");
    return typeof t2 == "function" && Object(e20) instanceof t2;
  }, I$2 = function(e20, t2) {
    try {
      Object.defineProperty(n$2, e20, {value: t2, configurable: true, writable: true});
    } catch (s2) {
      n$2[e20] = t2;
    }
    return t2;
  }, v$2 = n$2["__core-js_shared__"] || I$2("__core-js_shared__", {}), k$2 = s$2(function(e20) {
    (e20.exports = function(e21, t2) {
      return v$2[e21] || (v$2[e21] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
  }), L$2 = function(e20) {
    return Object(y$2(e20));
  }, O$2 = {}.hasOwnProperty, M$2 = Object.hasOwn || function(e20, t2) {
    return O$2.call(L$2(e20), t2);
  }, R$2 = 0, j$2 = Math.random(), _$2 = function(e20) {
    return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++R$2 + j$2).toString(36);
  }, U$2 = k$2("wks"), q$2 = n$2.Symbol, $$2 = B$2 ? q$2 : q$2 && q$2.withoutSetter || _$2, H$2 = function(e20) {
    return M$2(U$2, e20) && (S$2 || typeof U$2[e20] == "string") || (S$2 && M$2(q$2, e20) ? U$2[e20] = q$2[e20] : U$2[e20] = $$2("Symbol." + e20)), U$2[e20];
  }, V$2 = H$2("toPrimitive"), z$2 = function(e20, t2) {
    if (!E$2(e20) || N$2(e20))
      return e20;
    var s2, r2 = e20[V$2];
    if (r2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), s2 = r2.call(e20, t2), !E$2(s2) || N$2(s2))
        return s2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e21, t3) {
      var s3, r3;
      if (t3 === "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
        return r3;
      if (typeof (s3 = e21.valueOf) == "function" && !E$2(r3 = s3.call(e21)))
        return r3;
      if (t3 !== "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
        return r3;
      throw TypeError("Can't convert object to primitive value");
    }(e20, t2);
  }, W$2 = function(e20) {
    var t2 = z$2(e20, "string");
    return N$2(t2) ? t2 : String(t2);
  }, G$2 = n$2.document, K$2 = E$2(G$2) && E$2(G$2.createElement), X$2 = !u$2 && !o$2(function() {
    return Object.defineProperty((e20 = "div", K$2 ? G$2.createElement(e20) : {}), "a", {get: function() {
      return 7;
    }}).a != 7;
    var e20;
  }), J$2 = Object.getOwnPropertyDescriptor, Y$2 = {f: u$2 ? J$2 : function(e20, t2) {
    if (e20 = A$2(e20), t2 = W$2(t2), X$2)
      try {
        return J$2(e20, t2);
      } catch (e21) {
      }
    if (M$2(e20, t2))
      return l$2(!p$2.f.call(e20, t2), e20[t2]);
  }}, Q$2 = function(e20) {
    if (!E$2(e20))
      throw TypeError(String(e20) + " is not an object");
    return e20;
  }, Z$2 = Object.defineProperty, ee$2 = {f: u$2 ? Z$2 : function(e20, t2, s2) {
    if (Q$2(e20), t2 = W$2(t2), Q$2(s2), X$2)
      try {
        return Z$2(e20, t2, s2);
      } catch (e21) {
      }
    if ("get" in s2 || "set" in s2)
      throw TypeError("Accessors not supported");
    return "value" in s2 && (e20[t2] = s2.value), e20;
  }}, te$2 = u$2 ? function(e20, t2, s2) {
    return ee$2.f(e20, t2, l$2(1, s2));
  } : function(e20, t2, s2) {
    return e20[t2] = s2, e20;
  }, se$2 = Function.toString;
  typeof v$2.inspectSource != "function" && (v$2.inspectSource = function(e20) {
    return se$2.call(e20);
  });
  var re$2, ie$2, ae$2, ne$2, oe$2 = v$2.inspectSource, ue$2 = n$2.WeakMap, he$2 = typeof ue$2 == "function" && /native code/.test(oe$2(ue$2)), ce$2 = k$2("keys"), pe$2 = {}, le$2 = n$2.WeakMap;
  if (he$2 || v$2.state) {
    var de$2 = v$2.state || (v$2.state = new le$2()), De$2 = de$2.get, me$2 = de$2.has, fe$2 = de$2.set;
    re$2 = function(e20, t2) {
      if (me$2.call(de$2, e20))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, fe$2.call(de$2, e20, t2), t2;
    }, ie$2 = function(e20) {
      return De$2.call(de$2, e20) || {};
    }, ae$2 = function(e20) {
      return me$2.call(de$2, e20);
    };
  } else {
    var ye$2 = ce$2[ne$2 = "state"] || (ce$2[ne$2] = _$2(ne$2));
    pe$2[ye$2] = true, re$2 = function(e20, t2) {
      if (M$2(e20, ye$2))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, te$2(e20, ye$2, t2), t2;
    }, ie$2 = function(e20) {
      return M$2(e20, ye$2) ? e20[ye$2] : {};
    }, ae$2 = function(e20) {
      return M$2(e20, ye$2);
    };
  }
  var Ae$2 = {set: re$2, get: ie$2, has: ae$2, enforce: function(e20) {
    return ae$2(e20) ? ie$2(e20) : re$2(e20, {});
  }, getterFor: function(e20) {
    return function(t2) {
      var s2;
      if (!E$2(t2) || (s2 = ie$2(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return s2;
    };
  }}, Ee$2 = s$2(function(e20) {
    var t2 = Ae$2.get, s2 = Ae$2.enforce, r2 = String(String).split("String");
    (e20.exports = function(e21, t3, i2, a2) {
      var o2, u2 = !!a2 && !!a2.unsafe, h2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || M$2(i2, "name") || te$2(i2, "name", t3), (o2 = s2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== n$2 ? (u2 ? !c2 && e21[t3] && (h2 = true) : delete e21[t3], h2 ? e21[t3] = i2 : te$2(e21, t3, i2)) : h2 ? e21[t3] = i2 : I$2(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || oe$2(this);
    });
  }), Ce$2 = Math.ceil, xe$2 = Math.floor, Fe$2 = function(e20) {
    return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? xe$2 : Ce$2)(e20);
  }, ge$2 = Math.min, be$2 = function(e20) {
    return e20 > 0 ? ge$2(Fe$2(e20), 9007199254740991) : 0;
  }, Pe$2 = Math.max, Te$2 = Math.min, we$2 = function(e20) {
    return function(t2, s2, r2) {
      var i2, a2 = A$2(t2), n2 = be$2(a2.length), o2 = function(e21, t3) {
        var s3 = Fe$2(e21);
        return s3 < 0 ? Pe$2(s3 + t3, 0) : Te$2(s3, t3);
      }(r2, n2);
      if (e20 && s2 != s2) {
        for (; n2 > o2; )
          if ((i2 = a2[o2++]) != i2)
            return true;
      } else
        for (; n2 > o2; o2++)
          if ((e20 || o2 in a2) && a2[o2] === s2)
            return e20 || o2 || 0;
      return !e20 && -1;
    };
  }, Se$2 = {includes: we$2(true), indexOf: we$2(false)}.indexOf, Be$2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ne$2 = {f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var s2, r2 = A$2(e21), i2 = 0, a2 = [];
      for (s2 in r2)
        !M$2(pe$2, s2) && M$2(r2, s2) && a2.push(s2);
      for (; t2.length > i2; )
        M$2(r2, s2 = t2[i2++]) && (~Se$2(a2, s2) || a2.push(s2));
      return a2;
    }(e20, Be$2);
  }}, Ie$2 = {f: Object.getOwnPropertySymbols}, ve$2 = x$2("Reflect", "ownKeys") || function(e20) {
    var t2 = Ne$2.f(Q$2(e20)), s2 = Ie$2.f;
    return s2 ? t2.concat(s2(e20)) : t2;
  }, ke$2 = function(e20, t2) {
    for (var s2 = ve$2(t2), r2 = ee$2.f, i2 = Y$2.f, a2 = 0; a2 < s2.length; a2++) {
      var n2 = s2[a2];
      M$2(e20, n2) || r2(e20, n2, i2(t2, n2));
    }
  }, Le$2 = /#|\.prototype\./, Oe$2 = function(e20, t2) {
    var s2 = Re$2[Me$2(e20)];
    return s2 == _e$2 || s2 != je$2 && (typeof t2 == "function" ? o$2(t2) : !!t2);
  }, Me$2 = Oe$2.normalize = function(e20) {
    return String(e20).replace(Le$2, ".").toLowerCase();
  }, Re$2 = Oe$2.data = {}, je$2 = Oe$2.NATIVE = "N", _e$2 = Oe$2.POLYFILL = "P", Ue$2 = Oe$2, qe$2 = Y$2.f, $e$2 = function(e20, t2) {
    var s2, r2, i2, a2, o2, u2 = e20.target, h2 = e20.global, c2 = e20.stat;
    if (s2 = h2 ? n$2 : c2 ? n$2[u2] || I$2(u2, {}) : (n$2[u2] || {}).prototype)
      for (r2 in t2) {
        if (a2 = t2[r2], i2 = e20.noTargetGet ? (o2 = qe$2(s2, r2)) && o2.value : s2[r2], !Ue$2(h2 ? r2 : u2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
          if (typeof a2 == typeof i2)
            continue;
          ke$2(a2, i2);
        }
        (e20.sham || i2 && i2.sham) && te$2(a2, "sham", true), Ee$2(s2, r2, a2, e20);
      }
  }, He$2 = Array.isArray || function(e20) {
    return D$2(e20) == "Array";
  }, Ve$2 = function(e20) {
    if (typeof e20 != "function")
      throw TypeError(String(e20) + " is not a function");
    return e20;
  }, ze$2 = function(e20, t2, s2) {
    if (Ve$2(e20), t2 === void 0)
      return e20;
    switch (s2) {
      case 0:
        return function() {
          return e20.call(t2);
        };
      case 1:
        return function(s3) {
          return e20.call(t2, s3);
        };
      case 2:
        return function(s3, r2) {
          return e20.call(t2, s3, r2);
        };
      case 3:
        return function(s3, r2, i2) {
          return e20.call(t2, s3, r2, i2);
        };
    }
    return function() {
      return e20.apply(t2, arguments);
    };
  }, We$2 = function(e20, t2, s2, r2, i2, a2, n2, o2) {
    for (var u2, h2 = i2, c2 = 0, p2 = !!n2 && ze$2(n2, o2, 3); c2 < r2; ) {
      if (c2 in s2) {
        if (u2 = p2 ? p2(s2[c2], c2, t2) : s2[c2], a2 > 0 && He$2(u2))
          h2 = We$2(e20, t2, u2, be$2(u2.length), h2, a2 - 1) - 1;
        else {
          if (h2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e20[h2] = u2;
        }
        h2++;
      }
      c2++;
    }
    return h2;
  }, Ge$2 = We$2, Ke$2 = H$2("species"), Xe$2 = function(e20, t2) {
    return new (function(e21) {
      var t3;
      return He$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !He$2(t3.prototype) ? E$2(t3) && (t3 = t3[Ke$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e20))(t2 === 0 ? 0 : t2);
  };
  $e$2({target: "Array", proto: true}, {flatMap: function(e20) {
    var t2, s2 = L$2(this), r2 = be$2(s2.length);
    return Ve$2(e20), (t2 = Xe$2(s2, 0)).length = Ge$2(t2, s2, s2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }});
  var Je$2 = function(...e20) {
    let t2;
    for (const [s2, r2] of e20.entries())
      try {
        return {result: r2()};
      } catch (e21) {
        s2 === 0 && (t2 = e21);
      }
    return {error: t2};
  }, Ye$2 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e21 ? void 0 : "g");
  })(), "") : e20;
  const Qe$2 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
  var Ze$2 = Qe$2, et$2 = Qe$2;
  Ze$2.default = et$2;
  const tt$2 = (e20) => {
    if (typeof e20 != "string" || e20.length === 0)
      return 0;
    if ((e20 = Ye$2(e20)).length === 0)
      return 0;
    e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let s2 = 0; s2 < e20.length; s2++) {
      const r2 = e20.codePointAt(s2);
      r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, t2 += Ze$2(r2) ? 2 : 1));
    }
    return t2;
  };
  var st$2 = tt$2, rt$2 = tt$2;
  st$2.default = rt$2;
  var it$2 = (e20) => {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  var at$2 = (e20) => e20[e20.length - 1];
  function nt$2(e20, t2) {
    if (e20 == null)
      return {};
    var s2, r2, i2 = function(e21, t3) {
      if (e21 == null)
        return {};
      var s3, r3, i3 = {}, a3 = Object.keys(e21);
      for (r3 = 0; r3 < a3.length; r3++)
        s3 = a3[r3], t3.indexOf(s3) >= 0 || (i3[s3] = e21[s3]);
      return i3;
    }(e20, t2);
    if (Object.getOwnPropertySymbols) {
      var a2 = Object.getOwnPropertySymbols(e20);
      for (r2 = 0; r2 < a2.length; r2++)
        s2 = a2[r2], t2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, s2) && (i2[s2] = e20[s2]);
    }
    return i2;
  }
  var ot$2, ut$2, ht$2 = function(e20) {
    if (N$2(e20))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e20);
  }, ct$2 = Math.floor, pt$2 = function(e20, t2) {
    var s2 = e20.length, r2 = ct$2(s2 / 2);
    return s2 < 8 ? lt$2(e20, t2) : dt$2(pt$2(e20.slice(0, r2), t2), pt$2(e20.slice(r2), t2), t2);
  }, lt$2 = function(e20, t2) {
    for (var s2, r2, i2 = e20.length, a2 = 1; a2 < i2; ) {
      for (r2 = a2, s2 = e20[a2]; r2 && t2(e20[r2 - 1], s2) > 0; )
        e20[r2] = e20[--r2];
      r2 !== a2++ && (e20[r2] = s2);
    }
    return e20;
  }, dt$2 = function(e20, t2, s2) {
    for (var r2 = e20.length, i2 = t2.length, a2 = 0, n2 = 0, o2 = []; a2 < r2 || n2 < i2; )
      a2 < r2 && n2 < i2 ? o2.push(s2(e20[a2], t2[n2]) <= 0 ? e20[a2++] : t2[n2++]) : o2.push(a2 < r2 ? e20[a2++] : t2[n2++]);
    return o2;
  }, Dt$2 = pt$2, mt$2 = F$2.match(/firefox\/(\d+)/i), ft$2 = !!mt$2 && +mt$2[1], yt$2 = /MSIE|Trident/.test(F$2), At$2 = F$2.match(/AppleWebKit\/(\d+)\./), Et$2 = !!At$2 && +At$2[1], Ct$2 = [], xt$2 = Ct$2.sort, Ft$2 = o$2(function() {
    Ct$2.sort(void 0);
  }), gt$2 = o$2(function() {
    Ct$2.sort(null);
  }), bt$2 = !!(ut$2 = []["sort"]) && o$2(function() {
    ut$2.call(null, ot$2 || function() {
      throw 1;
    }, 1);
  }), Pt$1 = !o$2(function() {
    if (w$2)
      return w$2 < 70;
    if (!(ft$2 && ft$2 > 3)) {
      if (yt$2)
        return true;
      if (Et$2)
        return Et$2 < 603;
      var e20, t2, s2, r2, i2 = "";
      for (e20 = 65; e20 < 76; e20++) {
        switch (t2 = String.fromCharCode(e20), e20) {
          case 66:
          case 69:
          case 70:
          case 72:
            s2 = 3;
            break;
          case 68:
          case 71:
            s2 = 4;
            break;
          default:
            s2 = 2;
        }
        for (r2 = 0; r2 < 47; r2++)
          Ct$2.push({k: t2 + r2, v: s2});
      }
      for (Ct$2.sort(function(e21, t3) {
        return t3.v - e21.v;
      }), r2 = 0; r2 < Ct$2.length; r2++)
        t2 = Ct$2[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  $e$2({target: "Array", proto: true, forced: Ft$2 || !gt$2 || !bt$2 || !Pt$1}, {sort: function(e20) {
    e20 !== void 0 && Ve$2(e20);
    var t2 = L$2(this);
    if (Pt$1)
      return e20 === void 0 ? xt$2.call(t2) : xt$2.call(t2, e20);
    var s2, r2, i2 = [], a2 = be$2(t2.length);
    for (r2 = 0; r2 < a2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (s2 = (i2 = Dt$2(i2, function(e21) {
      return function(t3, s3) {
        return s3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, s3) || 0 : ht$2(t3) > ht$2(s3) ? 1 : -1;
      };
    }(e20))).length, r2 = 0; r2 < s2; )
      t2[r2] = i2[r2++];
    for (; r2 < a2; )
      delete t2[r2++];
    return t2;
  }});
  var Tt$1 = {}, wt$2 = H$2("iterator"), St$1 = Array.prototype, Bt$1 = {};
  Bt$1[H$2("toStringTag")] = "z";
  var Nt$1 = String(Bt$1) === "[object z]", It$1 = H$2("toStringTag"), vt$2 = D$2(function() {
    return arguments;
  }()) == "Arguments", kt$2 = Nt$1 ? D$2 : function(e20) {
    var t2, s2, r2;
    return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (s2 = function(e21, t3) {
      try {
        return e21[t3];
      } catch (e22) {
      }
    }(t2 = Object(e20), It$1)) == "string" ? s2 : vt$2 ? D$2(t2) : (r2 = D$2(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
  }, Lt$1 = H$2("iterator"), Ot$2 = function(e20) {
    if (e20 != null)
      return e20[Lt$1] || e20["@@iterator"] || Tt$1[kt$2(e20)];
  }, Mt$1 = function(e20, t2, s2) {
    var r2, i2;
    Q$2(e20);
    try {
      if ((r2 = e20.return) === void 0) {
        if (t2 === "throw")
          throw s2;
        return s2;
      }
      r2 = r2.call(e20);
    } catch (e21) {
      i2 = true, r2 = e21;
    }
    if (t2 === "throw")
      throw s2;
    if (i2)
      throw r2;
    return Q$2(r2), s2;
  }, Rt$1 = function(e20, t2) {
    this.stopped = e20, this.result = t2;
  }, jt$1 = function(e20, t2, s2) {
    var r2, i2, a2, n2, o2, u2, h2, c2, p2 = s2 && s2.that, l2 = !(!s2 || !s2.AS_ENTRIES), d2 = !(!s2 || !s2.IS_ITERATOR), D2 = !(!s2 || !s2.INTERRUPTED), m2 = ze$2(t2, p2, 1 + l2 + D2), f2 = function(e21) {
      return r2 && Mt$1(r2, "normal", e21), new Rt$1(true, e21);
    }, y2 = function(e21) {
      return l2 ? (Q$2(e21), D2 ? m2(e21[0], e21[1], f2) : m2(e21[0], e21[1])) : D2 ? m2(e21, f2) : m2(e21);
    };
    if (d2)
      r2 = e20;
    else {
      if (typeof (i2 = Ot$2(e20)) != "function")
        throw TypeError("Target is not iterable");
      if ((c2 = i2) !== void 0 && (Tt$1.Array === c2 || St$1[wt$2] === c2)) {
        for (a2 = 0, n2 = be$2(e20.length); n2 > a2; a2++)
          if ((o2 = y2(e20[a2])) && o2 instanceof Rt$1)
            return o2;
        return new Rt$1(false);
      }
      r2 = function(e21, t3) {
        var s3 = arguments.length < 2 ? Ot$2(e21) : t3;
        if (typeof s3 != "function")
          throw TypeError(String(e21) + " is not iterable");
        return Q$2(s3.call(e21));
      }(e20, i2);
    }
    for (u2 = r2.next; !(h2 = u2.call(r2)).done; ) {
      try {
        o2 = y2(h2.value);
      } catch (e21) {
        Mt$1(r2, "throw", e21);
      }
      if (typeof o2 == "object" && o2 && o2 instanceof Rt$1)
        return o2;
    }
    return new Rt$1(false);
  };
  $e$2({target: "Object", stat: true}, {fromEntries: function(e20) {
    var t2 = {};
    return jt$1(e20, function(e21, s2) {
      !function(e22, t3, s3) {
        var r2 = W$2(t3);
        r2 in e22 ? ee$2.f(e22, r2, l$2(0, s3)) : e22[r2] = s3;
      }(t2, e21, s2);
    }, {AS_ENTRIES: true}), t2;
  }});
  var _t$1 = _t$1 !== void 0 ? _t$1 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function Ut$1() {
    throw new Error("setTimeout has not been defined");
  }
  function qt$1() {
    throw new Error("clearTimeout has not been defined");
  }
  var $t$1 = Ut$1, Ht$1 = qt$1;
  function Vt$1(e20) {
    if ($t$1 === setTimeout)
      return setTimeout(e20, 0);
    if (($t$1 === Ut$1 || !$t$1) && setTimeout)
      return $t$1 = setTimeout, setTimeout(e20, 0);
    try {
      return $t$1(e20, 0);
    } catch (t2) {
      try {
        return $t$1.call(null, e20, 0);
      } catch (t3) {
        return $t$1.call(this, e20, 0);
      }
    }
  }
  typeof _t$1.setTimeout == "function" && ($t$1 = setTimeout), typeof _t$1.clearTimeout == "function" && (Ht$1 = clearTimeout);
  var zt$1, Wt$1 = [], Gt$1 = false, Kt$1 = -1;
  function Xt$1() {
    Gt$1 && zt$1 && (Gt$1 = false, zt$1.length ? Wt$1 = zt$1.concat(Wt$1) : Kt$1 = -1, Wt$1.length && Jt$1());
  }
  function Jt$1() {
    if (!Gt$1) {
      var e20 = Vt$1(Xt$1);
      Gt$1 = true;
      for (var t2 = Wt$1.length; t2; ) {
        for (zt$1 = Wt$1, Wt$1 = []; ++Kt$1 < t2; )
          zt$1 && zt$1[Kt$1].run();
        Kt$1 = -1, t2 = Wt$1.length;
      }
      zt$1 = null, Gt$1 = false, function(e21) {
        if (Ht$1 === clearTimeout)
          return clearTimeout(e21);
        if ((Ht$1 === qt$1 || !Ht$1) && clearTimeout)
          return Ht$1 = clearTimeout, clearTimeout(e21);
        try {
          Ht$1(e21);
        } catch (t3) {
          try {
            return Ht$1.call(null, e21);
          } catch (t4) {
            return Ht$1.call(this, e21);
          }
        }
      }(e20);
    }
  }
  function Yt$1(e20, t2) {
    this.fun = e20, this.array = t2;
  }
  Yt$1.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function Qt$1() {
  }
  var Zt$1 = Qt$1, es$1 = Qt$1, ts$1 = Qt$1, ss$1 = Qt$1, rs$1 = Qt$1, is$1 = Qt$1, as$1 = Qt$1;
  var ns$1 = _t$1.performance || {}, os$1 = ns$1.now || ns$1.mozNow || ns$1.msNow || ns$1.oNow || ns$1.webkitNow || function() {
    return new Date().getTime();
  };
  var us$1 = new Date();
  var hs$1 = {nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var s2 = 1; s2 < arguments.length; s2++)
        t2[s2 - 1] = arguments[s2];
    Wt$1.push(new Yt$1(e20, t2)), Wt$1.length !== 1 || Gt$1 || Vt$1(Jt$1);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Zt$1, addListener: es$1, once: ts$1, off: ss$1, removeListener: rs$1, removeAllListeners: is$1, emit: as$1, binding: function(e20) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e20) {
    var t2 = 1e-3 * os$1.call(ns$1), s2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (s2 -= e20[0], (r2 -= e20[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - us$1) / 1e3;
  }};
  var cs$1 = typeof hs$1 == "object" && hs$1.env && hs$1.env.NODE_DEBUG && /\bsemver\b/i.test(hs$1.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
  };
  var ps$1 = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, ls$1 = s$2(function(e20, t2) {
    const {MAX_SAFE_COMPONENT_LENGTH: s2} = ps$1, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], a2 = t2.t = {};
    let n2 = 0;
    const o2 = (e21, t3, s3) => {
      const o3 = n2++;
      cs$1(o3, t3), a2[e21] = o3, i2[o3] = t3, r2[o3] = new RegExp(t3, s3 ? "g" : void 0);
    };
    o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", `(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})`), o2("MAINVERSIONLOOSE", `(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})`), o2("PRERELEASEIDENTIFIER", `(?:${i2[a2.NUMERICIDENTIFIER]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[a2.NUMERICIDENTIFIERLOOSE]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASE", `(?:-(${i2[a2.PRERELEASEIDENTIFIER]}(?:\\.${i2[a2.PRERELEASEIDENTIFIER]})*))`), o2("PRERELEASELOOSE", `(?:-?(${i2[a2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[a2.PRERELEASEIDENTIFIERLOOSE]})*))`), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", `(?:\\+(${i2[a2.BUILDIDENTIFIER]}(?:\\.${i2[a2.BUILDIDENTIFIER]})*))`), o2("FULLPLAIN", `v?${i2[a2.MAINVERSION]}${i2[a2.PRERELEASE]}?${i2[a2.BUILD]}?`), o2("FULL", `^${i2[a2.FULLPLAIN]}$`), o2("LOOSEPLAIN", `[v=\\s]*${i2[a2.MAINVERSIONLOOSE]}${i2[a2.PRERELEASELOOSE]}?${i2[a2.BUILD]}?`), o2("LOOSE", `^${i2[a2.LOOSEPLAIN]}$`), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", `${i2[a2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), o2("XRANGEIDENTIFIER", `${i2[a2.NUMERICIDENTIFIER]}|x|X|\\*`), o2("XRANGEPLAIN", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:${i2[a2.PRERELEASE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:${i2[a2.PRERELEASELOOSE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAIN]}$`), o2("XRANGELOOSE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COERCE", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?(?:$|[^\\d])`), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", `(\\s*)${i2[a2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", o2("TILDE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAIN]}$`), o2("TILDELOOSE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", `(\\s*)${i2[a2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", o2("CARET", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAIN]}$`), o2("CARETLOOSE", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COMPARATORLOOSE", `^${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]})$|^$`), o2("COMPARATOR", `^${i2[a2.GTLT]}\\s*(${i2[a2.FULLPLAIN]})$|^$`), o2("COMPARATORTRIM", `(\\s*)${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]}|${i2[a2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", `^\\s*(${i2[a2.XRANGEPLAIN]})\\s+-\\s+(${i2[a2.XRANGEPLAIN]})\\s*$`), o2("HYPHENRANGELOOSE", `^\\s*(${i2[a2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[a2.XRANGEPLAINLOOSE]})\\s*$`), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const ds$1 = ["includePrerelease", "loose", "rtl"];
  var Ds$1 = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : ds$1.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
  const ms$1 = /^[0-9]+$/, fs$1 = (e20, t2) => {
    const s2 = ms$1.test(e20), r2 = ms$1.test(t2);
    return s2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : e20 < t2 ? -1 : 1;
  };
  var ys$1 = {compareIdentifiers: fs$1, rcompareIdentifiers: (e20, t2) => fs$1(t2, e20)};
  const {MAX_LENGTH: As$1, MAX_SAFE_INTEGER: Es$1} = ps$1, {re: Cs$1, t: xs$1} = ls$1, {compareIdentifiers: Fs$1} = ys$1;
  class gs$1 {
    constructor(e20, t2) {
      if (t2 = Ds$1(t2), e20 instanceof gs$1) {
        if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
          return e20;
        e20 = e20.version;
      } else if (typeof e20 != "string")
        throw new TypeError(`Invalid Version: ${e20}`);
      if (e20.length > As$1)
        throw new TypeError(`version is longer than ${As$1} characters`);
      cs$1("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const s2 = e20.trim().match(t2.loose ? Cs$1[xs$1.LOOSE] : Cs$1[xs$1.FULL]);
      if (!s2)
        throw new TypeError(`Invalid Version: ${e20}`);
      if (this.raw = e20, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Es$1 || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > Es$1 || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > Es$1 || this.patch < 0)
        throw new TypeError("Invalid patch version");
      s2[4] ? this.prerelease = s2[4].split(".").map((e21) => {
        if (/^[0-9]+$/.test(e21)) {
          const t3 = +e21;
          if (t3 >= 0 && t3 < Es$1)
            return t3;
        }
        return e21;
      }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e20) {
      if (cs$1("SemVer.compare", this.version, this.options, e20), !(e20 instanceof gs$1)) {
        if (typeof e20 == "string" && e20 === this.version)
          return 0;
        e20 = new gs$1(e20, this.options);
      }
      return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
    }
    compareMain(e20) {
      return e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), Fs$1(this.major, e20.major) || Fs$1(this.minor, e20.minor) || Fs$1(this.patch, e20.patch);
    }
    comparePre(e20) {
      if (e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
        return -1;
      if (!this.prerelease.length && e20.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e20.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const s2 = this.prerelease[t2], r2 = e20.prerelease[t2];
        if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (s2 === void 0)
          return -1;
        if (s2 !== r2)
          return Fs$1(s2, r2);
      } while (++t2);
    }
    compareBuild(e20) {
      e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options));
      let t2 = 0;
      do {
        const s2 = this.build[t2], r2 = e20.build[t2];
        if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
          return 0;
        if (r2 === void 0)
          return 1;
        if (s2 === void 0)
          return -1;
        if (s2 !== r2)
          return Fs$1(s2, r2);
      } while (++t2);
    }
    inc(e20, t2) {
      switch (e20) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e21 = this.prerelease.length;
            for (; --e21 >= 0; )
              typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
            e21 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e20}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var bs$1 = gs$1;
  var Ps$1 = (e20, t2, s2) => new bs$1(e20, s2).compare(new bs$1(t2, s2));
  var Ts$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) < 0;
  var ws$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) >= 0, Ss$1 = s$2(function(e20, t2) {
    function s2() {
      for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
        e21[t3] = arguments[t3];
    }
    function r2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : {add: s2, delete: s2, get: s2, set: s2, has: function(e21) {
        return false;
      }};
    }
    Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, a2 = function(e21, t3) {
      return i2.call(e21, t3);
    };
    function n2(e21, t3) {
      for (var s3 in t3)
        a2(t3, s3) && (e21[s3] = t3[s3]);
      return e21;
    }
    var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function l2(e21, t3, s3) {
      var r3 = 0, i3 = e21[0].match(c2);
      i3 && (r3 = i3[1].length);
      var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
      t3 && (e21 = e21.slice(1));
      var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = e21.length;
      return e21.map(function(e22, t4) {
        return e22 = e22.replace(a3, "$1"), t4 === 0 && h3 && (e22 = e22.replace(o2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(u2, "")), l3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
          return n3;
        })), e22;
      });
    }
    function d2(e21, t3) {
      for (var s3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
        s3 += e21[r3], r3 < i3 - 1 && (s3 += t3[r3]);
      return s3;
    }
    function D2(e21) {
      return a2(e21, "raw") && a2(e21, "length");
    }
    var m2 = function e21(t3) {
      var s3 = r2(), i3 = r2();
      return n2(function r3(a3) {
        for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
          o3[u3 - 1] = arguments[u3];
        if (D2(a3)) {
          var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
          if (A2 || (A2 = l2(c3, f2, t3), y2.set(c3, A2)), o3.length === 0)
            return A2[0];
          var E2 = d2(A2, f2 ? o3.slice(1) : o3);
          return E2;
        }
        return e21(n2(n2({}, t3), a3 || {}));
      }, {string: function(e22) {
        return l2([e22], false, t3)[0];
      }});
    }({trimLeadingNewline: true, trimTrailingNewline: true});
    t2.outdent = m2, t2.default = m2;
    try {
      e20.exports = m2, Object.defineProperty(m2, "__esModule", {value: true}), m2.default = m2, m2.outdent = m2;
    } catch (e21) {
    }
  });
  const {outdent: Bs$1} = Ss$1, Ns$1 = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Bs$1`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Bs$1`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Bs$1`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Bs$1`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
  const Is$1 = ["cliName", "cliCategory", "cliDescription"], vs$1 = {compare: Ps$1, lt: Ts$1, gte: ws$1}, ks$1 = "2.4.1", Ls$1 = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Ns$1}.options;
  var Os$1 = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: s2 = false, showInternal: r2 = false} = {}) {
    const i2 = ks$1.split("-", 1)[0], a2 = e20.flatMap((e21) => e21.languages || []).filter(h2), n2 = (o2 = Object.assign({}, ...e20.map(({options: e21}) => e21), Ls$1), u2 = "name", Object.entries(o2).map(([e21, t3]) => Object.assign({[u2]: e21}, t3))).filter((e21) => h2(e21) && c2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (r2)
        return e21;
      return nt$2(e21, Is$1);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(h2).sort((e21, t4) => vs$1.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => h2(e21) && c2(e21)), t3.name === "parser" && function(e21, t4, s4) {
        const r3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const a3 = s4.find((e22) => e22.parsers && e22.parsers[t5]);
                let n3 = i3.name;
                a3 && a3.name && (n3 += ` (plugin: ${a3.name})`), e21.choices.push({value: t5, description: n3});
              }
          }
      }(t3, a2, e20));
      const s3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: s3});
    });
    var o2, u2;
    return {languages: a2, options: n2};
    function h2(e21) {
      return t2 || !("since" in e21) || e21.since && vs$1.gte(i2, e21.since);
    }
    function c2(e21) {
      return s2 || !("deprecated" in e21) || e21.deprecated && vs$1.lt(i2, e21.deprecated);
    }
  }};
  const {getSupportInfo: Ms$1} = Os$1, Rs$1 = /[^\x20-\x7F]/;
  function js$1(e20) {
    return (t2, s2, r2) => {
      const i2 = r2 && r2.backwards;
      if (s2 === false)
        return false;
      const {length: a2} = t2;
      let n2 = s2;
      for (; n2 >= 0 && n2 < a2; ) {
        const s3 = t2.charAt(n2);
        if (e20 instanceof RegExp) {
          if (!e20.test(s3))
            return n2;
        } else if (!e20.includes(s3))
          return n2;
        i2 ? n2-- : n2++;
      }
      return (n2 === -1 || n2 === a2) && n2;
    };
  }
  const _s$1 = js$1(/\s/), Us$1 = js$1(" 	"), qs$1 = js$1(",; 	"), $s$1 = js$1(/[^\n\r]/);
  function Hs$1(e20, t2) {
    if (t2 === false)
      return false;
    if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
      for (let s2 = t2 + 2; s2 < e20.length; ++s2)
        if (e20.charAt(s2) === "*" && e20.charAt(s2 + 1) === "/")
          return s2 + 2;
    }
    return t2;
  }
  function Vs$1(e20, t2) {
    return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? $s$1(e20, t2) : t2);
  }
  function zs$1(e20, t2, s2) {
    const r2 = s2 && s2.backwards;
    if (t2 === false)
      return false;
    const i2 = e20.charAt(t2);
    if (r2) {
      if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function Ws$1(e20, t2, s2 = {}) {
    const r2 = Us$1(e20, s2.backwards ? t2 - 1 : t2, s2);
    return r2 !== zs$1(e20, r2, s2);
  }
  function Gs$1(e20, t2) {
    let s2 = null, r2 = t2;
    for (; r2 !== s2; )
      s2 = r2, r2 = qs$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Us$1(e20, r2);
    return r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2), r2 !== false && Ws$1(e20, r2);
  }
  function Ks$1(e20, t2) {
    let s2 = null, r2 = t2;
    for (; r2 !== s2; )
      s2 = r2, r2 = Us$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2);
    return r2;
  }
  function Xs$1(e20, t2, s2) {
    return Ks$1(e20, s2(t2));
  }
  function Js$1(e20, t2, s2 = 0) {
    let r2 = 0;
    for (let i2 = s2; i2 < e20.length; ++i2)
      e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
    return r2;
  }
  function Ys$1(e20, t2) {
    const s2 = e20.slice(1, -1), r2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, a2 = t2 === "'" ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
    let o2 = a2.quote;
    if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
      o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
    }
    return o2;
  }
  function Qs$1(e20, t2, s2) {
    const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, a2) => i3 === r2 ? i3 : a2 === t2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function Zs$1(e20, t2) {
    (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
      const t3 = e21.type || e21.kind || "(unknown type)";
      let s2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
      s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
      return t3 + (s2 ? " " + s2 : "");
    }(e20);
  }
  var er$1, tr$1 = {inferParserByLanguage: function(e20, t2) {
    const {languages: s2} = Ms$1({plugins: t2.plugins}), r2 = s2.find(({name: t3}) => t3.toLowerCase() === e20) || s2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || s2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return r2 && r2.parsers[0];
  }, getStringWidth: function(e20) {
    return e20 ? Rs$1.test(e20) ? st$2(e20) : e20.length : 0;
  }, getMaxContinuousCount: function(e20, t2) {
    const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
    return s2 === null ? 0 : s2.reduce((e21, s3) => Math.max(e21, s3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e20, t2) {
    const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
    if (s2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e21 of s2) {
      const s3 = e21.length / t2.length;
      r2.set(s3, true), s3 > i2 && (i2 = s3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!r2.get(e21))
        return e21;
    return i2 + 1;
  }, getPenultimate: (e20) => e20[e20.length - 2], getLast: at$2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ks$1, getNextNonSpaceNonCommentCharacterIndex: Xs$1, getNextNonSpaceNonCommentCharacter: function(e20, t2, s2) {
    return e20.charAt(Xs$1(e20, t2, s2));
  }, skip: js$1, skipWhitespace: _s$1, skipSpaces: Us$1, skipToLineEnd: qs$1, skipEverythingButNewLine: $s$1, skipInlineComment: Hs$1, skipTrailingComment: Vs$1, skipNewline: zs$1, isNextLineEmptyAfterIndex: Gs$1, isNextLineEmpty: function(e20, t2, s2) {
    return Gs$1(e20, s2(t2));
  }, isPreviousLineEmpty: function(e20, t2, s2) {
    let r2 = s2(t2) - 1;
    return r2 = Us$1(e20, r2, {backwards: true}), r2 = zs$1(e20, r2, {backwards: true}), r2 = Us$1(e20, r2, {backwards: true}), r2 !== zs$1(e20, r2, {backwards: true});
  }, hasNewline: Ws$1, hasNewlineInRange: function(e20, t2, s2) {
    for (let r2 = t2; r2 < s2; ++r2)
      if (e20.charAt(r2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e20, t2, s2 = {}) {
    return Us$1(e20, s2.backwards ? t2 - 1 : t2, s2) !== t2;
  }, getAlignmentSize: Js$1, getIndentSize: function(e20, t2) {
    const s2 = e20.lastIndexOf("\n");
    return s2 === -1 ? 0 : Js$1(e20.slice(s2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: Ys$1, printString: function(e20, t2) {
    return Qs$1(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Ys$1(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: Qs$1, addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, Zs$1(e20, t2);
  }, addDanglingComment: function(e20, t2, s2) {
    t2.leading = false, t2.trailing = false, s2 && (t2.marker = s2), Zs$1(e20, t2);
  }, addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, Zs$1(e20, t2);
  }, isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  }, getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  }, isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  }, createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(s2) {
      return t2.has(s2) || t2.set(s2, Symbol(e20)), t2.get(s2);
    };
  }};
  function sr$1() {
    if (er$1 === void 0) {
      var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), s2 = new Uint16Array(e20);
      if (t2[0] = 1, t2[1] = 2, s2[0] === 258)
        er$1 = "BE";
      else {
        if (s2[0] !== 513)
          throw new Error("unable to figure out endianess");
        er$1 = "LE";
      }
    }
    return er$1;
  }
  function rr$1() {
    return _t$1.location !== void 0 ? _t$1.location.hostname : "";
  }
  function ir$1() {
    return [];
  }
  function ar$1() {
    return 0;
  }
  function nr$1() {
    return Number.MAX_VALUE;
  }
  function or$1() {
    return Number.MAX_VALUE;
  }
  function ur$1() {
    return [];
  }
  function hr$1() {
    return "Browser";
  }
  function cr$1() {
    return _t$1.navigator !== void 0 ? _t$1.navigator.appVersion : "";
  }
  function pr$1() {
  }
  function lr$1() {
  }
  function dr$1() {
    return "javascript";
  }
  function Dr$1() {
    return "browser";
  }
  function mr$1() {
    return "/tmp";
  }
  var fr$1 = mr$1, yr$1 = {EOL: "\n", arch: dr$1, platform: Dr$1, tmpdir: fr$1, tmpDir: mr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, release: cr$1, type: hr$1, cpus: ur$1, totalmem: or$1, freemem: nr$1, uptime: ar$1, loadavg: ir$1, hostname: rr$1, endianness: sr$1}, Ar$1 = Object.freeze({__proto__: null, endianness: sr$1, hostname: rr$1, loadavg: ir$1, uptime: ar$1, freemem: nr$1, totalmem: or$1, cpus: ur$1, type: hr$1, release: cr$1, networkInterfaces: pr$1, getNetworkInterfaces: lr$1, arch: dr$1, platform: Dr$1, tmpDir: mr$1, tmpdir: fr$1, EOL: "\n", default: yr$1});
  const Er$1 = (e20) => {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    const t2 = e20.match(/(?:\r?\n)/g) || [];
    if (t2.length === 0)
      return;
    const s2 = t2.filter((e21) => e21 === "\r\n").length;
    return s2 > t2.length - s2 ? "\r\n" : "\n";
  };
  var Cr$1 = Er$1;
  Cr$1.graceful = (e20) => typeof e20 == "string" && Er$1(e20) || "\n";
  var xr$1 = t$2(Ar$1), Fr$1 = function(e20) {
    const t2 = e20.match(Ir$1);
    return t2 ? t2[0].trimLeft() : "";
  }, gr$1 = function(e20) {
    const t2 = e20.match(Ir$1);
    return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
  }, br$1 = function(e20) {
    return jr$1(e20).pragmas;
  }, Pr$1 = jr$1, Tr$1 = function({comments: e20 = "", pragmas: t2 = {}}) {
    const s2 = (0, Sr$1().default)(e20) || wr$1().EOL, r2 = " *", i2 = Object.keys(t2), a2 = i2.map((e21) => _r$1(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + s2).join("");
    if (!e20) {
      if (i2.length === 0)
        return "";
      if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
        const e21 = t2[i2[0]];
        return `/** ${_r$1(i2[0], e21)[0]} */`;
      }
    }
    const n2 = e20.split(s2).map((e21) => ` * ${e21}`).join(s2) + s2;
    return "/**" + s2 + (e20 ? n2 : "") + (e20 && i2.length ? r2 + s2 : "") + a2 + " */";
  };
  function wr$1() {
    const e20 = xr$1;
    return wr$1 = function() {
      return e20;
    }, e20;
  }
  function Sr$1() {
    const e20 = (t2 = Cr$1) && t2.__esModule ? t2 : {default: t2};
    var t2;
    return Sr$1 = function() {
      return e20;
    }, e20;
  }
  const Br$1 = /\*\/$/, Nr$1 = /^\/\*\*/, Ir$1 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vr$1 = /(^|\s+)\/\/([^\r\n]*)/g, kr$1 = /^(\r?\n)+/, Lr$1 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Or$1 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Mr$1 = /(\r?\n|^) *\* ?/g, Rr$1 = [];
  function jr$1(e20) {
    const t2 = (0, Sr$1().default)(e20) || wr$1().EOL;
    e20 = e20.replace(Nr$1, "").replace(Br$1, "").replace(Mr$1, "$1");
    let s2 = "";
    for (; s2 !== e20; )
      s2 = e20, e20 = e20.replace(Lr$1, `${t2}$1 $2${t2}`);
    e20 = e20.replace(kr$1, "").trimRight();
    const r2 = Object.create(null), i2 = e20.replace(Or$1, "").replace(kr$1, "").trimRight();
    let a2;
    for (; a2 = Or$1.exec(e20); ) {
      const e21 = a2[2].replace(vr$1, "");
      typeof r2[a2[1]] == "string" || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = Rr$1.concat(r2[a2[1]], e21) : r2[a2[1]] = e21;
    }
    return {comments: i2, pragmas: r2};
  }
  function _r$1(e20, t2) {
    return Rr$1.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
  }
  var Ur$1 = Object.defineProperty({extract: Fr$1, strip: gr$1, parse: br$1, parseWithComments: Pr$1, print: Tr$1}, "__esModule", {value: true});
  var qr$1 = {guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e20, t2) {
    let s2;
    if (t2 === "\n")
      s2 = /\n/g;
    else if (t2 === "\r")
      s2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      s2 = /\r\n/g;
    }
    const r2 = e20.match(s2);
    return r2 ? r2.length : 0;
  }, normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }};
  const {parseWithComments: $r$1, strip: Hr$1, extract: Vr$1, print: zr$1} = Ur$1, {getShebang: Wr$1} = tr$1, {normalizeEndOfLine: Gr$1} = qr$1;
  function Kr$1(e20) {
    const t2 = Wr$1(e20);
    t2 && (e20 = e20.slice(t2.length + 1));
    const s2 = Vr$1(e20), {pragmas: r2, comments: i2} = $r$1(s2);
    return {shebang: t2, text: e20, pragmas: r2, comments: i2};
  }
  var Xr$1 = {hasPragma: function(e20) {
    const t2 = Object.keys(Kr$1(e20).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  }, insertPragma: function(e20) {
    const {shebang: t2, text: s2, pragmas: r2, comments: i2} = Kr$1(e20), a2 = Hr$1(s2), n2 = zr$1({pragmas: Object.assign({format: ""}, r2), comments: i2.trimStart()});
    return (t2 ? `${t2}
` : "") + Gr$1(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
  }};
  const {isNonEmptyArray: Jr$1} = tr$1;
  function Yr$1(e20, t2) {
    const {ignoreDecorators: s2} = t2 || {};
    if (!s2) {
      const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
      if (Jr$1(t3))
        return Yr$1(t3[0]);
    }
    return e20.range ? e20.range[0] : e20.start;
  }
  function Qr$1(e20) {
    return e20.range ? e20.range[1] : e20.end;
  }
  function Zr$1(e20, t2) {
    return Yr$1(e20) === Yr$1(t2);
  }
  var ei$1 = {locStart: Yr$1, locEnd: Qr$1, hasSameLocStart: Zr$1, hasSameLoc: function(e20, t2) {
    return Zr$1(e20, t2) && function(e21, t3) {
      return Qr$1(e21) === Qr$1(t3);
    }(e20, t2);
  }};
  const {hasPragma: ti$1} = Xr$1, {locStart: si$1, locEnd: ri$1} = ei$1;
  var ii$1 = function(e20) {
    return e20 = typeof e20 == "function" ? {parse: e20} : e20, Object.assign({astFormat: "estree", hasPragma: ti$1, locStart: si$1, locEnd: ri$1}, e20);
  };
  var ai$1 = function(e20, t2) {
    const s2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
    return s2.loc = t2, s2;
  };
  var ni$1 = function(e20) {
    const {message: t2, loc: s2} = e20;
    return ai$1(t2.replace(/ \(.*\)/, ""), {start: {line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0}});
  }, oi$1 = s$2(function(e20) {
    !function() {
      function t2(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function s2(e21) {
        switch (e21.type) {
          case "IfStatement":
            return e21.alternate != null ? e21.alternate : e21.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return e21.body;
        }
        return null;
      }
      e20.exports = {isExpression: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }, isStatement: t2, isIterationStatement: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }, isSourceElement: function(e21) {
        return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
      }, isProblematicIfStatement: function(e21) {
        var t3;
        if (e21.type !== "IfStatement")
          return false;
        if (e21.alternate == null)
          return false;
        t3 = e21.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = s2(t3);
        } while (t3);
        return false;
      }, trailingStatement: s2};
    }();
  }), ui$1 = s$2(function(e20) {
    !function() {
      var t2, s2, r2, i2, a2, n2;
      function o2(e21) {
        return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
      }
      for (s2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/}, t2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
        i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
      for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
        a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
      e20.exports = {isDecimalDigit: function(e21) {
        return 48 <= e21 && e21 <= 57;
      }, isHexDigit: function(e21) {
        return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
      }, isOctalDigit: function(e21) {
        return e21 >= 48 && e21 <= 55;
      }, isWhiteSpace: function(e21) {
        return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
      }, isLineTerminator: function(e21) {
        return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
      }, isIdentifierStartES5: function(e21) {
        return e21 < 128 ? i2[e21] : s2.NonAsciiIdentifierStart.test(o2(e21));
      }, isIdentifierPartES5: function(e21) {
        return e21 < 128 ? a2[e21] : s2.NonAsciiIdentifierPart.test(o2(e21));
      }, isIdentifierStartES6: function(e21) {
        return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(o2(e21));
      }, isIdentifierPartES6: function(e21) {
        return e21 < 128 ? a2[e21] : t2.NonAsciiIdentifierPart.test(o2(e21));
      }};
    }();
  }), hi$1 = s$2(function(e20) {
    !function() {
      var t2 = ui$1;
      function s2(e21, t3) {
        return !(!t3 && e21 === "yield") && r2(e21, t3);
      }
      function r2(e21, t3) {
        if (t3 && function(e22) {
          switch (e22) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "let":
              return true;
            default:
              return false;
          }
        }(e21))
          return true;
        switch (e21.length) {
          case 2:
            return e21 === "if" || e21 === "in" || e21 === "do";
          case 3:
            return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
          case 4:
            return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
          case 5:
            return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
          case 6:
            return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
          case 7:
            return e21 === "default" || e21 === "finally" || e21 === "extends";
          case 8:
            return e21 === "function" || e21 === "continue" || e21 === "debugger";
          case 10:
            return e21 === "instanceof";
          default:
            return false;
        }
      }
      function i2(e21, t3) {
        return e21 === "null" || e21 === "true" || e21 === "false" || s2(e21, t3);
      }
      function a2(e21, t3) {
        return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
      }
      function n2(e21) {
        var s3, r3, i3;
        if (e21.length === 0)
          return false;
        if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
          return false;
        for (s3 = 1, r3 = e21.length; s3 < r3; ++s3)
          if (i3 = e21.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
            return false;
        return true;
      }
      function o2(e21) {
        var s3, r3, i3, a3, n3;
        if (e21.length === 0)
          return false;
        for (n3 = t2.isIdentifierStartES6, s3 = 0, r3 = e21.length; s3 < r3; ++s3) {
          if (55296 <= (i3 = e21.charCodeAt(s3)) && i3 <= 56319) {
            if (++s3 >= r3)
              return false;
            if (!(56320 <= (a3 = e21.charCodeAt(s3)) && a3 <= 57343))
              return false;
            i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
          }
          if (!n3(i3))
            return false;
          n3 = t2.isIdentifierPartES6;
        }
        return true;
      }
      e20.exports = {isKeywordES5: s2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: a2, isRestrictedWord: function(e21) {
        return e21 === "eval" || e21 === "arguments";
      }, isIdentifierNameES5: n2, isIdentifierNameES6: o2, isIdentifierES5: function(e21, t3) {
        return n2(e21) && !i2(e21, t3);
      }, isIdentifierES6: function(e21, t3) {
        return o2(e21) && !a2(e21, t3);
      }};
    }();
  });
  const ci$1 = s$2(function(e20, t2) {
    t2.ast = oi$1, t2.code = ui$1, t2.keyword = hi$1;
  }).keyword.isIdentifierNameES5, {getLast: pi$1, hasNewline: li$1, skipWhitespace: di$1, isNonEmptyArray: Di$1, isNextLineEmptyAfterIndex: mi$1, getStringWidth: fi$1} = tr$1, {locStart: yi$1, locEnd: Ai$1, hasSameLocStart: Ei$1} = ei$1, Ci$1 = new RegExp("^(?:(?=.)\\s)*:"), xi$1 = new RegExp("^(?:(?=.)\\s)*::");
  function Fi$1(e20) {
    return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
  }
  function gi$1(e20) {
    return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
  }
  const bi$1 = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function Pi$1(e20) {
    return e20 && bi$1.has(e20.type);
  }
  function Ti$1(e20) {
    return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
  }
  function wi$1(e20) {
    return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
  }
  function Si$1(e20) {
    return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
  }
  function Bi$1(e20) {
    return Mi$1(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
  }
  function Ni$1(e20) {
    return e20.type === "JSXElement" || e20.type === "JSXFragment";
  }
  function Ii$1(e20) {
    return e20.kind === "get" || e20.kind === "set";
  }
  function vi$1(e20) {
    return Ii$1(e20) || Ei$1(e20, e20.value);
  }
  const ki$1 = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  const Li$1 = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  const Oi$1 = /^(?:skip|[fx]?(?:it|describe|test))$/;
  function Mi$1(e20) {
    return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
  }
  function Ri$1(e20) {
    return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
  }
  function ji$1(e20) {
    return /^(?:\d+|\d+\.\d+)$/.test(e20);
  }
  function _i$1(e20) {
    return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
  }
  function Ui$1(e20) {
    return e20.extra ? e20.extra.raw : e20.raw;
  }
  const qi$1 = {"==": true, "!=": true, "===": true, "!==": true}, $i$1 = {"*": true, "/": true, "%": true}, Hi$1 = {">>": true, ">>>": true, "<<": true};
  const Vi$1 = {};
  for (const [e20, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
    for (const s2 of t2)
      Vi$1[s2] = e20;
  function zi$1(e20) {
    return Vi$1[e20];
  }
  const Wi$1 = new WeakMap();
  function Gi$1(e20) {
    if (Wi$1.has(e20))
      return Wi$1.get(e20);
    const t2 = [];
    return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Wi$1.set(e20, t2), t2;
  }
  const Ki$1 = new WeakMap();
  function Xi$1(e20) {
    if (Ki$1.has(e20))
      return Ki$1.get(e20);
    let t2 = e20.arguments;
    return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), Ki$1.set(e20, t2), t2;
  }
  function Ji$1(e20) {
    return e20.value.trim() === "prettier-ignore" && !e20.unignore;
  }
  function Yi$1(e20) {
    return e20 && (e20.prettierIgnore || ea(e20, Qi$1.PrettierIgnore));
  }
  const Qi$1 = {Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256}, Zi$1 = (e20, t2) => {
    if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
      return (s2, r2, i2) => !(e20 & Qi$1.Leading && !s2.leading || e20 & Qi$1.Trailing && !s2.trailing || e20 & Qi$1.Dangling && (s2.leading || s2.trailing) || e20 & Qi$1.Block && !Fi$1(s2) || e20 & Qi$1.Line && !gi$1(s2) || e20 & Qi$1.First && r2 !== 0 || e20 & Qi$1.Last && r2 !== i2.length - 1 || e20 & Qi$1.PrettierIgnore && !Ji$1(s2) || t2 && !t2(s2));
  };
  function ea(e20, t2, s2) {
    if (!e20 || !Di$1(e20.comments))
      return false;
    const r2 = Zi$1(t2, s2);
    return !r2 || e20.comments.some(r2);
  }
  function ta(e20, t2, s2) {
    if (!e20 || !Array.isArray(e20.comments))
      return [];
    const r2 = Zi$1(t2, s2);
    return r2 ? e20.comments.filter(r2) : e20.comments;
  }
  function sa(e20) {
    return Mi$1(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
  }
  var ra = {getFunctionParameters: Gi$1, iterateFunctionParametersPath: function(e20, t2) {
    const s2 = e20.getValue();
    let r2 = 0;
    const i2 = (e21) => t2(e21, r2++);
    s2.this && e20.call(i2, "this"), Array.isArray(s2.parameters) ? e20.each(i2, "parameters") : Array.isArray(s2.params) && e20.each(i2, "params"), s2.rest && e20.call(i2, "rest");
  }, getCallArguments: Xi$1, iterateCallArgumentsPath: function(e20, t2) {
    const s2 = e20.getValue();
    s2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), s2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
  }, hasRestParameter: function(e20) {
    if (e20.rest)
      return true;
    const t2 = Gi$1(e20);
    return t2.length > 0 && pi$1(t2).type === "RestElement";
  }, getLeftSide: function(e20) {
    return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
  }, getLeftSidePathName: function(e20, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }, getParentExportDeclaration: function(e20) {
    const t2 = e20.getParentNode();
    return e20.getName() === "declaration" && Pi$1(t2) ? t2 : null;
  }, getTypeScriptMappedTypeModifier: function(e20, t2) {
    return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
  }, hasFlowAnnotationComment: function(e20) {
    return Di$1(e20) && Fi$1(e20[0]) && xi$1.test(e20[0].value);
  }, hasFlowShorthandAnnotationComment: function(e20) {
    return e20.extra && e20.extra.parenthesized && Di$1(e20.trailingComments) && Fi$1(e20.trailingComments[0]) && Ci$1.test(e20.trailingComments[0].value);
  }, hasLeadingOwnLineComment: function(e20, t2) {
    return Ni$1(t2) ? Yi$1(t2) : ea(t2, Qi$1.Leading, (t3) => li$1(e20, Ai$1(t3)));
  }, hasNakedLeftSide: function(e20) {
    return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Mi$1(e20) || Ri$1(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
  }, hasNode: function e13(t2, s2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e13(t3, s2));
    const r2 = s2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e13(t3, s2));
  }, hasIgnoreComment: function(e20) {
    return Yi$1(e20.getValue());
  }, hasNodeIgnoreComment: Yi$1, identity: function(e20) {
    return e20;
  }, isBinaryish: function(e20) {
    return ki$1.has(e20.type);
  }, isBlockComment: Fi$1, isCallLikeExpression: sa, isLineComment: gi$1, isPrettierIgnoreComment: Ji$1, isCallExpression: Mi$1, isMemberExpression: Ri$1, isExportDeclaration: Pi$1, isFlowAnnotationComment: function(e20, t2) {
    const s2 = yi$1(t2), r2 = di$1(e20, Ai$1(t2));
    return r2 !== false && e20.slice(s2, s2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
  }, isFunctionCompositionArgs: function(e20) {
    if (e20.length <= 1)
      return false;
    let t2 = 0;
    for (const s2 of e20)
      if (Si$1(s2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Mi$1(s2)) {
        for (const e21 of s2.arguments)
          if (Si$1(e21))
            return true;
      }
    return false;
  }, isFunctionNotation: vi$1, isFunctionOrArrowExpression: Si$1, isGetterOrSetter: Ii$1, isJestEachTemplateLiteral: function(e20, t2) {
    const s2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && s2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && s2.test(t2.tag.object.object.name));
  }, isJsxNode: Ni$1, isLiteral: function(e20) {
    return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
  }, isLongCurriedCallExpression: function(e20) {
    const t2 = e20.getValue(), s2 = e20.getParentNode();
    return Mi$1(t2) && Mi$1(s2) && s2.callee === t2 && t2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
  }, isSimpleCallArgument: function e14(t2, s2) {
    if (s2 >= 2)
      return false;
    const r2 = (t3) => e14(t3, s2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && fi$1(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : sa(t2) ? (t2.type === "ImportExpression" || e14(t2.callee, s2)) && Xi$1(t2).every(r2) : Ri$1(t2) ? e14(t2.object, s2) && e14(t2.property, s2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e14(t2.expression, s2) : e14(t2.argument, s2)));
  }, isMemberish: function(e20) {
    return Ri$1(e20) || e20.type === "BindExpression" && Boolean(e20.object);
  }, isNumericLiteral: Ti$1, isSignedNumericLiteral: function(e20) {
    return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && Ti$1(e20.argument);
  }, isObjectProperty: function(e20) {
    return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
  }, isObjectType: function(e20) {
    return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
  }, isObjectTypePropertyAFunction: function(e20) {
    return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || vi$1(e20));
  }, isSimpleType: function(e20) {
    return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!Li$1.has(e20.type));
  }, isSimpleNumber: ji$1, isSimpleTemplateLiteral: function(e20) {
    let t2 = "expressions";
    e20.type === "TSTemplateLiteralType" && (t2 = "types");
    const s2 = e20[t2];
    return s2.length !== 0 && s2.every((e21) => {
      if (ea(e21))
        return false;
      if (e21.type === "Identifier" || e21.type === "ThisExpression")
        return true;
      if (Ri$1(e21)) {
        let t3 = e21;
        for (; Ri$1(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, ea(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  }, isStringLiteral: wi$1, isStringPropSafeToUnquote: function(e20, t2) {
    return t2.parser !== "json" && wi$1(e20.key) && Ui$1(e20.key).slice(1, -1) === e20.key.value && (ci$1(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || ji$1(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  }, isTemplateOnItsOwnLine: function(e20, t2) {
    return (e20.type === "TemplateLiteral" && _i$1(e20) || e20.type === "TaggedTemplateExpression" && _i$1(e20.quasi)) && !li$1(t2, yi$1(e20), {backwards: true});
  }, isTestCall: function e15(t2, s2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Bi$1(t2) && s2 && e15(s2))
        return Si$1(t2.arguments[0]);
      if (function(e20) {
        return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
      }(t2))
        return Bi$1(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Oi$1.test(t2.callee.name) || function(e20) {
      return Ri$1(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Oi$1.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
    }(t2)) && (function(e20) {
      return e20.type === "TemplateLiteral";
    }(t2.arguments[0]) || wi$1(t2.arguments[0])))
      return !(t2.arguments[2] && !Ti$1(t2.arguments[2])) && ((t2.arguments.length === 2 ? Si$1(t2.arguments[1]) : function(e20) {
        return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
      }(t2.arguments[1]) && Gi$1(t2.arguments[1]).length <= 1) || Bi$1(t2.arguments[1]));
    return false;
  }, isTheOnlyJsxElementInMarkdown: function(e20, t2) {
    if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
      return false;
    const s2 = t2.getNode();
    if (!s2.expression || !Ni$1(s2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  }, isTSXFile: function(e20) {
    return e20.filepath && /\.tsx$/i.test(e20.filepath);
  }, isTypeAnnotationAFunction: function(e20) {
    return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || Ei$1(e20, e20.typeAnnotation));
  }, isNextLineEmpty: (e20, {originalText: t2}) => mi$1(t2, Ai$1(e20)), needsHardlineAfterDanglingComment: function(e20) {
    if (!ea(e20))
      return false;
    const t2 = pi$1(ta(e20, Qi$1.Dangling));
    return t2 && !Fi$1(t2);
  }, rawText: Ui$1, shouldPrintComma: function(e20, t2 = "es5") {
    return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  }, isBitwiseOperator: function(e20) {
    return Boolean(Hi$1[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
  }, shouldFlatten: function(e20, t2) {
    return zi$1(t2) === zi$1(e20) && (e20 !== "**" && ((!qi$1[e20] || !qi$1[t2]) && (!(t2 === "%" && $i$1[e20] || e20 === "%" && $i$1[t2]) && ((t2 === e20 || !$i$1[t2] || !$i$1[e20]) && (!Hi$1[e20] || !Hi$1[t2])))));
  }, startsWithNoLookaheadToken: function e16(t2, s2) {
    switch ((t2 = function(e20) {
      for (; e20.left; )
        e20 = e20.left;
      return e20;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return s2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e16(t2.object, s2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e16(t2.tag, s2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e16(t2.callee, s2);
      case "ConditionalExpression":
        return e16(t2.test, s2);
      case "UpdateExpression":
        return !t2.prefix && e16(t2.argument, s2);
      case "BindExpression":
        return t2.object && e16(t2.object, s2);
      case "SequenceExpression":
        return e16(t2.expressions[0], s2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e16(t2.expression, s2);
      default:
        return false;
    }
  }, getPrecedence: zi$1, hasComment: ea, getComments: ta, CommentCheckFlags: Qi$1};
  const {getLast: ia, hasNewline: aa, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: na, getNextNonSpaceNonCommentCharacter: oa, hasNewlineInRange: ua, addLeadingComment: ha, addTrailingComment: ca, addDanglingComment: pa, getNextNonSpaceNonCommentCharacterIndex: la, isNonEmptyArray: da} = tr$1, {isBlockComment: Da, getFunctionParameters: ma, isPrettierIgnoreComment: fa, isJsxNode: ya, hasFlowShorthandAnnotationComment: Aa, hasFlowAnnotationComment: Ea, hasIgnoreComment: Ca, isCallLikeExpression: xa, getCallArguments: Fa, isCallExpression: ga, isMemberExpression: ba, isObjectProperty: Pa, getComments: Ta, CommentCheckFlags: wa} = ra, {locStart: Sa, locEnd: Ba} = ei$1;
  function Na(e20, t2) {
    const s2 = (e20.body || e20.properties).find(({type: e21}) => e21 !== "EmptyStatement");
    s2 ? ha(s2, t2) : pa(e20, t2);
  }
  function Ia(e20, t2) {
    e20.type === "BlockStatement" ? Na(e20, t2) : ha(e20, t2);
  }
  function va({comment: e20, followingNode: t2}) {
    return !(!t2 || !un$1(e20)) && (ha(t2, e20), true);
  }
  function ka({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
    if (!s2 || s2.type !== "IfStatement" || !r2)
      return false;
    return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : t2 === s2.consequent && r2 === s2.alternate ? (t2.type === "BlockStatement" ? ca(t2, e20) : pa(s2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "IfStatement" ? (Ia(r2.consequent, e20), true) : s2.consequent === r2 && (ha(r2, e20), true);
  }
  function La({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
    if (!s2 || s2.type !== "WhileStatement" || !r2)
      return false;
    return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : s2.body === r2 && (ha(r2, e20), true);
  }
  function Oa({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
    return !(!s2 || s2.type !== "TryStatement" && s2.type !== "CatchClause" || !r2) && (s2.type === "CatchClause" && t2 ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "TryStatement" ? (Ia(r2.finalizer, e20), true) : r2.type === "CatchClause" && (Ia(r2.body, e20), true));
  }
  function Ma({comment: e20, enclosingNode: t2, followingNode: s2}) {
    return !(!ba(t2) || !s2 || s2.type !== "Identifier") && (ha(t2, e20), true);
  }
  function Ra({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
    const a2 = t2 && !ua(i2, Ba(t2), Sa(e20));
    return !(t2 && a2 || !s2 || s2.type !== "ConditionalExpression" && s2.type !== "TSConditionalType" || !r2) && (ha(r2, e20), true);
  }
  function ja({comment: e20, precedingNode: t2, enclosingNode: s2}) {
    return !(!Pa(s2) || !s2.shorthand || s2.key !== t2 || s2.value.type !== "AssignmentPattern") && (ca(s2.value.left, e20), true);
  }
  function _a$3({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
    if (s2 && (s2.type === "ClassDeclaration" || s2.type === "ClassExpression" || s2.type === "DeclareClass" || s2.type === "DeclareInterface" || s2.type === "InterfaceDeclaration" || s2.type === "TSInterfaceDeclaration")) {
      if (da(s2.decorators) && (!r2 || r2.type !== "Decorator"))
        return ca(ia(s2.decorators), e20), true;
      if (s2.body && r2 === s2.body)
        return Na(s2.body, e20), true;
      if (r2) {
        for (const i2 of ["implements", "extends", "mixins"])
          if (s2[i2] && r2 === s2[i2][0])
            return !t2 || t2 !== s2.id && t2 !== s2.typeParameters && t2 !== s2.superClass ? pa(s2, e20, i2) : ca(t2, e20), true;
      }
    }
    return false;
  }
  function Ua({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
    return (s2 && t2 && (s2.type === "Property" || s2.type === "TSDeclareMethod" || s2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && s2.key === t2 && oa(r2, t2, Ba) !== ":" || !(!t2 || !s2 || t2.type !== "Decorator" || s2.type !== "ClassMethod" && s2.type !== "ClassProperty" && s2.type !== "PropertyDefinition" && s2.type !== "TSAbstractClassProperty" && s2.type !== "TSAbstractMethodDefinition" && s2.type !== "TSDeclareMethod" && s2.type !== "MethodDefinition")) && (ca(t2, e20), true);
  }
  function qa({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
    return oa(r2, e20, Ba) === "(" && (!(!t2 || !s2 || s2.type !== "FunctionDeclaration" && s2.type !== "FunctionExpression" && s2.type !== "ClassMethod" && s2.type !== "MethodDefinition" && s2.type !== "ObjectMethod") && (ca(t2, e20), true));
  }
  function $a({comment: e20, enclosingNode: t2, text: s2}) {
    if (!t2 || t2.type !== "ArrowFunctionExpression")
      return false;
    const r2 = la(s2, e20, Ba);
    return r2 !== false && s2.slice(r2, r2 + 2) === "=>" && (pa(t2, e20), true);
  }
  function Ha({comment: e20, enclosingNode: t2, text: s2}) {
    return oa(s2, e20, Ba) === ")" && (t2 && (on$1(t2) && ma(t2).length === 0 || xa(t2) && Fa(t2).length === 0) ? (pa(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || ma(t2.value).length !== 0) && (pa(t2.value, e20), true));
  }
  function Va({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2}) {
    if (t2 && t2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
      return ca(t2, e20), true;
    if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && s2 && on$1(s2) && oa(i2, e20, Ba) === ")")
      return ca(t2, e20), true;
    if (s2 && s2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
      const t3 = (() => {
        const e21 = ma(s2);
        if (e21.length > 0)
          return na(i2, Ba(ia(e21)));
        const t4 = na(i2, Ba(s2.id));
        return t4 !== false && na(i2, t4 + 1);
      })();
      if (Sa(e20) > t3)
        return Na(r2, e20), true;
    }
    return false;
  }
  function za({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ImportSpecifier") && (ha(t2, e20), true);
  }
  function Wa({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "LabeledStatement") && (ha(t2, e20), true);
  }
  function Ga({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (ca(t2, e20), true);
  }
  function Ka({comment: e20, precedingNode: t2, enclosingNode: s2}) {
    return !!(ga(s2) && t2 && s2.callee === t2 && s2.arguments.length > 0) && (ha(s2.arguments[0], e20), true);
  }
  function Xa({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
    return !s2 || s2.type !== "UnionTypeAnnotation" && s2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && fa(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (fa(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (ca(t2, e20), true));
  }
  function Ja({comment: e20, enclosingNode: t2}) {
    return !!Pa(t2) && (ha(t2, e20), true);
  }
  function Ya({comment: e20, enclosingNode: t2, followingNode: s2, ast: r2, isLastComment: i2}) {
    return r2 && r2.body && r2.body.length === 0 ? (i2 ? pa(r2, e20) : ha(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !da(t2.directives) ? (i2 ? pa(t2, e20) : ha(t2, e20), true) : !(!s2 || s2.type !== "Program" || s2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (pa(s2, e20), true);
  }
  function Qa({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (ha(t2, e20), true);
  }
  function Za({comment: e20, precedingNode: t2, enclosingNode: s2, text: r2}) {
    return !!(t2 && t2.type === "ImportSpecifier" && s2 && s2.type === "ImportDeclaration" && aa(r2, Ba(e20))) && (ca(t2, e20), true);
  }
  function en$1({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "AssignmentPattern") && (ha(t2, e20), true);
  }
  function tn$1({comment: e20, enclosingNode: t2}) {
    return !(!t2 || t2.type !== "TypeAlias") && (ha(t2, e20), true);
  }
  function sn$1({comment: e20, enclosingNode: t2, followingNode: s2}) {
    return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !s2 || s2.type !== "ObjectExpression" && s2.type !== "ArrayExpression" && s2.type !== "TemplateLiteral" && s2.type !== "TaggedTemplateExpression" && !Da(e20)) && (ha(s2, e20), true);
  }
  function rn$1({comment: e20, enclosingNode: t2, followingNode: s2, text: r2}) {
    return !(s2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || oa(r2, e20, Ba) !== ";") && (ca(t2, e20), true);
  }
  function an$1({comment: e20, enclosingNode: t2, followingNode: s2}) {
    if (fa(e20) && t2 && t2.type === "TSMappedType" && s2 && s2.type === "TSTypeParameter" && s2.constraint)
      return t2.prettierIgnore = true, e20.unignore = true, true;
  }
  function nn$1({comment: e20, precedingNode: t2, enclosingNode: s2, followingNode: r2}) {
    return !(!s2 || s2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (ha(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (ca(t2.constraint, e20), true));
  }
  function on$1(e20) {
    return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
  }
  function un$1(e20) {
    return Da(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
  }
  var hn$1 = {handleOwnLineComment: function(e20) {
    return [an$1, Va, Ma, ka, La, Oa, _a$3, za, Qa, Xa, Ya, Za, en$1, Ua, Wa].some((t2) => t2(e20));
  }, handleEndOfLineComment: function(e20) {
    return [va, Va, Ra, za, ka, La, Oa, _a$3, Wa, Ka, Ja, Ya, tn$1, sn$1].some((t2) => t2(e20));
  }, handleRemainingComment: function(e20) {
    return [an$1, ka, La, ja, Ha, Ua, Ya, $a, qa, nn$1, Ga, rn$1].some((t2) => t2(e20));
  }, isTypeCastComment: un$1, getCommentChildNodes: function(e20, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && ma(e20.value).length === 0 && !e20.value.returnType && !da(e20.value.typeParameters) && e20.value.body)
      return [...e20.decorators || [], e20.key, e20.value.body];
  }, willPrintOwnComments: function(e20) {
    const t2 = e20.getValue(), s2 = e20.getParentNode();
    return (t2 && (ya(t2) || Aa(t2) || ga(s2) && ((e21) => Ea(Ta(e21, wa.Leading)) || Ea(Ta(e21, wa.Trailing)))(t2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === t2)) && (!Ca(e20) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
  }};
  const {getLast: cn$1, getNextNonSpaceNonCommentCharacter: pn$1} = tr$1, {locStart: ln$1, locEnd: dn$1} = ei$1, {isTypeCastComment: Dn$1} = hn$1;
  function mn$1(e20) {
    return e20.type === "CallExpression" ? (e20.type = "OptionalCallExpression", e20.callee = mn$1(e20.callee)) : e20.type === "MemberExpression" ? (e20.type = "OptionalMemberExpression", e20.object = mn$1(e20.object)) : e20.type === "TSNonNullExpression" && (e20.expression = mn$1(e20.expression)), e20;
  }
  function fn$1(e20, t2) {
    let s2;
    if (Array.isArray(e20))
      s2 = e20.entries();
    else {
      if (!e20 || typeof e20 != "object" || typeof e20.type != "string")
        return e20;
      s2 = Object.entries(e20);
    }
    for (const [r2, i2] of s2)
      e20[r2] = fn$1(i2, t2);
    return Array.isArray(e20) ? e20 : t2(e20) || e20;
  }
  function yn$1(e20) {
    return e20.type === "LogicalExpression" && e20.right.type === "LogicalExpression" && e20.operator === e20.right.operator;
  }
  function An$1(e20) {
    return yn$1(e20) ? An$1({type: "LogicalExpression", operator: e20.operator, left: An$1({type: "LogicalExpression", operator: e20.operator, left: e20.left, right: e20.right.left, range: [ln$1(e20.left), dn$1(e20.right.left)]}), right: e20.right.right, range: [ln$1(e20), dn$1(e20)]}) : e20;
  }
  var En$1 = function(e20, t2) {
    if (t2.parser === "typescript" && t2.originalText.includes("@")) {
      const {esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2} = t2.tsParseResult;
      e20 = fn$1(e20, (e21) => {
        const t3 = s2.get(e21);
        if (!t3)
          return;
        const i2 = t3.decorators;
        if (!Array.isArray(i2))
          return;
        const a2 = r2.get(t3);
        if (a2 !== e21)
          return;
        const n2 = a2.decorators;
        if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((e22) => {
          const t4 = r2.get(e22);
          return !t4 || !n2.includes(t4);
        })) {
          const {start: e22, end: t4} = a2.loc;
          throw ai$1("Leading decorators must be attached to a class declaration", {start: {line: e22.line, column: e22.column + 1}, end: {line: t4.line, column: t4.column + 1}});
        }
      });
    }
    if (t2.parser !== "typescript" && t2.parser !== "flow" && t2.parser !== "espree" && t2.parser !== "meriyah") {
      const t3 = new Set();
      e20 = fn$1(e20, (e21) => {
        e21.leadingComments && e21.leadingComments.some(Dn$1) && t3.add(ln$1(e21));
      }), e20 = fn$1(e20, (e21) => {
        if (e21.type === "ParenthesizedExpression") {
          const {expression: s2} = e21;
          if (s2.type === "TypeCastExpression")
            return s2.range = e21.range, s2;
          const r2 = ln$1(e21);
          if (!t3.has(r2))
            return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, {parenthesized: true}), s2;
        }
      });
    }
    return e20 = fn$1(e20, (e21) => {
      switch (e21.type) {
        case "ChainExpression":
          return mn$1(e21.expression);
        case "LogicalExpression":
          if (yn$1(e21))
            return An$1(e21);
          break;
        case "VariableDeclaration": {
          const s2 = cn$1(e21.declarations);
          s2 && s2.init && function(e22, s3) {
            if (t2.originalText[dn$1(s3)] === ";")
              return;
            e22.range = [ln$1(e22), dn$1(s3)];
          }(e21, s2);
          break;
        }
        case "TSParenthesizedType":
          return e21.typeAnnotation.range = [ln$1(e21), dn$1(e21)], e21.typeAnnotation;
        case "TSTypeParameter":
          if (typeof e21.name == "string") {
            const t3 = ln$1(e21);
            e21.name = {type: "Identifier", name: e21.name, range: [t3, t3 + e21.name.length]};
          }
          break;
        case "SequenceExpression": {
          const t3 = cn$1(e21.expressions);
          e21.range = [ln$1(e21), Math.min(dn$1(t3), dn$1(e21))];
          break;
        }
        case "ClassProperty":
          e21.key && e21.key.type === "TSPrivateIdentifier" && pn$1(t2.originalText, e21.key, dn$1) === "?" && (e21.optional = true);
      }
    });
  };
  class Cn$1 {
    constructor(e20, t2 = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e20, this.keyword = t2.keyword, this.beforeExpr = !!t2.beforeExpr, this.startsExpr = !!t2.startsExpr, this.rightAssociative = !!t2.rightAssociative, this.isLoop = !!t2.isLoop, this.isAssign = !!t2.isAssign, this.prefix = !!t2.prefix, this.postfix = !!t2.postfix, this.binop = t2.binop != null ? t2.binop : null, this.updateContext = null;
    }
  }
  const xn$1 = new Map();
  function Fn$1(e20, t2 = {}) {
    t2.keyword = e20;
    const s2 = new Cn$1(e20, t2);
    return xn$1.set(e20, s2), s2;
  }
  function gn$1(e20, t2) {
    return new Cn$1(e20, {beforeExpr: true, binop: t2});
  }
  const bn$1 = {num: new Cn$1("num", {startsExpr: true}), bigint: new Cn$1("bigint", {startsExpr: true}), decimal: new Cn$1("decimal", {startsExpr: true}), regexp: new Cn$1("regexp", {startsExpr: true}), string: new Cn$1("string", {startsExpr: true}), name: new Cn$1("name", {startsExpr: true}), privateName: new Cn$1("#name", {startsExpr: true}), eof: new Cn$1("eof"), bracketL: new Cn$1("[", {beforeExpr: true, startsExpr: true}), bracketHashL: new Cn$1("#[", {beforeExpr: true, startsExpr: true}), bracketBarL: new Cn$1("[|", {beforeExpr: true, startsExpr: true}), bracketR: new Cn$1("]"), bracketBarR: new Cn$1("|]"), braceL: new Cn$1("{", {beforeExpr: true, startsExpr: true}), braceBarL: new Cn$1("{|", {beforeExpr: true, startsExpr: true}), braceHashL: new Cn$1("#{", {beforeExpr: true, startsExpr: true}), braceR: new Cn$1("}", {beforeExpr: true}), braceBarR: new Cn$1("|}"), parenL: new Cn$1("(", {beforeExpr: true, startsExpr: true}), parenR: new Cn$1(")"), comma: new Cn$1(",", {beforeExpr: true}), semi: new Cn$1(";", {beforeExpr: true}), colon: new Cn$1(":", {beforeExpr: true}), doubleColon: new Cn$1("::", {beforeExpr: true}), dot: new Cn$1("."), question: new Cn$1("?", {beforeExpr: true}), questionDot: new Cn$1("?."), arrow: new Cn$1("=>", {beforeExpr: true}), template: new Cn$1("template"), ellipsis: new Cn$1("...", {beforeExpr: true}), backQuote: new Cn$1("`", {startsExpr: true}), dollarBraceL: new Cn$1("${", {beforeExpr: true, startsExpr: true}), at: new Cn$1("@"), hash: new Cn$1("#", {startsExpr: true}), interpreterDirective: new Cn$1("#!..."), eq: new Cn$1("=", {beforeExpr: true, isAssign: true}), assign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), slashAssign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), moduloAssign: new Cn$1("_=", {beforeExpr: true, isAssign: true}), incDec: new Cn$1("++/--", {prefix: true, postfix: true, startsExpr: true}), bang: new Cn$1("!", {beforeExpr: true, prefix: true, startsExpr: true}), tilde: new Cn$1("~", {beforeExpr: true, prefix: true, startsExpr: true}), pipeline: gn$1("|>", 0), nullishCoalescing: gn$1("??", 1), logicalOR: gn$1("||", 1), logicalAND: gn$1("&&", 2), bitwiseOR: gn$1("|", 3), bitwiseXOR: gn$1("^", 4), bitwiseAND: gn$1("&", 5), equality: gn$1("==/!=/===/!==", 6), relational: gn$1("</>/<=/>=", 7), bitShift: gn$1("<</>>/>>>", 8), plusMin: new Cn$1("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}), modulo: new Cn$1("%", {binop: 10, startsExpr: true}), star: new Cn$1("*", {binop: 10}), slash: gn$1("/", 10), exponent: new Cn$1("**", {beforeExpr: true, binop: 11, rightAssociative: true}), _break: Fn$1("break"), _case: Fn$1("case", {beforeExpr: true}), _catch: Fn$1("catch"), _continue: Fn$1("continue"), _debugger: Fn$1("debugger"), _default: Fn$1("default", {beforeExpr: true}), _do: Fn$1("do", {isLoop: true, beforeExpr: true}), _else: Fn$1("else", {beforeExpr: true}), _finally: Fn$1("finally"), _for: Fn$1("for", {isLoop: true}), _function: Fn$1("function", {startsExpr: true}), _if: Fn$1("if"), _return: Fn$1("return", {beforeExpr: true}), _switch: Fn$1("switch"), _throw: Fn$1("throw", {beforeExpr: true, prefix: true, startsExpr: true}), _try: Fn$1("try"), _var: Fn$1("var"), _const: Fn$1("const"), _while: Fn$1("while", {isLoop: true}), _with: Fn$1("with"), _new: Fn$1("new", {beforeExpr: true, startsExpr: true}), _this: Fn$1("this", {startsExpr: true}), _super: Fn$1("super", {startsExpr: true}), _class: Fn$1("class", {startsExpr: true}), _extends: Fn$1("extends", {beforeExpr: true}), _export: Fn$1("export"), _import: Fn$1("import", {startsExpr: true}), _null: Fn$1("null", {startsExpr: true}), _true: Fn$1("true", {startsExpr: true}), _false: Fn$1("false", {startsExpr: true}), _in: Fn$1("in", {beforeExpr: true, binop: 7}), _instanceof: Fn$1("instanceof", {beforeExpr: true, binop: 7}), _typeof: Fn$1("typeof", {beforeExpr: true, prefix: true, startsExpr: true}), _void: Fn$1("void", {beforeExpr: true, prefix: true, startsExpr: true}), _delete: Fn$1("delete", {beforeExpr: true, prefix: true, startsExpr: true})}, Pn$1 = /\r\n?|[\n\u2028\u2029]/, Tn$1 = new RegExp(Pn$1.source, "g");
  function wn$1(e20) {
    switch (e20) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const Sn$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Bn$1 = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Nn$1(e20) {
    switch (e20) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class In$1 {
    constructor(e20, t2) {
      this.line = void 0, this.column = void 0, this.line = e20, this.column = t2;
    }
  }
  class vn$1 {
    constructor(e20, t2) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e20, this.end = t2;
    }
  }
  function kn$1(e20, t2) {
    e20.trailingComments === void 0 ? e20.trailingComments = t2 : e20.trailingComments.unshift(...t2);
  }
  function Ln$1(e20, t2) {
    e20.innerComments === void 0 ? e20.innerComments = t2 : t2 !== void 0 && e20.innerComments.unshift(...t2);
  }
  function On$1(e20, t2, s2) {
    let r2 = null, i2 = t2.length;
    for (; r2 === null && i2 > 0; )
      r2 = t2[--i2];
    r2 === null || r2.start > s2.start ? Ln$1(e20, s2.comments) : kn$1(r2, s2.comments);
  }
  const Mn$1 = Object.freeze({SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}), Rn$1 = Un$1({AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."}, Mn$1.SyntaxError), jn$1 = Un$1({ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`}, Mn$1.SourceTypeModuleError);
  function _n$1(e20, t2) {
    return t2 === "flow" && e20 === "PatternIsOptional" ? "OptionalBindingPattern" : e20;
  }
  function Un$1(e20, t2, s2) {
    const r2 = {};
    return Object.keys(e20).forEach((i2) => {
      r2[i2] = Object.freeze({code: t2, reasonCode: _n$1(i2, s2), template: e20[i2]});
    }), Object.freeze(r2);
  }
  class qn$1 {
    constructor(e20, t2) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e20, this.preserveSpace = !!t2;
    }
  }
  const $n$1 = {brace: new qn$1("{"), template: new qn$1("`", true)};
  bn$1.braceR.updateContext = (e20) => {
    e20.pop();
  }, bn$1.braceL.updateContext = bn$1.braceHashL.updateContext = bn$1.dollarBraceL.updateContext = (e20) => {
    e20.push($n$1.brace);
  }, bn$1.backQuote.updateContext = (e20) => {
    e20[e20.length - 1] === $n$1.template ? e20.pop() : e20.push($n$1.template);
  };
  let Hn$1 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Vn$1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  const zn$1 = new RegExp("[" + Hn$1 + "]"), Wn$1 = new RegExp("[" + Hn$1 + Vn$1 + "]");
  Hn$1 = Vn$1 = null;
  const Gn$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Kn$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Xn$1(e20, t2) {
    let s2 = 65536;
    for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
      if (s2 += t2[r2], s2 > e20)
        return false;
      if (s2 += t2[r2 + 1], s2 >= e20)
        return true;
    }
    return false;
  }
  function Jn$1(e20) {
    return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && zn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1)));
  }
  function Yn$1(e20) {
    return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Wn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1) || Xn$1(e20, Kn$1))));
  }
  const Qn$1 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Zn$1 = ["eval", "arguments"], eo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), to$1 = new Set(Qn$1), so$1 = new Set(Zn$1);
  function ro$1(e20, t2) {
    return t2 && e20 === "await" || e20 === "enum";
  }
  function io$1(e20, t2) {
    return ro$1(e20, t2) || to$1.has(e20);
  }
  function ao$1(e20) {
    return so$1.has(e20);
  }
  function no$1(e20, t2) {
    return io$1(e20, t2) || ao$1(e20);
  }
  function oo$1(e20) {
    return eo$1.has(e20);
  }
  const uo$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  class ho$1 {
    constructor(e20) {
      this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e20;
    }
  }
  class co$1 {
    constructor(e20, t2) {
      this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e20, this.inModule = t2;
    }
    get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e20 = this.currentThisScopeFlags();
      return (64 & e20) > 0 && (2 & e20) == 0;
    }
    get inStaticBlock() {
      for (let e20 = this.scopeStack.length - 1; ; e20--) {
        const {flags: t2} = this.scopeStack[e20];
        if (128 & t2)
          return true;
        if (323 & t2)
          return false;
      }
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e20) {
      return new ho$1(e20);
    }
    enter(e20) {
      this.scopeStack.push(this.createScope(e20));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(e20) {
      return !!(2 & e20.flags || !this.inModule && 1 & e20.flags);
    }
    declareName(e20, t2, s2) {
      let r2 = this.currentScope();
      if (8 & t2 || 16 & t2)
        this.checkRedeclarationInScope(r2, e20, t2, s2), 16 & t2 ? r2.functions.add(e20) : r2.lexical.add(e20), 8 & t2 && this.maybeExportDefined(r2, e20);
      else if (4 & t2)
        for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, e20, t2, s2), r2.var.add(e20), this.maybeExportDefined(r2, e20), !(259 & r2.flags)); --i2)
          ;
      this.inModule && 1 & r2.flags && this.undefinedExports.delete(e20);
    }
    maybeExportDefined(e20, t2) {
      this.inModule && 1 & e20.flags && this.undefinedExports.delete(t2);
    }
    checkRedeclarationInScope(e20, t2, s2, r2) {
      this.isRedeclaredInScope(e20, t2, s2) && this.raise(r2, Rn$1.VarRedeclaration, t2);
    }
    isRedeclaredInScope(e20, t2, s2) {
      return !!(1 & s2) && (8 & s2 ? e20.lexical.has(t2) || e20.functions.has(t2) || e20.var.has(t2) : 16 & s2 ? e20.lexical.has(t2) || !this.treatFunctionsAsVarInScope(e20) && e20.var.has(t2) : e20.lexical.has(t2) && !(8 & e20.flags && e20.lexical.values().next().value === t2) || !this.treatFunctionsAsVarInScope(e20) && e20.functions.has(t2));
    }
    checkLocalExport(e20) {
      const {name: t2} = e20, s2 = this.scopeStack[0];
      s2.lexical.has(t2) || s2.var.has(t2) || s2.functions.has(t2) || this.undefinedExports.set(t2, e20.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e20 = this.scopeStack.length - 1; ; e20--) {
        const {flags: t2} = this.scopeStack[e20];
        if (259 & t2)
          return t2;
      }
    }
    currentThisScopeFlags() {
      for (let e20 = this.scopeStack.length - 1; ; e20--) {
        const {flags: t2} = this.scopeStack[e20];
        if (323 & t2 && !(4 & t2))
          return t2;
      }
    }
  }
  class po$1 extends ho$1 {
    constructor(...e20) {
      super(...e20), this.declareFunctions = new Set();
    }
  }
  class lo$1 extends co$1 {
    createScope(e20) {
      return new po$1(e20);
    }
    declareName(e20, t2, s2) {
      const r2 = this.currentScope();
      if (2048 & t2)
        return this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20), void r2.declareFunctions.add(e20);
      super.declareName(...arguments);
    }
    isRedeclaredInScope(e20, t2, s2) {
      return !!super.isRedeclaredInScope(...arguments) || !!(2048 & s2) && (!e20.declareFunctions.has(t2) && (e20.lexical.has(t2) || e20.functions.has(t2)));
    }
    checkLocalExport(e20) {
      this.scopeStack[0].declareFunctions.has(e20.name) || super.checkLocalExport(e20);
    }
  }
  class Do$1 {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null}, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.lineStart = 0, this.type = bn$1.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$n$1.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
    }
    init(e20) {
      this.strict = e20.strictMode !== false && (e20.strictMode === true || e20.sourceType === "module"), this.curLine = e20.startLine, this.startLoc = this.endLoc = this.curPosition();
    }
    curPosition() {
      return new In$1(this.curLine, this.pos - this.lineStart);
    }
    clone(e20) {
      const t2 = new Do$1(), s2 = Object.keys(this);
      for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
        const i3 = s2[r2];
        let a2 = this[i3];
        !e20 && Array.isArray(a2) && (a2 = a2.slice()), t2[i3] = a2;
      }
      return t2;
    }
  }
  var mo$1 = function(e20) {
    return e20 >= 48 && e20 <= 57;
  };
  const fo$1 = new Set([103, 109, 115, 105, 121, 117, 100]), yo$1 = {decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120]}, Ao$1 = {bin: [48, 49]};
  Ao$1.oct = [...Ao$1.bin, 50, 51, 52, 53, 54, 55], Ao$1.dec = [...Ao$1.oct, 56, 57], Ao$1.hex = [...Ao$1.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
  class Eo$1 {
    constructor(e20) {
      this.type = e20.type, this.value = e20.value, this.start = e20.start, this.end = e20.end, this.loc = new vn$1(e20.startLoc, e20.endLoc);
    }
  }
  class Co$1 {
    constructor() {
      this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
    }
  }
  class xo$1 {
    constructor(e20) {
      this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e20;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Co$1());
    }
    exit() {
      const e20 = this.stack.pop(), t2 = this.current();
      for (const [s2, r2] of Array.from(e20.undefinedPrivateNames))
        t2 ? t2.undefinedPrivateNames.has(s2) || t2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Rn$1.InvalidPrivateFieldResolution, s2);
    }
    declarePrivateName(e20, t2, s2) {
      const r2 = this.current();
      let i2 = r2.privateNames.has(e20);
      if (3 & t2) {
        const s3 = i2 && r2.loneAccessors.get(e20);
        if (s3) {
          const a2 = 4 & s3, n2 = 4 & t2;
          i2 = (3 & s3) === (3 & t2) || a2 !== n2, i2 || r2.loneAccessors.delete(e20);
        } else
          i2 || r2.loneAccessors.set(e20, t2);
      }
      i2 && this.raise(s2, Rn$1.PrivateNameRedeclaration, e20), r2.privateNames.add(e20), r2.undefinedPrivateNames.delete(e20);
    }
    usePrivateName(e20, t2) {
      let s2;
      for (s2 of this.stack)
        if (s2.privateNames.has(e20))
          return;
      s2 ? s2.undefinedPrivateNames.set(e20, t2) : this.raise(t2, Rn$1.InvalidPrivateFieldResolution, e20);
    }
  }
  class Fo$1 {
    constructor(e20 = 0) {
      this.type = void 0, this.type = e20;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class go$1 extends Fo$1 {
    constructor(e20) {
      super(e20), this.errors = new Map();
    }
    recordDeclarationError(e20, t2) {
      this.errors.set(e20, t2);
    }
    clearDeclarationError(e20) {
      this.errors.delete(e20);
    }
    iterateErrors(e20) {
      this.errors.forEach(e20);
    }
  }
  class bo$1 {
    constructor(e20) {
      this.stack = [new Fo$1()], this.raise = e20;
    }
    enter(e20) {
      this.stack.push(e20);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e20, t2) {
      const {stack: s2} = this;
      let r2 = s2.length - 1, i2 = s2[r2];
      for (; !i2.isCertainlyParameterDeclaration(); ) {
        if (!i2.canBeArrowParameterDeclaration())
          return;
        i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
      }
      this.raise(e20, t2);
    }
    recordParenthesizedIdentifierError(e20, t2) {
      const {stack: s2} = this, r2 = s2[s2.length - 1];
      if (r2.isCertainlyParameterDeclaration())
        this.raise(e20, t2);
      else {
        if (!r2.canBeArrowParameterDeclaration())
          return;
        r2.recordDeclarationError(e20, t2);
      }
    }
    recordAsyncArrowParametersError(e20, t2) {
      const {stack: s2} = this;
      let r2 = s2.length - 1, i2 = s2[r2];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.type === 2 && i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
    }
    validateAsPattern() {
      const {stack: e20} = this, t2 = e20[e20.length - 1];
      t2.canBeArrowParameterDeclaration() && t2.iterateErrors((t3, s2) => {
        this.raise(s2, t3);
        let r2 = e20.length - 2, i2 = e20[r2];
        for (; i2.canBeArrowParameterDeclaration(); )
          i2.clearDeclarationError(s2), i2 = e20[--r2];
      });
    }
  }
  function Po$1() {
    return new Fo$1();
  }
  class To$1 {
    constructor() {
      this.stacks = [];
    }
    enter(e20) {
      this.stacks.push(e20);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
    get hasIn() {
      return (8 & this.currentFlags()) > 0;
    }
  }
  function wo$1(e20, t2) {
    return (e20 ? 2 : 0) | (t2 ? 1 : 0);
  }
  class So$1 {
    constructor() {
      this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
    }
  }
  class Bo$1 {
    constructor(e20, t2, s2) {
      this.type = "", this.start = t2, this.end = 0, this.loc = new vn$1(s2), e20 != null && e20.options.ranges && (this.range = [t2, 0]), e20 != null && e20.filename && (this.loc.filename = e20.filename);
    }
  }
  const No$1 = Bo$1.prototype;
  function Io$1(e20) {
    const {type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2, name: o2} = e20, u2 = Object.create(No$1);
    return u2.type = t2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = a2, u2.extra = n2, u2.name = o2, t2 === "Placeholder" && (u2.expectedNode = e20.expectedNode), u2;
  }
  function vo$1(e20) {
    const {type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2} = e20;
    if (t2 === "Placeholder")
      return function(e21) {
        return Io$1(e21);
      }(e20);
    const o2 = Object.create(No$1);
    return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = a2, o2.extra = n2, o2.value = e20.value, o2;
  }
  No$1.__clone = function() {
    const e20 = new Bo$1(), t2 = Object.keys(this);
    for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
      const r3 = t2[s2];
      r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (e20[r3] = this[r3]);
    }
    return e20;
  };
  const ko$1 = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Lo$1 = Un$1({AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment."}, Mn$1.SyntaxError, "flow");
  function Oo$1(e20) {
    return e20.importKind === "type" || e20.importKind === "typeof";
  }
  function Mo(e20) {
    return (e20.type === bn$1.name || !!e20.type.keyword) && e20.value !== "from";
  }
  const Ro$1 = {const: "declare export var", let: "declare export var", type: "export type", interface: "export interface"};
  const jo = /\*?\s*@((?:no)?flow)\b/;
  const _o$1 = {quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666"}, Uo = /^[\da-fA-F]+$/, qo = /^\d+$/, $o = Un$1({AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"}, Mn$1.SyntaxError, "jsx");
  function Ho(e20) {
    return !!e20 && (e20.type === "JSXOpeningFragment" || e20.type === "JSXClosingFragment");
  }
  function Vo(e20) {
    if (e20.type === "JSXIdentifier")
      return e20.name;
    if (e20.type === "JSXNamespacedName")
      return e20.namespace.name + ":" + e20.name.name;
    if (e20.type === "JSXMemberExpression")
      return Vo(e20.object) + "." + Vo(e20.property);
    throw new Error("Node had unexpected type: " + e20.type);
  }
  $n$1.j_oTag = new qn$1("<tag"), $n$1.j_cTag = new qn$1("</tag"), $n$1.j_expr = new qn$1("<tag>...</tag>", true), bn$1.jsxName = new Cn$1("jsxName"), bn$1.jsxText = new Cn$1("jsxText", {beforeExpr: true}), bn$1.jsxTagStart = new Cn$1("jsxTagStart", {startsExpr: true}), bn$1.jsxTagEnd = new Cn$1("jsxTagEnd"), bn$1.jsxTagStart.updateContext = (e20) => {
    e20.push($n$1.j_expr, $n$1.j_oTag);
  };
  class zo extends ho$1 {
    constructor(...e20) {
      super(...e20), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
    }
  }
  class Wo extends co$1 {
    createScope(e20) {
      return new zo(e20);
    }
    declareName(e20, t2, s2) {
      const r2 = this.currentScope();
      if (1024 & t2)
        return this.maybeExportDefined(r2, e20), void r2.exportOnlyBindings.add(e20);
      super.declareName(...arguments), 2 & t2 && (1 & t2 || (this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20)), r2.types.add(e20)), 256 & t2 && r2.enums.add(e20), 512 & t2 && r2.constEnums.add(e20), 128 & t2 && r2.classes.add(e20);
    }
    isRedeclaredInScope(e20, t2, s2) {
      if (e20.enums.has(t2)) {
        if (256 & s2) {
          return !!(512 & s2) !== e20.constEnums.has(t2);
        }
        return true;
      }
      return 128 & s2 && e20.classes.has(t2) ? !!e20.lexical.has(t2) && !!(1 & s2) : !!(2 & s2 && e20.types.has(t2)) || super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(e20) {
      const t2 = this.scopeStack[0], {name: s2} = e20;
      t2.types.has(s2) || t2.exportOnlyBindings.has(s2) || super.checkLocalExport(e20);
    }
  }
  function Go(e20) {
    if (e20 == null)
      throw new Error(`Unexpected ${e20} value.`);
    return e20;
  }
  function Ko(e20) {
    if (!e20)
      throw new Error("Assert fail");
  }
  const Xo = Un$1({AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."}, Mn$1.SyntaxError, "typescript");
  function Jo(e20) {
    return e20 === "private" || e20 === "public" || e20 === "protected";
  }
  bn$1.placeholder = new Cn$1("%%", {startsExpr: true});
  const Yo = Un$1({ClassNameIsRequired: "A class name is required."}, Mn$1.SyntaxError);
  function Qo(e20, t2) {
    return e20.some((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
  }
  function Zo(e20, t2, s2) {
    const r2 = e20.find((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
    return r2 && Array.isArray(r2) ? r2[1][s2] : null;
  }
  const eu = ["minimal", "fsharp", "hack", "smart"], tu = ["%", "#"], su = ["hash", "bar"];
  const ru = {estree: (e20) => class extends e20 {
    parseRegExpLiteral({pattern: e21, flags: t2}) {
      let s2 = null;
      try {
        s2 = new RegExp(e21, t2);
      } catch (e22) {
      }
      const r2 = this.estreeParseLiteral(s2);
      return r2.regex = {pattern: e21, flags: t2}, r2;
    }
    parseBigIntLiteral(e21) {
      let t2;
      try {
        t2 = BigInt(e21);
      } catch (e22) {
        t2 = null;
      }
      const s2 = this.estreeParseLiteral(t2);
      return s2.bigint = String(s2.value || e21), s2;
    }
    parseDecimalLiteral(e21) {
      const t2 = this.estreeParseLiteral(null);
      return t2.decimal = String(t2.value || e21), t2;
    }
    estreeParseLiteral(e21) {
      return this.parseLiteral(e21, "Literal");
    }
    parseStringLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    parseNumericLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    directiveToStmt(e21) {
      const t2 = e21.value, s2 = this.startNodeAt(e21.start, e21.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start);
      return r2.value = t2.extra.expressionValue, r2.raw = t2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", t2.end, t2.loc.end), s2.directive = t2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", e21.end, e21.loc.end);
    }
    initFunction(e21, t2) {
      super.initFunction(e21, t2), e21.expression = false;
    }
    checkDeclaration(e21) {
      e21 != null && this.isObjectProperty(e21) ? this.checkDeclaration(e21.value) : super.checkDeclaration(e21);
    }
    getObjectOrClassMethodParams(e21) {
      return e21.value.params;
    }
    isValidDirective(e21) {
      var t2;
      return e21.type === "ExpressionStatement" && e21.expression.type === "Literal" && typeof e21.expression.value == "string" && !((t2 = e21.expression.extra) != null && t2.parenthesized);
    }
    stmtToDirective(e21) {
      const t2 = e21.expression.value, s2 = super.stmtToDirective(e21);
      return this.addExtra(s2.value, "expressionValue", t2), s2;
    }
    parseBlockBody(e21, ...t2) {
      super.parseBlockBody(e21, ...t2);
      const s2 = e21.directives.map((e22) => this.directiveToStmt(e22));
      e21.body = s2.concat(e21.body), delete e21.directives;
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true), t2.typeParameters && (t2.value.typeParameters = t2.typeParameters, delete t2.typeParameters), e21.body.push(t2);
    }
    parseMaybePrivateName(...e21) {
      const t2 = super.parseMaybePrivateName(...e21);
      return t2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t2) : t2;
    }
    convertPrivateNameToPrivateIdentifier(e21) {
      const t2 = super.getPrivateNameSV(e21);
      return delete (e21 = e21).id, e21.name = t2, e21.type = "PrivateIdentifier", e21;
    }
    isPrivateName(e21) {
      return this.getPluginOption("estree", "classFeatures") ? e21.type === "PrivateIdentifier" : super.isPrivateName(e21);
    }
    getPrivateNameSV(e21) {
      return this.getPluginOption("estree", "classFeatures") ? e21.name : super.getPrivateNameSV(e21);
    }
    parseLiteral(e21, t2) {
      const s2 = super.parseLiteral(e21, t2);
      return s2.raw = s2.extra.raw, delete s2.extra, s2;
    }
    parseFunctionBody(e21, t2, s2 = false) {
      super.parseFunctionBody(e21, t2, s2), e21.expression = e21.body.type !== "BlockStatement";
    }
    parseMethod(e21, t2, s2, r2, i2, a2, n2 = false) {
      let o2 = this.startNode();
      return o2.kind = e21.kind, o2 = super.parseMethod(o2, t2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, e21.value = o2, a2 === "ClassPrivateMethod" && (e21.computed = false), a2 = "MethodDefinition", this.finishNode(e21, a2);
    }
    parseClassProperty(...e21) {
      const t2 = super.parseClassProperty(...e21);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition"), t2;
    }
    parseClassPrivateProperty(...e21) {
      const t2 = super.parseClassPrivateProperty(...e21);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition", t2.computed = false), t2;
    }
    parseObjectMethod(e21, t2, s2, r2, i2) {
      const a2 = super.parseObjectMethod(e21, t2, s2, r2, i2);
      return a2 && (a2.type = "Property", a2.kind === "method" && (a2.kind = "init"), a2.shorthand = false), a2;
    }
    parseObjectProperty(e21, t2, s2, r2, i2) {
      const a2 = super.parseObjectProperty(e21, t2, s2, r2, i2);
      return a2 && (a2.kind = "init", a2.type = "Property"), a2;
    }
    isAssignable(e21, t2) {
      return e21 != null && this.isObjectProperty(e21) ? this.isAssignable(e21.value, t2) : super.isAssignable(e21, t2);
    }
    toAssignable(e21, t2 = false) {
      return e21 != null && this.isObjectProperty(e21) ? (this.toAssignable(e21.value, t2), e21) : super.toAssignable(e21, t2);
    }
    toAssignableObjectExpressionProp(e21, ...t2) {
      e21.kind === "get" || e21.kind === "set" ? this.raise(e21.key.start, Rn$1.PatternHasAccessor) : e21.method ? this.raise(e21.key.start, Rn$1.PatternHasMethod) : super.toAssignableObjectExpressionProp(e21, ...t2);
    }
    finishCallExpression(e21, t2) {
      if (super.finishCallExpression(e21, t2), e21.callee.type === "Import") {
        var s2;
        if (e21.type = "ImportExpression", e21.source = e21.arguments[0], this.hasPlugin("importAssertions"))
          e21.attributes = (s2 = e21.arguments[1]) != null ? s2 : null;
        delete e21.arguments, delete e21.callee;
      }
      return e21;
    }
    toReferencedArguments(e21) {
      e21.type !== "ImportExpression" && super.toReferencedArguments(e21);
    }
    parseExport(e21) {
      switch (super.parseExport(e21), e21.type) {
        case "ExportAllDeclaration":
          e21.exported = null;
          break;
        case "ExportNamedDeclaration":
          e21.specifiers.length === 1 && e21.specifiers[0].type === "ExportNamespaceSpecifier" && (e21.type = "ExportAllDeclaration", e21.exported = e21.specifiers[0].exported, delete e21.specifiers);
      }
      return e21;
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      const a2 = super.parseSubscript(e21, t2, s2, r2, i2);
      if (i2.optionalChainMember) {
        if (a2.type !== "OptionalMemberExpression" && a2.type !== "OptionalCallExpression" || (a2.type = a2.type.substring(8)), i2.stop) {
          const e22 = this.startNodeAtNode(a2);
          return e22.expression = a2, this.finishNode(e22, "ChainExpression");
        }
      } else
        a2.type !== "MemberExpression" && a2.type !== "CallExpression" || (a2.optional = false);
      return a2;
    }
    hasPropertyAsPrivateName(e21) {
      return e21.type === "ChainExpression" && (e21 = e21.expression), super.hasPropertyAsPrivateName(e21);
    }
    isOptionalChain(e21) {
      return e21.type === "ChainExpression";
    }
    isObjectProperty(e21) {
      return e21.type === "Property" && e21.kind === "init" && !e21.method;
    }
    isObjectMethod(e21) {
      return e21.method || e21.kind === "get" || e21.kind === "set";
    }
  }, jsx: (e20) => class extends e20 {
    jsxReadToken() {
      let e21 = "", t2 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, $o.UnterminatedJsxContent);
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? s2 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(s2) : (e21 += this.input.slice(t2, this.state.pos), this.finishToken(bn$1.jsxText, e21));
          case 38:
            e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadEntity(), t2 = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            wn$1(s2) ? (e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadNewLine(true), t2 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e21) {
      const t2 = this.input.charCodeAt(this.state.pos);
      let s2;
      return ++this.state.pos, t2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = e21 ? "\n" : "\r\n") : s2 = String.fromCharCode(t2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
    }
    jsxReadString(e21) {
      let t2 = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === e21)
          break;
        r2 === 38 ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadEntity(), s2 = this.state.pos) : wn$1(r2) ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
      }
      return t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
    }
    jsxReadEntity() {
      let e21, t2 = "", s2 = 0, r2 = this.input[this.state.pos];
      const i2 = ++this.state.pos;
      for (; this.state.pos < this.length && s2++ < 10; ) {
        if (r2 = this.input[this.state.pos++], r2 === ";") {
          t2[0] === "#" ? t2[1] === "x" ? (t2 = t2.substr(2), Uo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 16)))) : (t2 = t2.substr(1), qo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 10)))) : e21 = _o$1[t2];
          break;
        }
        t2 += r2;
      }
      return e21 || (this.state.pos = i2, "&");
    }
    jsxReadWord() {
      let e21;
      const t2 = this.state.pos;
      do {
        e21 = this.input.charCodeAt(++this.state.pos);
      } while (Yn$1(e21) || e21 === 45);
      return this.finishToken(bn$1.jsxName, this.input.slice(t2, this.state.pos));
    }
    jsxParseIdentifier() {
      const e21 = this.startNode();
      return this.match(bn$1.jsxName) ? e21.name = this.state.value : this.state.type.keyword ? e21.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e21, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
      if (!this.eat(bn$1.colon))
        return s2;
      const r2 = this.startNodeAt(e21, t2);
      return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.jsxParseNamespacedName();
      if (s2.type === "JSXNamespacedName")
        return s2;
      for (; this.eat(bn$1.dot); ) {
        const r2 = this.startNodeAt(e21, t2);
        r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
      }
      return s2;
    }
    jsxParseAttributeValue() {
      let e21;
      switch (this.state.type) {
        case bn$1.braceL:
          return e21 = this.startNode(), this.next(), e21 = this.jsxParseExpressionContainer(e21), e21.expression.type === "JSXEmptyExpression" && this.raise(e21.start, $o.AttributeIsEmpty), e21;
        case bn$1.jsxTagStart:
        case bn$1.string:
          return this.parseExprAtom();
        default:
          throw this.raise(this.state.start, $o.UnsupportedJsxValue);
      }
    }
    jsxParseEmptyExpression() {
      const e21 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(e21, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }
    jsxParseSpreadChild(e21) {
      return this.next(), e21.expression = this.parseExpression(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e21) {
      if (this.match(bn$1.braceR))
        e21.expression = this.jsxParseEmptyExpression();
      else {
        const t2 = this.parseExpression();
        e21.expression = t2;
      }
      return this.expect(bn$1.braceR), this.finishNode(e21, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e21 = this.startNode();
      return this.eat(bn$1.braceL) ? (this.expect(bn$1.ellipsis), e21.argument = this.parseMaybeAssignAllowIn(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadAttribute")) : (e21.name = this.jsxParseNamespacedName(), e21.value = this.eat(bn$1.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e21, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
    }
    jsxParseOpeningElementAfterName(e21) {
      const t2 = [];
      for (; !this.match(bn$1.slash) && !this.match(bn$1.jsxTagEnd); )
        t2.push(this.jsxParseAttribute());
      return e21.attributes = t2, e21.selfClosing = this.eat(bn$1.slash), this.expect(bn$1.jsxTagEnd), this.finishNode(e21, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
    }
    jsxParseElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2), r2 = [], i2 = this.jsxParseOpeningElementAt(e21, t2);
      let a2 = null;
      if (!i2.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case bn$1.jsxTagStart:
                if (e21 = this.state.start, t2 = this.state.startLoc, this.next(), this.eat(bn$1.slash)) {
                  a2 = this.jsxParseClosingElementAt(e21, t2);
                  break e;
                }
                r2.push(this.jsxParseElementAt(e21, t2));
                break;
              case bn$1.jsxText:
                r2.push(this.parseExprAtom());
                break;
              case bn$1.braceL: {
                const e22 = this.startNode();
                this.next(), this.match(bn$1.ellipsis) ? r2.push(this.jsxParseSpreadChild(e22)) : r2.push(this.jsxParseExpressionContainer(e22));
                break;
              }
              default:
                throw this.unexpected();
            }
        Ho(i2) && !Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagFragment) : !Ho(i2) && Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name)) : Ho(i2) || Ho(a2) || Vo(a2.name) !== Vo(i2.name) && this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name));
      }
      if (Ho(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
        throw this.raise(this.state.start, $o.UnwrappedAdjacentJSXElements);
      return Ho(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
    }
    jsxParseElement() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e21, t2);
    }
    parseExprAtom(e21) {
      return this.match(bn$1.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(bn$1.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(bn$1.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e21);
    }
    createLookaheadState(e21) {
      const t2 = super.createLookaheadState(e21);
      return t2.inPropertyName = e21.inPropertyName, t2;
    }
    getTokenFromCode(e21) {
      if (this.state.inPropertyName)
        return super.getTokenFromCode(e21);
      const t2 = this.curContext();
      if (t2 === $n$1.j_expr)
        return this.jsxReadToken();
      if (t2 === $n$1.j_oTag || t2 === $n$1.j_cTag) {
        if (Jn$1(e21))
          return this.jsxReadWord();
        if (e21 === 62)
          return ++this.state.pos, this.finishToken(bn$1.jsxTagEnd);
        if ((e21 === 34 || e21 === 39) && t2 === $n$1.j_oTag)
          return this.jsxReadString(e21);
      }
      return e21 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(e21);
    }
    updateContext(e21) {
      super.updateContext(e21);
      const {context: t2, type: s2} = this.state;
      if (s2 === bn$1.slash && e21 === bn$1.jsxTagStart)
        t2.splice(-2, 2, $n$1.j_cTag), this.state.exprAllowed = false;
      else if (s2 === bn$1.jsxTagEnd) {
        const s3 = t2.pop();
        s3 === $n$1.j_oTag && e21 === bn$1.slash || s3 === $n$1.j_cTag ? (t2.pop(), this.state.exprAllowed = t2[t2.length - 1] === $n$1.j_expr) : this.state.exprAllowed = true;
      } else
        !s2.keyword || e21 !== bn$1.dot && e21 !== bn$1.questionDot ? this.state.exprAllowed = s2.beforeExpr : this.state.exprAllowed = false;
    }
  }, flow: (e20) => class extends e20 {
    constructor(...e21) {
      super(...e21), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return lo$1;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e21, t2) {
      return e21 !== bn$1.string && e21 !== bn$1.semi && e21 !== bn$1.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e21, t2);
    }
    addComment(e21) {
      if (this.flowPragma === void 0) {
        const t2 = jo.exec(e21.value);
        if (t2)
          if (t2[1] === "flow")
            this.flowPragma = "flow";
          else {
            if (t2[1] !== "noflow")
              throw new Error("Unexpected flow pragma");
            this.flowPragma = "noflow";
          }
      }
      return super.addComment(e21);
    }
    flowParseTypeInitialiser(e21) {
      const t2 = this.state.inType;
      this.state.inType = true, this.expect(e21 || bn$1.colon);
      const s2 = this.flowParseType();
      return this.state.inType = t2, s2;
    }
    flowParsePredicate() {
      const e21 = this.startNode(), t2 = this.state.start;
      return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t2 + 1 && this.raise(t2, Lo$1.UnexpectedSpaceBetweenModuloChecks), this.eat(bn$1.parenL) ? (e21.value = this.parseExpression(), this.expect(bn$1.parenR), this.finishNode(e21, "DeclaredPredicate")) : this.finishNode(e21, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e21 = this.state.inType;
      this.state.inType = true, this.expect(bn$1.colon);
      let t2 = null, s2 = null;
      return this.match(bn$1.modulo) ? (this.state.inType = e21, s2 = this.flowParsePredicate()) : (t2 = this.flowParseType(), this.state.inType = e21, this.match(bn$1.modulo) && (s2 = this.flowParsePredicate())), [t2, s2];
    }
    flowParseDeclareClass(e21) {
      return this.next(), this.flowParseInterfaceish(e21, true), this.finishNode(e21, "DeclareClass");
    }
    flowParseDeclareFunction(e21) {
      this.next();
      const t2 = e21.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
      this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(bn$1.parenL);
      const i2 = this.flowParseFunctionTypeParams();
      return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(bn$1.parenR), [s2.returnType, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), t2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(t2), this.semicolon(), this.scope.declareName(e21.id.name, 2048, e21.id.start), this.finishNode(e21, "DeclareFunction");
    }
    flowParseDeclare(e21, t2) {
      if (this.match(bn$1._class))
        return this.flowParseDeclareClass(e21);
      if (this.match(bn$1._function))
        return this.flowParseDeclareFunction(e21);
      if (this.match(bn$1._var))
        return this.flowParseDeclareVariable(e21);
      if (this.eatContextual("module"))
        return this.match(bn$1.dot) ? this.flowParseDeclareModuleExports(e21) : (t2 && this.raise(this.state.lastTokStart, Lo$1.NestedDeclareModule), this.flowParseDeclareModule(e21));
      if (this.isContextual("type"))
        return this.flowParseDeclareTypeAlias(e21);
      if (this.isContextual("opaque"))
        return this.flowParseDeclareOpaqueType(e21);
      if (this.isContextual("interface"))
        return this.flowParseDeclareInterface(e21);
      if (this.match(bn$1._export))
        return this.flowParseDeclareExportDeclaration(e21, t2);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e21) {
      return this.next(), e21.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e21.id.name, 5, e21.id.start), this.semicolon(), this.finishNode(e21, "DeclareVariable");
    }
    flowParseDeclareModule(e21) {
      this.scope.enter(0), this.match(bn$1.string) ? e21.id = this.parseExprAtom() : e21.id = this.parseIdentifier();
      const t2 = e21.body = this.startNode(), s2 = t2.body = [];
      for (this.expect(bn$1.braceL); !this.match(bn$1.braceR); ) {
        let e22 = this.startNode();
        this.match(bn$1._import) ? (this.next(), this.isContextual("type") || this.match(bn$1._typeof) || this.raise(this.state.lastTokStart, Lo$1.InvalidNonTypeImportInDeclareModule), this.parseImport(e22)) : (this.expectContextual("declare", Lo$1.UnsupportedStatementInDeclareModule), e22 = this.flowParseDeclare(e22, true)), s2.push(e22);
      }
      this.scope.exit(), this.expect(bn$1.braceR), this.finishNode(t2, "BlockStatement");
      let r2 = null, i2 = false;
      return s2.forEach((e22) => {
        !function(e23) {
          return e23.type === "DeclareExportAllDeclaration" || e23.type === "DeclareExportDeclaration" && (!e23.declaration || e23.declaration.type !== "TypeAlias" && e23.declaration.type !== "InterfaceDeclaration");
        }(e22) ? e22.type === "DeclareModuleExports" && (i2 && this.raise(e22.start, Lo$1.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "ES");
      }), e21.kind = r2 || "CommonJS", this.finishNode(e21, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e21, t2) {
      if (this.expect(bn$1._export), this.eat(bn$1._default))
        return this.match(bn$1._function) || this.match(bn$1._class) ? e21.declaration = this.flowParseDeclare(this.startNode()) : (e21.declaration = this.flowParseType(), this.semicolon()), e21.default = true, this.finishNode(e21, "DeclareExportDeclaration");
      if (this.match(bn$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t2) {
        const e22 = this.state.value, t3 = Ro$1[e22];
        throw this.raise(this.state.start, Lo$1.UnsupportedDeclareExportKind, e22, t3);
      }
      if (this.match(bn$1._var) || this.match(bn$1._function) || this.match(bn$1._class) || this.isContextual("opaque"))
        return e21.declaration = this.flowParseDeclare(this.startNode()), e21.default = false, this.finishNode(e21, "DeclareExportDeclaration");
      if (this.match(bn$1.star) || this.match(bn$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
        return (e21 = this.parseExport(e21)).type === "ExportNamedDeclaration" && (e21.type = "ExportDeclaration", e21.default = false, delete e21.exportKind), e21.type = "Declare" + e21.type, e21;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e21) {
      return this.next(), this.expectContextual("exports"), e21.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e21, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e21) {
      return this.next(), this.flowParseTypeAlias(e21), e21.type = "DeclareTypeAlias", e21;
    }
    flowParseDeclareOpaqueType(e21) {
      return this.next(), this.flowParseOpaqueType(e21, true), e21.type = "DeclareOpaqueType", e21;
    }
    flowParseDeclareInterface(e21) {
      return this.next(), this.flowParseInterfaceish(e21), this.finishNode(e21, "DeclareInterface");
    }
    flowParseInterfaceish(e21, t2 = false) {
      if (e21.id = this.flowParseRestrictedIdentifier(!t2, true), this.scope.declareName(e21.id.name, t2 ? 17 : 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.extends = [], e21.implements = [], e21.mixins = [], this.eat(bn$1._extends))
        do {
          e21.extends.push(this.flowParseInterfaceExtends());
        } while (!t2 && this.eat(bn$1.comma));
      if (this.isContextual("mixins")) {
        this.next();
        do {
          e21.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      if (this.isContextual("implements")) {
        this.next();
        do {
          e21.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      e21.body = this.flowParseObjectType({allowStatic: t2, allowExact: false, allowSpread: false, allowProto: t2, allowInexact: false});
    }
    flowParseInterfaceExtends() {
      const e21 = this.startNode();
      return e21.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterInstantiation() : e21.typeParameters = null, this.finishNode(e21, "InterfaceExtends");
    }
    flowParseInterface(e21) {
      return this.flowParseInterfaceish(e21), this.finishNode(e21, "InterfaceDeclaration");
    }
    checkNotUnderscore(e21) {
      e21 === "_" && this.raise(this.state.start, Lo$1.UnexpectedReservedUnderscore);
    }
    checkReservedType(e21, t2, s2) {
      ko$1.has(e21) && this.raise(t2, s2 ? Lo$1.AssignReservedType : Lo$1.UnexpectedReservedType, e21);
    }
    flowParseRestrictedIdentifier(e21, t2) {
      return this.checkReservedType(this.state.value, this.state.start, t2), this.parseIdentifier(e21);
    }
    flowParseTypeAlias(e21) {
      return e21.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.right = this.flowParseTypeInitialiser(bn$1.eq), this.semicolon(), this.finishNode(e21, "TypeAlias");
    }
    flowParseOpaqueType(e21, t2) {
      return this.expectContextual("type"), e21.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.supertype = null, this.match(bn$1.colon) && (e21.supertype = this.flowParseTypeInitialiser(bn$1.colon)), e21.impltype = null, t2 || (e21.impltype = this.flowParseTypeInitialiser(bn$1.eq)), this.semicolon(), this.finishNode(e21, "OpaqueType");
    }
    flowParseTypeParameter(e21 = false) {
      const t2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
      return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(bn$1.eq) ? (this.eat(bn$1.eq), s2.default = this.flowParseType()) : e21 && this.raise(t2, Lo$1.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e21 = this.state.inType, t2 = this.startNode();
      t2.params = [], this.state.inType = true, this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected();
      let s2 = false;
      do {
        const e22 = this.flowParseTypeParameter(s2);
        t2.params.push(e22), e22.default && (s2 = true), this.isRelational(">") || this.expect(bn$1.comma);
      } while (!this.isRelational(">"));
      return this.expectRelational(">"), this.state.inType = e21, this.finishNode(t2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e21 = this.startNode(), t2 = this.state.inType;
      e21.params = [], this.state.inType = true, this.expectRelational("<");
      const s2 = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
        e21.params.push(this.flowParseType()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e21 = this.startNode(), t2 = this.state.inType;
      for (e21.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
        e21.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e21 = this.startNode();
      if (this.expectContextual("interface"), e21.extends = [], this.eat(bn$1._extends))
        do {
          e21.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      return e21.body = this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false}), this.finishNode(e21, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(bn$1.num) || this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e21, t2, s2) {
      return e21.static = t2, this.lookahead().type === bn$1.colon ? (e21.id = this.flowParseObjectPropertyKey(), e21.key = this.flowParseTypeInitialiser()) : (e21.id = null, e21.key = this.flowParseType()), this.expect(bn$1.bracketR), e21.value = this.flowParseTypeInitialiser(), e21.variance = s2, this.finishNode(e21, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e21, t2) {
      return e21.static = t2, e21.id = this.flowParseObjectPropertyKey(), this.expect(bn$1.bracketR), this.expect(bn$1.bracketR), this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, e21.optional = false, e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start))) : (e21.method = false, this.eat(bn$1.question) && (e21.optional = true), e21.value = this.flowParseTypeInitialiser()), this.finishNode(e21, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e21) {
      for (e21.params = [], e21.rest = null, e21.typeParameters = null, e21.this = null, this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(bn$1.parenL), this.match(bn$1._this) && (e21.this = this.flowParseFunctionTypeParam(true), e21.this.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e21.params.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (e21.rest = this.flowParseFunctionTypeParam(false)), this.expect(bn$1.parenR), e21.returnType = this.flowParseTypeInitialiser(), this.finishNode(e21, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e21, t2) {
      const s2 = this.startNode();
      return e21.static = t2, e21.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(e21, "ObjectTypeCallProperty");
    }
    flowParseObjectType({allowStatic: e21, allowExact: t2, allowSpread: s2, allowProto: r2, allowInexact: i2}) {
      const a2 = this.state.inType;
      this.state.inType = true;
      const n2 = this.startNode();
      let o2, u2;
      n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
      let h2 = false;
      for (t2 && this.match(bn$1.braceBarL) ? (this.expect(bn$1.braceBarL), o2 = bn$1.braceBarR, u2 = true) : (this.expect(bn$1.braceL), o2 = bn$1.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
        let t3 = false, a3 = null, o3 = null;
        const c3 = this.startNode();
        if (r2 && this.isContextual("proto")) {
          const t4 = this.lookahead();
          t4.type !== bn$1.colon && t4.type !== bn$1.question && (this.next(), a3 = this.state.start, e21 = false);
        }
        if (e21 && this.isContextual("static")) {
          const e22 = this.lookahead();
          e22.type !== bn$1.colon && e22.type !== bn$1.question && (this.next(), t3 = true);
        }
        const p2 = this.flowParseVariance();
        if (this.eat(bn$1.bracketL))
          a3 != null && this.unexpected(a3), this.eat(bn$1.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, t3, p2));
        else if (this.match(bn$1.parenL) || this.isRelational("<"))
          a3 != null && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t3));
        else {
          let e22 = "init";
          if (this.isContextual("get") || this.isContextual("set")) {
            const t4 = this.lookahead();
            t4.type !== bn$1.name && t4.type !== bn$1.string && t4.type !== bn$1.num || (e22 = this.state.value, this.next());
          }
          const r3 = this.flowParseObjectTypeProperty(c3, t3, a3, p2, e22, s2, i2 != null ? i2 : !u2);
          r3 === null ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
        }
        this.flowObjectTypeSemicolon(), !o3 || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.raise(o3, Lo$1.UnexpectedExplicitInexactInObject);
      }
      this.expect(o2), s2 && (n2.inexact = h2);
      const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
      return this.state.inType = a2, c2;
    }
    flowParseObjectTypeProperty(e21, t2, s2, r2, i2, a2, n2) {
      if (this.eat(bn$1.ellipsis)) {
        return this.match(bn$1.comma) || this.match(bn$1.semi) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Lo$1.InexactInsideExact) : this.raise(this.state.lastTokStart, Lo$1.InexactInsideNonObject), r2 && this.raise(r2.start, Lo$1.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Lo$1.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Lo$1.SpreadVariance), e21.argument = this.flowParseType(), this.finishNode(e21, "ObjectTypeSpreadProperty"));
      }
      {
        e21.key = this.flowParseObjectPropertyKey(), e21.static = t2, e21.proto = s2 != null, e21.kind = i2;
        let n3 = false;
        return this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(e21), !a2 && e21.key.name === "constructor" && e21.value.this && this.raise(e21.value.this.start, Lo$1.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), e21.method = false, this.eat(bn$1.question) && (n3 = true), e21.value = this.flowParseTypeInitialiser(), e21.variance = r2), e21.optional = n3, this.finishNode(e21, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e21) {
      const t2 = e21.kind === "get" ? 0 : 1, s2 = e21.start, r2 = e21.value.params.length + (e21.value.rest ? 1 : 0);
      e21.value.this && this.raise(e21.value.this.start, e21.kind === "get" ? Lo$1.GetterMayNotHaveThisParam : Lo$1.SetterMayNotHaveThisParam), r2 !== t2 && (e21.kind === "get" ? this.raise(s2, Rn$1.BadGetterArity) : this.raise(s2, Rn$1.BadSetterArity)), e21.kind === "set" && e21.value.rest && this.raise(s2, Rn$1.BadSetterRestParameter);
    }
    flowObjectTypeSemicolon() {
      this.eat(bn$1.semi) || this.eat(bn$1.comma) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e21, t2, s2) {
      e21 = e21 || this.state.start, t2 = t2 || this.state.startLoc;
      let r2 = s2 || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(bn$1.dot); ) {
        const s3 = this.startNodeAt(e21, t2);
        s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
      }
      return r2;
    }
    flowParseGenericType(e21, t2, s2) {
      const r2 = this.startNodeAt(e21, t2);
      return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(e21, t2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e21 = this.startNode();
      return this.expect(bn$1._typeof), e21.argument = this.flowParsePrimaryType(), this.finishNode(e21, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e21 = this.startNode();
      for (e21.types = [], this.expect(bn$1.bracketL); this.state.pos < this.length && !this.match(bn$1.bracketR) && (e21.types.push(this.flowParseType()), !this.match(bn$1.bracketR)); )
        this.expect(bn$1.comma);
      return this.expect(bn$1.bracketR), this.finishNode(e21, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e21) {
      let t2 = null, s2 = false, r2 = null;
      const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === bn$1._this;
      return a2.type === bn$1.colon || a2.type === bn$1.question ? (n2 && !e21 && this.raise(i2.start, Lo$1.ThisParamMustBeFirst), t2 = this.parseIdentifier(n2), this.eat(bn$1.question) && (s2 = true, n2 && this.raise(i2.start, Lo$1.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = t2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e21) {
      const t2 = this.startNodeAt(e21.start, e21.loc.start);
      return t2.name = null, t2.optional = false, t2.typeAnnotation = e21, this.finishNode(t2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e21 = []) {
      let t2 = null, s2 = null;
      for (this.match(bn$1._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e21.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (t2 = this.flowParseFunctionTypeParam(false)), {params: e21, rest: t2, _this: s2};
    }
    flowIdentToTypeAnnotation(e21, t2, s2, r2) {
      switch (r2.name) {
        case "any":
          return this.finishNode(s2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s2, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r2.name), this.flowParseGenericType(e21, t2, r2);
      }
    }
    flowParsePrimaryType() {
      const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.startNode();
      let r2, i2, a2 = false;
      const n2 = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case bn$1.name:
          return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e21, t2, s2, this.parseIdentifier());
        case bn$1.braceL:
          return this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true});
        case bn$1.braceBarL:
          return this.flowParseObjectType({allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false});
        case bn$1.bracketL:
          return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
        case bn$1.relational:
          if (this.state.value === "<")
            return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(bn$1.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
          break;
        case bn$1.parenL:
          if (this.next(), !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis))
            if (this.match(bn$1.name) || this.match(bn$1._this)) {
              const e22 = this.lookahead().type;
              a2 = e22 !== bn$1.question && e22 !== bn$1.colon;
            } else
              a2 = true;
          if (a2) {
            if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(bn$1.comma) || this.match(bn$1.parenR) && this.lookahead().type === bn$1.arrow))
              return this.expect(bn$1.parenR), i2;
            this.eat(bn$1.comma);
          }
          return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
        case bn$1.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case bn$1._true:
        case bn$1._false:
          return s2.value = this.match(bn$1._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
        case bn$1.plusMin:
          if (this.state.value === "-") {
            if (this.next(), this.match(bn$1.num))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
            if (this.match(bn$1.bigint))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
            throw this.raise(this.state.start, Lo$1.UnexpectedSubtractionOperand);
          }
          throw this.unexpected();
        case bn$1.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case bn$1.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case bn$1._void:
          return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
        case bn$1._null:
          return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
        case bn$1._this:
          return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
        case bn$1.star:
          return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
        default:
          if (this.state.type.keyword === "typeof")
            return this.flowParseTypeofType();
          if (this.state.type.keyword) {
            const e22 = this.state.type.label;
            return this.next(), super.createIdentifier(s2, e22);
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.flowParsePrimaryType(), r2 = false;
      for (; (this.match(bn$1.bracketL) || this.match(bn$1.questionDot)) && !this.canInsertSemicolon(); ) {
        const i2 = this.startNodeAt(e21, t2), a2 = this.eat(bn$1.questionDot);
        r2 = r2 || a2, this.expect(bn$1.bracketL), !a2 && this.match(bn$1.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(bn$1.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
      }
      return s2;
    }
    flowParsePrefixType() {
      const e21 = this.startNode();
      return this.eat(bn$1.question) ? (e21.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e21, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e21 = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(bn$1.arrow)) {
        const t2 = this.startNodeAt(e21.start, e21.loc.start);
        return t2.params = [this.reinterpretTypeAsFunctionTypeParam(e21)], t2.rest = null, t2.this = null, t2.returnType = this.flowParseType(), t2.typeParameters = null, this.finishNode(t2, "FunctionTypeAnnotation");
      }
      return e21;
    }
    flowParseIntersectionType() {
      const e21 = this.startNode();
      this.eat(bn$1.bitwiseAND);
      const t2 = this.flowParseAnonFunctionWithoutParens();
      for (e21.types = [t2]; this.eat(bn$1.bitwiseAND); )
        e21.types.push(this.flowParseAnonFunctionWithoutParens());
      return e21.types.length === 1 ? t2 : this.finishNode(e21, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e21 = this.startNode();
      this.eat(bn$1.bitwiseOR);
      const t2 = this.flowParseIntersectionType();
      for (e21.types = [t2]; this.eat(bn$1.bitwiseOR); )
        e21.types.push(this.flowParseIntersectionType());
      return e21.types.length === 1 ? t2 : this.finishNode(e21, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e21 = this.state.inType;
      this.state.inType = true;
      const t2 = this.flowParseUnionType();
      return this.state.inType = e21, t2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === bn$1.name && this.state.value === "_") {
        const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.parseIdentifier();
        return this.flowParseGenericType(e21, t2, s2);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e21 = this.startNode();
      return e21.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e21, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e21) {
      const t2 = e21 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(bn$1.colon) && (t2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t2)), t2;
    }
    typeCastToParameter(e21) {
      return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
    }
    flowParseVariance() {
      let e21 = null;
      return this.match(bn$1.plusMin) && (e21 = this.startNode(), this.state.value === "+" ? e21.kind = "plus" : e21.kind = "minus", this.next(), this.finishNode(e21, "Variance")), e21;
    }
    parseFunctionBody(e21, t2, s2 = false) {
      return t2 ? this.forwardNoArrowParamsConversionAt(e21, () => super.parseFunctionBody(e21, true, s2)) : super.parseFunctionBody(e21, false, s2);
    }
    parseFunctionBodyAndFinish(e21, t2, s2 = false) {
      if (this.match(bn$1.colon)) {
        const t3 = this.startNode();
        [t3.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), e21.returnType = t3.typeAnnotation ? this.finishNode(t3, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e21, t2, s2);
    }
    parseStatement(e21, t2) {
      if (this.state.strict && this.match(bn$1.name) && this.state.value === "interface") {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name || oo$1(e22.value)) {
          const e23 = this.startNode();
          return this.next(), this.flowParseInterface(e23);
        }
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e22 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e22);
      }
      const s2 = super.parseStatement(e21, t2);
      return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
    }
    parseExpressionStatement(e21, t2) {
      if (t2.type === "Identifier") {
        if (t2.name === "declare") {
          if (this.match(bn$1._class) || this.match(bn$1.name) || this.match(bn$1._function) || this.match(bn$1._var) || this.match(bn$1._export))
            return this.flowParseDeclare(e21);
        } else if (this.match(bn$1.name)) {
          if (t2.name === "interface")
            return this.flowParseInterface(e21);
          if (t2.name === "type")
            return this.flowParseTypeAlias(e21);
          if (t2.name === "opaque")
            return this.flowParseOpaqueType(e21, false);
        }
      }
      return super.parseExpressionStatement(e21, t2);
    }
    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      return (!this.match(bn$1.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e21 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e21);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e21, t2, s2, r2) {
      if (!this.match(bn$1.question))
        return e21;
      if (this.state.maybeInArrowParameters) {
        const t3 = this.lookaheadCharCode();
        if (t3 === 44 || t3 === 61 || t3 === 58 || t3 === 41)
          return this.setOptionalParametersError(r2), e21;
      }
      this.expect(bn$1.question);
      const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(t2, s2);
      let {consequent: o2, failed: u2} = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
      if (u2 || c2.length > 0) {
        const e22 = [...a2];
        if (c2.length > 0) {
          this.state = i2, this.state.noArrowAt = e22;
          for (let t3 = 0; t3 < c2.length; t3++)
            e22.push(c2[t3].start);
          ({consequent: o2, failed: u2} = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
        }
        u2 && h2.length > 1 && this.raise(i2.start, Lo$1.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, e22.push(h2[0].start), this.state.noArrowAt = e22, {consequent: o2, failed: u2} = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(bn$1.colon), n2.test = e21, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e21 = this.parseMaybeAssignAllowIn(), t2 = !this.match(bn$1.colon);
      return this.state.noArrowParamsConversionAt.pop(), {consequent: e21, failed: t2};
    }
    getArrowLikeExpressions(e21, t2) {
      const s2 = [e21], r2 = [];
      for (; s2.length !== 0; ) {
        const e22 = s2.pop();
        e22.type === "ArrowFunctionExpression" ? (e22.typeParameters || !e22.returnType ? this.finishArrowValidation(e22) : r2.push(e22), s2.push(e22.body)) : e22.type === "ConditionalExpression" && (s2.push(e22.consequent), s2.push(e22.alternate));
      }
      return t2 ? (r2.forEach((e22) => this.finishArrowValidation(e22)), [r2, []]) : function(e22, t3) {
        const s3 = [], r3 = [];
        for (let i2 = 0; i2 < e22.length; i2++)
          (t3(e22[i2], i2, e22) ? s3 : r3).push(e22[i2]);
        return [s3, r3];
      }(r2, (e22) => e22.params.every((e23) => this.isAssignable(e23, true)));
    }
    finishArrowValidation(e21) {
      var t2;
      this.toAssignableList(e21.params, (t2 = e21.extra) == null ? void 0 : t2.trailingComma, false), this.scope.enter(6), super.checkParams(e21, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e21, t2) {
      let s2;
      return this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = t2(), this.state.noArrowParamsConversionAt.pop()) : s2 = t2(), s2;
    }
    parseParenItem(e21, t2, s2) {
      if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e21, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
      }
      return e21;
    }
    assertModuleNodeAllowed(e21) {
      e21.type === "ImportDeclaration" && (e21.importKind === "type" || e21.importKind === "typeof") || e21.type === "ExportNamedDeclaration" && e21.exportKind === "type" || e21.type === "ExportAllDeclaration" && e21.exportKind === "type" || super.assertModuleNodeAllowed(e21);
    }
    parseExport(e21) {
      const t2 = super.parseExport(e21);
      return t2.type !== "ExportNamedDeclaration" && t2.type !== "ExportAllDeclaration" || (t2.exportKind = t2.exportKind || "value"), t2;
    }
    parseExportDeclaration(e21) {
      if (this.isContextual("type")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.match(bn$1.braceL) ? (e21.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e21), null) : this.flowParseTypeAlias(t2);
      }
      if (this.isContextual("opaque")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseOpaqueType(t2, false);
      }
      if (this.isContextual("interface")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseInterface(t2);
      }
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        e21.exportKind = "value";
        const t2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t2);
      }
      return super.parseExportDeclaration(e21);
    }
    eatExportStar(e21) {
      return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== bn$1.star) && (e21.exportKind = "type", this.next(), this.next(), true);
    }
    maybeParseExportNamespaceSpecifier(e21) {
      const t2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(e21);
      return s2 && e21.exportKind === "type" && this.unexpected(t2), s2;
    }
    parseClassId(e21, t2, s2) {
      super.parseClassId(e21, t2, s2), this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e21, t2, s2) {
      const r2 = this.state.start;
      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(e21, t2))
          return;
        t2.declare = true;
      }
      super.parseClassMember(e21, t2, s2), t2.declare && (t2.type !== "ClassProperty" && t2.type !== "ClassPrivateProperty" && t2.type !== "PropertyDefinition" ? this.raise(r2, Lo$1.DeclareClassElement) : t2.value && this.raise(t2.value.start, Lo$1.DeclareClassFieldInitializer));
    }
    isIterator(e21) {
      return e21 === "iterator" || e21 === "asyncIterator";
    }
    readIterator() {
      const e21 = super.readWord1(), t2 = "@@" + e21;
      this.isIterator(e21) && this.state.inType || this.raise(this.state.pos, Rn$1.InvalidIdentifier, t2), this.finishToken(bn$1.name, t2);
    }
    getTokenFromCode(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      return e21 === 123 && t2 === 124 ? this.finishOp(bn$1.braceBarL, 2) : !this.state.inType || e21 !== 62 && e21 !== 60 ? this.state.inType && e21 === 63 ? t2 === 46 ? this.finishOp(bn$1.questionDot, 2) : this.finishOp(bn$1.question, 1) : function(e22, t3) {
        return e22 === 64 && t3 === 64;
      }(e21, t2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
    }
    isAssignable(e21, t2) {
      return e21.type === "TypeCastExpression" ? this.isAssignable(e21.expression, t2) : super.isAssignable(e21, t2);
    }
    toAssignable(e21, t2 = false) {
      return e21.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e21), t2) : super.toAssignable(e21, t2);
    }
    toAssignableList(e21, t2, s2) {
      for (let t3 = 0; t3 < e21.length; t3++) {
        const s3 = e21[t3];
        (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (e21[t3] = this.typeCastToParameter(s3));
      }
      return super.toAssignableList(e21, t2, s2);
    }
    toReferencedList(e21, t2) {
      for (let r2 = 0; r2 < e21.length; r2++) {
        var s2;
        const i2 = e21[r2];
        !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(e21.length > 1) && t2 || this.raise(i2.typeAnnotation.start, Lo$1.TypeCastInPattern);
      }
      return e21;
    }
    parseArrayLike(e21, t2, s2, r2) {
      const i2 = super.parseArrayLike(e21, t2, s2, r2);
      return t2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
    }
    checkLVal(e21, ...t2) {
      if (e21.type !== "TypeCastExpression")
        return super.checkLVal(e21, ...t2);
    }
    parseClassProperty(e21) {
      return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e21);
    }
    parseClassPrivateProperty(e21) {
      return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e21);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.colon) || super.isClassProperty();
    }
    isNonstaticConstructor(e21) {
      return !this.match(bn$1.colon) && super.isNonstaticConstructor(e21);
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      if (t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e21, t2, s2, r2, i2, a2), t2.params && i2) {
        const e22 = t2.params;
        e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      } else if (t2.type === "MethodDefinition" && i2 && t2.value.params) {
        const e22 = t2.value.params;
        e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      }
    }
    pushClassPrivateMethod(e21, t2, s2, r2) {
      t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e21, t2, s2, r2);
    }
    parseClassSuper(e21) {
      if (super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
        this.next();
        const t2 = e21.implements = [];
        do {
          const e22 = this.startNode();
          e22.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e22.typeParameters = this.flowParseTypeParameterInstantiation() : e22.typeParameters = null, t2.push(this.finishNode(e22, "ClassImplements"));
        } while (this.eat(bn$1.comma));
      }
    }
    checkGetterSetterParams(e21) {
      super.checkGetterSetterParams(e21);
      const t2 = this.getObjectOrClassMethodParams(e21);
      if (t2.length > 0) {
        const s2 = t2[0];
        this.isThisParam(s2) && e21.kind === "get" ? this.raise(s2.start, Lo$1.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Lo$1.SetterMayNotHaveThisParam);
      }
    }
    parsePropertyName(e21, t2) {
      const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(e21, t2);
      return e21.variance = s2, r2;
    }
    parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2) {
      let u2;
      e21.variance && this.unexpected(e21.variance.start), delete e21.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(bn$1.parenL) || this.unexpected()), super.parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2), u2 && ((e21.value || e21).typeParameters = u2);
    }
    parseAssignableListItemTypes(e21) {
      return this.eat(bn$1.question) && (e21.type !== "Identifier" && this.raise(e21.start, Lo$1.PatternIsOptional), this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamMayNotBeOptional), e21.optional = true), this.match(bn$1.colon) ? e21.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamAnnotationRequired), this.match(bn$1.eq) && this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamNoDefault), this.resetEndLocation(e21), e21;
    }
    parseMaybeDefault(e21, t2, s2) {
      const r2 = super.parseMaybeDefault(e21, t2, s2);
      return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Lo$1.TypeBeforeInitializer), r2;
    }
    shouldParseDefaultImport(e21) {
      return Oo$1(e21) ? Mo(this.state) : super.shouldParseDefaultImport(e21);
    }
    parseImportSpecifierLocal(e21, t2, s2, r2) {
      t2.local = Oo$1(e21) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e21.specifiers.push(this.finishNode(t2, s2));
    }
    maybeParseDefaultImportSpecifier(e21) {
      e21.importKind = "value";
      let t2 = null;
      if (this.match(bn$1._typeof) ? t2 = "typeof" : this.isContextual("type") && (t2 = "type"), t2) {
        const s2 = this.lookahead();
        t2 === "type" && s2.type === bn$1.star && this.unexpected(s2.start), (Mo(s2) || s2.type === bn$1.braceL || s2.type === bn$1.star) && (this.next(), e21.importKind = t2);
      }
      return super.maybeParseDefaultImportSpecifier(e21);
    }
    parseImportSpecifier(e21) {
      const t2 = this.startNode(), s2 = this.match(bn$1.string), r2 = this.parseModuleExportName();
      let i2 = null;
      r2.type === "Identifier" && (r2.name === "type" ? i2 = "type" : r2.name === "typeof" && (i2 = "typeof"));
      let a2 = false;
      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const e22 = this.parseIdentifier(true);
        i2 === null || this.match(bn$1.name) || this.state.type.keyword ? (t2.imported = r2, t2.importKind = null, t2.local = this.parseIdentifier()) : (t2.imported = e22, t2.importKind = i2, t2.local = Io$1(e22));
      } else {
        if (i2 !== null && (this.match(bn$1.name) || this.state.type.keyword))
          t2.imported = this.parseIdentifier(true), t2.importKind = i2;
        else {
          if (s2)
            throw this.raise(t2.start, Rn$1.ImportBindingIsString, r2.value);
          t2.imported = r2, t2.importKind = null;
        }
        this.eatContextual("as") ? t2.local = this.parseIdentifier() : (a2 = true, t2.local = Io$1(t2.imported));
      }
      const n2 = Oo$1(e21), o2 = Oo$1(t2);
      n2 && o2 && this.raise(t2.start, Lo$1.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(t2.local.name, t2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(t2.local.name, t2.start, true, true), this.checkLVal(t2.local, "import specifier", 9), e21.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e21, t2) {
      const s2 = e21.kind;
      s2 !== "get" && s2 !== "set" && this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e21, t2);
    }
    parseVarId(e21, t2) {
      super.parseVarId(e21, t2), this.match(bn$1.colon) && (e21.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e21.id));
    }
    parseAsyncArrowFromCallExpression(e21, t2) {
      if (this.match(bn$1.colon)) {
        const t3 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e21.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t3;
      }
      return super.parseAsyncArrowFromCallExpression(e21, t2);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e21, t2) {
      var s2;
      let r2, i2 = null;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(e21, t2), i2), !r2.error)
          return r2.node;
        const {context: s3} = this.state, a3 = s3[s3.length - 1];
        a3 === $n$1.j_oTag ? s3.length -= 2 : a3 === $n$1.j_expr && (s3.length -= 1);
      }
      if ((s2 = r2) != null && s2.error || this.isRelational("<")) {
        var a2, n2;
        let s3;
        i2 = i2 || this.state.clone();
        const o2 = this.tryParse((r3) => {
          var i3;
          s3 = this.flowParseTypeParameterDeclaration();
          const a3 = this.forwardNoArrowParamsConversionAt(s3, () => {
            const r4 = super.parseMaybeAssign(e21, t2);
            return this.resetStartLocationFromNode(r4, s3), r4;
          });
          (i3 = a3.extra) != null && i3.parenthesized && r3();
          const n3 = this.maybeUnwrapTypeCastExpression(a3);
          return n3.type !== "ArrowFunctionExpression" && r3(), n3.typeParameters = s3, this.resetStartLocationFromNode(n3, s3), a3;
        }, i2);
        let u2 = null;
        if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
          if (!o2.error && !o2.aborted)
            return o2.node.async && this.raise(s3.start, Lo$1.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
          u2 = o2.node;
        }
        if ((a2 = r2) != null && a2.node)
          return this.state = r2.failState, r2.node;
        if (u2)
          return this.state = o2.failState, u2;
        if ((n2 = r2) != null && n2.thrown)
          throw r2.error;
        if (o2.thrown)
          throw o2.error;
        throw this.raise(s3.start, Lo$1.UnexpectedTokenAfterTypeParameter);
      }
      return super.parseMaybeAssign(e21, t2);
    }
    parseArrow(e21) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse(() => {
          const t3 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const s2 = this.startNode();
          return [s2.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t3, this.canInsertSemicolon() && this.unexpected(), this.match(bn$1.arrow) || this.unexpected(), s2;
        });
        if (t2.thrown)
          return null;
        t2.error && (this.state = t2.failState), e21.returnType = t2.node.typeAnnotation ? this.finishNode(t2.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e21);
    }
    shouldParseArrow(e21) {
      return this.match(bn$1.colon) || super.shouldParseArrow(e21);
    }
    setArrowFunctionParameters(e21, t2) {
      this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? e21.params = t2 : super.setArrowFunctionParameters(e21, t2);
    }
    checkParams(e21, t2, s2) {
      if (!s2 || this.state.noArrowParamsConversionAt.indexOf(e21.start) === -1) {
        for (let t3 = 0; t3 < e21.params.length; t3++)
          this.isThisParam(e21.params[t3]) && t3 > 0 && this.raise(e21.params[t3].start, Lo$1.ThisParamMustBeFirst);
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e21) {
      return super.parseParenAndDistinguishExpression(e21 && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e21, t2, s2, r2) {
      if (e21.type === "Identifier" && e21.name === "async" && this.state.noArrowAt.indexOf(t2) !== -1) {
        this.next();
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e21, r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), e21 = this.finishNode(r3, "CallExpression");
      } else if (e21.type === "Identifier" && e21.name === "async" && this.isRelational("<")) {
        const i2 = this.state.clone(), a2 = this.tryParse((e22) => this.parseAsyncArrowWithTypeParameters(t2, s2) || e22(), i2);
        if (!a2.error && !a2.aborted)
          return a2.node;
        const n2 = this.tryParse(() => super.parseSubscripts(e21, t2, s2, r2), i2);
        if (n2.node && !n2.error)
          return n2.node;
        if (a2.node)
          return this.state = a2.failState, a2.node;
        if (n2.node)
          return this.state = n2.failState, n2.node;
        throw a2.error || n2.error;
      }
      return super.parseSubscripts(e21, t2, s2, r2);
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      if (this.match(bn$1.questionDot) && this.isLookaheadToken_lt()) {
        if (i2.optionalChainMember = true, r2)
          return i2.stop = true, e21;
        this.next();
        const a2 = this.startNodeAt(t2, s2);
        return a2.callee = e21, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(bn$1.parenL), a2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
      }
      if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e21;
        const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(bn$1.parenL), r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
        if (a2.node)
          return a2.error && (this.state = a2.failState), a2.node;
      }
      return super.parseSubscript(e21, t2, s2, r2, i2);
    }
    parseNewArguments(e21) {
      let t2 = null;
      this.shouldParseTypes() && this.isRelational("<") && (t2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e21.typeArguments = t2, super.parseNewArguments(e21);
    }
    parseAsyncArrowWithTypeParameters(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      if (this.parseFunctionParams(s2), this.parseArrow(s2))
        return this.parseArrowExpression(s2, void 0, true);
    }
    readToken_mult_modulo(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (e21 === 42 && t2 === 47 && this.state.hasFlowComment)
        return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(e21);
    }
    readToken_pipe_amp(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      e21 !== 124 || t2 !== 125 ? super.readToken_pipe_amp(e21) : this.finishOp(bn$1.braceBarR, 2);
    }
    parseTopLevel(e21, t2) {
      const s2 = super.parseTopLevel(e21, t2);
      return this.state.hasFlowComment && this.raise(this.state.pos, Lo$1.UnterminatedFlowComment), s2;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment())
        return this.state.hasFlowComment && this.unexpected(null, Lo$1.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
      if (!this.state.hasFlowComment)
        return super.skipBlockComment();
      {
        const e21 = this.input.indexOf("*-/", this.state.pos += 2);
        if (e21 === -1)
          throw this.raise(this.state.pos - 2, Rn$1.UnterminatedComment);
        this.state.pos = e21 + 3;
      }
    }
    skipFlowComment() {
      const {pos: e21} = this.state;
      let t2 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e21 + t2)); )
        t2++;
      const s2 = this.input.charCodeAt(t2 + e21), r2 = this.input.charCodeAt(t2 + e21 + 1);
      return s2 === 58 && r2 === 58 ? t2 + 2 : this.input.slice(t2 + e21, t2 + e21 + 12) === "flow-include" ? t2 + 12 : s2 === 58 && r2 !== 58 && t2;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(this.state.pos, Rn$1.UnterminatedComment);
    }
    flowEnumErrorBooleanMemberNotInitialized(e21, {enumName: t2, memberName: s2}) {
      this.raise(e21, Lo$1.EnumBooleanMemberNotInitialized, s2, t2);
    }
    flowEnumErrorInvalidMemberName(e21, {enumName: t2, memberName: s2}) {
      const r2 = s2[0].toUpperCase() + s2.slice(1);
      this.raise(e21, Lo$1.EnumInvalidMemberName, s2, r2, t2);
    }
    flowEnumErrorDuplicateMemberName(e21, {enumName: t2, memberName: s2}) {
      this.raise(e21, Lo$1.EnumDuplicateMemberName, s2, t2);
    }
    flowEnumErrorInconsistentMemberValues(e21, {enumName: t2}) {
      this.raise(e21, Lo$1.EnumInconsistentMemberValues, t2);
    }
    flowEnumErrorInvalidExplicitType(e21, {enumName: t2, suppliedType: s2}) {
      return this.raise(e21, s2 === null ? Lo$1.EnumInvalidExplicitTypeUnknownSupplied : Lo$1.EnumInvalidExplicitType, t2, s2);
    }
    flowEnumErrorInvalidMemberInitializer(e21, {enumName: t2, explicitType: s2, memberName: r2}) {
      let i2 = null;
      switch (s2) {
        case "boolean":
        case "number":
        case "string":
          i2 = Lo$1.EnumInvalidMemberInitializerPrimaryType;
          break;
        case "symbol":
          i2 = Lo$1.EnumInvalidMemberInitializerSymbolType;
          break;
        default:
          i2 = Lo$1.EnumInvalidMemberInitializerUnknownType;
      }
      return this.raise(e21, i2, t2, r2, s2);
    }
    flowEnumErrorNumberMemberNotInitialized(e21, {enumName: t2, memberName: s2}) {
      this.raise(e21, Lo$1.EnumNumberMemberNotInitialized, t2, s2);
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e21, {enumName: t2}) {
      this.raise(e21, Lo$1.EnumStringMemberInconsistentlyInitailized, t2);
    }
    flowEnumMemberInit() {
      const e21 = this.state.start, t2 = () => this.match(bn$1.comma) || this.match(bn$1.braceR);
      switch (this.state.type) {
        case bn$1.num: {
          const s2 = this.parseNumericLiteral(this.state.value);
          return t2() ? {type: "number", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
        }
        case bn$1.string: {
          const s2 = this.parseStringLiteral(this.state.value);
          return t2() ? {type: "string", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
        }
        case bn$1._true:
        case bn$1._false: {
          const s2 = this.parseBooleanLiteral(this.match(bn$1._true));
          return t2() ? {type: "boolean", pos: s2.start, value: s2} : {type: "invalid", pos: e21};
        }
        default:
          return {type: "invalid", pos: e21};
      }
    }
    flowEnumMemberRaw() {
      const e21 = this.state.start;
      return {id: this.parseIdentifier(true), init: this.eat(bn$1.eq) ? this.flowEnumMemberInit() : {type: "none", pos: e21}};
    }
    flowEnumCheckExplicitTypeMismatch(e21, t2, s2) {
      const {explicitType: r2} = t2;
      r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(e21, t2);
    }
    flowEnumMembers({enumName: e21, explicitType: t2}) {
      const s2 = new Set(), r2 = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []};
      let i2 = false;
      for (; !this.match(bn$1.braceR); ) {
        if (this.eat(bn$1.ellipsis)) {
          i2 = true;
          break;
        }
        const a2 = this.startNode(), {id: n2, init: o2} = this.flowEnumMemberRaw(), u2 = n2.name;
        if (u2 === "")
          continue;
        /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, {enumName: e21, memberName: u2}), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, {enumName: e21, memberName: u2}), s2.add(u2);
        const h2 = {enumName: e21, explicitType: t2, memberName: u2};
        switch (a2.id = n2, o2.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
          case "none":
            switch (t2) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
                break;
              default:
                r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
            }
        }
        this.match(bn$1.braceR) || this.expect(bn$1.comma);
      }
      return {members: r2, hasUnknownMembers: i2};
    }
    flowEnumStringMembers(e21, t2, {enumName: s2}) {
      if (e21.length === 0)
        return t2;
      if (t2.length === 0)
        return e21;
      if (t2.length > e21.length) {
        for (const t3 of e21)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(t3.start, {enumName: s2});
        return t2;
      }
      for (const e22 of t2)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(e22.start, {enumName: s2});
      return e21;
    }
    flowEnumParseExplicitType({enumName: e21}) {
      if (this.eatContextual("of")) {
        if (!this.match(bn$1.name))
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: e21, suppliedType: null});
        const {value: t2} = this.state;
        return this.next(), t2 !== "boolean" && t2 !== "number" && t2 !== "string" && t2 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: e21, suppliedType: t2}), t2;
      }
      return null;
    }
    flowEnumBody(e21, {enumName: t2, nameLoc: s2}) {
      const r2 = this.flowEnumParseExplicitType({enumName: t2});
      this.expect(bn$1.braceL);
      const {members: i2, hasUnknownMembers: a2} = this.flowEnumMembers({enumName: t2, explicitType: r2});
      switch (e21.hasUnknownMembers = a2, r2) {
        case "boolean":
          return e21.explicitType = true, e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
        case "number":
          return e21.explicitType = true, e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
        case "string":
          return e21.explicitType = true, e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {enumName: t2}), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
        case "symbol":
          return e21.members = i2.defaultedMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumSymbolBody");
        default: {
          const r3 = () => (e21.members = [], this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody"));
          e21.explicitType = false;
          const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
          if (a3 || n2 || o2 || u2) {
            if (a3 || n2) {
              if (!n2 && !o2 && a3 >= u2) {
                for (const e22 of i2.defaultedMembers)
                  this.flowEnumErrorBooleanMemberNotInitialized(e22.start, {enumName: t2, memberName: e22.id.name});
                return e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
              }
              if (!a3 && !o2 && n2 >= u2) {
                for (const e22 of i2.defaultedMembers)
                  this.flowEnumErrorNumberMemberNotInitialized(e22.start, {enumName: t2, memberName: e22.id.name});
                return e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
              }
              return this.flowEnumErrorInconsistentMemberValues(s2, {enumName: t2}), r3();
            }
            return e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {enumName: t2}), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
          }
          return r3();
        }
      }
    }
    flowParseEnumDeclaration(e21) {
      const t2 = this.parseIdentifier();
      return e21.id = t2, e21.body = this.flowEnumBody(this.startNode(), {enumName: t2.name, nameLoc: t2.start}), this.finishNode(e21, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e21 = this.nextTokenStart();
      if (this.input.charCodeAt(e21) === 60) {
        const t2 = this.input.charCodeAt(e21 + 1);
        return t2 !== 60 && t2 !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e21) {
      return e21.type === "TypeCastExpression" ? e21.expression : e21;
    }
  }, typescript: (e20) => class extends e20 {
    getScopeHandler() {
      return Wo;
    }
    tsIsIdentifier() {
      return this.match(bn$1.name);
    }
    tsTokenCanFollowModifier() {
      return (this.match(bn$1.bracketL) || this.match(bn$1.braceL) || this.match(bn$1.star) || this.match(bn$1.ellipsis) || this.match(bn$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e21, t2) {
      if (!this.match(bn$1.name))
        return;
      const s2 = this.state.value;
      if (e21.indexOf(s2) !== -1) {
        if (t2 && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return s2;
      }
    }
    tsParseModifiers(e21, t2, s2, r2, i2) {
      const a2 = (t3, s3, r3, i3) => {
        s3 === r3 && e21[i3] && this.raise(t3, Xo.InvalidModifiersOrder, r3, i3);
      }, n2 = (t3, s3, r3, i3) => {
        (e21[r3] && s3 === i3 || e21[i3] && s3 === r3) && this.raise(t3, Xo.IncompatibleModifiers, r3, i3);
      };
      for (; ; ) {
        const o2 = this.state.start, u2 = this.tsParseModifier(t2.concat(s2 != null ? s2 : []), i2);
        if (!u2)
          break;
        Jo(u2) ? e21.accessibility ? this.raise(o2, Xo.DuplicateAccessibilityModifier) : (a2(o2, u2, u2, "override"), a2(o2, u2, u2, "static"), a2(o2, u2, u2, "readonly"), e21.accessibility = u2) : (Object.hasOwnProperty.call(e21, u2) ? this.raise(o2, Xo.DuplicateModifier, u2) : (a2(o2, u2, "static", "readonly"), a2(o2, u2, "static", "override"), a2(o2, u2, "override", "readonly"), a2(o2, u2, "abstract", "override"), n2(o2, u2, "declare", "override"), n2(o2, u2, "static", "abstract")), e21[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
      }
    }
    tsIsListTerminator(e21) {
      switch (e21) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(bn$1.braceR);
        case "HeritageClauseElement":
          return this.match(bn$1.braceL);
        case "TupleElementTypes":
          return this.match(bn$1.bracketR);
        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }
      throw new Error("Unreachable");
    }
    tsParseList(e21, t2) {
      const s2 = [];
      for (; !this.tsIsListTerminator(e21); )
        s2.push(t2());
      return s2;
    }
    tsParseDelimitedList(e21, t2) {
      return Go(this.tsParseDelimitedListWorker(e21, t2, true));
    }
    tsParseDelimitedListWorker(e21, t2, s2) {
      const r2 = [];
      for (; !this.tsIsListTerminator(e21); ) {
        const i2 = t2();
        if (i2 == null)
          return;
        if (r2.push(i2), !this.eat(bn$1.comma)) {
          if (this.tsIsListTerminator(e21))
            break;
          return void (s2 && this.expect(bn$1.comma));
        }
      }
      return r2;
    }
    tsParseBracketedList(e21, t2, s2, r2) {
      r2 || (s2 ? this.expect(bn$1.bracketL) : this.expectRelational("<"));
      const i2 = this.tsParseDelimitedList(e21, t2);
      return s2 ? this.expect(bn$1.bracketR) : this.expectRelational(">"), i2;
    }
    tsParseImportType() {
      const e21 = this.startNode();
      return this.expect(bn$1._import), this.expect(bn$1.parenL), this.match(bn$1.string) || this.raise(this.state.start, Xo.UnsupportedImportTypeArgument), e21.argument = this.parseExprAtom(), this.expect(bn$1.parenR), this.eat(bn$1.dot) && (e21.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSImportType");
    }
    tsParseEntityName(e21) {
      let t2 = this.parseIdentifier();
      for (; this.eat(bn$1.dot); ) {
        const s2 = this.startNodeAtNode(t2);
        s2.left = t2, s2.right = this.parseIdentifier(e21), t2 = this.finishNode(s2, "TSQualifiedName");
      }
      return t2;
    }
    tsParseTypeReference() {
      const e21 = this.startNode();
      return e21.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSTypeReference");
    }
    tsParseThisTypePredicate(e21) {
      this.next();
      const t2 = this.startNodeAtNode(e21);
      return t2.parameterName = e21, t2.typeAnnotation = this.tsParseTypeAnnotation(false), t2.asserts = false, this.finishNode(t2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e21 = this.startNode();
      return this.next(), this.finishNode(e21, "TSThisType");
    }
    tsParseTypeQuery() {
      const e21 = this.startNode();
      return this.expect(bn$1._typeof), this.match(bn$1._import) ? e21.exprName = this.tsParseImportType() : e21.exprName = this.tsParseEntityName(true), this.finishNode(e21, "TSTypeQuery");
    }
    tsParseTypeParameter() {
      const e21 = this.startNode();
      return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsEatThenParseType(bn$1._extends), e21.default = this.tsEatThenParseType(bn$1.eq), this.finishNode(e21, "TSTypeParameter");
    }
    tsTryParseTypeParameters() {
      if (this.isRelational("<"))
        return this.tsParseTypeParameters();
    }
    tsParseTypeParameters() {
      const e21 = this.startNode();
      return this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected(), e21.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeParameters), this.finishNode(e21, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      return this.lookahead().type === bn$1._const ? (this.next(), this.tsParseTypeReference()) : null;
    }
    tsFillSignature(e21, t2) {
      const s2 = e21 === bn$1.arrow;
      t2.typeParameters = this.tsTryParseTypeParameters(), this.expect(bn$1.parenL), t2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(e21)) && (t2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e21));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(bn$1.parenR, 41).map((e21) => (e21.type !== "Identifier" && e21.type !== "RestElement" && e21.type !== "ObjectPattern" && e21.type !== "ArrayPattern" && this.raise(e21.start, Xo.UnsupportedSignatureParameterKind, e21.type), e21));
    }
    tsParseTypeMemberSemicolon() {
      this.eat(bn$1.comma) || this.isLineTerminator() || this.expect(bn$1.semi);
    }
    tsParseSignatureMember(e21, t2) {
      return this.tsFillSignature(bn$1.colon, t2), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, e21);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), this.eat(bn$1.name) && this.match(bn$1.colon);
    }
    tsTryParseIndexSignature(e21) {
      if (!this.match(bn$1.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
        return;
      this.expect(bn$1.bracketL);
      const t2 = this.parseIdentifier();
      t2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t2), this.expect(bn$1.bracketR), e21.parameters = [t2];
      const s2 = this.tsTryParseTypeAnnotation();
      return s2 && (e21.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(e21, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e21, t2) {
      this.eat(bn$1.question) && (e21.optional = true);
      const s2 = e21;
      if (this.match(bn$1.parenL) || this.isRelational("<")) {
        t2 && this.raise(e21.start, Xo.ReadonlyForMethodSignature);
        const r2 = s2;
        if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Xo.AccesorCannotHaveTypeParameters), this.tsFillSignature(bn$1.colon, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
          r2.parameters.length > 0 && (this.raise(this.state.pos, Rn$1.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter));
        else if (r2.kind === "set") {
          if (r2.parameters.length !== 1)
            this.raise(this.state.pos, Rn$1.BadSetterArity);
          else {
            const e22 = r2.parameters[0];
            this.isThisParam(e22) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter), e22.type === "Identifier" && e22.optional && this.raise(this.state.pos, Xo.SetAccesorCannotHaveOptionalParameter), e22.type === "RestElement" && this.raise(this.state.pos, Xo.SetAccesorCannotHaveRestParameter);
          }
          r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Xo.SetAccesorCannotHaveReturnType);
        } else
          r2.kind = "method";
        return this.finishNode(r2, "TSMethodSignature");
      }
      {
        const e22 = s2;
        t2 && (e22.readonly = true);
        const r2 = this.tsTryParseTypeAnnotation();
        return r2 && (e22.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(e22, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e21 = this.startNode();
      if (this.match(bn$1.parenL) || this.isRelational("<"))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e21);
      if (this.match(bn$1._new)) {
        const t3 = this.startNode();
        return this.next(), this.match(bn$1.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e21) : (e21.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e21, false));
      }
      this.tsParseModifiers(e21, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Xo.InvalidModifierOnTypeMember);
      const t2 = this.tsTryParseIndexSignature(e21);
      return t2 || (this.parsePropertyName(e21, false), e21.computed || e21.key.type !== "Identifier" || e21.key.name !== "get" && e21.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e21.kind = e21.key.name, this.parsePropertyName(e21, false)), this.tsParsePropertyOrMethodSignature(e21, !!e21.readonly));
    }
    tsParseTypeLiteral() {
      const e21 = this.startNode();
      return e21.members = this.tsParseObjectTypeMembers(), this.finishNode(e21, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(bn$1.braceL);
      const e21 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(bn$1.braceR), e21;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(bn$1.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(bn$1.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(bn$1._in))));
    }
    tsParseMappedTypeParameter() {
      const e21 = this.startNode();
      return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsExpectThenParseType(bn$1._in), this.finishNode(e21, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e21 = this.startNode();
      return this.expect(bn$1.braceL), this.match(bn$1.plusMin) ? (e21.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e21.readonly = true), this.expect(bn$1.bracketL), e21.typeParameter = this.tsParseMappedTypeParameter(), e21.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(bn$1.bracketR), this.match(bn$1.plusMin) ? (e21.optional = this.state.value, this.next(), this.expect(bn$1.question)) : this.eat(bn$1.question) && (e21.optional = true), e21.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(bn$1.braceR), this.finishNode(e21, "TSMappedType");
    }
    tsParseTupleType() {
      const e21 = this.startNode();
      e21.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t2 = false, s2 = null;
      return e21.elementTypes.forEach((e22) => {
        var r2;
        let {type: i2} = e22;
        !t2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && e22.optional || this.raise(e22.start, Xo.OptionalTypeBeforeRequired), t2 = t2 || i2 === "TSNamedTupleMember" && e22.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (e22 = e22.typeAnnotation).type);
        const a2 = i2 === "TSNamedTupleMember";
        s2 = (r2 = s2) != null ? r2 : a2, s2 !== a2 && this.raise(e22.start, Xo.MixedLabeledAndUnlabeledElements);
      }), this.finishNode(e21, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {start: e21, startLoc: t2} = this.state, s2 = this.eat(bn$1.ellipsis);
      let r2 = this.tsParseType();
      const i2 = this.eat(bn$1.question);
      if (this.eat(bn$1.colon)) {
        const e22 = this.startNodeAtNode(r2);
        e22.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, Xo.InvalidTupleMemberLabel), e22.label = r2) : e22.label = r2.typeName, e22.elementType = this.tsParseType(), r2 = this.finishNode(e22, "TSNamedTupleMember");
      } else if (i2) {
        const e22 = this.startNodeAtNode(r2);
        e22.typeAnnotation = r2, r2 = this.finishNode(e22, "TSOptionalType");
      }
      if (s2) {
        const s3 = this.startNodeAt(e21, t2);
        s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
      }
      return r2;
    }
    tsParseParenthesizedType() {
      const e21 = this.startNode();
      return this.expect(bn$1.parenL), e21.typeAnnotation = this.tsParseType(), this.expect(bn$1.parenR), this.finishNode(e21, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e21, t2) {
      const s2 = this.startNode();
      return e21 === "TSConstructorType" && (s2.abstract = !!t2, t2 && this.next(), this.next()), this.tsFillSignature(bn$1.arrow, s2), this.finishNode(s2, e21);
    }
    tsParseLiteralTypeNode() {
      const e21 = this.startNode();
      return e21.literal = (() => {
        switch (this.state.type) {
          case bn$1.num:
          case bn$1.bigint:
          case bn$1.string:
          case bn$1._true:
          case bn$1._false:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e21, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e21 = this.startNode();
      return e21.literal = this.parseTemplate(false), this.finishNode(e21, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e21 = this.tsParseThisTypeNode();
      return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e21) : e21;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case bn$1.name:
        case bn$1._void:
        case bn$1._null: {
          const e21 = this.match(bn$1._void) ? "TSVoidKeyword" : this.match(bn$1._null) ? "TSNullKeyword" : function(e22) {
            switch (e22) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }(this.state.value);
          if (e21 !== void 0 && this.lookaheadCharCode() !== 46) {
            const t2 = this.startNode();
            return this.next(), this.finishNode(t2, e21);
          }
          return this.tsParseTypeReference();
        }
        case bn$1.string:
        case bn$1.num:
        case bn$1.bigint:
        case bn$1._true:
        case bn$1._false:
          return this.tsParseLiteralTypeNode();
        case bn$1.plusMin:
          if (this.state.value === "-") {
            const e21 = this.startNode(), t2 = this.lookahead();
            if (t2.type !== bn$1.num && t2.type !== bn$1.bigint)
              throw this.unexpected();
            return e21.literal = this.parseMaybeUnary(), this.finishNode(e21, "TSLiteralType");
          }
          break;
        case bn$1._this:
          return this.tsParseThisTypeOrThisTypePredicate();
        case bn$1._typeof:
          return this.tsParseTypeQuery();
        case bn$1._import:
          return this.tsParseImportType();
        case bn$1.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case bn$1.bracketL:
          return this.tsParseTupleType();
        case bn$1.parenL:
          return this.tsParseParenthesizedType();
        case bn$1.backQuote:
          return this.tsParseTemplateLiteralType();
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e21 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(bn$1.bracketL); )
        if (this.match(bn$1.bracketR)) {
          const t2 = this.startNodeAtNode(e21);
          t2.elementType = e21, this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSArrayType");
        } else {
          const t2 = this.startNodeAtNode(e21);
          t2.objectType = e21, t2.indexType = this.tsParseType(), this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSIndexedAccessType");
        }
      return e21;
    }
    tsParseTypeOperator(e21) {
      const t2 = this.startNode();
      return this.expectContextual(e21), t2.operator = e21, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e21 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e21) {
      switch (e21.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(e21.start, Xo.UnexpectedReadonly);
      }
    }
    tsParseInferType() {
      const e21 = this.startNode();
      this.expectContextual("infer");
      const t2 = this.startNode();
      return t2.name = this.tsParseTypeParameterName(), e21.typeParameter = this.finishNode(t2, "TSTypeParameter"), this.finishNode(e21, "TSInferType");
    }
    tsParseTypeOperatorOrHigher() {
      const e21 = ["keyof", "unique", "readonly"].find((e22) => this.isContextual(e22));
      return e21 ? this.tsParseTypeOperator(e21) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }
    tsParseUnionOrIntersectionType(e21, t2, s2) {
      const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
      do {
        a2.push(t2());
      } while (this.eat(s2));
      return a2.length !== 1 || i2 ? (r2.types = a2, this.finishNode(r2, e21)) : a2[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), bn$1.bitwiseAND);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), bn$1.bitwiseOR);
    }
    tsIsStartOfFunctionType() {
      return !!this.isRelational("<") || this.match(bn$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (this.match(bn$1.name) || this.match(bn$1._this))
        return this.next(), true;
      if (this.match(bn$1.braceL)) {
        let e21 = 1;
        for (this.next(); e21 > 0; )
          this.match(bn$1.braceL) ? ++e21 : this.match(bn$1.braceR) && --e21, this.next();
        return true;
      }
      if (this.match(bn$1.bracketL)) {
        let e21 = 1;
        for (this.next(); e21 > 0; )
          this.match(bn$1.bracketL) ? ++e21 : this.match(bn$1.bracketR) && --e21, this.next();
        return true;
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(bn$1.parenR) || this.match(bn$1.ellipsis))
        return true;
      if (this.tsSkipParameterStart()) {
        if (this.match(bn$1.colon) || this.match(bn$1.comma) || this.match(bn$1.question) || this.match(bn$1.eq))
          return true;
        if (this.match(bn$1.parenR) && (this.next(), this.match(bn$1.arrow)))
          return true;
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(e21) {
      return this.tsInType(() => {
        const t2 = this.startNode();
        this.expect(e21);
        const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (r2 && this.match(bn$1._this)) {
          let e22 = this.tsParseThisTypeOrThisTypePredicate();
          return e22.type === "TSThisType" ? (s2.parameterName = e22, s2.asserts = true, s2.typeAnnotation = null, e22 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(e22, s2), e22.asserts = true), t2.typeAnnotation = e22, this.finishNode(t2, "TSTypeAnnotation");
        }
        const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!i2)
          return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t2);
        const a2 = this.tsParseTypeAnnotation(false);
        return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(bn$1.colon);
    }
    tsParseTypePredicatePrefix() {
      const e21 = this.parseIdentifier();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak())
        return this.next(), e21;
    }
    tsParseTypePredicateAsserts() {
      if (!this.match(bn$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
        return false;
      const e21 = this.state.containsEsc;
      return this.next(), !(!this.match(bn$1.name) && !this.match(bn$1._this)) && (e21 && this.raise(this.state.lastTokStart, Rn$1.InvalidEscapedReservedWord, "asserts"), true);
    }
    tsParseTypeAnnotation(e21 = true, t2 = this.startNode()) {
      return this.tsInType(() => {
        e21 && this.expect(bn$1.colon), t2.typeAnnotation = this.tsParseType();
      }), this.finishNode(t2, "TSTypeAnnotation");
    }
    tsParseType() {
      Ko(this.state.inType);
      const e21 = this.tsParseNonConditionalType();
      if (this.hasPrecedingLineBreak() || !this.eat(bn$1._extends))
        return e21;
      const t2 = this.startNodeAtNode(e21);
      return t2.checkType = e21, t2.extendsType = this.tsParseNonConditionalType(), this.expect(bn$1.question), t2.trueType = this.tsParseType(), this.expect(bn$1.colon), t2.falseType = this.tsParseType(), this.finishNode(t2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._new;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(bn$1._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      const e21 = this.startNode(), t2 = this.tsTryNextParseConstantContext();
      return e21.typeAnnotation = t2 || this.tsNextThenParseType(), this.expectRelational(">"), e21.expression = this.parseMaybeUnary(), this.finishNode(e21, "TSTypeAssertion");
    }
    tsParseHeritageClause(e21) {
      const t2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
      return s2.length || this.raise(t2, Xo.EmptyHeritageClauseType, e21), s2;
    }
    tsParseExpressionWithTypeArguments() {
      const e21 = this.startNode();
      return e21.expression = this.tsParseEntityName(false), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSExpressionWithTypeArguments");
    }
    tsParseInterfaceDeclaration(e21) {
      this.match(bn$1.name) ? (e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript interface declaration", 130)) : (e21.id = null, this.raise(this.state.start, Xo.MissingInterfaceName)), e21.typeParameters = this.tsTryParseTypeParameters(), this.eat(bn$1._extends) && (e21.extends = this.tsParseHeritageClause("extends"));
      const t2 = this.startNode();
      return t2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e21.body = this.finishNode(t2, "TSInterfaceBody"), this.finishNode(e21, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e21) {
      return e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript type alias", 2), e21.typeParameters = this.tsTryParseTypeParameters(), e21.typeAnnotation = this.tsInType(() => {
        if (this.expect(bn$1.eq), this.isContextual("intrinsic") && this.lookahead().type !== bn$1.dot) {
          const e22 = this.startNode();
          return this.next(), this.finishNode(e22, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e21, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e21) {
      const t2 = this.state.context;
      this.state.context = [t2[0]];
      try {
        return e21();
      } finally {
        this.state.context = t2;
      }
    }
    tsInType(e21) {
      const t2 = this.state.inType;
      this.state.inType = true;
      try {
        return e21();
      } finally {
        this.state.inType = t2;
      }
    }
    tsEatThenParseType(e21) {
      return this.match(e21) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e21) {
      return this.tsDoThenParseType(() => this.expect(e21));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e21) {
      return this.tsInType(() => (e21(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e21 = this.startNode();
      return e21.id = this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(bn$1.eq) && (e21.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e21, "TSEnumMember");
    }
    tsParseEnumDeclaration(e21, t2) {
      return t2 && (e21.const = true), e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript enum declaration", t2 ? 779 : 267), this.expect(bn$1.braceL), e21.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(bn$1.braceR), this.finishNode(e21, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e21 = this.startNode();
      return this.scope.enter(0), this.expect(bn$1.braceL), this.parseBlockOrModuleBlockBody(e21.body = [], void 0, true, bn$1.braceR), this.scope.exit(), this.finishNode(e21, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e21, t2 = false) {
      if (e21.id = this.parseIdentifier(), t2 || this.checkLVal(e21.id, "module or namespace declaration", 1024), this.eat(bn$1.dot)) {
        const t3 = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(t3, true), e21.body = t3;
      } else
        this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e21, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e21) {
      return this.isContextual("global") ? (e21.global = true, e21.id = this.parseIdentifier()) : this.match(bn$1.string) ? e21.id = this.parseExprAtom() : this.unexpected(), this.match(bn$1.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e21, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e21, t2) {
      e21.isExport = t2 || false, e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "import equals declaration", 9), this.expect(bn$1.eq);
      const s2 = this.tsParseModuleReference();
      return e21.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, Xo.ImportAliasHasImportType), e21.moduleReference = s2, this.semicolon(), this.finishNode(e21, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e21 = this.startNode();
      if (this.expectContextual("require"), this.expect(bn$1.parenL), !this.match(bn$1.string))
        throw this.unexpected();
      return e21.expression = this.parseExprAtom(), this.expect(bn$1.parenR), this.finishNode(e21, "TSExternalModuleReference");
    }
    tsLookAhead(e21) {
      const t2 = this.state.clone(), s2 = e21();
      return this.state = t2, s2;
    }
    tsTryParseAndCatch(e21) {
      const t2 = this.tryParse((t3) => e21() || t3());
      if (!t2.aborted && t2.node)
        return t2.error && (this.state = t2.failState), t2.node;
    }
    tsTryParse(e21) {
      const t2 = this.state.clone(), s2 = e21();
      return s2 !== void 0 && s2 !== false ? s2 : void (this.state = t2);
    }
    tsTryParseDeclare(e21) {
      if (this.isLineTerminator())
        return;
      let t2, s2 = this.state.type;
      return this.isContextual("let") && (s2 = bn$1._var, t2 = "let"), this.tsInAmbientContext(() => {
        switch (s2) {
          case bn$1._function:
            return e21.declare = true, this.parseFunctionStatement(e21, false, true);
          case bn$1._class:
            return e21.declare = true, this.parseClass(e21, true, false);
          case bn$1._const:
            if (this.match(bn$1._const) && this.isLookaheadContextual("enum"))
              return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e21, true);
          case bn$1._var:
            return t2 = t2 || this.state.value, this.parseVarStatement(e21, t2);
          case bn$1.name: {
            const t3 = this.state.value;
            return t3 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e21) : this.tsParseDeclaration(e21, t3, true);
          }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e21, t2) {
      switch (t2.name) {
        case "declare": {
          const t3 = this.tsTryParseDeclare(e21);
          if (t3)
            return t3.declare = true, t3;
          break;
        }
        case "global":
          if (this.match(bn$1.braceL)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const s2 = e21;
            return s2.global = true, s2.id = t2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e21, t2.name, false);
      }
    }
    tsParseDeclaration(e21, t2, s2) {
      switch (t2) {
        case "abstract":
          if (this.tsCheckLineTerminator(s2) && (this.match(bn$1._class) || this.match(bn$1.name)))
            return this.tsParseAbstractDeclaration(e21);
          break;
        case "enum":
          if (s2 || this.match(bn$1.name))
            return s2 && this.next(), this.tsParseEnumDeclaration(e21, false);
          break;
        case "interface":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseInterfaceDeclaration(e21);
          break;
        case "module":
          if (this.tsCheckLineTerminator(s2)) {
            if (this.match(bn$1.string))
              return this.tsParseAmbientExternalModuleDeclaration(e21);
            if (this.match(bn$1.name))
              return this.tsParseModuleOrNamespaceDeclaration(e21);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseModuleOrNamespaceDeclaration(e21);
          break;
        case "type":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseTypeAliasDeclaration(e21);
      }
    }
    tsCheckLineTerminator(e21) {
      return e21 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e21, t2) {
      if (!this.isRelational("<"))
        return;
      const s2 = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const r2 = this.tsTryParseAndCatch(() => {
        const s3 = this.startNodeAt(e21, t2);
        return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(bn$1.arrow), s3;
      });
      return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
    }
    tsParseTypeArguments() {
      const e21 = this.startNode();
      return e21.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e21, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      if (this.match(bn$1.name))
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      return false;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e21, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      let i2, a2 = false, n2 = false;
      if (e21 !== void 0) {
        const t3 = {};
        this.tsParseModifiers(t3, ["public", "private", "protected", "override", "readonly"]), i2 = t3.accessibility, n2 = t3.override, a2 = t3.readonly, e21 === false && (i2 || a2 || n2) && this.raise(s2, Xo.UnexpectedParameterModifier);
      }
      const o2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(o2);
      const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
      if (i2 || a2 || n2) {
        const e22 = this.startNodeAt(s2, r2);
        return t2.length && (e22.decorators = t2), i2 && (e22.accessibility = i2), a2 && (e22.readonly = a2), n2 && (e22.override = n2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(e22.start, Xo.UnsupportedParameterPropertyKind), e22.parameter = u2, this.finishNode(e22, "TSParameterProperty");
      }
      return t2.length && (o2.decorators = t2), u2;
    }
    parseFunctionBodyAndFinish(e21, t2, s2 = false) {
      this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon));
      const r2 = t2 === "FunctionDeclaration" ? "TSDeclareFunction" : t2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
      r2 && !this.match(bn$1.braceL) && this.isLineTerminator() ? this.finishNode(e21, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e21.start, Xo.DeclareFunctionHasImplementation), e21.declare) ? super.parseFunctionBodyAndFinish(e21, r2, s2) : super.parseFunctionBodyAndFinish(e21, t2, s2);
    }
    registerFunctionStatementId(e21) {
      !e21.body && e21.id ? this.checkLVal(e21.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e21) {
      e21.forEach((e22) => {
        (e22 == null ? void 0 : e22.type) === "TSTypeCastExpression" && this.raise(e22.typeAnnotation.start, Xo.UnexpectedTypeAnnotation);
      });
    }
    toReferencedList(e21, t2) {
      return this.tsCheckForInvalidTypeCasts(e21), e21;
    }
    parseArrayLike(...e21) {
      const t2 = super.parseArrayLike(...e21);
      return t2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t2.elements), t2;
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      if (!this.hasPrecedingLineBreak() && this.match(bn$1.bang)) {
        this.state.exprAllowed = false, this.next();
        const r3 = this.startNodeAt(t2, s2);
        return r3.expression = e21, this.finishNode(r3, "TSNonNullExpression");
      }
      let a2 = false;
      if (this.match(bn$1.questionDot) && this.lookaheadCharCode() === 60) {
        if (r2)
          return i2.stop = true, e21;
        i2.optionalChainMember = a2 = true, this.next();
      }
      if (this.isRelational("<")) {
        let n2;
        const o2 = this.tsTryParseAndCatch(() => {
          if (!r2 && this.atPossibleAsyncArrow(e21)) {
            const e22 = this.tsTryParseGenericAsyncArrowFunction(t2, s2);
            if (e22)
              return e22;
          }
          const o3 = this.startNodeAt(t2, s2);
          o3.callee = e21;
          const u2 = this.tsParseTypeArguments();
          if (u2) {
            if (a2 && !this.match(bn$1.parenL) && (n2 = this.state.pos, this.unexpected()), !r2 && this.eat(bn$1.parenL))
              return o3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = a2), this.finishCallExpression(o3, i2.optionalChainMember);
            if (this.match(bn$1.backQuote)) {
              const r3 = this.parseTaggedTemplateExpression(e21, t2, s2, i2);
              return r3.typeParameters = u2, r3;
            }
          }
          this.unexpected();
        });
        if (n2 && this.unexpected(n2, bn$1.parenL), o2)
          return o2;
      }
      return super.parseSubscript(e21, t2, s2, r2, i2);
    }
    parseNewArguments(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => {
          const e22 = this.tsParseTypeArguments();
          return this.match(bn$1.parenL) || this.unexpected(), e22;
        });
        t2 && (e21.typeParameters = t2);
      }
      super.parseNewArguments(e21);
    }
    parseExprOp(e21, t2, s2, r2) {
      if (Go(bn$1._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const i2 = this.startNodeAt(t2, s2);
        i2.expression = e21;
        const a2 = this.tsTryNextParseConstantContext();
        return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t2, s2, r2);
      }
      return super.parseExprOp(e21, t2, s2, r2);
    }
    checkReservedWord(e21, t2, s2, r2) {
    }
    checkDuplicateExports() {
    }
    parseImport(e21) {
      if (e21.importKind = "value", this.match(bn$1.name) || this.match(bn$1.star) || this.match(bn$1.braceL)) {
        let t3 = this.lookahead();
        if (!this.isContextual("type") || t3.type === bn$1.comma || t3.type === bn$1.name && t3.value === "from" || t3.type === bn$1.eq || (e21.importKind = "type", this.next(), t3 = this.lookahead()), this.match(bn$1.name) && t3.type === bn$1.eq)
          return this.tsParseImportEqualsDeclaration(e21);
      }
      const t2 = super.parseImport(e21);
      return t2.importKind === "type" && t2.specifiers.length > 1 && t2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t2.start, Xo.TypeImportCannotSpecifyDefaultAndNamed), t2;
    }
    parseExport(e21) {
      if (this.match(bn$1._import))
        return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e21.importKind = "type", this.next()) : e21.importKind = "value", this.tsParseImportEqualsDeclaration(e21, true);
      if (this.eat(bn$1.eq)) {
        const t2 = e21;
        return t2.expression = this.parseExpression(), this.semicolon(), this.finishNode(t2, "TSExportAssignment");
      }
      if (this.eatContextual("as")) {
        const t2 = e21;
        return this.expectContextual("namespace"), t2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t2, "TSNamespaceExportDeclaration");
      }
      return this.isContextual("type") && this.lookahead().type === bn$1.braceL ? (this.next(), e21.exportKind = "type") : e21.exportKind = "value", super.parseExport(e21);
    }
    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._class;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e21 = this.startNode();
        return this.next(), e21.abstract = true, this.parseClass(e21, true, true), e21;
      }
      if (this.state.value === "interface") {
        const e21 = this.startNode();
        this.next();
        const t2 = this.tsParseInterfaceDeclaration(e21);
        if (t2)
          return t2;
      }
      return super.parseExportDefaultExpression();
    }
    parseStatementContent(e21, t2) {
      if (this.state.type === bn$1._const) {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name && e22.value === "enum") {
          const e23 = this.startNode();
          return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e23, true);
        }
      }
      return super.parseStatementContent(e21, t2);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e21, t2) {
      return t2.some((t3) => Jo(t3) ? e21.accessibility === t3 : !!e21[t3]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual("static") && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e21, t2, s2) {
      const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers(t2, r2, void 0, void 0, true);
      const i2 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t2, r2) && this.raise(this.state.pos, Xo.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e21, t2)) : this.parseClassMemberWithIsStatic(e21, t2, s2, !!t2.static);
      };
      t2.declare ? this.tsInAmbientContext(i2) : i2();
    }
    parseClassMemberWithIsStatic(e21, t2, s2, r2) {
      const i2 = this.tsTryParseIndexSignature(t2);
      if (i2)
        return e21.body.push(i2), t2.abstract && this.raise(t2.start, Xo.IndexSignatureHasAbstract), t2.accessibility && this.raise(t2.start, Xo.IndexSignatureHasAccessibility, t2.accessibility), t2.declare && this.raise(t2.start, Xo.IndexSignatureHasDeclare), void (t2.override && this.raise(t2.start, Xo.IndexSignatureHasOverride));
      !this.state.inAbstractClass && t2.abstract && this.raise(t2.start, Xo.NonAbstractClassHasAbstractMethod), t2.override && (s2.hadSuperClass || this.raise(t2.start, Xo.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e21, t2, s2, r2);
    }
    parsePostMemberNameModifiers(e21) {
      this.eat(bn$1.question) && (e21.optional = true), e21.readonly && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasReadonly), e21.declare && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasDeclare);
    }
    parseExpressionStatement(e21, t2) {
      return (t2.type === "Identifier" ? this.tsParseExpressionStatement(e21, t2) : void 0) || super.parseExpressionStatement(e21, t2);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(e21, t2, s2, r2) {
      if (!this.state.maybeInArrowParameters || !this.match(bn$1.question))
        return super.parseConditional(e21, t2, s2, r2);
      const i2 = this.tryParse(() => super.parseConditional(e21, t2, s2));
      return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), e21);
    }
    parseParenItem(e21, t2, s2) {
      if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e21, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
      }
      return e21;
    }
    parseExportDeclaration(e21) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
      if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
        throw this.raise(this.state.start, Xo.ExpectedAmbientAfterExportDeclare);
      let i2;
      return this.match(bn$1.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(e21)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (e21.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, t2, s2), i2.declare = true), i2;
    }
    parseClassId(e21, t2, s2) {
      if ((!t2 || s2) && this.isContextual("implements"))
        return;
      super.parseClassId(e21, t2, s2, e21.declare ? 1024 : 139);
      const r2 = this.tsTryParseTypeParameters();
      r2 && (e21.typeParameters = r2);
    }
    parseClassPropertyAnnotation(e21) {
      !e21.optional && this.eat(bn$1.bang) && (e21.definite = true);
      const t2 = this.tsTryParseTypeAnnotation();
      t2 && (e21.typeAnnotation = t2);
    }
    parseClassProperty(e21) {
      if (this.parseClassPropertyAnnotation(e21), this.state.isAmbientContext && this.match(bn$1.eq) && this.raise(this.state.start, Xo.DeclareClassFieldHasInitializer), e21.abstract && this.match(bn$1.eq)) {
        const {key: t2} = e21;
        this.raise(this.state.start, Xo.AbstractPropertyHasInitializer, t2.type !== "Identifier" || e21.computed ? `[${this.input.slice(t2.start, t2.end)}]` : t2.name);
      }
      return super.parseClassProperty(e21);
    }
    parseClassPrivateProperty(e21) {
      return e21.abstract && this.raise(e21.start, Xo.PrivateElementHasAbstract), e21.accessibility && this.raise(e21.start, Xo.PrivateElementHasAccessibility, e21.accessibility), this.parseClassPropertyAnnotation(e21), super.parseClassPrivateProperty(e21);
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      const n2 = this.tsTryParseTypeParameters();
      n2 && i2 && this.raise(n2.start, Xo.ConstructorHasTypeParameters), !t2.declare || t2.kind !== "get" && t2.kind !== "set" || this.raise(t2.start, Xo.DeclareAccessor, t2.kind), n2 && (t2.typeParameters = n2), super.pushClassMethod(e21, t2, s2, r2, i2, a2);
    }
    pushClassPrivateMethod(e21, t2, s2, r2) {
      const i2 = this.tsTryParseTypeParameters();
      i2 && (t2.typeParameters = i2), super.pushClassPrivateMethod(e21, t2, s2, r2);
    }
    parseClassSuper(e21) {
      super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e21.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e21, ...t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e21.typeParameters = s2), super.parseObjPropValue(e21, ...t2);
    }
    parseFunctionParams(e21, t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e21.typeParameters = s2), super.parseFunctionParams(e21, t2);
    }
    parseVarId(e21, t2) {
      super.parseVarId(e21, t2), e21.id.type === "Identifier" && this.eat(bn$1.bang) && (e21.definite = true);
      const s2 = this.tsTryParseTypeAnnotation();
      s2 && (e21.id.typeAnnotation = s2, this.resetEndLocation(e21.id));
    }
    parseAsyncArrowFromCallExpression(e21, t2) {
      return this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e21, t2);
    }
    parseMaybeAssign(...e21) {
      var t2, s2, r2, i2, a2, n2, o2;
      let u2, h2, c2, p2;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !h2.error)
          return h2.node;
        const {context: t3} = this.state;
        t3[t3.length - 1] === $n$1.j_oTag ? t3.length -= 2 : t3[t3.length - 1] === $n$1.j_expr && (t3.length -= 1);
      }
      if (!((t2 = h2) != null && t2.error || this.isRelational("<")))
        return super.parseMaybeAssign(...e21);
      u2 = u2 || this.state.clone();
      const l2 = this.tryParse((t3) => {
        var s3, r3;
        p2 = this.tsParseTypeParameters();
        const i3 = super.parseMaybeAssign(...e21);
        return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t3(), ((r3 = p2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
      }, u2);
      if (!l2.error && !l2.aborted)
        return l2.node;
      if (!h2 && (Ko(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !c2.error))
        return c2.node;
      if ((s2 = h2) != null && s2.node)
        return this.state = h2.failState, h2.node;
      if (l2.node)
        return this.state = l2.failState, l2.node;
      if ((r2 = c2) != null && r2.node)
        return this.state = c2.failState, c2.node;
      if ((i2 = h2) != null && i2.thrown)
        throw h2.error;
      if (l2.thrown)
        throw l2.error;
      if ((a2 = c2) != null && a2.thrown)
        throw c2.error;
      throw ((n2 = h2) == null ? void 0 : n2.error) || l2.error || ((o2 = c2) == null ? void 0 : o2.error);
    }
    parseMaybeUnary(e21) {
      return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e21);
    }
    parseArrow(e21) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse((e22) => {
          const t3 = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon);
          return !this.canInsertSemicolon() && this.match(bn$1.arrow) || e22(), t3;
        });
        if (t2.aborted)
          return;
        t2.thrown || (t2.error && (this.state = t2.failState), e21.returnType = t2.node);
      }
      return super.parseArrow(e21);
    }
    parseAssignableListItemTypes(e21) {
      this.eat(bn$1.question) && (e21.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e21.start, Xo.PatternIsOptional), e21.optional = true);
      const t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e21.typeAnnotation = t2), this.resetEndLocation(e21), e21;
    }
    isAssignable(e21, t2) {
      switch (e21.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e21.expression, t2);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e21, t2);
      }
    }
    toAssignable(e21, t2 = false) {
      switch (e21.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(e21), t2);
        case "TSParameterProperty":
          return super.toAssignable(e21, t2);
        case "ParenthesizedExpression":
          return this.toAssignableParenthesizedExpression(e21, t2);
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          return e21.expression = this.toAssignable(e21.expression, t2), e21;
        default:
          return super.toAssignable(e21, t2);
      }
    }
    toAssignableParenthesizedExpression(e21, t2) {
      switch (e21.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          return e21.expression = this.toAssignable(e21.expression, t2), e21;
        default:
          return super.toAssignable(e21, t2);
      }
    }
    checkLVal(e21, t2, ...s2) {
      var r2;
      switch (e21.type) {
        case "TSTypeCastExpression":
          return;
        case "TSParameterProperty":
          return void this.checkLVal(e21.parameter, "parameter property", ...s2);
        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!(s2[0] || t2 === "parenthesized expression" || (r2 = e21.extra) != null && r2.parenthesized)) {
            this.raise(e21.start, Rn$1.InvalidLhs, t2);
            break;
          }
          return void this.checkLVal(e21.expression, "parenthesized expression", ...s2);
        case "TSNonNullExpression":
          return void this.checkLVal(e21.expression, t2, ...s2);
        default:
          return void super.checkLVal(e21, t2, ...s2);
      }
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsParseTypeArguments();
        if (this.match(bn$1.parenL)) {
          const s2 = super.parseMaybeDecoratorArguments(e21);
          return s2.typeParameters = t2, s2;
        }
        this.unexpected(this.state.start, bn$1.parenL);
      }
      return super.parseMaybeDecoratorArguments(e21);
    }
    checkCommaAfterRest(e21) {
      this.state.isAmbientContext && this.match(bn$1.comma) && this.lookaheadCharCode() === e21 ? this.next() : super.checkCommaAfterRest(e21);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.bang) || this.match(bn$1.colon) || super.isClassProperty();
    }
    parseMaybeDefault(...e21) {
      const t2 = super.parseMaybeDefault(...e21);
      return t2.type === "AssignmentPattern" && t2.typeAnnotation && t2.right.start < t2.typeAnnotation.start && this.raise(t2.typeAnnotation.start, Xo.TypeAnnotationAfterAssign), t2;
    }
    getTokenFromCode(e21) {
      return !this.state.inType || e21 !== 62 && e21 !== 60 ? super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
    }
    reScan_lt_gt() {
      if (this.match(bn$1.relational)) {
        const e21 = this.input.charCodeAt(this.state.start);
        e21 !== 60 && e21 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e21));
      }
    }
    toAssignableList(e21) {
      for (let t2 = 0; t2 < e21.length; t2++) {
        const s2 = e21[t2];
        if (s2)
          switch (s2.type) {
            case "TSTypeCastExpression":
              e21[t2] = this.typeCastToParameter(s2);
              break;
            case "TSAsExpression":
            case "TSTypeAssertion":
              this.state.maybeInArrowParameters ? this.raise(s2.start, Xo.UnexpectedTypeCastInParameter) : e21[t2] = this.typeCastToParameter(s2);
          }
      }
      return super.toAssignableList(...arguments);
    }
    typeCastToParameter(e21) {
      return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
    }
    shouldParseArrow(e21) {
      return this.match(bn$1.colon) ? e21.every((e22) => this.isAssignable(e22, true)) : super.shouldParseArrow(e21);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        t2 && (e21.typeParameters = t2);
      }
      return super.jsxParseOpeningElementAfterName(e21);
    }
    getGetterSetterExpectedParamCount(e21) {
      const t2 = super.getGetterSetterExpectedParamCount(e21), s2 = this.getObjectOrClassMethodParams(e21)[0];
      return s2 && this.isThisParam(s2) ? t2 + 1 : t2;
    }
    parseCatchClauseParam() {
      const e21 = super.parseCatchClauseParam(), t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e21.typeAnnotation = t2, this.resetEndLocation(e21)), e21;
    }
    tsInAmbientContext(e21) {
      const t2 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e21();
      } finally {
        this.state.isAmbientContext = t2;
      }
    }
    parseClass(e21, ...t2) {
      const s2 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e21.abstract;
      try {
        return super.parseClass(e21, ...t2);
      } finally {
        this.state.inAbstractClass = s2;
      }
    }
    tsParseAbstractDeclaration(e21) {
      if (this.match(bn$1._class))
        return e21.abstract = true, this.parseClass(e21, true, false);
      if (this.isContextual("interface")) {
        if (!this.hasFollowingLineBreak())
          return e21.abstract = true, this.raise(e21.start, Xo.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e21);
      } else
        this.unexpected(null, bn$1._class);
    }
    parseMethod(...e21) {
      const t2 = super.parseMethod(...e21);
      if (t2.abstract) {
        if (this.hasPlugin("estree") ? !!t2.value.body : !!t2.body) {
          const {key: e22} = t2;
          this.raise(t2.start, Xo.AbstractMethodHasImplementation, e22.type !== "Identifier" || t2.computed ? `[${this.input.slice(e22.start, e22.end)}]` : e22.name);
        }
      }
      return t2;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
  }, v8intrinsic: (e20) => class extends e20 {
    parseV8Intrinsic() {
      if (this.match(bn$1.modulo)) {
        const e21 = this.state.start, t2 = this.startNode();
        if (this.eat(bn$1.modulo), this.match(bn$1.name)) {
          const e22 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(t2, e22);
          if (s2.type = "V8IntrinsicIdentifier", this.match(bn$1.parenL))
            return s2;
        }
        this.unexpected(e21);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  }, placeholders: (e20) => class extends e20 {
    parsePlaceholder(e21) {
      if (this.match(bn$1.placeholder)) {
        const t2 = this.startNode();
        return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(bn$1.placeholder), this.finishPlaceholder(t2, e21);
      }
    }
    finishPlaceholder(e21, t2) {
      const s2 = !(!e21.expectedNode || e21.type !== "Placeholder");
      return e21.expectedNode = t2, s2 ? e21 : this.finishNode(e21, "Placeholder");
    }
    getTokenFromCode(e21) {
      return e21 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(bn$1.placeholder, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e21) {
      e21 !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    checkLVal(e21) {
      e21.type !== "Placeholder" && super.checkLVal(...arguments);
    }
    toAssignable(e21) {
      return e21 && e21.type === "Placeholder" && e21.expectedNode === "Expression" ? (e21.expectedNode = "Pattern", e21) : super.toAssignable(...arguments);
    }
    isLet(e21) {
      if (super.isLet(e21))
        return true;
      if (!this.isContextual("let"))
        return false;
      if (e21)
        return false;
      return this.lookahead().type === bn$1.placeholder;
    }
    verifyBreakContinue(e21) {
      e21.label && e21.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e21, t2) {
      if (t2.type !== "Placeholder" || t2.extra && t2.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(bn$1.colon)) {
        const s2 = e21;
        return s2.label = this.finishPlaceholder(t2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
      }
      return this.semicolon(), e21.name = t2.name, this.finishPlaceholder(e21, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e21, t2, s2) {
      const r2 = t2 ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e21);
      const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
      if (a2)
        if (this.match(bn$1._extends) || this.match(bn$1.placeholder) || this.match(bn$1.braceL))
          e21.id = a2;
        else {
          if (s2 || !t2)
            return e21.id = null, e21.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(e21, r2);
          this.unexpected(null, Yo.ClassNameIsRequired);
        }
      else
        this.parseClassId(e21, t2, s2);
      return this.parseClassSuper(e21), e21.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e21.superClass, i2), this.finishNode(e21, r2);
    }
    parseExport(e21) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseExport(...arguments);
      if (!this.isContextual("from") && !this.match(bn$1.comma))
        return e21.specifiers = [], e21.source = null, e21.declaration = this.finishPlaceholder(t2, "Declaration"), this.finishNode(e21, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const s2 = this.startNode();
      return s2.exported = t2, e21.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(e21);
    }
    isExportDefaultSpecifier() {
      if (this.match(bn$1._default)) {
        const e21 = this.nextTokenStart();
        if (this.isUnparsedContextual(e21, "from") && this.input.startsWith(bn$1.placeholder.label, this.nextTokenStartSince(e21 + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e21) {
      return !!(e21.specifiers && e21.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e21) {
      const {specifiers: t2} = e21;
      t2 != null && t2.length && (e21.specifiers = t2.filter((e22) => e22.exported.type === "Placeholder")), super.checkExport(e21), e21.specifiers = t2;
    }
    parseImport(e21) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseImport(...arguments);
      if (e21.specifiers = [], !this.isContextual("from") && !this.match(bn$1.comma))
        return e21.source = this.finishPlaceholder(t2, "StringLiteral"), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
      const s2 = this.startNodeAtNode(t2);
      if (s2.local = t2, this.finishNode(s2, "ImportDefaultSpecifier"), e21.specifiers.push(s2), this.eat(bn$1.comma)) {
        this.maybeParseStarImportSpecifier(e21) || this.parseNamedImportSpecifiers(e21);
      }
      return this.expectContextual("from"), e21.source = this.parseImportSource(), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
  }}, iu = Object.keys(ru), au = {sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true};
  const nu = (e20) => e20.type === "ParenthesizedExpression" ? nu(e20.expression) : e20;
  const ou = {kind: "loop"}, uu = {kind: "switch"}, hu = /[\uD800-\uDFFF]/u, cu = /in(?:stanceof)?/y;
  class pu extends class extends class extends class extends class extends class extends class extends class extends class extends class {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e20) {
      return this.plugins.has(e20);
    }
    getPluginOption(e20, t2) {
      if (this.hasPlugin(e20))
        return this.plugins.get(e20)[t2];
    }
  } {
    addComment(e20) {
      this.filename && (e20.loc.filename = this.filename), this.state.comments.push(e20);
    }
    processComment(e20) {
      const {commentStack: t2} = this.state, s2 = t2.length;
      if (s2 === 0)
        return;
      let r2 = s2 - 1;
      const i2 = t2[r2];
      i2.start === e20.end && (i2.leadingNode = e20, r2--);
      const {start: a2} = e20;
      for (; r2 >= 0; r2--) {
        const s3 = t2[r2], i3 = s3.end;
        if (!(i3 > a2)) {
          i3 === a2 && (s3.trailingNode = e20);
          break;
        }
        s3.containingNode = e20, this.finalizeComment(s3), t2.splice(r2, 1);
      }
    }
    finalizeComment(e20) {
      const {comments: t2} = e20;
      if (e20.leadingNode !== null || e20.trailingNode !== null)
        e20.leadingNode !== null && kn$1(e20.leadingNode, t2), e20.trailingNode !== null && (e20.trailingNode.leadingComments = t2);
      else {
        const {containingNode: s2, start: r2} = e20;
        if (this.input.charCodeAt(r2 - 1) === 44)
          switch (s2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              On$1(s2, s2.properties, e20);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              On$1(s2, s2.arguments, e20);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              On$1(s2, s2.params, e20);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              On$1(s2, s2.elements, e20);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              On$1(s2, s2.specifiers, e20);
              break;
            default:
              Ln$1(s2, t2);
          }
        else
          Ln$1(s2, t2);
      }
    }
    finalizeRemainingComments() {
      const {commentStack: e20} = this.state;
      for (let t2 = e20.length - 1; t2 >= 0; t2--)
        this.finalizeComment(e20[t2]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e20) {
      const {commentStack: t2} = this.state, {length: s2} = t2;
      if (s2 === 0)
        return;
      const r2 = t2[s2 - 1];
      r2.leadingNode === e20 && (r2.leadingNode = null);
    }
  } {
    getLocationForPosition(e20) {
      let t2;
      return t2 = e20 === this.state.start ? this.state.startLoc : e20 === this.state.lastTokStart ? this.state.lastTokStartLoc : e20 === this.state.end ? this.state.endLoc : e20 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e21, t3) {
        let s2, r2 = 1, i2 = 0;
        for (Tn$1.lastIndex = 0; (s2 = Tn$1.exec(e21)) && s2.index < t3; )
          r2++, i2 = Tn$1.lastIndex;
        return new In$1(r2, t3 - i2);
      }(this.input, e20), t2;
    }
    raise(e20, {code: t2, reasonCode: s2, template: r2}, ...i2) {
      return this.raiseWithData(e20, {code: t2, reasonCode: s2}, r2, ...i2);
    }
    raiseOverwrite(e20, {code: t2, template: s2}, ...r2) {
      const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
      if (this.options.errorRecovery) {
        const t3 = this.state.errors;
        for (let s3 = t3.length - 1; s3 >= 0; s3--) {
          const r3 = t3[s3];
          if (r3.pos === e20)
            return Object.assign(r3, {message: a2});
          if (r3.pos < e20)
            break;
        }
      }
      return this._raise({code: t2, loc: i2, pos: e20}, a2);
    }
    raiseWithData(e20, t2, s2, ...r2) {
      const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
      return this._raise(Object.assign({loc: i2, pos: e20}, t2), a2);
    }
    _raise(e20, t2) {
      const s2 = new SyntaxError(t2);
      if (Object.assign(s2, e20), this.options.errorRecovery)
        return this.isLookahead || this.state.errors.push(s2), s2;
      throw s2;
    }
  } {
    constructor(e20, t2) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new Do$1(), this.state.init(e20), this.input = t2, this.length = t2.length, this.isLookahead = false;
    }
    pushToken(e20) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e20), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Eo$1(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e20) {
      return !!this.match(e20) && (this.next(), true);
    }
    match(e20) {
      return this.state.type === e20;
    }
    createLookaheadState(e20) {
      return {pos: e20.pos, value: null, type: e20.type, start: e20.start, end: e20.end, lastTokEnd: e20.end, context: [this.curContext()], inType: e20.inType};
    }
    lookahead() {
      const e20 = this.state;
      this.state = this.createLookaheadState(e20), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t2 = this.state;
      return this.state = e20, t2;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e20) {
      return Sn$1.lastIndex = e20, Sn$1.test(this.input) ? Sn$1.lastIndex : e20;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(e20) {
      let t2 = this.input.charCodeAt(e20);
      if ((64512 & t2) == 55296 && ++e20 < this.input.length) {
        const s2 = this.input.charCodeAt(e20);
        (64512 & s2) == 56320 && (t2 = 65536 + ((1023 & t2) << 10) + (1023 & s2));
      }
      return t2;
    }
    setStrict(e20) {
      this.state.strict = e20, e20 && (this.state.strictErrors.forEach((e21, t2) => this.raise(t2, e21)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      const e20 = this.curContext();
      e20.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(bn$1.eof) : e20 === $n$1.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let e20;
      this.isLookahead || (e20 = this.state.curPosition());
      const t2 = this.state.pos, s2 = this.input.indexOf("*/", t2 + 2);
      if (s2 === -1)
        throw this.raise(t2, Rn$1.UnterminatedComment);
      for (this.state.pos = s2 + 2, Tn$1.lastIndex = t2 + 2; Tn$1.test(this.input) && Tn$1.lastIndex <= s2; )
        ++this.state.curLine, this.state.lineStart = Tn$1.lastIndex;
      if (this.isLookahead)
        return;
      const r2 = {type: "CommentBlock", value: this.input.slice(t2 + 2, s2), start: t2, end: s2 + 2, loc: new vn$1(e20, this.state.curPosition())};
      return this.options.tokens && this.pushToken(r2), r2;
    }
    skipLineComment(e20) {
      const t2 = this.state.pos;
      let s2;
      this.isLookahead || (s2 = this.state.curPosition());
      let r2 = this.input.charCodeAt(this.state.pos += e20);
      if (this.state.pos < this.length)
        for (; !wn$1(r2) && ++this.state.pos < this.length; )
          r2 = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const i2 = this.state.pos, a2 = {type: "CommentLine", value: this.input.slice(t2 + e20, i2), start: t2, end: i2, loc: new vn$1(s2, this.state.curPosition())};
      return this.options.tokens && this.pushToken(a2), a2;
    }
    skipSpace() {
      const e20 = this.state.pos, t2 = [];
      e:
        for (; this.state.pos < this.length; ) {
          const s2 = this.input.charCodeAt(this.state.pos);
          switch (s2) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const e21 = this.skipBlockComment();
                  e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                  break;
                }
                case 47: {
                  const e21 = this.skipLineComment(2);
                  e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Nn$1(s2))
                ++this.state.pos;
              else if (s2 !== 45 || this.inModule) {
                if (s2 !== 60 || this.inModule)
                  break e;
                {
                  const e21 = this.state.pos;
                  if (this.input.charCodeAt(e21 + 1) !== 33 || this.input.charCodeAt(e21 + 2) !== 45 || this.input.charCodeAt(e21 + 3) !== 45)
                    break e;
                  {
                    const e22 = this.skipLineComment(4);
                    e22 !== void 0 && (this.addComment(e22), this.options.attachComment && t2.push(e22));
                  }
                }
              } else {
                const s3 = this.state.pos;
                if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(e20 === 0 || this.state.lineStart > e20))
                  break e;
                {
                  const e21 = this.skipLineComment(3);
                  e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                }
              }
          }
        }
      if (t2.length > 0) {
        const s2 = {start: e20, end: this.state.pos, comments: t2, leadingNode: null, trailingNode: null, containingNode: null};
        this.state.commentStack.push(s2);
      }
    }
    finishToken(e20, t2) {
      this.state.end = this.state.pos;
      const s2 = this.state.type;
      this.state.type = e20, this.state.value = t2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const e20 = this.state.pos + 1, t2 = this.codePointAtPos(e20);
      if (t2 >= 48 && t2 <= 57)
        throw this.raise(this.state.pos, Rn$1.UnexpectedDigitAfterHash);
      if (t2 === 123 || t2 === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(this.state.pos, t2 === 123 ? Rn$1.RecordExpressionHashIncorrectStartSyntaxType : Rn$1.TupleExpressionHashIncorrectStartSyntaxType);
        this.state.pos += 2, t2 === 123 ? this.finishToken(bn$1.braceHashL) : this.finishToken(bn$1.bracketHashL);
      } else
        Jn$1(t2) ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1(t2))) : t2 === 92 ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1())) : this.finishOp(bn$1.hash, 1);
    }
    readToken_dot() {
      const e20 = this.input.charCodeAt(this.state.pos + 1);
      e20 >= 48 && e20 <= 57 ? this.readNumber(true) : e20 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(bn$1.ellipsis)) : (++this.state.pos, this.finishToken(bn$1.dot));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.slashAssign, 2) : this.finishOp(bn$1.slash, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let e20 = this.input.charCodeAt(this.state.pos + 1);
      if (e20 !== 33)
        return false;
      const t2 = this.state.pos;
      for (this.state.pos += 1; !wn$1(e20) && ++this.state.pos < this.length; )
        e20 = this.input.charCodeAt(this.state.pos);
      const s2 = this.input.slice(t2 + 2, this.state.pos);
      return this.finishToken(bn$1.interpreterDirective, s2), true;
    }
    readToken_mult_modulo(e20) {
      let t2 = e20 === 42 ? bn$1.star : bn$1.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
      e20 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), t2 = bn$1.exponent), r2 !== 61 || this.state.inType || (s2++, t2 = e20 === 37 ? bn$1.moduloAssign : bn$1.assign), this.finishOp(t2, s2);
    }
    readToken_pipe_amp(e20) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (t2 !== e20) {
        if (e20 === 124) {
          if (t2 === 62)
            return void this.finishOp(bn$1.pipeline, 2);
          if (this.hasPlugin("recordAndTuple") && t2 === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectEndSyntaxType);
            return this.state.pos += 2, void this.finishToken(bn$1.braceBarR);
          }
          if (this.hasPlugin("recordAndTuple") && t2 === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectEndSyntaxType);
            return this.state.pos += 2, void this.finishToken(bn$1.bracketBarR);
          }
        }
        t2 !== 61 ? this.finishOp(e20 === 124 ? bn$1.bitwiseOR : bn$1.bitwiseAND, 1) : this.finishOp(bn$1.assign, 2);
      } else
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(e20 === 124 ? bn$1.logicalOR : bn$1.logicalAND, 2);
    }
    readToken_caret() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.bitwiseXOR, 1);
    }
    readToken_plus_min(e20) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      t2 !== e20 ? t2 === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.plusMin, 1) : this.finishOp(bn$1.incDec, 2);
    }
    readToken_lt_gt(e20) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      let s2 = 1;
      if (t2 === e20)
        return s2 = e20 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s2) === 61 ? void this.finishOp(bn$1.assign, s2 + 1) : void this.finishOp(bn$1.bitShift, s2);
      t2 === 61 && (s2 = 2), this.finishOp(bn$1.relational, s2);
    }
    readToken_eq_excl(e20) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (t2 !== 61)
        return e20 === 61 && t2 === 62 ? (this.state.pos += 2, void this.finishToken(bn$1.arrow)) : void this.finishOp(e20 === 61 ? bn$1.eq : bn$1.bang, 1);
      this.finishOp(bn$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    }
    readToken_question() {
      const e20 = this.input.charCodeAt(this.state.pos + 1), t2 = this.input.charCodeAt(this.state.pos + 2);
      e20 === 63 ? t2 === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(bn$1.nullishCoalescing, 2) : e20 !== 46 || t2 >= 48 && t2 <= 57 ? (++this.state.pos, this.finishToken(bn$1.question)) : (this.state.pos += 2, this.finishToken(bn$1.questionDot));
    }
    getTokenFromCode(e20) {
      switch (e20) {
        case 46:
          return void this.readToken_dot();
        case 40:
          return ++this.state.pos, void this.finishToken(bn$1.parenL);
        case 41:
          return ++this.state.pos, void this.finishToken(bn$1.parenR);
        case 59:
          return ++this.state.pos, void this.finishToken(bn$1.semi);
        case 44:
          return ++this.state.pos, void this.finishToken(bn$1.comma);
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectStartSyntaxType);
            this.state.pos += 2, this.finishToken(bn$1.bracketBarL);
          } else
            ++this.state.pos, this.finishToken(bn$1.bracketL);
          return;
        case 93:
          return ++this.state.pos, void this.finishToken(bn$1.bracketR);
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectStartSyntaxType);
            this.state.pos += 2, this.finishToken(bn$1.braceBarL);
          } else
            ++this.state.pos, this.finishToken(bn$1.braceL);
          return;
        case 125:
          return ++this.state.pos, void this.finishToken(bn$1.braceR);
        case 58:
          return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(bn$1.doubleColon, 2) : (++this.state.pos, this.finishToken(bn$1.colon)));
        case 63:
          return void this.readToken_question();
        case 96:
          return ++this.state.pos, void this.finishToken(bn$1.backQuote);
        case 48: {
          const e21 = this.input.charCodeAt(this.state.pos + 1);
          if (e21 === 120 || e21 === 88)
            return void this.readRadixNumber(16);
          if (e21 === 111 || e21 === 79)
            return void this.readRadixNumber(8);
          if (e21 === 98 || e21 === 66)
            return void this.readRadixNumber(2);
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return void this.readNumber(false);
        case 34:
        case 39:
          return void this.readString(e20);
        case 47:
          return void this.readToken_slash();
        case 37:
        case 42:
          return void this.readToken_mult_modulo(e20);
        case 124:
        case 38:
          return void this.readToken_pipe_amp(e20);
        case 94:
          return void this.readToken_caret();
        case 43:
        case 45:
          return void this.readToken_plus_min(e20);
        case 60:
        case 62:
          return void this.readToken_lt_gt(e20);
        case 61:
        case 33:
          return void this.readToken_eq_excl(e20);
        case 126:
          return void this.finishOp(bn$1.tilde, 1);
        case 64:
          return ++this.state.pos, void this.finishToken(bn$1.at);
        case 35:
          return void this.readToken_numberSign();
        case 92:
          return void this.readWord();
        default:
          if (Jn$1(e20))
            return void this.readWord(e20);
      }
      throw this.raise(this.state.pos, Rn$1.InvalidOrUnexpectedToken, String.fromCodePoint(e20));
    }
    finishOp(e20, t2) {
      const s2 = this.input.slice(this.state.pos, this.state.pos + t2);
      this.state.pos += t2, this.finishToken(e20, s2);
    }
    readRegexp() {
      const e20 = this.state.start + 1;
      let t2, s2, {pos: r2} = this.state;
      for (; ; ++r2) {
        if (r2 >= this.length)
          throw this.raise(e20, Rn$1.UnterminatedRegExp);
        const i3 = this.input.charCodeAt(r2);
        if (wn$1(i3))
          throw this.raise(e20, Rn$1.UnterminatedRegExp);
        if (t2)
          t2 = false;
        else {
          if (i3 === 91)
            s2 = true;
          else if (i3 === 93 && s2)
            s2 = false;
          else if (i3 === 47 && !s2)
            break;
          t2 = i3 === 92;
        }
      }
      const i2 = this.input.slice(e20, r2);
      ++r2;
      let a2 = "";
      for (; r2 < this.length; ) {
        const e21 = this.codePointAtPos(r2), t3 = String.fromCharCode(e21);
        if (fo$1.has(e21))
          a2.includes(t3) && this.raise(r2 + 1, Rn$1.DuplicateRegExpFlags);
        else {
          if (!Yn$1(e21) && e21 !== 92)
            break;
          this.raise(r2 + 1, Rn$1.MalformedRegExpFlags);
        }
        ++r2, a2 += t3;
      }
      this.state.pos = r2, this.finishToken(bn$1.regexp, {pattern: i2, flags: a2});
    }
    readInt(e20, t2, s2, r2 = true) {
      const i2 = this.state.pos, a2 = e20 === 16 ? yo$1.hex : yo$1.decBinOct, n2 = e20 === 16 ? Ao$1.hex : e20 === 10 ? Ao$1.dec : e20 === 8 ? Ao$1.oct : Ao$1.bin;
      let o2 = false, u2 = 0;
      for (let i3 = 0, h2 = t2 == null ? 1 / 0 : t2; i3 < h2; ++i3) {
        const t3 = this.input.charCodeAt(this.state.pos);
        let h3;
        if (t3 !== 95) {
          if (h3 = t3 >= 97 ? t3 - 97 + 10 : t3 >= 65 ? t3 - 65 + 10 : mo$1(t3) ? t3 - 48 : 1 / 0, h3 >= e20)
            if (this.options.errorRecovery && h3 <= 9)
              h3 = 0, this.raise(this.state.start + i3 + 2, Rn$1.InvalidDigit, e20);
            else {
              if (!s2)
                break;
              h3 = 0, o2 = true;
            }
          ++this.state.pos, u2 = u2 * e20 + h3;
        } else {
          const e21 = this.input.charCodeAt(this.state.pos - 1), t4 = this.input.charCodeAt(this.state.pos + 1);
          (n2.indexOf(t4) === -1 || a2.indexOf(e21) > -1 || a2.indexOf(t4) > -1 || Number.isNaN(t4)) && this.raise(this.state.pos, Rn$1.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Rn$1.NumericSeparatorInEscapeSequence), ++this.state.pos;
        }
      }
      return this.state.pos === i2 || t2 != null && this.state.pos - i2 !== t2 || o2 ? null : u2;
    }
    readRadixNumber(e20) {
      const t2 = this.state.pos;
      let s2 = false;
      this.state.pos += 2;
      const r2 = this.readInt(e20);
      r2 == null && this.raise(this.state.start + 2, Rn$1.InvalidDigit, e20);
      const i2 = this.input.charCodeAt(this.state.pos);
      if (i2 === 110)
        ++this.state.pos, s2 = true;
      else if (i2 === 109)
        throw this.raise(t2, Rn$1.InvalidDecimal);
      if (Jn$1(this.codePointAtPos(this.state.pos)))
        throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
      if (s2) {
        const e21 = this.input.slice(t2, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(bn$1.bigint, e21);
      } else
        this.finishToken(bn$1.num, r2);
    }
    readNumber(e20) {
      const t2 = this.state.pos;
      let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
      e20 || this.readInt(10) !== null || this.raise(t2, Rn$1.InvalidNumber);
      const o2 = this.state.pos - t2 >= 2 && this.input.charCodeAt(t2) === 48;
      if (o2) {
        const e21 = this.input.slice(t2, this.state.pos);
        if (this.recordStrictModeErrors(t2, Rn$1.StrictOctalLiteral), !this.state.strict) {
          const s3 = e21.indexOf("_");
          s3 > 0 && this.raise(s3 + t2, Rn$1.ZeroDigitNumericSeparator);
        }
        n2 = o2 && !/[89]/.test(e21);
      }
      let u2 = this.input.charCodeAt(this.state.pos);
      if (u2 !== 46 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t2, Rn$1.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(t2, Rn$1.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(t2, Rn$1.InvalidDecimal), ++this.state.pos, i2 = true), Jn$1(this.codePointAtPos(this.state.pos)))
        throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
      const h2 = this.input.slice(t2, this.state.pos).replace(/[_mn]/g, "");
      if (r2)
        return void this.finishToken(bn$1.bigint, h2);
      if (i2)
        return void this.finishToken(bn$1.decimal, h2);
      const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
      this.finishToken(bn$1.num, c2);
    }
    readCodePoint(e20) {
      let t2;
      if (this.input.charCodeAt(this.state.pos) === 123) {
        const s2 = ++this.state.pos;
        if (t2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e20), ++this.state.pos, t2 !== null && t2 > 1114111) {
          if (!e20)
            return null;
          this.raise(s2, Rn$1.InvalidCodePoint);
        }
      } else
        t2 = this.readHexChar(4, false, e20);
      return t2;
    }
    readString(e20) {
      let t2 = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === e20)
          break;
        if (r2 === 92)
          t2 += this.input.slice(s2, this.state.pos), t2 += this.readEscapedChar(false), s2 = this.state.pos;
        else if (r2 === 8232 || r2 === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (wn$1(r2))
            throw this.raise(this.state.start, Rn$1.UnterminatedString);
          ++this.state.pos;
        }
      }
      t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
    }
    readTmplToken() {
      let e20 = "", t2 = this.state.pos, s2 = false;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedTemplate);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
          return this.state.pos === this.state.start && this.match(bn$1.template) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(bn$1.dollarBraceL)) : (++this.state.pos, void this.finishToken(bn$1.backQuote)) : (e20 += this.input.slice(t2, this.state.pos), void this.finishToken(bn$1.template, s2 ? null : e20));
        if (r2 === 92) {
          e20 += this.input.slice(t2, this.state.pos);
          const r3 = this.readEscapedChar(true);
          r3 === null ? s2 = true : e20 += r3, t2 = this.state.pos;
        } else if (wn$1(r2)) {
          switch (e20 += this.input.slice(t2, this.state.pos), ++this.state.pos, r2) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              e20 += "\n";
              break;
            default:
              e20 += String.fromCharCode(r2);
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, t2 = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(e20, t2) {
      this.state.strict && !this.state.strictErrors.has(e20) ? this.raise(e20, t2) : this.state.strictErrors.set(e20, t2);
    }
    readEscapedChar(e20) {
      const t2 = !e20, s2 = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, s2) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120: {
          const e21 = this.readHexChar(2, false, t2);
          return e21 === null ? null : String.fromCharCode(e21);
        }
        case 117: {
          const e21 = this.readCodePoint(t2);
          return e21 === null ? null : String.fromCodePoint(e21);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (e20)
            return null;
          this.recordStrictModeErrors(this.state.pos - 1, Rn$1.StrictNumericEscape);
        default:
          if (s2 >= 48 && s2 <= 55) {
            const t3 = this.state.pos - 1;
            let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
            r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
            const i2 = this.input.charCodeAt(this.state.pos);
            if (s3 !== "0" || i2 === 56 || i2 === 57) {
              if (e20)
                return null;
              this.recordStrictModeErrors(t3, Rn$1.StrictNumericEscape);
            }
            return String.fromCharCode(r2);
          }
          return String.fromCharCode(s2);
      }
    }
    readHexChar(e20, t2, s2) {
      const r2 = this.state.pos, i2 = this.readInt(16, e20, t2, false);
      return i2 === null && (s2 ? this.raise(r2, Rn$1.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
    }
    readWord1(e20) {
      this.state.containsEsc = false;
      let t2 = "";
      const s2 = this.state.pos;
      let r2 = this.state.pos;
      for (e20 !== void 0 && (this.state.pos += e20 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const e21 = this.codePointAtPos(this.state.pos);
        if (Yn$1(e21))
          this.state.pos += e21 <= 65535 ? 1 : 2;
        else {
          if (e21 !== 92)
            break;
          {
            this.state.containsEsc = true, t2 += this.input.slice(r2, this.state.pos);
            const e22 = this.state.pos, i2 = this.state.pos === s2 ? Jn$1 : Yn$1;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(this.state.pos, Rn$1.MissingUnicodeEscape), r2 = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const a2 = this.readCodePoint(true);
            a2 !== null && (i2(a2) || this.raise(e22, Rn$1.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), r2 = this.state.pos;
          }
        }
      }
      return t2 + this.input.slice(r2, this.state.pos);
    }
    readWord(e20) {
      const t2 = this.readWord1(e20), s2 = xn$1.get(t2) || bn$1.name;
      this.finishToken(s2, t2);
    }
    checkKeywordEscapes() {
      const e20 = this.state.type.keyword;
      e20 && this.state.containsEsc && this.raise(this.state.start, Rn$1.InvalidEscapedReservedWord, e20);
    }
    updateContext(e20) {
      var t2, s2;
      (t2 = (s2 = this.state.type).updateContext) == null || t2.call(s2, this.state.context);
    }
  } {
    addExtra(e20, t2, s2) {
      if (!e20)
        return;
      (e20.extra = e20.extra || {})[t2] = s2;
    }
    isRelational(e20) {
      return this.match(bn$1.relational) && this.state.value === e20;
    }
    expectRelational(e20) {
      this.isRelational(e20) ? this.next() : this.unexpected(null, bn$1.relational);
    }
    isContextual(e20) {
      return this.match(bn$1.name) && this.state.value === e20 && !this.state.containsEsc;
    }
    isUnparsedContextual(e20, t2) {
      const s2 = e20 + t2.length;
      if (this.input.slice(e20, s2) === t2) {
        const e21 = this.input.charCodeAt(s2);
        return !(Yn$1(e21) || (64512 & e21) == 55296);
      }
      return false;
    }
    isLookaheadContextual(e20) {
      const t2 = this.nextTokenStart();
      return this.isUnparsedContextual(t2, e20);
    }
    eatContextual(e20) {
      return this.isContextual(e20) && this.eat(bn$1.name);
    }
    expectContextual(e20, t2) {
      this.eatContextual(e20) || this.unexpected(null, t2);
    }
    canInsertSemicolon() {
      return this.match(bn$1.eof) || this.match(bn$1.braceR) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Pn$1.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
    hasFollowingLineBreak() {
      return Bn$1.lastIndex = this.state.end, Bn$1.test(this.input);
    }
    isLineTerminator() {
      return this.eat(bn$1.semi) || this.canInsertSemicolon();
    }
    semicolon(e20 = true) {
      (e20 ? this.isLineTerminator() : this.eat(bn$1.semi)) || this.raise(this.state.lastTokEnd, Rn$1.MissingSemicolon);
    }
    expect(e20, t2) {
      this.eat(e20) || this.unexpected(t2, e20);
    }
    assertNoSpace(e20 = "Unexpected space.") {
      this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, {code: Mn$1.SyntaxError, reasonCode: "UnexpectedSpace", template: e20});
    }
    unexpected(e20, t2 = {code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token"}) {
      throw t2 instanceof Cn$1 && (t2 = {code: Mn$1.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${t2.label}"`}), this.raise(e20 != null ? e20 : this.state.start, t2);
    }
    expectPlugin(e20, t2) {
      if (!this.hasPlugin(e20))
        throw this.raiseWithData(t2 != null ? t2 : this.state.start, {missingPlugin: [e20]}, `This experimental syntax requires enabling the parser plugin: '${e20}'`);
      return true;
    }
    expectOnePlugin(e20, t2) {
      if (!e20.some((e21) => this.hasPlugin(e21)))
        throw this.raiseWithData(t2 != null ? t2 : this.state.start, {missingPlugin: e20}, `This experimental syntax requires enabling one of the following parser plugin(s): '${e20.join(", ")}'`);
    }
    tryParse(e20, t2 = this.state.clone()) {
      const s2 = {node: null};
      try {
        const r2 = e20((e21 = null) => {
          throw s2.node = e21, s2;
        });
        if (this.state.errors.length > t2.errors.length) {
          const e21 = this.state;
          return this.state = t2, this.state.tokensLength = e21.tokensLength, {node: r2, error: e21.errors[t2.errors.length], thrown: false, aborted: false, failState: e21};
        }
        return {node: r2, error: null, thrown: false, aborted: false, failState: null};
      } catch (e21) {
        const r2 = this.state;
        if (this.state = t2, e21 instanceof SyntaxError)
          return {node: null, error: e21, thrown: true, aborted: false, failState: r2};
        if (e21 === s2)
          return {node: s2.node, error: null, thrown: false, aborted: true, failState: r2};
        throw e21;
      }
    }
    checkExpressionErrors(e20, t2) {
      if (!e20)
        return false;
      const {shorthandAssign: s2, doubleProto: r2, optionalParameters: i2} = e20;
      if (!t2)
        return s2 >= 0 || r2 >= 0 || i2 >= 0;
      s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Rn$1.DuplicateProto), i2 >= 0 && this.unexpected(i2);
    }
    isLiteralPropertyName() {
      return this.match(bn$1.name) || !!this.state.type.keyword || this.match(bn$1.string) || this.match(bn$1.num) || this.match(bn$1.bigint) || this.match(bn$1.decimal);
    }
    isPrivateName(e20) {
      return e20.type === "PrivateName";
    }
    getPrivateNameSV(e20) {
      return e20.id.name;
    }
    hasPropertyAsPrivateName(e20) {
      return (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression") && this.isPrivateName(e20.property);
    }
    isOptionalChain(e20) {
      return e20.type === "OptionalMemberExpression" || e20.type === "OptionalCallExpression";
    }
    isObjectProperty(e20) {
      return e20.type === "ObjectProperty";
    }
    isObjectMethod(e20) {
      return e20.type === "ObjectMethod";
    }
    initializeScopes(e20 = this.options.sourceType === "module") {
      const t2 = this.state.labels;
      this.state.labels = [];
      const s2 = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      const r2 = this.inModule;
      this.inModule = e20;
      const i2 = this.scope, a2 = this.getScopeHandler();
      this.scope = new a2(this.raise.bind(this), this.inModule);
      const n2 = this.prodParam;
      this.prodParam = new To$1();
      const o2 = this.classScope;
      this.classScope = new xo$1(this.raise.bind(this));
      const u2 = this.expressionScope;
      return this.expressionScope = new bo$1(this.raise.bind(this)), () => {
        this.state.labels = t2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
      };
    }
    enterInitialScopes() {
      let e20 = 0;
      this.inModule && (e20 |= 2), this.scope.enter(1), this.prodParam.enter(e20);
    }
  } {
    startNode() {
      return new Bo$1(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(e20, t2) {
      return new Bo$1(this, e20, t2);
    }
    startNodeAtNode(e20) {
      return this.startNodeAt(e20.start, e20.loc.start);
    }
    finishNode(e20, t2) {
      return this.finishNodeAt(e20, t2, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
    finishNodeAt(e20, t2, s2, r2) {
      return e20.type = t2, e20.end = s2, e20.loc.end = r2, this.options.ranges && (e20.range[1] = s2), this.options.attachComment && this.processComment(e20), e20;
    }
    resetStartLocation(e20, t2, s2) {
      e20.start = t2, e20.loc.start = s2, this.options.ranges && (e20.range[0] = t2);
    }
    resetEndLocation(e20, t2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
      e20.end = t2, e20.loc.end = s2, this.options.ranges && (e20.range[1] = t2);
    }
    resetStartLocationFromNode(e20, t2) {
      this.resetStartLocation(e20, t2.start, t2.loc.start);
    }
  } {
    toAssignable(e20, t2 = false) {
      var s2, r2;
      let i2;
      switch ((e20.type === "ParenthesizedExpression" || (s2 = e20.extra) != null && s2.parenthesized) && (i2 = nu(e20), t2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e20.start, Rn$1.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment) : this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment)), e20.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e20.type = "ObjectPattern";
          for (let s3 = 0, r3 = e20.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
            var a2;
            const r4 = e20.properties[s3], n2 = s3 === i3;
            this.toAssignableObjectExpressionProp(r4, n2, t2), n2 && r4.type === "RestElement" && (a2 = e20.extra) != null && a2.trailingComma && this.raiseRestNotLast(e20.extra.trailingComma);
          }
          break;
        case "ObjectProperty":
          this.toAssignable(e20.value, t2);
          break;
        case "SpreadElement": {
          this.checkToRestConversion(e20), e20.type = "RestElement";
          const s3 = e20.argument;
          this.toAssignable(s3, t2);
          break;
        }
        case "ArrayExpression":
          e20.type = "ArrayPattern", this.toAssignableList(e20.elements, (r2 = e20.extra) == null ? void 0 : r2.trailingComma, t2);
          break;
        case "AssignmentExpression":
          e20.operator !== "=" && this.raise(e20.left.end, Rn$1.MissingEqInAssignment), e20.type = "AssignmentPattern", delete e20.operator, this.toAssignable(e20.left, t2);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(i2, t2);
      }
      return e20;
    }
    toAssignableObjectExpressionProp(e20, t2, s2) {
      if (e20.type === "ObjectMethod") {
        const t3 = e20.kind === "get" || e20.kind === "set" ? Rn$1.PatternHasAccessor : Rn$1.PatternHasMethod;
        this.raise(e20.key.start, t3);
      } else
        e20.type !== "SpreadElement" || t2 ? this.toAssignable(e20, s2) : this.raiseRestNotLast(e20.start);
    }
    toAssignableList(e20, t2, s2) {
      let r2 = e20.length;
      if (r2) {
        const i2 = e20[r2 - 1];
        if ((i2 == null ? void 0 : i2.type) === "RestElement")
          --r2;
        else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
          i2.type = "RestElement";
          let e21 = i2.argument;
          this.toAssignable(e21, s2), e21 = nu(e21), e21.type !== "Identifier" && e21.type !== "MemberExpression" && e21.type !== "ArrayPattern" && e21.type !== "ObjectPattern" && this.unexpected(e21.start), t2 && this.raiseTrailingCommaAfterRest(t2), --r2;
        }
      }
      for (let t3 = 0; t3 < r2; t3++) {
        const r3 = e20[t3];
        r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
      }
      return e20;
    }
    isAssignable(e20, t2) {
      switch (e20.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const t3 = e20.properties.length - 1;
          return e20.properties.every((e21, s2) => e21.type !== "ObjectMethod" && (s2 === t3 || e21.type !== "SpreadElement") && this.isAssignable(e21));
        }
        case "ObjectProperty":
          return this.isAssignable(e20.value);
        case "SpreadElement":
          return this.isAssignable(e20.argument);
        case "ArrayExpression":
          return e20.elements.every((e21) => e21 === null || this.isAssignable(e21));
        case "AssignmentExpression":
          return e20.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e20.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t2;
        default:
          return false;
      }
    }
    toReferencedList(e20, t2) {
      return e20;
    }
    toReferencedListDeep(e20, t2) {
      this.toReferencedList(e20, t2);
      for (const t3 of e20)
        (t3 == null ? void 0 : t3.type) === "ArrayExpression" && this.toReferencedListDeep(t3.elements);
    }
    parseSpread(e20, t2) {
      const s2 = this.startNode();
      return this.next(), s2.argument = this.parseMaybeAssignAllowIn(e20, void 0, t2), this.finishNode(s2, "SpreadElement");
    }
    parseRestBinding() {
      const e20 = this.startNode();
      return this.next(), e20.argument = this.parseBindingAtom(), this.finishNode(e20, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1.bracketL: {
          const e20 = this.startNode();
          return this.next(), e20.elements = this.parseBindingList(bn$1.bracketR, 93, true), this.finishNode(e20, "ArrayPattern");
        }
        case bn$1.braceL:
          return this.parseObjectLike(bn$1.braceR, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e20, t2, s2, r2) {
      const i2 = [];
      let a2 = true;
      for (; !this.eat(e20); )
        if (a2 ? a2 = false : this.expect(bn$1.comma), s2 && this.match(bn$1.comma))
          i2.push(null);
        else {
          if (this.eat(e20))
            break;
          if (this.match(bn$1.ellipsis)) {
            i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t2), this.expect(e20);
            break;
          }
          {
            const e21 = [];
            for (this.match(bn$1.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedParameterDecorator); this.match(bn$1.at); )
              e21.push(this.parseDecorator());
            i2.push(this.parseAssignableListItem(r2, e21));
          }
        }
      return i2;
    }
    parseAssignableListItem(e20, t2) {
      const s2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s2);
      const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
      return t2.length && (s2.decorators = t2), r2;
    }
    parseAssignableListItemTypes(e20) {
      return e20;
    }
    parseMaybeDefault(e20, t2, s2) {
      var r2, i2, a2;
      if (t2 = (r2 = t2) != null ? r2 : this.state.startLoc, e20 = (i2 = e20) != null ? i2 : this.state.start, s2 = (a2 = s2) != null ? a2 : this.parseBindingAtom(), !this.eat(bn$1.eq))
        return s2;
      const n2 = this.startNodeAt(e20, t2);
      return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
    }
    checkLVal(e20, t2, s2 = 64, r2, i2, a2 = false) {
      switch (e20.type) {
        case "Identifier": {
          const {name: t3} = e20;
          this.state.strict && (a2 ? no$1(t3, this.inModule) : ao$1(t3)) && this.raise(e20.start, s2 === 64 ? Rn$1.StrictEvalArguments : Rn$1.StrictEvalArgumentsBinding, t3), r2 && (r2.has(t3) ? this.raise(e20.start, Rn$1.ParamDupe) : r2.add(t3)), i2 && t3 === "let" && this.raise(e20.start, Rn$1.LetInLexicalBinding), 64 & s2 || this.scope.declareName(t3, s2, e20.start);
          break;
        }
        case "MemberExpression":
          s2 !== 64 && this.raise(e20.start, Rn$1.InvalidPropertyBindingPattern);
          break;
        case "ObjectPattern":
          for (let t3 of e20.properties) {
            if (this.isObjectProperty(t3))
              t3 = t3.value;
            else if (this.isObjectMethod(t3))
              continue;
            this.checkLVal(t3, "object destructuring pattern", s2, r2, i2);
          }
          break;
        case "ArrayPattern":
          for (const t3 of e20.elements)
            t3 && this.checkLVal(t3, "array destructuring pattern", s2, r2, i2);
          break;
        case "AssignmentPattern":
          this.checkLVal(e20.left, "assignment pattern", s2, r2);
          break;
        case "RestElement":
          this.checkLVal(e20.argument, "rest element", s2, r2);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(e20.expression, "parenthesized expression", s2, r2);
          break;
        default:
          this.raise(e20.start, s2 === 64 ? Rn$1.InvalidLhs : Rn$1.InvalidLhsBinding, t2);
      }
    }
    checkToRestConversion(e20) {
      e20.argument.type !== "Identifier" && e20.argument.type !== "MemberExpression" && this.raise(e20.argument.start, Rn$1.InvalidRestAssignmentPattern);
    }
    checkCommaAfterRest(e20) {
      this.match(bn$1.comma) && (this.lookaheadCharCode() === e20 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
    }
    raiseRestNotLast(e20) {
      throw this.raise(e20, Rn$1.ElementAfterRest);
    }
    raiseTrailingCommaAfterRest(e20) {
      this.raise(e20, Rn$1.RestTrailingComma);
    }
  } {
    checkProto(e20, t2, s2, r2) {
      if (e20.type === "SpreadElement" || this.isObjectMethod(e20) || e20.computed || e20.shorthand)
        return;
      const i2 = e20.key;
      if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
        if (t2)
          return void this.raise(i2.start, Rn$1.RecordNoProto);
        s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Rn$1.DuplicateProto)), s2.used = true;
      }
    }
    shouldExitDescending(e20, t2) {
      return e20.type === "ArrowFunctionExpression" && e20.start === t2;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e20 = this.parseExpression();
      return this.match(bn$1.eof) || this.unexpected(), this.finalizeRemainingComments(), e20.comments = this.state.comments, e20.errors = this.state.errors, this.options.tokens && (e20.tokens = this.tokens), e20;
    }
    parseExpression(e20, t2) {
      return e20 ? this.disallowInAnd(() => this.parseExpressionBase(t2)) : this.allowInAnd(() => this.parseExpressionBase(t2));
    }
    parseExpressionBase(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(e20);
      if (this.match(bn$1.comma)) {
        const i2 = this.startNodeAt(t2, s2);
        for (i2.expressions = [r2]; this.eat(bn$1.comma); )
          i2.expressions.push(this.parseMaybeAssign(e20));
        return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
      }
      return r2;
    }
    parseMaybeAssignDisallowIn(e20, t2) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e20, t2));
    }
    parseMaybeAssignAllowIn(e20, t2) {
      return this.allowInAnd(() => this.parseMaybeAssign(e20, t2));
    }
    setOptionalParametersError(e20, t2) {
      var s2;
      e20.optionalParameters = (s2 = t2 == null ? void 0 : t2.pos) != null ? s2 : this.state.start;
    }
    parseMaybeAssign(e20, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      if (this.isContextual("yield") && this.prodParam.hasYield) {
        let e21 = this.parseYield();
        return t2 && (e21 = t2.call(this, e21, s2, r2)), e21;
      }
      let i2;
      e20 ? i2 = false : (e20 = new So$1(), i2 = true), (this.match(bn$1.parenL) || this.match(bn$1.name)) && (this.state.potentialArrowAt = this.state.start);
      let a2 = this.parseMaybeConditional(e20);
      if (t2 && (a2 = t2.call(this, a2, s2, r2)), this.state.type.isAssign) {
        const t3 = this.startNodeAt(s2, r2), i3 = this.state.value;
        t3.operator = i3;
        if (a2.type === "BinaryExpression" && a2.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack")
          throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, i3);
        return this.match(bn$1.eq) ? (t3.left = this.toAssignable(a2, true), e20.doubleProto = -1) : t3.left = a2, e20.shorthandAssign >= t3.left.start && (e20.shorthandAssign = -1), this.checkLVal(a2, "assignment expression"), this.next(), t3.right = this.parseMaybeAssign(), this.finishNode(t3, "AssignmentExpression");
      }
      return i2 && this.checkExpressionErrors(e20, true), a2;
    }
    parseMaybeConditional(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(e20);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, t2, s2, e20);
    }
    parseConditional(e20, t2, s2, r2) {
      if (this.eat(bn$1.question)) {
        const r3 = this.startNodeAt(t2, s2);
        return r3.test = e20, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(bn$1.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
      }
      return e20;
    }
    parseMaybeUnaryOrPrivate(e20) {
      return this.match(bn$1.privateName) ? this.parsePrivateName() : this.parseMaybeUnary(e20);
    }
    parseExprOps(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(e20);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, t2, s2, -1);
    }
    parseExprOp(e20, t2, s2, r2) {
      if (this.isPrivateName(e20)) {
        const t3 = this.getPrivateNameSV(e20), {start: s3} = e20;
        (r2 >= bn$1._in.binop || !this.prodParam.hasIn || !this.match(bn$1._in)) && this.raise(s3, Rn$1.PrivateInExpectedIn, t3), this.classScope.usePrivateName(t3, s3);
      }
      let i2 = this.state.type.binop;
      if (i2 != null && (this.prodParam.hasIn || !this.match(bn$1._in)) && i2 > r2) {
        const a2 = this.state.type;
        if (a2 === bn$1.pipeline) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return e20;
          this.checkPipelineAtInfixOperator(e20, t2);
        }
        const n2 = this.startNodeAt(t2, s2);
        n2.left = e20, n2.operator = this.state.value;
        const o2 = a2 === bn$1.logicalOR || a2 === bn$1.logicalAND, u2 = a2 === bn$1.nullishCoalescing;
        if (u2 && (i2 = bn$1.logicalAND.binop), this.next(), a2 === bn$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(bn$1.name) && this.state.value === "await" && this.prodParam.hasAwait)
          throw this.raise(this.state.start, Rn$1.UnexpectedAwaitAfterPipelineBody);
        n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
        const h2 = this.state.type;
        if (u2 && (h2 === bn$1.logicalOR || h2 === bn$1.logicalAND) || o2 && h2 === bn$1.nullishCoalescing)
          throw this.raise(this.state.start, Rn$1.MixingCoalesceWithLogical);
        return this.parseExprOp(n2, t2, s2, r2);
      }
      return e20;
    }
    parseExprOpRightExpr(e20, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      switch (e20) {
        case bn$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                const r3 = this.parseHackPipeBody(e20, t2);
                return this.checkHackPipeBodyEarlyErrors(s2), r3;
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                const i2 = this.parseHackPipeBody(e20, t2);
                return this.parseSmartPipelineBodyInStyle(i2, s2, r2);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t2));
          }
        default:
          return this.parseExprOpBaseRightExpr(e20, t2);
      }
    }
    parseExprOpBaseRightExpr(e20, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, e20.rightAssociative ? t2 - 1 : t2);
    }
    parseHackPipeBody(e20, t2) {
      if (this.prodParam.hasYield && this.isContextual("yield"))
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, this.state.value);
      return this.parseExprOpBaseRightExpr(e20, t2);
    }
    checkExponentialAfterUnary(e20) {
      this.match(bn$1.exponent) && this.raise(e20.argument.start, Rn$1.UnexpectedTokenUnaryExponentiation);
    }
    parseMaybeUnary(e20, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
      if (i2 && this.isAwaitAllowed()) {
        this.next();
        const e21 = this.parseAwait(s2, r2);
        return t2 || this.checkExponentialAfterUnary(e21), e21;
      }
      const a2 = this.match(bn$1.incDec), n2 = this.startNode();
      if (this.state.type.prefix) {
        n2.operator = this.state.value, n2.prefix = true, this.match(bn$1._throw) && this.expectPlugin("throwExpressions");
        const s3 = this.match(bn$1._delete);
        if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e20, true), this.state.strict && s3) {
          const e21 = n2.argument;
          e21.type === "Identifier" ? this.raise(n2.start, Rn$1.StrictDelete) : this.hasPropertyAsPrivateName(e21) && this.raise(n2.start, Rn$1.DeletePrivateField);
        }
        if (!a2)
          return t2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
      }
      const o2 = this.parseUpdate(n2, a2, e20);
      if (i2) {
        if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(bn$1.modulo)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(s2, Rn$1.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
      }
      return o2;
    }
    parseUpdate(e20, t2, s2) {
      if (t2)
        return this.checkLVal(e20.argument, "prefix operation"), this.finishNode(e20, "UpdateExpression");
      const r2 = this.state.start, i2 = this.state.startLoc;
      let a2 = this.parseExprSubscripts(s2);
      if (this.checkExpressionErrors(s2, false))
        return a2;
      for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
        const e21 = this.startNodeAt(r2, i2);
        e21.operator = this.state.value, e21.prefix = false, e21.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(e21, "UpdateExpression");
      }
      return a2;
    }
    parseExprSubscripts(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(e20);
      return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, t2, s2);
    }
    parseSubscripts(e20, t2, s2, r2) {
      const i2 = {optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e20), stop: false};
      do {
        e20 = this.parseSubscript(e20, t2, s2, r2, i2), i2.maybeAsyncArrow = false;
      } while (!i2.stop);
      return e20;
    }
    parseSubscript(e20, t2, s2, r2, i2) {
      if (!r2 && this.eat(bn$1.doubleColon))
        return this.parseBind(e20, t2, s2, r2, i2);
      if (this.match(bn$1.backQuote))
        return this.parseTaggedTemplateExpression(e20, t2, s2, i2);
      let a2 = false;
      if (this.match(bn$1.questionDot)) {
        if (r2 && this.lookaheadCharCode() === 40)
          return i2.stop = true, e20;
        i2.optionalChainMember = a2 = true, this.next();
      }
      if (!r2 && this.match(bn$1.parenL))
        return this.parseCoverCallAndAsyncArrowHead(e20, t2, s2, i2, a2);
      {
        const r3 = this.eat(bn$1.bracketL);
        return r3 || a2 || this.eat(bn$1.dot) ? this.parseMember(e20, t2, s2, i2, r3, a2) : (i2.stop = true, e20);
      }
    }
    parseMember(e20, t2, s2, r2, i2, a2) {
      const n2 = this.startNodeAt(t2, s2);
      n2.object = e20, n2.computed = i2;
      const o2 = !i2 && this.match(bn$1.privateName) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
      return o2 !== false && (n2.object.type === "Super" && this.raise(t2, Rn$1.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), n2.property = u2, i2 && this.expect(bn$1.bracketR), r2.optionalChainMember ? (n2.optional = a2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
    }
    parseBind(e20, t2, s2, r2, i2) {
      const a2 = this.startNodeAt(t2, s2);
      return a2.object = e20, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), t2, s2, r2);
    }
    parseCoverCallAndAsyncArrowHead(e20, t2, s2, r2, i2) {
      const a2 = this.state.maybeInArrowParameters;
      let n2 = null;
      this.state.maybeInArrowParameters = true, this.next();
      let o2 = this.startNodeAt(t2, s2);
      return o2.callee = e20, r2.maybeAsyncArrow && (this.expressionScope.enter(new go$1(2)), n2 = new So$1()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(bn$1.parenR) : this.parseCallExpressionArguments(bn$1.parenR, e20.type === "Import", e20.type !== "Super", o2, n2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = a2, o2;
    }
    toReferencedArguments(e20, t2) {
      this.toReferencedListDeep(e20.arguments, t2);
    }
    parseTaggedTemplateExpression(e20, t2, s2, r2) {
      const i2 = this.startNodeAt(t2, s2);
      return i2.tag = e20, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(t2, Rn$1.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e20) {
      return e20.type === "Identifier" && e20.name === "async" && this.state.lastTokEnd === e20.end && !this.canInsertSemicolon() && e20.end - e20.start == 5 && e20.start === this.state.potentialArrowAt;
    }
    finishCallExpression(e20, t2) {
      if (e20.callee.type === "Import")
        if (e20.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e20.arguments.length === 0 || e20.arguments.length > 2)
          this.raise(e20.start, Rn$1.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        else
          for (const t3 of e20.arguments)
            t3.type === "SpreadElement" && this.raise(t3.start, Rn$1.ImportCallSpreadArgument);
      return this.finishNode(e20, t2 ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e20, t2, s2, r2, i2) {
      const a2 = [];
      let n2 = true;
      const o2 = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e20); ) {
        if (n2)
          n2 = false;
        else if (this.expect(bn$1.comma), this.match(e20)) {
          !t2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Rn$1.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
          break;
        }
        a2.push(this.parseExprListItem(false, i2, s2));
      }
      return this.state.inFSharpPipelineDirectBody = o2, a2;
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.arrow) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e20, t2) {
      var s2;
      return this.resetPreviousNodeTrailingComments(t2), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2.arguments, true, (s2 = t2.extra) == null ? void 0 : s2.trailingComma), Ln$1(e20, t2.innerComments), Ln$1(e20, t2.callee.trailingComments), e20;
    }
    parseNoCallExpr() {
      const e20 = this.state.start, t2 = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e20, t2, true);
    }
    parseExprAtom(e20) {
      let t2;
      switch (this.state.type) {
        case bn$1._super:
          return this.parseSuper();
        case bn$1._import:
          return t2 = this.startNode(), this.next(), this.match(bn$1.dot) ? this.parseImportMetaProperty(t2) : (this.match(bn$1.parenL) || this.raise(this.state.lastTokStart, Rn$1.UnsupportedImport), this.finishNode(t2, "Import"));
        case bn$1._this:
          return t2 = this.startNode(), this.next(), this.finishNode(t2, "ThisExpression");
        case bn$1.name: {
          if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
            return this.parseModuleExpression();
          const e21 = this.state.potentialArrowAt === this.state.start, t3 = this.state.containsEsc, s2 = this.parseIdentifier();
          if (!t3 && s2.name === "async" && !this.canInsertSemicolon()) {
            if (this.match(bn$1._function))
              return this.resetPreviousNodeTrailingComments(s2), this.next(), this.parseFunction(this.startNodeAtNode(s2), void 0, true);
            if (this.match(bn$1.name))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s2)) : s2;
            if (this.match(bn$1._do))
              return this.resetPreviousNodeTrailingComments(s2), this.parseDo(this.startNodeAtNode(s2), true);
          }
          return e21 && this.match(bn$1.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s2), [s2], false)) : s2;
        }
        case bn$1._do:
          return this.parseDo(this.startNode(), false);
        case bn$1.slash:
        case bn$1.slashAssign:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case bn$1.num:
          return this.parseNumericLiteral(this.state.value);
        case bn$1.bigint:
          return this.parseBigIntLiteral(this.state.value);
        case bn$1.decimal:
          return this.parseDecimalLiteral(this.state.value);
        case bn$1.string:
          return this.parseStringLiteral(this.state.value);
        case bn$1._null:
          return this.parseNullLiteral();
        case bn$1._true:
          return this.parseBooleanLiteral(true);
        case bn$1._false:
          return this.parseBooleanLiteral(false);
        case bn$1.parenL: {
          const e21 = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e21);
        }
        case bn$1.bracketBarL:
        case bn$1.bracketHashL:
          return this.parseArrayLike(this.state.type === bn$1.bracketBarL ? bn$1.bracketBarR : bn$1.bracketR, false, true, e20);
        case bn$1.bracketL:
          return this.parseArrayLike(bn$1.bracketR, true, false, e20);
        case bn$1.braceBarL:
        case bn$1.braceHashL:
          return this.parseObjectLike(this.state.type === bn$1.braceBarL ? bn$1.braceBarR : bn$1.braceR, false, true, e20);
        case bn$1.braceL:
          return this.parseObjectLike(bn$1.braceR, false, false, e20);
        case bn$1._function:
          return this.parseFunctionOrFunctionSent();
        case bn$1.at:
          this.parseDecorators();
        case bn$1._class:
          return t2 = this.startNode(), this.takeDecorators(t2), this.parseClass(t2, false);
        case bn$1._new:
          return this.parseNewOrNewTarget();
        case bn$1.backQuote:
          return this.parseTemplate(false);
        case bn$1.doubleColon: {
          t2 = this.startNode(), this.next(), t2.object = null;
          const e21 = t2.callee = this.parseNoCallExpr();
          if (e21.type === "MemberExpression")
            return this.finishNode(t2, "BindExpression");
          throw this.raise(e21.start, Rn$1.UnsupportedBind);
        }
        case bn$1.privateName:
          return this.raise(this.state.start, Rn$1.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
        case bn$1.moduloAssign:
          if (this.getPluginOption("pipelineOperator", "proposal") !== "hack" || this.getPluginOption("pipelineOperator", "topicToken") !== "%")
            throw this.unexpected();
          this.state.value = "%", this.state.type = bn$1.modulo, this.state.pos--, this.state.end--, this.state.endLoc.column--;
        case bn$1.modulo:
        case bn$1.hash: {
          const e21 = this.getPluginOption("pipelineOperator", "proposal");
          if (e21) {
            t2 = this.startNode();
            const s2 = this.state.start, r2 = this.state.type;
            return this.next(), this.finishTopicReference(t2, s2, e21, r2);
          }
        }
        case bn$1.relational:
          if (this.state.value === "<") {
            const e21 = this.input.codePointAt(this.nextTokenStart());
            (Jn$1(e21) || e21 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
          }
        default:
          throw this.unexpected();
      }
    }
    finishTopicReference(e20, t2, s2, r2) {
      if (this.testTopicReferenceConfiguration(s2, t2, r2)) {
        let r3;
        return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(t2, Rn$1.PrimaryTopicNotAllowed) : this.raise(t2, Rn$1.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(e20, r3);
      }
      throw this.raise(t2, Rn$1.PipeTopicUnconfiguredToken, r2.label);
    }
    testTopicReferenceConfiguration(e20, t2, s2) {
      switch (e20) {
        case "hack": {
          const e21 = this.getPluginOption("pipelineOperator", "topicToken");
          return s2.label === e21;
        }
        case "smart":
          return s2 === bn$1.hash;
        default:
          throw this.raise(t2, Rn$1.PipeTopicRequiresHackPipes);
      }
    }
    parseAsyncArrowUnaryFunction(e20) {
      this.prodParam.enter(wo$1(true, this.prodParam.hasYield));
      const t2 = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Rn$1.LineTerminatorBeforeArrow), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2, true), e20;
    }
    parseDo(e20, t2) {
      this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions"), e20.async = t2, this.next();
      const s2 = this.state.labels;
      return this.state.labels = [], t2 ? (this.prodParam.enter(2), e20.body = this.parseBlock(), this.prodParam.exit()) : e20.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e20, "DoExpression");
    }
    parseSuper() {
      const e20 = this.startNode();
      return this.next(), !this.match(bn$1.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e20.start, Rn$1.UnexpectedSuper) : this.raise(e20.start, Rn$1.SuperNotAllowed), this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.dot) || this.raise(e20.start, Rn$1.UnsupportedSuper), this.finishNode(e20, "Super");
    }
    parseMaybePrivateName(e20) {
      return this.match(bn$1.privateName) ? (e20 || this.raise(this.state.start + 1, Rn$1.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
    }
    parsePrivateName() {
      const e20 = this.startNode(), t2 = this.startNodeAt(this.state.start + 1, new In$1(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
      return this.next(), e20.id = this.createIdentifier(t2, s2), this.finishNode(e20, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e20 = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(bn$1.dot)) {
        const t2 = this.createIdentifier(this.startNodeAtNode(e20), "function");
        return this.next(), this.parseMetaProperty(e20, t2, "sent");
      }
      return this.parseFunction(e20);
    }
    parseMetaProperty(e20, t2, s2) {
      e20.meta = t2, t2.name === "function" && s2 === "sent" && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
      const r2 = this.state.containsEsc;
      return e20.property = this.parseIdentifier(true), (e20.property.name !== s2 || r2) && this.raise(e20.property.start, Rn$1.UnsupportedMetaProperty, t2.name, s2), this.finishNode(e20, "MetaProperty");
    }
    parseImportMetaProperty(e20) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e20), "import");
      return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t2.start, jn$1.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e20, t2, "meta");
    }
    parseLiteralAtNode(e20, t2, s2) {
      return this.addExtra(s2, "rawValue", e20), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = e20, this.next(), this.finishNode(s2, t2);
    }
    parseLiteral(e20, t2) {
      const s2 = this.startNode();
      return this.parseLiteralAtNode(e20, t2, s2);
    }
    parseStringLiteral(e20) {
      return this.parseLiteral(e20, "StringLiteral");
    }
    parseNumericLiteral(e20) {
      return this.parseLiteral(e20, "NumericLiteral");
    }
    parseBigIntLiteral(e20) {
      return this.parseLiteral(e20, "BigIntLiteral");
    }
    parseDecimalLiteral(e20) {
      return this.parseLiteral(e20, "DecimalLiteral");
    }
    parseRegExpLiteral(e20) {
      const t2 = this.parseLiteral(e20.value, "RegExpLiteral");
      return t2.pattern = e20.pattern, t2.flags = e20.flags, t2;
    }
    parseBooleanLiteral(e20) {
      const t2 = this.startNode();
      return t2.value = e20, this.next(), this.finishNode(t2, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e20 = this.startNode();
      return this.next(), this.finishNode(e20, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc;
      let r2;
      this.next(), this.expressionScope.enter(new go$1(1));
      const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new So$1();
      let c2, p2, l2 = true;
      for (; !this.match(bn$1.parenR); ) {
        if (l2)
          l2 = false;
        else if (this.expect(bn$1.comma, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(bn$1.parenR)) {
          p2 = this.state.start;
          break;
        }
        if (this.match(bn$1.ellipsis)) {
          const e21 = this.state.start, t3 = this.state.startLoc;
          c2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), e21, t3)), this.checkCommaAfterRest(41);
          break;
        }
        u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
      }
      const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
      this.expect(bn$1.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
      let m2 = this.startNodeAt(t2, s2);
      if (e20 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
        return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
      if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), p2 && this.unexpected(p2), c2 && this.unexpected(c2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), r2.end = d2, r2.loc.end = D2) : r2 = u2[0], !this.options.createParenthesizedExpressions)
        return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2), r2;
      const f2 = this.startNodeAt(t2, s2);
      return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
    }
    shouldParseArrow(e20) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e20) {
      if (this.eat(bn$1.arrow))
        return e20;
    }
    parseParenItem(e20, t2, s2) {
      return e20;
    }
    parseNewOrNewTarget() {
      const e20 = this.startNode();
      if (this.next(), this.match(bn$1.dot)) {
        const t2 = this.createIdentifier(this.startNodeAtNode(e20), "new");
        this.next();
        const s2 = this.parseMetaProperty(e20, t2, "target");
        return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Rn$1.UnexpectedNewTarget), s2;
      }
      return this.parseNew(e20);
    }
    parseNew(e20) {
      return e20.callee = this.parseNoCallExpr(), e20.callee.type === "Import" ? this.raise(e20.callee.start, Rn$1.ImportCallNotNewExpression) : this.isOptionalChain(e20.callee) ? this.raise(this.state.lastTokEnd, Rn$1.OptionalChainingNoNew) : this.eat(bn$1.questionDot) && this.raise(this.state.start, Rn$1.OptionalChainingNoNew), this.parseNewArguments(e20), this.finishNode(e20, "NewExpression");
    }
    parseNewArguments(e20) {
      if (this.eat(bn$1.parenL)) {
        const t2 = this.parseExprList(bn$1.parenR);
        this.toReferencedList(t2), e20.arguments = t2;
      } else
        e20.arguments = [];
    }
    parseTemplateElement(e20) {
      const t2 = this.startNode();
      return this.state.value === null && (e20 || this.raise(this.state.start + 1, Rn$1.InvalidEscapeSequenceTemplate)), t2.value = {raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value}, this.next(), t2.tail = this.match(bn$1.backQuote), this.finishNode(t2, "TemplateElement");
    }
    parseTemplate(e20) {
      const t2 = this.startNode();
      this.next(), t2.expressions = [];
      let s2 = this.parseTemplateElement(e20);
      for (t2.quasis = [s2]; !s2.tail; )
        this.expect(bn$1.dollarBraceL), t2.expressions.push(this.parseTemplateSubstitution()), this.expect(bn$1.braceR), t2.quasis.push(s2 = this.parseTemplateElement(e20));
      return this.next(), this.finishNode(t2, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e20, t2, s2, r2) {
      s2 && this.expectPlugin("recordAndTuple");
      const i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const a2 = Object.create(null);
      let n2 = true;
      const o2 = this.startNode();
      for (o2.properties = [], this.next(); !this.match(e20); ) {
        if (n2)
          n2 = false;
        else if (this.expect(bn$1.comma), this.match(e20)) {
          this.addExtra(o2, "trailingComma", this.state.lastTokStart);
          break;
        }
        const i3 = this.parsePropertyDefinition(t2, r2);
        t2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Rn$1.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = i2;
      let u2 = "ObjectExpression";
      return t2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
    }
    maybeAsyncOrAccessorProp(e20) {
      return !e20.computed && e20.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(bn$1.bracketL) || this.match(bn$1.star));
    }
    parsePropertyDefinition(e20, t2) {
      let s2 = [];
      if (this.match(bn$1.at))
        for (this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedPropertyDecorator); this.match(bn$1.at); )
          s2.push(this.parseDecorator());
      const r2 = this.startNode();
      let i2, a2, n2 = false, o2 = false, u2 = false;
      if (this.match(bn$1.ellipsis))
        return s2.length && this.unexpected(), e20 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
      s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (e20 || t2) && (i2 = this.state.start, a2 = this.state.startLoc), e20 || (n2 = this.eat(bn$1.star));
      const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
      if (!e20 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
        const e21 = c2.name;
        e21 !== "async" || this.hasPrecedingLineBreak() || (o2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(bn$1.star), this.parsePropertyName(r2, false)), e21 !== "get" && e21 !== "set" || (u2 = true, this.resetPreviousNodeTrailingComments(c2), r2.kind = e21, this.match(bn$1.star) && (n2 = true, this.raise(this.state.pos, Rn$1.AccessorIsGenerator, e21), this.next()), this.parsePropertyName(r2, false));
      }
      return this.parseObjPropValue(r2, i2, a2, n2, o2, e20, u2, t2), r2;
    }
    getGetterSetterExpectedParamCount(e20) {
      return e20.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e20) {
      return e20.params;
    }
    checkGetterSetterParams(e20) {
      var t2;
      const s2 = this.getGetterSetterExpectedParamCount(e20), r2 = this.getObjectOrClassMethodParams(e20), i2 = e20.start;
      r2.length !== s2 && (e20.kind === "get" ? this.raise(i2, Rn$1.BadGetterArity) : this.raise(i2, Rn$1.BadSetterArity)), e20.kind === "set" && ((t2 = r2[r2.length - 1]) == null ? void 0 : t2.type) === "RestElement" && this.raise(i2, Rn$1.BadSetterRestParameter);
    }
    parseObjectMethod(e20, t2, s2, r2, i2) {
      return i2 ? (this.parseMethod(e20, t2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e20), e20) : s2 || t2 || this.match(bn$1.parenL) ? (r2 && this.unexpected(), e20.kind = "method", e20.method = true, this.parseMethod(e20, t2, s2, false, false, "ObjectMethod")) : void 0;
    }
    parseObjectProperty(e20, t2, s2, r2, i2) {
      return e20.shorthand = false, this.eat(bn$1.colon) ? (e20.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(e20, "ObjectProperty")) : e20.computed || e20.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e20.key.name, e20.key.start, true, false), r2 ? e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key)) : this.match(bn$1.eq) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key))) : e20.value = Io$1(e20.key), e20.shorthand = true, this.finishNode(e20, "ObjectProperty"));
    }
    parseObjPropValue(e20, t2, s2, r2, i2, a2, n2, o2) {
      const u2 = this.parseObjectMethod(e20, r2, i2, a2, n2) || this.parseObjectProperty(e20, t2, s2, a2, o2);
      return u2 || this.unexpected(), u2;
    }
    parsePropertyName(e20, t2) {
      if (this.eat(bn$1.bracketL))
        e20.computed = true, e20.key = this.parseMaybeAssignAllowIn(), this.expect(bn$1.bracketR);
      else {
        const s2 = this.state.inPropertyName;
        this.state.inPropertyName = true;
        const r2 = this.state.type;
        e20.key = r2 === bn$1.num || r2 === bn$1.string || r2 === bn$1.bigint || r2 === bn$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t2), r2 !== bn$1.privateName && (e20.computed = false), this.state.inPropertyName = s2;
      }
      return e20.key;
    }
    initFunction(e20, t2) {
      e20.id = null, e20.generator = false, e20.async = !!t2;
    }
    parseMethod(e20, t2, s2, r2, i2, a2, n2 = false) {
      this.initFunction(e20, s2), e20.generator = !!t2;
      const o2 = r2;
      return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(wo$1(s2, e20.generator)), this.parseFunctionParams(e20, o2), this.parseFunctionBodyAndFinish(e20, a2, true), this.prodParam.exit(), this.scope.exit(), e20;
    }
    parseArrayLike(e20, t2, s2, r2) {
      s2 && this.expectPlugin("recordAndTuple");
      const i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const a2 = this.startNode();
      return this.next(), a2.elements = this.parseExprList(e20, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e20, t2, s2, r2) {
      this.scope.enter(6);
      let i2 = wo$1(s2, false);
      !this.match(bn$1.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e20, s2);
      const a2 = this.state.maybeInArrowParameters;
      return t2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e20, t2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e20, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(e20, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e20, t2, s2) {
      e20.params = this.toAssignableList(t2, s2, false);
    }
    parseFunctionBodyAndFinish(e20, t2, s2 = false) {
      this.parseFunctionBody(e20, false, s2), this.finishNode(e20, t2);
    }
    parseFunctionBody(e20, t2, s2 = false) {
      const r2 = t2 && !this.match(bn$1.braceL);
      if (this.expressionScope.enter(Po$1()), r2)
        e20.body = this.parseMaybeAssign(), this.checkParams(e20, false, t2, false);
      else {
        const r3 = this.state.strict, i2 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e20.body = this.parseBlock(true, false, (i3) => {
          const a2 = !this.isSimpleParamList(e20.params);
          if (i3 && a2) {
            const t3 = e20.kind !== "method" && e20.kind !== "constructor" || !e20.key ? e20.start : e20.key.end;
            this.raise(t3, Rn$1.IllegalLanguageModeDirective);
          }
          const n2 = !r3 && this.state.strict;
          this.checkParams(e20, !(this.state.strict || t2 || s2 || a2), t2, n2), this.state.strict && e20.id && this.checkLVal(e20.id, "function name", 65, void 0, void 0, n2);
        }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
      }
    }
    isSimpleParamList(e20) {
      for (let t2 = 0, s2 = e20.length; t2 < s2; t2++)
        if (e20[t2].type !== "Identifier")
          return false;
      return true;
    }
    checkParams(e20, t2, s2, r2 = true) {
      const i2 = new Set();
      for (const s3 of e20.params)
        this.checkLVal(s3, "function parameter list", 5, t2 ? null : i2, void 0, r2);
    }
    parseExprList(e20, t2, s2, r2) {
      const i2 = [];
      let a2 = true;
      for (; !this.eat(e20); ) {
        if (a2)
          a2 = false;
        else if (this.expect(bn$1.comma), this.match(e20)) {
          r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
          break;
        }
        i2.push(this.parseExprListItem(t2, s2));
      }
      return i2;
    }
    parseExprListItem(e20, t2, s2) {
      let r2;
      if (this.match(bn$1.comma))
        e20 || this.raise(this.state.pos, Rn$1.UnexpectedToken, ","), r2 = null;
      else if (this.match(bn$1.ellipsis)) {
        const e21 = this.state.start, s3 = this.state.startLoc;
        r2 = this.parseParenItem(this.parseSpread(t2), e21, s3);
      } else if (this.match(bn$1.question)) {
        this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Rn$1.UnexpectedArgumentPlaceholder);
        const e21 = this.startNode();
        this.next(), r2 = this.finishNode(e21, "ArgumentPlaceholder");
      } else
        r2 = this.parseMaybeAssignAllowIn(t2, this.parseParenItem);
      return r2;
    }
    parseIdentifier(e20) {
      const t2 = this.startNode(), s2 = this.parseIdentifierName(t2.start, e20);
      return this.createIdentifier(t2, s2);
    }
    createIdentifier(e20, t2) {
      return e20.name = t2, e20.loc.identifierName = t2, this.finishNode(e20, "Identifier");
    }
    parseIdentifierName(e20, t2) {
      let s2;
      const {start: r2, type: i2} = this.state;
      if (i2 === bn$1.name)
        s2 = this.state.value;
      else {
        if (!i2.keyword)
          throw this.unexpected();
        s2 = i2.keyword;
      }
      return t2 ? this.state.type = bn$1.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
    }
    checkReservedWord(e20, t2, s2, r2) {
      if (e20.length > 10)
        return;
      if (!function(e21) {
        return uo$1.has(e21);
      }(e20))
        return;
      if (e20 === "yield") {
        if (this.prodParam.hasYield)
          return void this.raise(t2, Rn$1.YieldBindingIdentifier);
      } else if (e20 === "await") {
        if (this.prodParam.hasAwait)
          return void this.raise(t2, Rn$1.AwaitBindingIdentifier);
        if (this.scope.inStaticBlock)
          return void this.raise(t2, Rn$1.AwaitBindingIdentifierInStaticBlock);
        this.expressionScope.recordAsyncArrowParametersError(t2, Rn$1.AwaitBindingIdentifier);
      } else if (e20 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
        return void this.raise(t2, Rn$1.ArgumentsInClass);
      if (s2 && oo$1(e20))
        return void this.raise(t2, Rn$1.UnexpectedKeyword, e20);
      (this.state.strict ? r2 ? no$1 : io$1 : ro$1)(e20, this.inModule) && this.raise(t2, Rn$1.UnexpectedReservedWord, e20);
    }
    isAwaitAllowed() {
      return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
    }
    parseAwait(e20, t2) {
      const s2 = this.startNodeAt(e20, t2);
      return this.expressionScope.recordParameterInitializerError(s2.start, Rn$1.AwaitExpressionFormalParameter), this.eat(bn$1.star) && this.raise(s2.start, Rn$1.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
    }
    isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(bn$1.plusMin) || this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.backQuote) || this.match(bn$1.regexp) || this.match(bn$1.slash) || this.hasPlugin("v8intrinsic") && this.match(bn$1.modulo);
    }
    parseYield() {
      const e20 = this.startNode();
      this.expressionScope.recordParameterInitializerError(e20.start, Rn$1.YieldInParameter), this.next();
      let t2 = false, s2 = null;
      if (!this.hasPrecedingLineBreak())
        switch (t2 = this.eat(bn$1.star), this.state.type) {
          case bn$1.semi:
          case bn$1.eof:
          case bn$1.braceR:
          case bn$1.parenR:
          case bn$1.bracketR:
          case bn$1.braceBarR:
          case bn$1.colon:
          case bn$1.comma:
            if (!t2)
              break;
          default:
            s2 = this.parseMaybeAssign();
        }
      return e20.delegate = t2, e20.argument = s2, this.finishNode(e20, "YieldExpression");
    }
    checkPipelineAtInfixOperator(e20, t2) {
      this.getPluginOption("pipelineOperator", "proposal") === "smart" && e20.type === "SequenceExpression" && this.raise(t2, Rn$1.PipelineHeadSequenceExpression);
    }
    checkHackPipeBodyEarlyErrors(e20) {
      if (this.match(bn$1.arrow))
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, bn$1.arrow.label);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipeTopicUnused);
    }
    parseSmartPipelineBodyInStyle(e20, t2, s2) {
      const r2 = this.startNodeAt(t2, s2);
      return this.isSimpleReference(e20) ? (r2.callee = e20, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(t2), r2.expression = e20, this.finishNode(r2, "PipelineTopicExpression"));
    }
    isSimpleReference(e20) {
      switch (e20.type) {
        case "MemberExpression":
          return !e20.computed && this.isSimpleReference(e20.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e20) {
      if (this.match(bn$1.arrow))
        throw this.raise(this.state.start, Rn$1.PipelineBodyNoArrow);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipelineTopicUnused);
    }
    withTopicBindingContext(e20) {
      const t2 = this.state.topicContext;
      this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
      try {
        return e20();
      } finally {
        this.state.topicContext = t2;
      }
    }
    withSmartMixTopicForbiddingContext(e20) {
      if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
        return e20();
      {
        const t2 = this.state.topicContext;
        this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
        try {
          return e20();
        } finally {
          this.state.topicContext = t2;
        }
      }
    }
    withSoloAwaitPermittingContext(e20) {
      const t2 = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e20();
      } finally {
        this.state.soloAwait = t2;
      }
    }
    allowInAnd(e20) {
      const t2 = this.prodParam.currentFlags();
      if (8 & ~t2) {
        this.prodParam.enter(8 | t2);
        try {
          return e20();
        } finally {
          this.prodParam.exit();
        }
      }
      return e20();
    }
    disallowInAnd(e20) {
      const t2 = this.prodParam.currentFlags();
      if (8 & t2) {
        this.prodParam.enter(-9 & t2);
        try {
          return e20();
        } finally {
          this.prodParam.exit();
        }
      }
      return e20();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e20) {
      const t2 = this.state.start, s2 = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const r2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t2, s2, e20);
      return this.state.inFSharpPipelineDirectBody = r2, i2;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e20 = this.startNode();
      this.next(), this.eat(bn$1.braceL);
      const t2 = this.initializeScopes(true);
      this.enterInitialScopes();
      const s2 = this.startNode();
      try {
        e20.body = this.parseProgram(s2, bn$1.braceR, "module");
      } finally {
        t2();
      }
      return this.eat(bn$1.braceR), this.finishNode(e20, "ModuleExpression");
    }
  } {
    parseTopLevel(e20, t2) {
      return e20.program = this.parseProgram(t2), e20.comments = this.state.comments, this.options.tokens && (e20.tokens = function(e21) {
        for (let t3 = 0; t3 < e21.length; t3++) {
          const s2 = e21[t3];
          if (s2.type === bn$1.privateName) {
            const {loc: r2, start: i2, value: a2, end: n2} = s2, o2 = i2 + 1, u2 = new In$1(r2.start.line, r2.start.column + 1);
            e21.splice(t3, 1, new Eo$1({type: bn$1.hash, value: "#", start: i2, end: o2, startLoc: r2.start, endLoc: u2}), new Eo$1({type: bn$1.name, value: a2, start: o2, end: n2, startLoc: u2, endLoc: r2.end}));
          }
        }
        return e21;
      }(this.tokens)), this.finishNode(e20, "File");
    }
    parseProgram(e20, t2 = bn$1.eof, s2 = this.options.sourceType) {
      if (e20.sourceType = s2, e20.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e20, true, true, t2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [e21] of Array.from(this.scope.undefinedExports)) {
          const t3 = this.scope.undefinedExports.get(e21);
          this.raise(t3, Rn$1.ModuleExportUndefined, e21);
        }
      return this.finishNode(e20, "Program");
    }
    stmtToDirective(e20) {
      const t2 = e20;
      t2.type = "Directive", t2.value = t2.expression, delete t2.expression;
      const s2 = t2.value, r2 = this.input.slice(s2.start, s2.end), i2 = s2.value = r2.slice(1, -1);
      return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", i2), s2.type = "DirectiveLiteral", t2;
    }
    parseInterpreterDirective() {
      if (!this.match(bn$1.interpreterDirective))
        return null;
      const e20 = this.startNode();
      return e20.value = this.state.value, this.next(), this.finishNode(e20, "InterpreterDirective");
    }
    isLet(e20) {
      return !!this.isContextual("let") && this.isLetKeyword(e20);
    }
    isLetKeyword(e20) {
      const t2 = this.nextTokenStart(), s2 = this.codePointAtPos(t2);
      if (s2 === 92 || s2 === 91)
        return true;
      if (e20)
        return false;
      if (s2 === 123)
        return true;
      if (Jn$1(s2)) {
        if (cu.lastIndex = t2, cu.test(this.input)) {
          const e21 = this.codePointAtPos(cu.lastIndex);
          if (!Yn$1(e21) && e21 !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(e20, t2) {
      return this.match(bn$1.at) && this.parseDecorators(true), this.parseStatementContent(e20, t2);
    }
    parseStatementContent(e20, t2) {
      let s2 = this.state.type;
      const r2 = this.startNode();
      let i2;
      switch (this.isLet(e20) && (s2 = bn$1._var, i2 = "let"), s2) {
        case bn$1._break:
        case bn$1._continue:
          return this.parseBreakContinueStatement(r2, s2.keyword);
        case bn$1._debugger:
          return this.parseDebuggerStatement(r2);
        case bn$1._do:
          return this.parseDoStatement(r2);
        case bn$1._for:
          return this.parseForStatement(r2);
        case bn$1._function:
          if (this.lookaheadCharCode() === 46)
            break;
          return e20 && (this.state.strict ? this.raise(this.state.start, Rn$1.StrictFunction) : e20 !== "if" && e20 !== "label" && this.raise(this.state.start, Rn$1.SloppyFunction)), this.parseFunctionStatement(r2, false, !e20);
        case bn$1._class:
          return e20 && this.unexpected(), this.parseClass(r2, true);
        case bn$1._if:
          return this.parseIfStatement(r2);
        case bn$1._return:
          return this.parseReturnStatement(r2);
        case bn$1._switch:
          return this.parseSwitchStatement(r2);
        case bn$1._throw:
          return this.parseThrowStatement(r2);
        case bn$1._try:
          return this.parseTryStatement(r2);
        case bn$1._const:
        case bn$1._var:
          return i2 = i2 || this.state.value, e20 && i2 !== "var" && this.raise(this.state.start, Rn$1.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
        case bn$1._while:
          return this.parseWhileStatement(r2);
        case bn$1._with:
          return this.parseWithStatement(r2);
        case bn$1.braceL:
          return this.parseBlock();
        case bn$1.semi:
          return this.parseEmptyStatement(r2);
        case bn$1._import: {
          const e21 = this.lookaheadCharCode();
          if (e21 === 40 || e21 === 46)
            break;
        }
        case bn$1._export: {
          let e21;
          return this.options.allowImportExportEverywhere || t2 || this.raise(this.state.start, Rn$1.UnexpectedImportExport), this.next(), s2 === bn$1._import ? (e21 = this.parseImport(r2), e21.type !== "ImportDeclaration" || e21.importKind && e21.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e21 = this.parseExport(r2), (e21.type !== "ExportNamedDeclaration" || e21.exportKind && e21.exportKind !== "value") && (e21.type !== "ExportAllDeclaration" || e21.exportKind && e21.exportKind !== "value") && e21.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), e21;
        }
        default:
          if (this.isAsyncFunction())
            return e20 && this.raise(this.state.start, Rn$1.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !e20);
      }
      const a2 = this.state.value, n2 = this.parseExpression();
      return s2 === bn$1.name && n2.type === "Identifier" && this.eat(bn$1.colon) ? this.parseLabeledStatement(r2, a2, n2, e20) : this.parseExpressionStatement(r2, n2);
    }
    assertModuleNodeAllowed(e20) {
      this.options.allowImportExportEverywhere || this.inModule || this.raise(e20.start, jn$1.ImportOutsideModule);
    }
    takeDecorators(e20) {
      const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      t2.length && (e20.decorators = t2, this.resetStartLocationFromNode(e20, t2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(bn$1._class);
    }
    parseDecorators(e20) {
      const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(bn$1.at); ) {
        const e21 = this.parseDecorator();
        t2.push(e21);
      }
      if (this.match(bn$1._export))
        e20 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorExportClass);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(this.state.start, Rn$1.UnexpectedLeadingDecorator);
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      const e20 = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const t2 = this.state.start, s2 = this.state.startLoc;
        let r2;
        if (this.eat(bn$1.parenL))
          r2 = this.parseExpression(), this.expect(bn$1.parenR);
        else
          for (r2 = this.parseIdentifier(false); this.eat(bn$1.dot); ) {
            const e21 = this.startNodeAt(t2, s2);
            e21.object = r2, e21.property = this.parseIdentifier(true), e21.computed = false, r2 = this.finishNode(e21, "MemberExpression");
          }
        e20.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
      } else
        e20.expression = this.parseExprSubscripts();
      return this.finishNode(e20, "Decorator");
    }
    parseMaybeDecoratorArguments(e20) {
      if (this.eat(bn$1.parenL)) {
        const t2 = this.startNodeAtNode(e20);
        return t2.callee = e20, t2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.toReferencedList(t2.arguments), this.finishNode(t2, "CallExpression");
      }
      return e20;
    }
    parseBreakContinueStatement(e20, t2) {
      const s2 = t2 === "break";
      return this.next(), this.isLineTerminator() ? e20.label = null : (e20.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e20, t2), this.finishNode(e20, s2 ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e20, t2) {
      const s2 = t2 === "break";
      let r2;
      for (r2 = 0; r2 < this.state.labels.length; ++r2) {
        const t3 = this.state.labels[r2];
        if (e20.label == null || t3.name === e20.label.name) {
          if (t3.kind != null && (s2 || t3.kind === "loop"))
            break;
          if (e20.label && s2)
            break;
        }
      }
      r2 === this.state.labels.length && this.raise(e20.start, Rn$1.IllegalBreakContinue, t2);
    }
    parseDebuggerStatement(e20) {
      return this.next(), this.semicolon(), this.finishNode(e20, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(bn$1.parenL);
      const e20 = this.parseExpression();
      return this.expect(bn$1.parenR), e20;
    }
    parseDoStatement(e20) {
      return this.next(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(bn$1._while), e20.test = this.parseHeaderExpression(), this.eat(bn$1.semi), this.finishNode(e20, "DoWhileStatement");
    }
    parseForStatement(e20) {
      this.next(), this.state.labels.push(ou);
      let t2 = -1;
      if (this.isAwaitAllowed() && this.eatContextual("await") && (t2 = this.state.lastTokStart), this.scope.enter(0), this.expect(bn$1.parenL), this.match(bn$1.semi))
        return t2 > -1 && this.unexpected(t2), this.parseFor(e20, null);
      const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
      if (this.match(bn$1._var) || this.match(bn$1._const) || r2) {
        const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
        return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(bn$1._in) || this.isContextual("of")) && s3.declarations.length === 1 ? this.parseForIn(e20, s3, t2) : (t2 > -1 && this.unexpected(t2), this.parseFor(e20, s3));
      }
      const i2 = this.match(bn$1.name) && !this.state.containsEsc, a2 = new So$1(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
      if (o2 && (s2 ? this.raise(n2.start, Rn$1.ForOfLet) : t2 === -1 && i2 && n2.type === "Identifier" && n2.name === "async" && this.raise(n2.start, Rn$1.ForOfAsync)), o2 || this.match(bn$1._in)) {
        this.toAssignable(n2, true);
        const s3 = o2 ? "for-of statement" : "for-in statement";
        return this.checkLVal(n2, s3), this.parseForIn(e20, n2, t2);
      }
      return this.checkExpressionErrors(a2, true), t2 > -1 && this.unexpected(t2), this.parseFor(e20, n2);
    }
    parseFunctionStatement(e20, t2, s2) {
      return this.next(), this.parseFunction(e20, 1 | (s2 ? 0 : 2), t2);
    }
    parseIfStatement(e20) {
      return this.next(), e20.test = this.parseHeaderExpression(), e20.consequent = this.parseStatement("if"), e20.alternate = this.eat(bn$1._else) ? this.parseStatement("if") : null, this.finishNode(e20, "IfStatement");
    }
    parseReturnStatement(e20) {
      return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Rn$1.IllegalReturn), this.next(), this.isLineTerminator() ? e20.argument = null : (e20.argument = this.parseExpression(), this.semicolon()), this.finishNode(e20, "ReturnStatement");
    }
    parseSwitchStatement(e20) {
      this.next(), e20.discriminant = this.parseHeaderExpression();
      const t2 = e20.cases = [];
      let s2, r2;
      for (this.expect(bn$1.braceL), this.state.labels.push(uu), this.scope.enter(0); !this.match(bn$1.braceR); )
        if (this.match(bn$1._case) || this.match(bn$1._default)) {
          const e21 = this.match(bn$1._case);
          s2 && this.finishNode(s2, "SwitchCase"), t2.push(s2 = this.startNode()), s2.consequent = [], this.next(), e21 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Rn$1.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(bn$1.colon);
        } else
          s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e20, "SwitchStatement");
    }
    parseThrowStatement(e20) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Rn$1.NewlineAfterThrow), e20.argument = this.parseExpression(), this.semicolon(), this.finishNode(e20, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e20 = this.parseBindingAtom(), t2 = e20.type === "Identifier";
      return this.scope.enter(t2 ? 8 : 0), this.checkLVal(e20, "catch clause", 9), e20;
    }
    parseTryStatement(e20) {
      if (this.next(), e20.block = this.parseBlock(), e20.handler = null, this.match(bn$1._catch)) {
        const t2 = this.startNode();
        this.next(), this.match(bn$1.parenL) ? (this.expect(bn$1.parenL), t2.param = this.parseCatchClauseParam(), this.expect(bn$1.parenR)) : (t2.param = null, this.scope.enter(0)), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e20.handler = this.finishNode(t2, "CatchClause");
      }
      return e20.finalizer = this.eat(bn$1._finally) ? this.parseBlock() : null, e20.handler || e20.finalizer || this.raise(e20.start, Rn$1.NoCatchOrFinally), this.finishNode(e20, "TryStatement");
    }
    parseVarStatement(e20, t2) {
      return this.next(), this.parseVar(e20, false, t2), this.semicolon(), this.finishNode(e20, "VariableDeclaration");
    }
    parseWhileStatement(e20) {
      return this.next(), e20.test = this.parseHeaderExpression(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e20, "WhileStatement");
    }
    parseWithStatement(e20) {
      return this.state.strict && this.raise(this.state.start, Rn$1.StrictWith), this.next(), e20.object = this.parseHeaderExpression(), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e20, "WithStatement");
    }
    parseEmptyStatement(e20) {
      return this.next(), this.finishNode(e20, "EmptyStatement");
    }
    parseLabeledStatement(e20, t2, s2, r2) {
      for (const e21 of this.state.labels)
        e21.name === t2 && this.raise(s2.start, Rn$1.LabelRedeclaration, t2);
      const i2 = this.state.type.isLoop ? "loop" : this.match(bn$1._switch) ? "switch" : null;
      for (let t3 = this.state.labels.length - 1; t3 >= 0; t3--) {
        const s3 = this.state.labels[t3];
        if (s3.statementStart !== e20.start)
          break;
        s3.statementStart = this.state.start, s3.kind = i2;
      }
      return this.state.labels.push({name: t2, kind: i2, statementStart: this.state.start}), e20.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), e20.label = s2, this.finishNode(e20, "LabeledStatement");
    }
    parseExpressionStatement(e20, t2) {
      return e20.expression = t2, this.semicolon(), this.finishNode(e20, "ExpressionStatement");
    }
    parseBlock(e20 = false, t2 = true, s2) {
      const r2 = this.startNode();
      return e20 && this.state.strictErrors.clear(), this.expect(bn$1.braceL), t2 && this.scope.enter(0), this.parseBlockBody(r2, e20, false, bn$1.braceR, s2), t2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
    }
    isValidDirective(e20) {
      return e20.type === "ExpressionStatement" && e20.expression.type === "StringLiteral" && !e20.expression.extra.parenthesized;
    }
    parseBlockBody(e20, t2, s2, r2, i2) {
      const a2 = e20.body = [], n2 = e20.directives = [];
      this.parseBlockOrModuleBlockBody(a2, t2 ? n2 : void 0, s2, r2, i2);
    }
    parseBlockOrModuleBlockBody(e20, t2, s2, r2, i2) {
      const a2 = this.state.strict;
      let n2 = false, o2 = false;
      for (; !this.match(r2); ) {
        const r3 = this.parseStatement(null, s2);
        if (t2 && !o2) {
          if (this.isValidDirective(r3)) {
            const e21 = this.stmtToDirective(r3);
            t2.push(e21), n2 || e21.value.value !== "use strict" || (n2 = true, this.setStrict(true));
            continue;
          }
          o2 = true, this.state.strictErrors.clear();
        }
        e20.push(r3);
      }
      i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
    }
    parseFor(e20, t2) {
      return e20.init = t2, this.semicolon(false), e20.test = this.match(bn$1.semi) ? null : this.parseExpression(), this.semicolon(false), e20.update = this.match(bn$1.parenR) ? null : this.parseExpression(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, "ForStatement");
    }
    parseForIn(e20, t2, s2) {
      const r2 = this.match(bn$1._in);
      return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : e20.await = s2 > -1, t2.type !== "VariableDeclaration" || t2.declarations[0].init == null || r2 && !this.state.strict && t2.kind === "var" && t2.declarations[0].id.type === "Identifier" ? t2.type === "AssignmentPattern" && this.raise(t2.start, Rn$1.InvalidLhs, "for-loop") : this.raise(t2.start, Rn$1.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), e20.left = t2, e20.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, r2 ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e20, t2, s2) {
      const r2 = e20.declarations = [], i2 = this.hasPlugin("typescript");
      for (e20.kind = s2; ; ) {
        const e21 = this.startNode();
        if (this.parseVarId(e21, s2), this.eat(bn$1.eq) ? e21.init = t2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(bn$1._in) || this.isContextual("of") ? e21.id.type === "Identifier" || t2 && (this.match(bn$1._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Const declarations"), e21.init = null), r2.push(this.finishNode(e21, "VariableDeclarator")), !this.eat(bn$1.comma))
          break;
      }
      return e20;
    }
    parseVarId(e20, t2) {
      e20.id = this.parseBindingAtom(), this.checkLVal(e20.id, "variable declaration", t2 === "var" ? 5 : 9, void 0, t2 !== "var");
    }
    parseFunction(e20, t2 = 0, s2 = false) {
      const r2 = 1 & t2, i2 = 2 & t2, a2 = !(!r2 || 4 & t2);
      this.initFunction(e20, s2), this.match(bn$1.star) && i2 && this.raise(this.state.start, Rn$1.GeneratorInSingleStatementContext), e20.generator = this.eat(bn$1.star), r2 && (e20.id = this.parseFunctionId(a2));
      const n2 = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(wo$1(s2, e20.generator)), r2 || (e20.id = this.parseFunctionId()), this.parseFunctionParams(e20, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e20, r2 ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(e20), this.state.maybeInArrowParameters = n2, e20;
    }
    parseFunctionId(e20) {
      return e20 || this.match(bn$1.name) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e20, t2) {
      this.expect(bn$1.parenL), this.expressionScope.enter(new Fo$1(3)), e20.params = this.parseBindingList(bn$1.parenR, 41, false, t2), this.expressionScope.exit();
    }
    registerFunctionStatementId(e20) {
      e20.id && this.scope.declareName(e20.id.name, this.state.strict || e20.generator || e20.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e20.id.start);
    }
    parseClass(e20, t2, s2) {
      this.next(), this.takeDecorators(e20);
      const r2 = this.state.strict;
      return this.state.strict = true, this.parseClassId(e20, t2, s2), this.parseClassSuper(e20), e20.body = this.parseClassBody(!!e20.superClass, r2), this.finishNode(e20, t2 ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(bn$1.eq) || this.match(bn$1.semi) || this.match(bn$1.braceR);
    }
    isClassMethod() {
      return this.match(bn$1.parenL);
    }
    isNonstaticConstructor(e20) {
      return !(e20.computed || e20.static || e20.key.name !== "constructor" && e20.key.value !== "constructor");
    }
    parseClassBody(e20, t2) {
      this.classScope.enter();
      const s2 = {hadConstructor: false, hadSuperClass: e20};
      let r2 = [];
      const i2 = this.startNode();
      if (i2.body = [], this.expect(bn$1.braceL), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(bn$1.braceR); ) {
          if (this.eat(bn$1.semi)) {
            if (r2.length > 0)
              throw this.raise(this.state.lastTokEnd, Rn$1.DecoratorSemicolon);
            continue;
          }
          if (this.match(bn$1.at)) {
            r2.push(this.parseDecorator());
            continue;
          }
          const e21 = this.startNode();
          r2.length && (e21.decorators = r2, this.resetStartLocationFromNode(e21, r2[0]), r2 = []), this.parseClassMember(i2, e21, s2), e21.kind === "constructor" && e21.decorators && e21.decorators.length > 0 && this.raise(e21.start, Rn$1.DecoratorConstructor);
        }
      }), this.state.strict = t2, this.next(), r2.length)
        throw this.raise(this.state.start, Rn$1.TrailingDecorator);
      return this.classScope.exit(), this.finishNode(i2, "ClassBody");
    }
    parseClassMemberFromModifier(e20, t2) {
      const s2 = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const r2 = t2;
        return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(e20, r2, false, false, false, false), true;
      }
      if (this.isClassProperty()) {
        const r2 = t2;
        return r2.computed = false, r2.key = s2, r2.static = false, e20.body.push(this.parseClassProperty(r2)), true;
      }
      return this.resetPreviousNodeTrailingComments(s2), false;
    }
    parseClassMember(e20, t2, s2) {
      const r2 = this.isContextual("static");
      if (r2) {
        if (this.parseClassMemberFromModifier(e20, t2))
          return;
        if (this.eat(bn$1.braceL))
          return void this.parseClassStaticBlock(e20, t2);
      }
      this.parseClassMemberWithIsStatic(e20, t2, s2, r2);
    }
    parseClassMemberWithIsStatic(e20, t2, s2, r2) {
      const i2 = t2, a2 = t2, n2 = t2, o2 = t2, u2 = i2, h2 = i2;
      if (t2.static = r2, this.eat(bn$1.star)) {
        u2.kind = "method";
        const t3 = this.match(bn$1.privateName);
        return this.parseClassElementName(u2), t3 ? void this.pushClassPrivateMethod(e20, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsGenerator), void this.pushClassMethod(e20, i2, true, false, false, false));
      }
      const c2 = this.match(bn$1.name) && !this.state.containsEsc, p2 = this.match(bn$1.privateName), l2 = this.parseClassElementName(t2), d2 = this.state.start;
      if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
        if (u2.kind = "method", p2)
          return void this.pushClassPrivateMethod(e20, a2, false, false);
        const r3 = this.isNonstaticConstructor(i2);
        let n3 = false;
        r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Rn$1.DuplicateConstructor), r3 && this.hasPlugin("typescript") && t2.override && this.raise(l2.start, Rn$1.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(e20, i2, false, false, r3, n3);
      } else if (this.isClassProperty())
        p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2);
      else if (c2 && l2.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(l2);
        const t3 = this.eat(bn$1.star);
        h2.optional && this.unexpected(d2), u2.kind = "method";
        const s3 = this.match(bn$1.privateName);
        this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(e20, a2, t3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAsync), this.pushClassMethod(e20, i2, t3, true, false, false));
      } else if (!c2 || l2.name !== "get" && l2.name !== "set" || this.match(bn$1.star) && this.isLineTerminator())
        this.isLineTerminator() ? p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2) : this.unexpected();
      else {
        this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
        const t3 = this.match(bn$1.privateName);
        this.parseClassElementName(i2), t3 ? this.pushClassPrivateMethod(e20, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAccessor), this.pushClassMethod(e20, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
      }
    }
    parseClassElementName(e20) {
      const {type: t2, value: s2, start: r2} = this.state;
      return t2 !== bn$1.name && t2 !== bn$1.string || !e20.static || s2 !== "prototype" || this.raise(r2, Rn$1.StaticPrototype), t2 === bn$1.privateName && s2 === "constructor" && this.raise(r2, Rn$1.ConstructorClassPrivateField), this.parsePropertyName(e20, true);
    }
    parseClassStaticBlock(e20, t2) {
      var s2;
      this.expectPlugin("classStaticBlock", t2.start), this.scope.enter(208);
      const r2 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const i2 = t2.body = [];
      this.parseBlockOrModuleBlockBody(i2, void 0, false, bn$1.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, e20.body.push(this.finishNode(t2, "StaticBlock")), (s2 = t2.decorators) != null && s2.length && this.raise(t2.start, Rn$1.DecoratorStaticBlock);
    }
    pushClassProperty(e20, t2) {
      t2.computed || t2.key.name !== "constructor" && t2.key.value !== "constructor" || this.raise(t2.key.start, Rn$1.ConstructorClassField), e20.body.push(this.parseClassProperty(t2));
    }
    pushClassPrivateProperty(e20, t2) {
      const s2 = this.parseClassPrivateProperty(t2);
      e20.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
    }
    pushClassMethod(e20, t2, s2, r2, i2, a2) {
      e20.body.push(this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true));
    }
    pushClassPrivateMethod(e20, t2, s2, r2) {
      const i2 = this.parseMethod(t2, s2, r2, false, false, "ClassPrivateMethod", true);
      e20.body.push(i2);
      const a2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
      this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
    }
    parsePostMemberNameModifiers(e20) {
    }
    parseClassPrivateProperty(e20) {
      return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassPrivateProperty");
    }
    parseClassProperty(e20) {
      return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassProperty");
    }
    parseInitializer(e20) {
      this.scope.enter(80), this.expressionScope.enter(Po$1()), this.prodParam.enter(0), e20.value = this.eat(bn$1.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e20, t2, s2, r2 = 139) {
      this.match(bn$1.name) ? (e20.id = this.parseIdentifier(), t2 && this.checkLVal(e20.id, "class name", r2)) : s2 || !t2 ? e20.id = null : this.unexpected(null, Rn$1.MissingClassName);
    }
    parseClassSuper(e20) {
      e20.superClass = this.eat(bn$1._extends) ? this.parseExprSubscripts() : null;
    }
    parseExport(e20) {
      const t2 = this.maybeParseExportDefaultSpecifier(e20), s2 = !t2 || this.eat(bn$1.comma), r2 = s2 && this.eatExportStar(e20), i2 = r2 && this.maybeParseExportNamespaceSpecifier(e20), a2 = s2 && (!i2 || this.eat(bn$1.comma)), n2 = t2 || r2;
      if (r2 && !i2)
        return t2 && this.unexpected(), this.parseExportFrom(e20, true), this.finishNode(e20, "ExportAllDeclaration");
      const o2 = this.maybeParseExportNamedSpecifiers(e20);
      if (t2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
        throw this.unexpected(null, bn$1.braceL);
      let u2;
      if (n2 || o2 ? (u2 = false, this.parseExportFrom(e20, n2)) : u2 = this.maybeParseExportDeclaration(e20), n2 || o2 || u2)
        return this.checkExport(e20, true, false, !!e20.source), this.finishNode(e20, "ExportNamedDeclaration");
      if (this.eat(bn$1._default))
        return e20.declaration = this.parseExportDefaultExpression(), this.checkExport(e20, true, true), this.finishNode(e20, "ExportDefaultDeclaration");
      throw this.unexpected(null, bn$1.braceL);
    }
    eatExportStar(e20) {
      return this.eat(bn$1.star);
    }
    maybeParseExportDefaultSpecifier(e20) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const t2 = this.startNode();
        return t2.exported = this.parseIdentifier(true), e20.specifiers = [this.finishNode(t2, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e20) {
      if (this.isContextual("as")) {
        e20.specifiers || (e20.specifiers = []);
        const t2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), t2.exported = this.parseModuleExportName(), e20.specifiers.push(this.finishNode(t2, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e20) {
      return !!this.match(bn$1.braceL) && (e20.specifiers || (e20.specifiers = []), e20.specifiers.push(...this.parseExportSpecifiers()), e20.source = null, e20.declaration = null, true);
    }
    maybeParseExportDeclaration(e20) {
      return !!this.shouldParseExportDeclaration() && (e20.specifiers = [], e20.source = null, e20.declaration = this.parseExportDeclaration(e20), true);
    }
    isAsyncFunction() {
      if (!this.isContextual("async"))
        return false;
      const e20 = this.nextTokenStart();
      return !Pn$1.test(this.input.slice(this.state.pos, e20)) && this.isUnparsedContextual(e20, "function");
    }
    parseExportDefaultExpression() {
      const e20 = this.startNode(), t2 = this.isAsyncFunction();
      if (this.match(bn$1._function) || t2)
        return this.next(), t2 && this.next(), this.parseFunction(e20, 5, t2);
      if (this.match(bn$1._class))
        return this.parseClass(e20, true, true);
      if (this.match(bn$1.at))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e20, true, true);
      if (this.match(bn$1._const) || this.match(bn$1._var) || this.isLet())
        throw this.raise(this.state.start, Rn$1.UnsupportedDefaultExport);
      {
        const e21 = this.parseMaybeAssignAllowIn();
        return this.semicolon(), e21;
      }
    }
    parseExportDeclaration(e20) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      if (this.match(bn$1.name)) {
        const e21 = this.state.value;
        if (e21 === "async" && !this.state.containsEsc || e21 === "let")
          return false;
        if ((e21 === "type" || e21 === "interface") && !this.state.containsEsc) {
          const e22 = this.lookahead();
          if (e22.type === bn$1.name && e22.value !== "from" || e22.type === bn$1.braceL)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(bn$1._default))
        return false;
      const e20 = this.nextTokenStart(), t2 = this.isUnparsedContextual(e20, "from");
      if (this.input.charCodeAt(e20) === 44 || this.match(bn$1.name) && t2)
        return true;
      if (this.match(bn$1._default) && t2) {
        const t3 = this.input.charCodeAt(this.nextTokenStartSince(e20 + 4));
        return t3 === 34 || t3 === 39;
      }
      return false;
    }
    parseExportFrom(e20, t2) {
      if (this.eatContextual("from")) {
        e20.source = this.parseImportSource(), this.checkExport(e20);
        const t3 = this.maybeParseImportAssertions();
        t3 && (e20.assertions = t3);
      } else
        t2 ? this.unexpected() : e20.source = null;
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      if (this.match(bn$1.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
          return true;
        this.unexpected(this.state.start, Rn$1.DecoratorBeforeExport);
      }
      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e20, t2, s2, r2) {
      if (t2) {
        if (s2) {
          if (this.checkDuplicateExports(e20, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i2;
            const t3 = e20.declaration;
            t3.type !== "Identifier" || t3.name !== "from" || t3.end - t3.start != 4 || (i2 = t3.extra) != null && i2.parenthesized || this.raise(t3.start, Rn$1.ExportDefaultFromAsIdentifier);
          }
        } else if (e20.specifiers && e20.specifiers.length)
          for (const t3 of e20.specifiers) {
            const {exported: e21} = t3, s3 = e21.type === "Identifier" ? e21.name : e21.value;
            if (this.checkDuplicateExports(t3, s3), !r2 && t3.local) {
              const {local: e22} = t3;
              e22.type !== "Identifier" ? this.raise(t3.start, Rn$1.ExportBindingIsString, e22.value, s3) : (this.checkReservedWord(e22.name, e22.start, true, false), this.scope.checkLocalExport(e22));
            }
          }
        else if (e20.declaration) {
          if (e20.declaration.type === "FunctionDeclaration" || e20.declaration.type === "ClassDeclaration") {
            const t3 = e20.declaration.id;
            if (!t3)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(e20, t3.name);
          } else if (e20.declaration.type === "VariableDeclaration")
            for (const t3 of e20.declaration.declarations)
              this.checkDeclaration(t3.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(e20.start, Rn$1.UnsupportedDecoratorExport);
    }
    checkDeclaration(e20) {
      if (e20.type === "Identifier")
        this.checkDuplicateExports(e20, e20.name);
      else if (e20.type === "ObjectPattern")
        for (const t2 of e20.properties)
          this.checkDeclaration(t2);
      else if (e20.type === "ArrayPattern")
        for (const t2 of e20.elements)
          t2 && this.checkDeclaration(t2);
      else
        e20.type === "ObjectProperty" ? this.checkDeclaration(e20.value) : e20.type === "RestElement" ? this.checkDeclaration(e20.argument) : e20.type === "AssignmentPattern" && this.checkDeclaration(e20.left);
    }
    checkDuplicateExports(e20, t2) {
      this.exportedIdentifiers.has(t2) && this.raise(e20.start, t2 === "default" ? Rn$1.DuplicateDefaultExport : Rn$1.DuplicateExport, t2), this.exportedIdentifiers.add(t2);
    }
    parseExportSpecifiers() {
      const e20 = [];
      let t2 = true;
      for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
        if (t2)
          t2 = false;
        else if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
          break;
        const s2 = this.startNode(), r2 = this.match(bn$1.string), i2 = this.parseModuleExportName();
        s2.local = i2, this.eatContextual("as") ? s2.exported = this.parseModuleExportName() : s2.exported = r2 ? vo$1(i2) : Io$1(i2), e20.push(this.finishNode(s2, "ExportSpecifier"));
      }
      return e20;
    }
    parseModuleExportName() {
      if (this.match(bn$1.string)) {
        const e20 = this.parseStringLiteral(this.state.value), t2 = e20.value.match(hu);
        return t2 && this.raise(e20.start, Rn$1.ModuleExportNameHasLoneSurrogate, t2[0].charCodeAt(0).toString(16)), e20;
      }
      return this.parseIdentifier(true);
    }
    parseImport(e20) {
      if (e20.specifiers = [], !this.match(bn$1.string)) {
        const t3 = !this.maybeParseDefaultImportSpecifier(e20) || this.eat(bn$1.comma), s2 = t3 && this.maybeParseStarImportSpecifier(e20);
        t3 && !s2 && this.parseNamedImportSpecifiers(e20), this.expectContextual("from");
      }
      e20.source = this.parseImportSource();
      const t2 = this.maybeParseImportAssertions();
      if (t2)
        e20.assertions = t2;
      else {
        const t3 = this.maybeParseModuleAttributes();
        t3 && (e20.attributes = t3);
      }
      return this.semicolon(), this.finishNode(e20, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(bn$1.string) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(e20) {
      return this.match(bn$1.name);
    }
    parseImportSpecifierLocal(e20, t2, s2, r2) {
      t2.local = this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e20.specifiers.push(this.finishNode(t2, s2));
    }
    parseAssertEntries() {
      const e20 = [], t2 = new Set();
      do {
        if (this.match(bn$1.braceR))
          break;
        const s2 = this.startNode(), r2 = this.state.value;
        if (t2.has(r2) && this.raise(this.state.start, Rn$1.ModuleAttributesWithDuplicateKeys, r2), t2.add(r2), this.match(bn$1.string) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(bn$1.colon), !this.match(bn$1.string))
          throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
      } while (this.eat(bn$1.comma));
      return e20;
    }
    maybeParseModuleAttributes() {
      if (!this.match(bn$1._with) || this.hasPrecedingLineBreak())
        return this.hasPlugin("moduleAttributes") ? [] : null;
      this.expectPlugin("moduleAttributes"), this.next();
      const e20 = [], t2 = new Set();
      do {
        const s2 = this.startNode();
        if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Rn$1.ModuleAttributeDifferentFromType, s2.key.name), t2.has(s2.key.name) && this.raise(s2.key.start, Rn$1.ModuleAttributesWithDuplicateKeys, s2.key.name), t2.add(s2.key.name), this.expect(bn$1.colon), !this.match(bn$1.string))
          throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
      } while (this.eat(bn$1.comma));
      return e20;
    }
    maybeParseImportAssertions() {
      if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
        return this.hasPlugin("importAssertions") ? [] : null;
      this.expectPlugin("importAssertions"), this.next(), this.eat(bn$1.braceL);
      const e20 = this.parseAssertEntries();
      return this.eat(bn$1.braceR), e20;
    }
    maybeParseDefaultImportSpecifier(e20) {
      return !!this.shouldParseDefaultImport(e20) && (this.parseImportSpecifierLocal(e20, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
    }
    maybeParseStarImportSpecifier(e20) {
      if (this.match(bn$1.star)) {
        const t2 = this.startNode();
        return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e20, t2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e20) {
      let t2 = true;
      for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
        if (t2)
          t2 = false;
        else {
          if (this.eat(bn$1.colon))
            throw this.raise(this.state.start, Rn$1.DestructureNamedImport);
          if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
            break;
        }
        this.parseImportSpecifier(e20);
      }
    }
    parseImportSpecifier(e20) {
      const t2 = this.startNode(), s2 = this.match(bn$1.string);
      if (t2.imported = this.parseModuleExportName(), this.eatContextual("as"))
        t2.local = this.parseIdentifier();
      else {
        const {imported: e21} = t2;
        if (s2)
          throw this.raise(t2.start, Rn$1.ImportBindingIsString, e21.value);
        this.checkReservedWord(e21.name, t2.start, true, true), t2.local = Io$1(e21);
      }
      this.checkLVal(t2.local, "import specifier", 9), e20.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
    }
    isThisParam(e20) {
      return e20.type === "Identifier" && e20.name === "this";
    }
  } {
    constructor(e20, t2) {
      super(e20 = function(e21) {
        const t3 = {};
        for (const s2 of Object.keys(au))
          t3[s2] = e21 && e21[s2] != null ? e21[s2] : au[s2];
        return t3;
      }(e20), t2), this.options = e20, this.initializeScopes(), this.plugins = function(e21) {
        const t3 = new Map();
        for (const s2 of e21) {
          const [e22, r2] = Array.isArray(s2) ? s2 : [s2, {}];
          t3.has(e22) || t3.set(e22, r2 || {});
        }
        return t3;
      }(this.options.plugins), this.filename = e20.sourceFilename;
    }
    getScopeHandler() {
      return co$1;
    }
    parse() {
      this.enterInitialScopes();
      const e20 = this.startNode(), t2 = this.startNode();
      return this.nextToken(), e20.errors = null, this.parseTopLevel(e20, t2), e20.errors = this.state.errors, e20;
    }
  }
  function lu(e20, t2) {
    let s2 = pu;
    return e20 != null && e20.plugins && (!function(e21) {
      if (Qo(e21, "decorators")) {
        if (Qo(e21, "decorators-legacy"))
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const t3 = Zo(e21, "decorators", "decoratorsBeforeExport");
        if (t3 == null)
          throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        if (typeof t3 != "boolean")
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
      if (Qo(e21, "flow") && Qo(e21, "typescript"))
        throw new Error("Cannot combine flow and typescript plugins.");
      if (Qo(e21, "placeholders") && Qo(e21, "v8intrinsic"))
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (Qo(e21, "pipelineOperator")) {
        const t3 = Zo(e21, "pipelineOperator", "proposal");
        if (!eu.includes(t3)) {
          const e22 = eu.map((e23) => `"${e23}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e22}.`);
        }
        const s3 = Qo(e21, "recordAndTuple") && Zo(e21, "recordAndTuple", "syntaxType") === "hash";
        if (t3 === "hack") {
          if (Qo(e21, "placeholders"))
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          if (Qo(e21, "v8intrinsic"))
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          const t4 = Zo(e21, "pipelineOperator", "topicToken");
          if (!tu.includes(t4)) {
            const e22 = tu.map((e23) => `"${e23}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e22}.`);
          }
          if (t4 === "#" && s3)
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if (t3 === "smart" && s3)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
      if (Qo(e21, "moduleAttributes")) {
        if (Qo(e21, "importAssertions"))
          throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        if (Zo(e21, "moduleAttributes", "version") !== "may-2020")
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (Qo(e21, "recordAndTuple") && !su.includes(Zo(e21, "recordAndTuple", "syntaxType")))
        throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + su.map((e22) => `'${e22}'`).join(", "));
      if (Qo(e21, "asyncDoExpressions") && !Qo(e21, "doExpressions")) {
        const e22 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        throw e22.missingPlugins = "doExpressions", e22;
      }
    }(e20.plugins), s2 = function(e21) {
      const t3 = iu.filter((t4) => Qo(e21, t4)), s3 = t3.join("/");
      let r2 = du[s3];
      if (!r2) {
        r2 = pu;
        for (const e22 of t3)
          r2 = ru[e22](r2);
        du[s3] = r2;
      }
      return r2;
    }(e20.plugins)), new s2(e20, t2);
  }
  const du = {};
  var Du = function(e20, t2) {
    var s2;
    if (((s2 = t2) == null ? void 0 : s2.sourceType) !== "unambiguous")
      return lu(t2, e20).parse();
    t2 = Object.assign({}, t2);
    try {
      t2.sourceType = "module";
      const s3 = lu(t2, e20), r2 = s3.parse();
      if (s3.sawUnambiguousESM)
        return r2;
      if (s3.ambiguousScriptDifferentAst)
        try {
          return t2.sourceType = "script", lu(t2, e20).parse();
        } catch (e21) {
        }
      else
        r2.program.sourceType = "script";
      return r2;
    } catch (s3) {
      try {
        return t2.sourceType = "script", lu(t2, e20).parse();
      } catch (e21) {
      }
      throw s3;
    }
  }, mu = function(e20, t2) {
    const s2 = lu(t2, e20);
    return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
  }, fu = bn$1, yu = Object.defineProperty({parse: Du, parseExpression: mu, tokTypes: fu}, "__esModule", {value: true});
  const {isNonEmptyArray: Au} = tr$1;
  function Eu(e20 = {}) {
    const {allowComments: t2 = true} = e20;
    return function(e21) {
      const {parseExpression: s2} = yu;
      let r2;
      try {
        r2 = s2(e21, {tokens: true, ranges: true});
      } catch (e22) {
        throw ni$1(e22);
      }
      if (!t2 && Au(r2.comments))
        throw Cu(r2.comments[0], "Comment");
      return xu(r2), r2;
    };
  }
  function Cu(e20, t2) {
    const [s2, r2] = [e20.loc.start, e20.loc.end].map(({line: e21, column: t3}) => ({line: e21, column: t3 + 1}));
    return ai$1(`${t2} is not allowed in JSON.`, {start: s2, end: r2});
  }
  function xu(e20) {
    switch (e20.type) {
      case "ArrayExpression":
        for (const t2 of e20.elements)
          t2 !== null && xu(t2);
        return;
      case "ObjectExpression":
        for (const t2 of e20.properties)
          xu(t2);
        return;
      case "ObjectProperty":
        if (e20.computed)
          throw Cu(e20.key, "Computed key");
        if (e20.shorthand)
          throw Cu(e20.key, "Shorthand property");
        return e20.key.type !== "Identifier" && xu(e20.key), void xu(e20.value);
      case "UnaryExpression": {
        const {operator: t2, argument: s2} = e20;
        if (t2 !== "+" && t2 !== "-")
          throw Cu(e20, `Operator '${e20.operator}'`);
        if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
          return;
        throw Cu(s2, `Operator '${t2}' before '${s2.type}'`);
      }
      case "Identifier":
        if (e20.name !== "Infinity" && e20.name !== "NaN" && e20.name !== "undefined")
          throw Cu(e20, `Identifier '${e20.name}'`);
        return;
      case "TemplateLiteral":
        if (Au(e20.expressions))
          throw Cu(e20.expressions[0], "'TemplateLiteral' with expression");
        for (const t2 of e20.quasis)
          xu(t2);
        return;
      case "NullLiteral":
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
      case "TemplateElement":
        return;
      default:
        throw Cu(e20, `'${e20.type}'`);
    }
  }
  const Fu = Eu();
  var gu = {json: ii$1({parse: Fu, hasPragma: () => true}), json5: ii$1(Fu), "json-stringify": ii$1({parse: Eu({allowComments: false}), astFormat: "estree-json"})};
  const {getNextNonSpaceNonCommentCharacterIndexWithStartIndex: bu, getShebang: Pu} = tr$1, Tu = {sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", {decoratorsBeforeExport: false}], "importAssertions", "decimal", "classStaticBlock", "moduleBlocks", "asyncDoExpressions"], tokens: true, ranges: true}, wu = ["recordAndTuple", {syntaxType: "hash"}], Su = [["pipelineOperator", {proposal: "hack", topicToken: "%"}], ["pipelineOperator", {proposal: "minimal"}], ["pipelineOperator", {proposal: "fsharp"}]], Bu = (e20, t2 = Tu) => Object.assign(Object.assign({}, t2), {}, {plugins: [...t2.plugins, ...e20]}), Nu = /@(?:no)?flow\b/;
  function Iu(e20, ...t2) {
    return (s2, r2, i2 = {}) => {
      if ((i2.parser === "babel" || i2.parser === "__babel_estree") && function(e21, t3) {
        if (t3.filepath && t3.filepath.endsWith(".js.flow"))
          return true;
        const s3 = Pu(e21);
        s3 && (e21 = e21.slice(s3.length));
        const r3 = bu(e21, 0);
        return r3 !== false && (e21 = e21.slice(0, r3)), Nu.test(e21);
      }(s2, i2))
        return i2.parser = "babel-flow", ku(s2, r2, i2);
      let a2 = t2;
      i2.__babelSourceType === "script" && (a2 = a2.map((e21) => Object.assign(Object.assign({}, e21), {}, {sourceType: "script"}))), /#[[{]/.test(s2) && (a2 = a2.map((e21) => Bu([wu], e21)));
      const n2 = /%[A-Z]/.test(s2);
      if (s2.includes("|>")) {
        const e21 = n2 ? [...Su, "v8intrinsic"] : Su;
        a2 = e21.flatMap((e22) => a2.map((t3) => Bu([e22], t3)));
      } else
        n2 && (a2 = a2.map((e21) => Bu(["v8intrinsic"], e21)));
      const {result: o2, error: u2} = Je$2(...a2.map((t3) => () => function(e21, t4, s3) {
        const r3 = (0, yu[e21])(t4, s3), i3 = r3.errors.find((e22) => !Ru.has(e22.reasonCode));
        if (i3)
          throw i3;
        return r3;
      }(e20, s2, t3)));
      if (!o2)
        throw ni$1(u2);
      return En$1(o2, Object.assign(Object.assign({}, i2), {}, {originalText: s2}));
    };
  }
  const vu = Iu("parse", Bu(["jsx", "flow"])), ku = Iu("parse", Bu(["jsx", ["flow", {all: true, enums: true}]])), Lu = Iu("parse", Bu(["jsx", "typescript"]), Bu(["typescript"])), Ou = Iu("parse", Bu(["jsx", "flow", "estree"])), Mu = Iu("parseExpression", Bu(["jsx"])), Ru = new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), ju = ii$1(vu), _u = ii$1(Mu);
  var Uu = {parsers: Object.assign(Object.assign({babel: ju, "babel-flow": ii$1(ku), "babel-ts": ii$1(Lu)}, gu), {}, {__js_expression: _u, __vue_expression: _u, __vue_event_binding: ju, __babel_estree: ii$1(Ou)})};
  var e$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t$1(e20) {
    var t2 = {exports: {}};
    return e20(t2, t2.exports), t2.exports;
  }
  var r$1 = t$1(function(e20, t2) {
    function r2(e21) {
      return t2.$0 <= e21 && e21 <= t2.$9;
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true}), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
      return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
    }, t2.isDigit = r2, t2.isAsciiLetter = function(e21) {
      return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
    }, t2.isAsciiHexDigit = function(e21) {
      return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || r2(e21);
    }, t2.isNewLine = function(e21) {
      return e21 === t2.$LF || e21 === t2.$CR;
    }, t2.isOctalDigit = function(e21) {
      return t2.$0 <= e21 && e21 <= t2.$7;
    };
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class n$1 {
    constructor(e20, t2, r2) {
      this.filePath = e20, this.name = t2, this.members = r2;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  }
  var i$1 = n$1;
  var s$1 = class {
    constructor() {
      this.cache = new Map();
    }
    get(e20, t2, r2) {
      const i2 = `"${e20}".${t2}${(r2 = r2 || []).length ? `.${r2.join(".")}` : ""}`;
      let s2 = this.cache.get(i2);
      return s2 || (s2 = new n$1(e20, t2, r2), this.cache.set(i2, s2)), s2;
    }
  }, o$1 = Object.defineProperty({StaticSymbol: i$1, StaticSymbolCache: s$1}, "__esModule", {value: true});
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const a$1$1 = /-+([a-z0-9])/g;
  var u$1 = function(e20) {
    return e20.replace(a$1$1, (...e21) => e21[1].toUpperCase());
  };
  var c$1 = function(e20, t2) {
    return p$1(e20, ":", t2);
  };
  var l$1 = function(e20, t2) {
    return p$1(e20, ".", t2);
  };
  function p$1(e20, t2, r2) {
    const n2 = e20.indexOf(t2);
    return n2 == -1 ? r2 : [e20.slice(0, n2).trim(), e20.slice(n2 + 1).trim()];
  }
  function h$1(e20, t2, r2) {
    return Array.isArray(e20) ? t2.visitArray(e20, r2) : typeof (n2 = e20) == "object" && n2 !== null && Object.getPrototypeOf(n2) === v$1 ? t2.visitStringMap(e20, r2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, r2) : t2.visitOther(e20, r2);
    var n2;
  }
  var D$1 = h$1;
  var f$1 = function(e20) {
    return e20 != null;
  };
  var d$1$1 = function(e20) {
    return e20 === void 0 ? null : e20;
  };
  var g$1 = class {
    visitArray(e20, t2) {
      return e20.map((e21) => h$1(e21, this, t2));
    }
    visitStringMap(e20, t2) {
      const r2 = {};
      return Object.keys(e20).forEach((n2) => {
        r2[n2] = h$1(e20[n2], this, t2);
      }), r2;
    }
    visitPrimitive(e20, t2) {
      return e20;
    }
    visitOther(e20, t2) {
      return e20;
    }
  }, m$1 = {assertSync: (e20) => {
    if (k$1$1(e20))
      throw new Error("Illegal state: value cannot be a promise");
    return e20;
  }, then: (e20, t2) => k$1$1(e20) ? e20.then(t2) : t2(e20), all: (e20) => e20.some(k$1$1) ? Promise.all(e20) : e20};
  var E$1 = function(e20) {
    throw new Error(`Internal Error: ${e20}`);
  };
  var C$1 = function(e20, t2) {
    const r2 = Error(e20);
    return r2[y$1] = true, t2 && (r2[b$1] = t2), r2;
  };
  const y$1 = "ngSyntaxError", b$1 = "ngParseErrors";
  var S$1 = function(e20) {
    return e20[y$1];
  };
  var T$1 = function(e20) {
    return e20[b$1] || [];
  };
  var _$1 = function(e20) {
    return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  };
  const v$1 = Object.getPrototypeOf({});
  var A$1 = function(e20) {
    let t2 = "";
    for (let r2 = 0; r2 < e20.length; r2++) {
      let n2 = e20.charCodeAt(r2);
      if (n2 >= 55296 && n2 <= 56319 && e20.length > r2 + 1) {
        const t3 = e20.charCodeAt(r2 + 1);
        t3 >= 56320 && t3 <= 57343 && (r2++, n2 = (n2 - 55296 << 10) + t3 - 56320 + 65536);
      }
      n2 <= 127 ? t2 += String.fromCharCode(n2) : n2 <= 2047 ? t2 += String.fromCharCode(n2 >> 6 & 31 | 192, 63 & n2 | 128) : n2 <= 65535 ? t2 += String.fromCharCode(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128) : n2 <= 2097151 && (t2 += String.fromCharCode(n2 >> 18 & 7 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128));
    }
    return t2;
  };
  var F$1 = function e17(t2) {
    if (typeof t2 == "string")
      return t2;
    if (t2 instanceof Array)
      return "[" + t2.map(e17).join(", ") + "]";
    if (t2 == null)
      return "" + t2;
    if (t2.overriddenName)
      return `${t2.overriddenName}`;
    if (t2.name)
      return `${t2.name}`;
    if (!t2.toString)
      return "object";
    const r2 = t2.toString();
    if (r2 == null)
      return "" + r2;
    const n2 = r2.indexOf("\n");
    return n2 === -1 ? r2 : r2.substring(0, n2);
  };
  var w$1 = function(e20) {
    return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
  };
  function k$1$1(e20) {
    return !!e20 && typeof e20.then == "function";
  }
  var N$1 = k$1$1;
  var O$1 = class {
    constructor(e20) {
      this.full = e20;
      const t2 = e20.split(".");
      this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
    }
  };
  const x$1 = typeof window != "undefined" && window, I$1 = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
  var P$1 = e$1 !== void 0 && e$1 || x$1 || I$1, R$1 = Object.defineProperty({dashCaseToCamelCase: u$1, splitAtColon: c$1, splitAtPeriod: l$1, visitValue: D$1, isDefined: f$1, noUndefined: d$1$1, ValueTransformer: g$1, SyncAsync: m$1, error: E$1, syntaxError: C$1, isSyntaxError: S$1, getParseErrors: T$1, escapeRegExp: _$1, utf8Encode: A$1, stringify: F$1, resolveForwardRef: w$1, isPromise: N$1, Version: O$1, global: P$1}, "__esModule", {value: true}), L$1 = t$1(function(e20, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true});
    const r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function n2(e21) {
      return e21.replace(/\W/g, "_");
    }
    t2.sanitizeIdentifier = n2;
    let i2 = 0;
    function s2(e21) {
      if (!e21 || !e21.reference)
        return null;
      const t3 = e21.reference;
      if (t3 instanceof o$1.StaticSymbol)
        return t3.name;
      if (t3.__anonymousType)
        return t3.__anonymousType;
      let r3 = R$1.stringify(t3);
      return r3.indexOf("(") >= 0 ? (r3 = "anonymous_" + i2++, t3.__anonymousType = r3) : r3 = n2(r3), r3;
    }
    var a2;
    t2.identifierName = s2, t2.identifierModuleUrl = function(e21) {
      const t3 = e21.reference;
      return t3 instanceof o$1.StaticSymbol ? t3.filePath : `./${R$1.stringify(t3)}`;
    }, t2.viewClassName = function(e21, t3) {
      return `View_${s2({reference: e21})}_${t3}`;
    }, t2.rendererTypeName = function(e21) {
      return `RenderType_${s2({reference: e21})}`;
    }, t2.hostViewClassName = function(e21) {
      return `HostView_${s2({reference: e21})}`;
    }, t2.componentFactoryName = function(e21) {
      return `${s2({reference: e21})}NgFactory`;
    }, function(e21) {
      e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
    }(a2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
      return e21.value != null ? n2(e21.value) : s2(e21.identifier);
    }, t2.tokenReference = function(e21) {
      return e21.identifier != null ? e21.identifier.reference : e21.value;
    };
    t2.CompileStylesheetMetadata = class {
      constructor({moduleUrl: e21, styles: t3, styleUrls: r3} = {}) {
        this.moduleUrl = e21 || null, this.styles = c2(t3), this.styleUrls = c2(r3);
      }
    };
    t2.CompileTemplateMetadata = class {
      constructor({encapsulation: e21, template: t3, templateUrl: r3, htmlAst: n3, styles: i3, styleUrls: s3, externalStylesheets: o2, animations: a3, ngContentSelectors: u3, interpolation: p3, isInline: h2, preserveWhitespaces: D2}) {
        if (this.encapsulation = e21, this.template = t3, this.templateUrl = r3, this.htmlAst = n3, this.styles = c2(i3), this.styleUrls = c2(s3), this.externalStylesheets = c2(o2), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = u3 || [], p3 && p3.length != 2)
          throw new Error("'interpolation' should have a start and an end symbol.");
        this.interpolation = p3, this.isInline = h2, this.preserveWhitespaces = D2;
      }
      toSummary() {
        return {ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations};
      }
    };
    class u2 {
      static create({isHost: e21, type: t3, isComponent: n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: a3, outputs: c3, host: l3, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2}) {
        const b2 = {}, S2 = {}, T2 = {};
        l3 != null && Object.keys(l3).forEach((e22) => {
          const t4 = l3[e22], n4 = e22.match(r2);
          n4 === null ? T2[e22] = t4 : n4[1] != null ? S2[n4[1]] = t4 : n4[2] != null && (b2[n4[2]] = t4);
        });
        const _2 = {};
        a3 != null && a3.forEach((e22) => {
          const t4 = R$1.splitAtColon(e22, [e22, e22]);
          _2[t4[0]] = t4[1];
        });
        const v2 = {};
        return c3 != null && c3.forEach((e22) => {
          const t4 = R$1.splitAtColon(e22, [e22, e22]);
          v2[t4[0]] = t4[1];
        }), new u2({isHost: e21, type: t3, isComponent: !!n3, selector: i3, exportAs: s3, changeDetection: o2, inputs: _2, outputs: v2, hostListeners: b2, hostProperties: S2, hostAttributes: T2, providers: p3, viewProviders: h2, queries: D2, guards: f2, viewQueries: d2, entryComponents: g2, template: m2, componentViewType: E2, rendererType: C2, componentFactory: y2});
      }
      constructor({isHost: e21, type: t3, isComponent: r3, selector: n3, exportAs: i3, changeDetection: s3, inputs: o2, outputs: a3, hostListeners: u3, hostProperties: l3, hostAttributes: p3, providers: h2, viewProviders: D2, queries: f2, guards: d2, viewQueries: g2, entryComponents: m2, template: E2, componentViewType: C2, rendererType: y2, componentFactory: b2}) {
        this.isHost = !!e21, this.type = t3, this.isComponent = r3, this.selector = n3, this.exportAs = i3, this.changeDetection = s3, this.inputs = o2, this.outputs = a3, this.hostListeners = u3, this.hostProperties = l3, this.hostAttributes = p3, this.providers = c2(h2), this.viewProviders = c2(D2), this.queries = c2(f2), this.guards = d2, this.viewQueries = c2(g2), this.entryComponents = c2(m2), this.template = E2, this.componentViewType = C2, this.rendererType = y2, this.componentFactory = b2;
      }
      toSummary() {
        return {summaryKind: a2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory};
      }
    }
    t2.CompileDirectiveMetadata = u2;
    t2.CompilePipeMetadata = class {
      constructor({type: e21, name: t3, pure: r3}) {
        this.type = e21, this.name = t3, this.pure = !!r3;
      }
      toSummary() {
        return {summaryKind: a2.Pipe, type: this.type, name: this.name, pure: this.pure};
      }
    };
    t2.CompileShallowModuleMetadata = class {
    };
    t2.CompileNgModuleMetadata = class {
      constructor({type: e21, providers: t3, declaredDirectives: r3, exportedDirectives: n3, declaredPipes: i3, exportedPipes: s3, entryComponents: o2, bootstrapComponents: a3, importedModules: u3, exportedModules: l3, schemas: p3, transitiveModule: h2, id: D2}) {
        this.type = e21 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(n3), this.declaredPipes = c2(i3), this.exportedPipes = c2(s3), this.providers = c2(t3), this.entryComponents = c2(o2), this.bootstrapComponents = c2(a3), this.importedModules = c2(u3), this.exportedModules = c2(l3), this.schemas = c2(p3), this.id = D2 || null, this.transitiveModule = h2 || null;
      }
      toSummary() {
        const e21 = this.transitiveModule;
        return {summaryKind: a2.NgModule, type: this.type, entryComponents: e21.entryComponents, providers: e21.providers, modules: e21.modules, exportedDirectives: e21.exportedDirectives, exportedPipes: e21.exportedPipes};
      }
    };
    function c2(e21) {
      return e21 || [];
    }
    t2.TransitiveCompileNgModuleMetadata = class {
      constructor() {
        this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
      }
      addProvider(e21, t3) {
        this.providers.push({provider: e21, module: t3});
      }
      addDirective(e21) {
        this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
      }
      addExportedDirective(e21) {
        this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
      }
      addPipe(e21) {
        this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
      }
      addExportedPipe(e21) {
        this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
      }
      addModule(e21) {
        this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
      }
      addEntryComponent(e21) {
        this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
      }
    };
    function l2(e21) {
      return e21.reduce((e22, t3) => {
        const r3 = Array.isArray(t3) ? l2(t3) : t3;
        return e22.concat(r3);
      }, []);
    }
    function p2(e21) {
      return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t2.ProviderMeta = class {
      constructor(e21, {useClass: t3, useValue: r3, useExisting: n3, useFactory: i3, deps: s3, multi: o2}) {
        this.token = e21, this.useClass = t3 || null, this.useValue = r3, this.useExisting = n3, this.useFactory = i3 || null, this.dependencies = s3 || null, this.multi = !!o2;
      }
    }, t2.flatten = l2, t2.templateSourceUrl = function(e21, t3, r3) {
      let n3;
      return n3 = r3.isInline ? t3.type.reference instanceof o$1.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${s2(e21)}/${s2(t3.type)}.html` : r3.templateUrl, t3.type.reference instanceof o$1.StaticSymbol ? n3 : p2(n3);
    }, t2.sharedStylesheetJitUrl = function(e21, t3) {
      const r3 = e21.moduleUrl.split(/\/\\/g);
      return p2(`css/${t3}${r3[r3.length - 1]}.ngstyle.js`);
    }, t2.ngModuleJitUrl = function(e21) {
      return p2(`${s2(e21.type)}/module.ngfactory.js`);
    }, t2.templateJitUrl = function(e21, t3) {
      return p2(`${s2(e21)}/${s2(t3.type)}.ngfactory.js`);
    };
  }), B$1 = t$1(function(e20, t2) {
    Object.defineProperty(t2, "__esModule", {value: true});
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    class n2 {
      constructor(e21, t3, r2, n3) {
        this.file = e21, this.offset = t3, this.line = r2, this.col = n3;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(e21) {
        const t3 = this.file.content, i3 = t3.length;
        let s3 = this.offset, o3 = this.line, a2 = this.col;
        for (; s3 > 0 && e21 < 0; ) {
          s3--, e21++;
          if (t3.charCodeAt(s3) == r$1.$LF) {
            o3--;
            const e22 = t3.substr(0, s3 - 1).lastIndexOf(String.fromCharCode(r$1.$LF));
            a2 = e22 > 0 ? s3 - e22 : s3;
          } else
            a2--;
        }
        for (; s3 < i3 && e21 > 0; ) {
          const n3 = t3.charCodeAt(s3);
          s3++, e21--, n3 == r$1.$LF ? (o3++, a2 = 0) : a2++;
        }
        return new n2(this.file, s3, o3, a2);
      }
      getContext(e21, t3) {
        const r2 = this.file.content;
        let n3 = this.offset;
        if (n3 != null) {
          n3 > r2.length - 1 && (n3 = r2.length - 1);
          let i3 = n3, s3 = 0, o3 = 0;
          for (; s3 < e21 && n3 > 0 && (n3--, s3++, r2[n3] != "\n" || ++o3 != t3); )
            ;
          for (s3 = 0, o3 = 0; s3 < e21 && i3 < r2.length - 1 && (i3++, s3++, r2[i3] != "\n" || ++o3 != t3); )
            ;
          return {before: r2.substring(n3, this.offset), after: r2.substring(this.offset, i3 + 1)};
        }
        return null;
      }
    }
    t2.ParseLocation = n2;
    class i2 {
      constructor(e21, t3) {
        this.content = e21, this.url = t3;
      }
    }
    t2.ParseSourceFile = i2;
    class s2 {
      constructor(e21, t3, r2 = null) {
        this.start = e21, this.end = t3, this.details = r2;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    }
    var o2;
    t2.ParseSourceSpan = s2, t2.EMPTY_PARSE_LOCATION = new n2(new i2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new s2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
      e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
    }(o2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
    t2.ParseError = class {
      constructor(e21, t3, r2 = o2.ERROR) {
        this.span = e21, this.msg = t3, this.level = r2;
      }
      contextualMessage() {
        const e21 = this.span.start.getContext(100, 3);
        return e21 ? `${this.msg} ("${e21.before}[${o2[this.level]} ->]${e21.after}")` : this.msg;
      }
      toString() {
        const e21 = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${e21}`;
      }
    }, t2.typeSourceSpan = function(e21, t3) {
      const r2 = L$1.identifierModuleUrl(t3), o3 = r2 != null ? `in ${e21} ${L$1.identifierName(t3)} in ${r2}` : `in ${e21} ${L$1.identifierName(t3)}`, a2 = new i2("", o3);
      return new s2(new n2(a2, -1, -1, -1), new n2(a2, -1, -1, -1));
    }, t2.r3JitTypeSourceSpan = function(e21, t3, r2) {
      const o3 = new i2("", `in ${e21} ${t3} in ${r2}`);
      return new s2(new n2(o3, -1, -1, -1), new n2(o3, -1, -1, -1));
    };
  });
  const $$1 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  var q$1 = function(e20) {
    const t2 = e20.match($$1);
    if (!t2)
      return {content: e20};
    const {startDelimiter: r2, language: n2, value: i2 = "", endDelimiter: s2} = t2.groups;
    let o2 = n2.trim() || "yaml";
    if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== s2)
      return {content: e20};
    const [a2] = t2;
    return {frontMatter: {type: "front-matter", lang: o2, value: i2, startDelimiter: r2, endDelimiter: s2, raw: a2.replace(/\n$/, "")}, content: a2.replace(/[^\n]/g, " ") + e20.slice(a2.length)};
  };
  var M$1 = (e20) => e20[e20.length - 1];
  var j$1 = function(e20, t2) {
    const r2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
    return r2.loc = t2, r2;
  }, U$1 = (e20) => typeof e20 == "string" ? e20.replace((({onlyFirst: e21 = false} = {}) => {
    const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e21 ? void 0 : "g");
  })(), "") : e20;
  const G$1 = (e20) => !Number.isNaN(e20) && (e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141));
  var V$1 = G$1, H$1 = G$1;
  V$1.default = H$1;
  const X$1 = (e20) => {
    if (typeof e20 != "string" || e20.length === 0)
      return 0;
    if ((e20 = U$1(e20)).length === 0)
      return 0;
    e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
    let t2 = 0;
    for (let r2 = 0; r2 < e20.length; r2++) {
      const n2 = e20.codePointAt(r2);
      n2 <= 31 || n2 >= 127 && n2 <= 159 || (n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t2 += V$1(n2) ? 2 : 1));
    }
    return t2;
  };
  var z$1 = X$1, W$1 = X$1;
  z$1.default = W$1;
  var Y$1 = (e20) => {
    if (typeof e20 != "string")
      throw new TypeError("Expected a string");
    return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  function Q$1(e20, t2) {
    if (e20 == null)
      return {};
    var r2, n2, i2 = function(e21, t3) {
      if (e21 == null)
        return {};
      var r3, n3, i3 = {}, s3 = Object.keys(e21);
      for (n3 = 0; n3 < s3.length; n3++)
        r3 = s3[n3], t3.indexOf(r3) >= 0 || (i3[r3] = e21[r3]);
      return i3;
    }(e20, t2);
    if (Object.getOwnPropertySymbols) {
      var s2 = Object.getOwnPropertySymbols(e20);
      for (n2 = 0; n2 < s2.length; n2++)
        r2 = s2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, r2) && (i2[r2] = e20[r2]);
    }
    return i2;
  }
  var J$1, K$1, Z$1 = function(e20) {
    return e20 && e20.Math == Math && e20;
  }, ee$1 = Z$1(typeof globalThis == "object" && globalThis) || Z$1(typeof window == "object" && window) || Z$1(typeof self == "object" && self) || Z$1(typeof e$1 == "object" && e$1) || function() {
    return this;
  }() || Function("return this")(), te$1 = function(e20) {
    try {
      return !!e20();
    } catch (e21) {
      return true;
    }
  }, re$1 = !te$1(function() {
    return Object.defineProperty({}, 1, {get: function() {
      return 7;
    }})[1] != 7;
  }), ne$1 = {}.propertyIsEnumerable, ie$1 = Object.getOwnPropertyDescriptor, se$1 = {f: ie$1 && !ne$1.call({1: 2}, 1) ? function(e20) {
    var t2 = ie$1(this, e20);
    return !!t2 && t2.enumerable;
  } : ne$1}, oe$1 = function(e20, t2) {
    return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
  }, ae$1 = {}.toString, ue$1 = function(e20) {
    return ae$1.call(e20).slice(8, -1);
  }, ce$1 = "".split, le$1 = te$1(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e20) {
    return ue$1(e20) == "String" ? ce$1.call(e20, "") : Object(e20);
  } : Object, pe$1 = function(e20) {
    if (e20 == null)
      throw TypeError("Can't call method on " + e20);
    return e20;
  }, he$1 = function(e20) {
    return le$1(pe$1(e20));
  }, De$1 = function(e20) {
    return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
  }, fe$1 = function(e20) {
    return typeof e20 == "function" ? e20 : void 0;
  }, de$1 = function(e20, t2) {
    return arguments.length < 2 ? fe$1(ee$1[e20]) : ee$1[e20] && ee$1[e20][t2];
  }, ge$1 = de$1("navigator", "userAgent") || "", me$1 = ee$1.process, Ee$1 = ee$1.Deno, Ce$1 = me$1 && me$1.versions || Ee$1 && Ee$1.version, ye$1 = Ce$1 && Ce$1.v8;
  ye$1 ? K$1 = (J$1 = ye$1.split("."))[0] < 4 ? 1 : J$1[0] + J$1[1] : ge$1 && (!(J$1 = ge$1.match(/Edge\/(\d+)/)) || J$1[1] >= 74) && (J$1 = ge$1.match(/Chrome\/(\d+)/)) && (K$1 = J$1[1]);
  var be$1 = K$1 && +K$1, Se$1 = !!Object.getOwnPropertySymbols && !te$1(function() {
    var e20 = Symbol();
    return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && be$1 && be$1 < 41;
  }), Te$1 = Se$1 && !Symbol.sham && typeof Symbol.iterator == "symbol", _e$1$1 = Te$1 ? function(e20) {
    return typeof e20 == "symbol";
  } : function(e20) {
    var t2 = de$1("Symbol");
    return typeof t2 == "function" && Object(e20) instanceof t2;
  }, ve$1 = function(e20, t2) {
    try {
      Object.defineProperty(ee$1, e20, {value: t2, configurable: true, writable: true});
    } catch (r2) {
      ee$1[e20] = t2;
    }
    return t2;
  }, Ae$1 = ee$1["__core-js_shared__"] || ve$1("__core-js_shared__", {}), Fe$1 = t$1(function(e20) {
    (e20.exports = function(e21, t2) {
      return Ae$1[e21] || (Ae$1[e21] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
  }), we$1 = function(e20) {
    return Object(pe$1(e20));
  }, ke$1 = {}.hasOwnProperty, Ne$1 = Object.hasOwn || function(e20, t2) {
    return ke$1.call(we$1(e20), t2);
  }, Oe$1 = 0, xe$1 = Math.random(), Ie$1 = function(e20) {
    return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++Oe$1 + xe$1).toString(36);
  }, Pe$1 = Fe$1("wks"), Re$1 = ee$1.Symbol, Le$1 = Te$1 ? Re$1 : Re$1 && Re$1.withoutSetter || Ie$1, Be$1 = function(e20) {
    return Ne$1(Pe$1, e20) && (Se$1 || typeof Pe$1[e20] == "string") || (Se$1 && Ne$1(Re$1, e20) ? Pe$1[e20] = Re$1[e20] : Pe$1[e20] = Le$1("Symbol." + e20)), Pe$1[e20];
  }, $e$1 = Be$1("toPrimitive"), qe$1 = function(e20, t2) {
    if (!De$1(e20) || _e$1$1(e20))
      return e20;
    var r2, n2 = e20[$e$1];
    if (n2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !De$1(r2) || _e$1$1(r2))
        return r2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e21, t3) {
      var r3, n3;
      if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
        return n3;
      if (typeof (r3 = e21.valueOf) == "function" && !De$1(n3 = r3.call(e21)))
        return n3;
      if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
        return n3;
      throw TypeError("Can't convert object to primitive value");
    }(e20, t2);
  }, Me$1 = function(e20) {
    var t2 = qe$1(e20, "string");
    return _e$1$1(t2) ? t2 : String(t2);
  }, je$1 = ee$1.document, Ue$1 = De$1(je$1) && De$1(je$1.createElement), Ge$1 = !re$1 && !te$1(function() {
    return Object.defineProperty((e20 = "div", Ue$1 ? je$1.createElement(e20) : {}), "a", {get: function() {
      return 7;
    }}).a != 7;
    var e20;
  }), Ve$1 = Object.getOwnPropertyDescriptor, He$1 = {f: re$1 ? Ve$1 : function(e20, t2) {
    if (e20 = he$1(e20), t2 = Me$1(t2), Ge$1)
      try {
        return Ve$1(e20, t2);
      } catch (e21) {
      }
    if (Ne$1(e20, t2))
      return oe$1(!se$1.f.call(e20, t2), e20[t2]);
  }}, Xe$1 = function(e20) {
    if (!De$1(e20))
      throw TypeError(String(e20) + " is not an object");
    return e20;
  }, ze$1 = Object.defineProperty, We$1 = {f: re$1 ? ze$1 : function(e20, t2, r2) {
    if (Xe$1(e20), t2 = Me$1(t2), Xe$1(r2), Ge$1)
      try {
        return ze$1(e20, t2, r2);
      } catch (e21) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e20[t2] = r2.value), e20;
  }}, Ye$1 = re$1 ? function(e20, t2, r2) {
    return We$1.f(e20, t2, oe$1(1, r2));
  } : function(e20, t2, r2) {
    return e20[t2] = r2, e20;
  }, Qe$1 = Function.toString;
  typeof Ae$1.inspectSource != "function" && (Ae$1.inspectSource = function(e20) {
    return Qe$1.call(e20);
  });
  var Je$1, Ke$1, Ze$1, et$1, tt$1 = Ae$1.inspectSource, rt$1 = ee$1.WeakMap, nt$1 = typeof rt$1 == "function" && /native code/.test(tt$1(rt$1)), it$1 = Fe$1("keys"), st$1 = {}, ot$1 = ee$1.WeakMap;
  if (nt$1 || Ae$1.state) {
    var at$1 = Ae$1.state || (Ae$1.state = new ot$1()), ut$1 = at$1.get, ct$1 = at$1.has, lt$1 = at$1.set;
    Je$1 = function(e20, t2) {
      if (ct$1.call(at$1, e20))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, lt$1.call(at$1, e20, t2), t2;
    }, Ke$1 = function(e20) {
      return ut$1.call(at$1, e20) || {};
    }, Ze$1 = function(e20) {
      return ct$1.call(at$1, e20);
    };
  } else {
    var pt$1 = it$1[et$1 = "state"] || (it$1[et$1] = Ie$1(et$1));
    st$1[pt$1] = true, Je$1 = function(e20, t2) {
      if (Ne$1(e20, pt$1))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, Ye$1(e20, pt$1, t2), t2;
    }, Ke$1 = function(e20) {
      return Ne$1(e20, pt$1) ? e20[pt$1] : {};
    }, Ze$1 = function(e20) {
      return Ne$1(e20, pt$1);
    };
  }
  var ht$1 = {set: Je$1, get: Ke$1, has: Ze$1, enforce: function(e20) {
    return Ze$1(e20) ? Ke$1(e20) : Je$1(e20, {});
  }, getterFor: function(e20) {
    return function(t2) {
      var r2;
      if (!De$1(t2) || (r2 = Ke$1(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return r2;
    };
  }}, Dt$1 = t$1(function(e20) {
    var t2 = ht$1.get, r2 = ht$1.enforce, n2 = String(String).split("String");
    (e20.exports = function(e21, t3, i2, s2) {
      var o2, a2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, c2 = !!s2 && !!s2.noTargetGet;
      typeof i2 == "function" && (typeof t3 != "string" || Ne$1(i2, "name") || Ye$1(i2, "name", t3), (o2 = r2(i2)).source || (o2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== ee$1 ? (a2 ? !c2 && e21[t3] && (u2 = true) : delete e21[t3], u2 ? e21[t3] = i2 : Ye$1(e21, t3, i2)) : u2 ? e21[t3] = i2 : ve$1(t3, i2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || tt$1(this);
    });
  }), ft$1 = Math.ceil, dt$1 = Math.floor, gt$1 = function(e20) {
    return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? dt$1 : ft$1)(e20);
  }, mt$1 = Math.min, Et$1 = function(e20) {
    return e20 > 0 ? mt$1(gt$1(e20), 9007199254740991) : 0;
  }, Ct$1 = Math.max, yt$1 = Math.min, bt$1 = function(e20) {
    return function(t2, r2, n2) {
      var i2, s2 = he$1(t2), o2 = Et$1(s2.length), a2 = function(e21, t3) {
        var r3 = gt$1(e21);
        return r3 < 0 ? Ct$1(r3 + t3, 0) : yt$1(r3, t3);
      }(n2, o2);
      if (e20 && r2 != r2) {
        for (; o2 > a2; )
          if ((i2 = s2[a2++]) != i2)
            return true;
      } else
        for (; o2 > a2; a2++)
          if ((e20 || a2 in s2) && s2[a2] === r2)
            return e20 || a2 || 0;
      return !e20 && -1;
    };
  }, St = {includes: bt$1(true), indexOf: bt$1(false)}.indexOf, Tt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), _t = {f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var r2, n2 = he$1(e21), i2 = 0, s2 = [];
      for (r2 in n2)
        !Ne$1(st$1, r2) && Ne$1(n2, r2) && s2.push(r2);
      for (; t2.length > i2; )
        Ne$1(n2, r2 = t2[i2++]) && (~St(s2, r2) || s2.push(r2));
      return s2;
    }(e20, Tt);
  }}, vt$1 = {f: Object.getOwnPropertySymbols}, At$1 = de$1("Reflect", "ownKeys") || function(e20) {
    var t2 = _t.f(Xe$1(e20)), r2 = vt$1.f;
    return r2 ? t2.concat(r2(e20)) : t2;
  }, Ft$1 = function(e20, t2) {
    for (var r2 = At$1(t2), n2 = We$1.f, i2 = He$1.f, s2 = 0; s2 < r2.length; s2++) {
      var o2 = r2[s2];
      Ne$1(e20, o2) || n2(e20, o2, i2(t2, o2));
    }
  }, wt$1 = /#|\.prototype\./, kt$1 = function(e20, t2) {
    var r2 = Ot$1[Nt(e20)];
    return r2 == It || r2 != xt$1 && (typeof t2 == "function" ? te$1(t2) : !!t2);
  }, Nt = kt$1.normalize = function(e20) {
    return String(e20).replace(wt$1, ".").toLowerCase();
  }, Ot$1 = kt$1.data = {}, xt$1 = kt$1.NATIVE = "N", It = kt$1.POLYFILL = "P", Pt = kt$1, Rt = He$1.f, Lt = function(e20, t2) {
    var r2, n2, i2, s2, o2, a2 = e20.target, u2 = e20.global, c2 = e20.stat;
    if (r2 = u2 ? ee$1 : c2 ? ee$1[a2] || ve$1(a2, {}) : (ee$1[a2] || {}).prototype)
      for (n2 in t2) {
        if (s2 = t2[n2], i2 = e20.noTargetGet ? (o2 = Rt(r2, n2)) && o2.value : r2[n2], !Pt(u2 ? n2 : a2 + (c2 ? "." : "#") + n2, e20.forced) && i2 !== void 0) {
          if (typeof s2 == typeof i2)
            continue;
          Ft$1(s2, i2);
        }
        (e20.sham || i2 && i2.sham) && Ye$1(s2, "sham", true), Dt$1(r2, n2, s2, e20);
      }
  }, Bt = Array.isArray || function(e20) {
    return ue$1(e20) == "Array";
  }, $t = function(e20) {
    if (typeof e20 != "function")
      throw TypeError(String(e20) + " is not a function");
    return e20;
  }, qt = function(e20, t2, r2) {
    if ($t(e20), t2 === void 0)
      return e20;
    switch (r2) {
      case 0:
        return function() {
          return e20.call(t2);
        };
      case 1:
        return function(r3) {
          return e20.call(t2, r3);
        };
      case 2:
        return function(r3, n2) {
          return e20.call(t2, r3, n2);
        };
      case 3:
        return function(r3, n2, i2) {
          return e20.call(t2, r3, n2, i2);
        };
    }
    return function() {
      return e20.apply(t2, arguments);
    };
  }, Mt = function(e20, t2, r2, n2, i2, s2, o2, a2) {
    for (var u2, c2 = i2, l2 = 0, p2 = !!o2 && qt(o2, a2, 3); l2 < n2; ) {
      if (l2 in r2) {
        if (u2 = p2 ? p2(r2[l2], l2, t2) : r2[l2], s2 > 0 && Bt(u2))
          c2 = Mt(e20, t2, u2, Et$1(u2.length), c2, s2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e20[c2] = u2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, jt = Mt, Ut = Be$1("species"), Gt = function(e20, t2) {
    return new (function(e21) {
      var t3;
      return Bt(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !Bt(t3.prototype) ? De$1(t3) && (t3 = t3[Ut]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e20))(t2 === 0 ? 0 : t2);
  };
  Lt({target: "Array", proto: true}, {flatMap: function(e20) {
    var t2, r2 = we$1(this), n2 = Et$1(r2.length);
    return $t(e20), (t2 = Gt(r2, 0)).length = jt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }});
  var Vt, Ht, Xt = function(e20) {
    if (_e$1$1(e20))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e20);
  }, zt = Math.floor, Wt = function(e20, t2) {
    var r2 = e20.length, n2 = zt(r2 / 2);
    return r2 < 8 ? Yt(e20, t2) : Qt(Wt(e20.slice(0, n2), t2), Wt(e20.slice(n2), t2), t2);
  }, Yt = function(e20, t2) {
    for (var r2, n2, i2 = e20.length, s2 = 1; s2 < i2; ) {
      for (n2 = s2, r2 = e20[s2]; n2 && t2(e20[n2 - 1], r2) > 0; )
        e20[n2] = e20[--n2];
      n2 !== s2++ && (e20[n2] = r2);
    }
    return e20;
  }, Qt = function(e20, t2, r2) {
    for (var n2 = e20.length, i2 = t2.length, s2 = 0, o2 = 0, a2 = []; s2 < n2 || o2 < i2; )
      s2 < n2 && o2 < i2 ? a2.push(r2(e20[s2], t2[o2]) <= 0 ? e20[s2++] : t2[o2++]) : a2.push(s2 < n2 ? e20[s2++] : t2[o2++]);
    return a2;
  }, Jt = Wt, Kt = ge$1.match(/firefox\/(\d+)/i), Zt = !!Kt && +Kt[1], er = /MSIE|Trident/.test(ge$1), tr = ge$1.match(/AppleWebKit\/(\d+)\./), rr = !!tr && +tr[1], nr = [], ir = nr.sort, sr = te$1(function() {
    nr.sort(void 0);
  }), or = te$1(function() {
    nr.sort(null);
  }), ar = !!(Ht = []["sort"]) && te$1(function() {
    Ht.call(null, Vt || function() {
      throw 1;
    }, 1);
  }), ur = !te$1(function() {
    if (be$1)
      return be$1 < 70;
    if (!(Zt && Zt > 3)) {
      if (er)
        return true;
      if (rr)
        return rr < 603;
      var e20, t2, r2, n2, i2 = "";
      for (e20 = 65; e20 < 76; e20++) {
        switch (t2 = String.fromCharCode(e20), e20) {
          case 66:
          case 69:
          case 70:
          case 72:
            r2 = 3;
            break;
          case 68:
          case 71:
            r2 = 4;
            break;
          default:
            r2 = 2;
        }
        for (n2 = 0; n2 < 47; n2++)
          nr.push({k: t2 + n2, v: r2});
      }
      for (nr.sort(function(e21, t3) {
        return t3.v - e21.v;
      }), n2 = 0; n2 < nr.length; n2++)
        t2 = nr[n2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
      return i2 !== "DGBEFHACIJK";
    }
  });
  Lt({target: "Array", proto: true, forced: sr || !or || !ar || !ur}, {sort: function(e20) {
    e20 !== void 0 && $t(e20);
    var t2 = we$1(this);
    if (ur)
      return e20 === void 0 ? ir.call(t2) : ir.call(t2, e20);
    var r2, n2, i2 = [], s2 = Et$1(t2.length);
    for (n2 = 0; n2 < s2; n2++)
      n2 in t2 && i2.push(t2[n2]);
    for (r2 = (i2 = Jt(i2, function(e21) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : Xt(t3) > Xt(r3) ? 1 : -1;
      };
    }(e20))).length, n2 = 0; n2 < r2; )
      t2[n2] = i2[n2++];
    for (; n2 < s2; )
      delete t2[n2++];
    return t2;
  }});
  var cr = {}, lr = Be$1("iterator"), pr = Array.prototype, hr = {};
  hr[Be$1("toStringTag")] = "z";
  var Dr = String(hr) === "[object z]", fr = Be$1("toStringTag"), dr = ue$1(function() {
    return arguments;
  }()) == "Arguments", gr = Dr ? ue$1 : function(e20) {
    var t2, r2, n2;
    return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
      try {
        return e21[t3];
      } catch (e22) {
      }
    }(t2 = Object(e20), fr)) == "string" ? r2 : dr ? ue$1(t2) : (n2 = ue$1(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
  }, mr = Be$1("iterator"), Er = function(e20) {
    if (e20 != null)
      return e20[mr] || e20["@@iterator"] || cr[gr(e20)];
  }, Cr = function(e20, t2, r2) {
    var n2, i2;
    Xe$1(e20);
    try {
      if ((n2 = e20.return) === void 0) {
        if (t2 === "throw")
          throw r2;
        return r2;
      }
      n2 = n2.call(e20);
    } catch (e21) {
      i2 = true, n2 = e21;
    }
    if (t2 === "throw")
      throw r2;
    if (i2)
      throw n2;
    return Xe$1(n2), r2;
  }, yr = function(e20, t2) {
    this.stopped = e20, this.result = t2;
  }, br = function(e20, t2, r2) {
    var n2, i2, s2, o2, a2, u2, c2, l2, p2 = r2 && r2.that, h2 = !(!r2 || !r2.AS_ENTRIES), D2 = !(!r2 || !r2.IS_ITERATOR), f2 = !(!r2 || !r2.INTERRUPTED), d2 = qt(t2, p2, 1 + h2 + f2), g2 = function(e21) {
      return n2 && Cr(n2, "normal", e21), new yr(true, e21);
    }, m2 = function(e21) {
      return h2 ? (Xe$1(e21), f2 ? d2(e21[0], e21[1], g2) : d2(e21[0], e21[1])) : f2 ? d2(e21, g2) : d2(e21);
    };
    if (D2)
      n2 = e20;
    else {
      if (typeof (i2 = Er(e20)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = i2) !== void 0 && (cr.Array === l2 || pr[lr] === l2)) {
        for (s2 = 0, o2 = Et$1(e20.length); o2 > s2; s2++)
          if ((a2 = m2(e20[s2])) && a2 instanceof yr)
            return a2;
        return new yr(false);
      }
      n2 = function(e21, t3) {
        var r3 = arguments.length < 2 ? Er(e21) : t3;
        if (typeof r3 != "function")
          throw TypeError(String(e21) + " is not iterable");
        return Xe$1(r3.call(e21));
      }(e20, i2);
    }
    for (u2 = n2.next; !(c2 = u2.call(n2)).done; ) {
      try {
        a2 = m2(c2.value);
      } catch (e21) {
        Cr(n2, "throw", e21);
      }
      if (typeof a2 == "object" && a2 && a2 instanceof yr)
        return a2;
    }
    return new yr(false);
  };
  Lt({target: "Object", stat: true}, {fromEntries: function(e20) {
    var t2 = {};
    return br(e20, function(e21, r2) {
      !function(e22, t3, r3) {
        var n2 = Me$1(t3);
        n2 in e22 ? We$1.f(e22, n2, oe$1(0, r3)) : e22[n2] = r3;
      }(t2, e21, r2);
    }, {AS_ENTRIES: true}), t2;
  }});
  var Sr = Sr !== void 0 ? Sr : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  function Tr() {
    throw new Error("setTimeout has not been defined");
  }
  function _r() {
    throw new Error("clearTimeout has not been defined");
  }
  var vr = Tr, Ar = _r;
  function Fr(e20) {
    if (vr === setTimeout)
      return setTimeout(e20, 0);
    if ((vr === Tr || !vr) && setTimeout)
      return vr = setTimeout, setTimeout(e20, 0);
    try {
      return vr(e20, 0);
    } catch (t2) {
      try {
        return vr.call(null, e20, 0);
      } catch (t3) {
        return vr.call(this, e20, 0);
      }
    }
  }
  typeof Sr.setTimeout == "function" && (vr = setTimeout), typeof Sr.clearTimeout == "function" && (Ar = clearTimeout);
  var wr, kr = [], Nr = false, Or = -1;
  function xr() {
    Nr && wr && (Nr = false, wr.length ? kr = wr.concat(kr) : Or = -1, kr.length && Ir());
  }
  function Ir() {
    if (!Nr) {
      var e20 = Fr(xr);
      Nr = true;
      for (var t2 = kr.length; t2; ) {
        for (wr = kr, kr = []; ++Or < t2; )
          wr && wr[Or].run();
        Or = -1, t2 = kr.length;
      }
      wr = null, Nr = false, function(e21) {
        if (Ar === clearTimeout)
          return clearTimeout(e21);
        if ((Ar === _r || !Ar) && clearTimeout)
          return Ar = clearTimeout, clearTimeout(e21);
        try {
          Ar(e21);
        } catch (t3) {
          try {
            return Ar.call(null, e21);
          } catch (t4) {
            return Ar.call(this, e21);
          }
        }
      }(e20);
    }
  }
  function Pr(e20, t2) {
    this.fun = e20, this.array = t2;
  }
  Pr.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function Rr() {
  }
  var Lr = Rr, Br = Rr, $r = Rr, qr = Rr, Mr = Rr, jr = Rr, Ur = Rr;
  var Gr = Sr.performance || {}, Vr = Gr.now || Gr.mozNow || Gr.msNow || Gr.oNow || Gr.webkitNow || function() {
    return new Date().getTime();
  };
  var Hr = new Date();
  var Xr = {nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r2 = 1; r2 < arguments.length; r2++)
        t2[r2 - 1] = arguments[r2];
    kr.push(new Pr(e20, t2)), kr.length !== 1 || Nr || Fr(Ir);
  }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Lr, addListener: Br, once: $r, off: qr, removeListener: Mr, removeAllListeners: jr, emit: Ur, binding: function(e20) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e20) {
    var t2 = 1e-3 * Vr.call(Gr), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (r2 -= e20[0], (n2 -= e20[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (new Date() - Hr) / 1e3;
  }};
  var zr = typeof Xr == "object" && Xr.env && Xr.env.NODE_DEBUG && /\bsemver\b/i.test(Xr.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
  };
  var Wr = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, Yr = t$1(function(e20, t2) {
    const {MAX_SAFE_COMPONENT_LENGTH: r2} = Wr, n2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], s2 = t2.t = {};
    let o2 = 0;
    const a2 = (e21, t3, r3) => {
      const a3 = o2++;
      zr(a3, t3), s2[e21] = a3, i2[a3] = t3, n2[a3] = new RegExp(t3, r3 ? "g" : void 0);
    };
    a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", `(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})`), a2("MAINVERSIONLOOSE", `(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})`), a2("PRERELEASEIDENTIFIER", `(?:${i2[s2.NUMERICIDENTIFIER]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[s2.NUMERICIDENTIFIERLOOSE]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASE", `(?:-(${i2[s2.PRERELEASEIDENTIFIER]}(?:\\.${i2[s2.PRERELEASEIDENTIFIER]})*))`), a2("PRERELEASELOOSE", `(?:-?(${i2[s2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[s2.PRERELEASEIDENTIFIERLOOSE]})*))`), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", `(?:\\+(${i2[s2.BUILDIDENTIFIER]}(?:\\.${i2[s2.BUILDIDENTIFIER]})*))`), a2("FULLPLAIN", `v?${i2[s2.MAINVERSION]}${i2[s2.PRERELEASE]}?${i2[s2.BUILD]}?`), a2("FULL", `^${i2[s2.FULLPLAIN]}$`), a2("LOOSEPLAIN", `[v=\\s]*${i2[s2.MAINVERSIONLOOSE]}${i2[s2.PRERELEASELOOSE]}?${i2[s2.BUILD]}?`), a2("LOOSE", `^${i2[s2.LOOSEPLAIN]}$`), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", `${i2[s2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a2("XRANGEIDENTIFIER", `${i2[s2.NUMERICIDENTIFIER]}|x|X|\\*`), a2("XRANGEPLAIN", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:${i2[s2.PRERELEASE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:${i2[s2.PRERELEASELOOSE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAIN]}$`), a2("XRANGELOOSE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COERCE", `(^|[^\\d])(\\d{1,${r2}})(?:\\.(\\d{1,${r2}}))?(?:\\.(\\d{1,${r2}}))?(?:$|[^\\d])`), a2("COERCERTL", i2[s2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", `(\\s*)${i2[s2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", a2("TILDE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAIN]}$`), a2("TILDELOOSE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", `(\\s*)${i2[s2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", a2("CARET", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAIN]}$`), a2("CARETLOOSE", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COMPARATORLOOSE", `^${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]})$|^$`), a2("COMPARATOR", `^${i2[s2.GTLT]}\\s*(${i2[s2.FULLPLAIN]})$|^$`), a2("COMPARATORTRIM", `(\\s*)${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]}|${i2[s2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", `^\\s*(${i2[s2.XRANGEPLAIN]})\\s+-\\s+(${i2[s2.XRANGEPLAIN]})\\s*$`), a2("HYPHENRANGELOOSE", `^\\s*(${i2[s2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[s2.XRANGEPLAINLOOSE]})\\s*$`), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  const Qr = ["includePrerelease", "loose", "rtl"];
  var Jr = (e20) => e20 ? typeof e20 != "object" ? {loose: true} : Qr.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
  const Kr = /^[0-9]+$/, Zr = (e20, t2) => {
    const r2 = Kr.test(e20), n2 = Kr.test(t2);
    return r2 && n2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e20 < t2 ? -1 : 1;
  };
  var en = {compareIdentifiers: Zr, rcompareIdentifiers: (e20, t2) => Zr(t2, e20)};
  const {MAX_LENGTH: tn, MAX_SAFE_INTEGER: rn} = Wr, {re: nn, t: sn} = Yr, {compareIdentifiers: on} = en;
  class an {
    constructor(e20, t2) {
      if (t2 = Jr(t2), e20 instanceof an) {
        if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
          return e20;
        e20 = e20.version;
      } else if (typeof e20 != "string")
        throw new TypeError(`Invalid Version: ${e20}`);
      if (e20.length > tn)
        throw new TypeError(`version is longer than ${tn} characters`);
      zr("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
      const r2 = e20.trim().match(t2.loose ? nn[sn.LOOSE] : nn[sn.FULL]);
      if (!r2)
        throw new TypeError(`Invalid Version: ${e20}`);
      if (this.raw = e20, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > rn || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > rn || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > rn || this.patch < 0)
        throw new TypeError("Invalid patch version");
      r2[4] ? this.prerelease = r2[4].split(".").map((e21) => {
        if (/^[0-9]+$/.test(e21)) {
          const t3 = +e21;
          if (t3 >= 0 && t3 < rn)
            return t3;
        }
        return e21;
      }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e20) {
      if (zr("SemVer.compare", this.version, this.options, e20), !(e20 instanceof an)) {
        if (typeof e20 == "string" && e20 === this.version)
          return 0;
        e20 = new an(e20, this.options);
      }
      return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
    }
    compareMain(e20) {
      return e20 instanceof an || (e20 = new an(e20, this.options)), on(this.major, e20.major) || on(this.minor, e20.minor) || on(this.patch, e20.patch);
    }
    comparePre(e20) {
      if (e20 instanceof an || (e20 = new an(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
        return -1;
      if (!this.prerelease.length && e20.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e20.prerelease.length)
        return 0;
      let t2 = 0;
      do {
        const r2 = this.prerelease[t2], n2 = e20.prerelease[t2];
        if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
          return 0;
        if (n2 === void 0)
          return 1;
        if (r2 === void 0)
          return -1;
        if (r2 !== n2)
          return on(r2, n2);
      } while (++t2);
    }
    compareBuild(e20) {
      e20 instanceof an || (e20 = new an(e20, this.options));
      let t2 = 0;
      do {
        const r2 = this.build[t2], n2 = e20.build[t2];
        if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
          return 0;
        if (n2 === void 0)
          return 1;
        if (r2 === void 0)
          return -1;
        if (r2 !== n2)
          return on(r2, n2);
      } while (++t2);
    }
    inc(e20, t2) {
      switch (e20) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let e21 = this.prerelease.length;
            for (; --e21 >= 0; )
              typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
            e21 === -1 && this.prerelease.push(0);
          }
          t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e20}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  var un = an;
  var cn = (e20, t2, r2) => new un(e20, r2).compare(new un(t2, r2));
  var ln = (e20, t2, r2) => cn(e20, t2, r2) < 0;
  var pn = (e20, t2, r2) => cn(e20, t2, r2) >= 0, hn = t$1(function(e20, t2) {
    function r2() {
      for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
        e21[t3] = arguments[t3];
    }
    function n2() {
      return typeof WeakMap != "undefined" ? new WeakMap() : {add: r2, delete: r2, get: r2, set: r2, has: function(e21) {
        return false;
      }};
    }
    Object.defineProperty(t2, "__esModule", {value: true}), t2.outdent = void 0;
    var i2 = Object.prototype.hasOwnProperty, s2 = function(e21, t3) {
      return i2.call(e21, t3);
    };
    function o2(e21, t3) {
      for (var r3 in t3)
        s2(t3, r3) && (e21[r3] = t3[r3]);
      return e21;
    }
    var a2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function h2(e21, t3, r3) {
      var n3 = 0, i3 = e21[0].match(l2);
      i3 && (n3 = i3[1].length);
      var s3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
      t3 && (e21 = e21.slice(1));
      var o3 = r3.newline, c3 = r3.trimLeadingNewline, p3 = r3.trimTrailingNewline, h3 = typeof o3 == "string", D3 = e21.length;
      return e21.map(function(e22, t4) {
        return e22 = e22.replace(s3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(a2, "")), t4 === D3 - 1 && p3 && (e22 = e22.replace(u2, "")), h3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
          return o3;
        })), e22;
      });
    }
    function D2(e21, t3) {
      for (var r3 = "", n3 = 0, i3 = e21.length; n3 < i3; n3++)
        r3 += e21[n3], n3 < i3 - 1 && (r3 += t3[n3]);
      return r3;
    }
    function f2(e21) {
      return s2(e21, "raw") && s2(e21, "length");
    }
    var d2 = function e21(t3) {
      var r3 = n2(), i3 = n2();
      return o2(function n3(s3) {
        for (var a3 = [], u3 = 1; u3 < arguments.length; u3++)
          a3[u3 - 1] = arguments[u3];
        if (f2(s3)) {
          var l3 = s3, g2 = (a3[0] === n3 || a3[0] === d2) && p2.test(l3[0]) && c2.test(l3[1]), m2 = g2 ? i3 : r3, E2 = m2.get(l3);
          if (E2 || (E2 = h2(l3, g2, t3), m2.set(l3, E2)), a3.length === 0)
            return E2[0];
          var C2 = D2(E2, g2 ? a3.slice(1) : a3);
          return C2;
        }
        return e21(o2(o2({}, t3), s3 || {}));
      }, {string: function(e22) {
        return h2([e22], false, t3)[0];
      }});
    }({trimLeadingNewline: true, trimTrailingNewline: true});
    t2.outdent = d2, t2.default = d2;
    try {
      e20.exports = d2, Object.defineProperty(d2, "__esModule", {value: true}), d2.default = d2, d2.outdent = d2;
    } catch (e21) {
    }
  });
  const {outdent: Dn} = hn, fn$3 = {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Dn`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e20) => typeof e20 == "string" || typeof e20 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Dn`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e20) => typeof e20 == "string" || typeof e20 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: Dn`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Dn`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
  const dn = ["cliName", "cliCategory", "cliDescription"], gn = {compare: cn, lt: ln, gte: pn}, mn = "2.4.1", En = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: fn$3}.options;
  var Cn = {getSupportInfo: function({plugins: e20 = [], showUnreleased: t2 = false, showDeprecated: r2 = false, showInternal: n2 = false} = {}) {
    const i2 = mn.split("-", 1)[0], s2 = e20.flatMap((e21) => e21.languages || []).filter(a2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, r3]) => Object.assign({[t3]: e22}, r3)))(Object.assign({}, ...e20.map(({options: e21}) => e21), En), "name").filter((e21) => a2(e21) && u2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (n2)
        return e21;
      return Q$1(e21, dn);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(a2).sort((e21, t4) => gn.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => a2(e21) && u2(e21)), t3.name === "parser" && function(e21, t4, r4) {
        const n3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!n3.has(t5)) {
                n3.add(t5);
                const s3 = r4.find((e22) => e22.parsers && e22.parsers[t5]);
                let o3 = i3.name;
                s3 && s3.name && (o3 += ` (plugin: ${s3.name})`), e21.choices.push({value: t5, description: o3});
              }
          }
      }(t3, s2, e20));
      const r3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, {pluginDefaults: r3});
    });
    return {languages: s2, options: o2};
    function a2(e21) {
      return t2 || !("since" in e21) || e21.since && gn.gte(i2, e21.since);
    }
    function u2(e21) {
      return r2 || !("deprecated" in e21) || e21.deprecated && gn.lt(i2, e21.deprecated);
    }
  }};
  const {getSupportInfo: yn} = Cn, bn = /[^\x20-\x7F]/;
  function Sn(e20) {
    return (t2, r2, n2) => {
      const i2 = n2 && n2.backwards;
      if (r2 === false)
        return false;
      const {length: s2} = t2;
      let o2 = r2;
      for (; o2 >= 0 && o2 < s2; ) {
        const r3 = t2.charAt(o2);
        if (e20 instanceof RegExp) {
          if (!e20.test(r3))
            return o2;
        } else if (!e20.includes(r3))
          return o2;
        i2 ? o2-- : o2++;
      }
      return (o2 === -1 || o2 === s2) && o2;
    };
  }
  const Tn = Sn(/\s/), _n = Sn(" 	"), vn = Sn(",; 	"), An = Sn(/[^\n\r]/);
  function Fn(e20, t2) {
    if (t2 === false)
      return false;
    if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
      for (let r2 = t2 + 2; r2 < e20.length; ++r2)
        if (e20.charAt(r2) === "*" && e20.charAt(r2 + 1) === "/")
          return r2 + 2;
    }
    return t2;
  }
  function wn(e20, t2) {
    return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? An(e20, t2) : t2);
  }
  function kn(e20, t2, r2) {
    const n2 = r2 && r2.backwards;
    if (t2 === false)
      return false;
    const i2 = e20.charAt(t2);
    if (n2) {
      if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
        return t2 - 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 - 1;
    } else {
      if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
        return t2 + 2;
      if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return t2 + 1;
    }
    return t2;
  }
  function Nn(e20, t2, r2 = {}) {
    const n2 = _n(e20, r2.backwards ? t2 - 1 : t2, r2);
    return n2 !== kn(e20, n2, r2);
  }
  function On(e20, t2) {
    let r2 = null, n2 = t2;
    for (; n2 !== r2; )
      r2 = n2, n2 = vn(e20, n2), n2 = Fn(e20, n2), n2 = _n(e20, n2);
    return n2 = wn(e20, n2), n2 = kn(e20, n2), n2 !== false && Nn(e20, n2);
  }
  function xn(e20, t2) {
    let r2 = null, n2 = t2;
    for (; n2 !== r2; )
      r2 = n2, n2 = _n(e20, n2), n2 = Fn(e20, n2), n2 = wn(e20, n2), n2 = kn(e20, n2);
    return n2;
  }
  function In(e20, t2, r2) {
    return xn(e20, r2(t2));
  }
  function Pn(e20, t2, r2 = 0) {
    let n2 = 0;
    for (let i2 = r2; i2 < e20.length; ++i2)
      e20[i2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
    return n2;
  }
  function Rn(e20, t2) {
    const r2 = e20.slice(1, -1), n2 = {quote: '"', regex: /"/g}, i2 = {quote: "'", regex: /'/g}, s2 = t2 === "'" ? i2 : n2, o2 = s2 === i2 ? n2 : i2;
    let a2 = s2.quote;
    if (r2.includes(s2.quote) || r2.includes(o2.quote)) {
      a2 = (r2.match(s2.regex) || []).length > (r2.match(o2.regex) || []).length ? o2.quote : s2.quote;
    }
    return a2;
  }
  function Ln(e20, t2, r2) {
    const n2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, s2) => i3 === n2 ? i3 : s2 === t2 ? "\\" + s2 : s2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
    return t2 + i2 + t2;
  }
  function Bn(e20, t2) {
    (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
      const t3 = e21.type || e21.kind || "(unknown type)";
      let r2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
      r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
      return t3 + (r2 ? " " + r2 : "");
    }(e20);
  }
  var $n = {inferParserByLanguage: function(e20, t2) {
    const {languages: r2} = yn({plugins: t2.plugins}), n2 = r2.find(({name: t3}) => t3.toLowerCase() === e20) || r2.find(({aliases: t3}) => Array.isArray(t3) && t3.includes(e20)) || r2.find(({extensions: t3}) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return n2 && n2.parsers[0];
  }, getStringWidth: function(e20) {
    return e20 ? bn.test(e20) ? z$1(e20) : e20.length : 0;
  }, getMaxContinuousCount: function(e20, t2) {
    const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    return r2 === null ? 0 : r2.reduce((e21, r3) => Math.max(e21, r3.length / t2.length), 0);
  }, getMinNotPresentContinuousCount: function(e20, t2) {
    const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    if (r2 === null)
      return 0;
    const n2 = new Map();
    let i2 = 0;
    for (const e21 of r2) {
      const r3 = e21.length / t2.length;
      n2.set(r3, true), r3 > i2 && (i2 = r3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!n2.get(e21))
        return e21;
    return i2 + 1;
  }, getPenultimate: (e20) => e20[e20.length - 2], getLast: M$1, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: xn, getNextNonSpaceNonCommentCharacterIndex: In, getNextNonSpaceNonCommentCharacter: function(e20, t2, r2) {
    return e20.charAt(In(e20, t2, r2));
  }, skip: Sn, skipWhitespace: Tn, skipSpaces: _n, skipToLineEnd: vn, skipEverythingButNewLine: An, skipInlineComment: Fn, skipTrailingComment: wn, skipNewline: kn, isNextLineEmptyAfterIndex: On, isNextLineEmpty: function(e20, t2, r2) {
    return On(e20, r2(t2));
  }, isPreviousLineEmpty: function(e20, t2, r2) {
    let n2 = r2(t2) - 1;
    return n2 = _n(e20, n2, {backwards: true}), n2 = kn(e20, n2, {backwards: true}), n2 = _n(e20, n2, {backwards: true}), n2 !== kn(e20, n2, {backwards: true});
  }, hasNewline: Nn, hasNewlineInRange: function(e20, t2, r2) {
    for (let n2 = t2; n2 < r2; ++n2)
      if (e20.charAt(n2) === "\n")
        return true;
    return false;
  }, hasSpaces: function(e20, t2, r2 = {}) {
    return _n(e20, r2.backwards ? t2 - 1 : t2, r2) !== t2;
  }, getAlignmentSize: Pn, getIndentSize: function(e20, t2) {
    const r2 = e20.lastIndexOf("\n");
    return r2 === -1 ? 0 : Pn(e20.slice(r2 + 1).match(/^[\t ]*/)[0], t2);
  }, getPreferredQuote: Rn, printString: function(e20, t2) {
    return Ln(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Rn(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  }, printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }, makeString: Ln, addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, Bn(e20, t2);
  }, addDanglingComment: function(e20, t2, r2) {
    t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Bn(e20, t2);
  }, addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, Bn(e20, t2);
  }, isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  }, getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  }, isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  }, createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(r2) {
      return t2.has(r2) || t2.set(r2, Symbol(e20)), t2.get(r2);
    };
  }}, qn = {"*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"]};
  function Mn(e20) {
    return {type: "concat", parts: e20};
  }
  function jn(e20) {
    return {type: "indent", contents: e20};
  }
  function Un(e20, t2) {
    return {type: "align", contents: t2, n: e20};
  }
  function Gn(e20, t2 = {}) {
    return {type: "group", id: t2.id, contents: e20, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates};
  }
  const Vn = {type: "break-parent"}, Hn = {type: "line", hard: true}, Xn = {type: "line", hard: true, literal: true}, zn = Mn([Hn, Vn]), Wn = Mn([Xn, Vn]);
  var Yn = {concat: Mn, join: function(e20, t2) {
    const r2 = [];
    for (let n2 = 0; n2 < t2.length; n2++)
      n2 !== 0 && r2.push(e20), r2.push(t2[n2]);
    return Mn(r2);
  }, line: {type: "line"}, softline: {type: "line", soft: true}, hardline: zn, literalline: Wn, group: Gn, conditionalGroup: function(e20, t2) {
    return Gn(e20[0], Object.assign(Object.assign({}, t2), {}, {expandedStates: e20}));
  }, fill: function(e20) {
    return {type: "fill", parts: e20};
  }, lineSuffix: function(e20) {
    return {type: "line-suffix", contents: e20};
  }, lineSuffixBoundary: {type: "line-suffix-boundary"}, cursor: {type: "cursor", placeholder: Symbol("cursor")}, breakParent: Vn, ifBreak: function(e20, t2, r2 = {}) {
    return {type: "if-break", breakContents: e20, flatContents: t2, groupId: r2.groupId};
  }, trim: {type: "trim"}, indent: jn, indentIfBreak: function(e20, t2) {
    return {type: "indent-if-break", contents: e20, groupId: t2.groupId, negate: t2.negate};
  }, align: Un, addAlignmentToDoc: function(e20, t2, r2) {
    let n2 = e20;
    if (t2 > 0) {
      for (let e21 = 0; e21 < Math.floor(t2 / r2); ++e21)
        n2 = jn(n2);
      n2 = Un(t2 % r2, n2), n2 = Un(Number.NEGATIVE_INFINITY, n2);
    }
    return n2;
  }, markAsRoot: function(e20) {
    return Un({type: "root"}, e20);
  }, dedentToRoot: function(e20) {
    return Un(Number.NEGATIVE_INFINITY, e20);
  }, dedent: function(e20) {
    return Un(-1, e20);
  }, hardlineWithoutBreakParent: Hn, literallineWithoutBreakParent: Xn, label: function(e20, t2) {
    return {type: "label", label: e20, contents: t2};
  }};
  var Qn = {guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  }, convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }, countEndOfLineChars: function(e20, t2) {
    let r2;
    if (t2 === "\n")
      r2 = /\n/g;
    else if (t2 === "\r")
      r2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      r2 = /\r\n/g;
    }
    const n2 = e20.match(r2);
    return n2 ? n2.length : 0;
  }, normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }};
  const {literalline: Jn, join: Kn} = Yn, Zn = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", ei = (e20) => {
    if (Array.isArray(e20))
      return e20;
    if (e20.type !== "concat" && e20.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return e20.parts;
  }, ti = {};
  function ri(e20, t2, r2, n2) {
    const i2 = [e20];
    for (; i2.length > 0; ) {
      const e21 = i2.pop();
      if (e21 !== ti) {
        if (r2 && i2.push(e21, ti), !t2 || t2(e21) !== false)
          if (Zn(e21) || e21.type === "fill") {
            const t3 = ei(e21);
            for (let e22 = t3.length - 1; e22 >= 0; --e22)
              i2.push(t3[e22]);
          } else if (e21.type === "if-break")
            e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
          else if (e21.type === "group" && e21.expandedStates)
            if (n2)
              for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
                i2.push(e21.expandedStates[t3]);
            else
              i2.push(e21.contents);
          else
            e21.contents && i2.push(e21.contents);
      } else
        r2(i2.pop());
    }
  }
  function ni(e20, t2) {
    const r2 = new Map();
    return n2(e20);
    function n2(e21) {
      if (r2.has(e21))
        return r2.get(e21);
      const i2 = function(e22) {
        if (Array.isArray(e22))
          return t2(e22.map(n2));
        if (e22.type === "concat" || e22.type === "fill") {
          const r3 = e22.parts.map(n2);
          return t2(Object.assign(Object.assign({}, e22), {}, {parts: r3}));
        }
        if (e22.type === "if-break") {
          const r3 = e22.breakContents && n2(e22.breakContents), i3 = e22.flatContents && n2(e22.flatContents);
          return t2(Object.assign(Object.assign({}, e22), {}, {breakContents: r3, flatContents: i3}));
        }
        if (e22.type === "group" && e22.expandedStates) {
          const r3 = e22.expandedStates.map(n2), i3 = r3[0];
          return t2(Object.assign(Object.assign({}, e22), {}, {contents: i3, expandedStates: r3}));
        }
        if (e22.contents) {
          const r3 = n2(e22.contents);
          return t2(Object.assign(Object.assign({}, e22), {}, {contents: r3}));
        }
        return t2(e22);
      }(e21);
      return r2.set(e21, i2), i2;
    }
  }
  function ii(e20, t2, r2) {
    let n2 = r2, i2 = false;
    return ri(e20, function(e21) {
      const r3 = t2(e21);
      if (r3 !== void 0 && (i2 = true, n2 = r3), i2)
        return false;
    }), n2;
  }
  function si(e20) {
    return !(e20.type !== "group" || !e20.break) || (!(e20.type !== "line" || !e20.hard) || (e20.type === "break-parent" || void 0));
  }
  function oi(e20) {
    if (e20.length > 0) {
      const t2 = M$1(e20);
      t2.expandedStates || t2.break || (t2.break = "propagated");
    }
    return null;
  }
  function ai(e20) {
    return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
  }
  const ui = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
  function ci(e20) {
    if (!e20)
      return e20;
    if (Zn(e20) || e20.type === "fill") {
      const t2 = ei(e20);
      for (; t2.length > 1 && ui(...t2.slice(-2)); )
        t2.length -= 2;
      if (t2.length > 0) {
        const e21 = ci(M$1(t2));
        t2[t2.length - 1] = e21;
      }
      return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, {parts: t2});
    }
    switch (e20.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        const t2 = ci(e20.contents);
        return Object.assign(Object.assign({}, e20), {}, {contents: t2});
      }
      case "if-break": {
        const t2 = ci(e20.breakContents), r2 = ci(e20.flatContents);
        return Object.assign(Object.assign({}, e20), {}, {breakContents: t2, flatContents: r2});
      }
    }
    return e20;
  }
  function li(e20) {
    return ni(e20, (e21) => function(e22) {
      switch (e22.type) {
        case "fill":
          if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
            return "";
          break;
        case "group":
          if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
            return "";
          if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
            return e22.contents;
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!e22.contents)
            return "";
          break;
        case "if-break":
          if (!e22.flatContents && !e22.breakContents)
            return "";
      }
      if (!Zn(e22))
        return e22;
      const t2 = [];
      for (const r2 of ei(e22)) {
        if (!r2)
          continue;
        const [e23, ...n2] = Zn(r2) ? ei(r2) : [r2];
        typeof e23 == "string" && typeof M$1(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...n2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, {parts: t2});
    }(e21));
  }
  function pi(e20) {
    const t2 = [], r2 = e20.filter(Boolean);
    for (; r2.length > 0; ) {
      const e21 = r2.shift();
      e21 && (Zn(e21) ? r2.unshift(...ei(e21)) : t2.length > 0 && typeof M$1(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
    }
    return t2;
  }
  function hi(e20, t2 = Jn) {
    return Kn(t2, e20.split("\n")).parts;
  }
  var Di = {isConcat: Zn, getDocParts: ei, willBreak: function(e20) {
    return ii(e20, si, false);
  }, traverseDoc: ri, findInDoc: ii, mapDoc: ni, propagateBreaks: function(e20) {
    const t2 = new Set(), r2 = [];
    ri(e20, function(e21) {
      if (e21.type === "break-parent" && oi(r2), e21.type === "group") {
        if (r2.push(e21), t2.has(e21))
          return false;
        t2.add(e21);
      }
    }, function(e21) {
      if (e21.type === "group") {
        r2.pop().break && oi(r2);
      }
    }, true);
  }, removeLines: function(e20) {
    return ni(e20, ai);
  }, stripTrailingHardline: function(e20) {
    return ci(li(e20));
  }, normalizeParts: pi, normalizeDoc: function(e20) {
    return ni(e20, (e21) => Array.isArray(e21) ? pi(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, {parts: pi(e21.parts)}) : e21);
  }, cleanDoc: li, replaceTextEndOfLine: hi, replaceEndOfLine: function(e20) {
    return ni(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? hi(e21) : e21);
  }};
  const {getStringWidth: fi, getLast: di} = $n, {convertEndOfLineToChars: gi} = Qn, {fill: mi, cursor: Ei, indent: Ci} = Yn, {isConcat: yi, getDocParts: bi} = Di;
  let Si;
  function Ti(e20, t2) {
    return vi(e20, {type: "indent"}, t2);
  }
  function _i(e20, t2, r2) {
    if (t2 === Number.NEGATIVE_INFINITY)
      return e20.root || {value: "", length: 0, queue: []};
    if (t2 < 0)
      return vi(e20, {type: "dedent"}, r2);
    if (!t2)
      return e20;
    if (t2.type === "root")
      return Object.assign(Object.assign({}, e20), {}, {root: e20});
    return vi(e20, {type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2}, r2);
  }
  function vi(e20, t2, r2) {
    const n2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
    let i2 = "", s2 = 0, o2 = 0, a2 = 0;
    for (const e21 of n2)
      switch (e21.type) {
        case "indent":
          l2(), r2.useTabs ? u2(1) : c2(r2.tabWidth);
          break;
        case "stringAlign":
          l2(), i2 += e21.n, s2 += e21.n.length;
          break;
        case "numberAlign":
          o2 += 1, a2 += e21.n;
          break;
        default:
          throw new Error(`Unexpected type '${e21.type}'`);
      }
    return p2(), Object.assign(Object.assign({}, e20), {}, {value: i2, length: s2, queue: n2});
    function u2(e21) {
      i2 += "	".repeat(e21), s2 += r2.tabWidth * e21;
    }
    function c2(e21) {
      i2 += " ".repeat(e21), s2 += e21;
    }
    function l2() {
      r2.useTabs ? function() {
        o2 > 0 && u2(o2);
        h2();
      }() : p2();
    }
    function p2() {
      a2 > 0 && c2(a2), h2();
    }
    function h2() {
      o2 = 0, a2 = 0;
    }
  }
  function Ai(e20) {
    if (e20.length === 0)
      return 0;
    let t2 = 0;
    for (; e20.length > 0 && typeof di(e20) == "string" && /^[\t ]*$/.test(di(e20)); )
      t2 += e20.pop().length;
    if (e20.length > 0 && typeof di(e20) == "string") {
      const r2 = di(e20).replace(/[\t ]*$/, "");
      t2 += di(e20).length - r2.length, e20[e20.length - 1] = r2;
    }
    return t2;
  }
  function Fi(e20, t2, r2, n2, i2, s2) {
    let o2 = t2.length;
    const a2 = [e20], u2 = [];
    for (; r2 >= 0; ) {
      if (a2.length === 0) {
        if (o2 === 0)
          return true;
        a2.push(t2[o2 - 1]), o2--;
        continue;
      }
      const [e21, c2, l2] = a2.pop();
      if (typeof l2 == "string")
        u2.push(l2), r2 -= fi(l2);
      else if (yi(l2)) {
        const t3 = bi(l2);
        for (let r3 = t3.length - 1; r3 >= 0; r3--)
          a2.push([e21, c2, t3[r3]]);
      } else
        switch (l2.type) {
          case "indent":
            a2.push([Ti(e21, n2), c2, l2.contents]);
            break;
          case "align":
            a2.push([_i(e21, l2.n, n2), c2, l2.contents]);
            break;
          case "trim":
            r2 += Ai(u2);
            break;
          case "group": {
            if (s2 && l2.break)
              return false;
            const t3 = l2.break ? 1 : c2;
            a2.push([e21, t3, l2.expandedStates && t3 === 1 ? di(l2.expandedStates) : l2.contents]), l2.id && (Si[l2.id] = t3);
            break;
          }
          case "fill":
            for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
              a2.push([e21, c2, l2.parts[t3]]);
            break;
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Si[l2.groupId] : c2;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
              t4 && a2.push([e21, c2, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
              t4 && a2.push([e21, c2, t4]);
            }
            break;
          }
          case "line":
            switch (c2) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (u2.push(" "), r2 -= 1);
                  break;
                }
                return true;
              case 1:
                return true;
            }
            break;
          case "line-suffix":
            i2 = true;
            break;
          case "line-suffix-boundary":
            if (i2)
              return false;
            break;
          case "label":
            a2.push([e21, c2, l2.contents]);
        }
    }
    return false;
  }
  var wi = {printDocToString: function(e20, t2) {
    Si = {};
    const r2 = t2.printWidth, n2 = gi(t2.endOfLine);
    let i2 = 0;
    const s2 = [[{value: "", length: 0, queue: []}, 1, e20]], o2 = [];
    let a2 = false, u2 = [];
    for (; s2.length > 0; ) {
      const [e21, c3, l2] = s2.pop();
      if (typeof l2 == "string") {
        const e22 = n2 !== "\n" ? l2.replace(/\n/g, n2) : l2;
        o2.push(e22), i2 += fi(e22);
      } else if (yi(l2)) {
        const t3 = bi(l2);
        for (let r3 = t3.length - 1; r3 >= 0; r3--)
          s2.push([e21, c3, t3[r3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push(Ei.placeholder);
            break;
          case "indent":
            s2.push([Ti(e21, t2), c3, l2.contents]);
            break;
          case "align":
            s2.push([_i(e21, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ai(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!a2) {
                  s2.push([e21, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                a2 = false;
                const n3 = [e21, 2, l2.contents], o3 = r2 - i2, c4 = u2.length > 0;
                if (!l2.break && Fi(n3, s2, o3, t2, c4))
                  s2.push(n3);
                else if (l2.expandedStates) {
                  const r3 = di(l2.expandedStates);
                  if (l2.break) {
                    s2.push([e21, 1, r3]);
                    break;
                  }
                  for (let n4 = 1; n4 < l2.expandedStates.length + 1; n4++) {
                    if (n4 >= l2.expandedStates.length) {
                      s2.push([e21, 1, r3]);
                      break;
                    }
                    {
                      const r4 = [e21, 2, l2.expandedStates[n4]];
                      if (Fi(r4, s2, o3, t2, c4)) {
                        s2.push(r4);
                        break;
                      }
                    }
                  }
                } else
                  s2.push([e21, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Si[l2.id] = di(s2)[1]);
            break;
          case "fill": {
            const n3 = r2 - i2, {parts: o3} = l2;
            if (o3.length === 0)
              break;
            const [a3, p2] = o3, h2 = [e21, 2, a3], D2 = [e21, 1, a3], f2 = Fi(h2, [], n3, t2, u2.length > 0, true);
            if (o3.length === 1) {
              f2 ? s2.push(h2) : s2.push(D2);
              break;
            }
            const d2 = [e21, 2, p2], g2 = [e21, 1, p2];
            if (o3.length === 2) {
              f2 ? s2.push(d2, h2) : s2.push(g2, D2);
              break;
            }
            o3.splice(0, 2);
            const m2 = [e21, c3, mi(o3)];
            Fi([e21, 2, [a3, p2, o3[0]]], [], n3, t2, u2.length > 0, true) ? s2.push(m2, d2, h2) : f2 ? s2.push(m2, g2, h2) : s2.push(m2, g2, D2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Si[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
              t4 && s2.push([e21, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
              t4 && s2.push([e21, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            u2.push([e21, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            u2.length > 0 && s2.push([e21, c3, {type: "line", hard: true}]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                a2 = true;
              case 1:
                if (u2.length > 0) {
                  s2.push([e21, c3, l2], ...u2.reverse()), u2 = [];
                  break;
                }
                l2.literal ? e21.root ? (o2.push(n2, e21.root.value), i2 = e21.root.length) : (o2.push(n2), i2 = 0) : (i2 -= Ai(o2), o2.push(n2 + e21.value), i2 = e21.length);
            }
            break;
          case "label":
            s2.push([e21, c3, l2.contents]);
        }
      s2.length === 0 && u2.length > 0 && (s2.push(...u2.reverse()), u2 = []);
    }
    const c2 = o2.indexOf(Ei.placeholder);
    if (c2 !== -1) {
      const e21 = o2.indexOf(Ei.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), r3 = o2.slice(c2 + 1, e21).join("");
      return {formatted: t3 + r3 + o2.slice(e21 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: r3};
    }
    return {formatted: o2.join("")};
  }};
  const {isConcat: ki, getDocParts: Ni} = Di;
  function Oi(e20) {
    if (!e20)
      return "";
    if (ki(e20)) {
      const t2 = [];
      for (const r2 of Ni(e20))
        if (ki(r2))
          t2.push(...Oi(r2).parts);
        else {
          const e21 = Oi(r2);
          e21 !== "" && t2.push(e21);
        }
      return {type: "concat", parts: t2};
    }
    return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {breakContents: Oi(e20.breakContents), flatContents: Oi(e20.flatContents)}) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {contents: Oi(e20.contents), expandedStates: e20.expandedStates && e20.expandedStates.map(Oi)}) : e20.type === "fill" ? {type: "fill", parts: e20.parts.map(Oi)} : e20.contents ? Object.assign(Object.assign({}, e20), {}, {contents: Oi(e20.contents)}) : e20;
  }
  var xi = {builders: Yn, printer: wi, utils: Di, debug: {printDocToDebug: function(e20) {
    const t2 = Object.create(null), r2 = new Set();
    return function e21(t3, r3, i2) {
      if (typeof t3 == "string")
        return JSON.stringify(t3);
      if (ki(t3)) {
        const r4 = Ni(t3).map(e21).filter(Boolean);
        return r4.length === 1 ? r4[0] : `[${r4.join(", ")}]`;
      }
      if (t3.type === "line") {
        const e22 = Array.isArray(i2) && i2[r3 + 1] && i2[r3 + 1].type === "break-parent";
        return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
      }
      if (t3.type === "break-parent") {
        return Array.isArray(i2) && i2[r3 - 1] && i2[r3 - 1].type === "line" && i2[r3 - 1].hard ? void 0 : "breakParent";
      }
      if (t3.type === "trim")
        return "trim";
      if (t3.type === "indent")
        return "indent(" + e21(t3.contents) + ")";
      if (t3.type === "align")
        return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
      if (t3.type === "if-break")
        return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${n2(t3.groupId)} }` : "") + ")";
      if (t3.type === "indent-if-break") {
        const r4 = [];
        t3.negate && r4.push("negate: true"), t3.groupId && r4.push(`groupId: ${n2(t3.groupId)}`);
        const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
        return `indentIfBreak(${e21(t3.contents)}${i3})`;
      }
      if (t3.type === "group") {
        const r4 = [];
        t3.break && t3.break !== "propagated" && r4.push("shouldBreak: true"), t3.id && r4.push(`id: ${n2(t3.id)}`);
        const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
        return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
      }
      if (t3.type === "fill")
        return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
      if (t3.type === "line-suffix")
        return "lineSuffix(" + e21(t3.contents) + ")";
      if (t3.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (t3.type === "label")
        return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
      throw new Error("Unknown doc type " + t3.type);
    }(Oi(e20));
    function n2(e21) {
      if (typeof e21 != "symbol")
        return JSON.stringify(String(e21));
      if (e21 in t2)
        return t2[e21];
      const n3 = String(e21).slice(7, -1) || "symbol";
      for (let i2 = 0; ; i2++) {
        const s2 = n3 + (i2 > 0 ? ` #${i2}` : "");
        if (!r2.has(s2))
          return r2.add(s2), t2[e21] = `Symbol.for(${JSON.stringify(s2)})`;
      }
    }
  }}};
  const {inferParserByLanguage: Ii, isFrontMatterNode: Pi} = $n, {builders: {line: Ri, hardline: Li, join: Bi}, utils: {getDocParts: $i, replaceTextEndOfLine: qi}} = xi, {CSS_DISPLAY_TAGS: Mi, CSS_DISPLAY_DEFAULT: ji, CSS_WHITE_SPACE_TAGS: Ui, CSS_WHITE_SPACE_DEFAULT: Gi} = {CSS_DISPLAY_TAGS: {area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block"}, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: {listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap"}, CSS_WHITE_SPACE_DEFAULT: "normal"}, Vi = Yi(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), Hi = function(e20, t2) {
    const r2 = Object.create(null);
    for (const [n2, i2] of Object.entries(e20))
      r2[n2] = t2(i2, n2);
    return r2;
  }(qn, Yi), Xi = new Set(["	", "\n", "\f", "\r", " "]), zi = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), Wi = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(zi(e20));
  function Yi(e20) {
    const t2 = Object.create(null);
    for (const r2 of e20)
      t2[r2] = true;
    return t2;
  }
  function Qi(e20) {
    return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || as$3(e20) && (e20.name === "script" || e20.name === "style"));
  }
  function Ji(e20) {
    return us(e20).startsWith("pre");
  }
  function Ki(e20) {
    return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
  }
  function Zi(e20) {
    return ns(e20) || e20.type === "element" && e20.fullName === "br" || es(e20);
  }
  function es(e20) {
    return ts(e20) && rs(e20);
  }
  function ts(e20) {
    return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
  }
  function rs(e20) {
    return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
  }
  function ns(e20) {
    switch (e20.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(e20.name);
    }
    return false;
  }
  function is(e20) {
    const {type: t2, lang: r2} = e20.attrMap;
    return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || r2 === "jsx" ? "babel" : t2 === "application/x-typescript" || r2 === "ts" || r2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
  }
  function ss(e20) {
    return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
  }
  function os(e20) {
    return us(e20).startsWith("pre");
  }
  function as$3(e20) {
    return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
  }
  function us(e20) {
    return e20.type === "element" && (!e20.namespace || as$3(e20)) && Ui[e20.name] || Gi;
  }
  function cs(e20, t2 = function(e21) {
    let t3 = Number.POSITIVE_INFINITY;
    for (const n2 of e21.split("\n")) {
      if (n2.length === 0)
        continue;
      if (!Xi.has(n2[0]))
        return 0;
      const e22 = (r2 = n2, r2.match(/^[\t\n\f\r ]*/)[0]).length;
      n2.length !== e22 && e22 < t3 && (t3 = e22);
    }
    var r2;
    return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
  }(e20)) {
    return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
  }
  const ls = new Set(["template", "style", "script"]);
  function ps(e20, t2) {
    return hs(e20, t2) && !ls.has(e20.fullName);
  }
  function hs(e20, t2) {
    return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
  }
  function Ds(e20, t2) {
    return hs(e20, t2) && (ps(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
  }
  var fs = {HTML_ELEMENT_ATTRIBUTES: Hi, HTML_TAGS: Vi, htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(zi(e20)), htmlTrimPreserveIndentation: Wi, hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20), getLeadingAndTrailingHtmlWhitespace: (e20) => {
    const [, t2, r2, n2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return {leadingWhitespace: t2, trailingWhitespace: n2, text: r2};
  }, canHaveInterpolation: function(e20) {
    return e20.children && !Qi(e20);
  }, countChars: function(e20, t2) {
    let r2 = 0;
    for (let n2 = 0; n2 < e20.length; n2++)
      e20[n2] === t2 && r2++;
    return r2;
  }, countParents: function(e20, t2) {
    let r2 = 0;
    for (let n2 = e20.stack.length - 1; n2 >= 0; n2--) {
      const i2 = e20.stack[n2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && r2++;
    }
    return r2;
  }, dedentString: cs, forceBreakChildren: Ki, forceBreakContent: function(e20) {
    return Ki(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
      return e22.children && e22.children.some((e23) => e23.type !== "text");
    }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ts(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || rs(e20.lastChild));
  }, forceNextEmptyLine: function(e20) {
    return Pi(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
  }, getLastDescendant: function e18(t2) {
    return t2.lastChild ? e18(t2.lastChild) : t2;
  }, getNodeCssStyleDisplay: function(e20, t2) {
    if (e20.prev && e20.prev.type === "comment") {
      const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let r2 = false;
    if (e20.type === "element" && e20.namespace === "svg") {
      if (!function(e21, t3) {
        let r3 = e21;
        for (; r3; ) {
          if (t3(r3))
            return true;
          r3 = r3.parent;
        }
        return false;
      }(e20, (e21) => e21.fullName === "svg:foreignObject"))
        return e20.name === "svg" ? "inline-block" : "block";
      r2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || r2 || as$3(e20)) && Mi[e20.name] || ji;
    }
  }, getNodeCssStyleWhiteSpace: us, hasPrettierIgnore: function(e20) {
    return e20.type !== "attribute" && (!!e20.parent && (typeof e20.index == "number" && e20.index !== 0 && function(e21) {
      return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
    }(e20.parent.children[e20.index - 1])));
  }, inferScriptParser: function(e20, t2) {
    return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
      const {lang: t3} = e21.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e20) : t2 && Ds(e20, t2) ? is(e20) || !("src" in e20.attrMap) && Ii(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? is(e20) : "babel";
  }, isVueCustomBlock: ps, isVueNonHtmlBlock: Ds, isVueSlotAttribute: function(e20) {
    const t2 = e20.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  }, isVueSfcBindingsAttribute: function(e20, t2) {
    const r2 = e20.parent;
    if (!hs(r2, t2))
      return false;
    const n2 = r2.fullName, i2 = e20.fullName;
    return n2 === "script" && i2 === "setup" || n2 === "style" && i2 === "vars";
  }, isDanglingSpaceSensitiveNode: function(e20) {
    return !(t2 = e20.cssDisplay, ss(t2) || t2 === "inline-block" || Qi(e20));
    var t2;
  }, isIndentationSensitiveNode: Ji, isLeadingSpaceSensitiveNode: function(e20, t2) {
    const r2 = function() {
      if (Pi(e20))
        return false;
      if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
        return true;
      if (!e20.parent || e20.parent.cssDisplay === "none")
        return false;
      if (os(e20.parent))
        return true;
      if (!e20.prev && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r3 = e20.parent.cssDisplay, ss(r3) || r3 === "inline-block")))
        return false;
      var r3;
      if (e20.prev && !function(e21) {
        return !ss(e21);
      }(e20.prev.cssDisplay))
        return false;
      return true;
    }();
    return r2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : r2;
  }, isPreLikeNode: os, isScriptLikeTag: Qi, isTextLikeNode: function(e20) {
    return e20.type === "text" || e20.type === "comment";
  }, isTrailingSpaceSensitiveNode: function(e20, t2) {
    return !Pi(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!os(e20.parent) || !(!e20.next && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r2 = e20.parent.cssDisplay, ss(r2) || r2 === "inline-block"))) && !(e20.next && !function(e21) {
      return !ss(e21);
    }(e20.next.cssDisplay))));
    var r2;
  }, isWhitespaceSensitiveNode: function(e20) {
    return Qi(e20) || e20.type === "interpolation" || Ji(e20);
  }, isUnknownNamespace: as$3, preferHardlineAsLeadingSpaces: function(e20) {
    return ns(e20) || e20.prev && Zi(e20.prev) || es(e20);
  }, preferHardlineAsTrailingSpaces: Zi, shouldPreserveContent: function(e20, t2) {
    return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || (e20.type === "ieConditionalComment" && !e20.complete || (!(!os(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!Ds(e20, t2) || Qi(e20) || e20.type === "interpolation")));
  }, unescapeQuoteEntities: function(e20) {
    return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }, getTextValueParts: function(e20, t2 = e20.value) {
    return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? qi(t2) : qi(cs(Wi(t2)), Li) : $i(Bi(Ri, t2.split(/[\t\n\f\r ]+/)));
  }};
  var ds = {hasPragma: function(e20) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
  }, insertPragma: function(e20) {
    return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
  }};
  const {isNonEmptyArray: gs} = $n, ms = {attrs: true, children: true};
  class Es {
    constructor(e20 = {}) {
      for (const [t2, r2] of Object.entries(e20))
        t2 in ms ? this._setNodes(t2, r2) : this[t2] = r2;
    }
    _setNodes(e20, t2) {
      t2 !== this[e20] && (this[e20] = function(e21, t3) {
        const r2 = e21.map((e22) => e22 instanceof Es ? e22.clone() : new Es(e22));
        let n2 = null, i2 = r2[0], s2 = r2[1] || null;
        for (let e22 = 0; e22 < r2.length; e22++)
          ys(i2, {index: e22, siblings: r2, prev: n2, next: s2, parent: t3}), n2 = i2, i2 = s2, s2 = r2[e22 + 2] || null;
        return r2;
      }(t2, this), e20 === "attrs" && ys(this, {attrMap: Object.fromEntries(this[e20].map((e21) => [e21.fullName, e21.value]))}));
    }
    map(e20) {
      let t2 = null;
      for (const r2 in ms) {
        const n2 = this[r2];
        if (n2) {
          const i2 = Cs(n2, (t3) => t3.map(e20));
          t2 !== n2 && (t2 || (t2 = new Es()), t2._setNodes(r2, i2));
        }
      }
      if (t2) {
        for (const e22 in this)
          e22 in ms || (t2[e22] = this[e22]);
        const {index: e21, siblings: r2, prev: n2, next: i2, parent: s2} = this;
        ys(t2, {index: e21, siblings: r2, prev: n2, next: i2, parent: s2});
      }
      return e20(t2 || this);
    }
    walk(e20) {
      for (const t2 in ms) {
        const r2 = this[t2];
        if (r2)
          for (let t3 = 0; t3 < r2.length; t3++)
            r2[t3].walk(e20);
      }
      e20(this);
    }
    clone(e20) {
      return new Es(e20 ? Object.assign(Object.assign({}, this), e20) : this);
    }
    setChildren(e20) {
      this._setNodes("children", e20);
    }
    get firstChild() {
      return gs(this.children) ? this.children[0] : null;
    }
    get lastChild() {
      return gs(this.children) ? M$1(this.children) : null;
    }
    get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
      return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
  }
  function Cs(e20, t2) {
    const r2 = e20.map(t2);
    return r2.some((t3, r3) => t3 !== e20[r3]) ? r2 : e20;
  }
  function ys(e20, t2) {
    const r2 = Object.fromEntries(Object.entries(t2).map(([e21, t3]) => [e21, {value: t3, enumerable: false}]));
    Object.defineProperties(e20, r2);
  }
  var bs = {Node: Es};
  const {ParseSourceSpan: Ss} = B$1, Ts = [{regex: /^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s, parse: function(e20, t2, r2) {
    const [, n2, i2, s2] = r2, o2 = "<!--".length + n2.length, a2 = e20.sourceSpan.start.moveBy(o2), u2 = a2.moveBy(s2.length), [c2, l2] = (() => {
      try {
        return [true, t2(s2, a2).children];
      } catch (e) {
        return [false, [{type: "text", value: s2, sourceSpan: new Ss(a2, u2)}]];
      }
    })();
    return {type: "ieConditionalComment", complete: c2, children: l2, condition: i2.trim().replace(/\s+/g, " "), sourceSpan: e20.sourceSpan, startSourceSpan: new Ss(e20.sourceSpan.start, a2), endSourceSpan: new Ss(u2, e20.sourceSpan.end)};
  }}, {regex: /^\[if([^\]]*?)]><!$/, parse: function(e20, t2, r2) {
    const [, n2] = r2;
    return {type: "ieConditionalStartComment", condition: n2.trim().replace(/\s+/g, " "), sourceSpan: e20.sourceSpan};
  }}, {regex: /^<!\s*\[endif]$/, parse: function(e20) {
    return {type: "ieConditionalEndComment", sourceSpan: e20.sourceSpan};
  }}];
  var _s = {parseIeConditionalComment: function(e20, t2) {
    if (e20.value)
      for (const {regex: r2, parse: n2} of Ts) {
        const i2 = e20.value.match(r2);
        if (i2)
          return n2(e20, t2, i2);
      }
    return null;
  }};
  var vs = {locStart: function(e20) {
    return e20.sourceSpan.start.offset;
  }, locEnd: function(e20) {
    return e20.sourceSpan.end.offset;
  }}, As = t$1(function(e20, t2) {
    function r2(e21) {
      if (e21[0] != ":")
        return [null, e21];
      const t3 = e21.indexOf(":", 1);
      if (t3 == -1)
        throw new Error(`Unsupported format "${e21}" expecting ":namespace:name"`);
      return [e21.slice(1, t3), e21.slice(t3 + 1)];
    }
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true}), function(e21) {
      e21[e21.RAW_TEXT = 0] = "RAW_TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e21[e21.PARSABLE_DATA = 2] = "PARSABLE_DATA";
    }(t2.TagContentType || (t2.TagContentType = {})), t2.splitNsName = r2, t2.isNgContainer = function(e21) {
      return r2(e21)[1] === "ng-container";
    }, t2.isNgContent = function(e21) {
      return r2(e21)[1] === "ng-content";
    }, t2.isNgTemplate = function(e21) {
      return r2(e21)[1] === "ng-template";
    }, t2.getNsPrefix = function(e21) {
      return e21 === null ? null : r2(e21)[0];
    }, t2.mergeNsAndName = function(e21, t3) {
      return e21 ? `:${e21}:${t3}` : t3;
    }, t2.NAMED_ENTITIES = {Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C"}, t2.NGSP_UNICODE = "\uE500", t2.NAMED_ENTITIES.ngsp = t2.NGSP_UNICODE;
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Fs {
    constructor({closedByChildren: e20, implicitNamespacePrefix: t2, contentType: r2 = As.TagContentType.PARSABLE_DATA, closedByParent: n2 = false, isVoid: i2 = false, ignoreFirstLf: s2 = false} = {}) {
      this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, e20 && e20.length > 0 && e20.forEach((e21) => this.closedByChildren[e21] = true), this.isVoid = i2, this.closedByParent = n2 || i2, this.implicitNamespacePrefix = t2 || null, this.contentType = r2, this.ignoreFirstLf = s2;
    }
    isClosedByChild(e20) {
      return this.isVoid || e20.toLowerCase() in this.closedByChildren;
    }
  }
  var ws = Fs;
  let ks, Ns;
  var Os = function(e20) {
    return Ns || (ks = new Fs(), Ns = {base: new Fs({isVoid: true}), meta: new Fs({isVoid: true}), area: new Fs({isVoid: true}), embed: new Fs({isVoid: true}), link: new Fs({isVoid: true}), img: new Fs({isVoid: true}), input: new Fs({isVoid: true}), param: new Fs({isVoid: true}), hr: new Fs({isVoid: true}), br: new Fs({isVoid: true}), source: new Fs({isVoid: true}), track: new Fs({isVoid: true}), wbr: new Fs({isVoid: true}), p: new Fs({closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true}), thead: new Fs({closedByChildren: ["tbody", "tfoot"]}), tbody: new Fs({closedByChildren: ["tbody", "tfoot"], closedByParent: true}), tfoot: new Fs({closedByChildren: ["tbody"], closedByParent: true}), tr: new Fs({closedByChildren: ["tr"], closedByParent: true}), td: new Fs({closedByChildren: ["td", "th"], closedByParent: true}), th: new Fs({closedByChildren: ["td", "th"], closedByParent: true}), col: new Fs({isVoid: true}), svg: new Fs({implicitNamespacePrefix: "svg"}), math: new Fs({implicitNamespacePrefix: "math"}), li: new Fs({closedByChildren: ["li"], closedByParent: true}), dt: new Fs({closedByChildren: ["dt", "dd"]}), dd: new Fs({closedByChildren: ["dt", "dd"], closedByParent: true}), rb: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), rt: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), rtc: new Fs({closedByChildren: ["rb", "rtc", "rp"], closedByParent: true}), rp: new Fs({closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true}), optgroup: new Fs({closedByChildren: ["optgroup"], closedByParent: true}), option: new Fs({closedByChildren: ["option", "optgroup"], closedByParent: true}), pre: new Fs({ignoreFirstLf: true}), listing: new Fs({ignoreFirstLf: true}), style: new Fs({contentType: As.TagContentType.RAW_TEXT}), script: new Fs({contentType: As.TagContentType.RAW_TEXT}), title: new Fs({contentType: As.TagContentType.ESCAPABLE_RAW_TEXT}), textarea: new Fs({contentType: As.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true})}), Ns[e20] || ks;
  }, xs = Object.defineProperty({HtmlTagDefinition: ws, getHtmlTagDefinition: Os}, "__esModule", {value: true});
  var Is = class {
    constructor(e20, t2 = -1) {
      this.path = e20, this.position = t2;
    }
    get empty() {
      return !this.path || !this.path.length;
    }
    get head() {
      return this.path[0];
    }
    get tail() {
      return this.path[this.path.length - 1];
    }
    parentOf(e20) {
      return e20 && this.path[this.path.indexOf(e20) - 1];
    }
    childOf(e20) {
      return this.path[this.path.indexOf(e20) + 1];
    }
    first(e20) {
      for (let t2 = this.path.length - 1; t2 >= 0; t2--) {
        let r2 = this.path[t2];
        if (r2 instanceof e20)
          return r2;
      }
    }
    push(e20) {
      this.path.push(e20);
    }
    pop() {
      return this.path.pop();
    }
  }, Ps = Object.defineProperty({AstPath: Is}, "__esModule", {value: true});
  var Rs = class {
    constructor(e20, t2, r2) {
      this.value = e20, this.sourceSpan = t2, this.i18n = r2, this.type = "text";
    }
    visit(e20, t2) {
      return e20.visitText(this, t2);
    }
  };
  var Ls = class {
    constructor(e20, t2) {
      this.value = e20, this.sourceSpan = t2, this.type = "cdata";
    }
    visit(e20, t2) {
      return e20.visitCdata(this, t2);
    }
  };
  var Bs = class {
    constructor(e20, t2, r2, n2, i2, s2) {
      this.switchValue = e20, this.type = t2, this.cases = r2, this.sourceSpan = n2, this.switchValueSourceSpan = i2, this.i18n = s2;
    }
    visit(e20, t2) {
      return e20.visitExpansion(this, t2);
    }
  };
  var $s = class {
    constructor(e20, t2, r2, n2, i2) {
      this.value = e20, this.expression = t2, this.sourceSpan = r2, this.valueSourceSpan = n2, this.expSourceSpan = i2;
    }
    visit(e20, t2) {
      return e20.visitExpansionCase(this, t2);
    }
  };
  var qs$3 = class {
    constructor(e20, t2, r2, n2 = null, i2 = null, s2 = null) {
      this.name = e20, this.value = t2, this.sourceSpan = r2, this.valueSpan = n2, this.nameSpan = i2, this.i18n = s2, this.type = "attribute";
    }
    visit(e20, t2) {
      return e20.visitAttribute(this, t2);
    }
  };
  class Ms {
    constructor(e20, t2, r2, n2, i2 = null, s2 = null, o2 = null, a2 = null) {
      this.name = e20, this.attrs = t2, this.children = r2, this.sourceSpan = n2, this.startSourceSpan = i2, this.endSourceSpan = s2, this.nameSpan = o2, this.i18n = a2, this.type = "element";
    }
    visit(e20, t2) {
      return e20.visitElement(this, t2);
    }
  }
  var js = Ms;
  var Us = class {
    constructor(e20, t2) {
      this.value = e20, this.sourceSpan = t2, this.type = "comment";
    }
    visit(e20, t2) {
      return e20.visitComment(this, t2);
    }
  };
  var Gs = class {
    constructor(e20, t2) {
      this.value = e20, this.sourceSpan = t2, this.type = "docType";
    }
    visit(e20, t2) {
      return e20.visitDocType(this, t2);
    }
  };
  function Vs(e20, t2, r2 = null) {
    const n2 = [], i2 = e20.visit ? (t3) => e20.visit(t3, r2) || t3.visit(e20, r2) : (t3) => t3.visit(e20, r2);
    return t2.forEach((e21) => {
      const t3 = i2(e21);
      t3 && n2.push(t3);
    }), n2;
  }
  var Hs = Vs;
  class Xs {
    constructor() {
    }
    visitElement(e20, t2) {
      this.visitChildren(t2, (t3) => {
        t3(e20.attrs), t3(e20.children);
      });
    }
    visitAttribute(e20, t2) {
    }
    visitText(e20, t2) {
    }
    visitCdata(e20, t2) {
    }
    visitComment(e20, t2) {
    }
    visitDocType(e20, t2) {
    }
    visitExpansion(e20, t2) {
      return this.visitChildren(t2, (t3) => {
        t3(e20.cases);
      });
    }
    visitExpansionCase(e20, t2) {
    }
    visitChildren(e20, t2) {
      let r2 = [], n2 = this;
      return t2(function(t3) {
        t3 && r2.push(Vs(n2, t3, e20));
      }), Array.prototype.concat.apply([], r2);
    }
  }
  var zs = Xs;
  function Ws(e20) {
    const t2 = e20.sourceSpan.start.offset;
    let r2 = e20.sourceSpan.end.offset;
    return e20 instanceof Ms && (e20.endSourceSpan ? r2 = e20.endSourceSpan.end.offset : e20.children && e20.children.length && (r2 = Ws(e20.children[e20.children.length - 1]).end)), {start: t2, end: r2};
  }
  var Ys = function(e20, t2) {
    const r2 = [];
    return Vs(new class extends Xs {
      visit(e21, n2) {
        const i2 = Ws(e21);
        if (!(i2.start <= t2 && t2 < i2.end))
          return true;
        r2.push(e21);
      }
    }(), e20), new Ps.AstPath(r2, t2);
  }, Qs = Object.defineProperty({Text: Rs, CDATA: Ls, Expansion: Bs, ExpansionCase: $s, Attribute: qs$3, Element: js, Comment: Us, DocType: Gs, visitAll: Hs, RecursiveVisitor: zs, findNode: Ys}, "__esModule", {value: true});
  var Js = function(e20, t2) {
    if (t2 != null) {
      if (!Array.isArray(t2))
        throw new Error(`Expected '${e20}' to be an array of strings.`);
      for (let r2 = 0; r2 < t2.length; r2 += 1)
        if (typeof t2[r2] != "string")
          throw new Error(`Expected '${e20}' to be an array of strings.`);
    }
  };
  const Ks = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  var Zs = function(e20, t2) {
    if (!(t2 == null || Array.isArray(t2) && t2.length == 2))
      throw new Error(`Expected '${e20}' to be an array, [start, end].`);
    if (t2 != null) {
      const e21 = t2[0], r2 = t2[1];
      Ks.forEach((t3) => {
        if (t3.test(e21) || t3.test(r2))
          throw new Error(`['${e21}', '${r2}'] contains unusable interpolation symbol.`);
      });
    }
  }, eo = Object.defineProperty({assertArrayOfStrings: Js, assertInterpolationSymbols: Zs}, "__esModule", {value: true}), to$3 = t$1(function(e20, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true});
    class r2 {
      constructor(e21, t3) {
        this.start = e21, this.end = t3;
      }
      static fromArray(e21) {
        return e21 ? (eo.assertInterpolationSymbols("interpolation", e21), new r2(e21[0], e21[1])) : t2.DEFAULT_INTERPOLATION_CONFIG;
      }
    }
    t2.InterpolationConfig = r2, t2.DEFAULT_INTERPOLATION_CONFIG = new r2("{{", "}}");
  }), ro = t$1(function(e20, t2) {
    /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
    Object.defineProperty(t2, "__esModule", {value: true});
    const n2 = r$1;
    var i2;
    !function(e21) {
      e21[e21.TAG_OPEN_START = 0] = "TAG_OPEN_START", e21[e21.TAG_OPEN_END = 1] = "TAG_OPEN_END", e21[e21.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e21[e21.TAG_CLOSE = 3] = "TAG_CLOSE", e21[e21.TEXT = 4] = "TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e21[e21.RAW_TEXT = 6] = "RAW_TEXT", e21[e21.COMMENT_START = 7] = "COMMENT_START", e21[e21.COMMENT_END = 8] = "COMMENT_END", e21[e21.CDATA_START = 9] = "CDATA_START", e21[e21.CDATA_END = 10] = "CDATA_END", e21[e21.ATTR_NAME = 11] = "ATTR_NAME", e21[e21.ATTR_QUOTE = 12] = "ATTR_QUOTE", e21[e21.ATTR_VALUE = 13] = "ATTR_VALUE", e21[e21.DOC_TYPE_START = 14] = "DOC_TYPE_START", e21[e21.DOC_TYPE_END = 15] = "DOC_TYPE_END", e21[e21.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e21[e21.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e21[e21.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e21[e21.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e21[e21.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e21[e21.EOF = 21] = "EOF";
    }(i2 = t2.TokenType || (t2.TokenType = {}));
    class s2 {
      constructor(e21, t3, r2) {
        this.type = e21, this.parts = t3, this.sourceSpan = r2;
      }
    }
    t2.Token = s2;
    class o2 extends B$1.ParseError {
      constructor(e21, t3, r2) {
        super(r2, e21), this.tokenType = t3;
      }
    }
    t2.TokenError = o2;
    class a2 {
      constructor(e21, t3) {
        this.tokens = e21, this.errors = t3;
      }
    }
    t2.TokenizeResult = a2, t2.tokenize = function(e21, t3, r2, n3 = {}) {
      return new h2(new B$1.ParseSourceFile(e21, t3), r2, n3).tokenize();
    };
    const u2 = /\r\n?/g;
    function c2(e21) {
      return `Unexpected character "${e21 === n2.$EOF ? "EOF" : String.fromCharCode(e21)}"`;
    }
    function l2(e21) {
      return `Unknown entity "${e21}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
    }
    class p2 {
      constructor(e21) {
        this.error = e21;
      }
    }
    class h2 {
      constructor(e21, t3, r2) {
        this._getTagContentType = t3, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = r2.tokenizeExpansionForms || false, this._interpolationConfig = r2.interpolationConfig || to$3.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = r2.leadingTriviaChars && r2.leadingTriviaChars.map((e22) => e22.codePointAt(0) || 0), this._canSelfClose = r2.canSelfClose || false, this._allowHtmComponentClosingTags = r2.allowHtmComponentClosingTags || false;
        const n3 = r2.range || {endPos: e21.content.length, startPos: 0, startLine: 0, startCol: 0};
        this._cursor = r2.escapedString ? new C2(e21, n3) : new E2(e21, n3);
        try {
          this._cursor.init();
        } catch (e22) {
          this.handleError(e22);
        }
      }
      _processCarriageReturns(e21) {
        return e21.replace(u2, "\n");
      }
      tokenize() {
        for (; this._cursor.peek() !== n2.$EOF; ) {
          const e21 = this._cursor.clone();
          try {
            if (this._attemptCharCode(n2.$LT))
              if (this._attemptCharCode(n2.$BANG))
                this._attemptStr("[CDATA[") ? this._consumeCdata(e21) : this._attemptStr("--") ? this._consumeComment(e21) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e21) : this._consumeBogusComment(e21);
              else if (this._attemptCharCode(n2.$SLASH))
                this._consumeTagClose(e21);
              else {
                const t3 = this._cursor.clone();
                this._attemptCharCode(n2.$QUESTION) ? (this._cursor = t3, this._consumeBogusComment(e21)) : this._consumeTagOpen(e21);
              }
            else
              this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
          } catch (e22) {
            this.handleError(e22);
          }
        }
        return this._beginToken(i2.EOF), this._endToken([]), new a2(function(e21) {
          const t3 = [];
          let r2;
          for (let n3 = 0; n3 < e21.length; n3++) {
            const s3 = e21[n3];
            r2 && r2.type == i2.TEXT && s3.type == i2.TEXT ? (r2.parts[0] += s3.parts[0], r2.sourceSpan.end = s3.sourceSpan.end) : (r2 = s3, t3.push(r2));
          }
          return t3;
        }(this.tokens), this.errors);
      }
      _tokenizeExpansionForm() {
        if (this.isExpansionFormStart())
          return this._consumeExpansionFormStart(), true;
        if (((e21 = this._cursor.peek()) === n2.$EQ || n2.isAsciiLetter(e21) || n2.isDigit(e21)) && this._isInExpansionForm())
          return this._consumeExpansionCaseStart(), true;
        var e21;
        if (this._cursor.peek() === n2.$RBRACE) {
          if (this._isInExpansionCase())
            return this._consumeExpansionCaseEnd(), true;
          if (this._isInExpansionForm())
            return this._consumeExpansionFormEnd(), true;
        }
        return false;
      }
      _beginToken(e21, t3 = this._cursor.clone()) {
        this._currentTokenStart = t3, this._currentTokenType = e21;
      }
      _endToken(e21, t3 = this._cursor.clone()) {
        if (this._currentTokenStart === null)
          throw new o2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t3));
        if (this._currentTokenType === null)
          throw new o2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
        const r2 = new s2(this._currentTokenType, e21, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
        return this.tokens.push(r2), this._currentTokenStart = null, this._currentTokenType = null, r2;
      }
      _createError(e21, t3) {
        this._isInExpansionForm() && (e21 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
        const r2 = new o2(e21, this._currentTokenType, t3);
        return this._currentTokenStart = null, this._currentTokenType = null, new p2(r2);
      }
      handleError(e21) {
        if (e21 instanceof y2 && (e21 = this._createError(e21.msg, this._cursor.getSpan(e21.cursor))), !(e21 instanceof p2))
          throw e21;
        this.errors.push(e21.error);
      }
      _attemptCharCode(e21) {
        return this._cursor.peek() === e21 && (this._cursor.advance(), true);
      }
      _attemptCharCodeCaseInsensitive(e21) {
        return t3 = this._cursor.peek(), r2 = e21, m2(t3) == m2(r2) && (this._cursor.advance(), true);
        var t3, r2;
      }
      _requireCharCode(e21) {
        const t3 = this._cursor.clone();
        if (!this._attemptCharCode(e21))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _attemptStr(e21) {
        const t3 = e21.length;
        if (this._cursor.charsLeft() < t3)
          return false;
        const r2 = this._cursor.clone();
        for (let n3 = 0; n3 < t3; n3++)
          if (!this._attemptCharCode(e21.charCodeAt(n3)))
            return this._cursor = r2, false;
        return true;
      }
      _attemptStrCaseInsensitive(e21) {
        for (let t3 = 0; t3 < e21.length; t3++)
          if (!this._attemptCharCodeCaseInsensitive(e21.charCodeAt(t3)))
            return false;
        return true;
      }
      _requireStr(e21) {
        const t3 = this._cursor.clone();
        if (!this._attemptStr(e21))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _requireStrCaseInsensitive(e21) {
        const t3 = this._cursor.clone();
        if (!this._attemptStrCaseInsensitive(e21))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
      }
      _attemptCharCodeUntilFn(e21) {
        for (; !e21(this._cursor.peek()); )
          this._cursor.advance();
      }
      _requireCharCodeUntilFn(e21, t3) {
        const r2 = this._cursor.clone();
        this._attemptCharCodeUntilFn(e21);
        if (this._cursor.clone().diff(r2) < t3)
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(r2));
      }
      _attemptUntilChar(e21) {
        for (; this._cursor.peek() !== e21; )
          this._cursor.advance();
      }
      _readChar(e21) {
        if (e21 && this._cursor.peek() === n2.$AMPERSAND)
          return this._decodeEntity();
        {
          const e22 = String.fromCodePoint(this._cursor.peek());
          return this._cursor.advance(), e22;
        }
      }
      _decodeEntity() {
        const e21 = this._cursor.clone();
        if (this._cursor.advance(), !this._attemptCharCode(n2.$HASH)) {
          const t3 = this._cursor.clone();
          if (this._attemptCharCodeUntilFn(g2), this._cursor.peek() != n2.$SEMICOLON)
            return this._cursor = t3, "&";
          const r2 = this._cursor.getChars(t3);
          this._cursor.advance();
          const i3 = As.NAMED_ENTITIES[r2];
          if (!i3)
            throw this._createError(l2(r2), this._cursor.getSpan(e21));
          return i3;
        }
        {
          const t3 = this._attemptCharCode(n2.$x) || this._attemptCharCode(n2.$X), r2 = this._cursor.clone();
          if (this._attemptCharCodeUntilFn(d2), this._cursor.peek() != n2.$SEMICOLON)
            throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan());
          const i3 = this._cursor.getChars(r2);
          this._cursor.advance();
          try {
            const e22 = parseInt(i3, t3 ? 16 : 10);
            return String.fromCharCode(e22);
          } catch (t4) {
            throw this._createError(l2(this._cursor.getChars(e21)), this._cursor.getSpan());
          }
        }
      }
      _consumeRawText(e21, t3) {
        this._beginToken(e21 ? i2.ESCAPABLE_RAW_TEXT : i2.RAW_TEXT);
        const r2 = [];
        for (; ; ) {
          const n3 = this._cursor.clone(), i3 = t3();
          if (this._cursor = n3, i3)
            break;
          r2.push(this._readChar(e21));
        }
        return this._endToken([this._processCarriageReturns(r2.join(""))]);
      }
      _consumeComment(e21) {
        this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(i2.COMMENT_END), this._requireStr("-->"), this._endToken([]);
      }
      _consumeBogusComment(e21) {
        this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.COMMENT_END), this._cursor.advance(), this._endToken([]);
      }
      _consumeCdata(e21) {
        this._beginToken(i2.CDATA_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(i2.CDATA_END), this._requireStr("]]>"), this._endToken([]);
      }
      _consumeDocType(e21) {
        this._beginToken(i2.DOC_TYPE_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
      }
      _consumePrefixAndName() {
        const e21 = this._cursor.clone();
        let t3 = "";
        for (; this._cursor.peek() !== n2.$COLON && !(((r2 = this._cursor.peek()) < n2.$a || n2.$z < r2) && (r2 < n2.$A || n2.$Z < r2) && (r2 < n2.$0 || r2 > n2.$9)); )
          this._cursor.advance();
        var r2;
        let i3;
        this._cursor.peek() === n2.$COLON ? (t3 = this._cursor.getChars(e21), this._cursor.advance(), i3 = this._cursor.clone()) : i3 = e21, this._requireCharCodeUntilFn(f2, t3 === "" ? 0 : 1);
        return [t3, this._cursor.getChars(i3)];
      }
      _consumeTagOpen(e21) {
        let t3, r2, s3, o3 = this.tokens.length;
        const a3 = this._cursor.clone(), u3 = [];
        try {
          if (!n2.isAsciiLetter(this._cursor.peek()))
            throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(e21));
          for (s3 = this._consumeTagOpenStart(e21), r2 = s3.parts[0], t3 = s3.parts[1], this._attemptCharCodeUntilFn(D2); this._cursor.peek() !== n2.$SLASH && this._cursor.peek() !== n2.$GT; ) {
            const [e22, t4] = this._consumeAttributeName();
            if (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$EQ)) {
              this._attemptCharCodeUntilFn(D2);
              const r3 = this._consumeAttributeValue();
              u3.push({prefix: e22, name: t4, value: r3});
            } else
              u3.push({prefix: e22, name: t4});
            this._attemptCharCodeUntilFn(D2);
          }
          this._consumeTagOpenEnd();
        } catch (t4) {
          if (t4 instanceof p2)
            return this._cursor = a3, s3 && (this.tokens.length = o3), this._beginToken(i2.TEXT, e21), void this._endToken(["<"]);
          throw t4;
        }
        if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === i2.TAG_OPEN_END_VOID)
          return;
        const l3 = this._getTagContentType(t3, r2, this._fullNameStack.length > 0, u3);
        this._handleFullNameStackForTagOpen(r2, t3), l3 === As.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(r2, t3, false) : l3 === As.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r2, t3, true);
      }
      _consumeRawTextWithTagClose(e21, t3, r2) {
        this._consumeRawText(r2, () => !!this._attemptCharCode(n2.$LT) && (!!this._attemptCharCode(n2.$SLASH) && (this._attemptCharCodeUntilFn(D2), !!this._attemptStrCaseInsensitive(e21 ? `${e21}:${t3}` : t3) && (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$GT))))), this._beginToken(i2.TAG_CLOSE), this._requireCharCodeUntilFn((e22) => e22 === n2.$GT, 3), this._cursor.advance(), this._endToken([e21, t3]), this._handleFullNameStackForTagClose(e21, t3);
      }
      _consumeTagOpenStart(e21) {
        this._beginToken(i2.TAG_OPEN_START, e21);
        const t3 = this._consumePrefixAndName();
        return this._endToken(t3);
      }
      _consumeAttributeName() {
        const e21 = this._cursor.peek();
        if (e21 === n2.$SQ || e21 === n2.$DQ)
          throw this._createError(c2(e21), this._cursor.getSpan());
        this._beginToken(i2.ATTR_NAME);
        const t3 = this._consumePrefixAndName();
        return this._endToken(t3), t3;
      }
      _consumeAttributeValue() {
        let e21;
        if (this._cursor.peek() === n2.$SQ || this._cursor.peek() === n2.$DQ) {
          this._beginToken(i2.ATTR_QUOTE);
          const t3 = this._cursor.peek();
          this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]), this._beginToken(i2.ATTR_VALUE);
          const r2 = [];
          for (; this._cursor.peek() !== t3; )
            r2.push(this._readChar(true));
          e21 = this._processCarriageReturns(r2.join("")), this._endToken([e21]), this._beginToken(i2.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]);
        } else {
          this._beginToken(i2.ATTR_VALUE);
          const t3 = this._cursor.clone();
          this._requireCharCodeUntilFn(f2, 1), e21 = this._processCarriageReturns(this._cursor.getChars(t3)), this._endToken([e21]);
        }
        return e21;
      }
      _consumeTagOpenEnd() {
        const e21 = this._attemptCharCode(n2.$SLASH) ? i2.TAG_OPEN_END_VOID : i2.TAG_OPEN_END;
        this._beginToken(e21), this._requireCharCode(n2.$GT), this._endToken([]);
      }
      _consumeTagClose(e21) {
        if (this._beginToken(i2.TAG_CLOSE, e21), this._attemptCharCodeUntilFn(D2), this._allowHtmComponentClosingTags && this._attemptCharCode(n2.$SLASH))
          this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([]);
        else {
          const [e22, t3] = this._consumePrefixAndName();
          this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([e22, t3]), this._handleFullNameStackForTagClose(e22, t3);
        }
      }
      _consumeExpansionFormStart() {
        this._beginToken(i2.EXPANSION_FORM_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._expansionCaseStack.push(i2.EXPANSION_FORM_START), this._beginToken(i2.RAW_TEXT);
        const e21 = this._readUntil(n2.$COMMA);
        this._endToken([e21]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.RAW_TEXT);
        const t3 = this._readUntil(n2.$COMMA);
        this._endToken([t3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2);
      }
      _consumeExpansionCaseStart() {
        this._beginToken(i2.EXPANSION_CASE_VALUE);
        const e21 = this._readUntil(n2.$LBRACE).trim();
        this._endToken([e21]), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.EXPANSION_CASE_EXP_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.push(i2.EXPANSION_CASE_EXP_START);
      }
      _consumeExpansionCaseEnd() {
        this._beginToken(i2.EXPANSION_CASE_EXP_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.pop();
      }
      _consumeExpansionFormEnd() {
        this._beginToken(i2.EXPANSION_FORM_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
      }
      _consumeText() {
        const e21 = this._cursor.clone();
        this._beginToken(i2.TEXT, e21);
        const t3 = [];
        do {
          this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t3.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t3.push(this._interpolationConfig.end), this._inInterpolation = false) : t3.push(this._readChar(true));
        } while (!this._isTextEnd());
        this._endToken([this._processCarriageReturns(t3.join(""))]);
      }
      _isTextEnd() {
        if (this._cursor.peek() === n2.$LT || this._cursor.peek() === n2.$EOF)
          return true;
        if (this._tokenizeIcu && !this._inInterpolation) {
          if (this.isExpansionFormStart())
            return true;
          if (this._cursor.peek() === n2.$RBRACE && this._isInExpansionCase())
            return true;
        }
        return false;
      }
      _readUntil(e21) {
        const t3 = this._cursor.clone();
        return this._attemptUntilChar(e21), this._cursor.getChars(t3);
      }
      _isInExpansionCase() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_CASE_EXP_START;
      }
      _isInExpansionForm() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_FORM_START;
      }
      isExpansionFormStart() {
        if (this._cursor.peek() !== n2.$LBRACE)
          return false;
        if (this._interpolationConfig) {
          const e21 = this._cursor.clone(), t3 = this._attemptStr(this._interpolationConfig.start);
          return this._cursor = e21, !t3;
        }
        return true;
      }
      _handleFullNameStackForTagOpen(e21, t3) {
        const r2 = As.mergeNsAndName(e21, t3);
        this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] !== r2 || this._fullNameStack.push(r2);
      }
      _handleFullNameStackForTagClose(e21, t3) {
        const r2 = As.mergeNsAndName(e21, t3);
        this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r2 && this._fullNameStack.pop();
      }
    }
    function D2(e21) {
      return !n2.isWhitespace(e21) || e21 === n2.$EOF;
    }
    function f2(e21) {
      return n2.isWhitespace(e21) || e21 === n2.$GT || e21 === n2.$SLASH || e21 === n2.$SQ || e21 === n2.$DQ || e21 === n2.$EQ;
    }
    function d2(e21) {
      return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiHexDigit(e21);
    }
    function g2(e21) {
      return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiLetter(e21);
    }
    function m2(e21) {
      return e21 >= n2.$a && e21 <= n2.$z ? e21 - n2.$a + n2.$A : e21;
    }
    class E2 {
      constructor(e21, t3) {
        if (e21 instanceof E2)
          this.file = e21.file, this.input = e21.input, this.end = e21.end, this.state = Object.assign({}, e21.state);
        else {
          if (!t3)
            throw new Error("Programming error: the range argument must be provided with a file argument.");
          this.file = e21, this.input = e21.content, this.end = t3.endPos, this.state = {peek: -1, offset: t3.startPos, line: t3.startLine, column: t3.startCol};
        }
      }
      clone() {
        return new E2(this);
      }
      peek() {
        return this.state.peek;
      }
      charsLeft() {
        return this.end - this.state.offset;
      }
      diff(e21) {
        return this.state.offset - e21.state.offset;
      }
      advance() {
        this.advanceState(this.state);
      }
      init() {
        this.updatePeek(this.state);
      }
      getSpan(e21, t3) {
        if (e21 = e21 || this, t3)
          for (e21 = e21.clone(); this.diff(e21) > 0 && t3.indexOf(e21.peek()) !== -1; )
            e21.advance();
        return new B$1.ParseSourceSpan(new B$1.ParseLocation(e21.file, e21.state.offset, e21.state.line, e21.state.column), new B$1.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
      }
      getChars(e21) {
        return this.input.substring(e21.state.offset, this.state.offset);
      }
      charAt(e21) {
        return this.input.charCodeAt(e21);
      }
      advanceState(e21) {
        if (e21.offset >= this.end)
          throw this.state = e21, new y2('Unexpected character "EOF"', this);
        const t3 = this.charAt(e21.offset);
        t3 === n2.$LF ? (e21.line++, e21.column = 0) : n2.isNewLine(t3) || e21.column++, e21.offset++, this.updatePeek(e21);
      }
      updatePeek(e21) {
        e21.peek = e21.offset >= this.end ? n2.$EOF : this.charAt(e21.offset);
      }
    }
    class C2 extends E2 {
      constructor(e21, t3) {
        e21 instanceof C2 ? (super(e21), this.internalState = Object.assign({}, e21.internalState)) : (super(e21, t3), this.internalState = this.state);
      }
      advance() {
        this.state = this.internalState, super.advance(), this.processEscapeSequence();
      }
      init() {
        super.init(), this.processEscapeSequence();
      }
      clone() {
        return new C2(this);
      }
      getChars(e21) {
        const t3 = e21.clone();
        let r2 = "";
        for (; t3.internalState.offset < this.internalState.offset; )
          r2 += String.fromCodePoint(t3.peek()), t3.advance();
        return r2;
      }
      processEscapeSequence() {
        const e21 = () => this.internalState.peek;
        if (e21() === n2.$BACKSLASH)
          if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), e21() === n2.$n)
            this.state.peek = n2.$LF;
          else if (e21() === n2.$r)
            this.state.peek = n2.$CR;
          else if (e21() === n2.$v)
            this.state.peek = n2.$VTAB;
          else if (e21() === n2.$t)
            this.state.peek = n2.$TAB;
          else if (e21() === n2.$b)
            this.state.peek = n2.$BSPACE;
          else if (e21() === n2.$f)
            this.state.peek = n2.$FF;
          else if (e21() === n2.$u)
            if (this.advanceState(this.internalState), e21() === n2.$LBRACE) {
              this.advanceState(this.internalState);
              const t3 = this.clone();
              let r2 = 0;
              for (; e21() !== n2.$RBRACE; )
                this.advanceState(this.internalState), r2++;
              this.state.peek = this.decodeHexDigits(t3, r2);
            } else {
              const e22 = this.clone();
              this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 4);
            }
          else if (e21() === n2.$x) {
            this.advanceState(this.internalState);
            const e22 = this.clone();
            this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 2);
          } else if (n2.isOctalDigit(e21())) {
            let t3 = "", r2 = 0, i3 = this.clone();
            for (; n2.isOctalDigit(e21()) && r2 < 3; )
              i3 = this.clone(), t3 += String.fromCodePoint(e21()), this.advanceState(this.internalState), r2++;
            this.state.peek = parseInt(t3, 8), this.internalState = i3.internalState;
          } else
            n2.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
      }
      decodeHexDigits(e21, t3) {
        const r2 = this.input.substr(e21.internalState.offset, t3), n3 = parseInt(r2, 16);
        if (isNaN(n3))
          throw e21.state = e21.internalState, new y2("Invalid hexadecimal escape sequence", e21);
        return n3;
      }
    }
    class y2 {
      constructor(e21, t3) {
        this.msg = e21, this.cursor = t3;
      }
    }
    t2.CursorError = y2;
  });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class no extends B$1.ParseError {
    constructor(e20, t2, r2) {
      super(t2, r2), this.elementName = e20;
    }
    static create(e20, t2, r2) {
      return new no(e20, t2, r2);
    }
  }
  var io = no;
  class so {
    constructor(e20, t2) {
      this.rootNodes = e20, this.errors = t2;
    }
  }
  var oo = so;
  var ao = class {
    constructor(e20) {
      this.getTagDefinition = e20;
    }
    parse(e20, t2, r2, n2 = false, i2) {
      const s2 = (e21) => (t3, ...r3) => e21(t3.toLowerCase(), ...r3), o2 = n2 ? this.getTagDefinition : s2(this.getTagDefinition), a2 = (e21) => o2(e21).contentType, u2 = n2 ? i2 : s2(i2), c2 = i2 ? (e21, t3, r3, n3) => {
        const i3 = u2(e21, t3, r3, n3);
        return i3 !== void 0 ? i3 : a2(e21);
      } : a2, l2 = ro.tokenize(e20, t2, c2, r2), p2 = r2 && r2.canSelfClose || false, h2 = r2 && r2.allowHtmComponentClosingTags || false, D2 = new uo(l2.tokens, o2, p2, h2, n2).build();
      return new so(D2.rootNodes, l2.errors.concat(D2.errors));
    }
  };
  class uo {
    constructor(e20, t2, r2, n2, i2) {
      this.tokens = e20, this.getTagDefinition = t2, this.canSelfClose = r2, this.allowHtmComponentClosingTags = n2, this.isTagNameCaseSensitive = i2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
    }
    build() {
      for (; this._peek.type !== ro.TokenType.EOF; )
        this._peek.type === ro.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === ro.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === ro.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === ro.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === ro.TokenType.TEXT || this._peek.type === ro.TokenType.RAW_TEXT || this._peek.type === ro.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === ro.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === ro.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
      return new so(this._rootNodes, this._errors);
    }
    _advance() {
      const e20 = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e20;
    }
    _advanceIf(e20) {
      return this._peek.type === e20 ? this._advance() : null;
    }
    _consumeCdata(e20) {
      const t2 = this._advance(), r2 = this._getText(t2), n2 = this._advanceIf(ro.TokenType.CDATA_END);
      this._addToParent(new Qs.CDATA(r2, new B$1.ParseSourceSpan(e20.sourceSpan.start, (n2 || t2).sourceSpan.end)));
    }
    _consumeComment(e20) {
      const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.COMMENT_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
      this._addToParent(new Qs.Comment(n2, i2));
    }
    _consumeDocType(e20) {
      const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.DOC_TYPE_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
      this._addToParent(new Qs.DocType(n2, i2));
    }
    _consumeExpansion(e20) {
      const t2 = this._advance(), r2 = this._advance(), n2 = [];
      for (; this._peek.type === ro.TokenType.EXPANSION_CASE_VALUE; ) {
        const e21 = this._parseExpansionCase();
        if (!e21)
          return;
        n2.push(e21);
      }
      if (this._peek.type !== ro.TokenType.EXPANSION_FORM_END)
        return void this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      const i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new Qs.Expansion(t2.parts[0], r2.parts[0], n2, i2, t2.sourceSpan)), this._advance();
    }
    _parseExpansionCase() {
      const e20 = this._advance();
      if (this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START)
        return this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      const t2 = this._advance(), r2 = this._collectExpansionExpTokens(t2);
      if (!r2)
        return null;
      const n2 = this._advance();
      r2.push(new ro.Token(ro.TokenType.EOF, [], n2.sourceSpan));
      const i2 = new uo(r2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
      if (i2.errors.length > 0)
        return this._errors = this._errors.concat(i2.errors), null;
      const s2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, n2.sourceSpan.end), o2 = new B$1.ParseSourceSpan(t2.sourceSpan.start, n2.sourceSpan.end);
      return new Qs.ExpansionCase(e20.parts[0], i2.rootNodes, s2, e20.sourceSpan, o2);
    }
    _collectExpansionExpTokens(e20) {
      const t2 = [], r2 = [ro.TokenType.EXPANSION_CASE_EXP_START];
      for (; ; ) {
        if (this._peek.type !== ro.TokenType.EXPANSION_FORM_START && this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START || r2.push(this._peek.type), this._peek.type === ro.TokenType.EXPANSION_CASE_EXP_END) {
          if (!co(r2, ro.TokenType.EXPANSION_CASE_EXP_START))
            return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
          if (r2.pop(), r2.length == 0)
            return t2;
        }
        if (this._peek.type === ro.TokenType.EXPANSION_FORM_END) {
          if (!co(r2, ro.TokenType.EXPANSION_FORM_START))
            return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
          r2.pop();
        }
        if (this._peek.type === ro.TokenType.EOF)
          return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        t2.push(this._advance());
      }
    }
    _getText(e20) {
      let t2 = e20.parts[0];
      if (t2.length > 0 && t2[0] == "\n") {
        const e21 = this._getParentElement();
        e21 != null && e21.children.length == 0 && this.getTagDefinition(e21.name).ignoreFirstLf && (t2 = t2.substring(1));
      }
      return t2;
    }
    _consumeText(e20) {
      const t2 = this._getText(e20);
      t2.length > 0 && this._addToParent(new Qs.Text(t2, e20.sourceSpan));
    }
    _closeVoidElement() {
      const e20 = this._getParentElement();
      e20 && this.getTagDefinition(e20.name).isVoid && this._elementStack.pop();
    }
    _consumeStartTag(e20) {
      const t2 = e20.parts[0], r2 = e20.parts[1], n2 = [];
      for (; this._peek.type === ro.TokenType.ATTR_NAME; )
        n2.push(this._consumeAttr(this._advance()));
      const i2 = this._getElementFullName(t2, r2, this._getParentElement());
      let s2 = false;
      if (this._peek.type === ro.TokenType.TAG_OPEN_END_VOID) {
        this._advance(), s2 = true;
        const t3 = this.getTagDefinition(i2);
        this.canSelfClose || t3.canSelfClose || As.getNsPrefix(i2) !== null || t3.isVoid || this._errors.push(no.create(i2, e20.sourceSpan, `Only void and foreign elements can be self closed "${e20.parts[1]}"`));
      } else
        this._peek.type === ro.TokenType.TAG_OPEN_END && (this._advance(), s2 = false);
      const o2 = this._peek.sourceSpan.start, a2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, o2), u2 = new B$1.ParseSourceSpan(e20.sourceSpan.start.moveBy(1), e20.sourceSpan.end), c2 = new Qs.Element(i2, n2, [], a2, a2, void 0, u2);
      this._pushElement(c2), s2 && (this._popElement(i2), c2.endSourceSpan = a2);
    }
    _pushElement(e20) {
      const t2 = this._getParentElement();
      t2 && this.getTagDefinition(t2.name).isClosedByChild(e20.name) && this._elementStack.pop(), this._addToParent(e20), this._elementStack.push(e20);
    }
    _consumeEndTag(e20) {
      const t2 = this.allowHtmComponentClosingTags && e20.parts.length === 0 ? null : this._getElementFullName(e20.parts[0], e20.parts[1], this._getParentElement());
      if (this._getParentElement() && (this._getParentElement().endSourceSpan = e20.sourceSpan), t2 && this.getTagDefinition(t2).isVoid)
        this._errors.push(no.create(t2, e20.sourceSpan, `Void elements do not have end tags "${e20.parts[1]}"`));
      else if (!this._popElement(t2)) {
        const r2 = `Unexpected closing tag "${t2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this._errors.push(no.create(t2, e20.sourceSpan, r2));
      }
    }
    _popElement(e20) {
      for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
        const r2 = this._elementStack[t2];
        if (!e20 || (As.getNsPrefix(r2.name) ? r2.name == e20 : r2.name.toLowerCase() == e20.toLowerCase()))
          return this._elementStack.splice(t2, this._elementStack.length - t2), true;
        if (!this.getTagDefinition(r2.name).closedByParent)
          return false;
      }
      return false;
    }
    _consumeAttr(e20) {
      const t2 = As.mergeNsAndName(e20.parts[0], e20.parts[1]);
      let r2, n2, i2 = e20.sourceSpan.end, s2 = "";
      if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
        n2 = this._advance().sourceSpan.start;
      }
      if (this._peek.type === ro.TokenType.ATTR_VALUE) {
        const e21 = this._advance();
        s2 = e21.parts[0], i2 = e21.sourceSpan.end, r2 = e21.sourceSpan;
      }
      if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
        i2 = this._advance().sourceSpan.end, r2 = new B$1.ParseSourceSpan(n2, i2);
      }
      return new Qs.Attribute(t2, s2, new B$1.ParseSourceSpan(e20.sourceSpan.start, i2), r2, e20.sourceSpan);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _getParentElementSkippingContainers() {
      let e20 = null;
      for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
        if (!As.isNgContainer(this._elementStack[t2].name))
          return {parent: this._elementStack[t2], container: e20};
        e20 = this._elementStack[t2];
      }
      return {parent: null, container: e20};
    }
    _addToParent(e20) {
      const t2 = this._getParentElement();
      t2 != null ? t2.children.push(e20) : this._rootNodes.push(e20);
    }
    _insertBeforeContainer(e20, t2, r2) {
      if (t2) {
        if (e20) {
          const n2 = e20.children.indexOf(t2);
          e20.children[n2] = r2;
        } else
          this._rootNodes.push(r2);
        r2.children.push(t2), this._elementStack.splice(this._elementStack.indexOf(t2), 0, r2);
      } else
        this._addToParent(r2), this._elementStack.push(r2);
    }
    _getElementFullName(e20, t2, r2) {
      return e20 === "" && (e20 = this.getTagDefinition(t2).implicitNamespacePrefix || "") === "" && r2 != null && (e20 = As.getNsPrefix(r2.name)), As.mergeNsAndName(e20, t2);
    }
  }
  function co(e20, t2) {
    return e20.length > 0 && e20[e20.length - 1] === t2;
  }
  var lo = Object.defineProperty({TreeError: io, ParseTreeResult: oo, Parser: ao}, "__esModule", {value: true}), po = lo, ho = po.ParseTreeResult, Do = po.TreeError;
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class fo extends lo.Parser {
    constructor() {
      super(xs.getHtmlTagDefinition);
    }
    parse(e20, t2, r2, n2 = false, i2) {
      return super.parse(e20, t2, r2, n2, i2);
    }
  }
  var go = fo, mo = Object.defineProperty({ParseTreeResult: ho, TreeError: Do, HtmlParser: go}, "__esModule", {value: true}), Eo = As.TagContentType;
  let Co = null;
  var yo = function(e20, t2 = {}) {
    const {canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2} = t2;
    return (Co || (Co = new mo.HtmlParser()), Co).parse(e20, "angular-html-parser", {tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2}, i2, s2);
  }, bo = Object.defineProperty({TagContentType: Eo, parse: yo}, "__esModule", {value: true});
  const {ParseSourceSpan: So, ParseLocation: To, ParseSourceFile: _o} = B$1, {inferParserByLanguage: vo} = $n, {HTML_ELEMENT_ATTRIBUTES: Ao, HTML_TAGS: Fo, isUnknownNamespace: wo} = fs, {hasPragma: ko} = ds, {Node: No} = bs, {parseIeConditionalComment: Oo} = _s, {locStart: xo, locEnd: Io} = vs;
  function Po(e20, {recognizeSelfClosing: t2, normalizeTagName: r2, normalizeAttributeName: n2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2}, a2) {
    const u2 = bo, {RecursiveVisitor: c2, visitAll: l2} = Qs, {ParseSourceSpan: p2} = B$1, {getHtmlTagDefinition: h2} = xs;
    let {rootNodes: D2, errors: f2} = u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2});
    if (a2.parser === "vue") {
      if (D2.some((e21) => e21.type === "docType" && e21.value === "html" || e21.type === "element" && e21.name.toLowerCase() === "html")) {
        t2 = true, r2 = true, n2 = true, i2 = true, s2 = false;
        const o3 = u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2});
        D2 = o3.rootNodes, f2 = o3.errors;
      } else {
        const r3 = (e21) => {
          if (!e21)
            return false;
          if (e21.type !== "element" || e21.name !== "template")
            return false;
          const t3 = e21.attrs.find((e22) => e22.name === "lang"), r4 = t3 && t3.value;
          return !r4 || vo(r4, a2) === "html";
        };
        if (D2.some(r3)) {
          let n3;
          const o3 = () => u2.parse(e20, {canSelfClose: t2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2}), a3 = () => n3 || (n3 = o3()), c3 = (e21) => a3().rootNodes.find(({startSourceSpan: t3}) => t3 && t3.start.offset === e21.startSourceSpan.start.offset);
          for (let e21 = 0; e21 < D2.length; e21++) {
            const t3 = D2[e21], {endSourceSpan: n4, startSourceSpan: i3} = t3;
            if (n4 === null) {
              f2 = a3().errors, D2[e21] = c3(t3) || t3;
            } else if (r3(t3)) {
              const r4 = a3(), s3 = i3.end.offset, o4 = n4.start.offset;
              for (const e22 of r4.errors) {
                const {offset: t4} = e22.span.start;
                if (s3 < t4 && t4 < o4) {
                  f2 = [e22];
                  break;
                }
              }
              D2[e21] = c3(t3) || t3;
            }
          }
        }
      }
    }
    if (f2.length > 0) {
      const {msg: e21, span: {start: t3, end: r3}} = f2[0];
      throw j$1(e21, {start: {line: t3.line + 1, column: t3.col + 1}, end: {line: r3.line + 1, column: r3.col + 1}});
    }
    const d2 = (e21) => {
      const t3 = e21.name.startsWith(":") ? e21.name.slice(1).split(":")[0] : null, r3 = e21.nameSpan.toString(), n3 = t3 !== null && r3.startsWith(`${t3}:`), i3 = n3 ? r3.slice(t3.length + 1) : r3;
      e21.name = i3, e21.namespace = t3, e21.hasExplicitNamespace = n3;
    }, g2 = (e21, t3) => {
      const r3 = e21.toLowerCase();
      return t3(r3) ? r3 : e21;
    };
    return l2(new class extends c2 {
      visit(e21) {
        ((e22) => {
          if (e22.type === "element") {
            d2(e22);
            for (const t3 of e22.attrs)
              d2(t3), t3.valueSpan ? (t3.value = t3.valueSpan.toString(), /["']/.test(t3.value[0]) && (t3.value = t3.value.slice(1, -1))) : t3.value = null;
          } else
            e22.type === "comment" ? e22.value = e22.sourceSpan.toString().slice("<!--".length, -"-->".length) : e22.type === "text" && (e22.value = e22.sourceSpan.toString());
        })(e21), ((e22) => {
          if (e22.type === "element") {
            const t3 = h2(s2 ? e22.name : e22.name.toLowerCase());
            !e22.namespace || e22.namespace === t3.implicitNamespacePrefix || wo(e22) ? e22.tagDefinition = t3 : e22.tagDefinition = h2("");
          }
        })(e21), ((e22) => {
          if (e22.type === "element" && (!r2 || e22.namespace && e22.namespace !== e22.tagDefinition.implicitNamespacePrefix && !wo(e22) || (e22.name = g2(e22.name, (e23) => e23 in Fo)), n2)) {
            const t3 = Ao[e22.name] || Object.create(null);
            for (const r3 of e22.attrs)
              r3.namespace || (r3.name = g2(r3.name, (r4) => e22.name in Ao && (r4 in Ao["*"] || r4 in t3)));
          }
        })(e21), ((e22) => {
          e22.sourceSpan && e22.endSourceSpan && (e22.sourceSpan = new p2(e22.sourceSpan.start, e22.endSourceSpan.end));
        })(e21);
      }
    }(), D2), D2;
  }
  function Ro(e20, t2, r2, n2 = true) {
    const {frontMatter: i2, content: s2} = n2 ? q$1(e20) : {frontMatter: null, content: e20}, o2 = new _o(e20, t2.filepath), a2 = new To(o2, 0, 0, 0), u2 = a2.moveBy(e20.length), c2 = {type: "root", sourceSpan: new So(a2, u2), children: Po(s2, r2, t2)};
    if (i2) {
      const e21 = new To(o2, 0, 0, 0), t3 = e21.moveBy(i2.raw.length);
      i2.sourceSpan = new So(e21, t3), c2.children.unshift(i2);
    }
    const l2 = new No(c2), p2 = (n3, i3) => {
      const {offset: s3} = i3, o3 = Ro(e20.slice(0, s3).replace(/[^\n\r]/g, " ") + n3, t2, r2, false);
      o3.sourceSpan = new So(i3, M$1(o3.children).sourceSpan.end);
      const a3 = o3.children[0];
      return a3.length === s3 ? o3.children.shift() : (a3.sourceSpan = new So(a3.sourceSpan.start.moveBy(s3), a3.sourceSpan.end), a3.value = a3.value.slice(s3)), o3;
    };
    return l2.map((e21) => {
      if (e21.type === "comment") {
        const t3 = Oo(e21, p2);
        if (t3)
          return t3;
      }
      return e21;
    });
  }
  function Lo({recognizeSelfClosing: e20 = false, normalizeTagName: t2 = false, normalizeAttributeName: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2} = {}) {
    return {parse: (o2, a2, u2) => Ro(o2, u2, {recognizeSelfClosing: e20, normalizeTagName: t2, normalizeAttributeName: r2, allowHtmComponentClosingTags: n2, isTagNameCaseSensitive: i2, getTagContentType: s2}), hasPragma: ko, astFormat: "html", locStart: xo, locEnd: Io};
  }
  var Bo = {parsers: {html: Lo({recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true}), angular: Lo(), vue: Lo({recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e20, t2, r2, n2) => {
    if (e20.toLowerCase() !== "html" && !r2 && (e20 !== "template" || n2.some(({name: e21, value: t3}) => e21 === "lang" && t3 !== "html")))
      return bo.TagContentType.RAW_TEXT;
  }}), lwc: Lo()}};
  var e19 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function t(e20) {
    return e20 && e20.__esModule && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
  }
  function r(e20) {
    var t2 = {exports: {}};
    return e20(t2, t2.exports), t2.exports;
  }
  var n, o, i = function(e20) {
    return e20 && e20.Math == Math && e20;
  }, s = i(typeof globalThis == "object" && globalThis) || i(typeof window == "object" && window) || i(typeof self == "object" && self) || i(typeof e19 == "object" && e19) || function() {
    return this;
  }() || Function("return this")(), u = function(e20) {
    try {
      return !!e20();
    } catch (e21) {
      return true;
    }
  }, a$4 = !u(function() {
    return Object.defineProperty({}, 1, {get: function() {
      return 7;
    }})[1] != 7;
  }), c = {}.propertyIsEnumerable, l = Object.getOwnPropertyDescriptor, f = {f: l && !c.call({1: 2}, 1) ? function(e20) {
    var t2 = l(this, e20);
    return !!t2 && t2.enumerable;
  } : c}, p = function(e20, t2) {
    return {enumerable: !(1 & e20), configurable: !(2 & e20), writable: !(4 & e20), value: t2};
  }, h = {}.toString, d$4 = function(e20) {
    return h.call(e20).slice(8, -1);
  }, D = "".split, g = u(function() {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function(e20) {
    return d$4(e20) == "String" ? D.call(e20, "") : Object(e20);
  } : Object, m = function(e20) {
    if (e20 == null)
      throw TypeError("Can't call method on " + e20);
    return e20;
  }, v = function(e20) {
    return g(m(e20));
  }, y = function(e20) {
    return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
  }, w = function(e20) {
    return typeof e20 == "function" ? e20 : void 0;
  }, b = function(e20, t2) {
    return arguments.length < 2 ? w(s[e20]) : s[e20] && s[e20][t2];
  }, C = b("navigator", "userAgent") || "", E = s.process, F = s.Deno, x = E && E.versions || F && F.version, A = x && x.v8;
  A ? o = (n = A.split("."))[0] < 4 ? 1 : n[0] + n[1] : C && (!(n = C.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = C.match(/Chrome\/(\d+)/)) && (o = n[1]);
  var k$4 = o && +o, O = !!Object.getOwnPropertySymbols && !u(function() {
    var e20 = Symbol();
    return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && k$4 && k$4 < 41;
  }), _ = O && !Symbol.sham && typeof Symbol.iterator == "symbol", S = _ ? function(e20) {
    return typeof e20 == "symbol";
  } : function(e20) {
    var t2 = b("Symbol");
    return typeof t2 == "function" && Object(e20) instanceof t2;
  }, T = function(e20, t2) {
    try {
      Object.defineProperty(s, e20, {value: t2, configurable: true, writable: true});
    } catch (r2) {
      s[e20] = t2;
    }
    return t2;
  }, I = s["__core-js_shared__"] || T("__core-js_shared__", {}), N = r(function(e20) {
    (e20.exports = function(e21, t2) {
      return I[e21] || (I[e21] = t2 !== void 0 ? t2 : {});
    })("versions", []).push({version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
  }), M = function(e20) {
    return Object(m(e20));
  }, R = {}.hasOwnProperty, j$4 = Object.hasOwn || function(e20, t2) {
    return R.call(M(e20), t2);
  }, L = 0, B = Math.random(), P = function(e20) {
    return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++L + B).toString(36);
  }, $ = N("wks"), U = s.Symbol, G = _ ? U : U && U.withoutSetter || P, W = function(e20) {
    return j$4($, e20) && (O || typeof $[e20] == "string") || (O && j$4(U, e20) ? $[e20] = U[e20] : $[e20] = G("Symbol." + e20)), $[e20];
  }, z = W("toPrimitive"), V = function(e20, t2) {
    if (!y(e20) || S(e20))
      return e20;
    var r2, n2 = e20[z];
    if (n2 !== void 0) {
      if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !y(r2) || S(r2))
        return r2;
      throw TypeError("Can't convert object to primitive value");
    }
    return t2 === void 0 && (t2 = "number"), function(e21, t3) {
      var r3, n3;
      if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
        return n3;
      if (typeof (r3 = e21.valueOf) == "function" && !y(n3 = r3.call(e21)))
        return n3;
      if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
        return n3;
      throw TypeError("Can't convert object to primitive value");
    }(e20, t2);
  }, q = function(e20) {
    var t2 = V(e20, "string");
    return S(t2) ? t2 : String(t2);
  }, X = s.document, J = y(X) && y(X.createElement), H = !a$4 && !u(function() {
    return Object.defineProperty((e20 = "div", J ? X.createElement(e20) : {}), "a", {get: function() {
      return 7;
    }}).a != 7;
    var e20;
  }), Y = Object.getOwnPropertyDescriptor, K = {f: a$4 ? Y : function(e20, t2) {
    if (e20 = v(e20), t2 = q(t2), H)
      try {
        return Y(e20, t2);
      } catch (e21) {
      }
    if (j$4(e20, t2))
      return p(!f.f.call(e20, t2), e20[t2]);
  }}, Z = function(e20) {
    if (!y(e20))
      throw TypeError(String(e20) + " is not an object");
    return e20;
  }, Q = Object.defineProperty, ee = {f: a$4 ? Q : function(e20, t2, r2) {
    if (Z(e20), t2 = q(t2), Z(r2), H)
      try {
        return Q(e20, t2, r2);
      } catch (e21) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e20[t2] = r2.value), e20;
  }}, te = a$4 ? function(e20, t2, r2) {
    return ee.f(e20, t2, p(1, r2));
  } : function(e20, t2, r2) {
    return e20[t2] = r2, e20;
  }, re = Function.toString;
  typeof I.inspectSource != "function" && (I.inspectSource = function(e20) {
    return re.call(e20);
  });
  var ne, oe, ie, se, ue = I.inspectSource, ae = s.WeakMap, ce = typeof ae == "function" && /native code/.test(ue(ae)), le = N("keys"), fe = {}, pe = s.WeakMap;
  if (ce || I.state) {
    var he = I.state || (I.state = new pe()), de = he.get, De = he.has, ge = he.set;
    ne = function(e20, t2) {
      if (De.call(he, e20))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, ge.call(he, e20, t2), t2;
    }, oe = function(e20) {
      return de.call(he, e20) || {};
    }, ie = function(e20) {
      return De.call(he, e20);
    };
  } else {
    var me = le[se = "state"] || (le[se] = P(se));
    fe[me] = true, ne = function(e20, t2) {
      if (j$4(e20, me))
        throw new TypeError("Object already initialized");
      return t2.facade = e20, te(e20, me, t2), t2;
    }, oe = function(e20) {
      return j$4(e20, me) ? e20[me] : {};
    }, ie = function(e20) {
      return j$4(e20, me);
    };
  }
  var ve, ye, we = {set: ne, get: oe, has: ie, enforce: function(e20) {
    return ie(e20) ? oe(e20) : ne(e20, {});
  }, getterFor: function(e20) {
    return function(t2) {
      var r2;
      if (!y(t2) || (r2 = oe(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return r2;
    };
  }}, be = r(function(e20) {
    var t2 = we.get, r2 = we.enforce, n2 = String(String).split("String");
    (e20.exports = function(e21, t3, o2, i2) {
      var u2, a2 = !!i2 && !!i2.unsafe, c2 = !!i2 && !!i2.enumerable, l2 = !!i2 && !!i2.noTargetGet;
      typeof o2 == "function" && (typeof t3 != "string" || j$4(o2, "name") || te(o2, "name", t3), (u2 = r2(o2)).source || (u2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== s ? (a2 ? !l2 && e21[t3] && (c2 = true) : delete e21[t3], c2 ? e21[t3] = o2 : te(e21, t3, o2)) : c2 ? e21[t3] = o2 : T(t3, o2);
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && t2(this).source || ue(this);
    });
  }), Ce = Math.ceil, Ee = Math.floor, Fe = function(e20) {
    return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Ee : Ce)(e20);
  }, xe = Math.min, Ae = function(e20) {
    return e20 > 0 ? xe(Fe(e20), 9007199254740991) : 0;
  }, ke = Math.max, Oe = Math.min, _e$4 = function(e20) {
    return function(t2, r2, n2) {
      var o2, i2 = v(t2), s2 = Ae(i2.length), u2 = function(e21, t3) {
        var r3 = Fe(e21);
        return r3 < 0 ? ke(r3 + t3, 0) : Oe(r3, t3);
      }(n2, s2);
      if (e20 && r2 != r2) {
        for (; s2 > u2; )
          if ((o2 = i2[u2++]) != o2)
            return true;
      } else
        for (; s2 > u2; u2++)
          if ((e20 || u2 in i2) && i2[u2] === r2)
            return e20 || u2 || 0;
      return !e20 && -1;
    };
  }, Se = {includes: _e$4(true), indexOf: _e$4(false)}.indexOf, Te = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), Ie = {f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var r2, n2 = v(e21), o2 = 0, i2 = [];
      for (r2 in n2)
        !j$4(fe, r2) && j$4(n2, r2) && i2.push(r2);
      for (; t2.length > o2; )
        j$4(n2, r2 = t2[o2++]) && (~Se(i2, r2) || i2.push(r2));
      return i2;
    }(e20, Te);
  }}, Ne = {f: Object.getOwnPropertySymbols}, Me = b("Reflect", "ownKeys") || function(e20) {
    var t2 = Ie.f(Z(e20)), r2 = Ne.f;
    return r2 ? t2.concat(r2(e20)) : t2;
  }, Re = function(e20, t2) {
    for (var r2 = Me(t2), n2 = ee.f, o2 = K.f, i2 = 0; i2 < r2.length; i2++) {
      var s2 = r2[i2];
      j$4(e20, s2) || n2(e20, s2, o2(t2, s2));
    }
  }, je = /#|\.prototype\./, Le = function(e20, t2) {
    var r2 = Pe[Be(e20)];
    return r2 == Ue || r2 != $e && (typeof t2 == "function" ? u(t2) : !!t2);
  }, Be = Le.normalize = function(e20) {
    return String(e20).replace(je, ".").toLowerCase();
  }, Pe = Le.data = {}, $e = Le.NATIVE = "N", Ue = Le.POLYFILL = "P", Ge = Le, We = K.f, ze = function(e20, t2) {
    var r2, n2, o2, i2, u2, a2 = e20.target, c2 = e20.global, l2 = e20.stat;
    if (r2 = c2 ? s : l2 ? s[a2] || T(a2, {}) : (s[a2] || {}).prototype)
      for (n2 in t2) {
        if (i2 = t2[n2], o2 = e20.noTargetGet ? (u2 = We(r2, n2)) && u2.value : r2[n2], !Ge(c2 ? n2 : a2 + (l2 ? "." : "#") + n2, e20.forced) && o2 !== void 0) {
          if (typeof i2 == typeof o2)
            continue;
          Re(i2, o2);
        }
        (e20.sham || o2 && o2.sham) && te(i2, "sham", true), be(r2, n2, i2, e20);
      }
  }, Ve = function(e20) {
    if (typeof e20 != "function")
      throw TypeError(String(e20) + " is not a function");
    return e20;
  }, qe = function(e20) {
    if (S(e20))
      throw TypeError("Cannot convert a Symbol value to a string");
    return String(e20);
  }, Xe = Math.floor, Je = function(e20, t2) {
    var r2 = e20.length, n2 = Xe(r2 / 2);
    return r2 < 8 ? He(e20, t2) : Ye(Je(e20.slice(0, n2), t2), Je(e20.slice(n2), t2), t2);
  }, He = function(e20, t2) {
    for (var r2, n2, o2 = e20.length, i2 = 1; i2 < o2; ) {
      for (n2 = i2, r2 = e20[i2]; n2 && t2(e20[n2 - 1], r2) > 0; )
        e20[n2] = e20[--n2];
      n2 !== i2++ && (e20[n2] = r2);
    }
    return e20;
  }, Ye = function(e20, t2, r2) {
    for (var n2 = e20.length, o2 = t2.length, i2 = 0, s2 = 0, u2 = []; i2 < n2 || s2 < o2; )
      i2 < n2 && s2 < o2 ? u2.push(r2(e20[i2], t2[s2]) <= 0 ? e20[i2++] : t2[s2++]) : u2.push(i2 < n2 ? e20[i2++] : t2[s2++]);
    return u2;
  }, Ke = Je, Ze = C.match(/firefox\/(\d+)/i), Qe = !!Ze && +Ze[1], et = /MSIE|Trident/.test(C), tt = C.match(/AppleWebKit\/(\d+)\./), rt = !!tt && +tt[1], nt = [], ot = nt.sort, it = u(function() {
    nt.sort(void 0);
  }), st = u(function() {
    nt.sort(null);
  }), ut = !!(ye = []["sort"]) && u(function() {
    ye.call(null, ve || function() {
      throw 1;
    }, 1);
  }), at = !u(function() {
    if (k$4)
      return k$4 < 70;
    if (!(Qe && Qe > 3)) {
      if (et)
        return true;
      if (rt)
        return rt < 603;
      var e20, t2, r2, n2, o2 = "";
      for (e20 = 65; e20 < 76; e20++) {
        switch (t2 = String.fromCharCode(e20), e20) {
          case 66:
          case 69:
          case 70:
          case 72:
            r2 = 3;
            break;
          case 68:
          case 71:
            r2 = 4;
            break;
          default:
            r2 = 2;
        }
        for (n2 = 0; n2 < 47; n2++)
          nt.push({k: t2 + n2, v: r2});
      }
      for (nt.sort(function(e21, t3) {
        return t3.v - e21.v;
      }), n2 = 0; n2 < nt.length; n2++)
        t2 = nt[n2].k.charAt(0), o2.charAt(o2.length - 1) !== t2 && (o2 += t2);
      return o2 !== "DGBEFHACIJK";
    }
  });
  ze({target: "Array", proto: true, forced: it || !st || !ut || !at}, {sort: function(e20) {
    e20 !== void 0 && Ve(e20);
    var t2 = M(this);
    if (at)
      return e20 === void 0 ? ot.call(t2) : ot.call(t2, e20);
    var r2, n2, o2 = [], i2 = Ae(t2.length);
    for (n2 = 0; n2 < i2; n2++)
      n2 in t2 && o2.push(t2[n2]);
    for (r2 = (o2 = Ke(o2, function(e21) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : qe(t3) > qe(r3) ? 1 : -1;
      };
    }(e20))).length, n2 = 0; n2 < r2; )
      t2[n2] = o2[n2++];
    for (; n2 < i2; )
      delete t2[n2++];
    return t2;
  }});
  var ct = Array.isArray || function(e20) {
    return d$4(e20) == "Array";
  }, lt = function(e20, t2, r2) {
    if (Ve(e20), t2 === void 0)
      return e20;
    switch (r2) {
      case 0:
        return function() {
          return e20.call(t2);
        };
      case 1:
        return function(r3) {
          return e20.call(t2, r3);
        };
      case 2:
        return function(r3, n2) {
          return e20.call(t2, r3, n2);
        };
      case 3:
        return function(r3, n2, o2) {
          return e20.call(t2, r3, n2, o2);
        };
    }
    return function() {
      return e20.apply(t2, arguments);
    };
  }, ft = function(e20, t2, r2, n2, o2, i2, s2, u2) {
    for (var a2, c2 = o2, l2 = 0, f2 = !!s2 && lt(s2, u2, 3); l2 < n2; ) {
      if (l2 in r2) {
        if (a2 = f2 ? f2(r2[l2], l2, t2) : r2[l2], i2 > 0 && ct(a2))
          c2 = ft(e20, t2, a2, Ae(a2.length), c2, i2 - 1) - 1;
        else {
          if (c2 >= 9007199254740991)
            throw TypeError("Exceed the acceptable array length");
          e20[c2] = a2;
        }
        c2++;
      }
      l2++;
    }
    return c2;
  }, pt = ft, ht = W("species"), dt = function(e20, t2) {
    return new (function(e21) {
      var t3;
      return ct(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !ct(t3.prototype) ? y(t3) && (t3 = t3[ht]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
    }(e20))(t2 === 0 ? 0 : t2);
  };
  ze({target: "Array", proto: true}, {flatMap: function(e20) {
    var t2, r2 = M(this), n2 = Ae(r2.length);
    return Ve(e20), (t2 = dt(r2, 0)).length = pt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }});
  var Dt = {}, gt = W("iterator"), mt = Array.prototype, vt = {};
  vt[W("toStringTag")] = "z";
  var yt = String(vt) === "[object z]", wt = W("toStringTag"), bt = d$4(function() {
    return arguments;
  }()) == "Arguments", Ct = yt ? d$4 : function(e20) {
    var t2, r2, n2;
    return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
      try {
        return e21[t3];
      } catch (e22) {
      }
    }(t2 = Object(e20), wt)) == "string" ? r2 : bt ? d$4(t2) : (n2 = d$4(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
  }, Et = W("iterator"), Ft = function(e20) {
    if (e20 != null)
      return e20[Et] || e20["@@iterator"] || Dt[Ct(e20)];
  }, xt = function(e20, t2, r2) {
    var n2, o2;
    Z(e20);
    try {
      if ((n2 = e20.return) === void 0) {
        if (t2 === "throw")
          throw r2;
        return r2;
      }
      n2 = n2.call(e20);
    } catch (e21) {
      o2 = true, n2 = e21;
    }
    if (t2 === "throw")
      throw r2;
    if (o2)
      throw n2;
    return Z(n2), r2;
  }, At = function(e20, t2) {
    this.stopped = e20, this.result = t2;
  }, kt = function(e20, t2, r2) {
    var n2, o2, i2, s2, u2, a2, c2, l2, f2 = r2 && r2.that, p2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), d2 = !(!r2 || !r2.INTERRUPTED), D2 = lt(t2, f2, 1 + p2 + d2), g2 = function(e21) {
      return n2 && xt(n2, "normal", e21), new At(true, e21);
    }, m2 = function(e21) {
      return p2 ? (Z(e21), d2 ? D2(e21[0], e21[1], g2) : D2(e21[0], e21[1])) : d2 ? D2(e21, g2) : D2(e21);
    };
    if (h2)
      n2 = e20;
    else {
      if (typeof (o2 = Ft(e20)) != "function")
        throw TypeError("Target is not iterable");
      if ((l2 = o2) !== void 0 && (Dt.Array === l2 || mt[gt] === l2)) {
        for (i2 = 0, s2 = Ae(e20.length); s2 > i2; i2++)
          if ((u2 = m2(e20[i2])) && u2 instanceof At)
            return u2;
        return new At(false);
      }
      n2 = function(e21, t3) {
        var r3 = arguments.length < 2 ? Ft(e21) : t3;
        if (typeof r3 != "function")
          throw TypeError(String(e21) + " is not iterable");
        return Z(r3.call(e21));
      }(e20, o2);
    }
    for (a2 = n2.next; !(c2 = a2.call(n2)).done; ) {
      try {
        u2 = m2(c2.value);
      } catch (e21) {
        xt(n2, "throw", e21);
      }
      if (typeof u2 == "object" && u2 && u2 instanceof At)
        return u2;
    }
    return new At(false);
  };
  ze({target: "Object", stat: true}, {fromEntries: function(e20) {
    var t2 = {};
    return kt(e20, function(e21, r2) {
      !function(e22, t3, r3) {
        var n2 = q(t3);
        n2 in e22 ? ee.f(e22, n2, p(0, r3)) : e22[n2] = r3;
      }(t2, e21, r2);
    }, {AS_ENTRIES: true}), t2;
  }});
  var Ot = t(r(function(e20, t2) {
    new Function("return this")(), e20.exports = (() => {
      var e21 = {2426: (e22) => {
        e22.exports = ({onlyFirst: e23 = false} = {}) => {
          const t4 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t4, e23 ? void 0 : "g");
        };
      }, 118: (e22) => {
        e22.exports = function(e23) {
          if (typeof e23 != "function")
            throw TypeError(String(e23) + " is not a function");
          return e23;
        };
      }, 6956: (e22, t4, r3) => {
        var n2 = r3(2521);
        e22.exports = function(e23) {
          if (!n2(e23))
            throw TypeError(String(e23) + " is not an object");
          return e23;
        };
      }, 9729: (e22, t4, r3) => {
        var n2 = r3(9969), o2 = r3(8331), i2 = r3(1588), s2 = function(e23) {
          return function(t5, r4, s3) {
            var u2, a2 = n2(t5), c2 = o2(a2.length), l2 = i2(s3, c2);
            if (e23 && r4 != r4) {
              for (; c2 > l2; )
                if ((u2 = a2[l2++]) != u2)
                  return true;
            } else
              for (; c2 > l2; l2++)
                if ((e23 || l2 in a2) && a2[l2] === r4)
                  return e23 || l2 || 0;
            return !e23 && -1;
          };
        };
        e22.exports = {includes: s2(true), indexOf: s2(false)};
      }, 9719: (e22, t4, r3) => {
        var n2 = r3(2763);
        e22.exports = function(e23, t5) {
          var r4 = [][e23];
          return !!r4 && n2(function() {
            r4.call(null, t5 || function() {
              throw 1;
            }, 1);
          });
        };
      }, 3407: (e22) => {
        var t4 = Math.floor, r3 = function(e23, i2) {
          var s2 = e23.length, u2 = t4(s2 / 2);
          return s2 < 8 ? n2(e23, i2) : o2(r3(e23.slice(0, u2), i2), r3(e23.slice(u2), i2), i2);
        }, n2 = function(e23, t5) {
          for (var r4, n3, o3 = e23.length, i2 = 1; i2 < o3; ) {
            for (n3 = i2, r4 = e23[i2]; n3 && t5(e23[n3 - 1], r4) > 0; )
              e23[n3] = e23[--n3];
            n3 !== i2++ && (e23[n3] = r4);
          }
          return e23;
        }, o2 = function(e23, t5, r4) {
          for (var n3 = e23.length, o3 = t5.length, i2 = 0, s2 = 0, u2 = []; i2 < n3 || s2 < o3; )
            i2 < n3 && s2 < o3 ? u2.push(r4(e23[i2], t5[s2]) <= 0 ? e23[i2++] : t5[s2++]) : u2.push(i2 < n3 ? e23[i2++] : t5[s2++]);
          return u2;
        };
        e22.exports = r3;
      }, 2021: (e22, t4, r3) => {
        var n2 = r3(2521), o2 = r3(3964), i2 = r3(1386)("species");
        e22.exports = function(e23) {
          var t5;
          return o2(e23) && (typeof (t5 = e23.constructor) != "function" || t5 !== Array && !o2(t5.prototype) ? n2(t5) && (t5 = t5[i2]) === null && (t5 = void 0) : t5 = void 0), t5 === void 0 ? Array : t5;
        };
      }, 8347: (e22, t4, r3) => {
        var n2 = r3(2021);
        e22.exports = function(e23, t5) {
          return new (n2(e23))(t5 === 0 ? 0 : t5);
        };
      }, 2849: (e22) => {
        var t4 = {}.toString;
        e22.exports = function(e23) {
          return t4.call(e23).slice(8, -1);
        };
      }, 9538: (e22, t4, r3) => {
        var n2 = r3(6395), o2 = r3(2849), i2 = r3(1386)("toStringTag"), s2 = o2(function() {
          return arguments;
        }()) == "Arguments";
        e22.exports = n2 ? o2 : function(e23) {
          var t5, r4, n3;
          return e23 === void 0 ? "Undefined" : e23 === null ? "Null" : typeof (r4 = function(e24, t6) {
            try {
              return e24[t6];
            } catch (e25) {
            }
          }(t5 = Object(e23), i2)) == "string" ? r4 : s2 ? o2(t5) : (n3 = o2(t5)) == "Object" && typeof t5.callee == "function" ? "Arguments" : n3;
        };
      }, 4488: (e22, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9593), i2 = r3(8769), s2 = r3(7455);
        e22.exports = function(e23, t5) {
          for (var r4 = o2(t5), u2 = s2.f, a2 = i2.f, c2 = 0; c2 < r4.length; c2++) {
            var l2 = r4[c2];
            n2(e23, l2) || u2(e23, l2, a2(t5, l2));
          }
        };
      }, 1471: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7455), i2 = r3(5938);
        e22.exports = n2 ? function(e23, t5, r4) {
          return o2.f(e23, t5, i2(1, r4));
        } : function(e23, t5, r4) {
          return e23[t5] = r4, e23;
        };
      }, 5938: (e22) => {
        e22.exports = function(e23, t4) {
          return {enumerable: !(1 & e23), configurable: !(2 & e23), writable: !(4 & e23), value: t4};
        };
      }, 2385: (e22, t4, r3) => {
        var n2 = r3(5224), o2 = r3(7455), i2 = r3(5938);
        e22.exports = function(e23, t5, r4) {
          var s2 = n2(t5);
          s2 in e23 ? o2.f(e23, s2, i2(0, r4)) : e23[s2] = r4;
        };
      }, 7703: (e22, t4, r3) => {
        var n2 = r3(2763);
        e22.exports = !n2(function() {
          return Object.defineProperty({}, 1, {get: function() {
            return 7;
          }})[1] != 7;
        });
      }, 6004: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(2521), i2 = n2.document, s2 = o2(i2) && o2(i2.createElement);
        e22.exports = function(e23) {
          return s2 ? i2.createElement(e23) : {};
        };
      }, 5249: (e22, t4, r3) => {
        var n2 = r3(8635).match(/firefox\/(\d+)/i);
        e22.exports = !!n2 && +n2[1];
      }, 2049: (e22, t4, r3) => {
        var n2 = r3(8635);
        e22.exports = /MSIE|Trident/.test(n2);
      }, 8635: (e22, t4, r3) => {
        var n2 = r3(7642);
        e22.exports = n2("navigator", "userAgent") || "";
      }, 6962: (e22, t4, r3) => {
        var n2, o2, i2 = r3(6121), s2 = r3(8635), u2 = i2.process, a2 = i2.Deno, c2 = u2 && u2.versions || a2 && a2.version, l2 = c2 && c2.v8;
        l2 ? o2 = (n2 = l2.split("."))[0] < 4 ? 1 : n2[0] + n2[1] : s2 && (!(n2 = s2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = s2.match(/Chrome\/(\d+)/)) && (o2 = n2[1]), e22.exports = o2 && +o2;
      }, 8998: (e22, t4, r3) => {
        var n2 = r3(8635).match(/AppleWebKit\/(\d+)\./);
        e22.exports = !!n2 && +n2[1];
      }, 4731: (e22) => {
        e22.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, 7309: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(8769).f, i2 = r3(1471), s2 = r3(2327), u2 = r3(6565), a2 = r3(4488), c2 = r3(676);
        e22.exports = function(e23, t5) {
          var r4, l2, f2, p2, h2, d2 = e23.target, D2 = e23.global, g2 = e23.stat;
          if (r4 = D2 ? n2 : g2 ? n2[d2] || u2(d2, {}) : (n2[d2] || {}).prototype)
            for (l2 in t5) {
              if (p2 = t5[l2], f2 = e23.noTargetGet ? (h2 = o2(r4, l2)) && h2.value : r4[l2], !c2(D2 ? l2 : d2 + (g2 ? "." : "#") + l2, e23.forced) && f2 !== void 0) {
                if (typeof p2 == typeof f2)
                  continue;
                a2(p2, f2);
              }
              (e23.sham || f2 && f2.sham) && i2(p2, "sham", true), s2(r4, l2, p2, e23);
            }
        };
      }, 2763: (e22) => {
        e22.exports = function(e23) {
          try {
            return !!e23();
          } catch (e24) {
            return true;
          }
        };
      }, 5538: (e22, t4, r3) => {
        var n2 = r3(3964), o2 = r3(8331), i2 = r3(3322), s2 = function(e23, t5, r4, u2, a2, c2, l2, f2) {
          for (var p2, h2 = a2, d2 = 0, D2 = !!l2 && i2(l2, f2, 3); d2 < u2; ) {
            if (d2 in r4) {
              if (p2 = D2 ? D2(r4[d2], d2, t5) : r4[d2], c2 > 0 && n2(p2))
                h2 = s2(e23, t5, p2, o2(p2.length), h2, c2 - 1) - 1;
              else {
                if (h2 >= 9007199254740991)
                  throw TypeError("Exceed the acceptable array length");
                e23[h2] = p2;
              }
              h2++;
            }
            d2++;
          }
          return h2;
        };
        e22.exports = s2;
      }, 3322: (e22, t4, r3) => {
        var n2 = r3(118);
        e22.exports = function(e23, t5, r4) {
          if (n2(e23), t5 === void 0)
            return e23;
          switch (r4) {
            case 0:
              return function() {
                return e23.call(t5);
              };
            case 1:
              return function(r5) {
                return e23.call(t5, r5);
              };
            case 2:
              return function(r5, n3) {
                return e23.call(t5, r5, n3);
              };
            case 3:
              return function(r5, n3, o2) {
                return e23.call(t5, r5, n3, o2);
              };
          }
          return function() {
            return e23.apply(t5, arguments);
          };
        };
      }, 7642: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = function(e23) {
          return typeof e23 == "function" ? e23 : void 0;
        };
        e22.exports = function(e23, t5) {
          return arguments.length < 2 ? o2(n2[e23]) : n2[e23] && n2[e23][t5];
        };
      }, 5111: (e22, t4, r3) => {
        var n2 = r3(9538), o2 = r3(3403), i2 = r3(1386)("iterator");
        e22.exports = function(e23) {
          if (e23 != null)
            return e23[i2] || e23["@@iterator"] || o2[n2(e23)];
        };
      }, 8977: (e22, t4, r3) => {
        var n2 = r3(6956), o2 = r3(5111);
        e22.exports = function(e23, t5) {
          var r4 = arguments.length < 2 ? o2(e23) : t5;
          if (typeof r4 != "function")
            throw TypeError(String(e23) + " is not iterable");
          return n2(r4.call(e23));
        };
      }, 6121: (e22, t4, r3) => {
        var n2 = function(e23) {
          return e23 && e23.Math == Math && e23;
        };
        e22.exports = n2(typeof globalThis == "object" && globalThis) || n2(typeof window == "object" && window) || n2(typeof self == "object" && self) || n2(typeof r3.g == "object" && r3.g) || function() {
          return this;
        }() || Function("return this")();
      }, 2766: (e22, t4, r3) => {
        var n2 = r3(4766), o2 = {}.hasOwnProperty;
        e22.exports = Object.hasOwn || function(e23, t5) {
          return o2.call(n2(e23), t5);
        };
      }, 2048: (e22) => {
        e22.exports = {};
      }, 7226: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(2763), i2 = r3(6004);
        e22.exports = !n2 && !o2(function() {
          return Object.defineProperty(i2("div"), "a", {get: function() {
            return 7;
          }}).a != 7;
        });
      }, 3169: (e22, t4, r3) => {
        var n2 = r3(2763), o2 = r3(2849), i2 = "".split;
        e22.exports = n2(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e23) {
          return o2(e23) == "String" ? i2.call(e23, "") : Object(e23);
        } : Object;
      }, 9835: (e22, t4, r3) => {
        var n2 = r3(4682), o2 = Function.toString;
        typeof n2.inspectSource != "function" && (n2.inspectSource = function(e23) {
          return o2.call(e23);
        }), e22.exports = n2.inspectSource;
      }, 2995: (e22, t4, r3) => {
        var n2, o2, i2, s2 = r3(5546), u2 = r3(6121), a2 = r3(2521), c2 = r3(1471), l2 = r3(2766), f2 = r3(4682), p2 = r3(2562), h2 = r3(2048), d2 = "Object already initialized", D2 = u2.WeakMap;
        if (s2 || f2.state) {
          var g2 = f2.state || (f2.state = new D2()), m2 = g2.get, v2 = g2.has, y2 = g2.set;
          n2 = function(e23, t5) {
            if (v2.call(g2, e23))
              throw new TypeError(d2);
            return t5.facade = e23, y2.call(g2, e23, t5), t5;
          }, o2 = function(e23) {
            return m2.call(g2, e23) || {};
          }, i2 = function(e23) {
            return v2.call(g2, e23);
          };
        } else {
          var w2 = p2("state");
          h2[w2] = true, n2 = function(e23, t5) {
            if (l2(e23, w2))
              throw new TypeError(d2);
            return t5.facade = e23, c2(e23, w2, t5), t5;
          }, o2 = function(e23) {
            return l2(e23, w2) ? e23[w2] : {};
          }, i2 = function(e23) {
            return l2(e23, w2);
          };
        }
        e22.exports = {set: n2, get: o2, has: i2, enforce: function(e23) {
          return i2(e23) ? o2(e23) : n2(e23, {});
        }, getterFor: function(e23) {
          return function(t5) {
            var r4;
            if (!a2(t5) || (r4 = o2(t5)).type !== e23)
              throw TypeError("Incompatible receiver, " + e23 + " required");
            return r4;
          };
        }};
      }, 9439: (e22, t4, r3) => {
        var n2 = r3(1386), o2 = r3(3403), i2 = n2("iterator"), s2 = Array.prototype;
        e22.exports = function(e23) {
          return e23 !== void 0 && (o2.Array === e23 || s2[i2] === e23);
        };
      }, 3964: (e22, t4, r3) => {
        var n2 = r3(2849);
        e22.exports = Array.isArray || function(e23) {
          return n2(e23) == "Array";
        };
      }, 676: (e22, t4, r3) => {
        var n2 = r3(2763), o2 = /#|\.prototype\./, i2 = function(e23, t5) {
          var r4 = u2[s2(e23)];
          return r4 == c2 || r4 != a2 && (typeof t5 == "function" ? n2(t5) : !!t5);
        }, s2 = i2.normalize = function(e23) {
          return String(e23).replace(o2, ".").toLowerCase();
        }, u2 = i2.data = {}, a2 = i2.NATIVE = "N", c2 = i2.POLYFILL = "P";
        e22.exports = i2;
      }, 2521: (e22) => {
        e22.exports = function(e23) {
          return typeof e23 == "object" ? e23 !== null : typeof e23 == "function";
        };
      }, 8451: (e22) => {
        e22.exports = false;
      }, 5057: (e22, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2020);
        e22.exports = o2 ? function(e23) {
          return typeof e23 == "symbol";
        } : function(e23) {
          var t5 = n2("Symbol");
          return typeof t5 == "function" && Object(e23) instanceof t5;
        };
      }, 4572: (e22, t4, r3) => {
        var n2 = r3(6956), o2 = r3(9439), i2 = r3(8331), s2 = r3(3322), u2 = r3(8977), a2 = r3(5111), c2 = r3(4556), l2 = function(e23, t5) {
          this.stopped = e23, this.result = t5;
        };
        e22.exports = function(e23, t5, r4) {
          var f2, p2, h2, d2, D2, g2, m2, v2 = r4 && r4.that, y2 = !(!r4 || !r4.AS_ENTRIES), w2 = !(!r4 || !r4.IS_ITERATOR), b2 = !(!r4 || !r4.INTERRUPTED), C2 = s2(t5, v2, 1 + y2 + b2), E2 = function(e24) {
            return f2 && c2(f2, "normal", e24), new l2(true, e24);
          }, F2 = function(e24) {
            return y2 ? (n2(e24), b2 ? C2(e24[0], e24[1], E2) : C2(e24[0], e24[1])) : b2 ? C2(e24, E2) : C2(e24);
          };
          if (w2)
            f2 = e23;
          else {
            if (typeof (p2 = a2(e23)) != "function")
              throw TypeError("Target is not iterable");
            if (o2(p2)) {
              for (h2 = 0, d2 = i2(e23.length); d2 > h2; h2++)
                if ((D2 = F2(e23[h2])) && D2 instanceof l2)
                  return D2;
              return new l2(false);
            }
            f2 = u2(e23, p2);
          }
          for (g2 = f2.next; !(m2 = g2.call(f2)).done; ) {
            try {
              D2 = F2(m2.value);
            } catch (e24) {
              c2(f2, "throw", e24);
            }
            if (typeof D2 == "object" && D2 && D2 instanceof l2)
              return D2;
          }
          return new l2(false);
        };
      }, 4556: (e22, t4, r3) => {
        var n2 = r3(6956);
        e22.exports = function(e23, t5, r4) {
          var o2, i2;
          n2(e23);
          try {
            if ((o2 = e23.return) === void 0) {
              if (t5 === "throw")
                throw r4;
              return r4;
            }
            o2 = o2.call(e23);
          } catch (e24) {
            i2 = true, o2 = e24;
          }
          if (t5 === "throw")
            throw r4;
          if (i2)
            throw o2;
          return n2(o2), r4;
        };
      }, 3403: (e22) => {
        e22.exports = {};
      }, 4020: (e22, t4, r3) => {
        var n2 = r3(6962), o2 = r3(2763);
        e22.exports = !!Object.getOwnPropertySymbols && !o2(function() {
          var e23 = Symbol();
          return !String(e23) || !(Object(e23) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
        });
      }, 5546: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(9835), i2 = n2.WeakMap;
        e22.exports = typeof i2 == "function" && /native code/.test(o2(i2));
      }, 7455: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7226), i2 = r3(6956), s2 = r3(5224), u2 = Object.defineProperty;
        t4.f = n2 ? u2 : function(e23, t5, r4) {
          if (i2(e23), t5 = s2(t5), i2(r4), o2)
            try {
              return u2(e23, t5, r4);
            } catch (e24) {
            }
          if ("get" in r4 || "set" in r4)
            throw TypeError("Accessors not supported");
          return "value" in r4 && (e23[t5] = r4.value), e23;
        };
      }, 8769: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7751), i2 = r3(5938), s2 = r3(9969), u2 = r3(5224), a2 = r3(2766), c2 = r3(7226), l2 = Object.getOwnPropertyDescriptor;
        t4.f = n2 ? l2 : function(e23, t5) {
          if (e23 = s2(e23), t5 = u2(t5), c2)
            try {
              return l2(e23, t5);
            } catch (e24) {
            }
          if (a2(e23, t5))
            return i2(!o2.f.call(e23, t5), e23[t5]);
        };
      }, 2042: (e22, t4, r3) => {
        var n2 = r3(3224), o2 = r3(4731).concat("length", "prototype");
        t4.f = Object.getOwnPropertyNames || function(e23) {
          return n2(e23, o2);
        };
      }, 2719: (e22, t4) => {
        t4.f = Object.getOwnPropertySymbols;
      }, 3224: (e22, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9969), i2 = r3(9729).indexOf, s2 = r3(2048);
        e22.exports = function(e23, t5) {
          var r4, u2 = o2(e23), a2 = 0, c2 = [];
          for (r4 in u2)
            !n2(s2, r4) && n2(u2, r4) && c2.push(r4);
          for (; t5.length > a2; )
            n2(u2, r4 = t5[a2++]) && (~i2(c2, r4) || c2.push(r4));
          return c2;
        };
      }, 7751: (e22, t4) => {
        var r3 = {}.propertyIsEnumerable, n2 = Object.getOwnPropertyDescriptor, o2 = n2 && !r3.call({1: 2}, 1);
        t4.f = o2 ? function(e23) {
          var t5 = n2(this, e23);
          return !!t5 && t5.enumerable;
        } : r3;
      }, 1047: (e22, t4, r3) => {
        var n2 = r3(2521);
        e22.exports = function(e23, t5) {
          var r4, o2;
          if (t5 === "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          if (typeof (r4 = e23.valueOf) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          if (t5 !== "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          throw TypeError("Can't convert object to primitive value");
        };
      }, 9593: (e22, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2042), i2 = r3(2719), s2 = r3(6956);
        e22.exports = n2("Reflect", "ownKeys") || function(e23) {
          var t5 = o2.f(s2(e23)), r4 = i2.f;
          return r4 ? t5.concat(r4(e23)) : t5;
        };
      }, 2327: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(1471), i2 = r3(2766), s2 = r3(6565), u2 = r3(9835), a2 = r3(2995), c2 = a2.get, l2 = a2.enforce, f2 = String(String).split("String");
        (e22.exports = function(e23, t5, r4, u3) {
          var a3, c3 = !!u3 && !!u3.unsafe, p2 = !!u3 && !!u3.enumerable, h2 = !!u3 && !!u3.noTargetGet;
          typeof r4 == "function" && (typeof t5 != "string" || i2(r4, "name") || o2(r4, "name", t5), (a3 = l2(r4)).source || (a3.source = f2.join(typeof t5 == "string" ? t5 : ""))), e23 !== n2 ? (c3 ? !h2 && e23[t5] && (p2 = true) : delete e23[t5], p2 ? e23[t5] = r4 : o2(e23, t5, r4)) : p2 ? e23[t5] = r4 : s2(t5, r4);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && c2(this).source || u2(this);
        });
      }, 7263: (e22) => {
        e22.exports = function(e23) {
          if (e23 == null)
            throw TypeError("Can't call method on " + e23);
          return e23;
        };
      }, 6565: (e22, t4, r3) => {
        var n2 = r3(6121);
        e22.exports = function(e23, t5) {
          try {
            Object.defineProperty(n2, e23, {value: t5, configurable: true, writable: true});
          } catch (r4) {
            n2[e23] = t5;
          }
          return t5;
        };
      }, 2562: (e22, t4, r3) => {
        var n2 = r3(896), o2 = r3(1735), i2 = n2("keys");
        e22.exports = function(e23) {
          return i2[e23] || (i2[e23] = o2(e23));
        };
      }, 4682: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(6565), i2 = "__core-js_shared__", s2 = n2[i2] || o2(i2, {});
        e22.exports = s2;
      }, 896: (e22, t4, r3) => {
        var n2 = r3(8451), o2 = r3(4682);
        (e22.exports = function(e23, t5) {
          return o2[e23] || (o2[e23] = t5 !== void 0 ? t5 : {});
        })("versions", []).push({version: "3.17.3", mode: n2 ? "pure" : "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
      }, 1588: (e22, t4, r3) => {
        var n2 = r3(5623), o2 = Math.max, i2 = Math.min;
        e22.exports = function(e23, t5) {
          var r4 = n2(e23);
          return r4 < 0 ? o2(r4 + t5, 0) : i2(r4, t5);
        };
      }, 9969: (e22, t4, r3) => {
        var n2 = r3(3169), o2 = r3(7263);
        e22.exports = function(e23) {
          return n2(o2(e23));
        };
      }, 5623: (e22) => {
        var t4 = Math.ceil, r3 = Math.floor;
        e22.exports = function(e23) {
          return isNaN(e23 = +e23) ? 0 : (e23 > 0 ? r3 : t4)(e23);
        };
      }, 8331: (e22, t4, r3) => {
        var n2 = r3(5623), o2 = Math.min;
        e22.exports = function(e23) {
          return e23 > 0 ? o2(n2(e23), 9007199254740991) : 0;
        };
      }, 4766: (e22, t4, r3) => {
        var n2 = r3(7263);
        e22.exports = function(e23) {
          return Object(n2(e23));
        };
      }, 687: (e22, t4, r3) => {
        var n2 = r3(2521), o2 = r3(5057), i2 = r3(1047), s2 = r3(1386)("toPrimitive");
        e22.exports = function(e23, t5) {
          if (!n2(e23) || o2(e23))
            return e23;
          var r4, u2 = e23[s2];
          if (u2 !== void 0) {
            if (t5 === void 0 && (t5 = "default"), r4 = u2.call(e23, t5), !n2(r4) || o2(r4))
              return r4;
            throw TypeError("Can't convert object to primitive value");
          }
          return t5 === void 0 && (t5 = "number"), i2(e23, t5);
        };
      }, 5224: (e22, t4, r3) => {
        var n2 = r3(687), o2 = r3(5057);
        e22.exports = function(e23) {
          var t5 = n2(e23, "string");
          return o2(t5) ? t5 : String(t5);
        };
      }, 6395: (e22, t4, r3) => {
        var n2 = {};
        n2[r3(1386)("toStringTag")] = "z", e22.exports = String(n2) === "[object z]";
      }, 3710: (e22, t4, r3) => {
        var n2 = r3(5057);
        e22.exports = function(e23) {
          if (n2(e23))
            throw TypeError("Cannot convert a Symbol value to a string");
          return String(e23);
        };
      }, 1735: (e22) => {
        var t4 = 0, r3 = Math.random();
        e22.exports = function(e23) {
          return "Symbol(" + String(e23 === void 0 ? "" : e23) + ")_" + (++t4 + r3).toString(36);
        };
      }, 2020: (e22, t4, r3) => {
        var n2 = r3(4020);
        e22.exports = n2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }, 1386: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(896), i2 = r3(2766), s2 = r3(1735), u2 = r3(4020), a2 = r3(2020), c2 = o2("wks"), l2 = n2.Symbol, f2 = a2 ? l2 : l2 && l2.withoutSetter || s2;
        e22.exports = function(e23) {
          return i2(c2, e23) && (u2 || typeof c2[e23] == "string") || (u2 && i2(l2, e23) ? c2[e23] = l2[e23] : c2[e23] = f2("Symbol." + e23)), c2[e23];
        };
      }, 4304: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(5538), i2 = r3(4766), s2 = r3(8331), u2 = r3(118), a2 = r3(8347);
        n2({target: "Array", proto: true}, {flatMap: function(e23) {
          var t5, r4 = i2(this), n3 = s2(r4.length);
          return u2(e23), (t5 = a2(r4, 0)).length = o2(t5, r4, r4, n3, 0, 1, e23, arguments.length > 1 ? arguments[1] : void 0), t5;
        }});
      }, 4070: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(118), i2 = r3(4766), s2 = r3(8331), u2 = r3(3710), a2 = r3(2763), c2 = r3(3407), l2 = r3(9719), f2 = r3(5249), p2 = r3(2049), h2 = r3(6962), d2 = r3(8998), D2 = [], g2 = D2.sort, m2 = a2(function() {
          D2.sort(void 0);
        }), v2 = a2(function() {
          D2.sort(null);
        }), y2 = l2("sort"), w2 = !a2(function() {
          if (h2)
            return h2 < 70;
          if (!(f2 && f2 > 3)) {
            if (p2)
              return true;
            if (d2)
              return d2 < 603;
            var e23, t5, r4, n3, o3 = "";
            for (e23 = 65; e23 < 76; e23++) {
              switch (t5 = String.fromCharCode(e23), e23) {
                case 66:
                case 69:
                case 70:
                case 72:
                  r4 = 3;
                  break;
                case 68:
                case 71:
                  r4 = 4;
                  break;
                default:
                  r4 = 2;
              }
              for (n3 = 0; n3 < 47; n3++)
                D2.push({k: t5 + n3, v: r4});
            }
            for (D2.sort(function(e24, t6) {
              return t6.v - e24.v;
            }), n3 = 0; n3 < D2.length; n3++)
              t5 = D2[n3].k.charAt(0), o3.charAt(o3.length - 1) !== t5 && (o3 += t5);
            return o3 !== "DGBEFHACIJK";
          }
        });
        n2({target: "Array", proto: true, forced: m2 || !v2 || !y2 || !w2}, {sort: function(e23) {
          e23 !== void 0 && o2(e23);
          var t5 = i2(this);
          if (w2)
            return e23 === void 0 ? g2.call(t5) : g2.call(t5, e23);
          var r4, n3, a3 = [], l3 = s2(t5.length);
          for (n3 = 0; n3 < l3; n3++)
            n3 in t5 && a3.push(t5[n3]);
          for (r4 = (a3 = c2(a3, function(e24) {
            return function(t6, r5) {
              return r5 === void 0 ? -1 : t6 === void 0 ? 1 : e24 !== void 0 ? +e24(t6, r5) || 0 : u2(t6) > u2(r5) ? 1 : -1;
            };
          }(e23))).length, n3 = 0; n3 < r4; )
            t5[n3] = a3[n3++];
          for (; n3 < l3; )
            delete t5[n3++];
          return t5;
        }});
      }, 2612: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(4572), i2 = r3(2385);
        n2({target: "Object", stat: true}, {fromEntries: function(e23) {
          var t5 = {};
          return o2(e23, function(e24, r4) {
            i2(t5, e24, r4);
          }, {AS_ENTRIES: true}), t5;
        }});
      }, 3584: (e22) => {
        const t4 = (e23) => {
          if (typeof e23 != "string")
            throw new TypeError("Expected a string");
          const t5 = e23.match(/(?:\r?\n)/g) || [];
          if (t5.length === 0)
            return;
          const r3 = t5.filter((e24) => e24 === "\r\n").length;
          return r3 > t5.length - r3 ? "\r\n" : "\n";
        };
        e22.exports = t4, e22.exports.graceful = (e23) => typeof e23 == "string" && t4(e23) || "\n";
      }, 541: (e22) => {
        e22.exports = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        };
      }, 2240: (e22) => {
        e22.exports = (e23) => {
          if (typeof e23 != "string")
            throw new TypeError("Expected a string");
          return e23.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        };
      }, 8051: (e22) => {
        e22.exports = function(e23, t4) {
          return (t4 = typeof t4 == "number" ? t4 : 1 / 0) ? function e24(r3, n2) {
            return r3.reduce(function(r4, o2) {
              return Array.isArray(o2) && n2 < t4 ? r4.concat(e24(o2, n2 + 1)) : r4.concat(o2);
            }, []);
          }(e23, 1) : Array.isArray(e23) ? e23.map(function(e24) {
            return e24;
          }) : e23;
        };
      }, 7886: (e22) => {
        e22.exports = function(e23, t4) {
          for (var r3 = -1, n2 = []; (r3 = e23.indexOf(t4, r3 + 1)) !== -1; )
            n2.push(r3);
          return n2;
        };
      }, 8528: (e22) => {
        const t4 = (e23) => !Number.isNaN(e23) && e23 >= 4352 && (e23 <= 4447 || e23 === 9001 || e23 === 9002 || 11904 <= e23 && e23 <= 12871 && e23 !== 12351 || 12880 <= e23 && e23 <= 19903 || 19968 <= e23 && e23 <= 42182 || 43360 <= e23 && e23 <= 43388 || 44032 <= e23 && e23 <= 55203 || 63744 <= e23 && e23 <= 64255 || 65040 <= e23 && e23 <= 65049 || 65072 <= e23 && e23 <= 65131 || 65281 <= e23 && e23 <= 65376 || 65504 <= e23 && e23 <= 65510 || 110592 <= e23 && e23 <= 110593 || 127488 <= e23 && e23 <= 127569 || 131072 <= e23 && e23 <= 262141);
        e22.exports = t4, e22.exports.default = t4;
      }, 9234: (e22, t4, r3) => {
        function n2() {
          const e23 = r3(4372);
          return n2 = function() {
            return e23;
          }, e23;
        }
        function o2() {
          const e23 = (t5 = r3(3584)) && t5.__esModule ? t5 : {default: t5};
          var t5;
          return o2 = function() {
            return e23;
          }, e23;
        }
        Object.defineProperty(t4, "__esModule", {value: true}), t4.extract = function(e23) {
          const t5 = e23.match(u2);
          return t5 ? t5[0].trimLeft() : "";
        }, t4.strip = function(e23) {
          const t5 = e23.match(u2);
          return t5 && t5[0] ? e23.substring(t5[0].length) : e23;
        }, t4.parse = function(e23) {
          return d2(e23).pragmas;
        }, t4.parseWithComments = d2, t4.print = function({comments: e23 = "", pragmas: t5 = {}}) {
          const r4 = (0, o2().default)(e23) || n2().EOL, i3 = " *", s3 = Object.keys(t5), u3 = s3.map((e24) => D2(e24, t5[e24])).reduce((e24, t6) => e24.concat(t6), []).map((e24) => " * " + e24 + r4).join("");
          if (!e23) {
            if (s3.length === 0)
              return "";
            if (s3.length === 1 && !Array.isArray(t5[s3[0]])) {
              const e24 = t5[s3[0]];
              return `/** ${D2(s3[0], e24)[0]} */`;
            }
          }
          const a3 = e23.split(r4).map((e24) => ` * ${e24}`).join(r4) + r4;
          return "/**" + r4 + (e23 ? a3 : "") + (e23 && s3.length ? i3 + r4 : "") + u3 + " */";
        };
        const i2 = /\*\/$/, s2 = /^\/\*\*/, u2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a2 = /(^|\s+)\/\/([^\r\n]*)/g, c2 = /^(\r?\n)+/, l2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, f2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p2 = /(\r?\n|^) *\* ?/g, h2 = [];
        function d2(e23) {
          const t5 = (0, o2().default)(e23) || n2().EOL;
          e23 = e23.replace(s2, "").replace(i2, "").replace(p2, "$1");
          let r4 = "";
          for (; r4 !== e23; )
            r4 = e23, e23 = e23.replace(l2, `${t5}$1 $2${t5}`);
          e23 = e23.replace(c2, "").trimRight();
          const u3 = Object.create(null), d3 = e23.replace(f2, "").replace(c2, "").trimRight();
          let D3;
          for (; D3 = f2.exec(e23); ) {
            const e24 = D3[2].replace(a2, "");
            typeof u3[D3[1]] == "string" || Array.isArray(u3[D3[1]]) ? u3[D3[1]] = h2.concat(u3[D3[1]], e24) : u3[D3[1]] = e24;
          }
          return {comments: d3, pragmas: u3};
        }
        function D2(e23, t5) {
          return h2.concat(t5).map((t6) => `@${e23} ${t6}`.trim());
        }
      }, 5311: (e22, t4, r3) => {
        function n2() {
          for (var e23 = [], t5 = 0; t5 < arguments.length; t5++)
            e23[t5] = arguments[t5];
        }
        function o2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : {add: n2, delete: n2, get: n2, set: n2, has: function(e23) {
            return false;
          }};
        }
        r3.r(t4), r3.d(t4, {default: () => m2, outdent: () => g2}), e22 = r3.hmd(e22);
        var i2 = Object.prototype.hasOwnProperty, s2 = function(e23, t5) {
          return i2.call(e23, t5);
        };
        function u2(e23, t5) {
          for (var r4 in t5)
            s2(t5, r4) && (e23[r4] = t5[r4]);
          return e23;
        }
        var a2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, l2 = /^(?:[\r\n]|$)/, f2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function h2(e23, t5, r4) {
          var n3 = 0, o3 = e23[0].match(f2);
          o3 && (n3 = o3[1].length);
          var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
          t5 && (e23 = e23.slice(1));
          var s3 = r4.newline, u3 = r4.trimLeadingNewline, l3 = r4.trimTrailingNewline, p3 = typeof s3 == "string", h3 = e23.length;
          return e23.map(function(e24, t6) {
            return e24 = e24.replace(i3, "$1"), t6 === 0 && u3 && (e24 = e24.replace(a2, "")), t6 === h3 - 1 && l3 && (e24 = e24.replace(c2, "")), p3 && (e24 = e24.replace(/\r\n|\n|\r/g, function(e25) {
              return s3;
            })), e24;
          });
        }
        function d2(e23, t5) {
          for (var r4 = "", n3 = 0, o3 = e23.length; n3 < o3; n3++)
            r4 += e23[n3], n3 < o3 - 1 && (r4 += t5[n3]);
          return r4;
        }
        function D2(e23) {
          return s2(e23, "raw") && s2(e23, "length");
        }
        var g2 = function e23(t5) {
          var r4 = o2(), n3 = o2();
          return u2(function o3(i3) {
            for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
              s3[a3 - 1] = arguments[a3];
            if (D2(i3)) {
              var c3 = i3, f3 = (s3[0] === o3 || s3[0] === g2) && p2.test(c3[0]) && l2.test(c3[1]), m3 = f3 ? n3 : r4, v2 = m3.get(c3);
              return v2 || (v2 = h2(c3, f3, t5), m3.set(c3, v2)), s3.length === 0 ? v2[0] : d2(v2, f3 ? s3.slice(1) : s3);
            }
            return e23(u2(u2({}, t5), i3 || {}));
          }, {string: function(e24) {
            return h2([e24], false, t5)[0];
          }});
        }({trimLeadingNewline: true, trimTrailingNewline: true});
        const m2 = g2;
        try {
          e22.exports = g2, Object.defineProperty(g2, "__esModule", {value: true}), g2.default = g2, g2.outdent = g2;
        } catch (e23) {
        }
      }, 5724: (e22) => {
        function t4(e23) {
          if (typeof e23 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e23));
        }
        function r3(e23, t5) {
          for (var r4, n3 = "", o2 = 0, i2 = -1, s2 = 0, u2 = 0; u2 <= e23.length; ++u2) {
            if (u2 < e23.length)
              r4 = e23.charCodeAt(u2);
            else {
              if (r4 === 47)
                break;
              r4 = 47;
            }
            if (r4 === 47) {
              if (i2 === u2 - 1 || s2 === 1)
                ;
              else if (i2 !== u2 - 1 && s2 === 2) {
                if (n3.length < 2 || o2 !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
                  if (n3.length > 2) {
                    var a2 = n3.lastIndexOf("/");
                    if (a2 !== n3.length - 1) {
                      a2 === -1 ? (n3 = "", o2 = 0) : o2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), i2 = u2, s2 = 0;
                      continue;
                    }
                  } else if (n3.length === 2 || n3.length === 1) {
                    n3 = "", o2 = 0, i2 = u2, s2 = 0;
                    continue;
                  }
                }
                t5 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o2 = 2);
              } else
                n3.length > 0 ? n3 += "/" + e23.slice(i2 + 1, u2) : n3 = e23.slice(i2 + 1, u2), o2 = u2 - i2 - 1;
              i2 = u2, s2 = 0;
            } else
              r4 === 46 && s2 !== -1 ? ++s2 : s2 = -1;
          }
          return n3;
        }
        var n2 = {resolve: function() {
          for (var e23, n3 = "", o2 = false, i2 = arguments.length - 1; i2 >= -1 && !o2; i2--) {
            var s2;
            i2 >= 0 ? s2 = arguments[i2] : (e23 === void 0 && (e23 = process.cwd()), s2 = e23), t4(s2), s2.length !== 0 && (n3 = s2 + "/" + n3, o2 = s2.charCodeAt(0) === 47);
          }
          return n3 = r3(n3, !o2), o2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(e23) {
          if (t4(e23), e23.length === 0)
            return ".";
          var n3 = e23.charCodeAt(0) === 47, o2 = e23.charCodeAt(e23.length - 1) === 47;
          return (e23 = r3(e23, !n3)).length !== 0 || n3 || (e23 = "."), e23.length > 0 && o2 && (e23 += "/"), n3 ? "/" + e23 : e23;
        }, isAbsolute: function(e23) {
          return t4(e23), e23.length > 0 && e23.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0)
            return ".";
          for (var e23, r4 = 0; r4 < arguments.length; ++r4) {
            var o2 = arguments[r4];
            t4(o2), o2.length > 0 && (e23 === void 0 ? e23 = o2 : e23 += "/" + o2);
          }
          return e23 === void 0 ? "." : n2.normalize(e23);
        }, relative: function(e23, r4) {
          if (t4(e23), t4(r4), e23 === r4)
            return "";
          if ((e23 = n2.resolve(e23)) === (r4 = n2.resolve(r4)))
            return "";
          for (var o2 = 1; o2 < e23.length && e23.charCodeAt(o2) === 47; ++o2)
            ;
          for (var i2 = e23.length, s2 = i2 - o2, u2 = 1; u2 < r4.length && r4.charCodeAt(u2) === 47; ++u2)
            ;
          for (var a2 = r4.length - u2, c2 = s2 < a2 ? s2 : a2, l2 = -1, f2 = 0; f2 <= c2; ++f2) {
            if (f2 === c2) {
              if (a2 > c2) {
                if (r4.charCodeAt(u2 + f2) === 47)
                  return r4.slice(u2 + f2 + 1);
                if (f2 === 0)
                  return r4.slice(u2 + f2);
              } else
                s2 > c2 && (e23.charCodeAt(o2 + f2) === 47 ? l2 = f2 : f2 === 0 && (l2 = 0));
              break;
            }
            var p2 = e23.charCodeAt(o2 + f2);
            if (p2 !== r4.charCodeAt(u2 + f2))
              break;
            p2 === 47 && (l2 = f2);
          }
          var h2 = "";
          for (f2 = o2 + l2 + 1; f2 <= i2; ++f2)
            f2 !== i2 && e23.charCodeAt(f2) !== 47 || (h2.length === 0 ? h2 += ".." : h2 += "/..");
          return h2.length > 0 ? h2 + r4.slice(u2 + l2) : (u2 += l2, r4.charCodeAt(u2) === 47 && ++u2, r4.slice(u2));
        }, _makeLong: function(e23) {
          return e23;
        }, dirname: function(e23) {
          if (t4(e23), e23.length === 0)
            return ".";
          for (var r4 = e23.charCodeAt(0), n3 = r4 === 47, o2 = -1, i2 = true, s2 = e23.length - 1; s2 >= 1; --s2)
            if ((r4 = e23.charCodeAt(s2)) === 47) {
              if (!i2) {
                o2 = s2;
                break;
              }
            } else
              i2 = false;
          return o2 === -1 ? n3 ? "/" : "." : n3 && o2 === 1 ? "//" : e23.slice(0, o2);
        }, basename: function(e23, r4) {
          if (r4 !== void 0 && typeof r4 != "string")
            throw new TypeError('"ext" argument must be a string');
          t4(e23);
          var n3, o2 = 0, i2 = -1, s2 = true;
          if (r4 !== void 0 && r4.length > 0 && r4.length <= e23.length) {
            if (r4.length === e23.length && r4 === e23)
              return "";
            var u2 = r4.length - 1, a2 = -1;
            for (n3 = e23.length - 1; n3 >= 0; --n3) {
              var c2 = e23.charCodeAt(n3);
              if (c2 === 47) {
                if (!s2) {
                  o2 = n3 + 1;
                  break;
                }
              } else
                a2 === -1 && (s2 = false, a2 = n3 + 1), u2 >= 0 && (c2 === r4.charCodeAt(u2) ? --u2 == -1 && (i2 = n3) : (u2 = -1, i2 = a2));
            }
            return o2 === i2 ? i2 = a2 : i2 === -1 && (i2 = e23.length), e23.slice(o2, i2);
          }
          for (n3 = e23.length - 1; n3 >= 0; --n3)
            if (e23.charCodeAt(n3) === 47) {
              if (!s2) {
                o2 = n3 + 1;
                break;
              }
            } else
              i2 === -1 && (s2 = false, i2 = n3 + 1);
          return i2 === -1 ? "" : e23.slice(o2, i2);
        }, extname: function(e23) {
          t4(e23);
          for (var r4 = -1, n3 = 0, o2 = -1, i2 = true, s2 = 0, u2 = e23.length - 1; u2 >= 0; --u2) {
            var a2 = e23.charCodeAt(u2);
            if (a2 !== 47)
              o2 === -1 && (i2 = false, o2 = u2 + 1), a2 === 46 ? r4 === -1 ? r4 = u2 : s2 !== 1 && (s2 = 1) : r4 !== -1 && (s2 = -1);
            else if (!i2) {
              n3 = u2 + 1;
              break;
            }
          }
          return r4 === -1 || o2 === -1 || s2 === 0 || s2 === 1 && r4 === o2 - 1 && r4 === n3 + 1 ? "" : e23.slice(r4, o2);
        }, format: function(e23) {
          if (e23 === null || typeof e23 != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e23);
          return function(e24, t5) {
            var r4 = t5.dir || t5.root, n3 = t5.base || (t5.name || "") + (t5.ext || "");
            return r4 ? r4 === t5.root ? r4 + n3 : r4 + e24 + n3 : n3;
          }("/", e23);
        }, parse: function(e23) {
          t4(e23);
          var r4 = {root: "", dir: "", base: "", ext: "", name: ""};
          if (e23.length === 0)
            return r4;
          var n3, o2 = e23.charCodeAt(0), i2 = o2 === 47;
          i2 ? (r4.root = "/", n3 = 1) : n3 = 0;
          for (var s2 = -1, u2 = 0, a2 = -1, c2 = true, l2 = e23.length - 1, f2 = 0; l2 >= n3; --l2)
            if ((o2 = e23.charCodeAt(l2)) !== 47)
              a2 === -1 && (c2 = false, a2 = l2 + 1), o2 === 46 ? s2 === -1 ? s2 = l2 : f2 !== 1 && (f2 = 1) : s2 !== -1 && (f2 = -1);
            else if (!c2) {
              u2 = l2 + 1;
              break;
            }
          return s2 === -1 || a2 === -1 || f2 === 0 || f2 === 1 && s2 === a2 - 1 && s2 === u2 + 1 ? a2 !== -1 && (r4.base = r4.name = u2 === 0 && i2 ? e23.slice(1, a2) : e23.slice(u2, a2)) : (u2 === 0 && i2 ? (r4.name = e23.slice(1, s2), r4.base = e23.slice(1, a2)) : (r4.name = e23.slice(u2, s2), r4.base = e23.slice(u2, a2)), r4.ext = e23.slice(s2, a2)), u2 > 0 ? r4.dir = e23.slice(0, u2 - 1) : i2 && (r4.dir = "/"), r4;
        }, sep: "/", delimiter: ":", win32: null, posix: null};
        n2.posix = n2, e22.exports = n2;
      }, 8681: (e22, t4, r3) => {
        const n2 = r3(3102), o2 = r3(7116), {isInlineComment: i2} = r3(1101), {interpolation: s2} = r3(3295), {isMixinToken: u2} = r3(5953), a2 = r3(1330), c2 = r3(5255), l2 = /(!\s*important)$/i;
        e22.exports = class extends o2 {
          constructor(...e23) {
            super(...e23), this.lastNode = null;
          }
          atrule(e23) {
            s2.bind(this)(e23) || (super.atrule(e23), a2(this.lastNode), c2(this.lastNode));
          }
          decl(...e23) {
            super.decl(...e23), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
          }
          each(e23) {
            e23[0][1] = ` ${e23[0][1]}`;
            const t5 = e23.findIndex((e24) => e24[0] === "("), r4 = e23.reverse().find((e24) => e24[0] === ")"), n3 = e23.reverse().indexOf(r4), o3 = e23.splice(t5, n3).map((e24) => e24[1]).join("");
            for (const t6 of e23.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o3;
          }
          init(e23, t5, r4) {
            super.init(e23, t5, r4), this.lastNode = e23;
          }
          inlineComment(e23) {
            const t5 = new n2(), r4 = e23[1].slice(2);
            if (this.init(t5, e23[2], e23[3]), t5.source.end = {line: e23[4], column: e23[5]}, t5.inline = true, t5.raws.begin = "//", /^\s*$/.test(r4))
              t5.text = "", t5.raws.left = r4, t5.raws.right = "";
            else {
              const e24 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              [, t5.raws.left, t5.text, t5.raws.right] = e24;
            }
          }
          mixin(e23) {
            const [t5] = e23, r4 = t5[1].slice(0, 1), n3 = e23.findIndex((e24) => e24[0] === "brackets"), o3 = e23.findIndex((e24) => e24[0] === "(");
            let i3 = "";
            if ((n3 < 0 || n3 > 3) && o3 > 0) {
              const t6 = e23.reduce((e24, t7, r6) => t7[0] === ")" ? r6 : e24), r5 = e23.slice(o3, t6 + o3).map((e24) => e24[1]).join(""), [n4] = e23.slice(o3), i4 = [n4[2], n4[3]], [s4] = e23.slice(t6, t6 + 1), u4 = [s4[2], s4[3]], a3 = ["brackets", r5].concat(i4, u4), c3 = e23.slice(0, o3), l3 = e23.slice(t6 + 1);
              (e23 = c3).push(a3), e23 = e23.concat(l3);
            }
            const s3 = [];
            for (const t6 of e23)
              if ((t6[1] === "!" || s3.length) && s3.push(t6), t6[1] === "important")
                break;
            if (s3.length) {
              const [t6] = s3, r5 = e23.indexOf(t6), n4 = s3[s3.length - 1], o4 = [t6[2], t6[3]], i4 = [n4[4], n4[5]], u4 = ["word", s3.map((e24) => e24[1]).join("")].concat(o4, i4);
              e23.splice(r5, s3.length, u4);
            }
            const u3 = e23.findIndex((e24) => l2.test(e24[1]));
            u3 > 0 && ([, i3] = e23[u3], e23.splice(u3, 1));
            for (const t6 of e23.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r4, i3 && (this.lastNode.important = true, this.lastNode.raws.important = i3);
          }
          other(e23) {
            i2.bind(this)(e23) || super.other(e23);
          }
          rule(e23) {
            const t5 = e23[e23.length - 1], r4 = e23[e23.length - 2];
            if (r4[0] === "at-word" && t5[0] === "{" && (this.tokenizer.back(t5), s2.bind(this)(r4))) {
              const t6 = this.tokenizer.nextToken();
              e23 = e23.slice(0, e23.length - 2).concat([t6]);
              for (const t7 of e23.reverse())
                this.tokenizer.back(t7);
            } else
              super.rule(e23), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
          }
          unknownWord(e23) {
            const [t5] = e23;
            e23[0][1] !== "each" || e23[1][0] !== "(" ? u2(t5) ? this.mixin(e23) : super.unknownWord(e23) : this.each(e23);
          }
        };
      }, 3406: (e22, t4, r3) => {
        const n2 = r3(5701);
        e22.exports = class extends n2 {
          atrule(e23, t5) {
            if (!e23.mixin && !e23.variable && !e23.function)
              return void super.atrule(e23, t5);
            let r4 = `${e23.function ? "" : e23.raws.identifier || "@"}${e23.name}`, n3 = e23.params ? this.rawValue(e23, "params") : "";
            const o2 = e23.raws.important || "";
            if (e23.variable && (n3 = e23.value), e23.raws.afterName !== void 0 ? r4 += e23.raws.afterName : n3 && (r4 += " "), e23.nodes)
              this.block(e23, r4 + n3 + o2);
            else {
              const i2 = (e23.raws.between || "") + o2 + (t5 ? ";" : "");
              this.builder(r4 + n3 + i2, e23);
            }
          }
          comment(e23) {
            if (e23.inline) {
              const t5 = this.raw(e23, "left", "commentLeft"), r4 = this.raw(e23, "right", "commentRight");
              this.builder(`//${t5}${e23.text}${r4}`, e23);
            } else
              super.comment(e23);
          }
        };
      }, 7371: (e22, t4, r3) => {
        const n2 = r3(2993), o2 = r3(8681), i2 = r3(3406);
        e22.exports = {parse(e23, t5) {
          const r4 = new n2(e23, t5), i3 = new o2(r4);
          return i3.parse(), i3.root;
        }, stringify(e23, t5) {
          new i2(t5).stringify(e23);
        }, nodeToString(t5) {
          let r4 = "";
          return e22.exports.stringify(t5, (e23) => {
            r4 += e23;
          }), r4;
        }};
      }, 1330: (e22, t4, r3) => {
        const n2 = r3(1157), o2 = /^url\((.+)\)/;
        e22.exports = (e23) => {
          const {name: t5, params: r4 = ""} = e23;
          if (t5 === "import" && r4.length) {
            e23.import = true;
            const t6 = n2({css: r4});
            for (e23.filename = r4.replace(o2, "$1"); !t6.endOfFile(); ) {
              const [n3, o3] = t6.nextToken();
              if (n3 === "word" && o3 === "url")
                return;
              if (n3 === "brackets") {
                e23.options = o3, e23.filename = r4.replace(o3, "").trim();
                break;
              }
            }
          }
        };
      }, 1101: (e22, t4, r3) => {
        const n2 = r3(1157), o2 = r3(2993);
        e22.exports = {isInlineComment(t5) {
          if (t5[0] === "word" && t5[1].slice(0, 2) === "//") {
            const e23 = t5, r4 = [];
            let i2;
            for (; t5; ) {
              if (/\r?\n/.test(t5[1])) {
                if (/['"].*\r?\n/.test(t5[1])) {
                  r4.push(t5[1].substring(0, t5[1].indexOf("\n")));
                  let e24 = t5[1].substring(t5[1].indexOf("\n"));
                  e24 += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new o2(e24), this.tokenizer = n2(this.input);
                } else
                  this.tokenizer.back(t5);
                break;
              }
              r4.push(t5[1]), i2 = t5, t5 = this.tokenizer.nextToken({ignoreUnclosed: true});
            }
            const s2 = ["comment", r4.join(""), e23[2], e23[3], i2[2], i2[3]];
            return this.inlineComment(s2), true;
          }
          if (t5[1] === "/") {
            const r4 = this.tokenizer.nextToken({ignoreUnclosed: true});
            if (r4[0] === "comment" && /^\/\*/.test(r4[1]))
              return r4[0] = "word", r4[1] = r4[1].slice(1), t5[1] = "//", this.tokenizer.back(r4), e22.exports.isInlineComment.bind(this)(t5);
          }
          return false;
        }};
      }, 3295: (e22) => {
        e22.exports = {interpolation(e23) {
          let t4 = e23;
          const r3 = [e23], n2 = ["word", "{", "}"];
          if (e23 = this.tokenizer.nextToken(), t4[1].length > 1 || e23[0] !== "{")
            return this.tokenizer.back(e23), false;
          for (; e23 && n2.includes(e23[0]); )
            r3.push(e23), e23 = this.tokenizer.nextToken();
          const o2 = r3.map((e24) => e24[1]);
          [t4] = r3;
          const i2 = r3.pop(), s2 = [t4[2], t4[3]], u2 = [i2[4] || i2[2], i2[5] || i2[3]], a2 = ["word", o2.join("")].concat(s2, u2);
          return this.tokenizer.back(e23), this.tokenizer.back(a2), true;
        }};
      }, 5953: (e22) => {
        const t4 = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, r3 = /\.[0-9]/;
        e22.exports = {isMixinToken: (e23) => {
          const [, n2] = e23, [o2] = n2;
          return (o2 === "." || o2 === "#") && t4.test(n2) === false && r3.test(n2) === false;
        }};
      }, 5255: (e22) => {
        const t4 = /:$/, r3 = /^:(\s+)?/;
        e22.exports = (e23) => {
          const {name: n2, params: o2 = ""} = e23;
          if (e23.name.slice(-1) === ":") {
            if (t4.test(n2)) {
              const [r4] = n2.match(t4);
              e23.name = n2.replace(r4, ""), e23.raws.afterName = r4 + (e23.raws.afterName || ""), e23.variable = true, e23.value = e23.params;
            }
            if (r3.test(o2)) {
              const [t5] = o2.match(r3);
              e23.value = o2.replace(t5, ""), e23.raws.afterName = (e23.raws.afterName || "") + t5, e23.variable = true;
            }
          }
        };
      }, 8322: (e22, t4, r3) => {
        t4.Z = function(e23) {
          return new o2.default({nodes: (0, i2.parseMediaList)(e23), type: "media-query-list", value: e23.trim()});
        };
        var n2, o2 = (n2 = r3(9066)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(7625);
      }, 9066: (e22, t4, r3) => {
        Object.defineProperty(t4, "__esModule", {value: true});
        var n2, o2 = (n2 = r3(7680)) && n2.__esModule ? n2 : {default: n2};
        function i2(e23) {
          var t5 = this;
          this.constructor(e23), this.nodes = e23.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(e24) {
            e24.parent = t5;
          });
        }
        i2.prototype = Object.create(o2.default.prototype), i2.constructor = o2.default, i2.prototype.walk = function(e23, t5) {
          for (var r4 = typeof e23 == "string" || e23 instanceof RegExp, n3 = r4 ? t5 : e23, o3 = typeof e23 == "string" ? new RegExp(e23) : e23, i3 = 0; i3 < this.nodes.length; i3++) {
            var s2 = this.nodes[i3];
            if ((!r4 || o3.test(s2.type)) && n3 && n3(s2, i3, this.nodes) === false)
              return false;
            if (s2.nodes && s2.walk(e23, t5) === false)
              return false;
          }
          return true;
        }, i2.prototype.each = function() {
          for (var e23 = arguments.length <= 0 || arguments[0] === void 0 ? function() {
          } : arguments[0], t5 = 0; t5 < this.nodes.length; t5++)
            if (e23(this.nodes[t5], t5, this.nodes) === false)
              return false;
          return true;
        }, t4.default = i2;
      }, 7680: (e22, t4) => {
        Object.defineProperty(t4, "__esModule", {value: true}), t4.default = function(e23) {
          this.after = e23.after, this.before = e23.before, this.type = e23.type, this.value = e23.value, this.sourceIndex = e23.sourceIndex;
        };
      }, 7625: (e22, t4, r3) => {
        Object.defineProperty(t4, "__esModule", {value: true}), t4.parseMediaFeature = s2, t4.parseMediaQuery = u2, t4.parseMediaList = function(e23) {
          var t5 = [], r4 = 0, i3 = 0, s3 = /^(\s*)url\s*\(/.exec(e23);
          if (s3 !== null) {
            for (var a2 = s3[0].length, c2 = 1; c2 > 0; ) {
              var l2 = e23[a2];
              l2 === "(" && c2++, l2 === ")" && c2--, a2++;
            }
            t5.unshift(new n2.default({type: "url", value: e23.substring(0, a2).trim(), sourceIndex: s3[1].length, before: s3[1], after: /^(\s*)/.exec(e23.substring(a2))[1]})), r4 = a2;
          }
          for (var f2 = r4; f2 < e23.length; f2++) {
            var p2 = e23[f2];
            if (p2 === "(" && i3++, p2 === ")" && i3--, i3 === 0 && p2 === ",") {
              var h2 = e23.substring(r4, f2), d2 = /^(\s*)/.exec(h2)[1];
              t5.push(new o2.default({type: "media-query", value: h2.trim(), sourceIndex: r4 + d2.length, nodes: u2(h2, r4), before: d2, after: /(\s*)$/.exec(h2)[1]})), r4 = f2 + 1;
            }
          }
          var D2 = e23.substring(r4), g2 = /^(\s*)/.exec(D2)[1];
          return t5.push(new o2.default({type: "media-query", value: D2.trim(), sourceIndex: r4 + g2.length, nodes: u2(D2, r4), before: g2, after: /(\s*)$/.exec(D2)[1]})), t5;
        };
        var n2 = i2(r3(7680)), o2 = i2(r3(9066));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function s2(e23) {
          var t5 = [{mode: "normal", character: null}], r4 = [], n3 = 0, o3 = "", i3 = null, s3 = null, u3 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], a2 = e23;
          e23[0] === "(" && e23[e23.length - 1] === ")" && (a2 = e23.substring(1, e23.length - 1), u3++);
          for (var c2 = 0; c2 < a2.length; c2++) {
            var l2 = a2[c2];
            if (l2 !== "'" && l2 !== '"' || (t5[n3].isCalculationEnabled === true ? (t5.push({mode: "string", isCalculationEnabled: false, character: l2}), n3++) : t5[n3].mode === "string" && t5[n3].character === l2 && a2[c2 - 1] !== "\\" && (t5.pop(), n3--)), l2 === "{" ? (t5.push({mode: "interpolation", isCalculationEnabled: true}), n3++) : l2 === "}" && (t5.pop(), n3--), t5[n3].mode === "normal" && l2 === ":") {
              var f2 = a2.substring(c2 + 1);
              (s3 = {type: "value", before: /^(\s*)/.exec(f2)[1], after: /(\s*)$/.exec(f2)[1], value: f2.trim()}).sourceIndex = s3.before.length + c2 + 1 + u3, i3 = {type: "colon", sourceIndex: c2 + u3, after: s3.before, value: ":"};
              break;
            }
            o3 += l2;
          }
          return (o3 = {type: "media-feature", before: /^(\s*)/.exec(o3)[1], after: /(\s*)$/.exec(o3)[1], value: o3.trim()}).sourceIndex = o3.before.length + u3, r4.push(o3), i3 !== null && (i3.before = o3.after, r4.push(i3)), s3 !== null && r4.push(s3), r4;
        }
        function u2(e23) {
          var t5 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r4 = [], i3 = 0, u3 = false, a2 = void 0;
          a2 = {before: "", after: "", value: ""};
          for (var c2 = 0; c2 < e23.length; c2++) {
            var l2 = e23[c2];
            u3 ? (a2.value += l2, l2 !== "{" && l2 !== "(" || i3++, l2 !== ")" && l2 !== "}" || i3--) : l2.search(/\s/) !== -1 ? a2.before += l2 : (l2 === "(" && (a2.type = "media-feature-expression", i3++), a2.value = l2, a2.sourceIndex = t5 + c2, u3 = true), !u3 || i3 !== 0 || l2 !== ")" && c2 !== e23.length - 1 && e23[c2 + 1].search(/\s/) === -1 || (["not", "only", "and"].indexOf(a2.value) !== -1 && (a2.type = "keyword"), a2.type === "media-feature-expression" && (a2.nodes = s2(a2.value, a2.sourceIndex)), r4.push(Array.isArray(a2.nodes) ? new o2.default(a2) : new n2.default(a2)), a2 = {before: "", after: "", value: ""}, u3 = false);
          }
          for (var f2 = 0; f2 < r4.length; f2++)
            if (a2 = r4[f2], f2 > 0 && (r4[f2 - 1].after = a2.before), a2.type === void 0) {
              if (f2 > 0) {
                if (r4[f2 - 1].type === "media-feature-expression") {
                  a2.type = "keyword";
                  continue;
                }
                if (r4[f2 - 1].value === "not" || r4[f2 - 1].value === "only") {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 - 1].value === "and") {
                  a2.type = "media-feature-expression";
                  continue;
                }
                r4[f2 - 1].type === "media-type" && (r4[f2 + 1] ? a2.type = r4[f2 + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : a2.type = "media-feature-expression");
              }
              if (f2 === 0) {
                if (!r4[f2 + 1]) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 1] && (r4[f2 + 1].type === "media-feature-expression" || r4[f2 + 1].type === "keyword")) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 2]) {
                  if (r4[f2 + 2].type === "media-feature-expression") {
                    a2.type = "media-type", r4[f2 + 1].type = "keyword";
                    continue;
                  }
                  if (r4[f2 + 2].type === "keyword") {
                    a2.type = "keyword", r4[f2 + 1].type = "media-type";
                    continue;
                  }
                }
                if (r4[f2 + 3] && r4[f2 + 3].type === "media-feature-expression") {
                  a2.type = "keyword", r4[f2 + 1].type = "media-type", r4[f2 + 2].type = "keyword";
                  continue;
                }
              }
            }
          return r4;
        }
      }, 5822: (e22, t4, r3) => {
        var n2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "decl", r5.isNested = true, r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(r3(1204));
        e22.exports = n2;
      }, 1945: (e22, t4, r3) => {
        var n2 = r3(2993), o2 = r3(1713);
        e22.exports = function(e23, t5) {
          var r4 = new n2(e23, t5), i2 = new o2(r4);
          return i2.parse(), i2.root;
        };
      }, 1713: (e22, t4, r3) => {
        var n2 = r3(3102), o2 = r3(7116), i2 = r3(5822), s2 = r3(6256), u2 = function(e23) {
          var t5, r4;
          function o3() {
            return e23.apply(this, arguments) || this;
          }
          r4 = e23, (t5 = o3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = o3.prototype;
          return u3.createTokenizer = function() {
            this.tokenizer = s2(this.input);
          }, u3.rule = function(t6) {
            var r5 = false, n3 = 0, o4 = "", s3 = t6, u4 = Array.isArray(s3), a2 = 0;
            for (s3 = u4 ? s3 : s3[Symbol.iterator](); ; ) {
              var c2;
              if (u4) {
                if (a2 >= s3.length)
                  break;
                c2 = s3[a2++];
              } else {
                if ((a2 = s3.next()).done)
                  break;
                c2 = a2.value;
              }
              var l2 = c2;
              if (r5)
                l2[0] !== "comment" && l2[0] !== "{" && (o4 += l2[1]);
              else {
                if (l2[0] === "space" && l2[1].indexOf("\n") !== -1)
                  break;
                l2[0] === "(" ? n3 += 1 : l2[0] === ")" ? n3 -= 1 : n3 === 0 && l2[0] === ":" && (r5 = true);
              }
            }
            if (!r5 || o4.trim() === "" || /^[a-zA-Z-:#]/.test(o4))
              e23.prototype.rule.call(this, t6);
            else {
              t6.pop();
              var f2 = new i2();
              this.init(f2);
              var p2, h2 = t6[t6.length - 1];
              for (h2[4] ? f2.source.end = {line: h2[4], column: h2[5]} : f2.source.end = {line: h2[2], column: h2[3]}; t6[0][0] !== "word"; )
                f2.raws.before += t6.shift()[1];
              for (f2.source.start = {line: t6[0][2], column: t6[0][3]}, f2.prop = ""; t6.length; ) {
                var d2 = t6[0][0];
                if (d2 === ":" || d2 === "space" || d2 === "comment")
                  break;
                f2.prop += t6.shift()[1];
              }
              for (f2.raws.between = ""; t6.length; ) {
                if ((p2 = t6.shift())[0] === ":") {
                  f2.raws.between += p2[1];
                  break;
                }
                f2.raws.between += p2[1];
              }
              f2.prop[0] !== "_" && f2.prop[0] !== "*" || (f2.raws.before += f2.prop[0], f2.prop = f2.prop.slice(1)), f2.raws.between += this.spacesAndCommentsFromStart(t6), this.precheckMissedSemicolon(t6);
              for (var D2 = t6.length - 1; D2 > 0; D2--) {
                if ((p2 = t6[D2])[1] === "!important") {
                  f2.important = true;
                  var g2 = this.stringFrom(t6, D2);
                  (g2 = this.spacesFromEnd(t6) + g2) !== " !important" && (f2.raws.important = g2);
                  break;
                }
                if (p2[1] === "important") {
                  for (var m2 = t6.slice(0), v2 = "", y2 = D2; y2 > 0; y2--) {
                    var w2 = m2[y2][0];
                    if (v2.trim().indexOf("!") === 0 && w2 !== "space")
                      break;
                    v2 = m2.pop()[1] + v2;
                  }
                  v2.trim().indexOf("!") === 0 && (f2.important = true, f2.raws.important = v2, t6 = m2);
                }
                if (p2[0] !== "space" && p2[0] !== "comment")
                  break;
              }
              this.raw(f2, "value", t6), f2.value.indexOf(":") !== -1 && this.checkMissedSemicolon(t6), this.current = f2;
            }
          }, u3.comment = function(t6) {
            if (t6[6] === "inline") {
              var r5 = new n2();
              this.init(r5, t6[2], t6[3]), r5.raws.inline = true, r5.source.end = {line: t6[4], column: t6[5]};
              var o4 = t6[1].slice(2);
              if (/^\s*$/.test(o4))
                r5.text = "", r5.raws.left = o4, r5.raws.right = "";
              else {
                var i3 = o4.match(/^(\s*)([^]*[^\s])(\s*)$/), s3 = i3[2].replace(/(\*\/|\/\*)/g, "*//*");
                r5.text = s3, r5.raws.left = i3[1], r5.raws.right = i3[3], r5.raws.text = i3[2];
              }
            } else
              e23.prototype.comment.call(this, t6);
          }, u3.raw = function(t6, r5, n3) {
            if (e23.prototype.raw.call(this, t6, r5, n3), t6.raws[r5]) {
              var o4 = t6.raws[r5].raw;
              t6.raws[r5].raw = n3.reduce(function(e24, t7) {
                return t7[0] === "comment" && t7[6] === "inline" ? e24 + "/*" + t7[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*") + "*/" : e24 + t7[1];
              }, ""), o4 !== t6.raws[r5].raw && (t6.raws[r5].scss = o4);
            }
          }, o3;
        }(o2);
        e22.exports = u2;
      }, 9235: (e22, t4, r3) => {
        var n2 = function(e23) {
          var t5, r4;
          function n3() {
            return e23.apply(this, arguments) || this;
          }
          r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o2 = n3.prototype;
          return o2.comment = function(e24) {
            var t6 = this.raw(e24, "left", "commentLeft"), r5 = this.raw(e24, "right", "commentRight");
            if (e24.raws.inline) {
              var n4 = e24.raws.text || e24.text;
              this.builder("//" + t6 + n4 + r5, e24);
            } else
              this.builder("/*" + t6 + e24.text + r5 + "*/", e24);
          }, o2.decl = function(t6, r5) {
            if (t6.isNested) {
              var n4, o3 = this.raw(t6, "between", "colon"), i2 = t6.prop + o3 + this.rawValue(t6, "value");
              t6.important && (i2 += t6.raws.important || " !important"), this.builder(i2 + "{", t6, "start"), t6.nodes && t6.nodes.length ? (this.body(t6), n4 = this.raw(t6, "after")) : n4 = this.raw(t6, "after", "emptyBody"), n4 && this.builder(n4), this.builder("}", t6, "end");
            } else
              e23.prototype.decl.call(this, t6, r5);
          }, o2.rawValue = function(e24, t6) {
            var r5 = e24[t6], n4 = e24.raws[t6];
            return n4 && n4.value === r5 ? n4.scss ? n4.scss : n4.raw : r5;
          }, n3;
        }(r3(5701));
        e22.exports = n2;
      }, 4933: (e22, t4, r3) => {
        var n2 = r3(9235);
        e22.exports = function(e23, t5) {
          new n2(t5).stringify(e23);
        };
      }, 304: (e22, t4, r3) => {
        var n2 = r3(4933), o2 = r3(1945);
        e22.exports = {parse: o2, stringify: n2};
      }, 6256: (e22) => {
        var t4 = "'".charCodeAt(0), r3 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), o2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), s2 = " ".charCodeAt(0), u2 = "\f".charCodeAt(0), a2 = "	".charCodeAt(0), c2 = "\r".charCodeAt(0), l2 = "[".charCodeAt(0), f2 = "]".charCodeAt(0), p2 = "(".charCodeAt(0), h2 = ")".charCodeAt(0), d2 = "{".charCodeAt(0), D2 = "}".charCodeAt(0), g2 = ";".charCodeAt(0), m2 = "*".charCodeAt(0), v2 = ":".charCodeAt(0), y2 = "@".charCodeAt(0), w2 = ",".charCodeAt(0), b2 = "#".charCodeAt(0), C2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, E2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, F2 = /.[\\/("'\n]/, x2 = /[a-f0-9]/i, A2 = /[\r\f\n]/g;
        e22.exports = function(e23, k2) {
          k2 === void 0 && (k2 = {});
          var O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2, $2, U2, G2 = e23.css.valueOf(), W2 = k2.ignoreErrors, z2 = G2.length, V2 = -1, q2 = 1, X2 = 0, J2 = [], H2 = [];
          function Y2(t5) {
            throw e23.error("Unclosed " + t5, q2, X2 - V2);
          }
          function K2() {
            for (var e24 = 1, o3 = false, i3 = false; e24 > 0; )
              _2 += 1, G2.length <= _2 && Y2("interpolation"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), o3 ? i3 || O2 !== o3 ? O2 === n2 ? i3 = !L2 : i3 && (i3 = false) : (o3 = false, i3 = false) : O2 === t4 || O2 === r3 ? o3 = O2 : O2 === D2 ? e24 -= 1 : O2 === b2 && P2 === d2 && (e24 += 1);
          }
          return {back: function(e24) {
            H2.push(e24);
          }, nextToken: function() {
            if (H2.length)
              return H2.pop();
            if (!(X2 >= z2)) {
              switch (((O2 = G2.charCodeAt(X2)) === i2 || O2 === u2 || O2 === c2 && G2.charCodeAt(X2 + 1) !== i2) && (V2 = X2, q2 += 1), O2) {
                case i2:
                case s2:
                case a2:
                case c2:
                case u2:
                  _2 = X2;
                  do {
                    _2 += 1, (O2 = G2.charCodeAt(_2)) === i2 && (V2 = _2, q2 += 1);
                  } while (O2 === s2 || O2 === i2 || O2 === a2 || O2 === c2 || O2 === u2);
                  $2 = ["space", G2.slice(X2, _2)], X2 = _2 - 1;
                  break;
                case l2:
                  $2 = ["[", "[", q2, X2 - V2];
                  break;
                case f2:
                  $2 = ["]", "]", q2, X2 - V2];
                  break;
                case d2:
                  $2 = ["{", "{", q2, X2 - V2];
                  break;
                case D2:
                  $2 = ["}", "}", q2, X2 - V2];
                  break;
                case w2:
                  $2 = ["word", ",", q2, X2 - V2, q2, X2 - V2 + 1];
                  break;
                case v2:
                  $2 = [":", ":", q2, X2 - V2];
                  break;
                case g2:
                  $2 = [";", ";", q2, X2 - V2];
                  break;
                case p2:
                  if (B2 = J2.length ? J2.pop()[1] : "", P2 = G2.charCodeAt(X2 + 1), B2 === "url" && P2 !== t4 && P2 !== r3) {
                    for (U2 = 1, L2 = false, _2 = X2 + 1; _2 <= G2.length - 1; ) {
                      if ((P2 = G2.charCodeAt(_2)) === n2)
                        L2 = !L2;
                      else if (P2 === p2)
                        U2 += 1;
                      else if (P2 === h2 && (U2 -= 1) == 0)
                        break;
                      _2 += 1;
                    }
                    N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["brackets", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                  } else
                    _2 = G2.indexOf(")", X2 + 1), N2 = G2.slice(X2, _2 + 1), _2 === -1 || F2.test(N2) ? $2 = ["(", "(", q2, X2 - V2] : ($2 = ["brackets", N2, q2, X2 - V2, q2, _2 - V2], X2 = _2);
                  break;
                case h2:
                  $2 = [")", ")", q2, X2 - V2];
                  break;
                case t4:
                case r3:
                  for (S2 = O2, _2 = X2, L2 = false; _2 < z2 && (++_2 === z2 && Y2("string"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), L2 || O2 !== S2); )
                    O2 === n2 ? L2 = !L2 : L2 ? L2 = false : O2 === b2 && P2 === d2 && K2();
                  N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["string", G2.slice(X2, _2 + 1), q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2;
                  break;
                case y2:
                  C2.lastIndex = X2 + 1, C2.test(G2), _2 = C2.lastIndex === 0 ? G2.length - 1 : C2.lastIndex - 2, $2 = ["at-word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                  break;
                case n2:
                  for (_2 = X2, M2 = true; G2.charCodeAt(_2 + 1) === n2; )
                    _2 += 1, M2 = !M2;
                  if (O2 = G2.charCodeAt(_2 + 1), M2 && O2 !== o2 && O2 !== s2 && O2 !== i2 && O2 !== a2 && O2 !== c2 && O2 !== u2 && (_2 += 1, x2.test(G2.charAt(_2)))) {
                    for (; x2.test(G2.charAt(_2 + 1)); )
                      _2 += 1;
                    G2.charCodeAt(_2 + 1) === s2 && (_2 += 1);
                  }
                  $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], X2 = _2;
                  break;
                default:
                  P2 = G2.charCodeAt(X2 + 1), O2 === b2 && P2 === d2 ? (_2 = X2, K2(), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["word", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === m2 ? ((_2 = G2.indexOf("*/", X2 + 2) + 1) === 0 && (W2 ? _2 = G2.length : Y2("comment")), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = ["comment", N2, q2, X2 - V2, R2, _2 - j2], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === o2 ? (A2.lastIndex = X2 + 1, A2.test(G2), _2 = A2.lastIndex === 0 ? G2.length - 1 : A2.lastIndex - 2, N2 = G2.slice(X2, _2 + 1), $2 = ["comment", N2, q2, X2 - V2, q2, _2 - V2, "inline"], X2 = _2) : (E2.lastIndex = X2 + 1, E2.test(G2), _2 = E2.lastIndex === 0 ? G2.length - 1 : E2.lastIndex - 2, $2 = ["word", G2.slice(X2, _2 + 1), q2, X2 - V2, q2, _2 - V2], J2.push($2), X2 = _2);
              }
              return X2++, $2;
            }
          }, endOfFile: function() {
            return H2.length === 0 && X2 >= z2;
          }};
        };
      }, 1264: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2 = m2(r3(2566)), o2 = m2(r3(616)), i2 = m2(r3(7835)), s2 = m2(r3(478)), u2 = m2(r3(4907)), a2 = m2(r3(8420)), c2 = m2(r3(7523)), l2 = m2(r3(4316)), f2 = m2(r3(6909)), p2 = m2(r3(6279)), h2 = m2(r3(439)), d2 = m2(r3(9956)), D2 = m2(r3(70)), g2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790));
        function m2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        var v2 = function(e23) {
          return new n2.default(e23);
        };
        v2.attribute = function(e23) {
          return new o2.default(e23);
        }, v2.className = function(e23) {
          return new i2.default(e23);
        }, v2.combinator = function(e23) {
          return new s2.default(e23);
        }, v2.comment = function(e23) {
          return new u2.default(e23);
        }, v2.id = function(e23) {
          return new a2.default(e23);
        }, v2.nesting = function(e23) {
          return new c2.default(e23);
        }, v2.pseudo = function(e23) {
          return new l2.default(e23);
        }, v2.root = function(e23) {
          return new f2.default(e23);
        }, v2.selector = function(e23) {
          return new p2.default(e23);
        }, v2.string = function(e23) {
          return new h2.default(e23);
        }, v2.tag = function(e23) {
          return new d2.default(e23);
        }, v2.universal = function(e23) {
          return new D2.default(e23);
        }, Object.keys(g2).forEach(function(e23) {
          e23 !== "__esModule" && (v2[e23] = g2[e23]);
        }), t4.default = v2, e22.exports = t4.default;
      }, 5269: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), o2 = C2(r3(8051)), i2 = C2(r3(7886)), s2 = C2(r3(3210)), u2 = C2(r3(6909)), a2 = C2(r3(6279)), c2 = C2(r3(7835)), l2 = C2(r3(4907)), f2 = C2(r3(8420)), p2 = C2(r3(9956)), h2 = C2(r3(439)), d2 = C2(r3(4316)), D2 = C2(r3(616)), g2 = C2(r3(70)), m2 = C2(r3(478)), v2 = C2(r3(7523)), y2 = C2(r3(9788)), w2 = C2(r3(6554)), b2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790));
        function C2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        var E2 = function() {
          function e23(t5) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e23), this.input = t5, this.lossy = t5.options.lossless === false, this.position = 0, this.root = new u2.default();
            var r4 = new a2.default();
            return this.root.append(r4), this.current = r4, this.lossy ? this.tokens = (0, w2.default)({safe: t5.safe, css: t5.css.trim()}) : this.tokens = (0, w2.default)(t5), this.loop();
          }
          return e23.prototype.attribute = function() {
            var e24 = "", t5 = void 0, r4 = this.currToken;
            for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
              e24 += this.tokens[this.position][1], this.position++;
            this.position !== this.tokens.length || ~e24.indexOf("]") || this.error("Expected a closing square bracket.");
            var n3 = e24.split(/((?:[*~^$|]?=))([^]*)/), o3 = n3[0].split(/(\|)/g), i3 = {operator: n3[1], value: n3[2], source: {start: {line: r4[2], column: r4[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: r4[4]};
            if (o3.length > 1 ? (o3[0] === "" && (o3[0] = true), i3.attribute = this.parseValue(o3[2]), i3.namespace = this.parseNamespace(o3[0])) : i3.attribute = this.parseValue(n3[0]), t5 = new D2.default(i3), n3[2]) {
              var s3 = n3[2].split(/(\s+i\s*?)$/), u3 = s3[0].trim();
              t5.value = this.lossy ? u3 : s3[0], s3[1] && (t5.insensitive = true, this.lossy || (t5.raws.insensitive = s3[1])), t5.quoted = u3[0] === "'" || u3[0] === '"', t5.raws.unquoted = t5.quoted ? u3.slice(1, -1) : u3;
            }
            this.newNode(t5), this.position++;
          }, e23.prototype.combinator = function() {
            if (this.currToken[1] === "|")
              return this.namespace();
            for (var e24 = new m2.default({value: "", source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
              this.nextToken && this.nextToken[0] === "combinator" ? (e24.spaces.before = this.parseSpace(this.currToken[1]), e24.source.start.line = this.nextToken[2], e24.source.start.column = this.nextToken[3], e24.source.end.column = this.nextToken[3], e24.source.end.line = this.nextToken[2], e24.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? e24.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? e24.value = this.currToken[1] : this.currToken[0] === "space" && (e24.value = this.parseSpace(this.currToken[1], " ")), this.position++;
            return this.newNode(e24);
          }, e23.prototype.comma = function() {
            if (this.position === this.tokens.length - 1)
              return this.root.trailingComma = true, void this.position++;
            var e24 = new a2.default();
            this.current.parent.append(e24), this.current = e24, this.position++;
          }, e23.prototype.comment = function() {
            var e24 = new l2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]});
            this.newNode(e24), this.position++;
          }, e23.prototype.error = function(e24) {
            throw new this.input.error(e24);
          }, e23.prototype.missingBackslash = function() {
            return this.error("Expected a backslash preceding the semicolon.");
          }, e23.prototype.missingParenthesis = function() {
            return this.error("Expected opening parenthesis.");
          }, e23.prototype.missingSquareBracket = function() {
            return this.error("Expected opening square bracket.");
          }, e23.prototype.namespace = function() {
            var e24 = this.prevToken && this.prevToken[1] || true;
            return this.nextToken[0] === "word" ? (this.position++, this.word(e24)) : this.nextToken[0] === "*" ? (this.position++, this.universal(e24)) : void 0;
          }, e23.prototype.nesting = function() {
            this.newNode(new v2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]})), this.position++;
          }, e23.prototype.parentheses = function() {
            var e24 = this.current.last;
            if (e24 && e24.type === b2.PSEUDO) {
              var t5 = new a2.default(), r4 = this.current;
              e24.append(t5), this.current = t5;
              var n3 = 1;
              for (this.position++; this.position < this.tokens.length && n3; )
                this.currToken[0] === "(" && n3++, this.currToken[0] === ")" && n3--, n3 ? this.parse() : (t5.parent.source.end.line = this.currToken[2], t5.parent.source.end.column = this.currToken[3], this.position++);
              n3 && this.error("Expected closing parenthesis."), this.current = r4;
            } else {
              var o3 = 1;
              for (this.position++, e24.value += "("; this.position < this.tokens.length && o3; )
                this.currToken[0] === "(" && o3++, this.currToken[0] === ")" && o3--, e24.value += this.parseParenthesisToken(this.currToken), this.position++;
              o3 && this.error("Expected closing parenthesis.");
            }
          }, e23.prototype.pseudo = function() {
            for (var e24 = this, t5 = "", r4 = this.currToken; this.currToken && this.currToken[0] === ":"; )
              t5 += this.currToken[1], this.position++;
            if (!this.currToken)
              return this.error("Expected pseudo-class or pseudo-element");
            if (this.currToken[0] === "word") {
              var n3 = void 0;
              this.splitWord(false, function(o3, i3) {
                t5 += o3, n3 = new d2.default({value: t5, source: {start: {line: r4[2], column: r4[3]}, end: {line: e24.currToken[4], column: e24.currToken[5]}}, sourceIndex: r4[4]}), e24.newNode(n3), i3 > 1 && e24.nextToken && e24.nextToken[0] === "(" && e24.error("Misplaced parenthesis.");
              });
            } else
              this.error('Unexpected "' + this.currToken[0] + '" found.');
          }, e23.prototype.space = function() {
            var e24 = this.currToken;
            this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(e24[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(e24[1]), this.position++) : this.combinator();
          }, e23.prototype.string = function() {
            var e24 = this.currToken;
            this.newNode(new h2.default({value: this.currToken[1], source: {start: {line: e24[2], column: e24[3]}, end: {line: e24[4], column: e24[5]}}, sourceIndex: e24[6]})), this.position++;
          }, e23.prototype.universal = function(e24) {
            var t5 = this.nextToken;
            if (t5 && t5[1] === "|")
              return this.position++, this.namespace();
            this.newNode(new g2.default({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}), e24), this.position++;
          }, e23.prototype.splitWord = function(e24, t5) {
            for (var r4 = this, n3 = this.nextToken, u3 = this.currToken[1]; n3 && n3[0] === "word"; ) {
              this.position++;
              var a3 = this.currToken[1];
              if (u3 += a3, a3.lastIndexOf("\\") === a3.length - 1) {
                var l3 = this.nextToken;
                l3 && l3[0] === "space" && (u3 += this.parseSpace(l3[1], " "), this.position++);
              }
              n3 = this.nextToken;
            }
            var h3 = (0, i2.default)(u3, "."), d3 = (0, i2.default)(u3, "#"), D3 = (0, i2.default)(u3, "#{");
            D3.length && (d3 = d3.filter(function(e25) {
              return !~D3.indexOf(e25);
            }));
            var g3 = (0, y2.default)((0, s2.default)((0, o2.default)([[0], h3, d3])));
            g3.forEach(function(n4, o3) {
              var i3 = g3[o3 + 1] || u3.length, s3 = u3.slice(n4, i3);
              if (o3 === 0 && t5)
                return t5.call(r4, s3, g3.length);
              var a4 = void 0;
              a4 = ~h3.indexOf(n4) ? new c2.default({value: s3.slice(1), source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}) : ~d3.indexOf(n4) ? new f2.default({value: s3.slice(1), source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}) : new p2.default({value: s3, source: {start: {line: r4.currToken[2], column: r4.currToken[3] + n4}, end: {line: r4.currToken[4], column: r4.currToken[3] + (i3 - 1)}}, sourceIndex: r4.currToken[6] + g3[o3]}), r4.newNode(a4, e24);
            }), this.position++;
          }, e23.prototype.word = function(e24) {
            var t5 = this.nextToken;
            return t5 && t5[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(e24);
          }, e23.prototype.loop = function() {
            for (; this.position < this.tokens.length; )
              this.parse(true);
            return this.root;
          }, e23.prototype.parse = function(e24) {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parentheses();
                break;
              case ")":
                e24 && this.missingParenthesis();
                break;
              case "[":
                this.attribute();
                break;
              case "]":
                this.missingSquareBracket();
                break;
              case "at-word":
              case "word":
                this.word();
                break;
              case ":":
                this.pseudo();
                break;
              case ";":
                this.missingBackslash();
                break;
              case ",":
                this.comma();
                break;
              case "*":
                this.universal();
                break;
              case "&":
                this.nesting();
                break;
              case "combinator":
                this.combinator();
                break;
              case "string":
                this.string();
            }
          }, e23.prototype.parseNamespace = function(e24) {
            if (this.lossy && typeof e24 == "string") {
              var t5 = e24.trim();
              return !t5.length || t5;
            }
            return e24;
          }, e23.prototype.parseSpace = function(e24, t5) {
            return this.lossy ? t5 || "" : e24;
          }, e23.prototype.parseValue = function(e24) {
            return this.lossy && e24 && typeof e24 == "string" ? e24.trim() : e24;
          }, e23.prototype.parseParenthesisToken = function(e24) {
            return this.lossy ? e24[0] === "space" ? this.parseSpace(e24[1], " ") : this.parseValue(e24[1]) : e24[1];
          }, e23.prototype.newNode = function(e24, t5) {
            return t5 && (e24.namespace = this.parseNamespace(t5)), this.spaces && (e24.spaces.before = this.spaces, this.spaces = ""), this.current.append(e24);
          }, n2(e23, [{key: "currToken", get: function() {
            return this.tokens[this.position];
          }}, {key: "nextToken", get: function() {
            return this.tokens[this.position + 1];
          }}, {key: "prevToken", get: function() {
            return this.tokens[this.position - 1];
          }}]), e23;
        }();
        t4.default = E2, e22.exports = t4.default;
      }, 2566: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(5269)) && n2.__esModule ? n2 : {default: n2}, s2 = function() {
          function e23(t5) {
            return function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e23), this.func = t5 || function() {
            }, this;
          }
          return e23.prototype.process = function(e24) {
            var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r4 = new i2.default({css: e24, error: function(e25) {
              throw new Error(e25);
            }, options: t5});
            return this.res = r4, this.func(r4), this;
          }, o2(e23, [{key: "result", get: function() {
            return String(this.res);
          }}]), e23;
        }();
        t4.default = s2, e22.exports = t4.default;
      }, 616: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ATTRIBUTE, n3.raws = {}, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = [this.spaces.before, "[", this.ns, this.attribute];
            return this.operator && e24.push(this.operator), this.value && e24.push(this.value), this.raws.insensitive ? e24.push(this.raws.insensitive) : this.insensitive && e24.push(" i"), e24.push("]"), e24.concat(this.spaces.after).join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 7835: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.CLASS, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 478: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.COMBINATOR, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 4907: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.COMMENT, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 7144: (e22, t4, r3) => {
        r3(4070), t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, s2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790)), u2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.nodes || (n3.nodes = []), n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.append = function(e24) {
            return e24.parent = this, this.nodes.push(e24), this;
          }, t5.prototype.prepend = function(e24) {
            return e24.parent = this, this.nodes.unshift(e24), this;
          }, t5.prototype.at = function(e24) {
            return this.nodes[e24];
          }, t5.prototype.index = function(e24) {
            return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
          }, t5.prototype.removeChild = function(e24) {
            e24 = this.index(e24), this.at(e24).parent = void 0, this.nodes.splice(e24, 1);
            var t6 = void 0;
            for (var r4 in this.indexes)
              (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
            return this;
          }, t5.prototype.removeAll = function() {
            var e24 = this.nodes, t6 = Array.isArray(e24), r4 = 0;
            for (e24 = t6 ? e24 : e24[Symbol.iterator](); ; ) {
              var n3;
              if (t6) {
                if (r4 >= e24.length)
                  break;
                n3 = e24[r4++];
              } else {
                if ((r4 = e24.next()).done)
                  break;
                n3 = r4.value;
              }
              n3.parent = void 0;
            }
            return this.nodes = [], this;
          }, t5.prototype.empty = function() {
            return this.removeAll();
          }, t5.prototype.insertAfter = function(e24, t6) {
            var r4 = this.index(e24);
            this.nodes.splice(r4 + 1, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.insertBefore = function(e24, t6) {
            var r4 = this.index(e24);
            this.nodes.splice(r4, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.each = function(e24) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.length) {
              for (var r4 = void 0, n3 = void 0; this.indexes[t6] < this.length && (r4 = this.indexes[t6], (n3 = e24(this.at(r4), r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3 !== false && void 0;
            }
          }, t5.prototype.walk = function(e24) {
            return this.each(function(t6, r4) {
              var n3 = e24(t6, r4);
              if (n3 !== false && t6.length && (n3 = t6.walk(e24)), n3 === false)
                return false;
            });
          }, t5.prototype.walkAttributes = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ATTRIBUTE)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkClasses = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.CLASS)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkCombinators = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMBINATOR)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkComments = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMMENT)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkIds = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ID)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkNesting = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.NESTING)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkPseudos = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.PSEUDO)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkTags = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.TAG)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkUniversals = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.UNIVERSAL)
                return e24.call(t6, r4);
            });
          }, t5.prototype.split = function(e24) {
            var t6 = this, r4 = [];
            return this.reduce(function(n3, o3, i3) {
              var s3 = e24.call(t6, o3);
              return r4.push(o3), s3 ? (n3.push(r4), r4 = []) : i3 === t6.length - 1 && n3.push(r4), n3;
            }, []);
          }, t5.prototype.map = function(e24) {
            return this.nodes.map(e24);
          }, t5.prototype.reduce = function(e24, t6) {
            return this.nodes.reduce(e24, t6);
          }, t5.prototype.every = function(e24) {
            return this.nodes.every(e24);
          }, t5.prototype.some = function(e24) {
            return this.nodes.some(e24);
          }, t5.prototype.filter = function(e24) {
            return this.nodes.filter(e24);
          }, t5.prototype.sort = function(e24) {
            return this.nodes.sort(e24);
          }, t5.prototype.toString = function() {
            return this.map(String).join("");
          }, o2(t5, [{key: "first", get: function() {
            return this.at(0);
          }}, {key: "last", get: function() {
            return this.at(this.length - 1);
          }}, {key: "length", get: function() {
            return this.nodes.length;
          }}]), t5;
        }(i2.default);
        t4.default = u2, e22.exports = t4.default;
      }, 8420: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ID, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 4379: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }();
        function i2(e23, t5) {
          if (!(e23 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        function s2(e23, t5) {
          if (!e23)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !t5 || typeof t5 != "object" && typeof t5 != "function" ? e23 : t5;
        }
        var u2 = function(e23) {
          function t5() {
            return i2(this, t5), s2(this, e23.apply(this, arguments));
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
          }, o2(t5, [{key: "ns", get: function() {
            var e24 = this.namespace;
            return e24 ? (typeof e24 == "string" ? e24 : "") + "|" : "";
          }}]), t5;
        }(((n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}).default);
        t4.default = u2, e22.exports = t4.default;
      }, 7523: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.NESTING, n3.value = "&", n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 8871: (e22, t4) => {
        t4.__esModule = true;
        var r3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e23) {
          return typeof e23;
        } : function(e23) {
          return e23 && typeof Symbol == "function" && e23.constructor === Symbol && e23 !== Symbol.prototype ? "symbol" : typeof e23;
        };
        function n2(e23, t5) {
          if (!(e23 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        var o2 = function e23(t5, n3) {
          if ((t5 === void 0 ? "undefined" : r3(t5)) !== "object")
            return t5;
          var o3 = new t5.constructor();
          for (var i3 in t5)
            if (t5.hasOwnProperty(i3)) {
              var s2 = t5[i3], u2 = s2 === void 0 ? "undefined" : r3(s2);
              i3 === "parent" && u2 === "object" ? n3 && (o3[i3] = n3) : o3[i3] = s2 instanceof Array ? s2.map(function(t6) {
                return e23(t6, o3);
              }) : e23(s2, o3);
            }
          return o3;
        }, i2 = function() {
          function e23() {
            var t5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            for (var r4 in n2(this, e23), t5)
              this[r4] = t5[r4];
            var o3 = t5.spaces, i3 = (o3 = o3 === void 0 ? {} : o3).before, s2 = i3 === void 0 ? "" : i3, u2 = o3.after, a2 = u2 === void 0 ? "" : u2;
            this.spaces = {before: s2, after: a2};
          }
          return e23.prototype.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, e23.prototype.replaceWith = function() {
            if (this.parent) {
              for (var e24 in arguments)
                this.parent.insertBefore(this, arguments[e24]);
              this.remove();
            }
            return this;
          }, e23.prototype.next = function() {
            return this.parent.at(this.parent.index(this) + 1);
          }, e23.prototype.prev = function() {
            return this.parent.at(this.parent.index(this) - 1);
          }, e23.prototype.clone = function() {
            var e24 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t5 = o2(this);
            for (var r4 in e24)
              t5[r4] = e24[r4];
            return t5;
          }, e23.prototype.toString = function() {
            return [this.spaces.before, String(this.value), this.spaces.after].join("");
          }, e23;
        }();
        t4.default = i2, e22.exports = t4.default;
      }, 4316: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.PSEUDO, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [this.spaces.before, String(this.value), e24, this.spaces.after].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 6909: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ROOT, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = this.reduce(function(e25, t6) {
              var r4 = String(t6);
              return r4 ? e25 + r4 + "," : "";
            }, "").slice(0, -1);
            return this.trailingComma ? e24 + "," : e24;
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 6279: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.SELECTOR, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 439: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.STRING, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 9956: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.TAG, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 8790: (e22, t4) => {
        t4.__esModule = true, t4.TAG = "tag", t4.STRING = "string", t4.SELECTOR = "selector", t4.ROOT = "root", t4.PSEUDO = "pseudo", t4.NESTING = "nesting", t4.ID = "id", t4.COMMENT = "comment", t4.COMBINATOR = "combinator", t4.CLASS = "class", t4.ATTRIBUTE = "attribute", t4.UNIVERSAL = "universal";
      }, 70: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : {default: n2}, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.UNIVERSAL, n3.value = "*", n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {constructor: {value: e24, enumerable: false, writable: true, configurable: true}}), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      }, 9788: (e22, t4, r3) => {
        r3(4070), t4.__esModule = true, t4.default = function(e23) {
          return e23.sort(function(e24, t5) {
            return e24 - t5;
          });
        }, e22.exports = t4.default;
      }, 6554: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23) {
          for (var t5 = [], o2 = e23.css.valueOf(), i2 = void 0, s2 = void 0, u2 = void 0, a2 = void 0, c2 = void 0, l2 = void 0, f2 = void 0, p2 = void 0, h2 = void 0, d2 = void 0, D2 = void 0, g2 = o2.length, m2 = -1, v2 = 1, y2 = 0, w2 = function(t6, r4) {
            if (!e23.safe)
              throw e23.error("Unclosed " + t6, v2, y2 - m2, y2);
            s2 = (o2 += r4).length - 1;
          }; y2 < g2; ) {
            switch ((i2 = o2.charCodeAt(y2)) === 10 && (m2 = y2, v2 += 1), i2) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12:
                s2 = y2;
                do {
                  s2 += 1, (i2 = o2.charCodeAt(s2)) === 10 && (m2 = s2, v2 += 1);
                } while (i2 === 32 || i2 === 10 || i2 === 9 || i2 === 13 || i2 === 12);
                t5.push(["space", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
                break;
              case 43:
              case 62:
              case 126:
              case 124:
                s2 = y2;
                do {
                  s2 += 1, i2 = o2.charCodeAt(s2);
                } while (i2 === 43 || i2 === 62 || i2 === 126 || i2 === 124);
                t5.push(["combinator", o2.slice(y2, s2), v2, y2 - m2, y2]), y2 = s2 - 1;
                break;
              case 42:
                t5.push(["*", "*", v2, y2 - m2, y2]);
                break;
              case 38:
                t5.push(["&", "&", v2, y2 - m2, y2]);
                break;
              case 44:
                t5.push([",", ",", v2, y2 - m2, y2]);
                break;
              case 91:
                t5.push(["[", "[", v2, y2 - m2, y2]);
                break;
              case 93:
                t5.push(["]", "]", v2, y2 - m2, y2]);
                break;
              case 58:
                t5.push([":", ":", v2, y2 - m2, y2]);
                break;
              case 59:
                t5.push([";", ";", v2, y2 - m2, y2]);
                break;
              case 40:
                t5.push(["(", "(", v2, y2 - m2, y2]);
                break;
              case 41:
                t5.push([")", ")", v2, y2 - m2, y2]);
                break;
              case 39:
              case 34:
                u2 = i2 === 39 ? "'" : '"', s2 = y2;
                do {
                  for (d2 = false, (s2 = o2.indexOf(u2, s2 + 1)) === -1 && w2("quote", u2), D2 = s2; o2.charCodeAt(D2 - 1) === 92; )
                    D2 -= 1, d2 = !d2;
                } while (d2);
                t5.push(["string", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              case 64:
                r3.lastIndex = y2 + 1, r3.test(o2), s2 = r3.lastIndex === 0 ? o2.length - 1 : r3.lastIndex - 2, t5.push(["at-word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              case 92:
                for (s2 = y2, f2 = true; o2.charCodeAt(s2 + 1) === 92; )
                  s2 += 1, f2 = !f2;
                i2 = o2.charCodeAt(s2 + 1), f2 && i2 !== 47 && i2 !== 32 && i2 !== 10 && i2 !== 9 && i2 !== 13 && i2 !== 12 && (s2 += 1), t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2;
                break;
              default:
                i2 === 47 && o2.charCodeAt(y2 + 1) === 42 ? ((s2 = o2.indexOf("*/", y2 + 2) + 1) === 0 && w2("comment", "*/"), (c2 = (a2 = (l2 = o2.slice(y2, s2 + 1)).split("\n")).length - 1) > 0 ? (p2 = v2 + c2, h2 = s2 - a2[c2].length) : (p2 = v2, h2 = m2), t5.push(["comment", l2, v2, y2 - m2, p2, s2 - h2, y2]), m2 = h2, v2 = p2, y2 = s2) : (n2.lastIndex = y2 + 1, n2.test(o2), s2 = n2.lastIndex === 0 ? o2.length - 1 : n2.lastIndex - 2, t5.push(["word", o2.slice(y2, s2 + 1), v2, y2 - m2, v2, s2 - m2, y2]), y2 = s2);
            }
            y2++;
          }
          return t5;
        };
        var r3 = /[ \n\t\r\{\(\)'"\\;/]/g, n2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
        e22.exports = t4.default;
      }, 5294: (e22, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.type = "atword";
          }
          toString() {
            return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
          }
        }
        n2.registerWalker(o2), e22.exports = o2;
      }, 8709: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "colon";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 3627: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "comma";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 4384: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "comment", this.inline = Object(e23).inline || false;
          }
          toString() {
            return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 4196: (e22, t4, r3) => {
        const n2 = r3(1466);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.nodes || (this.nodes = []);
          }
          push(e23) {
            return e23.parent = this, this.nodes.push(e23), this;
          }
          each(e23) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let t5, r4, n3 = this.lastEach;
            if (this.indexes[n3] = 0, this.nodes) {
              for (; this.indexes[n3] < this.nodes.length && (t5 = this.indexes[n3], r4 = e23(this.nodes[t5], t5), r4 !== false); )
                this.indexes[n3] += 1;
              return delete this.indexes[n3], r4;
            }
          }
          walk(e23) {
            return this.each((t5, r4) => {
              let n3 = e23(t5, r4);
              return n3 !== false && t5.walk && (n3 = t5.walk(e23)), n3;
            });
          }
          walkType(e23, t5) {
            if (!e23 || !t5)
              throw new Error("Parameters {type} and {callback} are required.");
            const r4 = typeof e23 == "function";
            return this.walk((n3, o3) => {
              if (r4 && n3 instanceof e23 || !r4 && n3.type === e23)
                return t5.call(this, n3, o3);
            });
          }
          append(e23) {
            return e23.parent = this, this.nodes.push(e23), this;
          }
          prepend(e23) {
            return e23.parent = this, this.nodes.unshift(e23), this;
          }
          cleanRaws(e23) {
            if (super.cleanRaws(e23), this.nodes)
              for (let t5 of this.nodes)
                t5.cleanRaws(e23);
          }
          insertAfter(e23, t5) {
            let r4, n3 = this.index(e23);
            this.nodes.splice(n3 + 1, 0, t5);
            for (let e24 in this.indexes)
              r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
            return this;
          }
          insertBefore(e23, t5) {
            let r4, n3 = this.index(e23);
            this.nodes.splice(n3, 0, t5);
            for (let e24 in this.indexes)
              r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
            return this;
          }
          removeChild(e23) {
            let t5;
            e23 = this.index(e23), this.nodes[e23].parent = void 0, this.nodes.splice(e23, 1);
            for (let r4 in this.indexes)
              t5 = this.indexes[r4], t5 >= e23 && (this.indexes[r4] = t5 - 1);
            return this;
          }
          removeAll() {
            for (let e23 of this.nodes)
              e23.parent = void 0;
            return this.nodes = [], this;
          }
          every(e23) {
            return this.nodes.every(e23);
          }
          some(e23) {
            return this.nodes.some(e23);
          }
          index(e23) {
            return typeof e23 == "number" ? e23 : this.nodes.indexOf(e23);
          }
          get first() {
            if (this.nodes)
              return this.nodes[0];
          }
          get last() {
            if (this.nodes)
              return this.nodes[this.nodes.length - 1];
          }
          toString() {
            let e23 = this.nodes.map(String).join("");
            return this.value && (e23 = this.value + e23), this.raws.before && (e23 = this.raws.before + e23), this.raws.after && (e23 += this.raws.after), e23;
          }
        }
        o2.registerWalker = (e23) => {
          let t5 = "walk" + e23.name;
          t5.lastIndexOf("s") !== t5.length - 1 && (t5 += "s"), o2.prototype[t5] || (o2.prototype[t5] = function(t6) {
            return this.walkType(e23, t6);
          });
        }, e22.exports = o2;
      }, 9645: (e22) => {
        class t4 extends Error {
          constructor(e23) {
            super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
          }
        }
        e22.exports = t4;
      }, 5128: (e22) => {
        class t4 extends Error {
          constructor(e23) {
            super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
          }
        }
        e22.exports = t4;
      }, 4320: (e22, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.type = "func", this.unbalanced = -1;
          }
        }
        n2.registerWalker(o2), e22.exports = o2;
      }, 9962: (e22, t4, r3) => {
        const n2 = r3(3784), o2 = r3(5294), i2 = r3(8709), s2 = r3(3627), u2 = r3(4384), a2 = r3(4320), c2 = r3(3074), l2 = r3(7214), f2 = r3(1238), p2 = r3(9672), h2 = r3(1369), d2 = r3(2057), D2 = r3(6593);
        let g2 = function(e23, t5) {
          return new n2(e23, t5);
        };
        g2.atword = function(e23) {
          return new o2(e23);
        }, g2.colon = function(e23) {
          return new i2(Object.assign({value: ":"}, e23));
        }, g2.comma = function(e23) {
          return new s2(Object.assign({value: ","}, e23));
        }, g2.comment = function(e23) {
          return new u2(e23);
        }, g2.func = function(e23) {
          return new a2(e23);
        }, g2.number = function(e23) {
          return new c2(e23);
        }, g2.operator = function(e23) {
          return new l2(e23);
        }, g2.paren = function(e23) {
          return new f2(Object.assign({value: "("}, e23));
        }, g2.string = function(e23) {
          return new p2(Object.assign({quote: "'"}, e23));
        }, g2.value = function(e23) {
          return new d2(e23);
        }, g2.word = function(e23) {
          return new D2(e23);
        }, g2.unicodeRange = function(e23) {
          return new h2(e23);
        }, e22.exports = g2;
      }, 1466: (e22) => {
        let t4 = function(e23, r3) {
          let n2 = new e23.constructor();
          for (let o2 in e23) {
            if (!e23.hasOwnProperty(o2))
              continue;
            let i2 = e23[o2], s2 = typeof i2;
            o2 === "parent" && s2 === "object" ? r3 && (n2[o2] = r3) : o2 === "source" ? n2[o2] = i2 : i2 instanceof Array ? n2[o2] = i2.map((e24) => t4(e24, n2)) : o2 !== "before" && o2 !== "after" && o2 !== "between" && o2 !== "semicolon" && (s2 === "object" && i2 !== null && (i2 = t4(i2)), n2[o2] = i2);
          }
          return n2;
        };
        e22.exports = class {
          constructor(e23) {
            e23 = e23 || {}, this.raws = {before: "", after: ""};
            for (let t5 in e23)
              this[t5] = e23[t5];
          }
          remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }
          toString() {
            return [this.raws.before, String(this.value), this.raws.after].join("");
          }
          clone(e23) {
            e23 = e23 || {};
            let r3 = t4(this);
            for (let t5 in e23)
              r3[t5] = e23[t5];
            return r3;
          }
          cloneBefore(e23) {
            e23 = e23 || {};
            let t5 = this.clone(e23);
            return this.parent.insertBefore(this, t5), t5;
          }
          cloneAfter(e23) {
            e23 = e23 || {};
            let t5 = this.clone(e23);
            return this.parent.insertAfter(this, t5), t5;
          }
          replaceWith() {
            let e23 = Array.prototype.slice.call(arguments);
            if (this.parent) {
              for (let t5 of e23)
                this.parent.insertBefore(this, t5);
              this.remove();
            }
            return this;
          }
          moveTo(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.append(this), this;
          }
          moveBefore(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertBefore(e23, this), this;
          }
          moveAfter(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertAfter(e23, this), this;
          }
          next() {
            let e23 = this.parent.index(this);
            return this.parent.nodes[e23 + 1];
          }
          prev() {
            let e23 = this.parent.index(this);
            return this.parent.nodes[e23 - 1];
          }
          toJSON() {
            let e23 = {};
            for (let t5 in this) {
              if (!this.hasOwnProperty(t5))
                continue;
              if (t5 === "parent")
                continue;
              let r3 = this[t5];
              r3 instanceof Array ? e23[t5] = r3.map((e24) => typeof e24 == "object" && e24.toJSON ? e24.toJSON() : e24) : typeof r3 == "object" && r3.toJSON ? e23[t5] = r3.toJSON() : e23[t5] = r3;
            }
            return e23;
          }
          root() {
            let e23 = this;
            for (; e23.parent; )
              e23 = e23.parent;
            return e23;
          }
          cleanRaws(e23) {
            delete this.raws.before, delete this.raws.after, e23 || delete this.raws.between;
          }
          positionInside(e23) {
            let t5 = this.toString(), r3 = this.source.start.column, n2 = this.source.start.line;
            for (let o2 = 0; o2 < e23; o2++)
              t5[o2] === "\n" ? (r3 = 1, n2 += 1) : r3 += 1;
            return {line: n2, column: r3};
          }
          positionBy(e23) {
            let t5 = this.source.start;
            if (Object(e23).index)
              t5 = this.positionInside(e23.index);
            else if (Object(e23).word) {
              let r3 = this.toString().indexOf(e23.word);
              r3 !== -1 && (t5 = this.positionInside(r3));
            }
            return t5;
          }
        };
      }, 3074: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "number", this.unit = Object(e23).unit || "";
          }
          toString() {
            return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 7214: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "operator";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 1238: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "paren", this.parenType = "";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 3784: (e22, t4, r3) => {
        r3(4070);
        const n2 = r3(4343), o2 = r3(2057), i2 = r3(5294), s2 = r3(8709), u2 = r3(3627), a2 = r3(4384), c2 = r3(4320), l2 = r3(3074), f2 = r3(7214), p2 = r3(1238), h2 = r3(9672), d2 = r3(6593), D2 = r3(1369), g2 = r3(2481), m2 = r3(8051), v2 = r3(7886), y2 = r3(3210), w2 = r3(9645);
        e22.exports = class {
          constructor(e23, t5) {
            this.cache = [], this.input = e23, this.options = Object.assign({}, {loose: false}, t5), this.position = 0, this.unbalanced = 0, this.root = new n2();
            let r4 = new o2();
            this.root.append(r4), this.current = r4, this.tokens = g2(e23, this.options);
          }
          parse() {
            return this.loop();
          }
          colon() {
            let e23 = this.currToken;
            this.newNode(new s2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
          }
          comma() {
            let e23 = this.currToken;
            this.newNode(new u2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
          }
          comment() {
            let e23, t5 = false, r4 = this.currToken[1].replace(/\/\*|\*\//g, "");
            this.options.loose && r4.startsWith("//") && (r4 = r4.substring(2), t5 = true), e23 = new a2({value: r4, inline: t5, source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]}), this.newNode(e23), this.position++;
          }
          error(e23, t5) {
            throw new w2(e23 + ` at line: ${t5[2]}, column ${t5[3]}`);
          }
          loop() {
            for (; this.position < this.tokens.length; )
              this.parseTokens();
            return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
          }
          operator() {
            let e23, t5 = this.currToken[1];
            if (t5 === "+" || t5 === "-") {
              if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? (this.prevToken[0] !== "space" && this.prevToken[0] !== "(" || this.nextToken[0] !== "space" && this.nextToken[0] !== "word" || this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(") && this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "operator" && this.prevToken[0] !== "operator" || this.error("Syntax Error", this.currToken)), this.options.loose) {
                if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                  return this.word();
              } else if (this.nextToken[0] === "word")
                return this.word();
            }
            return e23 = new f2({value: this.currToken[1], source: {start: {line: this.currToken[2], column: this.currToken[3]}, end: {line: this.currToken[2], column: this.currToken[3]}}, sourceIndex: this.currToken[4]}), this.position++, this.newNode(e23);
          }
          parseTokens() {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "colon":
                this.colon();
                break;
              case "comma":
                this.comma();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parenOpen();
                break;
              case ")":
                this.parenClose();
                break;
              case "atword":
              case "word":
                this.word();
                break;
              case "operator":
                this.operator();
                break;
              case "string":
                this.string();
                break;
              case "unicoderange":
                this.unicodeRange();
                break;
              default:
                this.word();
            }
          }
          parenOpen() {
            let e23, t5 = 1, r4 = this.position + 1, n3 = this.currToken;
            for (; r4 < this.tokens.length && t5; ) {
              let e24 = this.tokens[r4];
              e24[0] === "(" && t5++, e24[0] === ")" && t5--, r4++;
            }
            if (t5 && this.error("Expected closing parenthesis", n3), e23 = this.current.last, e23 && e23.type === "func" && e23.unbalanced < 0 && (e23.unbalanced = 0, this.current = e23), this.current.unbalanced++, this.newNode(new p2({value: n3[1], source: {start: {line: n3[2], column: n3[3]}, end: {line: n3[4], column: n3[5]}}, sourceIndex: n3[6]})), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
              let e24 = this.nextToken, t6 = this.currToken[1], r5 = {line: this.currToken[2], column: this.currToken[3]};
              for (; e24 && e24[0] !== ")" && this.current.unbalanced; )
                this.position++, t6 += this.currToken[1], e24 = this.nextToken;
              this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d2({value: t6, source: {start: r5, end: {line: this.currToken[4], column: this.currToken[5]}}, sourceIndex: this.currToken[6]})));
            }
          }
          parenClose() {
            let e23 = this.currToken;
            this.newNode(new p2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++, this.position >= this.tokens.length - 1 && !this.current.unbalanced || (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e23), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
          }
          space() {
            let e23 = this.currToken;
            this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e23[1], this.position++) : (this.spaces = e23[1], this.position++);
          }
          unicodeRange() {
            let e23 = this.currToken;
            this.newNode(new D2({value: e23[1], source: {start: {line: e23[2], column: e23[3]}, end: {line: e23[4], column: e23[5]}}, sourceIndex: e23[6]})), this.position++;
          }
          splitWord() {
            let e23, t5, r4 = this.nextToken, n3 = this.currToken[1], o3 = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
            if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n3))
              for (; r4 && r4[0] === "word"; ) {
                this.position++;
                let e24 = this.currToken[1];
                n3 += e24, r4 = this.nextToken;
              }
            var s3;
            e23 = v2(n3, "@"), s3 = y2(m2([[0], e23])), t5 = s3.sort((e24, t6) => e24 - t6), t5.forEach((s4, u3) => {
              let a3, f3 = t5[u3 + 1] || n3.length, p3 = n3.slice(s4, f3);
              if (~e23.indexOf(s4))
                a3 = new i2({value: p3.slice(1), source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3]});
              else if (o3.test(this.currToken[1])) {
                let e24 = p3.replace(o3, "");
                a3 = new l2({value: p3.replace(e24, ""), source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3], unit: e24});
              } else
                a3 = new (r4 && r4[0] === "(" ? c2 : d2)({value: p3, source: {start: {line: this.currToken[2], column: this.currToken[3] + s4}, end: {line: this.currToken[4], column: this.currToken[3] + (f3 - 1)}}, sourceIndex: this.currToken[6] + t5[u3]}), a3.constructor.name === "Word" ? (a3.isHex = /^#(.+)/.test(p3), a3.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(p3)) : this.cache.push(this.current);
              this.newNode(a3);
            }), this.position++;
          }
          string() {
            let e23, t5 = this.currToken, r4 = this.currToken[1], n3 = /^(\"|\')/, o3 = n3.test(r4), i3 = "";
            o3 && (i3 = r4.match(n3)[0], r4 = r4.slice(1, r4.length - 1)), e23 = new h2({value: r4, source: {start: {line: t5[2], column: t5[3]}, end: {line: t5[4], column: t5[5]}}, sourceIndex: t5[6], quoted: o3}), e23.raws.quote = i3, this.newNode(e23), this.position++;
          }
          word() {
            return this.splitWord();
          }
          newNode(e23) {
            return this.spaces && (e23.raws.before += this.spaces, this.spaces = ""), this.current.append(e23);
          }
          get currToken() {
            return this.tokens[this.position];
          }
          get nextToken() {
            return this.tokens[this.position + 1];
          }
          get prevToken() {
            return this.tokens[this.position - 1];
          }
        };
      }, 4343: (e22, t4, r3) => {
        const n2 = r3(4196);
        e22.exports = class extends n2 {
          constructor(e23) {
            super(e23), this.type = "root";
          }
        };
      }, 9672: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "string";
          }
          toString() {
            let e23 = this.quoted ? this.raws.quote : "";
            return [this.raws.before, e23, this.value + "", e23, this.raws.after].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 2481: (e22, t4, r3) => {
        const n2 = "{".charCodeAt(0), o2 = "}".charCodeAt(0), i2 = "(".charCodeAt(0), s2 = ")".charCodeAt(0), u2 = "'".charCodeAt(0), a2 = '"'.charCodeAt(0), c2 = "\\".charCodeAt(0), l2 = "/".charCodeAt(0), f2 = ".".charCodeAt(0), p2 = ",".charCodeAt(0), h2 = ":".charCodeAt(0), d2 = "*".charCodeAt(0), D2 = "-".charCodeAt(0), g2 = "+".charCodeAt(0), m2 = "#".charCodeAt(0), v2 = "\n".charCodeAt(0), y2 = " ".charCodeAt(0), w2 = "\f".charCodeAt(0), b2 = "	".charCodeAt(0), C2 = "\r".charCodeAt(0), E2 = "@".charCodeAt(0), F2 = "e".charCodeAt(0), x2 = "E".charCodeAt(0), A2 = "0".charCodeAt(0), k2 = "9".charCodeAt(0), O2 = "u".charCodeAt(0), _2 = "U".charCodeAt(0), S2 = /[ \n\t\r\{\(\)'"\\;,/]/g, T2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, I2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, N2 = /^[a-z0-9]/i, M2 = /^[a-f0-9?\-]/i, R2 = r3(8472), j2 = r3(5128);
        e22.exports = function(e23, t5) {
          t5 = t5 || {};
          let r4, L2, B2, P2, $2, U2, G2, W2, z2, V2, q2, X2 = [], J2 = e23.valueOf(), H2 = J2.length, Y2 = -1, K2 = 1, Z2 = 0, Q2 = 0, ee2 = null;
          function te2(e24) {
            let t6 = R2.format("Unclosed %s at line: %d, column: %d, token: %d", e24, K2, Z2 - Y2, Z2);
            throw new j2(t6);
          }
          for (; Z2 < H2; ) {
            switch (r4 = J2.charCodeAt(Z2), r4 === v2 && (Y2 = Z2, K2 += 1), r4) {
              case v2:
              case y2:
              case b2:
              case C2:
              case w2:
                L2 = Z2;
                do {
                  L2 += 1, r4 = J2.charCodeAt(L2), r4 === v2 && (Y2 = L2, K2 += 1);
                } while (r4 === y2 || r4 === v2 || r4 === b2 || r4 === C2 || r4 === w2);
                X2.push(["space", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case h2:
                L2 = Z2 + 1, X2.push(["colon", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case p2:
                L2 = Z2 + 1, X2.push(["comma", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              case n2:
                X2.push(["{", "{", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case o2:
                X2.push(["}", "}", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case i2:
                Q2++, ee2 = !ee2 && Q2 === 1 && X2.length > 0 && X2[X2.length - 1][0] === "word" && X2[X2.length - 1][1] === "url", X2.push(["(", "(", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case s2:
                Q2--, ee2 = ee2 && Q2 > 0, X2.push([")", ")", K2, Z2 - Y2, K2, L2 - Y2, Z2]);
                break;
              case u2:
              case a2:
                B2 = r4 === u2 ? "'" : '"', L2 = Z2;
                do {
                  for (z2 = false, L2 = J2.indexOf(B2, L2 + 1), L2 === -1 && te2("quote"), V2 = L2; J2.charCodeAt(V2 - 1) === c2; )
                    V2 -= 1, z2 = !z2;
                } while (z2);
                X2.push(["string", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case E2:
                S2.lastIndex = Z2 + 1, S2.test(J2), L2 = S2.lastIndex === 0 ? J2.length - 1 : S2.lastIndex - 2, X2.push(["atword", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case c2:
                L2 = Z2, r4 = J2.charCodeAt(L2 + 1), X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                break;
              case g2:
              case D2:
              case d2:
                if (L2 = Z2 + 1, q2 = J2.slice(Z2 + 1, L2 + 1), J2.slice(Z2 - 1, Z2), r4 === D2 && q2.charCodeAt(0) === D2) {
                  L2++, X2.push(["word", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                  break;
                }
                X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                break;
              default:
                if (r4 === l2 && (J2.charCodeAt(Z2 + 1) === d2 || t5.loose && !ee2 && J2.charCodeAt(Z2 + 1) === l2)) {
                  if (J2.charCodeAt(Z2 + 1) === d2)
                    L2 = J2.indexOf("*/", Z2 + 2) + 1, L2 === 0 && te2("comment");
                  else {
                    const e24 = J2.indexOf("\n", Z2 + 2);
                    L2 = e24 !== -1 ? e24 - 1 : H2;
                  }
                  U2 = J2.slice(Z2, L2 + 1), P2 = U2.split("\n"), $2 = P2.length - 1, $2 > 0 ? (G2 = K2 + $2, W2 = L2 - P2[$2].length) : (G2 = K2, W2 = Y2), X2.push(["comment", U2, K2, Z2 - Y2, G2, L2 - W2, Z2]), Y2 = W2, K2 = G2, Z2 = L2;
                } else if (r4 !== m2 || N2.test(J2.slice(Z2 + 1, Z2 + 2)))
                  if (r4 !== O2 && r4 !== _2 || J2.charCodeAt(Z2 + 1) !== g2)
                    if (r4 === l2)
                      L2 = Z2 + 1, X2.push(["operator", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                    else {
                      let e24 = T2;
                      if (r4 >= A2 && r4 <= k2 && (e24 = I2), e24.lastIndex = Z2 + 1, e24.test(J2), L2 = e24.lastIndex === 0 ? J2.length - 1 : e24.lastIndex - 2, e24 === I2 || r4 === f2) {
                        let e25 = J2.charCodeAt(L2), t6 = J2.charCodeAt(L2 + 1), r5 = J2.charCodeAt(L2 + 2);
                        (e25 === F2 || e25 === x2) && (t6 === D2 || t6 === g2) && r5 >= A2 && r5 <= k2 && (I2.lastIndex = L2 + 2, I2.test(J2), L2 = I2.lastIndex === 0 ? J2.length - 1 : I2.lastIndex - 2);
                      }
                      X2.push(["word", J2.slice(Z2, L2 + 1), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2;
                    }
                  else {
                    L2 = Z2 + 2;
                    do {
                      L2 += 1, r4 = J2.charCodeAt(L2);
                    } while (L2 < H2 && M2.test(J2.slice(L2, L2 + 1)));
                    X2.push(["unicoderange", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
                  }
                else
                  L2 = Z2 + 1, X2.push(["#", J2.slice(Z2, L2), K2, Z2 - Y2, K2, L2 - Y2, Z2]), Z2 = L2 - 1;
            }
            Z2++;
          }
          return X2;
        };
      }, 1369: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "unicode-range";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 2057: (e22, t4, r3) => {
        const n2 = r3(4196);
        e22.exports = class extends n2 {
          constructor(e23) {
            super(e23), this.type = "value", this.unbalanced = 0;
          }
        };
      }, 6593: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "word";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      }, 8940: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "atrule", r5;
          }
          r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o3 = n3.prototype;
          return o3.append = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e23.prototype.append).call.apply(t6, [this].concat(n4));
          }, o3.prepend = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e23.prototype.prepend).call.apply(t6, [this].concat(n4));
          }, n3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : {default: n2}).default);
        t4.default = o2, e22.exports = t4.default;
      }, 3102: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "comment", r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : {default: n2}).default);
        t4.default = o2, e22.exports = t4.default;
      }, 1204: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(6417)), o2 = i2(r3(3102));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function s2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return u2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        function a2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        function c2(e23) {
          return e23.map(function(e24) {
            return e24.nodes && (e24.nodes = c2(e24.nodes)), delete e24.source, e24;
          });
        }
        var l2 = function(e23) {
          var t5, i3;
          function u3() {
            return e23.apply(this, arguments) || this;
          }
          i3 = e23, (t5 = u3).prototype = Object.create(i3.prototype), t5.prototype.constructor = t5, t5.__proto__ = i3;
          var l3, f2 = u3.prototype;
          return f2.push = function(e24) {
            return e24.parent = this, this.nodes.push(e24), this;
          }, f2.each = function(e24) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.nodes) {
              for (var r4, n3; this.indexes[t6] < this.nodes.length && (r4 = this.indexes[t6], (n3 = e24(this.nodes[r4], r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3;
            }
          }, f2.walk = function(e24) {
            return this.each(function(t6, r4) {
              var n3;
              try {
                n3 = e24(t6, r4);
              } catch (e25) {
                if (e25.postcssNode = t6, e25.stack && t6.source && /\n\s{4}at /.test(e25.stack)) {
                  var o3 = t6.source;
                  e25.stack = e25.stack.replace(/\n\s{4}at /, "$&" + o3.input.from + ":" + o3.start.line + ":" + o3.start.column + "$&");
                }
                throw e25;
              }
              return n3 !== false && t6.walk && (n3 = t6.walk(e24)), n3;
            });
          }, f2.walkDecls = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "decl" && e24.test(r4.prop))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "decl" && r4.prop === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "decl")
                return t6(e25, r4);
            }));
          }, f2.walkRules = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "rule" && e24.test(r4.selector))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "rule" && r4.selector === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "rule")
                return t6(e25, r4);
            }));
          }, f2.walkAtRules = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "atrule" && e24.test(r4.name))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "atrule" && r4.name === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "atrule")
                return t6(e25, r4);
            }));
          }, f2.walkComments = function(e24) {
            return this.walk(function(t6, r4) {
              if (t6.type === "comment")
                return e24(t6, r4);
            });
          }, f2.append = function() {
            for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
              t6[r4] = arguments[r4];
            for (var n3 = 0, o3 = t6; n3 < o3.length; n3++)
              for (var i4, u4 = o3[n3], a3 = s2(this.normalize(u4, this.last)); !(i4 = a3()).done; ) {
                var c3 = i4.value;
                this.nodes.push(c3);
              }
            return this;
          }, f2.prepend = function() {
            for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
              t6[r4] = arguments[r4];
            for (var n3, o3 = s2(t6 = t6.reverse()); !(n3 = o3()).done; ) {
              for (var i4, u4 = n3.value, a3 = this.normalize(u4, this.first, "prepend").reverse(), c3 = s2(a3); !(i4 = c3()).done; ) {
                var l4 = i4.value;
                this.nodes.unshift(l4);
              }
              for (var f3 in this.indexes)
                this.indexes[f3] = this.indexes[f3] + a3.length;
            }
            return this;
          }, f2.cleanRaws = function(t6) {
            if (e23.prototype.cleanRaws.call(this, t6), this.nodes)
              for (var r4, n3 = s2(this.nodes); !(r4 = n3()).done; )
                r4.value.cleanRaws(t6);
          }, f2.insertBefore = function(e24, t6) {
            for (var r4, n3, o3 = (e24 = this.index(e24)) === 0 && "prepend", i4 = this.normalize(t6, this.nodes[e24], o3).reverse(), u4 = s2(i4); !(r4 = u4()).done; ) {
              var a3 = r4.value;
              this.nodes.splice(e24, 0, a3);
            }
            for (var c3 in this.indexes)
              e24 <= (n3 = this.indexes[c3]) && (this.indexes[c3] = n3 + i4.length);
            return this;
          }, f2.insertAfter = function(e24, t6) {
            e24 = this.index(e24);
            for (var r4, n3, o3 = this.normalize(t6, this.nodes[e24]).reverse(), i4 = s2(o3); !(r4 = i4()).done; ) {
              var u4 = r4.value;
              this.nodes.splice(e24 + 1, 0, u4);
            }
            for (var a3 in this.indexes)
              e24 < (n3 = this.indexes[a3]) && (this.indexes[a3] = n3 + o3.length);
            return this;
          }, f2.removeChild = function(e24) {
            var t6;
            for (var r4 in e24 = this.index(e24), this.nodes[e24].parent = void 0, this.nodes.splice(e24, 1), this.indexes)
              (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
            return this;
          }, f2.removeAll = function() {
            for (var e24, t6 = s2(this.nodes); !(e24 = t6()).done; )
              e24.value.parent = void 0;
            return this.nodes = [], this;
          }, f2.replaceValues = function(e24, t6, r4) {
            return r4 || (r4 = t6, t6 = {}), this.walkDecls(function(n3) {
              t6.props && t6.props.indexOf(n3.prop) === -1 || t6.fast && n3.value.indexOf(t6.fast) === -1 || (n3.value = n3.value.replace(e24, r4));
            }), this;
          }, f2.every = function(e24) {
            return this.nodes.every(e24);
          }, f2.some = function(e24) {
            return this.nodes.some(e24);
          }, f2.index = function(e24) {
            return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
          }, f2.normalize = function(e24, t6) {
            var i4 = this;
            if (typeof e24 == "string")
              e24 = c2(r3(7057)(e24).nodes);
            else if (Array.isArray(e24))
              for (var u4, a3 = s2(e24 = e24.slice(0)); !(u4 = a3()).done; ) {
                var l4 = u4.value;
                l4.parent && l4.parent.removeChild(l4, "ignore");
              }
            else if (e24.type === "root")
              for (var f3, p2 = s2(e24 = e24.nodes.slice(0)); !(f3 = p2()).done; ) {
                var h2 = f3.value;
                h2.parent && h2.parent.removeChild(h2, "ignore");
              }
            else if (e24.type)
              e24 = [e24];
            else if (e24.prop) {
              if (e24.value === void 0)
                throw new Error("Value field is missed in node creation");
              typeof e24.value != "string" && (e24.value = String(e24.value)), e24 = [new n2.default(e24)];
            } else if (e24.selector)
              e24 = [new (r3(6621))(e24)];
            else if (e24.name)
              e24 = [new (r3(8940))(e24)];
            else {
              if (!e24.text)
                throw new Error("Unknown node type in node creation");
              e24 = [new o2.default(e24)];
            }
            return e24.map(function(e25) {
              return e25.parent && e25.parent.removeChild(e25), e25.raws.before === void 0 && t6 && t6.raws.before !== void 0 && (e25.raws.before = t6.raws.before.replace(/[^\s]/g, "")), e25.parent = i4, e25;
            });
          }, (l3 = [{key: "first", get: function() {
            if (this.nodes)
              return this.nodes[0];
          }}, {key: "last", get: function() {
            if (this.nodes)
              return this.nodes[this.nodes.length - 1];
          }}]) && a2(u3.prototype, l3), u3;
        }(i2(r3(1714)).default);
        t4.default = l2, e22.exports = t4.default;
      }, 1667: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(6083)), o2 = s2(r3(3248)), i2 = s2(r3(2868));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function u2(e23) {
          var t5 = typeof Map == "function" ? new Map() : void 0;
          return (u2 = function(e24) {
            if (e24 === null || (r4 = e24, Function.toString.call(r4).indexOf("[native code]") === -1))
              return e24;
            var r4;
            if (typeof e24 != "function")
              throw new TypeError("Super expression must either be null or a function");
            if (t5 !== void 0) {
              if (t5.has(e24))
                return t5.get(e24);
              t5.set(e24, n3);
            }
            function n3() {
              return a2(e24, arguments, f2(this).constructor);
            }
            return n3.prototype = Object.create(e24.prototype, {constructor: {value: n3, enumerable: false, writable: true, configurable: true}}), l2(n3, e24);
          })(e23);
        }
        function a2(e23, t5, r4) {
          return (a2 = c2() ? Reflect.construct : function(e24, t6, r5) {
            var n3 = [null];
            n3.push.apply(n3, t6);
            var o3 = new (Function.bind.apply(e24, n3))();
            return r5 && l2(o3, r5.prototype), o3;
          }).apply(null, arguments);
        }
        function c2() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (e23) {
            return false;
          }
        }
        function l2(e23, t5) {
          return (l2 = Object.setPrototypeOf || function(e24, t6) {
            return e24.__proto__ = t6, e24;
          })(e23, t5);
        }
        function f2(e23) {
          return (f2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e24) {
            return e24.__proto__ || Object.getPrototypeOf(e24);
          })(e23);
        }
        var p2 = function(e23) {
          var t5, r4;
          function s3(t6, r5, n3, o3, i3, u4) {
            var a3;
            return (a3 = e23.call(this, t6) || this).name = "CssSyntaxError", a3.reason = t6, i3 && (a3.file = i3), o3 && (a3.source = o3), u4 && (a3.plugin = u4), r5 !== void 0 && n3 !== void 0 && (a3.line = r5, a3.column = n3), a3.setMessage(), Error.captureStackTrace && Error.captureStackTrace(function(e24) {
              if (e24 === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e24;
            }(a3), s3), a3;
          }
          r4 = e23, (t5 = s3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = s3.prototype;
          return u3.setMessage = function() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
          }, u3.showSourceCode = function(e24) {
            var t6 = this;
            if (!this.source)
              return "";
            var r5 = this.source;
            i2.default && (e24 === void 0 && (e24 = n2.default.stdout), e24 && (r5 = (0, i2.default)(r5)));
            var s4 = r5.split(/\r?\n/), u4 = Math.max(this.line - 3, 0), a3 = Math.min(this.line + 2, s4.length), c3 = String(a3).length;
            function l3(t7) {
              return e24 && o2.default.red ? o2.default.red.bold(t7) : t7;
            }
            function f3(t7) {
              return e24 && o2.default.gray ? o2.default.gray(t7) : t7;
            }
            return s4.slice(u4, a3).map(function(e25, r6) {
              var n3 = u4 + 1 + r6, o3 = " " + (" " + n3).slice(-c3) + " | ";
              if (n3 === t6.line) {
                var i3 = f3(o3.replace(/\d/g, " ")) + e25.slice(0, t6.column - 1).replace(/[^\t]/g, " ");
                return l3(">") + f3(o3) + e25 + "\n " + i3 + l3("^");
              }
              return " " + f3(o3) + e25;
            }).join("\n");
          }, u3.toString = function() {
            var e24 = this.showSourceCode();
            return e24 && (e24 = "\n\n" + e24 + "\n"), this.name + ": " + this.message + e24;
          }, s3;
        }(u2(Error));
        t4.default = p2, e22.exports = t4.default;
      }, 6417: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "decl", r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : {default: n2}).default);
        t4.default = o2, e22.exports = t4.default;
      }, 2993: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(3974)), o2 = s2(r3(1667)), i2 = s2(r3(3353));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function u2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var a2 = 0, c2 = function() {
          function e23(e24, t6) {
            if (t6 === void 0 && (t6 = {}), e24 == null || typeof e24 == "object" && !e24.toString)
              throw new Error("PostCSS received " + e24 + " instead of CSS string");
            this.css = e24.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t6.from && (/^\w+:\/\//.test(t6.from) || n2.default.isAbsolute(t6.from) ? this.file = t6.from : this.file = n2.default.resolve(t6.from));
            var r5 = new i2.default(this.css, t6);
            if (r5.text) {
              this.map = r5;
              var o3 = r5.consumer().file;
              !this.file && o3 && (this.file = this.mapResolve(o3));
            }
            this.file || (a2 += 1, this.id = "<input css " + a2 + ">"), this.map && (this.map.file = this.from);
          }
          var t5, r4 = e23.prototype;
          return r4.error = function(e24, t6, r5, n3) {
            var i3;
            n3 === void 0 && (n3 = {});
            var s3 = this.origin(t6, r5);
            return (i3 = s3 ? new o2.default(e24, s3.line, s3.column, s3.source, s3.file, n3.plugin) : new o2.default(e24, t6, r5, this.css, this.file, n3.plugin)).input = {line: t6, column: r5, source: this.css}, this.file && (i3.input.file = this.file), i3;
          }, r4.origin = function(e24, t6) {
            if (!this.map)
              return false;
            var r5 = this.map.consumer(), n3 = r5.originalPositionFor({line: e24, column: t6});
            if (!n3.source)
              return false;
            var o3 = {file: this.mapResolve(n3.source), line: n3.line, column: n3.column}, i3 = r5.sourceContentFor(n3.source);
            return i3 && (o3.source = i3), o3;
          }, r4.mapResolve = function(e24) {
            return /^\w+:\/\//.test(e24) ? e24 : n2.default.resolve(this.map.consumer().sourceRoot || ".", e24);
          }, (t5 = [{key: "from", get: function() {
            return this.file || this.id;
          }}]) && u2(e23.prototype, t5), e23;
        }();
        t4.default = c2, e22.exports = t4.default;
      }, 6992: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = u2(r3(8991)), o2 = u2(r3(6157)), i2 = (u2(r3(6574)), u2(r3(6865))), s2 = u2(r3(7057));
        function u2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function a2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return c2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? c2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function c2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        function l2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        function f2(e23) {
          return typeof e23 == "object" && typeof e23.then == "function";
        }
        var p2 = function() {
          function e23(t6, r5, n3) {
            var o3;
            if (this.stringified = false, this.processed = false, typeof r5 == "object" && r5 !== null && r5.type === "root")
              o3 = r5;
            else if (r5 instanceof e23 || r5 instanceof i2.default)
              o3 = r5.root, r5.map && (n3.map === void 0 && (n3.map = {}), n3.map.inline || (n3.map.inline = false), n3.map.prev = r5.map);
            else {
              var u3 = s2.default;
              n3.syntax && (u3 = n3.syntax.parse), n3.parser && (u3 = n3.parser), u3.parse && (u3 = u3.parse);
              try {
                o3 = u3(r5, n3);
              } catch (t7) {
                this.error = t7;
              }
            }
            this.result = new i2.default(t6, o3, n3);
          }
          var t5, r4 = e23.prototype;
          return r4.warnings = function() {
            return this.sync().warnings();
          }, r4.toString = function() {
            return this.css;
          }, r4.then = function(e24, t6) {
            return this.async().then(e24, t6);
          }, r4.catch = function(e24) {
            return this.async().catch(e24);
          }, r4.finally = function(e24) {
            return this.async().then(e24, e24);
          }, r4.handleError = function(e24, t6) {
            try {
              this.error = e24, e24.name !== "CssSyntaxError" || e24.plugin ? t6.postcssVersion : (e24.plugin = t6.postcssPlugin, e24.setMessage());
            } catch (e25) {
              console && console.error && console.error(e25);
            }
          }, r4.asyncTick = function(e24, t6) {
            var r5 = this;
            if (this.plugin >= this.processor.plugins.length)
              return this.processed = true, e24();
            try {
              var n3 = this.processor.plugins[this.plugin], o3 = this.run(n3);
              this.plugin += 1, f2(o3) ? o3.then(function() {
                r5.asyncTick(e24, t6);
              }).catch(function(e25) {
                r5.handleError(e25, n3), r5.processed = true, t6(e25);
              }) : this.asyncTick(e24, t6);
            } catch (e25) {
              this.processed = true, t6(e25);
            }
          }, r4.async = function() {
            var e24 = this;
            return this.processed ? new Promise(function(t6, r5) {
              e24.error ? r5(e24.error) : t6(e24.stringify());
            }) : (this.processing || (this.processing = new Promise(function(t6, r5) {
              if (e24.error)
                return r5(e24.error);
              e24.plugin = 0, e24.asyncTick(t6, r5);
            }).then(function() {
              return e24.processed = true, e24.stringify();
            })), this.processing);
          }, r4.sync = function() {
            if (this.processed)
              return this.result;
            if (this.processed = true, this.processing)
              throw new Error("Use process(css).then(cb) to work with async plugins");
            if (this.error)
              throw this.error;
            for (var e24, t6 = a2(this.result.processor.plugins); !(e24 = t6()).done; ) {
              var r5 = e24.value;
              if (f2(this.run(r5)))
                throw new Error("Use process(css).then(cb) to work with async plugins");
            }
            return this.result;
          }, r4.run = function(e24) {
            this.result.lastPlugin = e24;
            try {
              return e24(this.result.root, this.result);
            } catch (t6) {
              throw this.handleError(t6, e24), t6;
            }
          }, r4.stringify = function() {
            if (this.stringified)
              return this.result;
            this.stringified = true, this.sync();
            var e24 = this.result.opts, t6 = o2.default;
            e24.syntax && (t6 = e24.syntax.stringify), e24.stringifier && (t6 = e24.stringifier), t6.stringify && (t6 = t6.stringify);
            var r5 = new n2.default(t6, this.result.root, this.result.opts).generate();
            return this.result.css = r5[0], this.result.map = r5[1], this.result;
          }, (t5 = [{key: "processor", get: function() {
            return this.result.processor;
          }}, {key: "opts", get: function() {
            return this.result.opts;
          }}, {key: "css", get: function() {
            return this.stringify().css;
          }}, {key: "content", get: function() {
            return this.stringify().content;
          }}, {key: "map", get: function() {
            return this.stringify().map;
          }}, {key: "root", get: function() {
            return this.sync().root;
          }}, {key: "messages", get: function() {
            return this.sync().messages;
          }}]) && l2(e23.prototype, t5), e23;
        }();
        t4.default = p2, e22.exports = t4.default;
      }, 6136: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = {split: function(e23, t5, r4) {
          for (var n3 = [], o2 = "", i2 = false, s2 = 0, u2 = false, a2 = false, c2 = 0; c2 < e23.length; c2++) {
            var l2 = e23[c2];
            u2 ? a2 ? a2 = false : l2 === "\\" ? a2 = true : l2 === u2 && (u2 = false) : l2 === '"' || l2 === "'" ? u2 = l2 : l2 === "(" ? s2 += 1 : l2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && t5.indexOf(l2) !== -1 && (i2 = true), i2 ? (o2 !== "" && n3.push(o2.trim()), o2 = "", i2 = false) : o2 += l2;
          }
          return (r4 || o2 !== "") && n3.push(o2.trim()), n3;
        }, space: function(e23) {
          return r3.split(e23, [" ", "\n", "	"]);
        }, comma: function(e23) {
          return r3.split(e23, [","], true);
        }}, n2 = r3;
        t4.default = n2, e22.exports = t4.default;
      }, 8991: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(2447)), o2 = i2(r3(3974));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function s2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return u2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        var a2 = function() {
          function e23(e24, t6, r4) {
            this.stringify = e24, this.mapOpts = r4.map || {}, this.root = t6, this.opts = r4;
          }
          var t5 = e23.prototype;
          return t5.isMap = function() {
            return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
          }, t5.previous = function() {
            var e24 = this;
            return this.previousMaps || (this.previousMaps = [], this.root.walk(function(t6) {
              if (t6.source && t6.source.input.map) {
                var r4 = t6.source.input.map;
                e24.previousMaps.indexOf(r4) === -1 && e24.previousMaps.push(r4);
              }
            })), this.previousMaps;
          }, t5.isInline = function() {
            if (this.mapOpts.inline !== void 0)
              return this.mapOpts.inline;
            var e24 = this.mapOpts.annotation;
            return (e24 === void 0 || e24 === true) && (!this.previous().length || this.previous().some(function(e25) {
              return e25.inline;
            }));
          }, t5.isSourcesContent = function() {
            return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some(function(e24) {
              return e24.withContent();
            });
          }, t5.clearAnnotation = function() {
            if (this.mapOpts.annotation !== false)
              for (var e24, t6 = this.root.nodes.length - 1; t6 >= 0; t6--)
                (e24 = this.root.nodes[t6]).type === "comment" && e24.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t6);
          }, t5.setSourcesContent = function() {
            var e24 = this, t6 = {};
            this.root.walk(function(r4) {
              if (r4.source) {
                var n3 = r4.source.input.from;
                if (n3 && !t6[n3]) {
                  t6[n3] = true;
                  var o3 = e24.relative(n3);
                  e24.map.setSourceContent(o3, r4.source.input.css);
                }
              }
            });
          }, t5.applyPrevMaps = function() {
            for (var e24, t6 = s2(this.previous()); !(e24 = t6()).done; ) {
              var r4 = e24.value, i3 = this.relative(r4.file), u3 = r4.root || o2.default.dirname(r4.file), a3 = void 0;
              this.mapOpts.sourcesContent === false ? (a3 = new n2.default.SourceMapConsumer(r4.text)).sourcesContent && (a3.sourcesContent = a3.sourcesContent.map(function() {
                return null;
              })) : a3 = r4.consumer(), this.map.applySourceMap(a3, i3, this.relative(u3));
            }
          }, t5.isAnnotation = function() {
            return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some(function(e24) {
              return e24.annotation;
            }));
          }, t5.toBase64 = function(e24) {
            return Buffer ? Buffer.from(e24).toString("base64") : window.btoa(unescape(encodeURIComponent(e24)));
          }, t5.addAnnotation = function() {
            var e24;
            e24 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : this.outputFile() + ".map";
            var t6 = "\n";
            this.css.indexOf("\r\n") !== -1 && (t6 = "\r\n"), this.css += t6 + "/*# sourceMappingURL=" + e24 + " */";
          }, t5.outputFile = function() {
            return this.opts.to ? this.relative(this.opts.to) : this.opts.from ? this.relative(this.opts.from) : "to.css";
          }, t5.generateMap = function() {
            return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
          }, t5.relative = function(e24) {
            if (e24.indexOf("<") === 0)
              return e24;
            if (/^\w+:\/\//.test(e24))
              return e24;
            var t6 = this.opts.to ? o2.default.dirname(this.opts.to) : ".";
            return typeof this.mapOpts.annotation == "string" && (t6 = o2.default.dirname(o2.default.resolve(t6, this.mapOpts.annotation))), e24 = o2.default.relative(t6, e24), o2.default.sep === "\\" ? e24.replace(/\\/g, "/") : e24;
          }, t5.sourcePath = function(e24) {
            return this.mapOpts.from ? this.mapOpts.from : this.relative(e24.source.input.from);
          }, t5.generateString = function() {
            var e24 = this;
            this.css = "", this.map = new n2.default.SourceMapGenerator({file: this.outputFile()});
            var t6, r4, o3 = 1, i3 = 1;
            this.stringify(this.root, function(n3, s3, u3) {
              if (e24.css += n3, s3 && u3 !== "end" && (s3.source && s3.source.start ? e24.map.addMapping({source: e24.sourcePath(s3), generated: {line: o3, column: i3 - 1}, original: {line: s3.source.start.line, column: s3.source.start.column - 1}}) : e24.map.addMapping({source: "<no source>", original: {line: 1, column: 0}, generated: {line: o3, column: i3 - 1}})), (t6 = n3.match(/\n/g)) ? (o3 += t6.length, r4 = n3.lastIndexOf("\n"), i3 = n3.length - r4) : i3 += n3.length, s3 && u3 !== "start") {
                var a3 = s3.parent || {raws: {}};
                (s3.type !== "decl" || s3 !== a3.last || a3.raws.semicolon) && (s3.source && s3.source.end ? e24.map.addMapping({source: e24.sourcePath(s3), generated: {line: o3, column: i3 - 2}, original: {line: s3.source.end.line, column: s3.source.end.column - 1}}) : e24.map.addMapping({source: "<no source>", original: {line: 1, column: 0}, generated: {line: o3, column: i3 - 1}}));
              }
            });
          }, t5.generate = function() {
            if (this.clearAnnotation(), this.isMap())
              return this.generateMap();
            var e24 = "";
            return this.stringify(this.root, function(t6) {
              e24 += t6;
            }), [e24];
          }, e23;
        }();
        t4.default = a2, e22.exports = t4.default;
      }, 1714: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(1667)), o2 = s2(r3(5701)), i2 = s2(r3(6157));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function u2(e23, t5) {
          var r4 = new e23.constructor();
          for (var n3 in e23)
            if (e23.hasOwnProperty(n3)) {
              var o3 = e23[n3], i3 = typeof o3;
              n3 === "parent" && i3 === "object" ? t5 && (r4[n3] = t5) : n3 === "source" ? r4[n3] = o3 : o3 instanceof Array ? r4[n3] = o3.map(function(e24) {
                return u2(e24, r4);
              }) : (i3 === "object" && o3 !== null && (o3 = u2(o3)), r4[n3] = o3);
            }
          return r4;
        }
        var a2 = function() {
          function e23(e24) {
            for (var t6 in e24 === void 0 && (e24 = {}), this.raws = {}, e24)
              this[t6] = e24[t6];
          }
          var t5 = e23.prototype;
          return t5.error = function(e24, t6) {
            if (t6 === void 0 && (t6 = {}), this.source) {
              var r4 = this.positionBy(t6);
              return this.source.input.error(e24, r4.line, r4.column, t6);
            }
            return new n2.default(e24);
          }, t5.warn = function(e24, t6, r4) {
            var n3 = {node: this};
            for (var o3 in r4)
              n3[o3] = r4[o3];
            return e24.warn(t6, n3);
          }, t5.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, t5.toString = function(e24) {
            e24 === void 0 && (e24 = i2.default), e24.stringify && (e24 = e24.stringify);
            var t6 = "";
            return e24(this, function(e25) {
              t6 += e25;
            }), t6;
          }, t5.clone = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = u2(this);
            for (var r4 in e24)
              t6[r4] = e24[r4];
            return t6;
          }, t5.cloneBefore = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = this.clone(e24);
            return this.parent.insertBefore(this, t6), t6;
          }, t5.cloneAfter = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = this.clone(e24);
            return this.parent.insertAfter(this, t6), t6;
          }, t5.replaceWith = function() {
            if (this.parent) {
              for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
                t6[r4] = arguments[r4];
              for (var n3 = 0, o3 = t6; n3 < o3.length; n3++) {
                var i3 = o3[n3];
                this.parent.insertBefore(this, i3);
              }
              this.remove();
            }
            return this;
          }, t5.next = function() {
            if (this.parent) {
              var e24 = this.parent.index(this);
              return this.parent.nodes[e24 + 1];
            }
          }, t5.prev = function() {
            if (this.parent) {
              var e24 = this.parent.index(this);
              return this.parent.nodes[e24 - 1];
            }
          }, t5.before = function(e24) {
            return this.parent.insertBefore(this, e24), this;
          }, t5.after = function(e24) {
            return this.parent.insertAfter(this, e24), this;
          }, t5.toJSON = function() {
            var e24 = {};
            for (var t6 in this)
              if (this.hasOwnProperty(t6) && t6 !== "parent") {
                var r4 = this[t6];
                r4 instanceof Array ? e24[t6] = r4.map(function(e25) {
                  return typeof e25 == "object" && e25.toJSON ? e25.toJSON() : e25;
                }) : typeof r4 == "object" && r4.toJSON ? e24[t6] = r4.toJSON() : e24[t6] = r4;
              }
            return e24;
          }, t5.raw = function(e24, t6) {
            return new o2.default().raw(this, e24, t6);
          }, t5.root = function() {
            for (var e24 = this; e24.parent; )
              e24 = e24.parent;
            return e24;
          }, t5.cleanRaws = function(e24) {
            delete this.raws.before, delete this.raws.after, e24 || delete this.raws.between;
          }, t5.positionInside = function(e24) {
            for (var t6 = this.toString(), r4 = this.source.start.column, n3 = this.source.start.line, o3 = 0; o3 < e24; o3++)
              t6[o3] === "\n" ? (r4 = 1, n3 += 1) : r4 += 1;
            return {line: n3, column: r4};
          }, t5.positionBy = function(e24) {
            var t6 = this.source.start;
            if (e24.index)
              t6 = this.positionInside(e24.index);
            else if (e24.word) {
              var r4 = this.toString().indexOf(e24.word);
              r4 !== -1 && (t6 = this.positionInside(r4));
            }
            return t6;
          }, e23;
        }();
        t4.default = a2, e22.exports = t4.default;
      }, 7057: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(7116)), o2 = i2(r3(2993));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        var s2 = function(e23, t5) {
          var r4 = new o2.default(e23, t5), i3 = new n2.default(r4);
          try {
            i3.parse();
          } catch (e24) {
            throw e24;
          }
          return i3.root;
        };
        t4.default = s2, e22.exports = t4.default;
      }, 7116: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = c2(r3(6417)), o2 = c2(r3(1157)), i2 = c2(r3(3102)), s2 = c2(r3(8940)), u2 = c2(r3(7563)), a2 = c2(r3(6621));
        function c2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        var l2 = function() {
          function e23(e24) {
            this.input = e24, this.root = new u2.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = {input: e24, start: {line: 1, column: 1}};
          }
          var t5 = e23.prototype;
          return t5.createTokenizer = function() {
            this.tokenizer = (0, o2.default)(this.input);
          }, t5.parse = function() {
            for (var e24; !this.tokenizer.endOfFile(); )
              switch ((e24 = this.tokenizer.nextToken())[0]) {
                case "space":
                  this.spaces += e24[1];
                  break;
                case ";":
                  this.freeSemicolon(e24);
                  break;
                case "}":
                  this.end(e24);
                  break;
                case "comment":
                  this.comment(e24);
                  break;
                case "at-word":
                  this.atrule(e24);
                  break;
                case "{":
                  this.emptyRule(e24);
                  break;
                default:
                  this.other(e24);
              }
            this.endFile();
          }, t5.comment = function(e24) {
            var t6 = new i2.default();
            this.init(t6, e24[2], e24[3]), t6.source.end = {line: e24[4], column: e24[5]};
            var r4 = e24[1].slice(2, -2);
            if (/^\s*$/.test(r4))
              t6.text = "", t6.raws.left = r4, t6.raws.right = "";
            else {
              var n3 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              t6.text = n3[2], t6.raws.left = n3[1], t6.raws.right = n3[3];
            }
          }, t5.emptyRule = function(e24) {
            var t6 = new a2.default();
            this.init(t6, e24[2], e24[3]), t6.selector = "", t6.raws.between = "", this.current = t6;
          }, t5.other = function(e24) {
            for (var t6 = false, r4 = null, n3 = false, o3 = null, i3 = [], s3 = [], u3 = e24; u3; ) {
              if (r4 = u3[0], s3.push(u3), r4 === "(" || r4 === "[")
                o3 || (o3 = u3), i3.push(r4 === "(" ? ")" : "]");
              else if (i3.length === 0) {
                if (r4 === ";") {
                  if (n3)
                    return void this.decl(s3);
                  break;
                }
                if (r4 === "{")
                  return void this.rule(s3);
                if (r4 === "}") {
                  this.tokenizer.back(s3.pop()), t6 = true;
                  break;
                }
                r4 === ":" && (n3 = true);
              } else
                r4 === i3[i3.length - 1] && (i3.pop(), i3.length === 0 && (o3 = null));
              u3 = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile() && (t6 = true), i3.length > 0 && this.unclosedBracket(o3), t6 && n3) {
              for (; s3.length && ((u3 = s3[s3.length - 1][0]) === "space" || u3 === "comment"); )
                this.tokenizer.back(s3.pop());
              this.decl(s3);
            } else
              this.unknownWord(s3);
          }, t5.rule = function(e24) {
            e24.pop();
            var t6 = new a2.default();
            this.init(t6, e24[0][2], e24[0][3]), t6.raws.between = this.spacesAndCommentsFromEnd(e24), this.raw(t6, "selector", e24), this.current = t6;
          }, t5.decl = function(e24) {
            var t6 = new n2.default();
            this.init(t6);
            var r4, o3 = e24[e24.length - 1];
            for (o3[0] === ";" && (this.semicolon = true, e24.pop()), o3[4] ? t6.source.end = {line: o3[4], column: o3[5]} : t6.source.end = {line: o3[2], column: o3[3]}; e24[0][0] !== "word"; )
              e24.length === 1 && this.unknownWord(e24), t6.raws.before += e24.shift()[1];
            for (t6.source.start = {line: e24[0][2], column: e24[0][3]}, t6.prop = ""; e24.length; ) {
              var i3 = e24[0][0];
              if (i3 === ":" || i3 === "space" || i3 === "comment")
                break;
              t6.prop += e24.shift()[1];
            }
            for (t6.raws.between = ""; e24.length; ) {
              if ((r4 = e24.shift())[0] === ":") {
                t6.raws.between += r4[1];
                break;
              }
              r4[0] === "word" && /\w/.test(r4[1]) && this.unknownWord([r4]), t6.raws.between += r4[1];
            }
            t6.prop[0] !== "_" && t6.prop[0] !== "*" || (t6.raws.before += t6.prop[0], t6.prop = t6.prop.slice(1)), t6.raws.between += this.spacesAndCommentsFromStart(e24), this.precheckMissedSemicolon(e24);
            for (var s3 = e24.length - 1; s3 > 0; s3--) {
              if ((r4 = e24[s3])[1].toLowerCase() === "!important") {
                t6.important = true;
                var u3 = this.stringFrom(e24, s3);
                (u3 = this.spacesFromEnd(e24) + u3) !== " !important" && (t6.raws.important = u3);
                break;
              }
              if (r4[1].toLowerCase() === "important") {
                for (var a3 = e24.slice(0), c3 = "", l3 = s3; l3 > 0; l3--) {
                  var f2 = a3[l3][0];
                  if (c3.trim().indexOf("!") === 0 && f2 !== "space")
                    break;
                  c3 = a3.pop()[1] + c3;
                }
                c3.trim().indexOf("!") === 0 && (t6.important = true, t6.raws.important = c3, e24 = a3);
              }
              if (r4[0] !== "space" && r4[0] !== "comment")
                break;
            }
            this.raw(t6, "value", e24), t6.value.indexOf(":") !== -1 && this.checkMissedSemicolon(e24);
          }, t5.atrule = function(e24) {
            var t6, r4, n3 = new s2.default();
            n3.name = e24[1].slice(1), n3.name === "" && this.unnamedAtrule(n3, e24), this.init(n3, e24[2], e24[3]);
            for (var o3 = false, i3 = false, u3 = []; !this.tokenizer.endOfFile(); ) {
              if ((e24 = this.tokenizer.nextToken())[0] === ";") {
                n3.source.end = {line: e24[2], column: e24[3]}, this.semicolon = true;
                break;
              }
              if (e24[0] === "{") {
                i3 = true;
                break;
              }
              if (e24[0] === "}") {
                if (u3.length > 0) {
                  for (t6 = u3[r4 = u3.length - 1]; t6 && t6[0] === "space"; )
                    t6 = u3[--r4];
                  t6 && (n3.source.end = {line: t6[4], column: t6[5]});
                }
                this.end(e24);
                break;
              }
              if (u3.push(e24), this.tokenizer.endOfFile()) {
                o3 = true;
                break;
              }
            }
            n3.raws.between = this.spacesAndCommentsFromEnd(u3), u3.length ? (n3.raws.afterName = this.spacesAndCommentsFromStart(u3), this.raw(n3, "params", u3), o3 && (e24 = u3[u3.length - 1], n3.source.end = {line: e24[4], column: e24[5]}, this.spaces = n3.raws.between, n3.raws.between = "")) : (n3.raws.afterName = "", n3.params = ""), i3 && (n3.nodes = [], this.current = n3);
          }, t5.end = function(e24) {
            this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = {line: e24[2], column: e24[3]}, this.current = this.current.parent) : this.unexpectedClose(e24);
          }, t5.endFile = function() {
            this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          }, t5.freeSemicolon = function(e24) {
            if (this.spaces += e24[1], this.current.nodes) {
              var t6 = this.current.nodes[this.current.nodes.length - 1];
              t6 && t6.type === "rule" && !t6.raws.ownSemicolon && (t6.raws.ownSemicolon = this.spaces, this.spaces = "");
            }
          }, t5.init = function(e24, t6, r4) {
            this.current.push(e24), e24.source = {start: {line: t6, column: r4}, input: this.input}, e24.raws.before = this.spaces, this.spaces = "", e24.type !== "comment" && (this.semicolon = false);
          }, t5.raw = function(e24, t6, r4) {
            for (var n3, o3, i3, s3, u3 = r4.length, a3 = "", c3 = true, l3 = /^([.|#])?([\w])+/i, f2 = 0; f2 < u3; f2 += 1)
              (o3 = (n3 = r4[f2])[0]) !== "comment" || e24.type !== "rule" ? o3 === "comment" || o3 === "space" && f2 === u3 - 1 ? c3 = false : a3 += n3[1] : (s3 = r4[f2 - 1], i3 = r4[f2 + 1], s3[0] !== "space" && i3[0] !== "space" && l3.test(s3[1]) && l3.test(i3[1]) ? a3 += n3[1] : c3 = false);
            if (!c3) {
              var p2 = r4.reduce(function(e25, t7) {
                return e25 + t7[1];
              }, "");
              e24.raws[t6] = {value: a3, raw: p2};
            }
            e24[t6] = a3;
          }, t5.spacesAndCommentsFromEnd = function(e24) {
            for (var t6, r4 = ""; e24.length && ((t6 = e24[e24.length - 1][0]) === "space" || t6 === "comment"); )
              r4 = e24.pop()[1] + r4;
            return r4;
          }, t5.spacesAndCommentsFromStart = function(e24) {
            for (var t6, r4 = ""; e24.length && ((t6 = e24[0][0]) === "space" || t6 === "comment"); )
              r4 += e24.shift()[1];
            return r4;
          }, t5.spacesFromEnd = function(e24) {
            for (var t6 = ""; e24.length && e24[e24.length - 1][0] === "space"; )
              t6 = e24.pop()[1] + t6;
            return t6;
          }, t5.stringFrom = function(e24, t6) {
            for (var r4 = "", n3 = t6; n3 < e24.length; n3++)
              r4 += e24[n3][1];
            return e24.splice(t6, e24.length - t6), r4;
          }, t5.colon = function(e24) {
            for (var t6, r4, n3, o3 = 0, i3 = 0; i3 < e24.length; i3++) {
              if ((r4 = (t6 = e24[i3])[0]) === "(" && (o3 += 1), r4 === ")" && (o3 -= 1), o3 === 0 && r4 === ":") {
                if (n3) {
                  if (n3[0] === "word" && n3[1] === "progid")
                    continue;
                  return i3;
                }
                this.doubleColon(t6);
              }
              n3 = t6;
            }
            return false;
          }, t5.unclosedBracket = function(e24) {
            throw this.input.error("Unclosed bracket", e24[2], e24[3]);
          }, t5.unknownWord = function(e24) {
            throw this.input.error("Unknown word", e24[0][2], e24[0][3]);
          }, t5.unexpectedClose = function(e24) {
            throw this.input.error("Unexpected }", e24[2], e24[3]);
          }, t5.unclosedBlock = function() {
            var e24 = this.current.source.start;
            throw this.input.error("Unclosed block", e24.line, e24.column);
          }, t5.doubleColon = function(e24) {
            throw this.input.error("Double colon", e24[2], e24[3]);
          }, t5.unnamedAtrule = function(e24, t6) {
            throw this.input.error("At-rule without name", t6[2], t6[3]);
          }, t5.precheckMissedSemicolon = function() {
          }, t5.checkMissedSemicolon = function(e24) {
            var t6 = this.colon(e24);
            if (t6 !== false) {
              for (var r4, n3 = 0, o3 = t6 - 1; o3 >= 0 && ((r4 = e24[o3])[0] === "space" || (n3 += 1) !== 2); o3--)
                ;
              throw this.input.error("Missed semicolon", r4[2], r4[3]);
            }
          }, e23;
        }();
        t4.default = l2, e22.exports = t4.default;
      }, 3353: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(2447)), o2 = s2(r3(3974)), i2 = s2(r3(4940));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        var u2 = function() {
          function e23(e24, t6) {
            this.loadAnnotation(e24), this.inline = this.startWith(this.annotation, "data:");
            var r4 = t6.map ? t6.map.prev : void 0, n3 = this.loadMap(t6.from, r4);
            n3 && (this.text = n3);
          }
          var t5 = e23.prototype;
          return t5.consumer = function() {
            return this.consumerCache || (this.consumerCache = new n2.default.SourceMapConsumer(this.text)), this.consumerCache;
          }, t5.withContent = function() {
            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
          }, t5.startWith = function(e24, t6) {
            return !!e24 && e24.substr(0, t6.length) === t6;
          }, t5.getAnnotationURL = function(e24) {
            return e24.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
          }, t5.loadAnnotation = function(e24) {
            var t6 = e24.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
            if (t6 && t6.length > 0) {
              var r4 = t6[t6.length - 1];
              r4 && (this.annotation = this.getAnnotationURL(r4));
            }
          }, t5.decodeInline = function(e24) {
            var t6, r4 = "data:application/json,";
            if (this.startWith(e24, r4))
              return decodeURIComponent(e24.substr(r4.length));
            if (/^data:application\/json;charset=utf-?8;base64,/.test(e24) || /^data:application\/json;base64,/.test(e24))
              return t6 = e24.substr(RegExp.lastMatch.length), Buffer ? Buffer.from(t6, "base64").toString() : window.atob(t6);
            var n3 = e24.match(/data:application\/json;([^,]+),/)[1];
            throw new Error("Unsupported source map encoding " + n3);
          }, t5.loadMap = function(e24, t6) {
            if (t6 === false)
              return false;
            if (t6) {
              if (typeof t6 == "string")
                return t6;
              if (typeof t6 == "function") {
                var r4 = t6(e24);
                if (r4 && i2.default.existsSync && i2.default.existsSync(r4))
                  return i2.default.readFileSync(r4, "utf-8").toString().trim();
                throw new Error("Unable to load previous source map: " + r4.toString());
              }
              if (t6 instanceof n2.default.SourceMapConsumer)
                return n2.default.SourceMapGenerator.fromSourceMap(t6).toString();
              if (t6 instanceof n2.default.SourceMapGenerator)
                return t6.toString();
              if (this.isMap(t6))
                return JSON.stringify(t6);
              throw new Error("Unsupported previous source map format: " + t6.toString());
            }
            if (this.inline)
              return this.decodeInline(this.annotation);
            if (this.annotation) {
              var s3 = this.annotation;
              return e24 && (s3 = o2.default.join(o2.default.dirname(e24), s3)), this.root = o2.default.dirname(s3), !(!i2.default.existsSync || !i2.default.existsSync(s3)) && i2.default.readFileSync(s3, "utf-8").toString().trim();
            }
          }, t5.isMap = function(e24) {
            return typeof e24 == "object" && (typeof e24.mappings == "string" || typeof e24._mappings == "string");
          }, e23;
        }();
        t4.default = u2, e22.exports = t4.default;
      }, 9429: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(6992)) && n2.__esModule ? n2 : {default: n2};
        function i2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return s2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? s2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function s2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        var u2 = function() {
          function e23(e24) {
            e24 === void 0 && (e24 = []), this.version = "7.0.36", this.plugins = this.normalize(e24);
          }
          var t5 = e23.prototype;
          return t5.use = function(e24) {
            return this.plugins = this.plugins.concat(this.normalize([e24])), this;
          }, t5.process = function(e24) {
            function t6(t7) {
              return e24.apply(this, arguments);
            }
            return t6.toString = function() {
              return e24.toString();
            }, t6;
          }(function(e24, t6) {
            return t6 === void 0 && (t6 = {}), this.plugins.length === 0 && (t6.parser, t6.stringifier), new o2.default(this, e24, t6);
          }), t5.normalize = function(e24) {
            for (var t6, r4 = [], n3 = i2(e24); !(t6 = n3()).done; ) {
              var o3 = t6.value;
              if (o3.postcss === true) {
                var s3 = o3();
                throw new Error("PostCSS plugin " + s3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
              }
              if (o3.postcss && (o3 = o3.postcss), typeof o3 == "object" && Array.isArray(o3.plugins))
                r4 = r4.concat(o3.plugins);
              else if (typeof o3 == "function")
                r4.push(o3);
              else if (typeof o3 != "object" || !o3.parse && !o3.stringify)
                throw typeof o3 == "object" && o3.postcssPlugin ? new Error("PostCSS plugin " + o3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users") : new Error(o3 + " is not a PostCSS plugin");
            }
            return r4;
          }, e23;
        }();
        t4.default = u2, e22.exports = t4.default;
      }, 6865: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(1662)) && n2.__esModule ? n2 : {default: n2};
        function i2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var s2 = function() {
          function e23(e24, t6, r5) {
            this.processor = e24, this.messages = [], this.root = t6, this.opts = r5, this.css = void 0, this.map = void 0;
          }
          var t5, r4 = e23.prototype;
          return r4.toString = function() {
            return this.css;
          }, r4.warn = function(e24, t6) {
            t6 === void 0 && (t6 = {}), t6.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t6.plugin = this.lastPlugin.postcssPlugin);
            var r5 = new o2.default(e24, t6);
            return this.messages.push(r5), r5;
          }, r4.warnings = function() {
            return this.messages.filter(function(e24) {
              return e24.type === "warning";
            });
          }, (t5 = [{key: "content", get: function() {
            return this.css;
          }}]) && i2(e23.prototype, t5), e23;
        }();
        t4.default = s2, e22.exports = t4.default;
      }, 7563: (e22, t4, r3) => {
        var n2;
        function o2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return i2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? i2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? {done: true} : {done: false, value: e23[n3++]};
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function i2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        t4.__esModule = true, t4.default = void 0;
        var s2 = function(e23) {
          var t5, n3;
          function i3(t6) {
            var r4;
            return (r4 = e23.call(this, t6) || this).type = "root", r4.nodes || (r4.nodes = []), r4;
          }
          n3 = e23, (t5 = i3).prototype = Object.create(n3.prototype), t5.prototype.constructor = t5, t5.__proto__ = n3;
          var s3 = i3.prototype;
          return s3.removeChild = function(t6, r4) {
            var n4 = this.index(t6);
            return !r4 && n4 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n4].raws.before), e23.prototype.removeChild.call(this, t6);
          }, s3.normalize = function(t6, r4, n4) {
            var i4 = e23.prototype.normalize.call(this, t6);
            if (r4) {
              if (n4 === "prepend")
                this.nodes.length > 1 ? r4.raws.before = this.nodes[1].raws.before : delete r4.raws.before;
              else if (this.first !== r4)
                for (var s4, u2 = o2(i4); !(s4 = u2()).done; )
                  s4.value.raws.before = r4.raws.before;
            }
            return i4;
          }, s3.toResult = function(e24) {
            return e24 === void 0 && (e24 = {}), new (r3(6992))(new (r3(9429))(), this, e24).stringify();
          }, i3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : {default: n2}).default);
        t4.default = s2, e22.exports = t4.default;
      }, 6621: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(1204)), o2 = i2(r3(6136));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : {default: e23};
        }
        function s2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var u2 = function(e23) {
          var t5, r4, n3;
          function i3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "rule", r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e23, (t5 = i3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, (n3 = [{key: "selectors", get: function() {
            return o2.default.comma(this.selector);
          }, set: function(e24) {
            var t6 = this.selector ? this.selector.match(/,\s*/) : null, r5 = t6 ? t6[0] : "," + this.raw("between", "beforeOpen");
            this.selector = e24.join(r5);
          }}]) && s2(i3.prototype, n3), i3;
        }(n2.default);
        t4.default = u2, e22.exports = t4.default;
      }, 5701: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = {colon: ": ", indent: "    ", beforeDecl: "\n", beforeRule: "\n", beforeOpen: " ", beforeClose: "\n", beforeComment: "\n", after: "\n", emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false}, n2 = function() {
          function e23(e24) {
            this.builder = e24;
          }
          var t5 = e23.prototype;
          return t5.stringify = function(e24, t6) {
            this[e24.type](e24, t6);
          }, t5.root = function(e24) {
            this.body(e24), e24.raws.after && this.builder(e24.raws.after);
          }, t5.comment = function(e24) {
            var t6 = this.raw(e24, "left", "commentLeft"), r4 = this.raw(e24, "right", "commentRight");
            this.builder("/*" + t6 + e24.text + r4 + "*/", e24);
          }, t5.decl = function(e24, t6) {
            var r4 = this.raw(e24, "between", "colon"), n3 = e24.prop + r4 + this.rawValue(e24, "value");
            e24.important && (n3 += e24.raws.important || " !important"), t6 && (n3 += ";"), this.builder(n3, e24);
          }, t5.rule = function(e24) {
            this.block(e24, this.rawValue(e24, "selector")), e24.raws.ownSemicolon && this.builder(e24.raws.ownSemicolon, e24, "end");
          }, t5.atrule = function(e24, t6) {
            var r4 = "@" + e24.name, n3 = e24.params ? this.rawValue(e24, "params") : "";
            if (e24.raws.afterName !== void 0 ? r4 += e24.raws.afterName : n3 && (r4 += " "), e24.nodes)
              this.block(e24, r4 + n3);
            else {
              var o2 = (e24.raws.between || "") + (t6 ? ";" : "");
              this.builder(r4 + n3 + o2, e24);
            }
          }, t5.body = function(e24) {
            for (var t6 = e24.nodes.length - 1; t6 > 0 && e24.nodes[t6].type === "comment"; )
              t6 -= 1;
            for (var r4 = this.raw(e24, "semicolon"), n3 = 0; n3 < e24.nodes.length; n3++) {
              var o2 = e24.nodes[n3], i2 = this.raw(o2, "before");
              i2 && this.builder(i2), this.stringify(o2, t6 !== n3 || r4);
            }
          }, t5.block = function(e24, t6) {
            var r4, n3 = this.raw(e24, "between", "beforeOpen");
            this.builder(t6 + n3 + "{", e24, "start"), e24.nodes && e24.nodes.length ? (this.body(e24), r4 = this.raw(e24, "after")) : r4 = this.raw(e24, "after", "emptyBody"), r4 && this.builder(r4), this.builder("}", e24, "end");
          }, t5.raw = function(e24, t6, n3) {
            var o2;
            if (n3 || (n3 = t6), t6 && (o2 = e24.raws[t6]) !== void 0)
              return o2;
            var i2 = e24.parent;
            if (n3 === "before" && (!i2 || i2.type === "root" && i2.first === e24))
              return "";
            if (!i2)
              return r3[n3];
            var s2 = e24.root();
            if (s2.rawCache || (s2.rawCache = {}), s2.rawCache[n3] !== void 0)
              return s2.rawCache[n3];
            if (n3 === "before" || n3 === "after")
              return this.beforeAfter(e24, n3);
            var u2, a2 = "raw" + ((u2 = n3)[0].toUpperCase() + u2.slice(1));
            return this[a2] ? o2 = this[a2](s2, e24) : s2.walk(function(e25) {
              if ((o2 = e25.raws[t6]) !== void 0)
                return false;
            }), o2 === void 0 && (o2 = r3[n3]), s2.rawCache[n3] = o2, o2;
          }, t5.rawSemicolon = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length && e25.last.type === "decl" && (t6 = e25.raws.semicolon) !== void 0)
                return false;
            }), t6;
          }, t5.rawEmptyBody = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length === 0 && (t6 = e25.raws.after) !== void 0)
                return false;
            }), t6;
          }, t5.rawIndent = function(e24) {
            return e24.raws.indent ? e24.raws.indent : (e24.walk(function(r4) {
              var n3 = r4.parent;
              if (n3 && n3 !== e24 && n3.parent && n3.parent === e24 && r4.raws.before !== void 0) {
                var o2 = r4.raws.before.split("\n");
                return t6 = (t6 = o2[o2.length - 1]).replace(/[^\s]/g, ""), false;
              }
            }), t6);
            var t6;
          }, t5.rawBeforeComment = function(e24, t6) {
            var r4;
            return e24.walkComments(function(e25) {
              if (e25.raws.before !== void 0)
                return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeDecl") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeDecl = function(e24, t6) {
            var r4;
            return e24.walkDecls(function(e25) {
              if (e25.raws.before !== void 0)
                return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeRule") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeRule = function(e24) {
            var t6;
            return e24.walk(function(r4) {
              if (r4.nodes && (r4.parent !== e24 || e24.first !== r4) && r4.raws.before !== void 0)
                return (t6 = r4.raws.before).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeClose = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length > 0 && e25.raws.after !== void 0)
                return (t6 = e25.raws.after).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeOpen = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.type !== "decl" && (t6 = e25.raws.between) !== void 0)
                return false;
            }), t6;
          }, t5.rawColon = function(e24) {
            var t6;
            return e24.walkDecls(function(e25) {
              if (e25.raws.between !== void 0)
                return t6 = e25.raws.between.replace(/[^\s:]/g, ""), false;
            }), t6;
          }, t5.beforeAfter = function(e24, t6) {
            var r4;
            r4 = e24.type === "decl" ? this.raw(e24, null, "beforeDecl") : e24.type === "comment" ? this.raw(e24, null, "beforeComment") : t6 === "before" ? this.raw(e24, null, "beforeRule") : this.raw(e24, null, "beforeClose");
            for (var n3 = e24.parent, o2 = 0; n3 && n3.type !== "root"; )
              o2 += 1, n3 = n3.parent;
            if (r4.indexOf("\n") !== -1) {
              var i2 = this.raw(e24, null, "indent");
              if (i2.length)
                for (var s2 = 0; s2 < o2; s2++)
                  r4 += i2;
            }
            return r4;
          }, t5.rawValue = function(e24, t6) {
            var r4 = e24[t6], n3 = e24.raws[t6];
            return n3 && n3.value === r4 ? n3.raw : r4;
          }, e23;
        }();
        t4.default = n2, e22.exports = t4.default;
      }, 6157: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(5701)) && n2.__esModule ? n2 : {default: n2}, i2 = function(e23, t5) {
          new o2.default(t5).stringify(e23);
        };
        t4.default = i2, e22.exports = t4.default;
      }, 1157: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23, t5) {
          t5 === void 0 && (t5 = {});
          var x2, A2, k2, O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2 = e23.css.valueOf(), $2 = t5.ignoreErrors, U2 = P2.length, G2 = -1, W2 = 1, z2 = 0, V2 = [], q2 = [];
          function X2(t6) {
            throw e23.error("Unclosed " + t6, W2, z2 - G2);
          }
          return {back: function(e24) {
            q2.push(e24);
          }, nextToken: function(e24) {
            if (q2.length)
              return q2.pop();
            if (!(z2 >= U2)) {
              var t6 = !!e24 && e24.ignoreUnclosed;
              switch (((x2 = P2.charCodeAt(z2)) === s2 || x2 === a2 || x2 === l2 && P2.charCodeAt(z2 + 1) !== s2) && (G2 = z2, W2 += 1), x2) {
                case s2:
                case u2:
                case c2:
                case l2:
                case a2:
                  A2 = z2;
                  do {
                    A2 += 1, (x2 = P2.charCodeAt(A2)) === s2 && (G2 = A2, W2 += 1);
                  } while (x2 === u2 || x2 === s2 || x2 === c2 || x2 === l2 || x2 === a2);
                  B2 = ["space", P2.slice(z2, A2)], z2 = A2 - 1;
                  break;
                case f2:
                case p2:
                case D2:
                case g2:
                case y2:
                case m2:
                case d2:
                  var J2 = String.fromCharCode(x2);
                  B2 = [J2, J2, W2, z2 - G2];
                  break;
                case h2:
                  if (j2 = V2.length ? V2.pop()[1] : "", L2 = P2.charCodeAt(z2 + 1), j2 === "url" && L2 !== r3 && L2 !== n2 && L2 !== u2 && L2 !== s2 && L2 !== c2 && L2 !== a2 && L2 !== l2) {
                    A2 = z2;
                    do {
                      if (M2 = false, (A2 = P2.indexOf(")", A2 + 1)) === -1) {
                        if ($2 || t6) {
                          A2 = z2;
                          break;
                        }
                        X2("bracket");
                      }
                      for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                        R2 -= 1, M2 = !M2;
                    } while (M2);
                    B2 = ["brackets", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  } else
                    A2 = P2.indexOf(")", z2 + 1), S2 = P2.slice(z2, A2 + 1), A2 === -1 || E2.test(S2) ? B2 = ["(", "(", W2, z2 - G2] : (B2 = ["brackets", S2, W2, z2 - G2, W2, A2 - G2], z2 = A2);
                  break;
                case r3:
                case n2:
                  k2 = x2 === r3 ? "'" : '"', A2 = z2;
                  do {
                    if (M2 = false, (A2 = P2.indexOf(k2, A2 + 1)) === -1) {
                      if ($2 || t6) {
                        A2 = z2 + 1;
                        break;
                      }
                      X2("string");
                    }
                    for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                      R2 -= 1, M2 = !M2;
                  } while (M2);
                  S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["string", P2.slice(z2, A2 + 1), W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2;
                  break;
                case w2:
                  b2.lastIndex = z2 + 1, b2.test(P2), A2 = b2.lastIndex === 0 ? P2.length - 1 : b2.lastIndex - 2, B2 = ["at-word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  break;
                case o2:
                  for (A2 = z2, T2 = true; P2.charCodeAt(A2 + 1) === o2; )
                    A2 += 1, T2 = !T2;
                  if (x2 = P2.charCodeAt(A2 + 1), T2 && x2 !== i2 && x2 !== u2 && x2 !== s2 && x2 !== c2 && x2 !== l2 && x2 !== a2 && (A2 += 1, F2.test(P2.charAt(A2)))) {
                    for (; F2.test(P2.charAt(A2 + 1)); )
                      A2 += 1;
                    P2.charCodeAt(A2 + 1) === u2 && (A2 += 1);
                  }
                  B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], z2 = A2;
                  break;
                default:
                  x2 === i2 && P2.charCodeAt(z2 + 1) === v2 ? ((A2 = P2.indexOf("*/", z2 + 2) + 1) === 0 && ($2 || t6 ? A2 = P2.length : X2("comment")), S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = ["comment", S2, W2, z2 - G2, I2, A2 - N2], G2 = N2, W2 = I2, z2 = A2) : (C2.lastIndex = z2 + 1, C2.test(P2), A2 = C2.lastIndex === 0 ? P2.length - 1 : C2.lastIndex - 2, B2 = ["word", P2.slice(z2, A2 + 1), W2, z2 - G2, W2, A2 - G2], V2.push(B2), z2 = A2);
              }
              return z2++, B2;
            }
          }, endOfFile: function() {
            return q2.length === 0 && z2 >= U2;
          }, position: function() {
            return z2;
          }};
        };
        var r3 = "'".charCodeAt(0), n2 = '"'.charCodeAt(0), o2 = "\\".charCodeAt(0), i2 = "/".charCodeAt(0), s2 = "\n".charCodeAt(0), u2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), l2 = "\r".charCodeAt(0), f2 = "[".charCodeAt(0), p2 = "]".charCodeAt(0), h2 = "(".charCodeAt(0), d2 = ")".charCodeAt(0), D2 = "{".charCodeAt(0), g2 = "}".charCodeAt(0), m2 = ";".charCodeAt(0), v2 = "*".charCodeAt(0), y2 = ":".charCodeAt(0), w2 = "@".charCodeAt(0), b2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, C2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, E2 = /.[\\/("'\n]/, F2 = /[a-f0-9]/i;
        e22.exports = t4.default;
      }, 6574: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23) {
          r3[e23] || (r3[e23] = true, typeof console != "undefined" && console.warn && console.warn(e23));
        };
        var r3 = {};
        e22.exports = t4.default;
      }, 1662: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = function() {
          function e23(e24, t5) {
            if (t5 === void 0 && (t5 = {}), this.type = "warning", this.text = e24, t5.node && t5.node.source) {
              var r4 = t5.node.positionBy(t5);
              this.line = r4.line, this.column = r4.column;
            }
            for (var n2 in t5)
              this[n2] = t5[n2];
          }
          return e23.prototype.toString = function() {
            return this.node ? this.node.error(this.text, {plugin: this.plugin, index: this.index, word: this.word}).message : this.plugin ? this.plugin + ": " + this.text : this.text;
          }, e23;
        }();
        t4.default = r3, e22.exports = t4.default;
      }, 6210: (e22, t4, r3) => {
        const n2 = r3(895), {MAX_LENGTH: o2, MAX_SAFE_INTEGER: i2} = r3(8523), {re: s2, t: u2} = r3(3443), a2 = r3(8077), {compareIdentifiers: c2} = r3(8337);
        class l2 {
          constructor(e23, t5) {
            if (t5 = a2(t5), e23 instanceof l2) {
              if (e23.loose === !!t5.loose && e23.includePrerelease === !!t5.includePrerelease)
                return e23;
              e23 = e23.version;
            } else if (typeof e23 != "string")
              throw new TypeError(`Invalid Version: ${e23}`);
            if (e23.length > o2)
              throw new TypeError(`version is longer than ${o2} characters`);
            n2("SemVer", e23, t5), this.options = t5, this.loose = !!t5.loose, this.includePrerelease = !!t5.includePrerelease;
            const r4 = e23.trim().match(t5.loose ? s2[u2.LOOSE] : s2[u2.FULL]);
            if (!r4)
              throw new TypeError(`Invalid Version: ${e23}`);
            if (this.raw = e23, this.major = +r4[1], this.minor = +r4[2], this.patch = +r4[3], this.major > i2 || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > i2 || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > i2 || this.patch < 0)
              throw new TypeError("Invalid patch version");
            r4[4] ? this.prerelease = r4[4].split(".").map((e24) => {
              if (/^[0-9]+$/.test(e24)) {
                const t6 = +e24;
                if (t6 >= 0 && t6 < i2)
                  return t6;
              }
              return e24;
            }) : this.prerelease = [], this.build = r4[5] ? r4[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(e23) {
            if (n2("SemVer.compare", this.version, this.options, e23), !(e23 instanceof l2)) {
              if (typeof e23 == "string" && e23 === this.version)
                return 0;
              e23 = new l2(e23, this.options);
            }
            return e23.version === this.version ? 0 : this.compareMain(e23) || this.comparePre(e23);
          }
          compareMain(e23) {
            return e23 instanceof l2 || (e23 = new l2(e23, this.options)), c2(this.major, e23.major) || c2(this.minor, e23.minor) || c2(this.patch, e23.patch);
          }
          comparePre(e23) {
            if (e23 instanceof l2 || (e23 = new l2(e23, this.options)), this.prerelease.length && !e23.prerelease.length)
              return -1;
            if (!this.prerelease.length && e23.prerelease.length)
              return 1;
            if (!this.prerelease.length && !e23.prerelease.length)
              return 0;
            let t5 = 0;
            do {
              const r4 = this.prerelease[t5], o3 = e23.prerelease[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          compareBuild(e23) {
            e23 instanceof l2 || (e23 = new l2(e23, this.options));
            let t5 = 0;
            do {
              const r4 = this.build[t5], o3 = e23.build[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          inc(e23, t5) {
            switch (e23) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t5);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t5);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let e24 = this.prerelease.length;
                  for (; --e24 >= 0; )
                    typeof this.prerelease[e24] == "number" && (this.prerelease[e24]++, e24 = -2);
                  e24 === -1 && this.prerelease.push(0);
                }
                t5 && (this.prerelease[0] === t5 ? isNaN(this.prerelease[1]) && (this.prerelease = [t5, 0]) : this.prerelease = [t5, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${e23}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        e22.exports = l2;
      }, 2828: (e22, t4, r3) => {
        const n2 = r3(6210);
        e22.exports = (e23, t5, r4) => new n2(e23, r4).compare(new n2(t5, r4));
      }, 9195: (e22, t4, r3) => {
        const n2 = r3(2828);
        e22.exports = (e23, t5, r4) => n2(e23, t5, r4) >= 0;
      }, 3725: (e22, t4, r3) => {
        const n2 = r3(2828);
        e22.exports = (e23, t5, r4) => n2(e23, t5, r4) < 0;
      }, 8523: (e22) => {
        const t4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
        e22.exports = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: t4, MAX_SAFE_COMPONENT_LENGTH: 16};
      }, 895: (e22) => {
        const t4 = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e23) => console.error("SEMVER", ...e23) : () => {
        };
        e22.exports = t4;
      }, 8337: (e22) => {
        const t4 = /^[0-9]+$/, r3 = (e23, r4) => {
          const n2 = t4.test(e23), o2 = t4.test(r4);
          return n2 && o2 && (e23 = +e23, r4 = +r4), e23 === r4 ? 0 : n2 && !o2 ? -1 : o2 && !n2 ? 1 : e23 < r4 ? -1 : 1;
        };
        e22.exports = {compareIdentifiers: r3, rcompareIdentifiers: (e23, t5) => r3(t5, e23)};
      }, 8077: (e22) => {
        const t4 = ["includePrerelease", "loose", "rtl"];
        e22.exports = (e23) => e23 ? typeof e23 != "object" ? {loose: true} : t4.filter((t5) => e23[t5]).reduce((e24, t5) => (e24[t5] = true, e24), {}) : {};
      }, 3443: (e22, t4, r3) => {
        const {MAX_SAFE_COMPONENT_LENGTH: n2} = r3(8523), o2 = r3(895), i2 = (t4 = e22.exports = {}).re = [], s2 = t4.src = [], u2 = t4.t = {};
        let a2 = 0;
        const c2 = (e23, t5, r4) => {
          const n3 = a2++;
          o2(n3, t5), u2[e23] = n3, s2[n3] = t5, i2[n3] = new RegExp(t5, r4 ? "g" : void 0);
        };
        c2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c2("MAINVERSION", `(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})`), c2("MAINVERSIONLOOSE", `(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})`), c2("PRERELEASEIDENTIFIER", `(?:${s2[u2.NUMERICIDENTIFIER]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASEIDENTIFIERLOOSE", `(?:${s2[u2.NUMERICIDENTIFIERLOOSE]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASE", `(?:-(${s2[u2.PRERELEASEIDENTIFIER]}(?:\\.${s2[u2.PRERELEASEIDENTIFIER]})*))`), c2("PRERELEASELOOSE", `(?:-?(${s2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), c2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c2("BUILD", `(?:\\+(${s2[u2.BUILDIDENTIFIER]}(?:\\.${s2[u2.BUILDIDENTIFIER]})*))`), c2("FULLPLAIN", `v?${s2[u2.MAINVERSION]}${s2[u2.PRERELEASE]}?${s2[u2.BUILD]}?`), c2("FULL", `^${s2[u2.FULLPLAIN]}$`), c2("LOOSEPLAIN", `[v=\\s]*${s2[u2.MAINVERSIONLOOSE]}${s2[u2.PRERELEASELOOSE]}?${s2[u2.BUILD]}?`), c2("LOOSE", `^${s2[u2.LOOSEPLAIN]}$`), c2("GTLT", "((?:<|>)?=?)"), c2("XRANGEIDENTIFIERLOOSE", `${s2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c2("XRANGEIDENTIFIER", `${s2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), c2("XRANGEPLAIN", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:${s2[u2.PRERELEASE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGEPLAINLOOSE", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:${s2[u2.PRERELEASELOOSE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAIN]}$`), c2("XRANGELOOSE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), c2("COERCERTL", s2[u2.COERCE], true), c2("LONETILDE", "(?:~>?)"), c2("TILDETRIM", `(\\s*)${s2[u2.LONETILDE]}\\s+`, true), t4.tildeTrimReplace = "$1~", c2("TILDE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAIN]}$`), c2("TILDELOOSE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("LONECARET", "(?:\\^)"), c2("CARETTRIM", `(\\s*)${s2[u2.LONECARET]}\\s+`, true), t4.caretTrimReplace = "$1^", c2("CARET", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAIN]}$`), c2("CARETLOOSE", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COMPARATORLOOSE", `^${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]})$|^$`), c2("COMPARATOR", `^${s2[u2.GTLT]}\\s*(${s2[u2.FULLPLAIN]})$|^$`), c2("COMPARATORTRIM", `(\\s*)${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]}|${s2[u2.XRANGEPLAIN]})`, true), t4.comparatorTrimReplace = "$1$2$3", c2("HYPHENRANGE", `^\\s*(${s2[u2.XRANGEPLAIN]})\\s+-\\s+(${s2[u2.XRANGEPLAIN]})\\s*$`), c2("HYPHENRANGELOOSE", `^\\s*(${s2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${s2[u2.XRANGEPLAINLOOSE]})\\s*$`), c2("STAR", "(<|>)?=?\\s*\\*"), c2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      }, 6715: (e22, t4, r3) => {
        var n2 = r3(7837), o2 = Object.prototype.hasOwnProperty, i2 = typeof Map != "undefined";
        function s2() {
          this._array = [], this._set = i2 ? new Map() : Object.create(null);
        }
        s2.fromArray = function(e23, t5) {
          for (var r4 = new s2(), n3 = 0, o3 = e23.length; n3 < o3; n3++)
            r4.add(e23[n3], t5);
          return r4;
        }, s2.prototype.size = function() {
          return i2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }, s2.prototype.add = function(e23, t5) {
          var r4 = i2 ? e23 : n2.toSetString(e23), s3 = i2 ? this.has(e23) : o2.call(this._set, r4), u2 = this._array.length;
          s3 && !t5 || this._array.push(e23), s3 || (i2 ? this._set.set(e23, u2) : this._set[r4] = u2);
        }, s2.prototype.has = function(e23) {
          if (i2)
            return this._set.has(e23);
          var t5 = n2.toSetString(e23);
          return o2.call(this._set, t5);
        }, s2.prototype.indexOf = function(e23) {
          if (i2) {
            var t5 = this._set.get(e23);
            if (t5 >= 0)
              return t5;
          } else {
            var r4 = n2.toSetString(e23);
            if (o2.call(this._set, r4))
              return this._set[r4];
          }
          throw new Error('"' + e23 + '" is not in the set.');
        }, s2.prototype.at = function(e23) {
          if (e23 >= 0 && e23 < this._array.length)
            return this._array[e23];
          throw new Error("No element indexed by " + e23);
        }, s2.prototype.toArray = function() {
          return this._array.slice();
        }, t4.I = s2;
      }, 4886: (e22, t4, r3) => {
        var n2 = r3(4122);
        t4.encode = function(e23) {
          var t5, r4 = "", o2 = function(e24) {
            return e24 < 0 ? 1 + (-e24 << 1) : 0 + (e24 << 1);
          }(e23);
          do {
            t5 = 31 & o2, (o2 >>>= 5) > 0 && (t5 |= 32), r4 += n2.encode(t5);
          } while (o2 > 0);
          return r4;
        }, t4.decode = function(e23, t5, r4) {
          var o2, i2, s2, u2, a2 = e23.length, c2 = 0, l2 = 0;
          do {
            if (t5 >= a2)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if ((i2 = n2.decode(e23.charCodeAt(t5++))) === -1)
              throw new Error("Invalid base64 digit: " + e23.charAt(t5 - 1));
            o2 = !!(32 & i2), c2 += (i2 &= 31) << l2, l2 += 5;
          } while (o2);
          r4.value = (u2 = (s2 = c2) >> 1, (1 & s2) == 1 ? -u2 : u2), r4.rest = t5;
        };
      }, 4122: (e22, t4) => {
        var r3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        t4.encode = function(e23) {
          if (0 <= e23 && e23 < r3.length)
            return r3[e23];
          throw new TypeError("Must be between 0 and 63: " + e23);
        }, t4.decode = function(e23) {
          return 65 <= e23 && e23 <= 90 ? e23 - 65 : 97 <= e23 && e23 <= 122 ? e23 - 97 + 26 : 48 <= e23 && e23 <= 57 ? e23 - 48 + 52 : e23 == 43 ? 62 : e23 == 47 ? 63 : -1;
        };
      }, 8593: (e22, t4) => {
        function r3(e23, n2, o2, i2, s2, u2) {
          var a2 = Math.floor((n2 - e23) / 2) + e23, c2 = s2(o2, i2[a2], true);
          return c2 === 0 ? a2 : c2 > 0 ? n2 - a2 > 1 ? r3(a2, n2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? n2 < i2.length ? n2 : -1 : a2 : a2 - e23 > 1 ? r3(e23, a2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? a2 : e23 < 0 ? -1 : e23;
        }
        t4.GREATEST_LOWER_BOUND = 1, t4.LEAST_UPPER_BOUND = 2, t4.search = function(e23, n2, o2, i2) {
          if (n2.length === 0)
            return -1;
          var s2 = r3(-1, n2.length, e23, n2, o2, i2 || t4.GREATEST_LOWER_BOUND);
          if (s2 < 0)
            return -1;
          for (; s2 - 1 >= 0 && o2(n2[s2], n2[s2 - 1], true) === 0; )
            --s2;
          return s2;
        };
      }, 1028: (e22, t4, r3) => {
        r3(4070);
        var n2 = r3(7837);
        function o2() {
          this._array = [], this._sorted = true, this._last = {generatedLine: -1, generatedColumn: 0};
        }
        o2.prototype.unsortedForEach = function(e23, t5) {
          this._array.forEach(e23, t5);
        }, o2.prototype.add = function(e23) {
          var t5, r4, o3, i2, s2, u2;
          r4 = e23, o3 = (t5 = this._last).generatedLine, i2 = r4.generatedLine, s2 = t5.generatedColumn, u2 = r4.generatedColumn, i2 > o3 || i2 == o3 && u2 >= s2 || n2.compareByGeneratedPositionsInflated(t5, r4) <= 0 ? (this._last = e23, this._array.push(e23)) : (this._sorted = false, this._array.push(e23));
        }, o2.prototype.toArray = function() {
          return this._sorted || (this._array.sort(n2.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
        }, t4.H = o2;
      }, 6711: (e22, t4) => {
        function r3(e23, t5, r4) {
          var n3 = e23[t5];
          e23[t5] = e23[r4], e23[r4] = n3;
        }
        function n2(e23, t5, o2, i2) {
          if (o2 < i2) {
            var s2 = o2 - 1;
            r3(e23, (l2 = o2, f2 = i2, Math.round(l2 + Math.random() * (f2 - l2))), i2);
            for (var u2 = e23[i2], a2 = o2; a2 < i2; a2++)
              t5(e23[a2], u2) <= 0 && r3(e23, s2 += 1, a2);
            r3(e23, s2 + 1, a2);
            var c2 = s2 + 1;
            n2(e23, t5, o2, c2 - 1), n2(e23, t5, c2 + 1, i2);
          }
          var l2, f2;
        }
        t4.U = function(e23, t5) {
          n2(e23, t5, 0, e23.length - 1);
        };
      }, 8985: (e22, t4, r3) => {
        var n2 = r3(7837), o2 = r3(8593), i2 = r3(6715).I, s2 = r3(4886), u2 = r3(6711).U;
        function a2(e23, t5) {
          var r4 = e23;
          return typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23)), r4.sections != null ? new f2(r4, t5) : new c2(r4, t5);
        }
        function c2(e23, t5) {
          var r4 = e23;
          typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sources"), u3 = n2.getArg(r4, "names", []), a3 = n2.getArg(r4, "sourceRoot", null), c3 = n2.getArg(r4, "sourcesContent", null), l3 = n2.getArg(r4, "mappings"), f3 = n2.getArg(r4, "file", null);
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          a3 && (a3 = n2.normalize(a3)), s3 = s3.map(String).map(n2.normalize).map(function(e24) {
            return a3 && n2.isAbsolute(a3) && n2.isAbsolute(e24) ? n2.relative(a3, e24) : e24;
          }), this._names = i2.fromArray(u3.map(String), true), this._sources = i2.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e24) {
            return n2.computeSourceURL(a3, e24, t5);
          }), this.sourceRoot = a3, this.sourcesContent = c3, this._mappings = l3, this._sourceMapURL = t5, this.file = f3;
        }
        function l2() {
          this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
        }
        function f2(e23, t5) {
          var r4 = e23;
          typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sections");
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          this._sources = new i2(), this._names = new i2();
          var u3 = {line: -1, column: 0};
          this._sections = s3.map(function(e24) {
            if (e24.url)
              throw new Error("Support for url field in sections not implemented.");
            var r5 = n2.getArg(e24, "offset"), o4 = n2.getArg(r5, "line"), i3 = n2.getArg(r5, "column");
            if (o4 < u3.line || o4 === u3.line && i3 < u3.column)
              throw new Error("Section offsets must be ordered and non-overlapping.");
            return u3 = r5, {generatedOffset: {generatedLine: o4 + 1, generatedColumn: i3 + 1}, consumer: new a2(n2.getArg(e24, "map"), t5)};
          });
        }
        a2.fromSourceMap = function(e23, t5) {
          return c2.fromSourceMap(e23, t5);
        }, a2.prototype._version = 3, a2.prototype.__generatedMappings = null, Object.defineProperty(a2.prototype, "_generatedMappings", {configurable: true, enumerable: true, get: function() {
          return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
        }}), a2.prototype.__originalMappings = null, Object.defineProperty(a2.prototype, "_originalMappings", {configurable: true, enumerable: true, get: function() {
          return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
        }}), a2.prototype._charIsMappingSeparator = function(e23, t5) {
          var r4 = e23.charAt(t5);
          return r4 === ";" || r4 === ",";
        }, a2.prototype._parseMappings = function(e23, t5) {
          throw new Error("Subclasses must implement _parseMappings");
        }, a2.GENERATED_ORDER = 1, a2.ORIGINAL_ORDER = 2, a2.GREATEST_LOWER_BOUND = 1, a2.LEAST_UPPER_BOUND = 2, a2.prototype.eachMapping = function(e23, t5, r4) {
          var o3, i3 = t5 || null;
          switch (r4 || a2.GENERATED_ORDER) {
            case a2.GENERATED_ORDER:
              o3 = this._generatedMappings;
              break;
            case a2.ORIGINAL_ORDER:
              o3 = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var s3 = this.sourceRoot;
          o3.map(function(e24) {
            var t6 = e24.source === null ? null : this._sources.at(e24.source);
            return {source: t6 = n2.computeSourceURL(s3, t6, this._sourceMapURL), generatedLine: e24.generatedLine, generatedColumn: e24.generatedColumn, originalLine: e24.originalLine, originalColumn: e24.originalColumn, name: e24.name === null ? null : this._names.at(e24.name)};
          }, this).forEach(e23, i3);
        }, a2.prototype.allGeneratedPositionsFor = function(e23) {
          var t5 = n2.getArg(e23, "line"), r4 = {source: n2.getArg(e23, "source"), originalLine: t5, originalColumn: n2.getArg(e23, "column", 0)};
          if (r4.source = this._findSourceIndex(r4.source), r4.source < 0)
            return [];
          var i3 = [], s3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, o2.LEAST_UPPER_BOUND);
          if (s3 >= 0) {
            var u3 = this._originalMappings[s3];
            if (e23.column === void 0)
              for (var a3 = u3.originalLine; u3 && u3.originalLine === a3; )
                i3.push({line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)}), u3 = this._originalMappings[++s3];
            else
              for (var c3 = u3.originalColumn; u3 && u3.originalLine === t5 && u3.originalColumn == c3; )
                i3.push({line: n2.getArg(u3, "generatedLine", null), column: n2.getArg(u3, "generatedColumn", null), lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)}), u3 = this._originalMappings[++s3];
          }
          return i3;
        }, t4.SourceMapConsumer = a2, c2.prototype = Object.create(a2.prototype), c2.prototype.consumer = a2, c2.prototype._findSourceIndex = function(e23) {
          var t5, r4 = e23;
          if (this.sourceRoot != null && (r4 = n2.relative(this.sourceRoot, r4)), this._sources.has(r4))
            return this._sources.indexOf(r4);
          for (t5 = 0; t5 < this._absoluteSources.length; ++t5)
            if (this._absoluteSources[t5] == e23)
              return t5;
          return -1;
        }, c2.fromSourceMap = function(e23, t5) {
          var r4 = Object.create(c2.prototype), o3 = r4._names = i2.fromArray(e23._names.toArray(), true), s3 = r4._sources = i2.fromArray(e23._sources.toArray(), true);
          r4.sourceRoot = e23._sourceRoot, r4.sourcesContent = e23._generateSourcesContent(r4._sources.toArray(), r4.sourceRoot), r4.file = e23._file, r4._sourceMapURL = t5, r4._absoluteSources = r4._sources.toArray().map(function(e24) {
            return n2.computeSourceURL(r4.sourceRoot, e24, t5);
          });
          for (var a3 = e23._mappings.toArray().slice(), f3 = r4.__generatedMappings = [], p2 = r4.__originalMappings = [], h2 = 0, d2 = a3.length; h2 < d2; h2++) {
            var D2 = a3[h2], g2 = new l2();
            g2.generatedLine = D2.generatedLine, g2.generatedColumn = D2.generatedColumn, D2.source && (g2.source = s3.indexOf(D2.source), g2.originalLine = D2.originalLine, g2.originalColumn = D2.originalColumn, D2.name && (g2.name = o3.indexOf(D2.name)), p2.push(g2)), f3.push(g2);
          }
          return u2(r4.__originalMappings, n2.compareByOriginalPositions), r4;
        }, c2.prototype._version = 3, Object.defineProperty(c2.prototype, "sources", {get: function() {
          return this._absoluteSources.slice();
        }}), c2.prototype._parseMappings = function(e23, t5) {
          for (var r4, o3, i3, a3, c3, f3 = 1, p2 = 0, h2 = 0, d2 = 0, D2 = 0, g2 = 0, m2 = e23.length, v2 = 0, y2 = {}, w2 = {}, b2 = [], C2 = []; v2 < m2; )
            if (e23.charAt(v2) === ";")
              f3++, v2++, p2 = 0;
            else if (e23.charAt(v2) === ",")
              v2++;
            else {
              for ((r4 = new l2()).generatedLine = f3, a3 = v2; a3 < m2 && !this._charIsMappingSeparator(e23, a3); a3++)
                ;
              if (i3 = y2[o3 = e23.slice(v2, a3)])
                v2 += o3.length;
              else {
                for (i3 = []; v2 < a3; )
                  s2.decode(e23, v2, w2), c3 = w2.value, v2 = w2.rest, i3.push(c3);
                if (i3.length === 2)
                  throw new Error("Found a source, but no line and column");
                if (i3.length === 3)
                  throw new Error("Found a source and line, but no column");
                y2[o3] = i3;
              }
              r4.generatedColumn = p2 + i3[0], p2 = r4.generatedColumn, i3.length > 1 && (r4.source = D2 + i3[1], D2 += i3[1], r4.originalLine = h2 + i3[2], h2 = r4.originalLine, r4.originalLine += 1, r4.originalColumn = d2 + i3[3], d2 = r4.originalColumn, i3.length > 4 && (r4.name = g2 + i3[4], g2 += i3[4])), C2.push(r4), typeof r4.originalLine == "number" && b2.push(r4);
            }
          u2(C2, n2.compareByGeneratedPositionsDeflated), this.__generatedMappings = C2, u2(b2, n2.compareByOriginalPositions), this.__originalMappings = b2;
        }, c2.prototype._findMapping = function(e23, t5, r4, n3, i3, s3) {
          if (e23[r4] <= 0)
            throw new TypeError("Line must be greater than or equal to 1, got " + e23[r4]);
          if (e23[n3] < 0)
            throw new TypeError("Column must be greater than or equal to 0, got " + e23[n3]);
          return o2.search(e23, t5, i3, s3);
        }, c2.prototype.computeColumnSpans = function() {
          for (var e23 = 0; e23 < this._generatedMappings.length; ++e23) {
            var t5 = this._generatedMappings[e23];
            if (e23 + 1 < this._generatedMappings.length) {
              var r4 = this._generatedMappings[e23 + 1];
              if (t5.generatedLine === r4.generatedLine) {
                t5.lastGeneratedColumn = r4.generatedColumn - 1;
                continue;
              }
            }
            t5.lastGeneratedColumn = 1 / 0;
          }
        }, c2.prototype.originalPositionFor = function(e23) {
          var t5 = {generatedLine: n2.getArg(e23, "line"), generatedColumn: n2.getArg(e23, "column")}, r4 = this._findMapping(t5, this._generatedMappings, "generatedLine", "generatedColumn", n2.compareByGeneratedPositionsDeflated, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
          if (r4 >= 0) {
            var o3 = this._generatedMappings[r4];
            if (o3.generatedLine === t5.generatedLine) {
              var i3 = n2.getArg(o3, "source", null);
              i3 !== null && (i3 = this._sources.at(i3), i3 = n2.computeSourceURL(this.sourceRoot, i3, this._sourceMapURL));
              var s3 = n2.getArg(o3, "name", null);
              return s3 !== null && (s3 = this._names.at(s3)), {source: i3, line: n2.getArg(o3, "originalLine", null), column: n2.getArg(o3, "originalColumn", null), name: s3};
            }
          }
          return {source: null, line: null, column: null, name: null};
        }, c2.prototype.hasContentsOfAllSources = function() {
          return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e23) {
            return e23 == null;
          });
        }, c2.prototype.sourceContentFor = function(e23, t5) {
          if (!this.sourcesContent)
            return null;
          var r4 = this._findSourceIndex(e23);
          if (r4 >= 0)
            return this.sourcesContent[r4];
          var o3, i3 = e23;
          if (this.sourceRoot != null && (i3 = n2.relative(this.sourceRoot, i3)), this.sourceRoot != null && (o3 = n2.urlParse(this.sourceRoot))) {
            var s3 = i3.replace(/^file:\/\//, "");
            if (o3.scheme == "file" && this._sources.has(s3))
              return this.sourcesContent[this._sources.indexOf(s3)];
            if ((!o3.path || o3.path == "/") && this._sources.has("/" + i3))
              return this.sourcesContent[this._sources.indexOf("/" + i3)];
          }
          if (t5)
            return null;
          throw new Error('"' + i3 + '" is not in the SourceMap.');
        }, c2.prototype.generatedPositionFor = function(e23) {
          var t5 = n2.getArg(e23, "source");
          if ((t5 = this._findSourceIndex(t5)) < 0)
            return {line: null, column: null, lastColumn: null};
          var r4 = {source: t5, originalLine: n2.getArg(e23, "line"), originalColumn: n2.getArg(e23, "column")}, o3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
          if (o3 >= 0) {
            var i3 = this._originalMappings[o3];
            if (i3.source === r4.source)
              return {line: n2.getArg(i3, "generatedLine", null), column: n2.getArg(i3, "generatedColumn", null), lastColumn: n2.getArg(i3, "lastGeneratedColumn", null)};
          }
          return {line: null, column: null, lastColumn: null};
        }, f2.prototype = Object.create(a2.prototype), f2.prototype.constructor = a2, f2.prototype._version = 3, Object.defineProperty(f2.prototype, "sources", {get: function() {
          for (var e23 = [], t5 = 0; t5 < this._sections.length; t5++)
            for (var r4 = 0; r4 < this._sections[t5].consumer.sources.length; r4++)
              e23.push(this._sections[t5].consumer.sources[r4]);
          return e23;
        }}), f2.prototype.originalPositionFor = function(e23) {
          var t5 = {generatedLine: n2.getArg(e23, "line"), generatedColumn: n2.getArg(e23, "column")}, r4 = o2.search(t5, this._sections, function(e24, t6) {
            return e24.generatedLine - t6.generatedOffset.generatedLine || e24.generatedColumn - t6.generatedOffset.generatedColumn;
          }), i3 = this._sections[r4];
          return i3 ? i3.consumer.originalPositionFor({line: t5.generatedLine - (i3.generatedOffset.generatedLine - 1), column: t5.generatedColumn - (i3.generatedOffset.generatedLine === t5.generatedLine ? i3.generatedOffset.generatedColumn - 1 : 0), bias: e23.bias}) : {source: null, line: null, column: null, name: null};
        }, f2.prototype.hasContentsOfAllSources = function() {
          return this._sections.every(function(e23) {
            return e23.consumer.hasContentsOfAllSources();
          });
        }, f2.prototype.sourceContentFor = function(e23, t5) {
          for (var r4 = 0; r4 < this._sections.length; r4++) {
            var n3 = this._sections[r4].consumer.sourceContentFor(e23, true);
            if (n3)
              return n3;
          }
          if (t5)
            return null;
          throw new Error('"' + e23 + '" is not in the SourceMap.');
        }, f2.prototype.generatedPositionFor = function(e23) {
          for (var t5 = 0; t5 < this._sections.length; t5++) {
            var r4 = this._sections[t5];
            if (r4.consumer._findSourceIndex(n2.getArg(e23, "source")) !== -1) {
              var o3 = r4.consumer.generatedPositionFor(e23);
              if (o3)
                return {line: o3.line + (r4.generatedOffset.generatedLine - 1), column: o3.column + (r4.generatedOffset.generatedLine === o3.line ? r4.generatedOffset.generatedColumn - 1 : 0)};
            }
          }
          return {line: null, column: null};
        }, f2.prototype._parseMappings = function(e23, t5) {
          this.__generatedMappings = [], this.__originalMappings = [];
          for (var r4 = 0; r4 < this._sections.length; r4++)
            for (var o3 = this._sections[r4], i3 = o3.consumer._generatedMappings, s3 = 0; s3 < i3.length; s3++) {
              var a3 = i3[s3], c3 = o3.consumer._sources.at(a3.source);
              c3 = n2.computeSourceURL(o3.consumer.sourceRoot, c3, this._sourceMapURL), this._sources.add(c3), c3 = this._sources.indexOf(c3);
              var l3 = null;
              a3.name && (l3 = o3.consumer._names.at(a3.name), this._names.add(l3), l3 = this._names.indexOf(l3));
              var f3 = {source: c3, generatedLine: a3.generatedLine + (o3.generatedOffset.generatedLine - 1), generatedColumn: a3.generatedColumn + (o3.generatedOffset.generatedLine === a3.generatedLine ? o3.generatedOffset.generatedColumn - 1 : 0), originalLine: a3.originalLine, originalColumn: a3.originalColumn, name: l3};
              this.__generatedMappings.push(f3), typeof f3.originalLine == "number" && this.__originalMappings.push(f3);
            }
          u2(this.__generatedMappings, n2.compareByGeneratedPositionsDeflated), u2(this.__originalMappings, n2.compareByOriginalPositions);
        };
      }, 2400: (e22, t4, r3) => {
        var n2 = r3(4886), o2 = r3(7837), i2 = r3(6715).I, s2 = r3(1028).H;
        function u2(e23) {
          e23 || (e23 = {}), this._file = o2.getArg(e23, "file", null), this._sourceRoot = o2.getArg(e23, "sourceRoot", null), this._skipValidation = o2.getArg(e23, "skipValidation", false), this._sources = new i2(), this._names = new i2(), this._mappings = new s2(), this._sourcesContents = null;
        }
        u2.prototype._version = 3, u2.fromSourceMap = function(e23) {
          var t5 = e23.sourceRoot, r4 = new u2({file: e23.file, sourceRoot: t5});
          return e23.eachMapping(function(e24) {
            var n3 = {generated: {line: e24.generatedLine, column: e24.generatedColumn}};
            e24.source != null && (n3.source = e24.source, t5 != null && (n3.source = o2.relative(t5, n3.source)), n3.original = {line: e24.originalLine, column: e24.originalColumn}, e24.name != null && (n3.name = e24.name)), r4.addMapping(n3);
          }), e23.sources.forEach(function(n3) {
            var i3 = n3;
            t5 !== null && (i3 = o2.relative(t5, n3)), r4._sources.has(i3) || r4._sources.add(i3);
            var s3 = e23.sourceContentFor(n3);
            s3 != null && r4.setSourceContent(n3, s3);
          }), r4;
        }, u2.prototype.addMapping = function(e23) {
          var t5 = o2.getArg(e23, "generated"), r4 = o2.getArg(e23, "original", null), n3 = o2.getArg(e23, "source", null), i3 = o2.getArg(e23, "name", null);
          this._skipValidation || this._validateMapping(t5, r4, n3, i3), n3 != null && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), i3 != null && (i3 = String(i3), this._names.has(i3) || this._names.add(i3)), this._mappings.add({generatedLine: t5.line, generatedColumn: t5.column, originalLine: r4 != null && r4.line, originalColumn: r4 != null && r4.column, source: n3, name: i3});
        }, u2.prototype.setSourceContent = function(e23, t5) {
          var r4 = e23;
          this._sourceRoot != null && (r4 = o2.relative(this._sourceRoot, r4)), t5 != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o2.toSetString(r4)] = t5) : this._sourcesContents && (delete this._sourcesContents[o2.toSetString(r4)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        }, u2.prototype.applySourceMap = function(e23, t5, r4) {
          var n3 = t5;
          if (t5 == null) {
            if (e23.file == null)
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            n3 = e23.file;
          }
          var s3 = this._sourceRoot;
          s3 != null && (n3 = o2.relative(s3, n3));
          var u3 = new i2(), a2 = new i2();
          this._mappings.unsortedForEach(function(t6) {
            if (t6.source === n3 && t6.originalLine != null) {
              var i3 = e23.originalPositionFor({line: t6.originalLine, column: t6.originalColumn});
              i3.source != null && (t6.source = i3.source, r4 != null && (t6.source = o2.join(r4, t6.source)), s3 != null && (t6.source = o2.relative(s3, t6.source)), t6.originalLine = i3.line, t6.originalColumn = i3.column, i3.name != null && (t6.name = i3.name));
            }
            var c2 = t6.source;
            c2 == null || u3.has(c2) || u3.add(c2);
            var l2 = t6.name;
            l2 == null || a2.has(l2) || a2.add(l2);
          }, this), this._sources = u3, this._names = a2, e23.sources.forEach(function(t6) {
            var n4 = e23.sourceContentFor(t6);
            n4 != null && (r4 != null && (t6 = o2.join(r4, t6)), s3 != null && (t6 = o2.relative(s3, t6)), this.setSourceContent(t6, n4));
          }, this);
        }, u2.prototype._validateMapping = function(e23, t5, r4, n3) {
          if (t5 && typeof t5.line != "number" && typeof t5.column != "number")
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          if ((!(e23 && "line" in e23 && "column" in e23 && e23.line > 0 && e23.column >= 0) || t5 || r4 || n3) && !(e23 && "line" in e23 && "column" in e23 && t5 && "line" in t5 && "column" in t5 && e23.line > 0 && e23.column >= 0 && t5.line > 0 && t5.column >= 0 && r4))
            throw new Error("Invalid mapping: " + JSON.stringify({generated: e23, source: r4, original: t5, name: n3}));
        }, u2.prototype._serializeMappings = function() {
          for (var e23, t5, r4, i3, s3 = 0, u3 = 1, a2 = 0, c2 = 0, l2 = 0, f2 = 0, p2 = "", h2 = this._mappings.toArray(), d2 = 0, D2 = h2.length; d2 < D2; d2++) {
            if (e23 = "", (t5 = h2[d2]).generatedLine !== u3)
              for (s3 = 0; t5.generatedLine !== u3; )
                e23 += ";", u3++;
            else if (d2 > 0) {
              if (!o2.compareByGeneratedPositionsInflated(t5, h2[d2 - 1]))
                continue;
              e23 += ",";
            }
            e23 += n2.encode(t5.generatedColumn - s3), s3 = t5.generatedColumn, t5.source != null && (i3 = this._sources.indexOf(t5.source), e23 += n2.encode(i3 - f2), f2 = i3, e23 += n2.encode(t5.originalLine - 1 - c2), c2 = t5.originalLine - 1, e23 += n2.encode(t5.originalColumn - a2), a2 = t5.originalColumn, t5.name != null && (r4 = this._names.indexOf(t5.name), e23 += n2.encode(r4 - l2), l2 = r4)), p2 += e23;
          }
          return p2;
        }, u2.prototype._generateSourcesContent = function(e23, t5) {
          return e23.map(function(e24) {
            if (!this._sourcesContents)
              return null;
            t5 != null && (e24 = o2.relative(t5, e24));
            var r4 = o2.toSetString(e24);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, r4) ? this._sourcesContents[r4] : null;
          }, this);
        }, u2.prototype.toJSON = function() {
          var e23 = {version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings()};
          return this._file != null && (e23.file = this._file), this._sourceRoot != null && (e23.sourceRoot = this._sourceRoot), this._sourcesContents && (e23.sourcesContent = this._generateSourcesContent(e23.sources, e23.sourceRoot)), e23;
        }, u2.prototype.toString = function() {
          return JSON.stringify(this.toJSON());
        }, t4.SourceMapGenerator = u2;
      }, 6270: (e22, t4, r3) => {
        var n2 = r3(2400).SourceMapGenerator, o2 = r3(7837), i2 = /(\r?\n)/, s2 = "$$$isSourceNode$$$";
        function u2(e23, t5, r4, n3, o3) {
          this.children = [], this.sourceContents = {}, this.line = e23 == null ? null : e23, this.column = t5 == null ? null : t5, this.source = r4 == null ? null : r4, this.name = o3 == null ? null : o3, this[s2] = true, n3 != null && this.add(n3);
        }
        u2.fromStringWithSourceMap = function(e23, t5, r4) {
          var n3 = new u2(), s3 = e23.split(i2), a2 = 0, c2 = function() {
            return e24() + (e24() || "");
            function e24() {
              return a2 < s3.length ? s3[a2++] : void 0;
            }
          }, l2 = 1, f2 = 0, p2 = null;
          return t5.eachMapping(function(e24) {
            if (p2 !== null) {
              if (!(l2 < e24.generatedLine)) {
                var t6 = (r5 = s3[a2] || "").substr(0, e24.generatedColumn - f2);
                return s3[a2] = r5.substr(e24.generatedColumn - f2), f2 = e24.generatedColumn, h2(p2, t6), void (p2 = e24);
              }
              h2(p2, c2()), l2++, f2 = 0;
            }
            for (; l2 < e24.generatedLine; )
              n3.add(c2()), l2++;
            if (f2 < e24.generatedColumn) {
              var r5 = s3[a2] || "";
              n3.add(r5.substr(0, e24.generatedColumn)), s3[a2] = r5.substr(e24.generatedColumn), f2 = e24.generatedColumn;
            }
            p2 = e24;
          }, this), a2 < s3.length && (p2 && h2(p2, c2()), n3.add(s3.splice(a2).join(""))), t5.sources.forEach(function(e24) {
            var i3 = t5.sourceContentFor(e24);
            i3 != null && (r4 != null && (e24 = o2.join(r4, e24)), n3.setSourceContent(e24, i3));
          }), n3;
          function h2(e24, t6) {
            if (e24 === null || e24.source === void 0)
              n3.add(t6);
            else {
              var i3 = r4 ? o2.join(r4, e24.source) : e24.source;
              n3.add(new u2(e24.originalLine, e24.originalColumn, i3, t6, e24.name));
            }
          }
        }, u2.prototype.add = function(e23) {
          if (Array.isArray(e23))
            e23.forEach(function(e24) {
              this.add(e24);
            }, this);
          else {
            if (!e23[s2] && typeof e23 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
            e23 && this.children.push(e23);
          }
          return this;
        }, u2.prototype.prepend = function(e23) {
          if (Array.isArray(e23))
            for (var t5 = e23.length - 1; t5 >= 0; t5--)
              this.prepend(e23[t5]);
          else {
            if (!e23[s2] && typeof e23 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
            this.children.unshift(e23);
          }
          return this;
        }, u2.prototype.walk = function(e23) {
          for (var t5, r4 = 0, n3 = this.children.length; r4 < n3; r4++)
            (t5 = this.children[r4])[s2] ? t5.walk(e23) : t5 !== "" && e23(t5, {source: this.source, line: this.line, column: this.column, name: this.name});
        }, u2.prototype.join = function(e23) {
          var t5, r4, n3 = this.children.length;
          if (n3 > 0) {
            for (t5 = [], r4 = 0; r4 < n3 - 1; r4++)
              t5.push(this.children[r4]), t5.push(e23);
            t5.push(this.children[r4]), this.children = t5;
          }
          return this;
        }, u2.prototype.replaceRight = function(e23, t5) {
          var r4 = this.children[this.children.length - 1];
          return r4[s2] ? r4.replaceRight(e23, t5) : typeof r4 == "string" ? this.children[this.children.length - 1] = r4.replace(e23, t5) : this.children.push("".replace(e23, t5)), this;
        }, u2.prototype.setSourceContent = function(e23, t5) {
          this.sourceContents[o2.toSetString(e23)] = t5;
        }, u2.prototype.walkSourceContents = function(e23) {
          for (var t5 = 0, r4 = this.children.length; t5 < r4; t5++)
            this.children[t5][s2] && this.children[t5].walkSourceContents(e23);
          var n3 = Object.keys(this.sourceContents);
          for (t5 = 0, r4 = n3.length; t5 < r4; t5++)
            e23(o2.fromSetString(n3[t5]), this.sourceContents[n3[t5]]);
        }, u2.prototype.toString = function() {
          var e23 = "";
          return this.walk(function(t5) {
            e23 += t5;
          }), e23;
        }, u2.prototype.toStringWithSourceMap = function(e23) {
          var t5 = {code: "", line: 1, column: 0}, r4 = new n2(e23), o3 = false, i3 = null, s3 = null, u3 = null, a2 = null;
          return this.walk(function(e24, n3) {
            t5.code += e24, n3.source !== null && n3.line !== null && n3.column !== null ? (i3 === n3.source && s3 === n3.line && u3 === n3.column && a2 === n3.name || r4.addMapping({source: n3.source, original: {line: n3.line, column: n3.column}, generated: {line: t5.line, column: t5.column}, name: n3.name}), i3 = n3.source, s3 = n3.line, u3 = n3.column, a2 = n3.name, o3 = true) : o3 && (r4.addMapping({generated: {line: t5.line, column: t5.column}}), i3 = null, o3 = false);
            for (var c2 = 0, l2 = e24.length; c2 < l2; c2++)
              e24.charCodeAt(c2) === 10 ? (t5.line++, t5.column = 0, c2 + 1 === l2 ? (i3 = null, o3 = false) : o3 && r4.addMapping({source: n3.source, original: {line: n3.line, column: n3.column}, generated: {line: t5.line, column: t5.column}, name: n3.name})) : t5.column++;
          }), this.walkSourceContents(function(e24, t6) {
            r4.setSourceContent(e24, t6);
          }), {code: t5.code, map: r4};
        }, t4.SourceNode = u2;
      }, 7837: (e22, t4) => {
        t4.getArg = function(e23, t5, r4) {
          if (t5 in e23)
            return e23[t5];
          if (arguments.length === 3)
            return r4;
          throw new Error('"' + t5 + '" is a required argument.');
        };
        var r3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n2 = /^data:.+\,.+$/;
        function o2(e23) {
          var t5 = e23.match(r3);
          return t5 ? {scheme: t5[1], auth: t5[2], host: t5[3], port: t5[4], path: t5[5]} : null;
        }
        function i2(e23) {
          var t5 = "";
          return e23.scheme && (t5 += e23.scheme + ":"), t5 += "//", e23.auth && (t5 += e23.auth + "@"), e23.host && (t5 += e23.host), e23.port && (t5 += ":" + e23.port), e23.path && (t5 += e23.path), t5;
        }
        function s2(e23) {
          var r4 = e23, n3 = o2(e23);
          if (n3) {
            if (!n3.path)
              return e23;
            r4 = n3.path;
          }
          for (var s3, u3 = t4.isAbsolute(r4), a3 = r4.split(/\/+/), c3 = 0, l3 = a3.length - 1; l3 >= 0; l3--)
            (s3 = a3[l3]) === "." ? a3.splice(l3, 1) : s3 === ".." ? c3++ : c3 > 0 && (s3 === "" ? (a3.splice(l3 + 1, c3), c3 = 0) : (a3.splice(l3, 2), c3--));
          return (r4 = a3.join("/")) === "" && (r4 = u3 ? "/" : "."), n3 ? (n3.path = r4, i2(n3)) : r4;
        }
        function u2(e23, t5) {
          e23 === "" && (e23 = "."), t5 === "" && (t5 = ".");
          var r4 = o2(t5), u3 = o2(e23);
          if (u3 && (e23 = u3.path || "/"), r4 && !r4.scheme)
            return u3 && (r4.scheme = u3.scheme), i2(r4);
          if (r4 || t5.match(n2))
            return t5;
          if (u3 && !u3.host && !u3.path)
            return u3.host = t5, i2(u3);
          var a3 = t5.charAt(0) === "/" ? t5 : s2(e23.replace(/\/+$/, "") + "/" + t5);
          return u3 ? (u3.path = a3, i2(u3)) : a3;
        }
        t4.urlParse = o2, t4.urlGenerate = i2, t4.normalize = s2, t4.join = u2, t4.isAbsolute = function(e23) {
          return e23.charAt(0) === "/" || r3.test(e23);
        }, t4.relative = function(e23, t5) {
          e23 === "" && (e23 = "."), e23 = e23.replace(/\/$/, "");
          for (var r4 = 0; t5.indexOf(e23 + "/") !== 0; ) {
            var n3 = e23.lastIndexOf("/");
            if (n3 < 0)
              return t5;
            if ((e23 = e23.slice(0, n3)).match(/^([^\/]+:\/)?\/*$/))
              return t5;
            ++r4;
          }
          return Array(r4 + 1).join("../") + t5.substr(e23.length + 1);
        };
        var a2 = !("__proto__" in Object.create(null));
        function c2(e23) {
          return e23;
        }
        function l2(e23) {
          if (!e23)
            return false;
          var t5 = e23.length;
          if (t5 < 9)
            return false;
          if (e23.charCodeAt(t5 - 1) !== 95 || e23.charCodeAt(t5 - 2) !== 95 || e23.charCodeAt(t5 - 3) !== 111 || e23.charCodeAt(t5 - 4) !== 116 || e23.charCodeAt(t5 - 5) !== 111 || e23.charCodeAt(t5 - 6) !== 114 || e23.charCodeAt(t5 - 7) !== 112 || e23.charCodeAt(t5 - 8) !== 95 || e23.charCodeAt(t5 - 9) !== 95)
            return false;
          for (var r4 = t5 - 10; r4 >= 0; r4--)
            if (e23.charCodeAt(r4) !== 36)
              return false;
          return true;
        }
        function f2(e23, t5) {
          return e23 === t5 ? 0 : e23 === null ? 1 : t5 === null ? -1 : e23 > t5 ? 1 : -1;
        }
        t4.toSetString = a2 ? c2 : function(e23) {
          return l2(e23) ? "$" + e23 : e23;
        }, t4.fromSetString = a2 ? c2 : function(e23) {
          return l2(e23) ? e23.slice(1) : e23;
        }, t4.compareByOriginalPositions = function(e23, t5, r4) {
          var n3 = f2(e23.source, t5.source);
          return n3 !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 || r4 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || (n3 = e23.generatedLine - t5.generatedLine) != 0 ? n3 : f2(e23.name, t5.name);
        }, t4.compareByGeneratedPositionsDeflated = function(e23, t5, r4) {
          var n3 = e23.generatedLine - t5.generatedLine;
          return n3 !== 0 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || r4 || (n3 = f2(e23.source, t5.source)) !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 ? n3 : f2(e23.name, t5.name);
        }, t4.compareByGeneratedPositionsInflated = function(e23, t5) {
          var r4 = e23.generatedLine - t5.generatedLine;
          return r4 !== 0 || (r4 = e23.generatedColumn - t5.generatedColumn) != 0 || (r4 = f2(e23.source, t5.source)) !== 0 || (r4 = e23.originalLine - t5.originalLine) != 0 || (r4 = e23.originalColumn - t5.originalColumn) != 0 ? r4 : f2(e23.name, t5.name);
        }, t4.parseSourceMapInput = function(e23) {
          return JSON.parse(e23.replace(/^\)]}'[^\n]*\n/, ""));
        }, t4.computeSourceURL = function(e23, t5, r4) {
          if (t5 = t5 || "", e23 && (e23[e23.length - 1] !== "/" && t5[0] !== "/" && (e23 += "/"), t5 = e23 + t5), r4) {
            var n3 = o2(r4);
            if (!n3)
              throw new Error("sourceMapURL could not be parsed");
            if (n3.path) {
              var a3 = n3.path.lastIndexOf("/");
              a3 >= 0 && (n3.path = n3.path.substring(0, a3 + 1));
            }
            t5 = u2(i2(n3), t5);
          }
          return s2(t5);
        };
      }, 2447: (e22, t4, r3) => {
        t4.SourceMapGenerator = r3(2400).SourceMapGenerator, t4.SourceMapConsumer = r3(8985).SourceMapConsumer, t4.SourceNode = r3(6270).SourceNode;
      }, 6549: (e22, t4, r3) => {
        const n2 = r3(9992), o2 = r3(8528), i2 = r3(541), s2 = (e23) => {
          if (typeof e23 != "string" || e23.length === 0)
            return 0;
          if ((e23 = n2(e23)).length === 0)
            return 0;
          e23 = e23.replace(i2(), "  ");
          let t5 = 0;
          for (let r4 = 0; r4 < e23.length; r4++) {
            const n3 = e23.codePointAt(r4);
            n3 <= 31 || n3 >= 127 && n3 <= 159 || n3 >= 768 && n3 <= 879 || (n3 > 65535 && r4++, t5 += o2(n3) ? 2 : 1);
          }
          return t5;
        };
        e22.exports = s2, e22.exports.default = s2;
      }, 9992: (e22, t4, r3) => {
        const n2 = r3(2426);
        e22.exports = (e23) => typeof e23 == "string" ? e23.replace(n2(), "") : e23;
      }, 3210: (e22, t4, r3) => {
        r3(4070), e22.exports = function(e23, t5, r4) {
          return e23.length === 0 ? e23 : t5 ? (r4 || e23.sort(t5), function(e24, t6) {
            for (var r5 = 1, n2 = e24.length, o2 = e24[0], i2 = e24[0], s2 = 1; s2 < n2; ++s2)
              if (i2 = o2, t6(o2 = e24[s2], i2)) {
                if (s2 === r5) {
                  r5++;
                  continue;
                }
                e24[r5++] = o2;
              }
            return e24.length = r5, e24;
          }(e23, t5)) : (r4 || e23.sort(), function(e24) {
            for (var t6 = 1, r5 = e24.length, n2 = e24[0], o2 = e24[0], i2 = 1; i2 < r5; ++i2, o2 = n2)
              if (o2 = n2, (n2 = e24[i2]) !== o2) {
                if (i2 === t6) {
                  t6++;
                  continue;
                }
                e24[t6++] = n2;
              }
            return e24.length = t6, e24;
          }(e23));
        };
      }, 7933: (e22) => {
        e22.exports = {guessEndOfLine: function(e23) {
          const t4 = e23.indexOf("\r");
          return t4 >= 0 ? e23.charAt(t4 + 1) === "\n" ? "crlf" : "cr" : "lf";
        }, convertEndOfLineToChars: function(e23) {
          switch (e23) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        }, countEndOfLineChars: function(e23, t4) {
          let r3;
          if (t4 === "\n")
            r3 = /\n/g;
          else if (t4 === "\r")
            r3 = /\r/g;
          else {
            if (t4 !== "\r\n")
              throw new Error(`Unexpected "eol" ${JSON.stringify(t4)}.`);
            r3 = /\r\n/g;
          }
          const n2 = e23.match(r3);
          return n2 ? n2.length : 0;
        }, normalizeEndOfLine: function(e23) {
          return e23.replace(/\r\n?/g, "\n");
        }};
      }, 47: (e22) => {
        e22.exports = function(e23, t4) {
          const r3 = new SyntaxError(e23 + " (" + t4.start.line + ":" + t4.start.column + ")");
          return r3.loc = t4, r3;
        };
      }, 9428: (e22, t4, r3) => {
        const n2 = r3(6549), o2 = r3(2240), i2 = r3(4652), {getSupportInfo: s2} = r3(7290), u2 = /[^\x20-\x7F]/;
        function a2(e23) {
          return (t5, r4, n3) => {
            const o3 = n3 && n3.backwards;
            if (r4 === false)
              return false;
            const {length: i3} = t5;
            let s3 = r4;
            for (; s3 >= 0 && s3 < i3; ) {
              const r5 = t5.charAt(s3);
              if (e23 instanceof RegExp) {
                if (!e23.test(r5))
                  return s3;
              } else if (!e23.includes(r5))
                return s3;
              o3 ? s3-- : s3++;
            }
            return (s3 === -1 || s3 === i3) && s3;
          };
        }
        const c2 = a2(/\s/), l2 = a2(" 	"), f2 = a2(",; 	"), p2 = a2(/[^\n\r]/);
        function h2(e23, t5) {
          if (t5 === false)
            return false;
          if (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "*") {
            for (let r4 = t5 + 2; r4 < e23.length; ++r4)
              if (e23.charAt(r4) === "*" && e23.charAt(r4 + 1) === "/")
                return r4 + 2;
          }
          return t5;
        }
        function d2(e23, t5) {
          return t5 !== false && (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "/" ? p2(e23, t5) : t5);
        }
        function D2(e23, t5, r4) {
          const n3 = r4 && r4.backwards;
          if (t5 === false)
            return false;
          const o3 = e23.charAt(t5);
          if (n3) {
            if (e23.charAt(t5 - 1) === "\r" && o3 === "\n")
              return t5 - 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 - 1;
          } else {
            if (o3 === "\r" && e23.charAt(t5 + 1) === "\n")
              return t5 + 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 + 1;
          }
          return t5;
        }
        function g2(e23, t5, r4 = {}) {
          const n3 = l2(e23, r4.backwards ? t5 - 1 : t5, r4);
          return n3 !== D2(e23, n3, r4);
        }
        function m2(e23, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = f2(e23, n3), n3 = h2(e23, n3), n3 = l2(e23, n3);
          return n3 = d2(e23, n3), n3 = D2(e23, n3), n3 !== false && g2(e23, n3);
        }
        function v2(e23, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = l2(e23, n3), n3 = h2(e23, n3), n3 = d2(e23, n3), n3 = D2(e23, n3);
          return n3;
        }
        function y2(e23, t5, r4) {
          return v2(e23, r4(t5));
        }
        function w2(e23, t5, r4 = 0) {
          let n3 = 0;
          for (let o3 = r4; o3 < e23.length; ++o3)
            e23[o3] === "	" ? n3 = n3 + t5 - n3 % t5 : n3++;
          return n3;
        }
        function b2(e23, t5) {
          const r4 = e23.slice(1, -1), n3 = {quote: '"', regex: /"/g}, o3 = {quote: "'", regex: /'/g}, i3 = t5 === "'" ? o3 : n3, s3 = i3 === o3 ? n3 : o3;
          let u3 = i3.quote;
          return (r4.includes(i3.quote) || r4.includes(s3.quote)) && (u3 = (r4.match(i3.regex) || []).length > (r4.match(s3.regex) || []).length ? s3.quote : i3.quote), u3;
        }
        function C2(e23, t5, r4) {
          const n3 = t5 === '"' ? "'" : '"', o3 = e23.replace(/\\(.)|(["'])/gs, (e24, o4, i3) => o4 === n3 ? o4 : i3 === t5 ? "\\" + i3 : i3 || (r4 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o4) ? o4 : "\\" + o4));
          return t5 + o3 + t5;
        }
        function E2(e23, t5) {
          (e23.comments || (e23.comments = [])).push(t5), t5.printed = false, t5.nodeDescription = function(e24) {
            const t6 = e24.type || e24.kind || "(unknown type)";
            let r4 = String(e24.name || e24.id && (typeof e24.id == "object" ? e24.id.name : e24.id) || e24.key && (typeof e24.key == "object" ? e24.key.name : e24.key) || e24.value && (typeof e24.value == "object" ? "" : String(e24.value)) || e24.operator || "");
            return r4.length > 20 && (r4 = r4.slice(0, 19) + "\u2026"), t6 + (r4 ? " " + r4 : "");
          }(e23);
        }
        e22.exports = {inferParserByLanguage: function(e23, t5) {
          const {languages: r4} = s2({plugins: t5.plugins}), n3 = r4.find(({name: t6}) => t6.toLowerCase() === e23) || r4.find(({aliases: t6}) => Array.isArray(t6) && t6.includes(e23)) || r4.find(({extensions: t6}) => Array.isArray(t6) && t6.includes(`.${e23}`));
          return n3 && n3.parsers[0];
        }, getStringWidth: function(e23) {
          return e23 ? u2.test(e23) ? n2(e23) : e23.length : 0;
        }, getMaxContinuousCount: function(e23, t5) {
          const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
          return r4 === null ? 0 : r4.reduce((e24, r5) => Math.max(e24, r5.length / t5.length), 0);
        }, getMinNotPresentContinuousCount: function(e23, t5) {
          const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
          if (r4 === null)
            return 0;
          const n3 = new Map();
          let i3 = 0;
          for (const e24 of r4) {
            const r5 = e24.length / t5.length;
            n3.set(r5, true), r5 > i3 && (i3 = r5);
          }
          for (let e24 = 1; e24 < i3; e24++)
            if (!n3.get(e24))
              return e24;
          return i3 + 1;
        }, getPenultimate: (e23) => e23[e23.length - 2], getLast: i2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: v2, getNextNonSpaceNonCommentCharacterIndex: y2, getNextNonSpaceNonCommentCharacter: function(e23, t5, r4) {
          return e23.charAt(y2(e23, t5, r4));
        }, skip: a2, skipWhitespace: c2, skipSpaces: l2, skipToLineEnd: f2, skipEverythingButNewLine: p2, skipInlineComment: h2, skipTrailingComment: d2, skipNewline: D2, isNextLineEmptyAfterIndex: m2, isNextLineEmpty: function(e23, t5, r4) {
          return m2(e23, r4(t5));
        }, isPreviousLineEmpty: function(e23, t5, r4) {
          let n3 = r4(t5) - 1;
          return n3 = l2(e23, n3, {backwards: true}), n3 = D2(e23, n3, {backwards: true}), n3 = l2(e23, n3, {backwards: true}), n3 !== D2(e23, n3, {backwards: true});
        }, hasNewline: g2, hasNewlineInRange: function(e23, t5, r4) {
          for (let n3 = t5; n3 < r4; ++n3)
            if (e23.charAt(n3) === "\n")
              return true;
          return false;
        }, hasSpaces: function(e23, t5, r4 = {}) {
          return l2(e23, r4.backwards ? t5 - 1 : t5, r4) !== t5;
        }, getAlignmentSize: w2, getIndentSize: function(e23, t5) {
          const r4 = e23.lastIndexOf("\n");
          return r4 === -1 ? 0 : w2(e23.slice(r4 + 1).match(/^[\t ]*/)[0], t5);
        }, getPreferredQuote: b2, printString: function(e23, t5) {
          return C2(e23.slice(1, -1), t5.parser === "json" || t5.parser === "json5" && t5.quoteProps === "preserve" && !t5.singleQuote ? '"' : t5.__isInHtmlAttribute ? "'" : b2(e23, t5.singleQuote ? "'" : '"'), !(t5.parser === "css" || t5.parser === "less" || t5.parser === "scss" || t5.__embeddedInHtml));
        }, printNumber: function(e23) {
          return e23.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        }, makeString: C2, addLeadingComment: function(e23, t5) {
          t5.leading = true, t5.trailing = false, E2(e23, t5);
        }, addDanglingComment: function(e23, t5, r4) {
          t5.leading = false, t5.trailing = false, r4 && (t5.marker = r4), E2(e23, t5);
        }, addTrailingComment: function(e23, t5) {
          t5.leading = false, t5.trailing = true, E2(e23, t5);
        }, isFrontMatterNode: function(e23) {
          return e23 && e23.type === "front-matter";
        }, getShebang: function(e23) {
          if (!e23.startsWith("#!"))
            return "";
          const t5 = e23.indexOf("\n");
          return t5 === -1 ? e23 : e23.slice(0, t5);
        }, isNonEmptyArray: function(e23) {
          return Array.isArray(e23) && e23.length > 0;
        }, createGroupIdMapper: function(e23) {
          const t5 = new WeakMap();
          return function(r4) {
            return t5.has(r4) || t5.set(r4, Symbol(e23)), t5.get(r4);
          };
        }};
      }, 9355: (e22, t4, r3) => {
        const n2 = r3(6920), {getLast: o2, skipEverythingButNewLine: i2} = r3(9428);
        function s2(e23, t5) {
          return typeof e23.sourceIndex == "number" ? e23.sourceIndex : e23.source ? n2(e23.source.start, t5) - 1 : null;
        }
        function u2(e23, t5) {
          if (e23.type === "css-comment" && e23.inline)
            return i2(t5, e23.source.startOffset);
          const r4 = e23.nodes && o2(e23.nodes);
          return r4 && e23.source && !e23.source.end && (e23 = r4), e23.source && e23.source.end ? n2(e23.source.end, t5) : null;
        }
        function a2(e23, t5, r4) {
          e23.source && (e23.source.startOffset = s2(e23, r4) + t5, e23.source.endOffset = u2(e23, r4) + t5);
          for (const n3 in e23) {
            const o3 = e23[n3];
            n3 !== "source" && o3 && typeof o3 == "object" && a2(o3, t5, r4);
          }
        }
        function c2(e23) {
          let t5 = e23.source.startOffset;
          return typeof e23.prop == "string" && (t5 += e23.prop.length), e23.type === "css-atrule" && typeof e23.name == "string" && (t5 += 1 + e23.name.length + e23.raws.afterName.match(/^\s*:?\s*/)[0].length), e23.type !== "css-atrule" && e23.raws && typeof e23.raws.between == "string" && (t5 += e23.raws.between.length), t5;
        }
        e22.exports = {locStart: function(e23) {
          return e23.source.startOffset;
        }, locEnd: function(e23) {
          return e23.source.endOffset;
        }, calculateLoc: function e23(t5, r4) {
          t5.source && (t5.source.startOffset = s2(t5, r4), t5.source.endOffset = u2(t5, r4));
          for (const n3 in t5) {
            const o3 = t5[n3];
            n3 !== "source" && o3 && typeof o3 == "object" && (o3.type === "value-root" || o3.type === "value-unknown" ? a2(o3, c2(t5), o3.text || o3.value) : e23(o3, r4));
          }
        }, replaceQuotesInInlineComments: function(e23) {
          let t5, r4 = "initial", n3 = "initial", o3 = false;
          const i3 = [];
          for (let s3 = 0; s3 < e23.length; s3++) {
            const u3 = e23[s3];
            switch (r4) {
              case "initial":
                if (u3 === "'") {
                  r4 = "single-quotes";
                  continue;
                }
                if (u3 === '"') {
                  r4 = "double-quotes";
                  continue;
                }
                if ((u3 === "u" || u3 === "U") && e23.slice(s3, s3 + 4).toLowerCase() === "url(") {
                  r4 = "url", s3 += 3;
                  continue;
                }
                if (u3 === "*" && e23[s3 - 1] === "/") {
                  r4 = "comment-block";
                  continue;
                }
                if (u3 === "/" && e23[s3 - 1] === "/") {
                  r4 = "comment-inline", t5 = s3 - 1;
                  continue;
                }
                continue;
              case "single-quotes":
                if (u3 === "'" && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                  return e23;
                continue;
              case "double-quotes":
                if (u3 === '"' && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                  return e23;
                continue;
              case "url":
                if (u3 === ")" && (r4 = "initial"), u3 === "\n" || u3 === "\r")
                  return e23;
                if (u3 === "'") {
                  r4 = "single-quotes", n3 = "url";
                  continue;
                }
                if (u3 === '"') {
                  r4 = "double-quotes", n3 = "url";
                  continue;
                }
                continue;
              case "comment-block":
                u3 === "/" && e23[s3 - 1] === "*" && (r4 = "initial");
                continue;
              case "comment-inline":
                u3 !== '"' && u3 !== "'" && u3 !== "*" || (o3 = true), u3 !== "\n" && u3 !== "\r" || (o3 && i3.push([t5, s3]), r4 = "initial", o3 = false);
                continue;
            }
          }
          for (const [t6, r5] of i3)
            e23 = e23.slice(0, t6) + e23.slice(t6, r5).replace(/["'*]/g, " ") + e23.slice(r5);
          return e23;
        }};
      }, 738: (e22, t4, r3) => {
        const n2 = r3(47), o2 = r3(4652), i2 = r3(5115), {hasPragma: s2} = r3(8850), {hasSCSSInterpolation: u2, hasStringOrFunction: a2, isLessParser: c2, isSCSS: l2, isSCSSNestedPropertyNode: f2, isSCSSVariable: p2, stringifyNode: h2, isModuleRuleName: d2} = r3(5244), {locStart: D2, locEnd: g2} = r3(9355), {calculateLoc: m2, replaceQuotesInInlineComments: v2} = r3(9355), y2 = (e23) => {
          for (; e23.parent; )
            e23 = e23.parent;
          return e23;
        };
        function w2(e23, t5) {
          const {nodes: r4} = e23;
          let n3 = {open: null, close: null, groups: [], type: "paren_group"};
          const i3 = [n3], s3 = n3;
          let c3 = {groups: [], type: "comma_group"};
          const f3 = [c3];
          for (let s4 = 0; s4 < r4.length; ++s4) {
            const d3 = r4[s4];
            if (l2(t5.parser, d3.value) && d3.type === "number" && d3.unit === ".." && o2(d3.value) === "." && (d3.value = d3.value.slice(0, -1), d3.unit = "..."), d3.type === "func" && d3.value === "selector" && (d3.group.groups = [A2(y2(e23).text.slice(d3.group.open.sourceIndex + 1, d3.group.close.sourceIndex))]), d3.type === "func" && d3.value === "url") {
              const e24 = d3.group && d3.group.groups || [];
              let t6 = [];
              for (let r5 = 0; r5 < e24.length; r5++) {
                const n4 = e24[r5];
                n4.type === "comma_group" ? t6 = [...t6, ...n4.groups] : t6.push(n4);
              }
              if (u2(t6) || !a2(t6) && !p2(t6[0])) {
                const e25 = h2({groups: d3.group.groups});
                d3.group.groups = [e25.trim()];
              }
            }
            if (d3.type === "paren" && d3.value === "(")
              n3 = {open: d3, close: null, groups: [], type: "paren_group"}, i3.push(n3), c3 = {groups: [], type: "comma_group"}, f3.push(c3);
            else if (d3.type === "paren" && d3.value === ")") {
              if (c3.groups.length > 0 && n3.groups.push(c3), n3.close = d3, f3.length === 1)
                throw new Error("Unbalanced parenthesis");
              f3.pop(), c3 = o2(f3), c3.groups.push(n3), i3.pop(), n3 = o2(i3);
            } else
              d3.type === "comma" ? (n3.groups.push(c3), c3 = {groups: [], type: "comma_group"}, f3[f3.length - 1] = c3) : c3.groups.push(d3);
          }
          return c3.groups.length > 0 && n3.groups.push(c3), s3;
        }
        function b2(e23) {
          return e23.type !== "paren_group" || e23.open || e23.close || e23.groups.length !== 1 ? e23.type === "comma_group" && e23.groups.length === 1 ? b2(e23.groups[0]) : e23.type === "paren_group" || e23.type === "comma_group" ? Object.assign(Object.assign({}, e23), {}, {groups: e23.groups.map(b2)}) : e23 : b2(e23.groups[0]);
        }
        function C2(e23, t5, r4) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const n3 in e23)
              C2(e23[n3], t5, r4), n3 === "type" && typeof e23[n3] == "string" && (e23[n3].startsWith(t5) || r4 && r4.test(e23[n3]) || (e23[n3] = t5 + e23[n3]));
          }
          return e23;
        }
        function E2(e23) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const t5 in e23)
              E2(e23[t5]);
            Array.isArray(e23) || !e23.value || e23.type || (e23.type = "unknown");
          }
          return e23;
        }
        function F2(e23, t5) {
          if (e23 && typeof e23 == "object") {
            for (const r4 in e23)
              r4 !== "parent" && (F2(e23[r4], t5), r4 === "nodes" && (e23.group = b2(w2(e23, t5)), delete e23[r4]));
            delete e23.parent;
          }
          return e23;
        }
        function x2(e23, t5) {
          const n3 = r3(9962);
          let o3 = null;
          try {
            o3 = n3(e23, {loose: true}).parse();
          } catch (e) {
            return {type: "value-unknown", value: e23};
          }
          return o3.text = e23, C2(F2(o3, t5), "value-", /^selector-/);
        }
        function A2(e23) {
          if (/\/\/|\/\*/.test(e23))
            return {type: "selector-unknown", value: e23.trim()};
          const t5 = r3(1264);
          let n3 = null;
          try {
            t5((e24) => {
              n3 = e24;
            }).process(e23);
          } catch (e) {
            return {type: "selector-unknown", value: e23};
          }
          return C2(n3, "selector-");
        }
        function k2(e23) {
          const t5 = r3(8322).Z;
          let n3 = null;
          try {
            n3 = t5(e23);
          } catch (e) {
            return {type: "selector-unknown", value: e23};
          }
          return C2(E2(n3), "media-");
        }
        const O2 = /(\s*?)(!default).*$/, _2 = /(\s*?)(!global).*$/;
        function S2(e23, t5) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const r5 in e23)
              S2(e23[r5], t5);
            if (!e23.type)
              return e23;
            e23.raws || (e23.raws = {});
            let r4 = "";
            typeof e23.selector == "string" && (r4 = e23.raws.selector ? e23.raws.selector.scss ? e23.raws.selector.scss : e23.raws.selector.raw : e23.selector, e23.raws.between && e23.raws.between.trim().length > 0 && (r4 += e23.raws.between), e23.raws.selector = r4);
            let n3 = "";
            typeof e23.value == "string" && (n3 = e23.raws.value ? e23.raws.value.scss ? e23.raws.value.scss : e23.raws.value.raw : e23.value, n3 = n3.trim(), e23.raws.value = n3);
            let o3 = "";
            if (typeof e23.params == "string" && (o3 = e23.raws.params ? e23.raws.params.scss ? e23.raws.params.scss : e23.raws.params.raw : e23.params, e23.raws.afterName && e23.raws.afterName.trim().length > 0 && (o3 = e23.raws.afterName + o3), e23.raws.between && e23.raws.between.trim().length > 0 && (o3 += e23.raws.between), o3 = o3.trim(), e23.raws.params = o3), r4.trim().length > 0)
              return r4.startsWith("@") && r4.endsWith(":") ? e23 : e23.mixin ? (e23.selector = x2(r4, t5), e23) : (f2(e23) && (e23.isSCSSNesterProperty = true), e23.selector = A2(r4), e23);
            if (n3.length > 0) {
              const r5 = n3.match(O2);
              r5 && (n3 = n3.slice(0, r5.index), e23.scssDefault = true, r5[0].trim() !== "!default" && (e23.raws.scssDefault = r5[0]));
              const o4 = n3.match(_2);
              if (o4 && (n3 = n3.slice(0, o4.index), e23.scssGlobal = true, o4[0].trim() !== "!global" && (e23.raws.scssGlobal = o4[0])), n3.startsWith("progid:"))
                return {type: "value-unknown", value: n3};
              e23.value = x2(n3, t5);
            }
            if (c2(t5) && e23.type === "css-decl" && n3.startsWith("extend(") && (e23.extend || (e23.extend = e23.raws.between === ":"), e23.extend && !e23.selector && (delete e23.value, e23.selector = A2(n3.slice("extend(".length, -1)))), e23.type === "css-atrule") {
              if (c2(t5)) {
                if (e23.mixin) {
                  const t6 = e23.raws.identifier + e23.name + e23.raws.afterName + e23.raws.params;
                  return e23.selector = A2(t6), delete e23.params, e23;
                }
                if (e23.function)
                  return e23;
              }
              if (t5.parser === "css" && e23.name === "custom-selector") {
                const t6 = e23.params.match(/:--\S+?\s+/)[0].trim();
                return e23.customSelector = t6, e23.selector = A2(e23.params.slice(t6.length).trim()), delete e23.params, e23;
              }
              if (c2(t5)) {
                if (e23.name.includes(":") && !e23.params) {
                  e23.variable = true;
                  const r5 = e23.name.split(":");
                  e23.name = r5[0], e23.value = x2(r5.slice(1).join(":"), t5);
                }
                if (!["page", "nest", "keyframes"].includes(e23.name) && e23.params && e23.params[0] === ":" && (e23.variable = true, e23.value = x2(e23.params.slice(1), t5), e23.raws.afterName += ":"), e23.variable)
                  return delete e23.params, e23;
              }
            }
            if (e23.type === "css-atrule" && o3.length > 0) {
              const {name: r5} = e23, n4 = e23.name.toLowerCase();
              return r5 === "warn" || r5 === "error" ? (e23.params = {type: "media-unknown", value: o3}, e23) : r5 === "extend" || r5 === "nest" ? (e23.selector = A2(o3), delete e23.params, e23) : r5 === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o3) ? e23.params = x2(o3, t5) : (e23.selector = A2(o3), delete e23.params), e23) : d2(n4) ? (e23.import = true, delete e23.filename, e23.params = x2(o3, t5), e23) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(r5) ? (o3 = o3.replace(/(\$\S+?)\s+?\.{3}/, "$1..."), o3 = o3.replace(/^(?!if)(\S+)\s+\(/, "$1("), e23.value = x2(o3, t5), delete e23.params, e23) : ["media", "custom-media"].includes(n4) ? o3.includes("#{") ? {type: "media-unknown", value: o3} : (e23.params = k2(o3), e23) : (e23.params = o3, e23);
            }
          }
          return e23;
        }
        function T2(e23, t5, r4) {
          const o3 = i2(t5), {frontMatter: s3} = o3;
          let u3;
          t5 = o3.content;
          try {
            u3 = e23(t5);
          } catch (e24) {
            const {name: t6, reason: r5, line: o4, column: i3} = e24;
            if (typeof o4 != "number")
              throw e24;
            throw n2(`${t6}: ${r5}`, {start: {line: o4, column: i3}});
          }
          return u3 = S2(C2(u3, "css-"), r4), m2(u3, t5), s3 && (s3.source = {startOffset: 0, endOffset: s3.raw.length}, u3.nodes.unshift(s3)), u3;
        }
        function I2(e23, t5, n3) {
          const o3 = r3(7371);
          return T2((e24) => o3.parse(v2(e24)), e23, n3);
        }
        function N2(e23, t5, n3) {
          const {parse: o3} = r3(304);
          return T2(o3, e23, n3);
        }
        const M2 = {astFormat: "postcss", hasPragma: s2, locStart: D2, locEnd: g2};
        e22.exports = {parsers: {css: Object.assign(Object.assign({}, M2), {}, {parse: function(e23, t5, r4) {
          const n3 = l2(r4.parser, e23) ? [N2, I2] : [I2, N2];
          let o3;
          for (const i3 of n3)
            try {
              return i3(e23, t5, r4);
            } catch (e24) {
              o3 = o3 || e24;
            }
          if (o3)
            throw o3;
        }}), less: Object.assign(Object.assign({}, M2), {}, {parse: I2}), scss: Object.assign(Object.assign({}, M2), {}, {parse: N2})}};
      }, 8850: (e22, t4, r3) => {
        const n2 = r3(3831), o2 = r3(5115);
        e22.exports = {hasPragma: function(e23) {
          return n2.hasPragma(o2(e23).content);
        }, insertPragma: function(e23) {
          const {frontMatter: t5, content: r4} = o2(e23);
          return (t5 ? t5.raw + "\n\n" : "") + n2.insertPragma(r4);
        }};
      }, 5244: (e22, t4, r3) => {
        const {isNonEmptyArray: n2} = r3(9428), o2 = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), i2 = new Set(["import", "use", "forward"]);
        function s2(e23, t5) {
          const r4 = Array.isArray(t5) ? t5 : [t5];
          let n3, o3 = -1;
          for (; n3 = e23.getParentNode(++o3); )
            if (r4.includes(n3.type))
              return o3;
          return -1;
        }
        function u2(e23, t5) {
          const r4 = s2(e23, t5);
          return r4 === -1 ? null : e23.getParentNode(r4);
        }
        function a2(e23) {
          return e23.type === "value-operator" && e23.value === "*";
        }
        function c2(e23) {
          return e23.type === "value-operator" && e23.value === "/";
        }
        function l2(e23) {
          return e23.type === "value-operator" && e23.value === "+";
        }
        function f2(e23) {
          return e23.type === "value-operator" && e23.value === "-";
        }
        function p2(e23) {
          return e23.type === "value-operator" && e23.value === "%";
        }
        function h2(e23) {
          return e23.type === "value-comma_group" && e23.groups && e23.groups[1] && e23.groups[1].type === "value-colon";
        }
        function d2(e23) {
          return e23.type === "value-paren_group" && e23.groups && e23.groups[0] && h2(e23.groups[0]);
        }
        function D2(e23) {
          return e23 && e23.type === "value-colon";
        }
        e22.exports = {getAncestorCounter: s2, getAncestorNode: u2, getPropOfDeclNode: function(e23) {
          const t5 = u2(e23, "css-decl");
          return t5 && t5.prop && t5.prop.toLowerCase();
        }, hasSCSSInterpolation: function(e23) {
          if (n2(e23)) {
            for (let t5 = e23.length - 1; t5 > 0; t5--)
              if (e23[t5].type === "word" && e23[t5].value === "{" && e23[t5 - 1].type === "word" && e23[t5 - 1].value.endsWith("#"))
                return true;
          }
          return false;
        }, hasStringOrFunction: function(e23) {
          if (n2(e23)) {
            for (let t5 = 0; t5 < e23.length; t5++)
              if (e23[t5].type === "string" || e23[t5].type === "func")
                return true;
          }
          return false;
        }, maybeToLowerCase: function(e23) {
          return e23.includes("$") || e23.includes("@") || e23.includes("#") || e23.startsWith("%") || e23.startsWith("--") || e23.startsWith(":--") || e23.includes("(") && e23.includes(")") ? e23 : e23.toLowerCase();
        }, insideValueFunctionNode: function(e23, t5) {
          const r4 = u2(e23, "value-func");
          return r4 && r4.value && r4.value.toLowerCase() === t5;
        }, insideICSSRuleNode: function(e23) {
          const t5 = u2(e23, "css-rule");
          return t5 && t5.raws && t5.raws.selector && (t5.raws.selector.startsWith(":import") || t5.raws.selector.startsWith(":export"));
        }, insideAtRuleNode: function(e23, t5) {
          const r4 = Array.isArray(t5) ? t5 : [t5], n3 = u2(e23, "css-atrule");
          return n3 && r4.includes(n3.name.toLowerCase());
        }, insideURLFunctionInImportAtRuleNode: function(e23) {
          const t5 = e23.getValue(), r4 = u2(e23, "css-atrule");
          return r4 && r4.name === "import" && t5.groups[0].value === "url" && t5.groups.length === 2;
        }, isKeyframeAtRuleKeywords: function(e23, t5) {
          const r4 = u2(e23, "css-atrule");
          return r4 && r4.name && r4.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t5.toLowerCase());
        }, isWideKeywords: function(e23) {
          return ["initial", "inherit", "unset", "revert"].includes(e23.toLowerCase());
        }, isSCSS: function(e23, t5) {
          return e23 === "less" || e23 === "scss" ? e23 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t5);
        }, isSCSSVariable: function(e23) {
          return Boolean(e23 && e23.type === "word" && e23.value.startsWith("$"));
        }, isLastNode: function(e23, t5) {
          const r4 = e23.getParentNode();
          if (!r4)
            return false;
          const {nodes: n3} = r4;
          return n3 && n3.indexOf(t5) === n3.length - 1;
        }, isLessParser: function(e23) {
          return e23.parser === "css" || e23.parser === "less";
        }, isSCSSControlDirectiveNode: function(e23) {
          return e23.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e23.name);
        }, isDetachedRulesetDeclarationNode: function(e23) {
          return !!e23.selector && (typeof e23.selector == "string" && /^@.+:.*$/.test(e23.selector) || e23.selector.value && /^@.+:.*$/.test(e23.selector.value));
        }, isRelationalOperatorNode: function(e23) {
          return e23.type === "value-word" && ["<", ">", "<=", ">="].includes(e23.value);
        }, isEqualityOperatorNode: function(e23) {
          return e23.type === "value-word" && ["==", "!="].includes(e23.value);
        }, isMultiplicationNode: a2, isDivisionNode: c2, isAdditionNode: l2, isSubtractionNode: f2, isModuloNode: p2, isMathOperatorNode: function(e23) {
          return a2(e23) || c2(e23) || l2(e23) || f2(e23) || p2(e23);
        }, isEachKeywordNode: function(e23) {
          return e23.type === "value-word" && e23.value === "in";
        }, isForKeywordNode: function(e23) {
          return e23.type === "value-word" && ["from", "through", "end"].includes(e23.value);
        }, isURLFunctionNode: function(e23) {
          return e23.type === "value-func" && e23.value.toLowerCase() === "url";
        }, isIfElseKeywordNode: function(e23) {
          return e23.type === "value-word" && ["and", "or", "not"].includes(e23.value);
        }, hasComposesNode: function(e23) {
          return e23.value && e23.value.type === "value-root" && e23.value.group && e23.value.group.type === "value-value" && e23.prop.toLowerCase() === "composes";
        }, hasParensAroundNode: function(e23) {
          return e23.value && e23.value.group && e23.value.group.group && e23.value.group.group.type === "value-paren_group" && e23.value.group.group.open !== null && e23.value.group.group.close !== null;
        }, hasEmptyRawBefore: function(e23) {
          return e23.raws && e23.raws.before === "";
        }, isSCSSNestedPropertyNode: function(e23) {
          return !!e23.selector && e23.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
        }, isDetachedRulesetCallNode: function(e23) {
          return e23.raws && e23.raws.params && /^\(\s*\)$/.test(e23.raws.params);
        }, isTemplatePlaceholderNode: function(e23) {
          return e23.name.startsWith("prettier-placeholder");
        }, isTemplatePropNode: function(e23) {
          return e23.prop.startsWith("@prettier-placeholder");
        }, isPostcssSimpleVarNode: function(e23, t5) {
          return e23.value === "$$" && e23.type === "value-func" && t5 && t5.type === "value-word" && !t5.raws.before;
        }, isKeyValuePairNode: h2, isKeyValuePairInParenGroupNode: d2, isKeyInValuePairNode: function(e23, t5) {
          if (!h2(t5))
            return false;
          const {groups: r4} = t5, n3 = r4.indexOf(e23);
          return n3 !== -1 && D2(r4[n3 + 1]);
        }, isSCSSMapItemNode: function(e23) {
          const t5 = e23.getValue();
          if (t5.groups.length === 0)
            return false;
          const r4 = e23.getParentNode(1);
          if (!(d2(t5) || r4 && d2(r4)))
            return false;
          const n3 = u2(e23, "css-decl");
          return !!(n3 && n3.prop && n3.prop.startsWith("$")) || !!d2(r4) || r4.type === "value-func";
        }, isInlineValueCommentNode: function(e23) {
          return e23.type === "value-comment" && e23.inline;
        }, isHashNode: function(e23) {
          return e23.type === "value-word" && e23.value === "#";
        }, isLeftCurlyBraceNode: function(e23) {
          return e23.type === "value-word" && e23.value === "{";
        }, isRightCurlyBraceNode: function(e23) {
          return e23.type === "value-word" && e23.value === "}";
        }, isWordNode: function(e23) {
          return ["value-word", "value-atword"].includes(e23.type);
        }, isColonNode: D2, isMediaAndSupportsKeywords: function(e23) {
          return e23.value && ["not", "and", "or"].includes(e23.value.toLowerCase());
        }, isColorAdjusterFuncNode: function(e23) {
          return e23.type === "value-func" && o2.has(e23.value.toLowerCase());
        }, lastLineHasInlineComment: function(e23) {
          return /\/\//.test(e23.split(/[\n\r]/).pop());
        }, stringifyNode: function e23(t5) {
          if (t5.groups)
            return (t5.open && t5.open.value ? t5.open.value : "") + t5.groups.reduce((r5, n4, o3) => r5 + e23(n4) + (t5.groups[0].type === "comma_group" && o3 !== t5.groups.length - 1 ? "," : ""), "") + (t5.close && t5.close.value ? t5.close.value : "");
          const r4 = t5.raws && t5.raws.before ? t5.raws.before : "", n3 = t5.raws && t5.raws.quote ? t5.raws.quote : "";
          return r4 + n3 + (t5.type === "atword" ? "@" : "") + (t5.value ? t5.value : "") + n3 + (t5.unit ? t5.unit : "") + (t5.group ? e23(t5.group) : "") + (t5.raws && t5.raws.after ? t5.raws.after : "");
        }, isAtWordPlaceholderNode: function(e23) {
          return e23 && e23.type === "value-atword" && e23.value.startsWith("prettier-placeholder-");
        }, isModuleRuleName: function(e23) {
          return i2.has(e23);
        }};
      }, 3831: (e22, t4, r3) => {
        const {parseWithComments: n2, strip: o2, extract: i2, print: s2} = r3(9234), {getShebang: u2} = r3(9428), {normalizeEndOfLine: a2} = r3(7933);
        function c2(e23) {
          const t5 = u2(e23);
          t5 && (e23 = e23.slice(t5.length + 1));
          const r4 = i2(e23), {pragmas: o3, comments: s3} = n2(r4);
          return {shebang: t5, text: e23, pragmas: o3, comments: s3};
        }
        e22.exports = {hasPragma: function(e23) {
          const t5 = Object.keys(c2(e23).pragmas);
          return t5.includes("prettier") || t5.includes("format");
        }, insertPragma: function(e23) {
          const {shebang: t5, text: r4, pragmas: n3, comments: i3} = c2(e23), u3 = o2(r4), l2 = s2({pragmas: Object.assign({format: ""}, n3), comments: i3.trimStart()});
          return (t5 ? `${t5}
` : "") + a2(l2) + (u3.startsWith("\n") ? "\n" : "\n\n") + u3;
        }};
      }, 8988: (e22, t4, r3) => {
        const {outdent: n2} = r3(5311), o2 = "Config", i2 = "Editor", s2 = "Other", u2 = "Global", a2 = "Special", c2 = {cursorOffset: {since: "1.4.0", category: a2, type: "int", default: -1, range: {start: -1, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: i2}, endOfLine: {since: "1.15.0", category: u2, type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: n2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]}, filepath: {since: "1.4.0", category: a2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: s2, cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: a2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: s2}, parser: {since: "0.0.10", category: u2, type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e23) => typeof e23 == "string" || typeof e23 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "espree", since: "2.2.0", description: "JavaScript"}, {value: "meriyah", since: "2.2.0", description: "JavaScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: "2.3.0", description: "Ember / Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: u2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e23) => typeof e23 == "string" || typeof e23 == "object", cliName: "plugin", cliCategory: o2}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: u2, description: n2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e23) => typeof e23 == "string" || typeof e23 == "object", cliName: "plugin-search-dir", cliCategory: o2}, printWidth: {since: "0.0.0", category: u2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, rangeEnd: {since: "1.4.0", category: a2, type: "int", default: Number.POSITIVE_INFINITY, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2}, rangeStart: {since: "1.4.0", category: a2, type: "int", default: 0, range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}, description: n2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: i2}, requirePragma: {since: "1.7.0", category: a2, type: "boolean", default: false, description: n2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: s2}, tabWidth: {type: "int", category: u2, default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: Number.POSITIVE_INFINITY, step: 1}}, useTabs: {since: "1.0.0", category: u2, type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: u2, type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}};
        e22.exports = {CATEGORY_CONFIG: o2, CATEGORY_EDITOR: i2, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: s2, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: u2, CATEGORY_SPECIAL: a2, options: c2};
      }, 7290: (e22, t4, r3) => {
        const n2 = ["cliName", "cliCategory", "cliDescription"];
        function o2(e23, t5) {
          if (e23 == null)
            return {};
          var r4, n3, o3 = function(e24, t6) {
            if (e24 == null)
              return {};
            var r5, n4, o4 = {}, i4 = Object.keys(e24);
            for (n4 = 0; n4 < i4.length; n4++)
              r5 = i4[n4], t6.indexOf(r5) >= 0 || (o4[r5] = e24[r5]);
            return o4;
          }(e23, t5);
          if (Object.getOwnPropertySymbols) {
            var i3 = Object.getOwnPropertySymbols(e23);
            for (n3 = 0; n3 < i3.length; n3++)
              r4 = i3[n3], t5.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e23, r4) && (o3[r4] = e23[r4]);
          }
          return o3;
        }
        r3(4304), r3(4070), r3(2612);
        const i2 = {compare: r3(2828), lt: r3(3725), gte: r3(9195)}, s2 = r3(9077), u2 = r3(4147).i8, a2 = r3(8988).options;
        e22.exports = {getSupportInfo: function({plugins: e23 = [], showUnreleased: t5 = false, showDeprecated: r4 = false, showInternal: c2 = false} = {}) {
          const l2 = u2.split("-", 1)[0], f2 = e23.flatMap((e24) => e24.languages || []).filter(h2), p2 = s2(Object.assign({}, ...e23.map(({options: e24}) => e24), a2), "name").filter((e24) => h2(e24) && d2(e24)).sort((e24, t6) => e24.name === t6.name ? 0 : e24.name < t6.name ? -1 : 1).map(function(e24) {
            return c2 ? e24 : o2(e24, n2);
          }).map((t6) => {
            t6 = Object.assign({}, t6), Array.isArray(t6.default) && (t6.default = t6.default.length === 1 ? t6.default[0].value : t6.default.filter(h2).sort((e24, t7) => i2.compare(t7.since, e24.since))[0].value), Array.isArray(t6.choices) && (t6.choices = t6.choices.filter((e24) => h2(e24) && d2(e24)), t6.name === "parser" && function(e24, t7, r6) {
              const n3 = new Set(e24.choices.map((e25) => e25.value));
              for (const o3 of t7)
                if (o3.parsers) {
                  for (const t8 of o3.parsers)
                    if (!n3.has(t8)) {
                      n3.add(t8);
                      const i3 = r6.find((e25) => e25.parsers && e25.parsers[t8]);
                      let s3 = o3.name;
                      i3 && i3.name && (s3 += ` (plugin: ${i3.name})`), e24.choices.push({value: t8, description: s3});
                    }
                }
            }(t6, f2, e23));
            const r5 = Object.fromEntries(e23.filter((e24) => e24.defaultOptions && e24.defaultOptions[t6.name] !== void 0).map((e24) => [e24.name, e24.defaultOptions[t6.name]]));
            return Object.assign(Object.assign({}, t6), {}, {pluginDefaults: r5});
          });
          return {languages: f2, options: p2};
          function h2(e24) {
            return t5 || !("since" in e24) || e24.since && i2.gte(l2, e24.since);
          }
          function d2(e24) {
            return r4 || !("deprecated" in e24) || e24.deprecated && i2.lt(l2, e24.deprecated);
          }
        }};
      }, 9077: (e22) => {
        e22.exports = (e23, t4) => Object.entries(e23).map(([e24, r3]) => Object.assign({[t4]: e24}, r3));
      }, 5115: (e22) => {
        const t4 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
        e22.exports = function(e23) {
          const r3 = e23.match(t4);
          if (!r3)
            return {content: e23};
          const {startDelimiter: n2, language: o2, value: i2 = "", endDelimiter: s2} = r3.groups;
          let u2 = o2.trim() || "yaml";
          if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== s2)
            return {content: e23};
          const [a2] = r3;
          return {frontMatter: {type: "front-matter", lang: u2, value: i2, startDelimiter: n2, endDelimiter: s2, raw: a2.replace(/\n$/, "")}, content: a2.replace(/[^\n]/g, " ") + e23.slice(a2.length)};
        };
      }, 4652: (e22) => {
        e22.exports = (e23) => e23[e23.length - 1];
      }, 6920: (e22) => {
        e22.exports = function(e23, t4) {
          let r3 = 0;
          for (let n2 = 0; n2 < e23.line - 1; ++n2)
            r3 = t4.indexOf("\n", r3) + 1;
          return r3 + e23.column;
        };
      }, 8472: () => {
      }, 2868: () => {
      }, 3248: () => {
      }, 6083: () => {
      }, 4940: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, {existsSync: () => n2, readFileSync: () => o2, default: () => i2});
        const n2 = () => false, o2 = () => "", i2 = {existsSync: n2, readFileSync: o2};
      }, 4372: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, {default: () => n2});
        const n2 = {EOL: "\n", platform: () => "browser", cpus: () => [{model: "Prettier"}]};
      }, 3974: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, {default: () => n2});
        var n2 = r3(5724), o2 = {};
        for (const e23 in n2)
          e23 !== "default" && (o2[e23] = () => n2[e23]);
        r3.d(t4, o2);
      }, 4147: (e22) => {
        e22.exports = {i8: "2.4.1"};
      }}, t3 = {};
      function r2(n2) {
        var o2 = t3[n2];
        if (o2 !== void 0)
          return o2.exports;
        var i2 = t3[n2] = {id: n2, loaded: false, exports: {}};
        return e21[n2](i2, i2.exports, r2), i2.loaded = true, i2.exports;
      }
      return r2.d = (e22, t4) => {
        for (var n2 in t4)
          r2.o(t4, n2) && !r2.o(e22, n2) && Object.defineProperty(e22, n2, {enumerable: true, get: t4[n2]});
      }, r2.g = function() {
        if (typeof globalThis == "object")
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e22) {
          if (typeof window == "object")
            return window;
        }
      }(), r2.hmd = (e22) => ((e22 = Object.create(e22)).children || (e22.children = []), Object.defineProperty(e22, "exports", {enumerable: true, set: () => {
        throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e22.id);
      }}), e22), r2.o = (e22, t4) => Object.prototype.hasOwnProperty.call(e22, t4), r2.r = (e22) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e22, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e22, "__esModule", {value: true});
      }, r2(738);
    })();
  }));
  var __decorate$3 = function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$b = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e20) {
          reject(e20);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e20) {
          reject(e20);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  define$9();
  class SCodeExample extends SLitComponent {
    constructor() {
      var _a2;
      super(__deepMerge$6({
        componentUtils: {
          interface: SCodeExampleInterface
        }
      }));
      this._$copy = void 0;
      this._items = [];
      this._activeTabId = void 0;
      const languages = Object.assign({html: xml, javascript, js: javascript, php, bash, shell: bash, css}, (_a2 = this.props.languages) !== null && _a2 !== void 0 ? _a2 : {});
      Object.keys(languages).forEach((lang) => {
        core.registerLanguage(lang, languages[lang]);
      });
    }
    static get properties() {
      return SLitComponent.properties({}, SCodeExampleInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css$6)}
        `;
    }
    firstUpdated() {
      var _a2, _b2, _c2;
      return __awaiter$b(this, void 0, void 0, function* () {
        this.$templates.forEach(($template) => {
          var _a3, _b3, _c3, _d2, _e2, _f2, _g2;
          if (!$template.getAttribute)
            return;
          let parser = "babel";
          switch ((_b3 = (_a3 = $template.getAttribute("id")) !== null && _a3 !== void 0 ? _a3 : $template.getAttribute("language")) !== null && _b3 !== void 0 ? _b3 : $template.getAttribute("lang")) {
            case "html":
            case "xml":
              parser = "html";
              break;
            case "css":
            case "postcss":
              parser = "postcss";
              break;
          }
          let rawCode = decodeHtmlEntities($template.innerHTML);
          let formatedCode = rawCode;
          try {
            formatedCode = VV.format(rawCode, {
              parser,
              plugins: [Ot, Bo, Uu]
            });
          } catch (e20) {
          }
          this._items = [
            ...this._items,
            {
              id: (_e2 = (_d2 = (_c3 = $template.getAttribute("id")) !== null && _c3 !== void 0 ? _c3 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : $template.getAttribute("lang")) !== null && _e2 !== void 0 ? _e2 : "html",
              lang: (_g2 = (_f2 = $template.getAttribute("language")) !== null && _f2 !== void 0 ? _f2 : $template.getAttribute("lang")) !== null && _g2 !== void 0 ? _g2 : "html",
              code: formatedCode
            }
          ];
          $template.remove();
        });
        if (this.active) {
          this.setActiveTab(this.active);
        } else {
          if (this._items[0]) {
            this.setActiveTab(this._items[0].id);
          }
        }
        yield wait(500);
        this._$content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".s-code-example__content");
        this._$pre = (_b2 = this.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector(".s-code-example__code");
        this._$root = (_c2 = this.shadowRoot) === null || _c2 === void 0 ? void 0 : _c2.querySelector(".s-code-example");
        return true;
      });
    }
    setActiveTabByTab(e20) {
      this.setActiveTab(e20.target.id);
    }
    setActiveTab(id2) {
      return __awaiter$b(this, void 0, void 0, function* () {
        yield wait();
        this._activeTabId = id2;
        this.initPrismOnTab(id2);
      });
    }
    setMoreClass() {
      return __awaiter$b(this, void 0, void 0, function* () {
        yield wait(500);
        if (this._more) {
          this._$root.classList.add("s-code-example--more");
        } else {
          this._$root.classList.remove("s-code-example--more");
        }
      });
    }
    toggleMore() {
      this._more = !this._more;
      this.setMoreClass();
    }
    initPrismOnTab(id2) {
      var _a2;
      const $content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`pre#${id2} code`);
      if ($content.hasAttribute("inited")) {
        this.setMoreClass();
        return;
      }
      $content.setAttribute("inited", "true");
      core.highlightElement($content);
      this.setMoreClass();
    }
    copy() {
      const id2 = this._activeTabId;
      const item = this._items.filter((i2) => i2.id === id2)[0];
      this.$copy.copy(item.code);
    }
    render() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      return html$2`
            <div
                class="${this.componentUtils.className()} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.lines}"
                ?mounted="${this.mounted}"
                ?bare="${this.bare}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                <header class="${this.componentUtils.className("__nav")}">
                    <ol class="${this.componentUtils.className("__tabs", "s-tabs")}">
                        ${((_a2 = this._items) !== null && _a2 !== void 0 ? _a2 : []).map((item) => html$2`
                                <li
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${item.id}"
                                    ?active="${this._activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.lang}
                                </li>
                            `)}
                    </ol>
                    ${this.toolbarPosition === "nav" ? html$2`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? html$2`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this._items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
        var _a3, _b3, _c3;
        return html$2`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.lang}"
                                ?active="${this._activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)}"
                            >
                            <code lang="${(_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.lang} ${item.lang} ${this.props.bare ? "" : "hljs"}">${item.code.trim()}</code>
                        </pre>
                        `;
      })}
                    <div class="${this.componentUtils.className("__more-bar")}">
                        ${this._moreAction === "toggle" ? html$2`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn")}"
                                          @click="${this.toggleMore}"
                                      >
                                          ${this._more ? html$2`
                                                        ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                    ` : html$2`
                                                        ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                    `}
                                      </a>
                                  ` : html$2`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                          href="${this._moreAction}"
                                      >
                                          ${this._more ? html$2`
                                                        ${(_f2 = this.props.lessLabel) !== null && _f2 !== void 0 ? _f2 : "Show less"}
                                                    ` : html$2`
                                                        ${(_g2 = this.props.moreLabel) !== null && _g2 !== void 0 ? _g2 : "Show more"}
                                                    `}
                                      </a>
                                  `}                        
                        </a>
                    </div>
                </div>
            </div>
        `;
    }
  }
  __decorate$3([
    property$1()
  ], SCodeExample.prototype, "_items", void 0);
  __decorate$3([
    property$1()
  ], SCodeExample.prototype, "_activeTabId", void 0);
  __decorate$3([
    property$1({
      type: String
    })
  ], SCodeExample.prototype, "active", void 0);
  __decorate$3([
    property$1()
  ], SCodeExample.prototype, "props", void 0);
  __decorate$3([
    query("s-clipboard-copy")
  ], SCodeExample.prototype, "$copy", void 0);
  __decorate$3([
    query(".templates")
  ], SCodeExample.prototype, "$templatesContainer", void 0);
  __decorate$3([
    queryAssignedNodes()
  ], SCodeExample.prototype, "$templates", void 0);
  function define$8(props = {}, tagName = "s-code-example") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SCodeExample);
  }
  function getMethods(toCheck) {
    let props = [];
    let obj = toCheck;
    do {
      const _props = Object.getOwnPropertyNames(obj);
      if (_props.indexOf("__defineGetter__") !== -1)
        continue;
      props = props.concat(_props);
    } while (obj = Object.getPrototypeOf(obj));
    return props.sort().filter(function(e, i, arr) {
      if (e != arr[i + 1] && typeof toCheck[e] == "function")
        return true;
    });
  }
  var __viteBrowserExternal_path = new Proxy({}, {
    get() {
      throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
    }
  });
  var __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": __viteBrowserExternal_path});
  var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_path$1);
  var concatMap$1 = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray$3(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray$3 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  var balancedMatch = balanced$1;
  function balanced$1(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced$1.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  var concatMap = concatMap$1;
  var balanced = balancedMatch;
  var braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand$1(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand$1(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand$1(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand$1(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand$1(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand$1(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand$1(el, false);
      });
    }
    for (var j2 = 0; j2 < N.length; j2++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j2] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  var minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = {sep: "/"};
  try {
    path = require$$0$1;
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = braceExpansion;
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter$2;
  function filter$2(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path.sep !== "/") {
      pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path.sep !== "/") {
      f = f.split(path.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {"this": this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  var ansiRegex$1 = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
  const ansiRegex = ansiRegex$1;
  var stripAnsi$1 = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  function stripAnsi(string) {
    return stripAnsi$1(string);
  }
  function isTestEnv() {
    var _a;
    return ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) === "test";
  }
  function isChildProcess() {
    if (isTestEnv())
      return false;
    return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
  }
  class SLog {
    constructor(logObj) {
      var _a;
      if (!(logObj === null || logObj === void 0 ? void 0 : logObj.value) && !logObj._logObj) {
        throw new Error(`<red>[${this.constructor.name}]</red> Sorry but you cannot instanciate a new SLog without a "<yellow>value</yellow>" property...`);
      }
      this._logObj = __deepMerge$8({
        type: SLog.LOG,
        timestamp: Date.now(),
        decorators: true,
        time: false
      }, this.constructor._defaultLogObj, (_a = logObj._logObj) !== null && _a !== void 0 ? _a : logObj);
    }
    static filter(filterObj, name = "default") {
      this._appliedFilters[name] = filterObj;
    }
    static clearFilters() {
      this._appliedFilters = {};
    }
    static removeFilter(name) {
      delete this._appliedFilters[name];
    }
    static setDefaultLogObj(logObj) {
      this._defaultLogObj = logObj;
    }
    get value() {
      return this._logObj.value;
    }
    set value(value) {
      this._logObj.value = value;
    }
    get type() {
      return this._logObj.type;
    }
    get active() {
      const keys = Object.keys(this.constructor._appliedFilters);
      for (let i = 0; i < keys.length; i++) {
        const filterObj = this.constructor._appliedFilters[keys[i]];
        for (let j2 = 0; j2 < Object.keys(filterObj).length; j2++) {
          const filterId = Object.keys(filterObj)[j2];
          const filterItem = filterObj[filterId];
          if (this[filterId] === void 0) {
            continue;
          }
          if (Array.isArray(filterItem)) {
            if (filterItem.indexOf(this[filterId]) === -1)
              return false;
          } else if (filterItem !== this[filterId]) {
            return false;
          }
        }
      }
      return true;
    }
    get decorators() {
      return this._logObj.decorators;
    }
    set decorators(value) {
      this._logObj.decorators = value;
    }
    get time() {
      return this._logObj.time;
    }
    get timestamp() {
      return this._logObj.timestamp;
    }
    get clear() {
      return this._logObj.clear;
    }
    get temp() {
      return this._logObj.temp;
    }
    get as() {
      return this._logObj.as;
    }
  }
  SLog.LOG = 0;
  SLog.INFO = 1;
  SLog.WARN = 2;
  SLog.ERROR = 3;
  SLog.VERBOSE = 4;
  SLog.CHILD_PROCESS = 5;
  SLog._appliedFilters = {};
  SLog._defaultLogObj = {};
  var __awaiter$a = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SEventEmitter extends SClass {
    constructor(settings = {}) {
      super(__deepMerge$8({
        eventEmitter: {
          emitter: void 0,
          asyncStart: false,
          defaultCallTime: {},
          bufferTimeout: 1e3,
          bufferedEvents: [],
          forceObject: ["log"],
          defaults: {},
          castByEvent: {
            log: SLog
          },
          bind: void 0
        }
      }, settings || {}));
      this._asyncStarted = false;
      this._buffer = [];
      this._eventsStacks = {};
      this._onStackById = {};
    }
    static get global() {
      if (!this._globalInstance) {
        this._globalInstance = new SEventEmitter({
          metas: {
            id: "sugarEventSPromise"
          }
        });
      }
      return this._globalInstance;
    }
    static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
      const set = Object.assign({events: "*", prefixEvent: false, prefixValue: void 0, stripAnsi: false, trim: true, keepLineBreak: true, overrideEmitter: "bind", processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0}, settings !== null && settings !== void 0 ? settings : {});
      if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function")
        return sourceSEventEmitter;
      sourceSEventEmitter.on(set.events || "*", (value, metas) => __awaiter$a(this, void 0, void 0, function* () {
        var _a, _b;
        if (!metas) {
          return;
        }
        if (set.exclude && set.exclude.indexOf(metas.event) !== -1)
          return;
        if (set.filter && !set.filter(value, metas))
          return;
        if (set.stripAnsi) {
          if (value && value.value && typeof value.value === "string")
            value.value = stripAnsi(value.value);
          else if (typeof value === "string")
            value = stripAnsi(value);
        }
        if (set.trim) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.trim();
          else if (typeof value === "string")
            value = value.trim();
        }
        if (set.keepLineBreak === false) {
          if (value && value.value && typeof value.value === "string")
            value.value = value.value.replace(/\r?\n|\r/g, "");
          else if (typeof value === "string")
            value = value.replace(/\r?\n|\r/g, "");
        }
        if (set.processor) {
          const res = set.processor(value, metas);
          if (Array.isArray(res) && res.length === 2) {
            value = res[0];
            metas = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            value = res.value;
            metas = res.metas;
          } else {
            value = res;
          }
        }
        if (set.prefixValue) {
          if (value && value.value && typeof value.value === "string") {
            value.value = `${set.prefixValue}${value.value}`;
          } else if (typeof value === "string") {
            value = `${set.prefixValue}${value}`;
          }
        }
        if (metas && metas.event) {
          let emitStack = metas.event;
          if (!metas.emitter) {
            metas.emitter = this;
          }
          if (set.prefixEvent) {
            if (typeof set.prefixEvent === "string") {
              emitStack = `${set.prefixEvent}.${metas.event}`;
            } else {
              emitStack = `${metas.name}`;
            }
            metas.event = emitStack;
          }
          const emitMetas = Object.assign(Object.assign({}, metas), {level: ((_a = metas === null || metas === void 0 ? void 0 : metas.level) !== null && _a !== void 0 ? _a : 0) + 1});
          if (destSEventEmitter instanceof SEventEmitter) {
            if (set.overrideEmitter === "bind" && destSEventEmitter.eventEmitterSettings.bind) {
              emitMetas.emitter = destSEventEmitter.eventEmitterSettings.bind;
            } else if (set.overrideEmitter === true) {
              emitMetas.emitter = destSEventEmitter;
            }
          }
          if (destSEventEmitter === process && isChildProcess() && process.send) {
            if (value.value && value.value instanceof Error) {
              value.value = fn$6(value.value);
            }
            if ((_b = value.metas) === null || _b === void 0 ? void 0 : _b.event)
              delete value.metas;
            process.send({
              value,
              metas: emitMetas
            });
          } else {
            destSEventEmitter.emit(metas.event, value, emitMetas);
          }
        }
      }));
    }
    get eventEmitterSettings() {
      return this._settings.eventEmitter;
    }
    pipe(input, settings) {
      SEventEmitter.pipe(input, this, settings);
      return input;
    }
    pipeErrors(input, settings) {
      SEventEmitter.pipe(input, this, Object.assign(Object.assign({}, settings), {events: "error"}));
      return input;
    }
    pipeFrom(input, settings) {
      return this.pipe(input, settings);
    }
    pipeTo(dest, settings) {
      SEventEmitter.pipe(this, dest, settings);
      return this;
    }
    start() {
      if (!this.eventEmitterSettings.asyncStart)
        return;
      this._asyncStarted = true;
      this._processBuffer();
    }
    _createMetas(event, metas = {}) {
      var _a, _b, _c;
      return __deepMerge$8({
        event,
        name: event,
        emitter: (_b = (_a = this.eventEmitterSettings.bind) !== null && _a !== void 0 ? _a : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b !== void 0 ? _b : this,
        originalEmitter: (_c = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c !== void 0 ? _c : this,
        time: Date.now(),
        level: 0,
        id: uniqid()
      }, metas !== null && metas !== void 0 ? metas : {});
    }
    emit(event, value, metas) {
      return new Promise((resolve, reject) => __awaiter$a(this, void 0, void 0, function* () {
        let metasObj = this._createMetas(event, metas);
        const isFirstLevel = !metasObj.level;
        if (plainObject$8(value)) {
          Object.keys(this.eventEmitterSettings.defaults).forEach((key) => {
            var _a;
            const parts = key.split(",").map((l) => l.trim());
            if (parts.indexOf(event) === -1 && parts.indexOf("*") === -1)
              return;
            value = __deepMerge$8(value, (_a = this.eventEmitterSettings.defaults) === null || _a === void 0 ? void 0 : _a[key]);
          });
        }
        const CastClass = this.eventEmitterSettings.castByEvent[event];
        if (CastClass && cls(CastClass) && !(value instanceof CastClass) && !value._sEventEmitterPreprocessed) {
          value = new CastClass(value);
        }
        if (event === "ask") {
          if (isFirstLevel) {
            metasObj.askId = uniqid();
          }
        }
        if (!this._asyncStarted && this.eventEmitterSettings.asyncStart) {
          this._buffer.push({
            event,
            value,
            metas: metasObj,
            resolve,
            reject
          });
          return;
        }
        this._emit({
          event,
          value,
          metas: metasObj,
          resolve,
          reject
        });
      }));
    }
    _emit(logObj) {
      return __awaiter$a(this, void 0, void 0, function* () {
        if (logObj.event === "ask") {
          this.constructor.global.on(`answer.${logObj.metas.askId}:1`, (answer, metas) => {
            logObj.resolve(answer);
          });
          this._emitEvents(logObj.event, logObj.value, logObj.metas);
        } else {
          const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
          logObj.resolve(res);
        }
      });
    }
    _registerNewEventsStacks(events) {
      if (typeof events === "string")
        events = events.split(",").map((s) => s.trim());
      events.forEach((event) => {
        if (!this._eventsStacks[event]) {
          this._eventsStacks[event] = {
            buffer: [],
            callStack: []
          };
        }
      });
    }
    _registerCallbackInEventStack(event, callback, settings = {}) {
      settings = Object.assign({callNumber: void 0, filter: void 0, processor: void 0, id: void 0}, settings);
      if (settings.id) {
        if (!this._onStackById[settings.id])
          this._onStackById[settings.id] = [];
        this._onStackById[settings.id].push({
          event,
          callback,
          settings
        });
      }
      if (!this._eventsStacks[event]) {
        this._registerNewEventsStacks(event);
      }
      const eventStackObj = this._eventsStacks[event];
      let callNumber = settings.callNumber;
      if (callNumber === void 0 && this.eventEmitterSettings.defaultCallTime[event] !== void 0) {
        callNumber = this.eventEmitterSettings.defaultCallTime[event];
      } else if (callNumber === void 0) {
        callNumber = -1;
      }
      if (typeof callback === "function")
        eventStackObj.callStack.push({
          callback,
          callNumber,
          filter: settings.filter,
          processor: settings.processor,
          called: 0
        });
      this._processBuffer();
      return this;
    }
    _processBuffer() {
      if (this._buffer.length > 0) {
        setTimeout(() => {
          this._buffer = this._buffer.filter((item) => {
            this._emit(item);
            return false;
          });
        }, this.eventEmitterSettings.bufferTimeout);
      }
    }
    _emitEventStack(event, initialValue, metasObj) {
      return __awaiter$a(this, void 0, void 0, function* () {
        let currentCallbackReturnedValue = initialValue;
        if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
          return currentCallbackReturnedValue;
        if (!this._eventsStacks[event]) {
          this._registerNewEventsStacks(event);
        }
        let eventStackArray = [];
        const eventStackObj = this._eventsStacks[event];
        if (eventStackObj && eventStackObj.callStack) {
          eventStackArray = [
            ...eventStackArray,
            ...eventStackObj.callStack
          ];
        }
        Object.keys(this._eventsStacks).forEach((stackName) => {
          if (stackName === event)
            return currentCallbackReturnedValue;
          if (minimatch_1(event, stackName) && this._eventsStacks[stackName] !== void 0) {
            eventStackArray = [
              ...eventStackArray,
              ...this._eventsStacks[stackName].callStack
            ];
          }
        });
        eventStackArray.map((item) => item.called++);
        eventStackArray = eventStackArray.filter((item) => {
          if (item.callNumber === -1)
            return true;
          if (item.called <= item.callNumber)
            return true;
          return false;
        });
        for (let i = 0; i < eventStackArray.length; i++) {
          const item = eventStackArray[i];
          if (!item.callback)
            return currentCallbackReturnedValue;
          if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
            continue;
          if (item.processor) {
            const res = item.processor(currentCallbackReturnedValue, metasObj);
            if (Array.isArray(res) && res.length === 2) {
              currentCallbackReturnedValue = res[0];
              metasObj = res[1];
            } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
              currentCallbackReturnedValue = res.value;
              metasObj = res.metas;
            } else {
              currentCallbackReturnedValue = res;
            }
          }
          const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj, (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId) ? (answer) => {
            this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
          } : void 0);
          if (callbackResult !== void 0) {
            currentCallbackReturnedValue = callbackResult;
          }
        }
        return currentCallbackReturnedValue;
      });
    }
    _emitEvents(events, initialValue, metas) {
      return new Promise((resolve, reject) => __awaiter$a(this, void 0, void 0, function* () {
        if (!events)
          return this;
        if (typeof events === "string")
          events = events.split(",").map((s) => s.trim());
        let currentStackResult = initialValue;
        for (let i = 0; i < events.length; i++) {
          const stackResult = yield this._emitEventStack(events[i], currentStackResult, metas);
          if (stackResult !== void 0) {
            currentStackResult = stackResult;
          }
        }
        resolve(currentStackResult);
      }));
    }
    on(events, callback, settings) {
      const set = __deepMerge$8({
        filter: void 0,
        processor: void 0,
        id: void 0
      }, settings);
      if (typeof events === "string")
        events = events.split(",").map((s) => s.trim());
      events.forEach((name) => {
        const splitedName = name.split(":");
        let callNumber = -1;
        if (splitedName.length === 2) {
          name = splitedName[0];
          callNumber = parseInt(splitedName[1]);
        }
        this._registerCallbackInEventStack(name, callback, {
          callNumber,
          filter: set.filter,
          processor: set.processor,
          id: set.id
        });
      });
      return this;
    }
    off(event, callback) {
      if (!callback) {
        if (this._eventsStacks[event]) {
          delete this._eventsStacks[event];
        } else if (this._onStackById[event]) {
          this._onStackById[event].forEach((onStackByIdObj) => {
            this.off(onStackByIdObj.event, onStackByIdObj.callback);
          });
          delete this._onStackById[event];
        }
        return this;
      }
      const eventStackObj = this._eventsStacks[event];
      if (!eventStackObj)
        return this;
      eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
        if (item.callback === callback)
          return false;
        return true;
      });
      this._eventsStacks[event] = eventStackObj;
      return this;
    }
    destroy() {
      this._eventsStacks = {};
    }
  }
  SEventEmitter.usableAsMixin = true;
  function plainObject$5(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$5(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$5(newObj[key]) && plainObject$5(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  const fn = function treatAsValue(promise, settings = {}) {
    settings = Object.assign({during: -1}, settings);
    let during = settings.during || -1;
    try {
      const proxy = Proxy.revocable(promise, {
        get(target, prop, receiver) {
          if (prop === "then") {
            return target;
          }
          if (during > 0)
            during--;
          else if (during === 0) {
            proxy.revoke();
          }
          return Reflect.get(...arguments);
        }
      });
      proxy.proxy.restorePromiseBehavior = () => {
        proxy.revoke();
        return promise;
      };
      return proxy.proxy;
    } catch (e) {
      return promise;
    }
  };
  var __awaiter$9 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SPromise extends SClass.extends(Promise) {
    constructor(executorFnOrSettings = {}, settings) {
      let executorFn, resolvers = {};
      super(__deepMerge$5({
        promise: {
          treatCancelAs: "resolve",
          destroyTimeout: 1,
          preventRejectOnThrow: true,
          emitErrorEventOnThrow: true,
          resolveAtResolveEvent: false,
          rejectAtRejectEvent: false,
          proxies: {
            resolve: [],
            reject: []
          }
        }
      }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve, reject) => {
        resolvers.resolve = resolve;
        new Promise((rejectPromiseResolve, rejectPromiseReject) => {
          resolvers.reject = (...args) => {
            rejectPromiseReject(...args);
            if (this.promiseSettings.preventRejectOnThrow) {
              resolve(...args);
            } else {
              reject(...args);
            }
          };
        }).catch((e) => {
          this.emit("catch", e);
        });
      });
      this._promiseState = "pending";
      this._eventEmitter = new SEventEmitter(__deepMerge$5({
        metas: this.metas,
        eventEmitter: {}
      }, this._settings));
      this.expose(this._eventEmitter, {
        as: "eventEmitter",
        props: [
          "on",
          "off",
          "emit",
          "pipe",
          "pipeErrors",
          "pipeFrom",
          "pipeTo",
          "eventEmitterSettings"
        ]
      });
      this._resolvers = resolvers;
      if (this._settings.promise.destroyTimeout !== -1) {
        this.on("finally", (v, m) => {
          setTimeout(() => {
            this.destroy();
          }, this._settings.promise.destroyTimeout);
        });
      }
      executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
      if (executorFn) {
        const api = {};
        getMethods(this).forEach((func) => {
          if (func.slice(0, 1) === "_")
            return;
          api[func] = this[func].bind(this);
        });
        (() => __awaiter$9(this, void 0, void 0, function* () {
          yield wait$1(0);
          try {
            yield executorFn(api);
          } catch (e) {
            if (this.promiseSettings.emitErrorEventOnThrow) {
              this.emit("log", {
                type: SLog.ERROR,
                value: e
              });
            }
            this.reject(e);
          }
        }))();
      }
      if (this.promiseSettings.resolveAtResolveEvent) {
        this.on("resolve", (data, metas) => {
          this.resolve(data);
        });
      }
      if (this.promiseSettings.rejectAtRejectEvent) {
        this.on("reject", (data, metas) => {
          this.reject(data);
        });
      }
    }
    static treatAsValue(promise, settings = {}) {
      return fn(promise, settings);
    }
    get promiseSettings() {
      return this._settings.promise;
    }
    static get [Symbol.species]() {
      return Promise;
    }
    get [Symbol.toStringTag]() {
      return "SPromise";
    }
    get promiseState() {
      return this._promiseState;
    }
    treatAsValue(settings = {}) {
      return fn(this, settings);
    }
    registerProxy(point, proxy) {
      const ar = point.split(",").map((l) => l.trim());
      ar.forEach((a) => {
        this._settings.promise.proxies[a].push(proxy);
      });
    }
    is(status) {
      const statusArray = status.split(",").map((l) => l.trim());
      if (statusArray.indexOf(this._promiseState) !== -1)
        return true;
      return false;
    }
    isPending() {
      return this._promiseState === "pending";
    }
    isResolved() {
      return this._promiseState === "resolved";
    }
    isRejected() {
      return this._promiseState === "rejected";
    }
    isCanceled() {
      return this._promiseState === "canceled";
    }
    isDestroyed() {
      return this._promiseState === "destroyed";
    }
    resolve(arg, stacksOrder = "resolve,finally") {
      return this._resolve(arg, stacksOrder);
    }
    _resolve(arg, stacksOrder = "resolve,finally") {
      return __awaiter$9(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "resolved";
        const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
        for (let i = 0; i < stacksOrderArray.length; i++) {
          const stack = stacksOrderArray[i];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        for (const proxyFn of this._settings.promise.proxies.resolve || []) {
          arg = yield proxyFn(arg);
        }
        this._resolvers.resolve(arg);
        return arg;
      });
    }
    reject(arg, stacksOrder = `catch,reject,finally`) {
      return this._reject(arg, stacksOrder);
    }
    _reject(arg, stacksOrder = `catch,reject,finally`) {
      return __awaiter$9(this, void 0, void 0, function* () {
        if (this._promiseState === "destroyed")
          return;
        this._promiseState = "rejected";
        const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
        for (let i = 0; i < stacksOrderArray.length; i++) {
          const stack = stacksOrderArray[i];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        for (const proxyFn of this._settings.promise.proxies.reject || []) {
          arg = yield proxyFn(arg);
        }
        this._resolvers.reject(arg);
        return arg;
      });
    }
    cancel(arg, stacksOrder = "cancel,finally") {
      return this._cancel(arg, stacksOrder);
    }
    _cancel(arg, stacksOrder = "cancel,finally") {
      if (this._promiseState === "destroyed")
        return;
      return new Promise((resolve, reject) => __awaiter$9(this, void 0, void 0, function* () {
        this._promiseState = "canceled";
        const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
        for (let i = 0; i < stacksOrderArray.length; i++) {
          const stack = stacksOrderArray[i];
          arg = yield this.eventEmitter.emit(stack, arg);
        }
        if (this._settings.promise.treatCancelAs === "reject") {
          this._resolvers.reject(arg);
        } else {
          this._resolvers.resolve(arg);
        }
        resolve(arg);
      }));
    }
    catch(...args) {
      super.catch(...args);
      return this.on("catch", ...args);
    }
    finally(...args) {
      return this.on("finally", ...args);
    }
    destroy() {
      this._eventEmitter.destroy();
      this._promiseState = "destroyed";
    }
  }
  function plainObject$4(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$4(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$4(newObj[key]) && plainObject$4(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const standardProperty = (options, element) => {
    if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
      return __spreadProps(__spreadValues({}, element), {
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      return {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: element.key,
        initializer() {
          if (typeof element.initializer === "function") {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };
  const legacyProperty = (options, proto, name) => {
    proto.constructor.createProperty(name, options);
  };
  function property(options) {
    return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
  }
  class SSidePanelComponentInterface extends SInterface {
  }
  SSidePanelComponentInterface.definition = {
    side: {
      type: "String",
      values: ["top", "left", "bottom", "right"],
      default: "left"
    },
    active: {
      type: "Boolean",
      default: false
    },
    overlay: {
      type: "Boolean",
      default: false
    },
    triggerer: {
      type: "String"
    },
    closeOn: {
      type: {
        type: "Array<String>",
        splitChars: [","]
      },
      values: ["click", "escape"],
      default: ["click", "escape"]
    }
  };
  /*!
  * hotkeys-js v3.8.5
  * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
  * 
  * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
  * http://jaywcjlove.github.io/hotkeys
  * 
  * Licensed under the MIT license.
  */
  var isff$1 = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent$1(object, event, method) {
    if (object.addEventListener) {
      object.addEventListener(event, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event), function() {
        method(window.event);
      });
    }
  }
  function getMods$1(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i = 0; i < mods.length; i++) {
      mods[i] = modifier[mods[i].toLowerCase()];
    }
    return mods;
  }
  function getKeys$1(key) {
    if (typeof key !== "string")
      key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index = keys.lastIndexOf("");
    for (; index >= 0; ) {
      keys[index - 1] += ",";
      keys.splice(index, 1);
      index = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray$1(a1, a2) {
    var arr1 = a1.length >= a2.length ? a1 : a2;
    var arr2 = a1.length >= a2.length ? a2 : a1;
    var isIndex = true;
    for (var i = 0; i < arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) === -1)
        isIndex = false;
    }
    return isIndex;
  }
  var _keyMap$1 = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff$1 ? 173 : 189,
    "=": isff$1 ? 61 : 187,
    ";": isff$1 ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier$1 = {
    "\u21E7": 16,
    shift: 16,
    "\u2325": 18,
    alt: 18,
    option: 18,
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap$1 = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods$1 = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers$1 = {};
  for (var k$1 = 1; k$1 < 20; k$1++) {
    _keyMap$1["f".concat(k$1)] = 111 + k$1;
  }
  var _downKeys$1 = [];
  var _scope$1 = "all";
  var elementHasBindEvent$1 = [];
  var code$1 = function code2(x) {
    return _keyMap$1[x.toLowerCase()] || _modifier$1[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
  };
  function setScope$1(scope) {
    _scope$1 = scope || "all";
  }
  function getScope$1() {
    return _scope$1 || "all";
  }
  function getPressedKeyCodes$1() {
    return _downKeys$1.slice(0);
  }
  function filter$1(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag = false;
    }
    return flag;
  }
  function isPressed$1(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code$1(keyCode);
    }
    return _downKeys$1.indexOf(keyCode) !== -1;
  }
  function deleteScope$1(scope, newScope) {
    var handlers;
    var i;
    if (!scope)
      scope = getScope$1();
    for (var key in _handlers$1) {
      if (Object.prototype.hasOwnProperty.call(_handlers$1, key)) {
        handlers = _handlers$1[key];
        for (i = 0; i < handlers.length; ) {
          if (handlers[i].scope === scope)
            handlers.splice(i, 1);
          else
            i++;
        }
      }
    }
    if (getScope$1() === scope)
      setScope$1(newScope || "all");
  }
  function clearModifier$1(event) {
    var key = event.keyCode || event.which || event.charCode;
    var i = _downKeys$1.indexOf(key);
    if (i >= 0) {
      _downKeys$1.splice(i, 1);
    }
    if (event.key && event.key.toLowerCase() === "meta") {
      _downKeys$1.splice(0, _downKeys$1.length);
    }
    if (key === 93 || key === 224)
      key = 91;
    if (key in _mods$1) {
      _mods$1[key] = false;
      for (var k in _modifier$1) {
        if (_modifier$1[k] === key)
          hotkeys$1[k] = false;
      }
    }
  }
  function unbind$1(keysInfo) {
    if (!keysInfo) {
      Object.keys(_handlers$1).forEach(function(key) {
        return delete _handlers$1[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key)
          eachUnbind$1(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key)
        eachUnbind$1(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var scope = args[0], method = args[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind$1({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind$1 = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys$1(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code$1(lastKey);
      if (!_handlers$1[keyCode])
        return;
      if (!scope)
        scope = getScope$1();
      var mods = len > 1 ? getMods$1(_modifier$1, unbindKeys) : [];
      _handlers$1[keyCode] = _handlers$1[keyCode].map(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        if (isMatchingMethod && record.scope === scope && compareArray$1(record.mods, mods)) {
          return {};
        }
        return record;
      });
    });
  };
  function eventHandler$1(event, handler, scope) {
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y in _mods$1) {
        if (Object.prototype.hasOwnProperty.call(_mods$1, y)) {
          if (!_mods$1[y] && handler.mods.indexOf(+y) > -1 || _mods$1[y] && handler.mods.indexOf(+y) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods$1[16] && !_mods$1[18] && !_mods$1[17] && !_mods$1[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault)
            event.preventDefault();
          else
            event.returnValue = false;
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.cancelBubble)
            event.cancelBubble = true;
        }
      }
    }
  }
  function dispatch$1(event) {
    var asterisk = _handlers$1["*"];
    var key = event.keyCode || event.which || event.charCode;
    if (!hotkeys$1.filter.call(this, event))
      return;
    if (key === 93 || key === 224)
      key = 91;
    if (_downKeys$1.indexOf(key) === -1 && key !== 229)
      _downKeys$1.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap$1[keyName];
      if (event[keyName] && _downKeys$1.indexOf(keyNum) === -1) {
        _downKeys$1.push(keyNum);
      } else if (!event[keyName] && _downKeys$1.indexOf(keyNum) > -1) {
        _downKeys$1.splice(_downKeys$1.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event[keyName] && _downKeys$1.length === 3) {
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys$1 = _downKeys$1.slice(_downKeys$1.indexOf(keyNum));
        }
      }
    });
    if (key in _mods$1) {
      _mods$1[key] = true;
      for (var k in _modifier$1) {
        if (_modifier$1[k] === key)
          hotkeys$1[k] = true;
      }
      if (!asterisk)
        return;
    }
    for (var e in _mods$1) {
      if (Object.prototype.hasOwnProperty.call(_mods$1, e)) {
        _mods$1[e] = event[modifierMap$1[e]];
      }
    }
    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
      if (_downKeys$1.indexOf(17) === -1) {
        _downKeys$1.push(17);
      }
      if (_downKeys$1.indexOf(18) === -1) {
        _downKeys$1.push(18);
      }
      _mods$1[17] = true;
      _mods$1[18] = true;
    }
    var scope = getScope$1();
    if (asterisk) {
      for (var i = 0; i < asterisk.length; i++) {
        if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
          eventHandler$1(event, asterisk[i], scope);
        }
      }
    }
    if (!(key in _handlers$1))
      return;
    for (var _i = 0; _i < _handlers$1[key].length; _i++) {
      if (event.type === "keydown" && _handlers$1[key][_i].keydown || event.type === "keyup" && _handlers$1[key][_i].keyup) {
        if (_handlers$1[key][_i].key) {
          var record = _handlers$1[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a = 0; a < keyShortcut.length; a++) {
            _downKeysCurrent.push(code$1(keyShortcut[a]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys$1.sort().join("")) {
            eventHandler$1(event, record, scope);
          }
        }
      }
    }
  }
  function isElementBind$1(element) {
    return elementHasBindEvent$1.indexOf(element) > -1;
  }
  function hotkeys$1(key, option, method) {
    _downKeys$1 = [];
    var keys = getKeys$1(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope)
        scope = option.scope;
      if (option.element)
        element = option.element;
      if (option.keyup)
        keyup = option.keyup;
      if (option.keydown !== void 0)
        keydown = option.keydown;
      if (typeof option.splitKey === "string")
        splitKey = option.splitKey;
    }
    if (typeof option === "string")
      scope = option;
    for (; i < keys.length; i++) {
      key = keys[i].split(splitKey);
      mods = [];
      if (key.length > 1)
        mods = getMods$1(_modifier$1, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code$1(key);
      if (!(key in _handlers$1))
        _handlers$1[key] = [];
      _handlers$1[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i],
        method,
        key: keys[i],
        splitKey
      });
    }
    if (typeof element !== "undefined" && !isElementBind$1(element) && window) {
      elementHasBindEvent$1.push(element);
      addEvent$1(element, "keydown", function(e) {
        dispatch$1(e);
      });
      addEvent$1(window, "focus", function() {
        _downKeys$1 = [];
      });
      addEvent$1(element, "keyup", function(e) {
        dispatch$1(e);
        clearModifier$1(e);
      });
    }
  }
  var _api$1 = {
    setScope: setScope$1,
    getScope: getScope$1,
    deleteScope: deleteScope$1,
    getPressedKeyCodes: getPressedKeyCodes$1,
    isPressed: isPressed$1,
    filter: filter$1,
    unbind: unbind$1
  };
  for (var a$1 in _api$1) {
    if (Object.prototype.hasOwnProperty.call(_api$1, a$1)) {
      hotkeys$1[a$1] = _api$1[a$1];
    }
  }
  if (typeof window !== "undefined") {
    var _hotkeys$1 = window.hotkeys;
    hotkeys$1.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys$1) {
        window.hotkeys = _hotkeys$1;
      }
      return hotkeys$1;
    };
    window.hotkeys = hotkeys$1;
  }
  var hotkeys_common$1 = hotkeys$1;
  hotkeys_common$1.filter = function() {
    return true;
  };
  function hotkey$1(hotkey2, settings = {}) {
    return new SPromise(({resolve, reject, emit, cancel}) => {
      settings = Object.assign({element: null, keyup: false, keydown: true, once: false, splitKey: "+"}, settings);
      hotkeys_common$1(hotkey2, settings, (e, h) => {
        emit("press", e);
        if (settings.once)
          cancel();
      });
    }, {
      id: "hotkey"
    }).on("finally", () => {
      hotkeys_common$1.unbind(hotkey2);
    });
  }
  var __css$5 = "s-side-panel {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 9999;\n    pointer-events: none;\n}\n\n    s-side-panel[active] {\n        pointer-events: all;\n    }\n\n    s-side-panel:not([mounted]) > * {\n        display: none;\n    }\n\n.s-side-panel__overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n    width: 100%;\n    height: 100%;\n}\n\n[default-style] .s-side-panel__overlay {\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-lightness-offset, 0)) * 1%),var(--s-theme-color-main-a, 0.3));\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n        opacity: 0;\n    }\n\n[default-style][active] .s-side-panel__overlay {\n        opacity: 1;\n    }\n\n.s-side-panel__container {\n    display: none;\n    position: absolute;\n    z-index: 1;\n}\n\n[mounted] .s-side-panel__container {\n        display: block;\n    }\n\n[default-style] .s-side-panel__container {\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n[side='left'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        height: 100%;\n        transform: translateX(-100%);\n    }\n\n[side='top'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(-100%);\n    }\n\n[side='right'] .s-side-panel__container {\n        right: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        transform: translateX(100%);\n    }\n\n[side='bottom'] .s-side-panel__container {\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(100%);\n    }\n\n[active] .s-side-panel__container {\n        transform: translateX(0) translateY(0);\n    }\n\n.s-side-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n.s-side-panel[active] {\n        pointer-events: all;\n    }\n";
  var __decorate$2 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  class SSidePanel extends SLitComponent {
    constructor() {
      super(__deepMerge$4({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {
          interface: SSidePanelComponentInterface
        }
      }));
      if (this.props.closeOn.indexOf("click") !== -1) {
        this.addEventListener("click", (e) => {
          if (this._$container.contains(e.target))
            return;
          if (this.constructor._activePanels.slice(-1)[0] !== this)
            return;
          this.constructor._activePanels.pop();
          this.active = false;
        });
      }
      if (this.props.closeOn.indexOf("escape") !== -1) {
        hotkey$1("escape").on("press", () => {
          if (this.constructor._activePanels.slice(-1)[0] !== this)
            return;
          this.constructor._activePanels.pop();
          this.active = false;
        });
      }
      this._$nodes = Array.from(this.children);
      if (this.props.triggerer) {
        const $triggerers = Array.from(document.querySelectorAll(this.props.triggerer));
        $triggerers.forEach(($triggerer) => {
          $triggerer.addEventListener("click", (e) => {
            this.open();
          });
        });
      }
    }
    static get properties() {
      return SLitComponent.properties({}, SSidePanelComponentInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css$5)}
        `;
    }
    set active(value) {
      this._active = value;
      if (value && this.constructor._activePanels.indexOf(this) === -1) {
        this.constructor._activePanels.push(this);
      }
      if (value) {
        this.setAttribute("active", true);
      } else
        this.removeAttribute("active");
      this.requestUpdate();
    }
    get active() {
      return this._active;
    }
    firstUpdated() {
      this._$container = this.querySelector(".s-side-panel__container");
      this._$nodes.forEach(($node) => {
        var _a;
        (_a = this._$container) === null || _a === void 0 ? void 0 : _a.appendChild($node);
      });
    }
    open() {
      this.active = true;
    }
    close() {
      this.active = false;
    }
    render() {
      return html$2`
            ${this.overlay ? html$2` <div class="${this.componentUtils.className("__overlay")}"></div> ` : ""}
            <div class="${this.componentUtils.className("__container")}"></div>
        `;
    }
  }
  SSidePanel._activePanels = [];
  __decorate$2([
    property()
  ], SSidePanel.prototype, "overlay", void 0);
  function define$7(props = {}, tagName = "s-side-panel") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SSidePanel);
  }
  class SSugarConfig {
    static get(dotpath) {
      var _a, _b, _c;
      return get$3((_c = (_b = (_a = window.env) === null || _a === void 0 ? void 0 : _a.SUGAR) === null || _b === void 0 ? void 0 : _b.config) !== null && _c !== void 0 ? _c : {}, dotpath);
    }
  }
  var pikaday = {exports: {}};
  //! moment.js
  //! version : 2.29.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  var hookCallback;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray$2(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
  }
  function isObject(input) {
    return input != null && Object.prototype.toString.call(input) === "[object Object]";
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;
      for (k in obj) {
        if (hasOwnProp(obj, k)) {
          return false;
        }
      }
      return true;
    }
  }
  function isUndefined(input) {
    return input === void 0;
  }
  function isNumber(input) {
    return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
  }
  function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, "toString")) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, "valueOf")) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this), len = t.length >>> 0, i;
      for (i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
        return i != null;
      }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m._isValid;
  }
  function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  var momentProperties = hooks.momentProperties = [], updateInProgress = false;
  function copyConfig(to, from) {
    var i, prop, val;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i = 0; i < momentProperties.length; i++) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = new Date(NaN);
    }
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
      console.warn("Deprecation warning: " + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [], arg, i, key;
        for (i = 0; i < arguments.length; i++) {
          arg = "";
          if (typeof arguments[i] === "object") {
            arg += "\n[" + i + "] ";
            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ": " + arguments[0][key] + ", ";
              }
            }
            arg = arg.slice(0, -2);
          } else {
            arg = arguments[i];
          }
          args.push(arg);
        }
        warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  function isFunction(input) {
    return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
  }
  function set$1(config) {
    var prop, i;
    for (i in config) {
      if (hasOwnProp(config, i)) {
        prop = config[i];
        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this["_" + i] = prop;
        }
      }
    }
    this._config = config;
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i, res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
  };
  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar["sameElse"];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
    return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === "string") {
      func = function() {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function() {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, "");
    }
    return input.replace(/\\/g, "");
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = "", i2;
      for (i2 = 0; i2 < length; i2++) {
        output += isFunction(array[i2]) ? array[i2].call(mom, format) : array[i2];
      }
      return output;
    };
  }
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
      if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
        return tok.slice(1);
      }
      return tok;
    }).join("");
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = "Invalid date";
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace("%d", number);
  }
  var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? "future" : "past"];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {}, normalizedProp, prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [], u;
    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({unit: u, priority: priorities[u]});
      }
    }
    units.sort(function(a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion, value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        set$1$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }
  function get(mom, unit) {
    return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
  }
  function set$1$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
      }
    }
  }
  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === "object") {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units), i;
      for (i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
  regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i, func = callback;
    if (typeof token === "string") {
      token = [token];
    }
    if (isNumber(callback)) {
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function(input, array, config, token2) {
      config._w = config._w || {};
      callback(input, config._w, config, token2);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
  function mod(n, x) {
    return (n % x + x) % x;
  }
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  }
  addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken("MMMM", 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias("month", "M");
  addUnitPriority("month", 8);
  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(["M", "MM"], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(["MMM", "MMMM"], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
  function localeMonths(m, format) {
    if (!m) {
      return isArray$2(this._months) ? this._months : this._months["standalone"];
    }
    return isArray$2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
  }
  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
    }
    return isArray$2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
  }
  function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = createUTC([2e3, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = createUTC([2e3, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
        this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
      }
      if (!strict && !this._monthsParse[i]) {
        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
        this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === "string") {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (!isNumber(value)) {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, "Month");
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsShortRegex")) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsRegex")) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
    for (i = 0; i < 12; i++) {
      mom = createUTC([2e3, i]);
      shortPieces.push(this.monthsShort(mom, ""));
      longPieces.push(this.months(mom, ""));
      mixedPieces.push(this.months(mom, ""));
      mixedPieces.push(this.monthsShort(mom, ""));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  }
  addFormatToken("Y", 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : "+" + y;
  });
  addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addUnitAlias("year", "y");
  addUnitPriority("year", 1);
  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function(input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function(input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
  };
  var getSetYear = makeGetSet("FullYear", true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y, m, d, h, M, s, ms) {
    var date;
    if (y < 100 && y >= 0) {
      date = new Date(y + 400, m, d, h, M, s, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }
    return date;
  }
  function createUTCDate(y) {
    var date, args;
    if (y < 100 && y >= 0) {
      args = Array.prototype.slice.call(arguments);
      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }
    return date;
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");
  addUnitPriority("week", 5);
  addUnitPriority("isoWeek", 5);
  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match2);
  addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken("ddd", 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken("dddd", 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");
  addUnitPriority("day", 11);
  addUnitPriority("weekday", 11);
  addUnitPriority("isoWeekday", 11);
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function(input, week, config, token) {
    week[token] = toInt(input);
  });
  function parseWeekday(input, locale) {
    if (typeof input !== "string") {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === "number") {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale) {
    if (typeof input === "string") {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }
  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }
  var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
  function localeWeekdays(m, format) {
    var weekdays = isArray$2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }
  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }
  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = createUTC([2e3, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;
    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      mom = createUTC([2e3, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
        this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
        this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
      }
      if (!this._weekdaysParse[i]) {
        regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
        this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, "d");
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, "d");
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysShortRegex")) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysMinRegex")) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
      mom = createUTC([2e3, 1]).day(i);
      minp = regexEscape(this.weekdaysMin(mom, ""));
      shortp = regexEscape(this.weekdaysShort(mom, ""));
      longp = regexEscape(this.weekdays(mom, ""));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, kFormat);
  addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem("a", true);
  meridiem("A", false);
  addUnitAlias("hour", "h");
  addUnitPriority("hour", 13);
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("k", match1to2);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addRegexToken("kk", match1to2, match2);
  addRegexToken("hmm", match3to4);
  addRegexToken("hmmss", match5to6);
  addRegexToken("Hmm", match3to4);
  addRegexToken("Hmmss", match5to6);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function(input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(["a", "A"], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("Hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken("Hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return (input + "").toLowerCase().charAt(0) === "p";
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? "pm" : "PM";
    } else {
      return isLower ? "am" : "AM";
    }
  }
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  var locales = {}, localeFamilies = {}, globalLocale;
  function commonPrefix(arr1, arr2) {
    var i, minl = Math.min(arr1.length, arr2.length);
    for (i = 0; i < minl; i += 1) {
      if (arr1[i] !== arr2[i]) {
        return i;
      }
    }
    return minl;
  }
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }
  function chooseLocale(names) {
    var i = 0, j2, next, locale, split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split("-");
      j2 = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split("-") : null;
      while (j2 > 0) {
        locale = loadLocale(split.slice(0, j2).join("-"));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
          break;
        }
        j2--;
      }
      i++;
    }
    return globalLocale;
  }
  function loadLocale(name) {
    var oldLocale = null, aliasedRequire;
    if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = require;
        aliasedRequire("./locale/" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        locales[name] = null;
      }
    }
    return locales[name];
  }
  function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      } else {
        if (typeof console !== "undefined" && console.warn) {
          console.warn("Locale " + key + " not found. Did you forget to load it?");
        }
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var locale, parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);
          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }
            localeFamilies[config.parentLocale].push({
              name,
              config
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function(x) {
          defineLocale(x.name, x.config);
        });
      }
      getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale, tmpLocale, parentConfig = baseConfig;
      if (locales[name] != null && locales[name].parentLocale != null) {
        locales[name].set(mergeConfigs(locales[name]._config, config));
      } else {
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        if (tmpLocale == null) {
          config.abbr = name;
        }
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;
      }
      getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray$2(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow, a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, false],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
    ["YYYYDDD", /\d{7}/],
    ["YYYYMM", /\d{6}/, false],
    ["YYYY", /\d{4}/, false]
  ], isoTimes = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/]
  ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function configFromISO(config) {
    var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            timeFormat = (match[2] || " ") + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = "Z";
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
      untruncateYear(yearStr),
      defaultLocaleMonthsShort.indexOf(monthStr),
      parseInt(dayStr, 10),
      parseInt(hourStr, 10),
      parseInt(minuteStr, 10)
    ];
    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }
    return result;
  }
  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2e3 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }
  function preprocessRFC2822(s) {
    return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }
    return true;
  }
  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      return 0;
    } else {
      var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
      return h * 60 + m;
    }
  }
  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
    if (match) {
      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }
      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    configFromRFC2822(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    if (config._strict) {
      config._isValid = false;
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
  });
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
      return [
        nowValue.getUTCFullYear(),
        nowValue.getUTCMonth(),
        nowValue.getUTCDate()
      ];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
    if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
      week = defaults(w.w, curWeek.week);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
  hooks.ISO_8601 = function() {
  };
  hooks.RFC_2822 = function() {
  };
  function configFromStringAndFormat(config) {
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = void 0;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    era = getParsingFlags(config).era;
    if (era !== null) {
      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
    }
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (isValid(tempConfig)) {
        validFormatFound = true;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, "d");
      res._nextDay = void 0;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i, format = config._f;
    config._locale = config._locale || getLocale(config._l);
    if (input === null || format === void 0 && input === "") {
      return createInvalid({nullInput: true});
    }
    if (typeof input === "string") {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray$2(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === "string") {
      configFromString(config);
    } else if (isArray$2(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (format === true || format === false) {
      strict = format;
      format = void 0;
    }
    if (locale === true || locale === false) {
      strict = locale;
      locale = void 0;
    }
    if (isObject(input) && isObjectEmpty(input) || isArray$2(input) && input.length === 0) {
      input = void 0;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  });
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray$2(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isBefore", args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isAfter", args);
  }
  var now = function() {
    return Date.now ? Date.now() : +new Date();
  };
  var ordering = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function isDurationValid(m) {
    var key, unitHasDecimal = false, i;
    for (key in m) {
      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }
    for (i = 0; i < ordering.length; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false;
        }
        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput);
    this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
    this._days = +days + weeks * 7;
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function offset$1(token, separator) {
    addFormatToken(token, 0, 0, function() {
      var offset = this.utcOffset(), sign = "+";
      if (offset < 0) {
        offset = -offset;
        sign = "-";
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }
  offset$1("Z", ":");
  offset$1("ZZ", "");
  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = (string || "").match(matcher), chunk, parts, minutes;
    if (matches === null) {
      return null;
    }
    chunk = matches[matches.length - 1] || [];
    parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
  }
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset());
  }
  hooks.updateOffset = function() {
  };
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0, localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, "m"), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === "string") {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {}, other;
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(input, key) {
    var duration = input, match = null, sign, ret, diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input) || !isNaN(+input)) {
      duration = {};
      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign = match[1] === "-" ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign
      };
    } else if (match = isoRegex.exec(input)) {
      sign = match[1] === "-" ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, "_locale")) {
      ret._locale = input._locale;
    }
    if (isDuration(input) && hasOwnProp(input, "_isValid")) {
      ret._isValid = input._isValid;
    }
    return ret;
  }
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(",", "."));
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, "M").isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, "M");
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {milliseconds: 0, months: 0};
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur, tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
        tmp = val;
        val = period;
        period = tmp;
      }
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (months) {
      setMonth(mom, get(mom, "Month") + months * isAdding);
    }
    if (days) {
      set$1$1(mom, "Date", get(mom, "Date") + days * isAdding);
    }
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }
  var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
  function isString(input) {
    return typeof input === "string" || input instanceof String;
  }
  function isMomentInput(input) {
    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
  }
  function isMomentInputObject(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "years",
      "year",
      "y",
      "months",
      "month",
      "M",
      "days",
      "day",
      "d",
      "dates",
      "date",
      "D",
      "hours",
      "hour",
      "h",
      "minutes",
      "minute",
      "m",
      "seconds",
      "second",
      "s",
      "milliseconds",
      "millisecond",
      "ms"
    ], i, property;
    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function isNumberOrStringArray(input) {
    var arrayTest = isArray$2(input), dataTypeTest = false;
    if (arrayTest) {
      dataTypeTest = input.filter(function(item) {
        return !isNumber(item) && isString(input);
      }).length === 0;
    }
    return arrayTest && dataTypeTest;
  }
  function isCalendarSpec(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "sameDay",
      "nextDay",
      "lastDay",
      "nextWeek",
      "lastWeek",
      "sameElse"
    ], i, property;
    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, "days", true);
    return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
  }
  function calendar$1(time, formats) {
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time = void 0;
        formats = void 0;
      } else if (isMomentInput(arguments[0])) {
        time = arguments[0];
        formats = void 0;
      } else if (isCalendarSpec(arguments[0])) {
        formats = arguments[0];
        time = void 0;
      }
    }
    var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }
  function clone$1() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }
    inclusivity = inclusivity || "()";
    return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input), inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that, zoneDelta, output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    switch (units) {
      case "year":
        output = monthDiff(this, that) / 12;
        break;
      case "month":
        output = monthDiff(this, that);
        break;
      case "quarter":
        output = monthDiff(this, that) / 3;
        break;
      case "second":
        output = (this - that) / 1e3;
        break;
      case "minute":
        output = (this - that) / 6e4;
        break;
      case "hour":
        output = (this - that) / 36e5;
        break;
      case "day":
        output = (this - that - zoneDelta) / 864e5;
        break;
      case "week":
        output = (this - that - zoneDelta) / 6048e5;
        break;
      default:
        output = this - that;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    if (a.date() < b.date()) {
      return -monthDiff(b, a);
    }
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  function toString$1() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    if (isFunction(Date.prototype.toISOString)) {
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
      }
    }
    return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  function inspect() {
    if (!this.isValid()) {
      return "moment.invalid(/* " + this._i + " */)";
    }
    var func = "moment", zone = "", prefix, year, datetime, suffix;
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
      zone = "Z";
    }
    prefix = "[" + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
    datetime = "-MM-DD[T]HH:mm:ss.SSS";
    suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === void 0) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }
  function localStartOfDate(y, m, d) {
    if (y < 100 && y >= 0) {
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }
  function utcStartOfDate(y, m, d) {
    if (y < 100 && y >= 0) {
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }
  function startOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time = startOfDate(this.year(), 0, 1);
        break;
      case "quarter":
        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;
      case "month":
        time = startOfDate(this.year(), this.month(), 1);
        break;
      case "week":
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;
      case "isoWeek":
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case "day":
      case "date":
        time = startOfDate(this.year(), this.month(), this.date());
        break;
      case "hour":
        time = this._d.valueOf();
        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;
      case "minute":
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;
      case "second":
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function endOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case "month":
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case "isoWeek":
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case "day":
      case "date":
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;
      case "minute":
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;
      case "second":
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 6e4;
  }
  function unix() {
    return Math.floor(this.valueOf() / 1e3);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [
      m.year(),
      m.month(),
      m.date(),
      m.hour(),
      m.minute(),
      m.second(),
      m.millisecond()
    ];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken("N", 0, 0, "eraAbbr");
  addFormatToken("NN", 0, 0, "eraAbbr");
  addFormatToken("NNN", 0, 0, "eraAbbr");
  addFormatToken("NNNN", 0, 0, "eraName");
  addFormatToken("NNNNN", 0, 0, "eraNarrow");
  addFormatToken("y", ["y", 1], "yo", "eraYear");
  addFormatToken("y", ["yy", 2], 0, "eraYear");
  addFormatToken("y", ["yyy", 3], 0, "eraYear");
  addFormatToken("y", ["yyyy", 4], 0, "eraYear");
  addRegexToken("N", matchEraAbbr);
  addRegexToken("NN", matchEraAbbr);
  addRegexToken("NNN", matchEraAbbr);
  addRegexToken("NNNN", matchEraName);
  addRegexToken("NNNNN", matchEraNarrow);
  addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token) {
    var era = config._locale.erasParse(input, token, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  });
  addRegexToken("y", matchUnsigned);
  addRegexToken("yy", matchUnsigned);
  addRegexToken("yyy", matchUnsigned);
  addRegexToken("yyyy", matchUnsigned);
  addRegexToken("yo", matchEraYearOrdinal);
  addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
  addParseToken(["yo"], function(input, array, config, token) {
    var match;
    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }
    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });
  function localeEras(m, format) {
    var i, l, date, eras = this._eras || getLocale("en")._eras;
    for (i = 0, l = eras.length; i < l; ++i) {
      switch (typeof eras[i].since) {
        case "string":
          date = hooks(eras[i].since).startOf("day");
          eras[i].since = date.valueOf();
          break;
      }
      switch (typeof eras[i].until) {
        case "undefined":
          eras[i].until = Infinity;
          break;
        case "string":
          date = hooks(eras[i].until).startOf("day").valueOf();
          eras[i].until = date.valueOf();
          break;
      }
    }
    return eras;
  }
  function localeErasParse(eraName, format, strict) {
    var i, l, eras = this.eras(), name, abbr, narrow;
    eraName = eraName.toUpperCase();
    for (i = 0, l = eras.length; i < l; ++i) {
      name = eras[i].name.toUpperCase();
      abbr = eras[i].abbr.toUpperCase();
      narrow = eras[i].narrow.toUpperCase();
      if (strict) {
        switch (format) {
          case "N":
          case "NN":
          case "NNN":
            if (abbr === eraName) {
              return eras[i];
            }
            break;
          case "NNNN":
            if (name === eraName) {
              return eras[i];
            }
            break;
          case "NNNNN":
            if (narrow === eraName) {
              return eras[i];
            }
            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i];
      }
    }
  }
  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? 1 : -1;
    if (year === void 0) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }
  function getEraName() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].name;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].name;
      }
    }
    return "";
  }
  function getEraNarrow() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].narrow;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].narrow;
      }
    }
    return "";
  }
  function getEraAbbr() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].abbr;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].abbr;
      }
    }
    return "";
  }
  function getEraYear() {
    var i, l, dir, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      dir = eras[i].since <= eras[i].until ? 1 : -1;
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
      }
    }
    return this.year();
  }
  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNameRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNameRegex : this._erasRegex;
  }
  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, "_erasAbbrRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }
  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNarrowRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }
  function matchEraAbbr(isStrict, locale) {
    return locale.erasAbbrRegex(isStrict);
  }
  function matchEraName(isStrict, locale) {
    return locale.erasNameRegex(isStrict);
  }
  function matchEraNarrow(isStrict, locale) {
    return locale.erasNarrowRegex(isStrict);
  }
  function matchEraYearOrdinal(isStrict, locale) {
    return locale._eraYearOrdinalRegex || matchUnsigned;
  }
  function computeErasParse() {
    var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      namePieces.push(regexEscape(eras[i].name));
      abbrPieces.push(regexEscape(eras[i].abbr));
      narrowPieces.push(regexEscape(eras[i].narrow));
      mixedPieces.push(regexEscape(eras[i].name));
      mixedPieces.push(regexEscape(eras[i].abbr));
      mixedPieces.push(regexEscape(eras[i].narrow));
    }
    this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
    this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
    this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
  }
  addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");
  addUnitPriority("weekYear", 1);
  addUnitPriority("isoWeekYear", 1);
  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);
  addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(["gg", "GG"], function(input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken("Q", 0, "Qo", "quarter");
  addUnitAlias("quarter", "Q");
  addUnitPriority("quarter", 7);
  addRegexToken("Q", match1);
  addParseToken("Q", function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken("D", ["DD", 2], "Do", "date");
  addUnitAlias("date", "D");
  addUnitPriority("date", 9);
  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function(isStrict, locale) {
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addUnitAlias("dayOfYear", "DDD");
  addUnitPriority("dayOfYear", 4);
  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
  }
  addFormatToken("m", ["mm", 2], 0, "minute");
  addUnitAlias("minute", "m");
  addUnitPriority("minute", 14);
  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addUnitAlias("second", "s");
  addUnitPriority("second", 15);
  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);
  var getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1e3;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6;
  });
  addUnitAlias("millisecond", "ms");
  addUnitPriority("millisecond", 16);
  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);
  var token, getSetMillisecond;
  for (token = "SSSS"; token.length <= 9; token += "S") {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(("0." + input) * 1e3);
  }
  for (token = "S"; token.length <= 9; token += "S") {
    addParseToken(token, parseMs);
  }
  getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }
  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone$1;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== "undefined" && Symbol.for != null) {
    proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    };
  }
  proto.toJSON = toJSON;
  proto.toString = toString$1;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
  proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
  proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
  proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
  proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
  function createUnix(input) {
    return createLocal(input * 1e3);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set$1;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  function get$1(format, index, field, setter) {
    var locale = getLocale(), utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = void 0;
    }
    format = format || "";
    if (index != null) {
      return get$1(format, index, field, "month");
    }
    var i, out = [];
    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, "month");
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === "boolean") {
      if (isNumber(format)) {
        index = format;
        format = void 0;
      }
      format = format || "";
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (isNumber(format)) {
        index = format;
        format = void 0;
      }
      format = format || "";
    }
    var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];
    if (index != null) {
      return get$1(format, (index + shift) % 7, field, "day");
    }
    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, "day");
    }
    return out;
  }
  function listMonths(format, index) {
    return listMonthsImpl(format, index, "months");
  }
  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, "monthsShort");
  }
  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdays");
  }
  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
  }
  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
  }
  getSetGlobalLocale("en", {
    eras: [
      {
        since: "0001-01-01",
        until: Infinity,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
      },
      {
        since: "0000-12-31",
        until: -Infinity,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
      }
    ],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
      return number + output;
    }
  });
  hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
  hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
  var mathAbs = Math.abs;
  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;
    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }
    data.milliseconds = milliseconds % 1e3;
    seconds = absFloor(milliseconds / 1e3);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    return months * 146097 / 4800;
  }
  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days, months, milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === "month" || units === "quarter" || units === "year") {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      switch (units) {
        case "month":
          return months;
        case "quarter":
          return months / 3;
        case "year":
          return months / 12;
      }
    } else {
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case "week":
          return days / 7 + milliseconds / 6048e5;
        case "day":
          return days + milliseconds / 864e5;
        case "hour":
          return days * 24 + milliseconds / 36e5;
        case "minute":
          return days * 1440 + milliseconds / 6e4;
        case "second":
          return days * 86400 + milliseconds / 1e3;
        case "millisecond":
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
  function clone$1$1() {
    return createDuration(this);
  }
  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + "s"]() : NaN;
  }
  function makeGetter(name) {
    return function() {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round, thresholds = {
    ss: 44,
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    w: null,
    M: 11
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
    var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), weeks = round(duration.as("w")), years = round(duration.as("y")), a = seconds <= thresholds.ss && ["s", seconds] || seconds < thresholds.s && ["ss", seconds] || minutes <= 1 && ["m"] || minutes < thresholds.m && ["mm", minutes] || hours <= 1 && ["h"] || hours < thresholds.h && ["hh", hours] || days <= 1 && ["d"] || days < thresholds.d && ["dd", days];
    if (thresholds.w != null) {
      a = a || weeks <= 1 && ["w"] || weeks < thresholds.w && ["ww", weeks];
    }
    a = a || months <= 1 && ["M"] || months < thresholds.M && ["MM", months] || years <= 1 && ["y"] || ["yy", years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === void 0) {
      return round;
    }
    if (typeof roundingFunction === "function") {
      round = roundingFunction;
      return true;
    }
    return false;
  }
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === void 0) {
      return false;
    }
    if (limit === void 0) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === "s") {
      thresholds.ss = limit - 1;
    }
    return true;
  }
  function humanize(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var withSuffix = false, th = thresholds, locale, output;
    if (typeof argWithSuffix === "object") {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }
    if (typeof argWithSuffix === "boolean") {
      withSuffix = argWithSuffix;
    }
    if (typeof argThresholds === "object") {
      th = Object.assign({}, thresholds, argThresholds);
      if (argThresholds.s != null && argThresholds.ss == null) {
        th.ss = argThresholds.s - 1;
      }
    }
    locale = this.localeData();
    output = relativeTime$1(this, !withSuffix, th, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var abs$1 = Math.abs;
  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }
  function toISOString$1() {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
    if (!total) {
      return "P0D";
    }
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;
    years = absFloor(months / 12);
    months %= 12;
    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
    totalSign = total < 0 ? "-" : "";
    ymSign = sign(this._months) !== sign(total) ? "-" : "";
    daysSign = sign(this._days) !== sign(total) ? "-" : "";
    hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
    return totalSign + "P" + (years ? ymSign + years + "Y" : "") + (months ? ymSign + months + "M" : "") + (days ? daysSign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hmsSign + hours + "H" : "") + (minutes ? hmsSign + minutes + "M" : "") + (seconds ? hmsSign + s + "S" : "");
  }
  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
  proto$2.lang = lang;
  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");
  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function(input, array, config) {
    config._d = new Date(parseFloat(input) * 1e3);
  });
  addParseToken("x", function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  //! moment.js
  hooks.version = "2.29.1";
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE: "YYYY-MM-DD",
    TIME: "HH:mm",
    TIME_SECONDS: "HH:mm:ss",
    TIME_MS: "HH:mm:ss.SSS",
    WEEK: "GGGG-[W]WW",
    MONTH: "YYYY-MM"
  };
  var moment = /* @__PURE__ */ Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", "default": hooks});
  var require$$0 = /* @__PURE__ */ getAugmentedNamespace(moment);
  /*!
  * Pikaday
  *
  * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
  */
  (function(module2, exports) {
    (function(root, factory) {
      var moment;
      {
        try {
          moment = require$$0;
        } catch (e) {
        }
        module2.exports = factory(moment);
      }
    })(commonjsGlobal, function(moment) {
      var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document2 = window.document, sto = window.setTimeout, addEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.addEventListener(e, callback, !!capture);
        } else {
          el.attachEvent("on" + e, callback);
        }
      }, removeEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.removeEventListener(e, callback, !!capture);
        } else {
          el.detachEvent("on" + e, callback);
        }
      }, trim = function(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }, hasClass = function(el, cn) {
        return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1;
      }, addClass = function(el, cn) {
        if (!hasClass(el, cn)) {
          el.className = el.className === "" ? cn : el.className + " " + cn;
        }
      }, removeClass = function(el, cn) {
        el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "));
      }, isArray = function(obj) {
        return /Array/.test(Object.prototype.toString.call(obj));
      }, isDate = function(obj) {
        return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
      }, isWeekend = function(date) {
        var day = date.getDay();
        return day === 0 || day === 6;
      }, isLeapYear = function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }, getDaysInMonth = function(year, month) {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
      }, setToStartOfDay = function(date) {
        if (isDate(date))
          date.setHours(0, 0, 0, 0);
      }, compareDates = function(a, b) {
        return a.getTime() === b.getTime();
      }, extend = function(to, from, overwrite) {
        var prop, hasProp;
        for (prop in from) {
          hasProp = to[prop] !== void 0;
          if (hasProp && typeof from[prop] === "object" && from[prop] !== null && from[prop].nodeName === void 0) {
            if (isDate(from[prop])) {
              if (overwrite) {
                to[prop] = new Date(from[prop].getTime());
              }
            } else if (isArray(from[prop])) {
              if (overwrite) {
                to[prop] = from[prop].slice(0);
              }
            } else {
              to[prop] = extend({}, from[prop], overwrite);
            }
          } else if (overwrite || !hasProp) {
            to[prop] = from[prop];
          }
        }
        return to;
      }, fireEvent = function(el, eventName, data) {
        var ev;
        if (document2.createEvent) {
          ev = document2.createEvent("HTMLEvents");
          ev.initEvent(eventName, true, false);
          ev = extend(ev, data);
          el.dispatchEvent(ev);
        } else if (document2.createEventObject) {
          ev = document2.createEventObject();
          ev = extend(ev, data);
          el.fireEvent("on" + eventName, ev);
        }
      }, adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
          calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
          calendar.month += 12;
        }
        if (calendar.month > 11) {
          calendar.year += Math.floor(Math.abs(calendar.month) / 12);
          calendar.month -= 12;
        }
        return calendar;
      }, defaults = {
        field: null,
        bound: void 0,
        ariaLabel: "Use the arrow keys to pick a date",
        position: "bottom left",
        reposition: true,
        format: "YYYY-MM-DD",
        toString: null,
        parse: null,
        defaultDate: null,
        setDefaultDate: false,
        firstDay: 0,
        firstWeekOfYearMinDays: 4,
        formatStrict: false,
        minDate: null,
        maxDate: null,
        yearRange: 10,
        showWeekNumber: false,
        pickWholeWeek: false,
        minYear: 0,
        maxYear: 9999,
        minMonth: void 0,
        maxMonth: void 0,
        startRange: null,
        endRange: null,
        isRTL: false,
        yearSuffix: "",
        showMonthAfterYear: false,
        showDaysInNextAndPreviousMonths: false,
        enableSelectionDaysInNextAndPreviousMonths: false,
        numberOfMonths: 1,
        mainCalendar: "left",
        container: void 0,
        blurFieldOnSelect: true,
        i18n: {
          previousMonth: "Previous Month",
          nextMonth: "Next Month",
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        },
        theme: null,
        events: [],
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null,
        keyboardInput: true
      }, renderDayName = function(opts, day, abbr) {
        day += opts.firstDay;
        while (day >= 7) {
          day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
      }, renderDay = function(opts) {
        var arr = [];
        var ariaSelected = "false";
        if (opts.isEmpty) {
          if (opts.showDaysInNextAndPreviousMonths) {
            arr.push("is-outside-current-month");
            if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
              arr.push("is-selection-disabled");
            }
          } else {
            return '<td class="is-empty"></td>';
          }
        }
        if (opts.isDisabled) {
          arr.push("is-disabled");
        }
        if (opts.isToday) {
          arr.push("is-today");
        }
        if (opts.isSelected) {
          arr.push("is-selected");
          ariaSelected = "true";
        }
        if (opts.hasEvent) {
          arr.push("has-event");
        }
        if (opts.isInRange) {
          arr.push("is-inrange");
        }
        if (opts.isStartRange) {
          arr.push("is-startrange");
        }
        if (opts.isEndRange) {
          arr.push("is-endrange");
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
      }, isoWeek = function(date, firstWeekOfYearMinDays) {
        date.setHours(0, 0, 0, 0);
        var yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, prevWeekDay = function(day) {
          return (day + daysPerWeek - 1) % daysPerWeek;
        };
        date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
        var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
        return weekNum;
      }, renderWeek = function(d, m, y, firstWeekOfYearMinDays) {
        var date = new Date(y, m, d), week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
        return '<td class="pika-week">' + week + "</td>";
      }, renderRow = function(days, isRTL, pickWholeWeek, isRowSelected) {
        return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days.reverse() : days).join("") + "</tr>";
      }, renderBody = function(rows) {
        return "<tbody>" + rows.join("") + "</tbody>";
      }, renderHead = function(opts) {
        var i, arr = [];
        if (opts.showWeekNumber) {
          arr.push("<th></th>");
        }
        for (i = 0; i < 7; i++) {
          arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
        }
        return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
      }, renderTitle = function(instance, c, year, month, refYear, randId) {
        var i, j2, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;
        for (arr = [], i = 0; i < 12; i++) {
          arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>");
        }
        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
        if (isArray(opts.yearRange)) {
          i = opts.yearRange[0];
          j2 = opts.yearRange[1] + 1;
        } else {
          i = year - opts.yearRange;
          j2 = 1 + year + opts.yearRange;
        }
        for (arr = []; i < j2 && i <= opts.maxYear; i++) {
          if (i >= opts.minYear) {
            arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>");
          }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
        if (opts.showMonthAfterYear) {
          html += yearHtml + monthHtml;
        } else {
          html += monthHtml + yearHtml;
        }
        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
          prev = false;
        }
        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
          next = false;
        }
        if (c === 0) {
          html += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
        }
        if (c === instance._o.numberOfMonths - 1) {
          html += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
        }
        return html += "</div>";
      }, renderTable = function(opts, data, randId) {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>";
      }, Pikaday = function(options) {
        var self2 = this, opts = self2.config(options);
        self2._onMouseDown = function(e) {
          if (!self2._v) {
            return;
          }
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (!hasClass(target, "is-disabled")) {
            if (hasClass(target, "pika-button") && !hasClass(target, "is-empty") && !hasClass(target.parentNode, "is-disabled")) {
              self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
              if (opts.bound) {
                sto(function() {
                  self2.hide();
                  if (opts.blurFieldOnSelect && opts.field) {
                    opts.field.blur();
                  }
                }, 100);
              }
            } else if (hasClass(target, "pika-prev")) {
              self2.prevMonth();
            } else if (hasClass(target, "pika-next")) {
              self2.nextMonth();
            }
          }
          if (!hasClass(target, "pika-select")) {
            if (e.preventDefault) {
              e.preventDefault();
            } else {
              e.returnValue = false;
              return false;
            }
          } else {
            self2._c = true;
          }
        };
        self2._onChange = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (hasClass(target, "pika-select-month")) {
            self2.gotoMonth(target.value);
          } else if (hasClass(target, "pika-select-year")) {
            self2.gotoYear(target.value);
          }
        };
        self2._onKeyChange = function(e) {
          e = e || window.event;
          if (self2.isVisible()) {
            switch (e.keyCode) {
              case 13:
              case 27:
                if (opts.field) {
                  opts.field.blur();
                }
                break;
              case 37:
                self2.adjustDate("subtract", 1);
                break;
              case 38:
                self2.adjustDate("subtract", 7);
                break;
              case 39:
                self2.adjustDate("add", 1);
                break;
              case 40:
                self2.adjustDate("add", 7);
                break;
              case 8:
              case 46:
                self2.setDate(null);
                break;
            }
          }
        };
        self2._parseFieldValue = function() {
          if (opts.parse) {
            return opts.parse(opts.field.value, opts.format);
          } else if (hasMoment) {
            var date = moment(opts.field.value, opts.format, opts.formatStrict);
            return date && date.isValid() ? date.toDate() : null;
          } else {
            return new Date(Date.parse(opts.field.value));
          }
        };
        self2._onInputChange = function(e) {
          var date;
          if (e.firedBy === self2) {
            return;
          }
          date = self2._parseFieldValue();
          if (isDate(date)) {
            self2.setDate(date);
          }
          if (!self2._v) {
            self2.show();
          }
        };
        self2._onInputFocus = function() {
          self2.show();
        };
        self2._onInputClick = function() {
          self2.show();
        };
        self2._onInputBlur = function() {
          var pEl = document2.activeElement;
          do {
            if (hasClass(pEl, "pika-single")) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (!self2._c) {
            self2._b = sto(function() {
              self2.hide();
            }, 50);
          }
          self2._c = false;
        };
        self2._onClick = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement, pEl = target;
          if (!target) {
            return;
          }
          if (!hasEventListeners && hasClass(target, "pika-select")) {
            if (!target.onchange) {
              target.setAttribute("onchange", "return;");
              addEvent(target, "change", self2._onChange);
            }
          }
          do {
            if (hasClass(pEl, "pika-single") || pEl === opts.trigger) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
            self2.hide();
          }
        };
        self2.el = document2.createElement("div");
        self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
        addEvent(self2.el, "mousedown", self2._onMouseDown, true);
        addEvent(self2.el, "touchend", self2._onMouseDown, true);
        addEvent(self2.el, "change", self2._onChange);
        if (opts.keyboardInput) {
          addEvent(document2, "keydown", self2._onKeyChange);
        }
        if (opts.field) {
          if (opts.container) {
            opts.container.appendChild(self2.el);
          } else if (opts.bound) {
            document2.body.appendChild(self2.el);
          } else {
            opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
          }
          addEvent(opts.field, "change", self2._onInputChange);
          if (!opts.defaultDate) {
            opts.defaultDate = self2._parseFieldValue();
            opts.setDefaultDate = true;
          }
        }
        var defDate = opts.defaultDate;
        if (isDate(defDate)) {
          if (opts.setDefaultDate) {
            self2.setDate(defDate, true);
          } else {
            self2.gotoDate(defDate);
          }
        } else {
          self2.gotoDate(new Date());
        }
        if (opts.bound) {
          this.hide();
          self2.el.className += " is-bound";
          addEvent(opts.trigger, "click", self2._onInputClick);
          addEvent(opts.trigger, "focus", self2._onInputFocus);
          addEvent(opts.trigger, "blur", self2._onInputBlur);
        } else {
          this.show();
        }
      };
      Pikaday.prototype = {
        config: function(options) {
          if (!this._o) {
            this._o = extend({}, defaults, true);
          }
          var opts = extend(this._o, options, true);
          opts.isRTL = !!opts.isRTL;
          opts.field = opts.field && opts.field.nodeName ? opts.field : null;
          opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
          opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
          opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
          opts.disableWeekends = !!opts.disableWeekends;
          opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
          var nom = parseInt(opts.numberOfMonths, 10) || 1;
          opts.numberOfMonths = nom > 4 ? 4 : nom;
          if (!isDate(opts.minDate)) {
            opts.minDate = false;
          }
          if (!isDate(opts.maxDate)) {
            opts.maxDate = false;
          }
          if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
            opts.maxDate = opts.minDate = false;
          }
          if (opts.minDate) {
            this.setMinDate(opts.minDate);
          }
          if (opts.maxDate) {
            this.setMaxDate(opts.maxDate);
          }
          if (isArray(opts.yearRange)) {
            var fallback = new Date().getFullYear() - 10;
            opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
            opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
          } else {
            opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
            if (opts.yearRange > 100) {
              opts.yearRange = 100;
            }
          }
          return opts;
        },
        toString: function(format) {
          format = format || this._o.format;
          if (!isDate(this._d)) {
            return "";
          }
          if (this._o.toString) {
            return this._o.toString(this._d, format);
          }
          if (hasMoment) {
            return moment(this._d).format(format);
          }
          return this._d.toDateString();
        },
        getMoment: function() {
          return hasMoment ? moment(this._d) : null;
        },
        setMoment: function(date, preventOnSelect) {
          if (hasMoment && moment.isMoment(date)) {
            this.setDate(date.toDate(), preventOnSelect);
          }
        },
        getDate: function() {
          return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },
        setDate: function(date, preventOnSelect) {
          if (!date) {
            this._d = null;
            if (this._o.field) {
              this._o.field.value = "";
              fireEvent(this._o.field, "change", {firedBy: this});
            }
            return this.draw();
          }
          if (typeof date === "string") {
            date = new Date(Date.parse(date));
          }
          if (!isDate(date)) {
            return;
          }
          var min = this._o.minDate, max = this._o.maxDate;
          if (isDate(min) && date < min) {
            date = min;
          } else if (isDate(max) && date > max) {
            date = max;
          }
          this._d = new Date(date.getTime());
          setToStartOfDay(this._d);
          this.gotoDate(this._d);
          if (this._o.field) {
            this._o.field.value = this.toString();
            fireEvent(this._o.field, "change", {firedBy: this});
          }
          if (!preventOnSelect && typeof this._o.onSelect === "function") {
            this._o.onSelect.call(this, this.getDate());
          }
        },
        clear: function() {
          this.setDate(null);
        },
        gotoDate: function(date) {
          var newCalendar = true;
          if (!isDate(date)) {
            return;
          }
          if (this.calendars) {
            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
          }
          if (newCalendar) {
            this.calendars = [{
              month: date.getMonth(),
              year: date.getFullYear()
            }];
            if (this._o.mainCalendar === "right") {
              this.calendars[0].month += 1 - this._o.numberOfMonths;
            }
          }
          this.adjustCalendars();
        },
        adjustDate: function(sign, days) {
          var day = this.getDate() || new Date();
          var difference = parseInt(days) * 24 * 60 * 60 * 1e3;
          var newDay;
          if (sign === "add") {
            newDay = new Date(day.valueOf() + difference);
          } else if (sign === "subtract") {
            newDay = new Date(day.valueOf() - difference);
          }
          this.setDate(newDay);
        },
        adjustCalendars: function() {
          this.calendars[0] = adjustCalendar(this.calendars[0]);
          for (var c = 1; c < this._o.numberOfMonths; c++) {
            this.calendars[c] = adjustCalendar({
              month: this.calendars[0].month + c,
              year: this.calendars[0].year
            });
          }
          this.draw();
        },
        gotoToday: function() {
          this.gotoDate(new Date());
        },
        gotoMonth: function(month) {
          if (!isNaN(month)) {
            this.calendars[0].month = parseInt(month, 10);
            this.adjustCalendars();
          }
        },
        nextMonth: function() {
          this.calendars[0].month++;
          this.adjustCalendars();
        },
        prevMonth: function() {
          this.calendars[0].month--;
          this.adjustCalendars();
        },
        gotoYear: function(year) {
          if (!isNaN(year)) {
            this.calendars[0].year = parseInt(year, 10);
            this.adjustCalendars();
          }
        },
        setMinDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear = value.getFullYear();
            this._o.minMonth = value.getMonth();
          } else {
            this._o.minDate = defaults.minDate;
            this._o.minYear = defaults.minYear;
            this._o.minMonth = defaults.minMonth;
            this._o.startRange = defaults.startRange;
          }
          this.draw();
        },
        setMaxDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.maxDate = value;
            this._o.maxYear = value.getFullYear();
            this._o.maxMonth = value.getMonth();
          } else {
            this._o.maxDate = defaults.maxDate;
            this._o.maxYear = defaults.maxYear;
            this._o.maxMonth = defaults.maxMonth;
            this._o.endRange = defaults.endRange;
          }
          this.draw();
        },
        setStartRange: function(value) {
          this._o.startRange = value;
        },
        setEndRange: function(value) {
          this._o.endRange = value;
        },
        draw: function(force) {
          if (!this._v && !force) {
            return;
          }
          var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = "", randId;
          if (this._y <= minYear) {
            this._y = minYear;
            if (!isNaN(minMonth) && this._m < minMonth) {
              this._m = minMonth;
            }
          }
          if (this._y >= maxYear) {
            this._y = maxYear;
            if (!isNaN(maxMonth) && this._m > maxMonth) {
              this._m = maxMonth;
            }
          }
          for (var c = 0; c < opts.numberOfMonths; c++) {
            randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
            html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + "</div>";
          }
          this.el.innerHTML = html;
          if (opts.bound) {
            if (opts.field.type !== "hidden") {
              sto(function() {
                opts.trigger.focus();
              }, 1);
            }
          }
          if (typeof this._o.onDraw === "function") {
            this._o.onDraw(this);
          }
          if (opts.bound) {
            opts.field.setAttribute("aria-label", opts.ariaLabel);
          }
        },
        adjustPosition: function() {
          var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;
          if (this._o.container)
            return;
          this.el.style.position = "absolute";
          field = this._o.trigger;
          pEl = field;
          width = this.el.offsetWidth;
          height = this.el.offsetHeight;
          viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
          viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
          scrollTop = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
          leftAligned = true;
          bottomAligned = true;
          if (typeof field.getBoundingClientRect === "function") {
            clientRect = field.getBoundingClientRect();
            left = clientRect.left + window.pageXOffset;
            top = clientRect.bottom + window.pageYOffset;
          } else {
            left = pEl.offsetLeft;
            top = pEl.offsetTop + pEl.offsetHeight;
            while (pEl = pEl.offsetParent) {
              left += pEl.offsetLeft;
              top += pEl.offsetTop;
            }
          }
          if (this._o.reposition && left + width > viewportWidth || this._o.position.indexOf("right") > -1 && left - width + field.offsetWidth > 0) {
            left = left - width + field.offsetWidth;
            leftAligned = false;
          }
          if (this._o.reposition && top + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top - height - field.offsetHeight > 0) {
            top = top - height - field.offsetHeight;
            bottomAligned = false;
          }
          this.el.style.left = left + "px";
          this.el.style.top = top + "px";
          addClass(this.el, leftAligned ? "left-aligned" : "right-aligned");
          addClass(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
          removeClass(this.el, !leftAligned ? "left-aligned" : "right-aligned");
          removeClass(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned");
        },
        render: function(year, month, randId) {
          var opts = this._o, now = new Date(), days = getDaysInMonth(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
          setToStartOfDay(now);
          if (opts.firstDay > 0) {
            before -= opts.firstDay;
            if (before < 0) {
              before += 7;
            }
          }
          var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
          var cells = days + before, after = cells;
          while (after > 7) {
            after -= 7;
          }
          cells += 7 - after;
          var isWeekSelected = false;
          for (var i = 0, r = 0; i < cells; i++) {
            var day = new Date(year, month, 1 + (i - before)), isSelected = isDate(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty = i < before || i >= days + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
            if (isEmpty) {
              if (i < before) {
                dayNumber = daysInPreviousMonth + dayNumber;
                monthNumber = previousMonth;
                yearNumber = yearOfPreviousMonth;
              } else {
                dayNumber = dayNumber - days;
                monthNumber = nextMonth;
                yearNumber = yearOfNextMonth;
              }
            }
            var dayConfig = {
              day: dayNumber,
              month: monthNumber,
              year: yearNumber,
              hasEvent,
              isSelected,
              isToday,
              isDisabled,
              isEmpty,
              isStartRange,
              isEndRange,
              isInRange,
              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
              enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
            };
            if (opts.pickWholeWeek && isSelected) {
              isWeekSelected = true;
            }
            row.push(renderDay(dayConfig));
            if (++r === 7) {
              if (opts.showWeekNumber) {
                row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
              }
              data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
              row = [];
              r = 0;
              isWeekSelected = false;
            }
          }
          return renderTable(opts, data, randId);
        },
        isVisible: function() {
          return this._v;
        },
        show: function() {
          if (!this.isVisible()) {
            this._v = true;
            this.draw();
            removeClass(this.el, "is-hidden");
            if (this._o.bound) {
              addEvent(document2, "click", this._onClick);
              this.adjustPosition();
            }
            if (typeof this._o.onOpen === "function") {
              this._o.onOpen.call(this);
            }
          }
        },
        hide: function() {
          var v = this._v;
          if (v !== false) {
            if (this._o.bound) {
              removeEvent(document2, "click", this._onClick);
            }
            if (!this._o.container) {
              this.el.style.position = "static";
              this.el.style.left = "auto";
              this.el.style.top = "auto";
            }
            addClass(this.el, "is-hidden");
            this._v = false;
            if (v !== void 0 && typeof this._o.onClose === "function") {
              this._o.onClose.call(this);
            }
          }
        },
        destroy: function() {
          var opts = this._o;
          this.hide();
          removeEvent(this.el, "mousedown", this._onMouseDown, true);
          removeEvent(this.el, "touchend", this._onMouseDown, true);
          removeEvent(this.el, "change", this._onChange);
          if (opts.keyboardInput) {
            removeEvent(document2, "keydown", this._onKeyChange);
          }
          if (opts.field) {
            removeEvent(opts.field, "change", this._onInputChange);
            if (opts.bound) {
              removeEvent(opts.trigger, "click", this._onInputClick);
              removeEvent(opts.trigger, "focus", this._onInputFocus);
              removeEvent(opts.trigger, "blur", this._onInputBlur);
            }
          }
          if (this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
          }
        }
      };
      return Pikaday;
    });
  })(pikaday);
  var __pikaday = pikaday.exports;
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a$1, _b$1, _c$1, _d$1, _e$1;
  var _f$1;
  {
    console.warn("lit-html is in dev mode. Not recommended for production!");
  }
  const wrap$2 = ((_a$1 = window.ShadyDOM) === null || _a$1 === void 0 ? void 0 : _a$1.inUse) && ((_b$1 = window.ShadyDOM) === null || _b$1 === void 0 ? void 0 : _b$1.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
  const trustedTypes$1 = globalThis.trustedTypes;
  const policy$1 = trustedTypes$1 ? trustedTypes$1.createPolicy("lit-html", {
    createHTML: (s) => s
  }) : void 0;
  const identityFunction$1 = (value) => value;
  const noopSanitizer$1 = (_node, _name, _type) => identityFunction$1;
  const createSanitizer$1 = (node, name, type) => {
    return sanitizerFactoryInternal$1();
  };
  const boundAttributeSuffix$1 = "$lit$";
  const marker$1 = `lit$${String(Math.random()).slice(9)}$`;
  const markerMatch$1 = "?" + marker$1;
  const nodeMarker$1 = `<${markerMatch$1}>`;
  const d$1 = document;
  const createMarker$1 = (v = "") => d$1.createComment(v);
  const isPrimitive$1 = (value) => value === null || typeof value != "object" && typeof value != "function";
  const isArray$1 = Array.isArray;
  const isIterable$1 = (value) => {
    var _a2;
    return isArray$1(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
  };
  const SPACE_CHAR$1 = `[ 	
\f\r]`;
  const ATTR_VALUE_CHAR$1 = `[^ 	
\f\r"'\`<>=]`;
  const NAME_CHAR$1 = `[^\\s"'>=/]`;
  const textEndRegex$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  const COMMENT_START$1 = 1;
  const TAG_NAME$1 = 2;
  const DYNAMIC_TAG_NAME$1 = 3;
  const commentEndRegex$1 = /-->/g;
  const comment2EndRegex$1 = />/g;
  const tagEndRegex$1 = new RegExp(`>|${SPACE_CHAR$1}(?:(${NAME_CHAR$1}+)(${SPACE_CHAR$1}*=${SPACE_CHAR$1}*(?:${ATTR_VALUE_CHAR$1}|("|')|))|$)`, "g");
  const ENTIRE_MATCH$1 = 0;
  const ATTRIBUTE_NAME$1 = 1;
  const SPACES_AND_EQUALS$1 = 2;
  const QUOTE_CHAR$1 = 3;
  const singleQuoteAttrEndRegex$1 = /'/g;
  const doubleQuoteAttrEndRegex$1 = /"/g;
  const rawTextElement$1 = /^(?:script|style|textarea)$/i;
  const HTML_RESULT$1 = 1;
  const SVG_RESULT$1 = 2;
  const ATTRIBUTE_PART$1 = 1;
  const CHILD_PART$1 = 2;
  const PROPERTY_PART$1 = 3;
  const BOOLEAN_ATTRIBUTE_PART$1 = 4;
  const EVENT_PART$1 = 5;
  const ELEMENT_PART$1 = 6;
  const COMMENT_PART$1 = 7;
  const tag = (type) => (strings, ...values) => {
    if (strings.some((s) => s === void 0)) {
      console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
    }
    return {
      ["_$litType$"]: type,
      strings,
      values
    };
  };
  const html$1 = tag(HTML_RESULT$1);
  const noChange$1 = Symbol.for("lit-noChange");
  const nothing$1 = Symbol.for("lit-nothing");
  const templateCache$1 = new WeakMap();
  const walker$1 = d$1.createTreeWalker(d$1, 129, null, false);
  let sanitizerFactoryInternal$1 = noopSanitizer$1;
  const getTemplateHtml$1 = (strings, type) => {
    const l = strings.length - 1;
    const attrNames = [];
    let html2 = type === SVG_RESULT$1 ? "<svg>" : "";
    let rawTextEndRegex;
    let regex = textEndRegex$1;
    for (let i = 0; i < l; i++) {
      const s = strings[i];
      let attrNameEndIndex = -1;
      let attrName;
      let lastIndex = 0;
      let match;
      while (lastIndex < s.length) {
        regex.lastIndex = lastIndex;
        match = regex.exec(s);
        if (match === null) {
          break;
        }
        lastIndex = regex.lastIndex;
        if (regex === textEndRegex$1) {
          if (match[COMMENT_START$1] === "!--") {
            regex = commentEndRegex$1;
          } else if (match[COMMENT_START$1] !== void 0) {
            regex = comment2EndRegex$1;
          } else if (match[TAG_NAME$1] !== void 0) {
            if (rawTextElement$1.test(match[TAG_NAME$1])) {
              rawTextEndRegex = new RegExp(`</${match[TAG_NAME$1]}`, "g");
            }
            regex = tagEndRegex$1;
          } else if (match[DYNAMIC_TAG_NAME$1] !== void 0) {
            regex = tagEndRegex$1;
          }
        } else if (regex === tagEndRegex$1) {
          if (match[ENTIRE_MATCH$1] === ">") {
            regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$1;
            attrNameEndIndex = -1;
          } else if (match[ATTRIBUTE_NAME$1] === void 0) {
            attrNameEndIndex = -2;
          } else {
            attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS$1].length;
            attrName = match[ATTRIBUTE_NAME$1];
            regex = match[QUOTE_CHAR$1] === void 0 ? tagEndRegex$1 : match[QUOTE_CHAR$1] === '"' ? doubleQuoteAttrEndRegex$1 : singleQuoteAttrEndRegex$1;
          }
        } else if (regex === doubleQuoteAttrEndRegex$1 || regex === singleQuoteAttrEndRegex$1) {
          regex = tagEndRegex$1;
        } else if (regex === commentEndRegex$1 || regex === comment2EndRegex$1) {
          regex = textEndRegex$1;
        } else {
          regex = tagEndRegex$1;
          rawTextEndRegex = void 0;
        }
      }
      {
        console.assert(attrNameEndIndex === -1 || regex === tagEndRegex$1 || regex === singleQuoteAttrEndRegex$1 || regex === doubleQuoteAttrEndRegex$1, "unexpected parse state B");
      }
      const end = regex === tagEndRegex$1 && strings[i + 1].startsWith("/>") ? " " : "";
      html2 += regex === textEndRegex$1 ? s + nodeMarker$1 : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix$1 + s.slice(attrNameEndIndex)) + marker$1 + end : s + marker$1 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
    }
    const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT$1 ? "</svg>" : "");
    return [policy$1 !== void 0 ? policy$1.createHTML(htmlResult) : htmlResult, attrNames];
  };
  class Template$1 {
    constructor({strings, ["_$litType$"]: type}, options) {
      this.parts = [];
      let node;
      let nodeIndex = 0;
      let attrNameIndex = 0;
      const partCount = strings.length - 1;
      const parts = this.parts;
      const [html2, attrNames] = getTemplateHtml$1(strings, type);
      this.el = Template$1.createElement(html2, options);
      walker$1.currentNode = this.el.content;
      if (type === SVG_RESULT$1) {
        const content = this.el.content;
        const svgElement = content.firstChild;
        svgElement.remove();
        content.append(...svgElement.childNodes);
      }
      while ((node = walker$1.nextNode()) !== null && parts.length < partCount) {
        if (node.nodeType === 1) {
          if (node.hasAttributes()) {
            const attrsToRemove = [];
            for (const name of node.getAttributeNames()) {
              if (name.endsWith(boundAttributeSuffix$1) || name.startsWith(marker$1)) {
                const realName = attrNames[attrNameIndex++];
                attrsToRemove.push(name);
                if (realName !== void 0) {
                  const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$1);
                  const statics = value.split(marker$1);
                  const m = /([.?@])?(.*)/.exec(realName);
                  parts.push({
                    type: ATTRIBUTE_PART$1,
                    index: nodeIndex,
                    name: m[2],
                    strings: statics,
                    ctor: m[1] === "." ? PropertyPart$1 : m[1] === "?" ? BooleanAttributePart$1 : m[1] === "@" ? EventPart$1 : AttributePart$1
                  });
                } else {
                  parts.push({
                    type: ELEMENT_PART$1,
                    index: nodeIndex
                  });
                }
              }
            }
            for (const name of attrsToRemove) {
              node.removeAttribute(name);
            }
          }
          if (rawTextElement$1.test(node.tagName)) {
            const strings2 = node.textContent.split(marker$1);
            const lastIndex = strings2.length - 1;
            if (lastIndex > 0) {
              node.textContent = trustedTypes$1 ? trustedTypes$1.emptyScript : "";
              for (let i = 0; i < lastIndex; i++) {
                node.append(strings2[i], createMarker$1());
                walker$1.nextNode();
                parts.push({type: CHILD_PART$1, index: ++nodeIndex});
              }
              node.append(strings2[lastIndex], createMarker$1());
            }
          }
        } else if (node.nodeType === 8) {
          const data = node.data;
          if (data === markerMatch$1) {
            parts.push({type: CHILD_PART$1, index: nodeIndex});
          } else {
            let i = -1;
            while ((i = node.data.indexOf(marker$1, i + 1)) !== -1) {
              parts.push({type: COMMENT_PART$1, index: nodeIndex});
              i += marker$1.length - 1;
            }
          }
        }
        nodeIndex++;
      }
    }
    static createElement(html2, _options) {
      const el = d$1.createElement("template");
      el.innerHTML = html2;
      return el;
    }
  }
  function resolveDirective$1(part, value, parent = part, attributeIndex) {
    var _a2, _b2, _c2;
    var _d2;
    if (value === noChange$1) {
      return value;
    }
    let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
    const nextDirectiveConstructor = isPrimitive$1(value) ? void 0 : value["_$litDirective$"];
    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
      (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
      if (nextDirectiveConstructor === void 0) {
        currentDirective = void 0;
      } else {
        currentDirective = new nextDirectiveConstructor(part);
        currentDirective._$initialize(part, parent, attributeIndex);
      }
      if (attributeIndex !== void 0) {
        ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
      } else {
        parent.__directive = currentDirective;
      }
    }
    if (currentDirective !== void 0) {
      value = resolveDirective$1(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
    }
    return value;
  }
  class TemplateInstance$1 {
    constructor(template, parent) {
      this._parts = [];
      this._$disconnectableChildren = void 0;
      this._$template = template;
      this._$parent = parent;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(options) {
      var _a2;
      const {
        el: {content},
        parts
      } = this._$template;
      const fragment = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d$1).importNode(content, true);
      walker$1.currentNode = fragment;
      let node = walker$1.nextNode();
      let nodeIndex = 0;
      let partIndex = 0;
      let templatePart = parts[0];
      while (templatePart !== void 0) {
        if (nodeIndex === templatePart.index) {
          let part;
          if (templatePart.type === CHILD_PART$1) {
            part = new ChildPart$1(node, node.nextSibling, this, options);
          } else if (templatePart.type === ATTRIBUTE_PART$1) {
            part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
          } else if (templatePart.type === ELEMENT_PART$1) {
            part = new ElementPart$1(node, this, options);
          }
          this._parts.push(part);
          templatePart = parts[++partIndex];
        }
        if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
          node = walker$1.nextNode();
          nodeIndex++;
        }
      }
      return fragment;
    }
    _update(values) {
      let i = 0;
      for (const part of this._parts) {
        if (part !== void 0) {
          if (part.strings !== void 0) {
            part._$setValue(values, part, i);
            i += part.strings.length - 2;
          } else {
            part._$setValue(values[i]);
          }
        }
        i++;
      }
    }
  }
  class ChildPart$1 {
    constructor(startNode, endNode, parent, options) {
      this.type = CHILD_PART$1;
      this.__isConnected = true;
      this._$disconnectableChildren = void 0;
      this._$startNode = startNode;
      this._$endNode = endNode;
      this._$parent = parent;
      this.options = options;
      {
        this._textSanitizer = void 0;
      }
    }
    get _$isConnected() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
    }
    get parentNode() {
      return wrap$2(this._$startNode).parentNode;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
      value = resolveDirective$1(this, value, directiveParent);
      if (isPrimitive$1(value)) {
        if (value === nothing$1 || value == null || value === "") {
          if (this._$committedValue !== nothing$1) {
            this._$clear();
          }
          this._$committedValue = nothing$1;
        } else if (value !== this._$committedValue && value !== noChange$1) {
          this._commitText(value);
        }
      } else if (value["_$litType$"] !== void 0) {
        this._commitTemplateResult(value);
      } else if (value.nodeType !== void 0) {
        this._commitNode(value);
      } else if (isIterable$1(value)) {
        this._commitIterable(value);
      } else {
        this._commitText(value);
      }
    }
    _insert(node, ref = this._$endNode) {
      return wrap$2(wrap$2(this._$startNode).parentNode).insertBefore(node, ref);
    }
    _commitNode(value) {
      var _a2;
      if (this._$committedValue !== value) {
        this._$clear();
        if (sanitizerFactoryInternal$1 !== noopSanitizer$1) {
          const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
          if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
            this._insert(new Text("/* lit-html will not write TemplateResults to scripts and styles */"));
            return;
          }
        }
        this._$committedValue = this._insert(value);
      }
    }
    _commitText(value) {
      const node = wrap$2(this._$startNode).nextSibling;
      if (node !== null && node.nodeType === 3 && (this._$endNode === null ? wrap$2(node).nextSibling === null : node === wrap$2(this._$endNode).previousSibling)) {
        {
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer$1();
          }
          value = this._textSanitizer(value);
        }
        node.data = value;
      } else {
        {
          const textNode = document.createTextNode("");
          this._commitNode(textNode);
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer$1();
          }
          value = this._textSanitizer(value);
          textNode.data = value;
        }
      }
      this._$committedValue = value;
    }
    _commitTemplateResult(result) {
      var _a2;
      const {values, ["_$litType$"]: type} = result;
      const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template$1.createElement(type.h, this.options)), type);
      if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template) {
        this._$committedValue._update(values);
      } else {
        const instance = new TemplateInstance$1(template, this);
        const fragment = instance._clone(this.options);
        instance._update(values);
        this._commitNode(fragment);
        this._$committedValue = instance;
      }
    }
    _$getTemplate(result) {
      let template = templateCache$1.get(result.strings);
      if (template === void 0) {
        templateCache$1.set(result.strings, template = new Template$1(result));
      }
      return template;
    }
    _commitIterable(value) {
      if (!isArray$1(this._$committedValue)) {
        this._$committedValue = [];
        this._$clear();
      }
      const itemParts = this._$committedValue;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        if (partIndex === itemParts.length) {
          itemParts.push(itemPart = new ChildPart$1(this._insert(createMarker$1()), this._insert(createMarker$1()), this, this.options));
        } else {
          itemPart = itemParts[partIndex];
        }
        itemPart._$setValue(item);
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        this._$clear(itemPart && wrap$2(itemPart._$endNode).nextSibling, partIndex);
        itemParts.length = partIndex;
      }
    }
    _$clear(start = wrap$2(this._$startNode).nextSibling, from) {
      var _a2;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from);
      while (start && start !== this._$endNode) {
        const n = wrap$2(start).nextSibling;
        wrap$2(start).remove();
        start = n;
      }
    }
    setConnected(isConnected) {
      var _a2;
      if (this._$parent === void 0) {
        this.__isConnected = isConnected;
        (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
      } else {
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      }
    }
  }
  class AttributePart$1 {
    constructor(element, name, strings, parent, options) {
      this.type = ATTRIBUTE_PART$1;
      this._$committedValue = nothing$1;
      this._$disconnectableChildren = void 0;
      this.element = element;
      this.name = name;
      this._$parent = parent;
      this.options = options;
      if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
        this._$committedValue = new Array(strings.length - 1).fill(nothing$1);
        this.strings = strings;
      } else {
        this._$committedValue = nothing$1;
      }
      {
        this._sanitizer = void 0;
      }
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
      const strings = this.strings;
      let change = false;
      if (strings === void 0) {
        value = resolveDirective$1(this, value, directiveParent, 0);
        change = !isPrimitive$1(value) || value !== this._$committedValue && value !== noChange$1;
        if (change) {
          this._$committedValue = value;
        }
      } else {
        const values = value;
        value = strings[0];
        let i, v;
        for (i = 0; i < strings.length - 1; i++) {
          v = resolveDirective$1(this, values[valueIndex + i], directiveParent, i);
          if (v === noChange$1) {
            v = this._$committedValue[i];
          }
          change || (change = !isPrimitive$1(v) || v !== this._$committedValue[i]);
          if (v === nothing$1) {
            value = nothing$1;
          } else if (value !== nothing$1) {
            value += (v !== null && v !== void 0 ? v : "") + strings[i + 1];
          }
          this._$committedValue[i] = v;
        }
      }
      if (change && !noCommit) {
        this._commitValue(value);
      }
    }
    _commitValue(value) {
      if (value === nothing$1) {
        wrap$2(this.element).removeAttribute(this.name);
      } else {
        {
          if (this._sanitizer === void 0) {
            this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
          }
          value = this._sanitizer(value !== null && value !== void 0 ? value : "");
        }
        wrap$2(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
      }
    }
  }
  class PropertyPart$1 extends AttributePart$1 {
    constructor() {
      super(...arguments);
      this.type = PROPERTY_PART$1;
    }
    _commitValue(value) {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
        }
        value = this._sanitizer(value);
      }
      this.element[this.name] = value === nothing$1 ? void 0 : value;
    }
  }
  class BooleanAttributePart$1 extends AttributePart$1 {
    constructor() {
      super(...arguments);
      this.type = BOOLEAN_ATTRIBUTE_PART$1;
    }
    _commitValue(value) {
      if (value && value !== nothing$1) {
        wrap$2(this.element).setAttribute(this.name, "");
      } else {
        wrap$2(this.element).removeAttribute(this.name);
      }
    }
  }
  class EventPart$1 extends AttributePart$1 {
    constructor() {
      super(...arguments);
      this.type = EVENT_PART$1;
    }
    _$setValue(newListener, directiveParent = this) {
      var _a2;
      newListener = (_a2 = resolveDirective$1(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing$1;
      if (newListener === noChange$1) {
        return;
      }
      const oldListener = this._$committedValue;
      const shouldRemoveListener = newListener === nothing$1 && oldListener !== nothing$1 || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
      const shouldAddListener = newListener !== nothing$1 && (oldListener === nothing$1 || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.name, this, oldListener);
      }
      if (shouldAddListener) {
        this.element.addEventListener(this.name, this, newListener);
      }
      this._$committedValue = newListener;
    }
    handleEvent(event) {
      var _a2, _b2;
      if (typeof this._$committedValue === "function") {
        this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
      } else {
        this._$committedValue.handleEvent(event);
      }
    }
  }
  class ElementPart$1 {
    constructor(element, parent, options) {
      this.element = element;
      this.type = ELEMENT_PART$1;
      this._$disconnectableChildren = void 0;
      this._$parent = parent;
      this.options = options;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value) {
      resolveDirective$1(this, value);
    }
  }
  (_d$1 = (_c$1 = globalThis)["litHtmlPlatformSupport"]) === null || _d$1 === void 0 ? void 0 : _d$1.call(_c$1, Template$1, ChildPart$1);
  ((_e$1 = (_f$1 = globalThis)["litHtmlVersions"]) !== null && _e$1 !== void 0 ? _e$1 : _f$1["litHtmlVersions"] = []).push("2.0.0-rc.4");
  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const stringsCache = new Map();
  const withStatic = (coreTag) => (strings, ...values) => {
    var _a2;
    const l = values.length;
    let staticValue;
    let dynamicValue;
    const staticStrings = [];
    const dynamicValues = [];
    let i = 0;
    let hasStatics = false;
    let s;
    while (i < l) {
      s = strings[i];
      while (i < l && (dynamicValue = values[i], staticValue = (_a2 = dynamicValue) === null || _a2 === void 0 ? void 0 : _a2["_$litStatic$"]) !== void 0) {
        s += staticValue + strings[++i];
        hasStatics = true;
      }
      dynamicValues.push(dynamicValue);
      staticStrings.push(s);
      i++;
    }
    if (i === l) {
      staticStrings.push(strings[l]);
    }
    if (hasStatics) {
      const key = staticStrings.join("$$lit$$");
      strings = stringsCache.get(key);
      if (strings === void 0) {
        stringsCache.set(key, strings = staticStrings);
      }
      values = dynamicValues;
    }
    return coreTag(strings, ...values);
  };
  const html = withStatic(html$1);
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const decorateProperty = ({finisher, descriptor}) => (protoOrDescriptor, name) => {
    var _a2;
    if (name !== void 0) {
      const ctor = protoOrDescriptor.constructor;
      if (descriptor !== void 0) {
        Object.defineProperty(protoOrDescriptor, name, descriptor(name));
      }
      finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
    } else {
      const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
      const info = descriptor != void 0 ? {
        kind: "method",
        placement: "prototype",
        key,
        descriptor: descriptor(protoOrDescriptor.key)
      } : __spreadProps(__spreadValues({}, protoOrDescriptor), {key});
      if (finisher != void 0) {
        info.finisher = function(ctor) {
          finisher(ctor, key);
        };
      }
      return info;
    }
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  function queryAsync(selector) {
    return decorateProperty({
      descriptor: (_name) => ({
        get() {
          return __async(this, null, function* () {
            var _a2;
            yield this.updateComplete;
            return (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
          });
        },
        enumerable: true,
        configurable: true
      })
    });
  }
  var __isNode = () => {
    return typeof process !== "undefined" && process.release && process.release.name === "node";
  };
  var _a$2, _b$2, _c$2;
  class SDatePickerComponentInterface extends SInterface {
  }
  SDatePickerComponentInterface.definition = {
    name: {
      type: "String",
      required: true
    },
    value: {
      type: "String"
    },
    placeholder: {
      type: "String"
    },
    format: {
      type: "String",
      default: (_a$2 = SSugarConfig.get("datetime.dateFormat")) !== null && _a$2 !== void 0 ? _a$2 : "YYYY-MM-DD"
    },
    firstDay: {
      type: "Number",
      description: "Specify the first day of the week. 0 is sunday, 1 monday, etc...",
      default: 1
    },
    minDate: {
      type: "String",
      description: "the minimum/earliest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())"
    },
    maxDate: {
      type: "String",
      description: "the maximum/latest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())"
    },
    disableWeekends: {
      type: "Boolean",
      description: "disallow selection of Saturdays or Sundays",
      default: false
    },
    yearRange: {
      type: {
        type: "Array<Number>",
        splitChars: [","]
      },
      description: "number of years either side (e.g. 10) or array of upper/lower range (e.g. [1900,2015])"
    },
    rtl: {
      type: "Boolean",
      description: "reverse the calendar for right-to-left languages",
      default: !__isNode() ? ((_b$2 = document.querySelector("html")) === null || _b$2 === void 0 ? void 0 : _b$2.getAttribute("dir")) === "rtl" : false
    },
    i18n: {
      type: "String",
      description: "language defaults for month and weekday names",
      default: (_c$2 = SSugarConfig.get("datetime.i18n")) !== null && _c$2 !== void 0 ? _c$2 : {
        previousMonth: "Previous Month",
        nextMonth: "Next Month",
        months: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      }
    },
    numberOfMonths: {
      type: "Number",
      description: "number of visible calendars",
      default: 1
    },
    events: {
      type: {
        type: "Array<String>",
        splitChars: [","]
      },
      description: `array of dates that you would like to differentiate from regular days (e.g. ['Sat Jun 28 2017', 'Sun Jun 29 2017', 'Tue Jul 01 2017',])`,
      default: []
    },
    button: {
      type: "Boolean",
      default: true
    },
    arrowIcon: {
      type: "String",
      default: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.122 24l-4.122-4 8-8-8-8 4.122-4 11.878 12z"/></svg>'
    },
    calendarIcon: {
      type: "String",
      default: '<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="calendar-alt" class="svg-inline--fa fa-calendar-alt fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"></path></svg>'
    }
  };
  function plainObject$3(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$3(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$3(newObj[key]) && plainObject$3(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function whenInteract(elm, settings) {
    return new Promise((resolve, reject) => {
      settings = __deepMerge$3({
        mouse: {
          over: true,
          out: true,
          click: true
        },
        touch: {
          start: true,
          end: true
        },
        focus: true
      }, settings !== null && settings !== void 0 ? settings : {});
      function interacted(interaction) {
        resolve(interaction);
        elm.removeEventListener("mouseover", mouseover);
        elm.removeEventListener("mouseout", mouseout);
        elm.removeEventListener("click", click);
        elm.removeEventListener("touchstart", touchstart);
        elm.removeEventListener("touchend", touchend);
        elm.removeEventListener("focus", focus);
        elm.removeEventListener("focusin", focus);
      }
      function mouseover(e) {
        interacted("mouseover");
      }
      if (settings.mouse === true || settings.mouse.over) {
        elm.addEventListener("mouseover", mouseover);
      }
      function mouseout(e) {
        interacted("mouseout");
      }
      if (settings.mouse === true || settings.mouse.out) {
        elm.addEventListener("mouseout", mouseout);
      }
      function click(e) {
        interacted("click");
      }
      if (settings.mouse === true || settings.mouse.click) {
        elm.addEventListener("click", click);
      }
      function touchstart(e) {
        interacted("touchstart");
      }
      if (settings.touch === true || settings.touch.start) {
        elm.addEventListener("touchstart", touchstart);
      }
      function touchend(e) {
        interacted("touchend");
      }
      if (settings.touch === true || settings.touch.start) {
        elm.addEventListener("touchend", touchend);
      }
      function focus(e) {
        interacted("focus");
      }
      if (settings.focus === true) {
        elm.addEventListener("focus", focus);
        elm.addEventListener("focusin", focus);
      }
    });
  }
  var __css$4 = "s-date-picker {\n    display: inline-block;\n}\n.s-date-picker {\n    display: flex;\n    width: 100%;\n}\n\n.s-date-picker__input {\n    flex-grow: 1;\n    padding-inline: calc(var(--s-theme-ui-datePicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-datePicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n.s-date-picker__button {\n    padding-inline: calc(var(--s-theme-ui-datePicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-datePicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__input {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n        }\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__button {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__button {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n            order: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__input {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n            order: 1;\n        }\n\n.s-date-picker__button svg {\n        height: 1em;\n    }\n\n.s-date-picker__button svg,\n        .s-date-picker__button svg > * {\n            box-shadow: 0px 0px 3px 0 hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + -10) * 1%),var(--s-theme-color-ui-a, 1));\n        }\n";
  var __themeCss = "/**\n * This theme is an example to show how you can create your own.\n */\n\n.pika-lendar {\n    width: auto;\n}\n\n.pika-single.s-pikaday {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-foreground-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-main-foreground-a, 1));\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-surface-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-main-surface-a, 1));\n    border: 1px solid hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-border-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-border-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-border-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-border-a, 1));box-shadow: var(--s-theme-depth-100, 0);\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-label {\n    background-color: transparent;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    top: -0.5em;\n}\n\n.s-pikaday .pika-prev,\n.s-pikaday .is-rtl .pika-next,\n.s-pikaday .pika-next,\n.s-pikaday .is-rtl .pika-prev {\n    background: none;\n    position: relative;\n    display: inline-block;\n    font-size: 0;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    overflow: visible;\n    background: red;\n    opacity: 1;\n    width: 1em;\n    height: 1em;\n    opacity: 0.7;\n}\n\n.s-pikaday .pika-prev:hover,\n    .s-pikaday .pika-prev:focus,\n    .s-pikaday .is-rtl .pika-next:hover,\n    .s-pikaday .is-rtl .pika-next:focus,\n    .s-pikaday .pika-next:hover,\n    .s-pikaday .pika-next:focus,\n    .s-pikaday .is-rtl .pika-prev:hover,\n    .s-pikaday .is-rtl .pika-prev:focus {\n        opacity: 1;\n    }\n\n.s-pikaday .pika-prev:after, .s-pikaday .is-rtl .pika-next:after, .s-pikaday .pika-next:after, .s-pikaday .is-rtl .pika-prev:after {\n        content: '\u276F';\n        color: inherit;\n        font-size: 1rem;\n        position: absolute;\n        top: 0;\n        left: -2.2em;\n    }\n.s-pikaday .pika-prev:after, .s-pikaday.is-rtl .pika-next:after {\n        transform: rotate(180deg);\n        left: 1em;\n    }\n.s-pikaday.is-rtl .pika-prev:after {\n        transform: rotate(0deg) !important;\n        left: -2em;\n    }\n\n.s-pikaday .pika-table {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-table th * {\n    text-decoration: none;\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n}\n\n.s-pikaday .pika-button {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-week {\n    text-decoration: none;\n}\n\n.s-pikaday .is-today .pika-button {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    outline: none;\n}\n\n.s-pikaday .is-selected .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 0.5));\n    box-shadow: none !important;\n}\n\n.s-pikaday .is-disabled .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    opacity: 0.3;\n}\n\n.s-pikaday .pika-button:hover {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-foreground-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-foreground-a, 1)) !important;\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1)) !important;\n}\n";
  var __baseCss$1 = `@charset "UTF-8";

/*!
 * Pikaday
 * Copyright \xA9 2014 David Bushell | BSD & MIT license | https://dbushell.com/
 */

.pika-single {
    z-index: 9999;
    display: block;
    position: relative;
    color: #333;
    background: #fff;
    border: 1px solid #ccc;
    border-bottom-color: #bbb;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

/*
clear child float (pika-lendar), using the famous micro clearfix hack
http://nicolasgallagher.com/micro-clearfix-hack/
*/
.pika-single:before,
.pika-single:after {
    content: " ";
    display: table;
}
.pika-single:after { clear: both }

.pika-single.is-hidden {
    display: none;
}

.pika-single.is-bound {
    position: absolute;
    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);
}

.pika-lendar {
    float: left;
    width: 240px;
    margin: 8px;
}

.pika-title {
    position: relative;
    text-align: center;
}

.pika-label {
    display: inline-block;
    position: relative;
    z-index: 9999;
    overflow: hidden;
    margin: 0;
    padding: 5px 3px;
    font-size: 14px;
    line-height: 20px;
    font-weight: bold;
    background-color: #fff;
}
.pika-title select {
    cursor: pointer;
    position: absolute;
    z-index: 9998;
    margin: 0;
    left: 0;
    top: 5px;
    opacity: 0;
}

.pika-prev,
.pika-next {
    display: block;
    cursor: pointer;
    position: relative;
    outline: none;
    border: 0;
    padding: 0;
    width: 20px;
    height: 30px;
    /* hide text using text-indent trick, using width value (it's enough) */
    text-indent: 20px;
    white-space: nowrap;
    overflow: hidden;
    background-color: transparent;
    background-position: center center;
    background-repeat: no-repeat;
    background-size: 75% 75%;
    opacity: .5;
}

.pika-prev:hover,
.pika-next:hover {
    opacity: 1;
}

.pika-prev,
.is-rtl .pika-next {
    float: left;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');
}

.pika-next,
.is-rtl .pika-prev {
    float: right;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');
}

.pika-prev.is-disabled,
.pika-next.is-disabled {
    cursor: default;
    opacity: .2;
}

.pika-select {
    display: inline-block;
}

.pika-table {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    border: 0;
}

.pika-table th,
.pika-table td {
    width: 14.285714285714286%;
    padding: 0;
}

.pika-table th {
    color: #999;
    font-size: 12px;
    line-height: 25px;
    font-weight: bold;
    text-align: center;
}

.pika-button {
    cursor: pointer;
    display: block;
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    outline: none;
    border: 0;
    margin: 0;
    width: 100%;
    padding: 5px;
    color: #666;
    font-size: 12px;
    line-height: 15px;
    text-align: right;
    background: #f5f5f5;
    height: initial;
}

.pika-week {
    font-size: 11px;
    color: #999;
}

.is-today .pika-button {
    color: #33aaff;
    font-weight: bold;
}

.is-selected .pika-button,
.has-event .pika-button {
    color: #fff;
    font-weight: bold;
    background: #33aaff;
    box-shadow: inset 0 1px 3px #178fe5;
    border-radius: 3px;
}

.has-event .pika-button {
    background: #005da9;
    box-shadow: inset 0 1px 3px #0076c9;
}

.is-disabled .pika-button,
.is-inrange .pika-button {
    background: #D5E9F7;
}

.is-startrange .pika-button {
    color: #fff;
    background: #6CB31D;
    box-shadow: none;
    border-radius: 3px;
}

.is-endrange .pika-button {
    color: #fff;
    background: #33aaff;
    box-shadow: none;
    border-radius: 3px;
}

.is-disabled .pika-button {
    pointer-events: none;
    cursor: default;
    color: #999;
    opacity: .3;
}

.is-outside-current-month .pika-button {
    color: #999;
    opacity: .3;
}

.is-selection-disabled {
    pointer-events: none;
    cursor: default;
}

.pika-button:hover,
.pika-row.pick-whole-week:hover .pika-button {
    color: #fff;
    background: #ff8000;
    box-shadow: none;
    border-radius: 3px;
}

/* styling for abbr */
.pika-table abbr {
    border-bottom: none;
    cursor: help;
}
`;
  var __decorate$1 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d2 = decorators[i])
          r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter$8 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SDatePicker extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {
          interface: SDatePickerComponentInterface
        }
      });
    }
    static get properties() {
      return SLitComponent.properties({}, SDatePickerComponentInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(`
                ${__baseCss$1}
                ${__css$4}
                ${__themeCss}
            `)}
        `;
    }
    firstUpdated() {
      return __awaiter$8(this, void 0, void 0, function* () {
        const $input = yield this._$input;
        let $button;
        if (this.props.button)
          $button = yield this._$button;
        yield whenInteract(this);
        const _this = this;
        this._picker = new __pikaday({
          field: $input,
          format: this.props.format,
          trigger: $button,
          firstDay: this.props.firstDay,
          minDate: this.parseDate(this.props.minDate),
          maxDate: this.parseDate(this.props.maxDate),
          disableWeekends: this.props.disableWeekends,
          yearRange: this.props.yearRange,
          isRTL: this.props.rtl,
          i18n: this.props.i18n,
          numberOfMonths: this.props.numberOfMonths,
          events: this.props.events,
          defaultDate: this.props.value,
          theme: this.props.defaultStyle ? "s-pikaday" : "",
          toString(date, format) {
            return _this.dateToString(date, format);
          },
          parse(dateString, format) {
            return _this.parseDate(dateString, format);
          },
          onSelect: () => {
            this._dispatchEvent("select");
          },
          onOpen: () => {
            this._dispatchEvent("open");
          },
          onClose: () => {
            this._dispatchEvent("close");
          },
          onDraw: () => {
            this._dispatchEvent("draw");
          }
        });
        Array.from(this.classList).forEach((cls) => {
          if (cls.match(/^s-cs/))
            this._picker.el.classList.add(cls);
        });
        [
          "toString",
          "getDate",
          "setDate",
          "getMoment",
          "clear",
          "gotoDate",
          "gotoToday",
          "gotoMonth",
          "nextMonth",
          "prevMonth",
          "gotoYear",
          "setMinDate",
          "setMaxDate",
          "setStartRange",
          "setEndRange",
          "isVisible",
          "show",
          "adjustPosition",
          "hide",
          "destroy"
        ].forEach((key) => {
          this[key] = this._picker[key].bind(this._picker);
        });
      });
    }
    parseDate(dateString, format = this.props.format) {
      return hooks(dateString, format).toDate();
    }
    dateToString(date, format = this.props.format) {
      return hooks(date).format(format);
    }
    _dispatchEvent(eventName) {
      const event = new CustomEvent(eventName, {
        detail: {
          dateStr: this._picker.toString(),
          date: this._picker.getDate()
        }
      });
      this.dispatchEvent(event);
    }
    render() {
      return html$2`
            <div class="${this.componentUtils.className("")}">
                <input
                    class="${this.componentUtils.className("__input", "s-input")}"
                    type="text"
                    name="${this.name}"
                    ?rtl="${this.rtl}"
                    placeholder="${this.placeholder}"
                    autocomplete="off"
                />
                ${this.button ? html$2`
                          <button onclick="return false" class="${this.componentUtils.className("__button", "s-btn")}">
                              ${html([this.calendarIcon])}
                          </button>
                      ` : ""}
            </div>
        `;
    }
  }
  __decorate$1([queryAsync("input")], SDatePicker.prototype, "_$input", void 0);
  __decorate$1([queryAsync("button")], SDatePicker.prototype, "_$button", void 0);
  function define$6(props = {}, tagName = "s-date-picker") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SDatePicker);
  }
  var pickr_min = {exports: {}};
  /*! Pickr 1.8.1 MIT | https://github.com/Simonwep/pickr */
  (function(module2, exports) {
    !function(t, e) {
      module2.exports = e();
    }(window, function() {
      return function(t) {
        var e = {};
        function o(n) {
          if (e[n])
            return e[n].exports;
          var i = e[n] = {i: n, l: false, exports: {}};
          return t[n].call(i.exports, i, i.exports, o), i.l = true, i.exports;
        }
        return o.m = t, o.c = e, o.d = function(t2, e2, n) {
          o.o(t2, e2) || Object.defineProperty(t2, e2, {enumerable: true, get: n});
        }, o.r = function(t2) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t2, "__esModule", {value: true});
        }, o.t = function(t2, e2) {
          if (1 & e2 && (t2 = o(t2)), 8 & e2)
            return t2;
          if (4 & e2 && typeof t2 == "object" && t2 && t2.__esModule)
            return t2;
          var n = Object.create(null);
          if (o.r(n), Object.defineProperty(n, "default", {enumerable: true, value: t2}), 2 & e2 && typeof t2 != "string")
            for (var i in t2)
              o.d(n, i, function(e3) {
                return t2[e3];
              }.bind(null, i));
          return n;
        }, o.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return o.d(e2, "a", e2), e2;
        }, o.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, o.p = "", o(o.s = 0);
      }([function(t, e, o) {
        o.r(e);
        var n = {};
        function i(t2, e2, o2, n2, i2 = {}) {
          e2 instanceof HTMLCollection || e2 instanceof NodeList ? e2 = Array.from(e2) : Array.isArray(e2) || (e2 = [e2]), Array.isArray(o2) || (o2 = [o2]);
          for (const r2 of e2)
            for (const e3 of o2)
              r2[t2](e3, n2, __spreadValues({capture: false}, i2));
          return Array.prototype.slice.call(arguments, 1);
        }
        o.r(n), o.d(n, "on", function() {
          return r;
        }), o.d(n, "off", function() {
          return s;
        }), o.d(n, "createElementFromString", function() {
          return a;
        }), o.d(n, "createFromTemplate", function() {
          return l;
        }), o.d(n, "eventPath", function() {
          return c;
        }), o.d(n, "resolveElement", function() {
          return p;
        }), o.d(n, "adjustableInputNumbers", function() {
          return u;
        });
        const r = i.bind(null, "addEventListener"), s = i.bind(null, "removeEventListener");
        function a(t2) {
          const e2 = document.createElement("div");
          return e2.innerHTML = t2.trim(), e2.firstElementChild;
        }
        function l(t2) {
          const e2 = (t3, e3) => {
            const o3 = t3.getAttribute(e3);
            return t3.removeAttribute(e3), o3;
          }, o2 = (t3, n2 = {}) => {
            const i2 = e2(t3, ":obj"), r2 = e2(t3, ":ref"), s2 = i2 ? n2[i2] = {} : n2;
            r2 && (n2[r2] = t3);
            for (const n3 of Array.from(t3.children)) {
              const t4 = e2(n3, ":arr"), i3 = o2(n3, t4 ? {} : s2);
              t4 && (s2[t4] || (s2[t4] = [])).push(Object.keys(i3).length ? i3 : n3);
            }
            return n2;
          };
          return o2(a(t2));
        }
        function c(t2) {
          let e2 = t2.path || t2.composedPath && t2.composedPath();
          if (e2)
            return e2;
          let o2 = t2.target.parentElement;
          for (e2 = [t2.target, o2]; o2 = o2.parentElement; )
            e2.push(o2);
          return e2.push(document, window), e2;
        }
        function p(t2) {
          return t2 instanceof Element ? t2 : typeof t2 == "string" ? t2.split(/>>/g).reduce((t3, e2, o2, n2) => (t3 = t3.querySelector(e2), o2 < n2.length - 1 ? t3.shadowRoot : t3), document) : null;
        }
        function u(t2, e2 = (t3) => t3) {
          function o2(o3) {
            const n2 = [1e-3, 0.01, 0.1][Number(o3.shiftKey || 2 * o3.ctrlKey)] * (o3.deltaY < 0 ? 1 : -1);
            let i2 = 0, r2 = t2.selectionStart;
            t2.value = t2.value.replace(/[\d.]+/g, (t3, o4) => o4 <= r2 && o4 + t3.length >= r2 ? (r2 = o4, e2(Number(t3), n2, i2)) : (i2++, t3)), t2.focus(), t2.setSelectionRange(r2, r2), o3.preventDefault(), t2.dispatchEvent(new Event("input"));
          }
          r(t2, "focus", () => r(window, "wheel", o2, {passive: false})), r(t2, "blur", () => s(window, "wheel", o2));
        }
        const {min: h, max: d, floor: f, round: m} = Math;
        function v(t2, e2, o2) {
          e2 /= 100, o2 /= 100;
          const n2 = f(t2 = t2 / 360 * 6), i2 = t2 - n2, r2 = o2 * (1 - e2), s2 = o2 * (1 - i2 * e2), a2 = o2 * (1 - (1 - i2) * e2), l2 = n2 % 6;
          return [255 * [o2, s2, r2, r2, a2, o2][l2], 255 * [a2, o2, o2, s2, r2, r2][l2], 255 * [r2, r2, a2, o2, o2, s2][l2]];
        }
        function b(t2, e2, o2) {
          const n2 = (2 - (e2 /= 100)) * (o2 /= 100) / 2;
          return n2 !== 0 && (e2 = n2 === 1 ? 0 : n2 < 0.5 ? e2 * o2 / (2 * n2) : e2 * o2 / (2 - 2 * n2)), [t2, 100 * e2, 100 * n2];
        }
        function y(t2, e2, o2) {
          const n2 = h(t2 /= 255, e2 /= 255, o2 /= 255), i2 = d(t2, e2, o2), r2 = i2 - n2;
          let s2, a2;
          if (r2 === 0)
            s2 = a2 = 0;
          else {
            a2 = r2 / i2;
            const n3 = ((i2 - t2) / 6 + r2 / 2) / r2, l2 = ((i2 - e2) / 6 + r2 / 2) / r2, c2 = ((i2 - o2) / 6 + r2 / 2) / r2;
            t2 === i2 ? s2 = c2 - l2 : e2 === i2 ? s2 = 1 / 3 + n3 - c2 : o2 === i2 && (s2 = 2 / 3 + l2 - n3), s2 < 0 ? s2 += 1 : s2 > 1 && (s2 -= 1);
          }
          return [360 * s2, 100 * a2, 100 * i2];
        }
        function g(t2, e2, o2, n2) {
          e2 /= 100, o2 /= 100;
          return [...y(255 * (1 - h(1, (t2 /= 100) * (1 - (n2 /= 100)) + n2)), 255 * (1 - h(1, e2 * (1 - n2) + n2)), 255 * (1 - h(1, o2 * (1 - n2) + n2)))];
        }
        function _(t2, e2, o2) {
          e2 /= 100;
          const n2 = 2 * (e2 *= (o2 /= 100) < 0.5 ? o2 : 1 - o2) / (o2 + e2) * 100, i2 = 100 * (o2 + e2);
          return [t2, isNaN(n2) ? 0 : n2, i2];
        }
        function w(t2) {
          return y(...t2.match(/.{2}/g).map((t3) => parseInt(t3, 16)));
        }
        function A(t2) {
          t2 = t2.match(/^[a-zA-Z]+$/) ? function(t3) {
            if (t3.toLowerCase() === "black")
              return "#000";
            const e3 = document.createElement("canvas").getContext("2d");
            return e3.fillStyle = t3, e3.fillStyle === "#000" ? null : e3.fillStyle;
          }(t2) : t2;
          const e2 = {cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i, rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i}, o2 = (t3) => t3.map((t4) => /^(|\d+)\.\d+|\d+$/.test(t4) ? Number(t4) : void 0);
          let n2;
          t:
            for (const i2 in e2) {
              if (!(n2 = e2[i2].exec(t2)))
                continue;
              const r2 = (t3) => !!n2[2] == (typeof t3 == "number");
              switch (i2) {
                case "cmyk": {
                  const [, t3, e3, r3, s2] = o2(n2);
                  if (t3 > 100 || e3 > 100 || r3 > 100 || s2 > 100)
                    break t;
                  return {values: g(t3, e3, r3, s2), type: i2};
                }
                case "rgba": {
                  const [, , , t3, e3, s2, a2] = o2(n2);
                  if (t3 > 255 || e3 > 255 || s2 > 255 || a2 < 0 || a2 > 1 || !r2(a2))
                    break t;
                  return {values: [...y(t3, e3, s2), a2], a: a2, type: i2};
                }
                case "hexa": {
                  let [, t3] = n2;
                  t3.length !== 4 && t3.length !== 3 || (t3 = t3.split("").map((t4) => t4 + t4).join(""));
                  const e3 = t3.substring(0, 6);
                  let o3 = t3.substring(6);
                  return o3 = o3 ? parseInt(o3, 16) / 255 : void 0, {values: [...w(e3), o3], a: o3, type: i2};
                }
                case "hsla": {
                  const [, , , t3, e3, s2, a2] = o2(n2);
                  if (t3 > 360 || e3 > 100 || s2 > 100 || a2 < 0 || a2 > 1 || !r2(a2))
                    break t;
                  return {values: [..._(t3, e3, s2), a2], a: a2, type: i2};
                }
                case "hsva": {
                  const [, , , t3, e3, s2, a2] = o2(n2);
                  if (t3 > 360 || e3 > 100 || s2 > 100 || a2 < 0 || a2 > 1 || !r2(a2))
                    break t;
                  return {values: [t3, e3, s2, a2], a: a2, type: i2};
                }
              }
            }
          return {values: null, type: null};
        }
        function C(t2 = 0, e2 = 0, o2 = 0, n2 = 1) {
          const i2 = (t3, e3) => (o3 = -1) => e3(~o3 ? t3.map((t4) => Number(t4.toFixed(o3))) : t3), r2 = {h: t2, s: e2, v: o2, a: n2, toHSVA() {
            const t3 = [r2.h, r2.s, r2.v, r2.a];
            return t3.toString = i2(t3, (t4) => `hsva(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${r2.a})`), t3;
          }, toHSLA() {
            const t3 = [...b(r2.h, r2.s, r2.v), r2.a];
            return t3.toString = i2(t3, (t4) => `hsla(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${r2.a})`), t3;
          }, toRGBA() {
            const t3 = [...v(r2.h, r2.s, r2.v), r2.a];
            return t3.toString = i2(t3, (t4) => `rgba(${t4[0]}, ${t4[1]}, ${t4[2]}, ${r2.a})`), t3;
          }, toCMYK() {
            const t3 = function(t4, e3, o3) {
              const n3 = v(t4, e3, o3), i3 = n3[0] / 255, r3 = n3[1] / 255, s2 = n3[2] / 255, a2 = h(1 - i3, 1 - r3, 1 - s2);
              return [100 * (a2 === 1 ? 0 : (1 - i3 - a2) / (1 - a2)), 100 * (a2 === 1 ? 0 : (1 - r3 - a2) / (1 - a2)), 100 * (a2 === 1 ? 0 : (1 - s2 - a2) / (1 - a2)), 100 * a2];
            }(r2.h, r2.s, r2.v);
            return t3.toString = i2(t3, (t4) => `cmyk(${t4[0]}%, ${t4[1]}%, ${t4[2]}%, ${t4[3]}%)`), t3;
          }, toHEXA() {
            const t3 = function(t4, e4, o3) {
              return v(t4, e4, o3).map((t5) => m(t5).toString(16).padStart(2, "0"));
            }(r2.h, r2.s, r2.v), e3 = r2.a >= 1 ? "" : Number((255 * r2.a).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
            return e3 && t3.push(e3), t3.toString = () => "#" + t3.join("").toUpperCase(), t3;
          }, clone: () => C(r2.h, r2.s, r2.v, r2.a)};
          return r2;
        }
        const k = (t2) => Math.max(Math.min(t2, 1), 0);
        function $(t2) {
          const e2 = {options: Object.assign({lock: null, onchange: () => 0, onstop: () => 0}, t2), _keyboard(t3) {
            const {options: o3} = e2, {type: n3, key: i3} = t3;
            if (document.activeElement === o3.wrapper) {
              const {lock: o4} = e2.options, r2 = i3 === "ArrowUp", s2 = i3 === "ArrowRight", a2 = i3 === "ArrowDown", l2 = i3 === "ArrowLeft";
              if (n3 === "keydown" && (r2 || s2 || a2 || l2)) {
                let n4 = 0, i4 = 0;
                o4 === "v" ? n4 = r2 || s2 ? 1 : -1 : o4 === "h" ? n4 = r2 || s2 ? -1 : 1 : (i4 = r2 ? -1 : a2 ? 1 : 0, n4 = l2 ? -1 : s2 ? 1 : 0), e2.update(k(e2.cache.x + 0.01 * n4), k(e2.cache.y + 0.01 * i4)), t3.preventDefault();
              } else
                i3.startsWith("Arrow") && (e2.options.onstop(), t3.preventDefault());
            }
          }, _tapstart(t3) {
            r(document, ["mouseup", "touchend", "touchcancel"], e2._tapstop), r(document, ["mousemove", "touchmove"], e2._tapmove), t3.cancelable && t3.preventDefault(), e2._tapmove(t3);
          }, _tapmove(t3) {
            const {options: o3, cache: n3} = e2, {lock: i3, element: r2, wrapper: s2} = o3, a2 = s2.getBoundingClientRect();
            let l2 = 0, c2 = 0;
            if (t3) {
              const e3 = t3 && t3.touches && t3.touches[0];
              l2 = t3 ? (e3 || t3).clientX : 0, c2 = t3 ? (e3 || t3).clientY : 0, l2 < a2.left ? l2 = a2.left : l2 > a2.left + a2.width && (l2 = a2.left + a2.width), c2 < a2.top ? c2 = a2.top : c2 > a2.top + a2.height && (c2 = a2.top + a2.height), l2 -= a2.left, c2 -= a2.top;
            } else
              n3 && (l2 = n3.x * a2.width, c2 = n3.y * a2.height);
            i3 !== "h" && (r2.style.left = `calc(${l2 / a2.width * 100}% - ${r2.offsetWidth / 2}px)`), i3 !== "v" && (r2.style.top = `calc(${c2 / a2.height * 100}% - ${r2.offsetHeight / 2}px)`), e2.cache = {x: l2 / a2.width, y: c2 / a2.height};
            const p2 = k(l2 / a2.width), u2 = k(c2 / a2.height);
            switch (i3) {
              case "v":
                return o3.onchange(p2);
              case "h":
                return o3.onchange(u2);
              default:
                return o3.onchange(p2, u2);
            }
          }, _tapstop() {
            e2.options.onstop(), s(document, ["mouseup", "touchend", "touchcancel"], e2._tapstop), s(document, ["mousemove", "touchmove"], e2._tapmove);
          }, trigger() {
            e2._tapmove();
          }, update(t3 = 0, o3 = 0) {
            const {left: n3, top: i3, width: r2, height: s2} = e2.options.wrapper.getBoundingClientRect();
            e2.options.lock === "h" && (o3 = t3), e2._tapmove({clientX: n3 + r2 * t3, clientY: i3 + s2 * o3});
          }, destroy() {
            const {options: t3, _tapstart: o3, _keyboard: n3} = e2;
            s(document, ["keydown", "keyup"], n3), s([t3.wrapper, t3.element], "mousedown", o3), s([t3.wrapper, t3.element], "touchstart", o3, {passive: false});
          }}, {options: o2, _tapstart: n2, _keyboard: i2} = e2;
          return r([o2.wrapper, o2.element], "mousedown", n2), r([o2.wrapper, o2.element], "touchstart", n2, {passive: false}), r(document, ["keydown", "keyup"], i2), e2;
        }
        function S(t2 = {}) {
          t2 = Object.assign({onchange: () => 0, className: "", elements: []}, t2);
          const e2 = r(t2.elements, "click", (e3) => {
            t2.elements.forEach((o2) => o2.classList[e3.target === o2 ? "add" : "remove"](t2.className)), t2.onchange(e3), e3.stopPropagation();
          });
          return {destroy: () => s(...e2)};
        }
        /*! NanoPop 2.1.0 MIT | https://github.com/Simonwep/nanopop */
        const O = {variantFlipOrder: {start: "sme", middle: "mse", end: "ems"}, positionFlipOrder: {top: "tbrl", right: "rltb", bottom: "btrl", left: "lrbt"}, position: "bottom", margin: 8}, E = (t2, e2, o2) => {
          const n2 = typeof t2 != "object" || t2 instanceof HTMLElement ? __spreadValues({reference: t2, popper: e2}, o2) : t2;
          return {update(t3 = n2) {
            const {reference: e3, popper: o3} = Object.assign(n2, t3);
            if (!o3 || !e3)
              throw new Error("Popper- or reference-element missing.");
            return ((t4, e4, o4) => {
              const {container: n3, margin: i2, position: r2, variantFlipOrder: s2, positionFlipOrder: a2} = __spreadValues(__spreadValues({container: document.documentElement.getBoundingClientRect()}, O), o4), {left: l2, top: c2} = e4.style;
              e4.style.left = "0", e4.style.top = "0";
              const p2 = t4.getBoundingClientRect(), u2 = e4.getBoundingClientRect(), h2 = {t: p2.top - u2.height - i2, b: p2.bottom + i2, r: p2.right + i2, l: p2.left - u2.width - i2}, d2 = {vs: p2.left, vm: p2.left + p2.width / 2 + -u2.width / 2, ve: p2.left + p2.width - u2.width, hs: p2.top, hm: p2.bottom - p2.height / 2 - u2.height / 2, he: p2.bottom - u2.height}, [f2, m2 = "middle"] = r2.split("-"), v2 = a2[f2], b2 = s2[m2], {top: y2, left: g2, bottom: _2, right: w2} = n3;
              for (const t5 of v2) {
                const o5 = t5 === "t" || t5 === "b", n4 = h2[t5], [i3, r3] = o5 ? ["top", "left"] : ["left", "top"], [s3, a3] = o5 ? [u2.height, u2.width] : [u2.width, u2.height], [l3, c3] = o5 ? [_2, w2] : [w2, _2], [p3, f3] = o5 ? [y2, g2] : [g2, y2];
                if (!(n4 < p3 || n4 + s3 > l3))
                  for (const s4 of b2) {
                    const l4 = d2[(o5 ? "v" : "h") + s4];
                    if (!(l4 < f3 || l4 + a3 > c3))
                      return e4.style[r3] = l4 - u2[r3] + "px", e4.style[i3] = n4 - u2[i3] + "px", t5 + s4;
                  }
              }
              return e4.style.left = l2, e4.style.top = c2, null;
            })(e3, o3, n2);
          }};
        };
        function L(t2, e2, o2) {
          return e2 in t2 ? Object.defineProperty(t2, e2, {value: o2, enumerable: true, configurable: true, writable: true}) : t2[e2] = o2, t2;
        }
        class x {
          constructor(t2) {
            L(this, "_initializingActive", true), L(this, "_recalc", true), L(this, "_nanopop", null), L(this, "_root", null), L(this, "_color", C()), L(this, "_lastColor", C()), L(this, "_swatchColors", []), L(this, "_setupAnimationFrame", null), L(this, "_eventListener", {init: [], save: [], hide: [], show: [], clear: [], change: [], changestop: [], cancel: [], swatchselect: []}), this.options = t2 = Object.assign(__spreadValues({}, x.DEFAULT_OPTIONS), t2);
            const {swatches: e2, components: o2, theme: n2, sliders: i2, lockOpacity: r2, padding: s2} = t2;
            ["nano", "monolith"].includes(n2) && !i2 && (t2.sliders = "h"), o2.interaction || (o2.interaction = {});
            const {preview: a2, opacity: l2, hue: c2, palette: p2} = o2;
            o2.opacity = !r2 && l2, o2.palette = p2 || a2 || l2 || c2, this._preBuild(), this._buildComponents(), this._bindEvents(), this._finalBuild(), e2 && e2.length && e2.forEach((t3) => this.addSwatch(t3));
            const {button: u2, app: h2} = this._root;
            this._nanopop = E(u2, h2, {margin: s2}), u2.setAttribute("role", "button"), u2.setAttribute("aria-label", this._t("btn:toggle"));
            const d2 = this;
            this._setupAnimationFrame = requestAnimationFrame(function e3() {
              if (!h2.offsetWidth)
                return requestAnimationFrame(e3);
              d2.setColor(t2.default), d2._rePositioningPicker(), t2.defaultRepresentation && (d2._representation = t2.defaultRepresentation, d2.setColorRepresentation(d2._representation)), t2.showAlways && d2.show(), d2._initializingActive = false, d2._emit("init");
            });
          }
          _preBuild() {
            const {options: t2} = this;
            for (const e2 of ["el", "container"])
              t2[e2] = p(t2[e2]);
            this._root = ((t3) => {
              const {components: e2, useAsButton: o2, inline: n2, appClass: i2, theme: r2, lockOpacity: s2} = t3.options, a2 = (t4) => t4 ? "" : 'style="display:none" hidden', c2 = (e3) => t3._t(e3), p2 = l(`
      <div :ref="root" class="pickr">

        ${o2 ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${i2 || ""}" data-theme="${r2}" ${n2 ? 'style="position: unset"' : ""} aria-label="${c2("ui:dialog")}" role="window">
          <div class="pcr-selection" ${a2(e2.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${a2(e2.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c2("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c2("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${a2(e2.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c2("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${a2(e2.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c2("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e2.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${a2(Object.keys(e2.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${a2(e2.interaction.input)} aria-label="${c2("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${s2 ? "HEX" : "HEXA"}" type="button" ${a2(e2.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${s2 ? "RGB" : "RGBA"}" type="button" ${a2(e2.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${s2 ? "HSL" : "HSLA"}" type="button" ${a2(e2.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${s2 ? "HSV" : "HSVA"}" type="button" ${a2(e2.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${a2(e2.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${c2("btn:save")}" type="button" ${a2(e2.interaction.save)} aria-label="${c2("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${c2("btn:cancel")}" type="button" ${a2(e2.interaction.cancel)} aria-label="${c2("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${c2("btn:clear")}" type="button" ${a2(e2.interaction.clear)} aria-label="${c2("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `), u2 = p2.interaction;
              return u2.options.find((t4) => !t4.hidden && !t4.classList.add("active")), u2.type = () => u2.options.find((t4) => t4.classList.contains("active")), p2;
            })(this), t2.useAsButton && (this._root.button = t2.el), t2.container.appendChild(this._root.root);
          }
          _finalBuild() {
            const t2 = this.options, e2 = this._root;
            if (t2.container.removeChild(e2.root), t2.inline) {
              const o2 = t2.el.parentElement;
              t2.el.nextSibling ? o2.insertBefore(e2.app, t2.el.nextSibling) : o2.appendChild(e2.app);
            } else
              t2.container.appendChild(e2.app);
            t2.useAsButton ? t2.inline && t2.el.remove() : t2.el.parentNode.replaceChild(e2.root, t2.el), t2.disabled && this.disable(), t2.comparison || (e2.button.style.transition = "none", t2.useAsButton || (e2.preview.lastColor.style.transition = "none")), this.hide();
          }
          _buildComponents() {
            const t2 = this, e2 = this.options.components, o2 = (t2.options.sliders || "v").repeat(2), [n2, i2] = o2.match(/^[vh]+$/g) ? o2 : [], r2 = () => this._color || (this._color = this._lastColor.clone()), s2 = {palette: $({element: t2._root.palette.picker, wrapper: t2._root.palette.palette, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3, n3) {
              if (!e2.palette)
                return;
              const i3 = r2(), {_root: s3, options: a2} = t2, {lastColor: l2, currentColor: c2} = s3.preview;
              t2._recalc && (i3.s = 100 * o3, i3.v = 100 - 100 * n3, i3.v < 0 && (i3.v = 0), t2._updateOutput("slider"));
              const p2 = i3.toRGBA().toString(0);
              this.element.style.background = p2, this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${i3.a}), transparent),
                        linear-gradient(to left, hsla(${i3.h}, 100%, 50%, ${i3.a}), rgba(255, 255, 255, ${i3.a}))
                    `, a2.comparison ? a2.useAsButton || t2._lastColor || l2.style.setProperty("--pcr-color", p2) : (s3.button.style.color = p2, s3.button.classList.remove("clear"));
              const u2 = i3.toHEXA().toString();
              for (const {el: e3, color: o4} of t2._swatchColors)
                e3.classList[u2 === o4.toHEXA().toString() ? "add" : "remove"]("pcr-active");
              c2.style.setProperty("--pcr-color", p2);
            }}), hue: $({lock: i2 === "v" ? "h" : "v", element: t2._root.hue.picker, wrapper: t2._root.hue.slider, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3) {
              if (!e2.hue || !e2.palette)
                return;
              const n3 = r2();
              t2._recalc && (n3.h = 360 * o3), this.element.style.backgroundColor = `hsl(${n3.h}, 100%, 50%)`, s2.palette.trigger();
            }}), opacity: $({lock: n2 === "v" ? "h" : "v", element: t2._root.opacity.picker, wrapper: t2._root.opacity.slider, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3) {
              if (!e2.opacity || !e2.palette)
                return;
              const n3 = r2();
              t2._recalc && (n3.a = Math.round(100 * o3) / 100), this.element.style.background = `rgba(0, 0, 0, ${n3.a})`, s2.palette.trigger();
            }}), selectable: S({elements: t2._root.interaction.options, className: "active", onchange(e3) {
              t2._representation = e3.target.getAttribute("data-type").toUpperCase(), t2._recalc && t2._updateOutput("swatch");
            }})};
            this._components = s2;
          }
          _bindEvents() {
            const {_root: t2, options: e2} = this, o2 = [r(t2.interaction.clear, "click", () => this._clearColor()), r([t2.interaction.cancel, t2.preview.lastColor], "click", () => {
              this.setHSVA(...(this._lastColor || this._color).toHSVA(), true), this._emit("cancel");
            }), r(t2.interaction.save, "click", () => {
              !this.applyColor() && !e2.showAlways && this.hide();
            }), r(t2.interaction.result, ["keyup", "input"], (t3) => {
              this.setColor(t3.target.value, true) && !this._initializingActive && (this._emit("change", this._color, "input", this), this._emit("changestop", "input", this)), t3.stopImmediatePropagation();
            }), r(t2.interaction.result, ["focus", "blur"], (t3) => {
              this._recalc = t3.type === "blur", this._recalc && this._updateOutput(null);
            }), r([t2.palette.palette, t2.palette.picker, t2.hue.slider, t2.hue.picker, t2.opacity.slider, t2.opacity.picker], ["mousedown", "touchstart"], () => this._recalc = true, {passive: true})];
            if (!e2.showAlways) {
              const n2 = e2.closeWithKey;
              o2.push(r(t2.button, "click", () => this.isOpen() ? this.hide() : this.show()), r(document, "keyup", (t3) => this.isOpen() && (t3.key === n2 || t3.code === n2) && this.hide()), r(document, ["touchstart", "mousedown"], (e3) => {
                this.isOpen() && !c(e3).some((e4) => e4 === t2.app || e4 === t2.button) && this.hide();
              }, {capture: true}));
            }
            if (e2.adjustableNumbers) {
              const e3 = {rgba: [255, 255, 255, 1], hsva: [360, 100, 100, 1], hsla: [360, 100, 100, 1], cmyk: [100, 100, 100, 100]};
              u(t2.interaction.result, (t3, o3, n2) => {
                const i2 = e3[this.getColorRepresentation().toLowerCase()];
                if (i2) {
                  const e4 = i2[n2], r2 = t3 + (e4 >= 100 ? 1e3 * o3 : o3);
                  return r2 <= 0 ? 0 : Number((r2 < e4 ? r2 : e4).toPrecision(3));
                }
                return t3;
              });
            }
            if (e2.autoReposition && !e2.inline) {
              let t3 = null;
              const n2 = this;
              o2.push(r(window, ["scroll", "resize"], () => {
                n2.isOpen() && (e2.closeOnScroll && n2.hide(), t3 === null ? (t3 = setTimeout(() => t3 = null, 100), requestAnimationFrame(function e3() {
                  n2._rePositioningPicker(), t3 !== null && requestAnimationFrame(e3);
                })) : (clearTimeout(t3), t3 = setTimeout(() => t3 = null, 100)));
              }, {capture: true}));
            }
            this._eventBindings = o2;
          }
          _rePositioningPicker() {
            const {options: t2} = this;
            if (!t2.inline) {
              if (!this._nanopop.update({container: document.body.getBoundingClientRect(), position: t2.position})) {
                const t3 = this._root.app, e2 = t3.getBoundingClientRect();
                t3.style.top = (window.innerHeight - e2.height) / 2 + "px", t3.style.left = (window.innerWidth - e2.width) / 2 + "px";
              }
            }
          }
          _updateOutput(t2) {
            const {_root: e2, _color: o2, options: n2} = this;
            if (e2.interaction.type()) {
              const t3 = "to" + e2.interaction.type().getAttribute("data-type");
              e2.interaction.result.value = typeof o2[t3] == "function" ? o2[t3]().toString(n2.outputPrecision) : "";
            }
            !this._initializingActive && this._recalc && this._emit("change", o2, t2, this);
          }
          _clearColor(t2 = false) {
            const {_root: e2, options: o2} = this;
            o2.useAsButton || (e2.button.style.color = "rgba(0, 0, 0, 0.15)"), e2.button.classList.add("clear"), o2.showAlways || this.hide(), this._lastColor = null, this._initializingActive || t2 || (this._emit("save", null), this._emit("clear"));
          }
          _parseLocalColor(t2) {
            const {values: e2, type: o2, a: n2} = A(t2), {lockOpacity: i2} = this.options, r2 = n2 !== void 0 && n2 !== 1;
            return e2 && e2.length === 3 && (e2[3] = void 0), {values: !e2 || i2 && r2 ? null : e2, type: o2};
          }
          _t(t2) {
            return this.options.i18n[t2] || x.I18N_DEFAULTS[t2];
          }
          _emit(t2, ...e2) {
            this._eventListener[t2].forEach((t3) => t3(...e2, this));
          }
          on(t2, e2) {
            return this._eventListener[t2].push(e2), this;
          }
          off(t2, e2) {
            const o2 = this._eventListener[t2] || [], n2 = o2.indexOf(e2);
            return ~n2 && o2.splice(n2, 1), this;
          }
          addSwatch(t2) {
            const {values: e2} = this._parseLocalColor(t2);
            if (e2) {
              const {_swatchColors: t3, _root: o2} = this, n2 = C(...e2), i2 = a(`<button type="button" style="--pcr-color: ${n2.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);
              return o2.swatches.appendChild(i2), t3.push({el: i2, color: n2}), this._eventBindings.push(r(i2, "click", () => {
                this.setHSVA(...n2.toHSVA(), true), this._emit("swatchselect", n2), this._emit("change", n2, "swatch", this);
              })), true;
            }
            return false;
          }
          removeSwatch(t2) {
            const e2 = this._swatchColors[t2];
            if (e2) {
              const {el: o2} = e2;
              return this._root.swatches.removeChild(o2), this._swatchColors.splice(t2, 1), true;
            }
            return false;
          }
          applyColor(t2 = false) {
            const {preview: e2, button: o2} = this._root, n2 = this._color.toRGBA().toString(0);
            return e2.lastColor.style.setProperty("--pcr-color", n2), this.options.useAsButton || o2.style.setProperty("--pcr-color", n2), o2.classList.remove("clear"), this._lastColor = this._color.clone(), this._initializingActive || t2 || this._emit("save", this._color), this;
          }
          destroy() {
            cancelAnimationFrame(this._setupAnimationFrame), this._eventBindings.forEach((t2) => s(...t2)), Object.keys(this._components).forEach((t2) => this._components[t2].destroy());
          }
          destroyAndRemove() {
            this.destroy();
            const {root: t2, app: e2} = this._root;
            t2.parentElement && t2.parentElement.removeChild(t2), e2.parentElement.removeChild(e2), Object.keys(this).forEach((t3) => this[t3] = null);
          }
          hide() {
            return !!this.isOpen() && (this._root.app.classList.remove("visible"), this._emit("hide"), true);
          }
          show() {
            return !this.options.disabled && !this.isOpen() && (this._root.app.classList.add("visible"), this._rePositioningPicker(), this._emit("show", this._color), this);
          }
          isOpen() {
            return this._root.app.classList.contains("visible");
          }
          setHSVA(t2 = 360, e2 = 0, o2 = 0, n2 = 1, i2 = false) {
            const r2 = this._recalc;
            if (this._recalc = false, t2 < 0 || t2 > 360 || e2 < 0 || e2 > 100 || o2 < 0 || o2 > 100 || n2 < 0 || n2 > 1)
              return false;
            this._color = C(t2, e2, o2, n2);
            const {hue: s2, opacity: a2, palette: l2} = this._components;
            return s2.update(t2 / 360), a2.update(n2), l2.update(e2 / 100, 1 - o2 / 100), i2 || this.applyColor(), r2 && this._updateOutput(), this._recalc = r2, true;
          }
          setColor(t2, e2 = false) {
            if (t2 === null)
              return this._clearColor(e2), true;
            const {values: o2, type: n2} = this._parseLocalColor(t2);
            if (o2) {
              const t3 = n2.toUpperCase(), {options: i2} = this._root.interaction, r2 = i2.find((e3) => e3.getAttribute("data-type") === t3);
              if (r2 && !r2.hidden)
                for (const t4 of i2)
                  t4.classList[t4 === r2 ? "add" : "remove"]("active");
              return !!this.setHSVA(...o2, e2) && this.setColorRepresentation(t3);
            }
            return false;
          }
          setColorRepresentation(t2) {
            return t2 = t2.toUpperCase(), !!this._root.interaction.options.find((e2) => e2.getAttribute("data-type").startsWith(t2) && !e2.click());
          }
          getColorRepresentation() {
            return this._representation;
          }
          getColor() {
            return this._color;
          }
          getSelectedColor() {
            return this._lastColor;
          }
          getRoot() {
            return this._root;
          }
          disable() {
            return this.hide(), this.options.disabled = true, this._root.button.classList.add("disabled"), this;
          }
          enable() {
            return this.options.disabled = false, this._root.button.classList.remove("disabled"), this;
          }
        }
        L(x, "utils", n), L(x, "version", "1.8.1"), L(x, "I18N_DEFAULTS", {"ui:dialog": "color picker dialog", "btn:toggle": "toggle color picker dialog", "btn:swatch": "color swatch", "btn:last-color": "use previous color", "btn:save": "Save", "btn:cancel": "Cancel", "btn:clear": "Clear", "aria:btn:save": "save and close", "aria:btn:cancel": "cancel and close", "aria:btn:clear": "clear and close", "aria:input": "color input field", "aria:palette": "color selection area", "aria:hue": "hue selection slider", "aria:opacity": "selection slider"}), L(x, "DEFAULT_OPTIONS", {appClass: null, theme: "classic", useAsButton: false, padding: 8, disabled: false, comparison: true, closeOnScroll: false, outputPrecision: 0, lockOpacity: false, autoReposition: true, container: "body", components: {interaction: {}}, i18n: {}, swatches: null, inline: false, sliders: null, default: "#42445a", defaultRepresentation: null, position: "bottom-middle", adjustableNumbers: true, showAlways: false, closeWithKey: "Escape"}), L(x, "create", (t2) => new x(t2));
        e.default = x;
      }]).default;
    });
  })(pickr_min);
  var __Pickr = /* @__PURE__ */ getDefaultExportFromCjs(pickr_min.exports);
  function plainObject$2(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$2(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$2(newObj[key]) && plainObject$2(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  var __baseCss = `/*! Pickr 1.8.1 MIT | https://github.com/Simonwep/pickr */.pickr{position:relative;overflow:visible;transform:translateY(0)}.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pickr .pcr-button{position:relative;height:2em;width:2em;padding:.5em;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;border-radius:.15em;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" stroke="%2342445A" stroke-width="5px" stroke-linecap="round"><path d="M45,45L5,5"></path><path d="M45,5L5,45"></path></svg>') no-repeat 50%;background-size:0;transition:all .3s}.pickr .pcr-button:before{background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;z-index:-1;z-index:auto}.pickr .pcr-button:after,.pickr .pcr-button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;border-radius:.15em}.pickr .pcr-button:after{transition:background .3s;background:var(--pcr-color)}.pickr .pcr-button.clear{background-size:70%}.pickr .pcr-button.clear:before{opacity:0}.pickr .pcr-button.clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pickr .pcr-button.disabled{cursor:not-allowed}.pcr-app *,.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pcr-app button.pcr-active,.pcr-app button:focus,.pcr-app input.pcr-active,.pcr-app input:focus,.pickr button.pcr-active,.pickr button:focus,.pickr input.pcr-active,.pickr input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pcr-app .pcr-palette,.pcr-app .pcr-slider,.pickr .pcr-palette,.pickr .pcr-slider{transition:box-shadow .3s}.pcr-app .pcr-palette:focus,.pcr-app .pcr-slider:focus,.pickr .pcr-palette:focus,.pickr .pcr-slider:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(0,0,0,.25)}.pcr-app{position:fixed;display:flex;flex-direction:column;z-index:10000;border-radius:.1em;background:#fff;opacity:0;visibility:hidden;transition:opacity .3s,visibility 0s .3s;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;box-shadow:0 .15em 1.5em 0 rgba(0,0,0,.1),0 0 1em 0 rgba(0,0,0,.03);left:0;top:0}.pcr-app.visible{transition:opacity .3s;visibility:visible;opacity:1}.pcr-app .pcr-swatches{display:flex;flex-wrap:wrap;margin-top:.75em}.pcr-app .pcr-swatches.pcr-last{margin:0}@supports (display:grid){.pcr-app .pcr-swatches{display:grid;align-items:center;grid-template-columns:repeat(auto-fit,1.75em)}}.pcr-app .pcr-swatches>button{font-size:1em;position:relative;width:calc(1.75em - 5px);height:calc(1.75em - 5px);border-radius:.15em;cursor:pointer;margin:2.5px;flex-shrink:0;justify-self:center;transition:all .15s;overflow:hidden;background:transparent;z-index:1}.pcr-app .pcr-swatches>button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:6px;border-radius:.15em;z-index:-1}.pcr-app .pcr-swatches>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:var(--pcr-color);border:1px solid rgba(0,0,0,.05);border-radius:.15em;box-sizing:border-box}.pcr-app .pcr-swatches>button:hover{filter:brightness(1.05)}.pcr-app .pcr-swatches>button:not(.pcr-active){box-shadow:none}.pcr-app .pcr-interaction{display:flex;flex-wrap:wrap;align-items:center;margin:0 -.2em}.pcr-app .pcr-interaction>*{margin:0 .2em}.pcr-app .pcr-interaction input{letter-spacing:.07em;font-size:.75em;text-align:center;cursor:pointer;color:#75797e;background:#f1f3f4;border-radius:.15em;transition:all .15s;padding:.45em .5em;margin-top:.75em}.pcr-app .pcr-interaction input:hover{filter:brightness(.975)}.pcr-app .pcr-interaction input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(66,133,244,.75)}.pcr-app .pcr-interaction .pcr-result{color:#75797e;text-align:left;flex:1 1 8em;min-width:8em;transition:all .2s;border-radius:.15em;background:#f1f3f4;cursor:text}.pcr-app .pcr-interaction .pcr-result::-moz-selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-result::selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-type.active{color:#fff;background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear,.pcr-app .pcr-interaction .pcr-save{width:auto;color:#fff}.pcr-app .pcr-interaction .pcr-cancel:hover,.pcr-app .pcr-interaction .pcr-clear:hover,.pcr-app .pcr-interaction .pcr-save:hover{filter:brightness(.925)}.pcr-app .pcr-interaction .pcr-save{background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear{background:#f44250}.pcr-app .pcr-interaction .pcr-cancel:focus,.pcr-app .pcr-interaction .pcr-clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(244,66,80,.75)}.pcr-app .pcr-selection .pcr-picker{position:absolute;height:18px;width:18px;border:2px solid #fff;border-radius:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.pcr-app .pcr-selection .pcr-color-chooser,.pcr-app .pcr-selection .pcr-color-opacity,.pcr-app .pcr-selection .pcr-color-palette{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;cursor:grab;cursor:-webkit-grab}.pcr-app .pcr-selection .pcr-color-chooser:active,.pcr-app .pcr-selection .pcr-color-opacity:active,.pcr-app .pcr-selection .pcr-color-palette:active{cursor:grabbing;cursor:-webkit-grabbing}.pcr-app[data-theme=nano]{width:14.25em;max-width:95vw}.pcr-app[data-theme=nano] .pcr-swatches{margin-top:.6em;padding:0 .6em}.pcr-app[data-theme=nano] .pcr-interaction{padding:0 .6em .6em}.pcr-app[data-theme=nano] .pcr-selection{display:grid;grid-gap:.6em;grid-template-columns:1fr 4fr;grid-template-rows:5fr auto auto;align-items:center;height:10.5em;width:100%;align-self:flex-start}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview{grid-area:2/1/4/1;height:100%;width:100%;display:flex;flex-direction:row;justify-content:center;margin-left:.6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-last-color{display:none}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color{position:relative;background:var(--pcr-color);width:2em;height:2em;border-radius:50em;overflow:hidden}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette{grid-area:1/1/2/3;width:100%;height:100%;z-index:1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette{border-radius:.15em;width:100%;height:100%}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser{grid-area:2/2/2/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{grid-area:3/2/3/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{height:.5em;margin:0 .6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-picker,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-picker{top:50%;transform:translateY(-50%)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{flex-grow:1;border-radius:50em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider{background:linear-gradient(90deg,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{background:linear-gradient(90deg,transparent,#000),url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:100%,.25em}`;
  var __css$3 = ".s-color-picker[default-style] {\n}\n\ns-color-picker:not([mounted]) > * {\n        display: none;\n    }\n\n[default-style] .s-color-picker__picker {\n        background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n        overflow: hidden;box-shadow: var(--s-theme-ui-colorPicker-depth, 0);\n        border-radius: var(--s-theme-ui-colorPicker-borderRadius, 10px);\n        padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n        padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n    }\n\n.pickr.s-color-picker__preview {\n    display: inline-block;\n    outline: none;\n    border-radius: 0 !important;\n}\n\n[default-style] .pickr.s-color-picker__preview {\n        transition: var(--s-theme-transition-fast, all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n.pickr.s-color-picker__preview button:focus {\n        display: none;\n    }\n\n.pickr.s-color-picker__preview button {\n        width: 1em;\n        height: 1em;\n        border-radius: 0 !important;\n    }\n\n.pickr.s-color-picker__preview button:before,\n        .pickr.s-color-picker__preview button:after {\n            border-radius: 0 !important;\n        }\n";
  class SColorPickerComponentInterface extends SInterface {
  }
  SColorPickerComponentInterface.definition = {
    value: {
      type: "String",
      default: "#ff0000"
    }
  };
  class SColorPicker extends SLitComponent {
    static get properties() {
      return SLitComponent.properties({}, SColorPickerComponentInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(`
            ${__baseCss}
            ${__css$3}
        `)}
        `;
    }
    constructor() {
      super(__deepMerge$2({
        litComponent: {},
        componentUtils: {
          interface: SColorPickerComponentInterface
        }
      }));
    }
    firstUpdated() {
      var _a, _b, _c, _d;
      const pickr = __Pickr.create({
        el: (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".s-color-picker__preview"),
        theme: "nano",
        container: (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector(".s-color-picker__picker-wrapper"),
        default: this.props.value,
        comparison: false,
        swatches: [],
        components: {
          preview: true,
          opacity: true,
          hue: true,
          interaction: {
            hex: true,
            rgba: true,
            hsla: true,
            input: true,
            clear: true
          }
        }
      });
      function getPickrState() {
        const color = pickr.getColor();
        const hsla = color.toHSLA(), hsva = color.toHSVA(), rgba = color.toRGBA(), hex = color.toHEXA(), cmyk = color.toCMYK();
        return {
          isOpened: pickr.isOpen(),
          hsla: {
            h: hsla[0],
            s: hsla[1],
            l: hsla[2],
            a: hsla[3],
            string: `hsla(${hsla[0]},${hsla[1]},${hsla[2]},${hsla[3]})`
          },
          hsva: {
            h: hsva[0],
            s: hsva[1],
            v: hsva[2],
            a: hsva[3],
            string: `hsva(${hsva[0]},${hsva[1]},${hsva[2]},${hsva[3]})`
          },
          rgba: {
            r: rgba[0],
            g: rgba[1],
            b: rgba[2],
            a: rgba[3],
            string: `rgba(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3]})`
          },
          hex: hex.toString(),
          cmyk: {
            c: cmyk[0],
            m: cmyk[1],
            y: cmyk[2],
            k: cmyk[3],
            string: `cmyk(${cmyk[0]},${cmyk[1]},${cmyk[2]},${cmyk[3]})`
          }
        };
      }
      pickr.on("change", () => {
        pickr.applyColor();
        const detail = getPickrState();
        const change = new CustomEvent("change", {
          detail
        });
        this.dispatchEvent(change);
      });
      pickr.on("show", () => {
        const detail = getPickrState();
        const change = new CustomEvent("show", {
          detail
        });
        this.dispatchEvent(change);
      });
      pickr.on("hide", () => {
        const detail = getPickrState();
        const change = new CustomEvent("hide", {
          detail
        });
        this.dispatchEvent(change);
      });
      pickr.on("cancel", () => {
        const detail = getPickrState();
        const change = new CustomEvent("cancel", {
          detail
        });
        this.dispatchEvent(change);
      });
      const $app = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelector(".pcr-app");
      $app === null || $app === void 0 ? void 0 : $app.classList.add(this.componentUtils.className("__picker"));
      const $preview = (_d = this.shadowRoot) === null || _d === void 0 ? void 0 : _d.querySelector(".pickr");
      $preview === null || $preview === void 0 ? void 0 : $preview.classList.add(this.componentUtils.className("__preview"));
    }
    render() {
      return html$2`
            <div class="${this.componentUtils.className("")}">
                <div
                    class="${this.componentUtils.className("__picker-wrapper")}"
                ></div>
                <div
                    class="${this.componentUtils.className("__preview")}"
                ></div>
            </div>
        `;
    }
  }
  function define$5(props = {}, tagName = "s-color-picker") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SColorPicker);
  }
  class SRangeComponentInterface extends SInterface {
  }
  SRangeComponentInterface.definition = {
    name: {
      type: "String",
      description: 'Specify the name to assign to the internal input[type="range"]'
    },
    value: {
      type: "String",
      description: "Specify the initial range value"
    },
    min: {
      type: "Number",
      description: "Specify the minimal value or the range",
      default: 0
    },
    max: {
      type: "Number",
      description: "Specify the maximal value of the range",
      default: 100
    },
    step: {
      type: "Number",
      description: "Specify the steps between each values"
    },
    target: {
      type: "String",
      description: "Specify a css selector of any HTMLElement or HTMLInputElement in which to inject the value when the range is updated"
    },
    tooltip: {
      type: "Boolean",
      description: "Specify if you want to display the value inside a tooltip on top of the thumb",
      default: false
    }
  };
  var __css$2 = "s-range {\n    display: block;\n    width: 100%;\n}\n\n    s-range:not([mounted]) > * {\n        display: none;\n    }\n.s-range {\n    display: flex;\n    width: 100%;\n}\n\n.s-range__input {\n    flex-grow: 1;\n}\n\n.s-range__tooltip {\n    transition: none;\n}\n\ns-range[default-style] {\n}\n";
  function plainObject$1(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge$1(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject$1(newObj[key]) && plainObject$1(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  var __awaiter$7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SRange extends SLitComponent {
    static get properties() {
      return SLitComponent.properties({}, SRangeComponentInterface);
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(`
                ${__css$2}
            `)}
        `;
    }
    constructor() {
      super(__deepMerge$1({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {
          interface: SRangeComponentInterface
        }
      }));
    }
    firstUpdated() {
      return __awaiter$7(this, void 0, void 0, function* () {
        this._$input = this.querySelector("input");
        this._$tooltip = this.querySelector(".s-range__tooltip");
        this._$input.addEventListener("input", (e) => {
          this._handleTooltip();
          this._handleTarget();
        });
        if (this.props.target) {
          this._$targets = Array.from(document.querySelectorAll(this.props.target));
        }
        this._handleTooltip();
        this._handleTarget();
      });
    }
    _handleTarget() {
      if (!this._$targets)
        return;
      this._$targets.forEach(($target) => {
        $target.innerHTML = this._$input.value;
        $target.value = this._$input.value;
      });
    }
    _handleTooltip() {
      if (!this._$tooltip)
        return;
      const val = this._$input.value;
      const min = this._$input.min ? this._$input.min : 0;
      const max = this._$input.max ? this._$input.max : 100;
      const newVal = Number((val - min) * 100 / (max - min));
      this._$tooltip.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
      this._$tooltip.innerHTML = val;
    }
    render() {
      return html$2`
            <div class="${this.componentUtils.className("", "s-tooltip-container")}">
                <input
                    class="${this.componentUtils.className("__input", "s-range")}"
                    type="range"
                    name="${this.name}"
                    value="${this.value}"
                    min="${this.min}"
                    max="${this.max}"
                    step="${this.step}"
                />
                ${this.props.tooltip ? html$2` <div class="${this.componentUtils.className("__tooltip", "s-tooltip")}"></div> ` : ""}
            </div>
        `;
    }
  }
  function define$4(props = {}, tagName = "s-range") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SRange);
  }
  function matches(el, selector) {
    if (el.nodeName == "#comment" || el.nodeName == "#text") {
      return false;
    }
    const p = Element.prototype;
    const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
    };
    return f.call(el, selector);
  }
  let _observer;
  const _selectors = {};
  function querySelectorLive(selector, cb = null, settings = {}) {
    const id = `${selector} - ${uniqid()}`;
    settings = Object.assign({}, {
      rootNode: document,
      once: true
    }, settings);
    if (!_selectors[selector]) {
      _selectors[selector] = [
        {
          id,
          selector,
          cb,
          lastMutationId: null,
          settings
        }
      ];
    } else {
      _selectors[selector].push({
        id,
        selector,
        cb,
        lastMutationId: null,
        settings
      });
    }
    return new SPromise(({resolve, reject, emit}) => {
      function pushNewNode(node, sel, mutationId) {
        const objs = _selectors[sel];
        if (!objs)
          return;
        objs.forEach((obj) => {
          if (obj.lastMutationId && obj.lastMutationId === mutationId)
            return;
          if (obj.settings.once) {
            if (!node._querySelectorLive) {
              node._querySelectorLive = {};
            }
            if (node._querySelectorLive[obj.id])
              return;
            node._querySelectorLive[obj.id] = true;
          }
          emit("node", node);
          obj.cb && obj.cb(node, () => {
            delete _selectors[obj.selector];
          });
        });
      }
      if (!_observer) {
        _observer = new MutationObserver((mutations) => {
          const mutationId = `mutation-${uniqid()}`;
          mutations.forEach((mutation) => {
            if (mutation.addedNodes && mutation.addedNodes.length) {
              [].forEach.call(mutation.addedNodes, (node) => {
                const selectors = Object.keys(_selectors);
                selectors.forEach((sel) => {
                  if (matches(node, sel)) {
                    pushNewNode(node, sel, mutationId);
                  }
                });
                if (!node.querySelectorAll)
                  return;
                selectors.forEach((sel) => {
                  const nestedNodes = node.querySelectorAll(sel);
                  [].forEach.call(nestedNodes, (nestedNode) => {
                    pushNewNode(nestedNode, sel, mutationId);
                  });
                });
              });
            } else if (mutation.attributeName) {
              const selectors = Object.keys(_selectors);
              selectors.forEach((sel) => {
                if (matches(mutation.target, sel)) {
                  pushNewNode(mutation.target, sel, mutationId);
                }
              });
            }
          });
        });
        _observer.observe(settings.rootNode, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "id"]
        });
      }
      [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
        pushNewNode(node, selector, "init");
      });
    });
  }
  function expandPleasantCssClassname(classesStr) {
    const classesArray = [];
    const classNames = classesStr.split(/\s+/);
    let currentMedia = "";
    classNames.forEach((className) => {
      if (className.slice(0, 1) == "@") {
        currentMedia = className.replace("@", "___");
        return;
      }
      const parts = className.split(":");
      if (parts.length === 1) {
        let name = className;
        if (currentMedia !== "")
          name = className + currentMedia;
        classesArray.push(name);
      } else {
        const firstClass = parts[0];
        let name = firstClass;
        if (currentMedia !== "")
          name = firstClass + currentMedia;
        classesArray.push(name);
        parts.forEach((part, i) => {
          if (i > 0) {
            name = firstClass + "--" + part;
            if (currentMedia !== "")
              name = name + currentMedia;
            classesArray.push(name);
          }
        });
      }
    });
    return classesArray.join(" ");
  }
  function expandPleasantCssClassnamesLive(settings) {
    settings = Object.assign({rootNode: document}, settings);
    querySelectorLive('[class*=":"]:not(code [class*=":"]):not(template [class*=":"]),[class*="@"]:not(code [class*="@"]):not(template [class*="@"])', ($elm) => {
      const classesStr = $elm.getAttribute("class");
      const newClassesStr = expandPleasantCssClassname(classesStr);
      $elm.setAttribute("class", newClassesStr);
    }, {
      rootNode: settings === null || settings === void 0 ? void 0 : settings.rootNode,
      once: false
    });
  }
  var __awaiter$6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getState() {
    var _a;
    const state = JSON.parse((_a = window.localStorage.getItem("coffeekrakenio")) !== null && _a !== void 0 ? _a : "{}");
    return state;
  }
  function getCurrentVersion() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const docmapJson = yield loadDocmap();
      let version;
      if (document.location.hostname.split(".").length >= 4) {
        version = document.location.hostname.split(".").slice(0, 3).join(".").replace(/^v/, "");
      }
      return version !== null && version !== void 0 ? version : docmapJson.snapshots.slice(-1)[0];
    });
  }
  function setState(stateObj) {
    const state = getState();
    const newState = __deepMerge$8(state, stateObj);
    window.localStorage.setItem("coffeekrakenio", JSON.stringify(newState));
  }
  function loadDocmap() {
    return __awaiter$6(this, void 0, void 0, function* () {
      getState();
    });
  }
  var __decorate = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter$5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class VersionSelector extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        }
      });
      this._versions = [];
      (() => __awaiter$5(this, void 0, void 0, function* () {
        const docmapJson = yield loadDocmap();
        this._versions = docmapJson.snapshots || [];
        this._currentVersion = yield getCurrentVersion();
      }))();
    }
    _change(e) {
      setTimeout(() => {
        let newLocation = document.location.href;
        if (document.location.href.match(/^https?:\/\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\./)) {
          newLocation = document.location.href.replace(/^(https?:\/\/v)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.(.*)/, `$1${e.target.value}.$2`);
        } else {
          newLocation = document.location.href.replace(/^(https?:\/\/)(.*)/, `$1v${e.target.value}.$2`);
        }
        document.location = newLocation;
      });
    }
    render() {
      return html$2`
            <label class="s-select s-color:accent">
                <select @change="${this._change}">
                    ${this._versions.map((snap) => html$2`
                            <option ?selected="${this._currentVersion === snap}" value="${snap}">${snap}</option>
                        `)}
                </select>
            </label>
        `;
    }
  }
  __decorate([
    property$3()
  ], VersionSelector.prototype, "_currentVersion", void 0);
  __decorate([
    property$3()
  ], VersionSelector.prototype, "_versions", void 0);
  function define$3(props = {}, tagName = "version-selector") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, VersionSelector);
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  var _a, _b, _c, _d, _e;
  var _f;
  {
    console.warn("lit-html is in dev mode. Not recommended for production!");
  }
  const wrap$1 = ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
  const trustedTypes = globalThis.trustedTypes;
  const policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
    createHTML: (s) => s
  }) : void 0;
  const identityFunction = (value) => value;
  const noopSanitizer = (_node, _name, _type) => identityFunction;
  const createSanitizer = (node, name, type) => {
    return sanitizerFactoryInternal();
  };
  const boundAttributeSuffix = "$lit$";
  const marker = `lit$${String(Math.random()).slice(9)}$`;
  const markerMatch = "?" + marker;
  const nodeMarker = `<${markerMatch}>`;
  const d = document;
  const createMarker = (v = "") => d.createComment(v);
  const isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
  const isArray = Array.isArray;
  const isIterable = (value) => {
    var _a2;
    return isArray(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
  };
  const SPACE_CHAR = `[ 	
\f\r]`;
  const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
  const NAME_CHAR = `[^\\s"'>=/]`;
  const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  const COMMENT_START = 1;
  const TAG_NAME = 2;
  const DYNAMIC_TAG_NAME = 3;
  const commentEndRegex = /-->/g;
  const comment2EndRegex = />/g;
  const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
  const ENTIRE_MATCH = 0;
  const ATTRIBUTE_NAME = 1;
  const SPACES_AND_EQUALS = 2;
  const QUOTE_CHAR = 3;
  const singleQuoteAttrEndRegex = /'/g;
  const doubleQuoteAttrEndRegex = /"/g;
  const rawTextElement = /^(?:script|style|textarea)$/i;
  const SVG_RESULT = 2;
  const ATTRIBUTE_PART = 1;
  const CHILD_PART = 2;
  const PROPERTY_PART = 3;
  const BOOLEAN_ATTRIBUTE_PART = 4;
  const EVENT_PART = 5;
  const ELEMENT_PART = 6;
  const COMMENT_PART = 7;
  const noChange = Symbol.for("lit-noChange");
  const nothing = Symbol.for("lit-nothing");
  const templateCache = new WeakMap();
  const walker = d.createTreeWalker(d, 129, null, false);
  let sanitizerFactoryInternal = noopSanitizer;
  const getTemplateHtml = (strings, type) => {
    const l = strings.length - 1;
    const attrNames = [];
    let html2 = type === SVG_RESULT ? "<svg>" : "";
    let rawTextEndRegex;
    let regex = textEndRegex;
    for (let i = 0; i < l; i++) {
      const s = strings[i];
      let attrNameEndIndex = -1;
      let attrName;
      let lastIndex = 0;
      let match;
      while (lastIndex < s.length) {
        regex.lastIndex = lastIndex;
        match = regex.exec(s);
        if (match === null) {
          break;
        }
        lastIndex = regex.lastIndex;
        if (regex === textEndRegex) {
          if (match[COMMENT_START] === "!--") {
            regex = commentEndRegex;
          } else if (match[COMMENT_START] !== void 0) {
            regex = comment2EndRegex;
          } else if (match[TAG_NAME] !== void 0) {
            if (rawTextElement.test(match[TAG_NAME])) {
              rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, "g");
            }
            regex = tagEndRegex;
          } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
            regex = tagEndRegex;
          }
        } else if (regex === tagEndRegex) {
          if (match[ENTIRE_MATCH] === ">") {
            regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
            attrNameEndIndex = -1;
          } else if (match[ATTRIBUTE_NAME] === void 0) {
            attrNameEndIndex = -2;
          } else {
            attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
            attrName = match[ATTRIBUTE_NAME];
            regex = match[QUOTE_CHAR] === void 0 ? tagEndRegex : match[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
          }
        } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
          regex = tagEndRegex;
        } else if (regex === commentEndRegex || regex === comment2EndRegex) {
          regex = textEndRegex;
        } else {
          regex = tagEndRegex;
          rawTextEndRegex = void 0;
        }
      }
      {
        console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
      }
      const end = regex === tagEndRegex && strings[i + 1].startsWith("/>") ? " " : "";
      html2 += regex === textEndRegex ? s + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix + s.slice(attrNameEndIndex)) + marker + end : s + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
    }
    const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
    return [
      policy !== void 0 ? policy.createHTML(htmlResult) : htmlResult,
      attrNames
    ];
  };
  class Template {
    constructor({strings, ["_$litType$"]: type}, options) {
      this.parts = [];
      let node;
      let nodeIndex = 0;
      let attrNameIndex = 0;
      const partCount = strings.length - 1;
      const parts = this.parts;
      const [html2, attrNames] = getTemplateHtml(strings, type);
      this.el = Template.createElement(html2, options);
      walker.currentNode = this.el.content;
      if (type === SVG_RESULT) {
        const content = this.el.content;
        const svgElement = content.firstChild;
        svgElement.remove();
        content.append(...svgElement.childNodes);
      }
      while ((node = walker.nextNode()) !== null && parts.length < partCount) {
        if (node.nodeType === 1) {
          if (node.hasAttributes()) {
            const attrsToRemove = [];
            for (const name of node.getAttributeNames()) {
              if (name.endsWith(boundAttributeSuffix) || name.startsWith(marker)) {
                const realName = attrNames[attrNameIndex++];
                attrsToRemove.push(name);
                if (realName !== void 0) {
                  const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                  const statics = value.split(marker);
                  const m = /([.?@])?(.*)/.exec(realName);
                  parts.push({
                    type: ATTRIBUTE_PART,
                    index: nodeIndex,
                    name: m[2],
                    strings: statics,
                    ctor: m[1] === "." ? PropertyPart : m[1] === "?" ? BooleanAttributePart : m[1] === "@" ? EventPart : AttributePart
                  });
                } else {
                  parts.push({
                    type: ELEMENT_PART,
                    index: nodeIndex
                  });
                }
              }
            }
            for (const name of attrsToRemove) {
              node.removeAttribute(name);
            }
          }
          if (rawTextElement.test(node.tagName)) {
            const strings2 = node.textContent.split(marker);
            const lastIndex = strings2.length - 1;
            if (lastIndex > 0) {
              node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
              for (let i = 0; i < lastIndex; i++) {
                node.append(strings2[i], createMarker());
                walker.nextNode();
                parts.push({type: CHILD_PART, index: ++nodeIndex});
              }
              node.append(strings2[lastIndex], createMarker());
            }
          }
        } else if (node.nodeType === 8) {
          const data = node.data;
          if (data === markerMatch) {
            parts.push({type: CHILD_PART, index: nodeIndex});
          } else {
            let i = -1;
            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
              parts.push({type: COMMENT_PART, index: nodeIndex});
              i += marker.length - 1;
            }
          }
        }
        nodeIndex++;
      }
    }
    static createElement(html2, _options) {
      const el = d.createElement("template");
      el.innerHTML = html2;
      return el;
    }
  }
  function resolveDirective(part, value, parent = part, attributeIndex) {
    var _a2, _b2, _c2;
    var _d2;
    if (value === noChange) {
      return value;
    }
    let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
    const nextDirectiveConstructor = isPrimitive(value) ? void 0 : value["_$litDirective$"];
    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
      (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
      if (nextDirectiveConstructor === void 0) {
        currentDirective = void 0;
      } else {
        currentDirective = new nextDirectiveConstructor(part);
        currentDirective._$initialize(part, parent, attributeIndex);
      }
      if (attributeIndex !== void 0) {
        ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
      } else {
        parent.__directive = currentDirective;
      }
    }
    if (currentDirective !== void 0) {
      value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
    }
    return value;
  }
  class TemplateInstance {
    constructor(template, parent) {
      this._parts = [];
      this._$disconnectableChildren = void 0;
      this._$template = template;
      this._$parent = parent;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(options) {
      var _a2;
      const {el: {content}, parts} = this._$template;
      const fragment = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d).importNode(content, true);
      walker.currentNode = fragment;
      let node = walker.nextNode();
      let nodeIndex = 0;
      let partIndex = 0;
      let templatePart = parts[0];
      while (templatePart !== void 0) {
        if (nodeIndex === templatePart.index) {
          let part;
          if (templatePart.type === CHILD_PART) {
            part = new ChildPart(node, node.nextSibling, this, options);
          } else if (templatePart.type === ATTRIBUTE_PART) {
            part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
          } else if (templatePart.type === ELEMENT_PART) {
            part = new ElementPart(node, this, options);
          }
          this._parts.push(part);
          templatePart = parts[++partIndex];
        }
        if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
          node = walker.nextNode();
          nodeIndex++;
        }
      }
      return fragment;
    }
    _update(values) {
      let i = 0;
      for (const part of this._parts) {
        if (part !== void 0) {
          if (part.strings !== void 0) {
            part._$setValue(values, part, i);
            i += part.strings.length - 2;
          } else {
            part._$setValue(values[i]);
          }
        }
        i++;
      }
    }
  }
  class ChildPart {
    constructor(startNode, endNode, parent, options) {
      this.type = CHILD_PART;
      this.__isConnected = true;
      this._$disconnectableChildren = void 0;
      this._$startNode = startNode;
      this._$endNode = endNode;
      this._$parent = parent;
      this.options = options;
      {
        this._textSanitizer = void 0;
      }
    }
    get _$isConnected() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
    }
    get parentNode() {
      return wrap$1(this._$startNode).parentNode;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
      value = resolveDirective(this, value, directiveParent);
      if (isPrimitive(value)) {
        if (value === nothing || value == null || value === "") {
          if (this._$committedValue !== nothing) {
            this._$clear();
          }
          this._$committedValue = nothing;
        } else if (value !== this._$committedValue && value !== noChange) {
          this._commitText(value);
        }
      } else if (value["_$litType$"] !== void 0) {
        this._commitTemplateResult(value);
      } else if (value.nodeType !== void 0) {
        this._commitNode(value);
      } else if (isIterable(value)) {
        this._commitIterable(value);
      } else {
        this._commitText(value);
      }
    }
    _insert(node, ref = this._$endNode) {
      return wrap$1(wrap$1(this._$startNode).parentNode).insertBefore(node, ref);
    }
    _commitNode(value) {
      var _a2;
      if (this._$committedValue !== value) {
        this._$clear();
        if (sanitizerFactoryInternal !== noopSanitizer) {
          const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
          if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
            this._insert(new Text("/* lit-html will not write TemplateResults to scripts and styles */"));
            return;
          }
        }
        this._$committedValue = this._insert(value);
      }
    }
    _commitText(value) {
      const node = wrap$1(this._$startNode).nextSibling;
      if (node !== null && node.nodeType === 3 && (this._$endNode === null ? wrap$1(node).nextSibling === null : node === wrap$1(this._$endNode).previousSibling)) {
        {
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer();
          }
          value = this._textSanitizer(value);
        }
        node.data = value;
      } else {
        {
          const textNode = document.createTextNode("");
          this._commitNode(textNode);
          if (this._textSanitizer === void 0) {
            this._textSanitizer = createSanitizer();
          }
          value = this._textSanitizer(value);
          textNode.data = value;
        }
      }
      this._$committedValue = value;
    }
    _commitTemplateResult(result) {
      var _a2;
      const {values, ["_$litType$"]: type} = result;
      const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(type.h, this.options)), type);
      if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template) {
        this._$committedValue._update(values);
      } else {
        const instance = new TemplateInstance(template, this);
        const fragment = instance._clone(this.options);
        instance._update(values);
        this._commitNode(fragment);
        this._$committedValue = instance;
      }
    }
    _$getTemplate(result) {
      let template = templateCache.get(result.strings);
      if (template === void 0) {
        templateCache.set(result.strings, template = new Template(result));
      }
      return template;
    }
    _commitIterable(value) {
      if (!isArray(this._$committedValue)) {
        this._$committedValue = [];
        this._$clear();
      }
      const itemParts = this._$committedValue;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        if (partIndex === itemParts.length) {
          itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
        } else {
          itemPart = itemParts[partIndex];
        }
        itemPart._$setValue(item);
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        this._$clear(itemPart && wrap$1(itemPart._$endNode).nextSibling, partIndex);
        itemParts.length = partIndex;
      }
    }
    _$clear(start = wrap$1(this._$startNode).nextSibling, from) {
      var _a2;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from);
      while (start && start !== this._$endNode) {
        const n = wrap$1(start).nextSibling;
        wrap$1(start).remove();
        start = n;
      }
    }
    setConnected(isConnected) {
      var _a2;
      if (this._$parent === void 0) {
        this.__isConnected = isConnected;
        (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
      } else {
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      }
    }
  }
  class AttributePart {
    constructor(element, name, strings, parent, options) {
      this.type = ATTRIBUTE_PART;
      this._$committedValue = nothing;
      this._$disconnectableChildren = void 0;
      this.element = element;
      this.name = name;
      this._$parent = parent;
      this.options = options;
      if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
        this._$committedValue = new Array(strings.length - 1).fill(nothing);
        this.strings = strings;
      } else {
        this._$committedValue = nothing;
      }
      {
        this._sanitizer = void 0;
      }
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
      const strings = this.strings;
      let change = false;
      if (strings === void 0) {
        value = resolveDirective(this, value, directiveParent, 0);
        change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
        if (change) {
          this._$committedValue = value;
        }
      } else {
        const values = value;
        value = strings[0];
        let i, v;
        for (i = 0; i < strings.length - 1; i++) {
          v = resolveDirective(this, values[valueIndex + i], directiveParent, i);
          if (v === noChange) {
            v = this._$committedValue[i];
          }
          change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);
          if (v === nothing) {
            value = nothing;
          } else if (value !== nothing) {
            value += (v !== null && v !== void 0 ? v : "") + strings[i + 1];
          }
          this._$committedValue[i] = v;
        }
      }
      if (change && !noCommit) {
        this._commitValue(value);
      }
    }
    _commitValue(value) {
      if (value === nothing) {
        wrap$1(this.element).removeAttribute(this.name);
      } else {
        {
          if (this._sanitizer === void 0) {
            this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
          }
          value = this._sanitizer(value !== null && value !== void 0 ? value : "");
        }
        wrap$1(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
      }
    }
  }
  class PropertyPart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = PROPERTY_PART;
    }
    _commitValue(value) {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
        }
        value = this._sanitizer(value);
      }
      this.element[this.name] = value === nothing ? void 0 : value;
    }
  }
  class BooleanAttributePart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = BOOLEAN_ATTRIBUTE_PART;
    }
    _commitValue(value) {
      if (value && value !== nothing) {
        wrap$1(this.element).setAttribute(this.name, "");
      } else {
        wrap$1(this.element).removeAttribute(this.name);
      }
    }
  }
  class EventPart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = EVENT_PART;
    }
    _$setValue(newListener, directiveParent = this) {
      var _a2;
      newListener = (_a2 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing;
      if (newListener === noChange) {
        return;
      }
      const oldListener = this._$committedValue;
      const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
      const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.name, this, oldListener);
      }
      if (shouldAddListener) {
        this.element.addEventListener(this.name, this, newListener);
      }
      this._$committedValue = newListener;
    }
    handleEvent(event) {
      var _a2, _b2;
      if (typeof this._$committedValue === "function") {
        this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
      } else {
        this._$committedValue.handleEvent(event);
      }
    }
  }
  class ElementPart {
    constructor(element, parent, options) {
      this.element = element;
      this.type = ELEMENT_PART;
      this._$disconnectableChildren = void 0;
      this._$parent = parent;
      this.options = options;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value) {
      resolveDirective(this, value);
    }
  }
  (_d = (_c = globalThis)["litHtmlPlatformSupport"]) === null || _d === void 0 ? void 0 : _d.call(_c, Template, ChildPart);
  ((_e = (_f = globalThis)["litHtmlVersions"]) !== null && _e !== void 0 ? _e : _f["litHtmlVersions"] = []).push("2.0.0-rc.4");
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const PartType = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
  };
  const directive = (c) => (...values) => ({
    ["_$litDirective$"]: c,
    values
  });
  class Directive {
    constructor(_partInfo) {
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$initialize(part, parent, attributeIndex) {
      this.__part = part;
      this._$parent = parent;
      this.__attributeIndex = attributeIndex;
    }
    _$resolve(part, props) {
      return this.update(part, props);
    }
    update(_part, props) {
      return this.render(...props);
    }
  }
  /**
  * @license
  * Copyright 2017 Google LLC
  * SPDX-License-Identifier: BSD-3-Clause
  */
  const HTML_RESULT = 1;
  class UnsafeHTMLDirective extends Directive {
    constructor(partInfo) {
      super(partInfo);
      this._value = nothing;
      if (partInfo.type !== PartType.CHILD) {
        throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
      }
    }
    render(value) {
      if (value === nothing) {
        this._templateResult = void 0;
        return this._value = value;
      }
      if (value === noChange) {
        return value;
      }
      if (typeof value != "string") {
        throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
      }
      if (value === this._value) {
        return this._templateResult;
      }
      this._value = value;
      const strings = [value];
      strings.raw = strings;
      return this._templateResult = {
        ["_$litType$"]: this.constructor.resultType,
        strings,
        values: []
      };
    }
  }
  UnsafeHTMLDirective.directiveName = "unsafeHTML";
  UnsafeHTMLDirective.resultType = HTML_RESULT;
  const unsafeHTML = directive(UnsafeHTMLDirective);
  class SHighlightJsComponentInterface extends SInterface {
  }
  SHighlightJsComponentInterface.definition = {
    items: {
      type: "String|Function"
    },
    value: {
      type: "String",
      default: "value"
    },
    label: {
      type: "String|Function",
      default: "value"
    },
    emptyText: {
      type: "String",
      default: "No item to display"
    },
    loadingText: {
      type: "String",
      default: "Loading please wait..."
    },
    filtrable: {
      type: {
        type: "Array<String>",
        splitChars: [","]
      },
      default: []
    },
    templates: {
      description: 'Specify either an object with properties like "item", "empty" and "loading", or a function returning the good template depending on tne "type" argument property',
      type: "Object|Function"
    },
    closeTimeout: {
      type: "Number",
      default: 100
    },
    interactive: {
      type: "Boolean",
      default: false
    },
    notSelectable: {
      type: "Boolean",
      default: false
    },
    maxItems: {
      type: "Number",
      default: 25
    }
  };
  function plainObject(object) {
    if (!object)
      return false;
    if (typeof object !== "object")
      return false;
    if (object.constructor && object.constructor.name !== "Object")
      return false;
    if (Object.prototype.toString.call(object) !== "[object Object]")
      return false;
    if (object !== Object(object))
      return false;
    return true;
  }
  function __deepMerge(...args) {
    function merge(firstObj, secondObj) {
      const newObj = {};
      if (!firstObj && secondObj)
        return secondObj;
      if (!secondObj && firstObj)
        return firstObj;
      if (!firstObj && !secondObj)
        return {};
      const firstProps = Object.getOwnPropertyNames(firstObj);
      firstProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(firstObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = firstObj[key];
        }
      });
      const secondProps = Object.getOwnPropertyNames(secondObj);
      secondProps.forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(secondObj, key);
        if (desc.set || desc.get) {
          Object.defineProperty(newObj, key, desc);
        } else if (plainObject(newObj[key]) && plainObject(secondObj[key])) {
          newObj[key] = merge(newObj[key], secondObj[key]);
        } else {
          newObj[key] = secondObj[key];
        }
      });
      return newObj;
    }
    let currentObj = {};
    for (let i = 0; i < args.length; i++) {
      const toMergeObj = args[i];
      currentObj = merge(currentObj, toMergeObj);
    }
    return currentObj;
  }
  function clone(object, settings = {}) {
    settings = Object.assign({deep: false}, settings);
    if (settings.deep) {
      return __deepClone(object);
    }
    return __clone(object);
  }
  function scrollTop() {
    return window.pageYOffset || document.scrollTop || document.body.scrollTop;
  }
  function offset(elm) {
    const box = elm.getBoundingClientRect(), body = document.body, docEl = document.documentElement, scrollTop2 = window.pageYOffset || docEl.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft, clientTop = docEl.clientTop || body.clientTop || 0, clientLeft = docEl.clientLeft || body.clientLeft || 0, top = box.top + scrollTop2 - clientTop, left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
  function fromElementTopToViewportBottom(elm) {
    const offsets = offset(elm);
    const scrollTop$1 = scrollTop();
    const viewportHeight = window.innerHeight;
    const distance = viewportHeight - offsets.top + scrollTop$1;
    return distance;
  }
  function camelize(text) {
    let res = "";
    const reg = /(?:^|[_-\s])(\w)/g;
    res = text.replace(reg, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
    res = res.substr(0, 1).toLowerCase() + res.slice(1);
    return res.trim();
  }
  function autoCast(string) {
    if (typeof string !== "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
      return string.substr(1, string.length - 2);
    }
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber)) {
      if (presumedNumber.toString() === string) {
        return presumedNumber;
      }
    }
    if (window[string]) {
      return string;
    }
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e) {
      return string;
    }
  }
  function getStyleProperty(elm, property) {
    setTimeout(() => {
      elm._sComputedStyle = null;
    });
    const computed = elm._sComputedStyle || window.getComputedStyle(elm);
    elm._sComputedStyle = computed;
    const prefixes = ["", "webkit-", "moz-", "ms-", "o-", "khtml-"];
    for (let i = 0; i < prefixes.length; i++) {
      const prefix = prefixes[i];
      const value = computed[camelize(`${prefix}${property}`)];
      if (value && value.trim() !== "")
        return autoCast(value);
    }
    return null;
  }
  function fromElementTopToViewportTop(elm) {
    const offsets = offset(elm);
    const scrollTop$1 = scrollTop();
    return offsets.top - scrollTop$1;
  }
  /*!
  * hotkeys-js v3.8.5
  * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
  * 
  * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
  * http://jaywcjlove.github.io/hotkeys
  * 
  * Licensed under the MIT license.
  */
  var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent(object, event, method) {
    if (object.addEventListener) {
      object.addEventListener(event, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event), function() {
        method(window.event);
      });
    }
  }
  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i = 0; i < mods.length; i++) {
      mods[i] = modifier[mods[i].toLowerCase()];
    }
    return mods;
  }
  function getKeys(key) {
    if (typeof key !== "string")
      key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index = keys.lastIndexOf("");
    for (; index >= 0; ) {
      keys[index - 1] += ",";
      keys.splice(index, 1);
      index = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray(a1, a2) {
    var arr1 = a1.length >= a2.length ? a1 : a2;
    var arr2 = a1.length >= a2.length ? a2 : a1;
    var isIndex = true;
    for (var i = 0; i < arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) === -1)
        isIndex = false;
    }
    return isIndex;
  }
  var _keyMap = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff ? 173 : 189,
    "=": isff ? 61 : 187,
    ";": isff ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier = {
    "\u21E7": 16,
    shift: 16,
    "\u2325": 18,
    alt: 18,
    option: 18,
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {};
  for (var k = 1; k < 20; k++) {
    _keyMap["f".concat(k)] = 111 + k;
  }
  var _downKeys = [];
  var _scope = "all";
  var elementHasBindEvent = [];
  var code = function code2(x) {
    return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
  };
  function setScope(scope) {
    _scope = scope || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function filter(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag = false;
    }
    return flag;
  }
  function isPressed(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code(keyCode);
    }
    return _downKeys.indexOf(keyCode) !== -1;
  }
  function deleteScope(scope, newScope) {
    var handlers;
    var i;
    if (!scope)
      scope = getScope();
    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for (i = 0; i < handlers.length; ) {
          if (handlers[i].scope === scope)
            handlers.splice(i, 1);
          else
            i++;
        }
      }
    }
    if (getScope() === scope)
      setScope(newScope || "all");
  }
  function clearModifier(event) {
    var key = event.keyCode || event.which || event.charCode;
    var i = _downKeys.indexOf(key);
    if (i >= 0) {
      _downKeys.splice(i, 1);
    }
    if (event.key && event.key.toLowerCase() === "meta") {
      _downKeys.splice(0, _downKeys.length);
    }
    if (key === 93 || key === 224)
      key = 91;
    if (key in _mods) {
      _mods[key] = false;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = false;
      }
    }
  }
  function unbind(keysInfo) {
    if (!keysInfo) {
      Object.keys(_handlers).forEach(function(key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key)
          eachUnbind(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key)
        eachUnbind(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var scope = args[0], method = args[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code(lastKey);
      if (!_handlers[keyCode])
        return;
      if (!scope)
        scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].map(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
          return {};
        }
        return record;
      });
    });
  };
  function eventHandler(event, handler, scope) {
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y)) {
          if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault)
            event.preventDefault();
          else
            event.returnValue = false;
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.cancelBubble)
            event.cancelBubble = true;
        }
      }
    }
  }
  function dispatch(event) {
    var asterisk = _handlers["*"];
    var key = event.keyCode || event.which || event.charCode;
    if (!hotkeys.filter.call(this, event))
      return;
    if (key === 93 || key === 224)
      key = 91;
    if (_downKeys.indexOf(key) === -1 && key !== 229)
      _downKeys.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap[keyName];
      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    if (key in _mods) {
      _mods[key] = true;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = true;
      }
      if (!asterisk)
        return;
    }
    for (var e in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e)) {
        _mods[e] = event[modifierMap[e]];
      }
    }
    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }
      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }
      _mods[17] = true;
      _mods[18] = true;
    }
    var scope = getScope();
    if (asterisk) {
      for (var i = 0; i < asterisk.length; i++) {
        if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
          eventHandler(event, asterisk[i], scope);
        }
      }
    }
    if (!(key in _handlers))
      return;
    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a2 = 0; a2 < keyShortcut.length; a2++) {
            _downKeysCurrent.push(code(keyShortcut[a2]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
            eventHandler(event, record, scope);
          }
        }
      }
    }
  }
  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }
  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope)
        scope = option.scope;
      if (option.element)
        element = option.element;
      if (option.keyup)
        keyup = option.keyup;
      if (option.keydown !== void 0)
        keydown = option.keydown;
      if (typeof option.splitKey === "string")
        splitKey = option.splitKey;
    }
    if (typeof option === "string")
      scope = option;
    for (; i < keys.length; i++) {
      key = keys[i].split(splitKey);
      mods = [];
      if (key.length > 1)
        mods = getMods(_modifier, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code(key);
      if (!(key in _handlers))
        _handlers[key] = [];
      _handlers[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i],
        method,
        key: keys[i],
        splitKey
      });
    }
    if (typeof element !== "undefined" && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, "keydown", function(e) {
        dispatch(e);
      });
      addEvent(window, "focus", function() {
        _downKeys = [];
      });
      addEvent(element, "keyup", function(e) {
        dispatch(e);
        clearModifier(e);
      });
    }
  }
  var _api = {
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    isPressed,
    filter,
    unbind
  };
  for (var a in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a)) {
      hotkeys[a] = _api[a];
    }
  }
  if (typeof window !== "undefined") {
    var _hotkeys = window.hotkeys;
    hotkeys.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }
      return hotkeys;
    };
    window.hotkeys = hotkeys;
  }
  var hotkeys_common = hotkeys;
  hotkeys_common.filter = function() {
    return true;
  };
  function hotkey(hotkey2, settings = {}) {
    return new SPromise(({resolve, reject, emit, cancel}) => {
      settings = Object.assign({element: null, keyup: false, keydown: true, once: false, splitKey: "+"}, settings);
      hotkeys_common(hotkey2, settings, (e, h) => {
        emit("press", e);
        if (settings.once)
          cancel();
      });
    }, {
      id: "hotkey"
    }).on("finally", () => {
      hotkeys_common.unbind(hotkey2);
    });
  }
  function stripTags(html2) {
    const tmp = document.createElement("div");
    tmp.innerHTML = html2;
    return tmp.textContent || tmp.innerText || "";
  }
  function onScrollEnd($elm, callback, settings) {
    const finalSettings = Object.assign({offset: 20, once: false, times: -1}, settings !== null && settings !== void 0 ? settings : {});
    let isBody = false;
    let $scrollListenedElm = $elm;
    let $scrollHeightElm = $elm;
    if ($elm === window.document.body) {
      isBody = true;
      $scrollListenedElm = document;
      $scrollHeightElm = window.document.body;
    } else if ($elm === window.document) {
      isBody = true;
      $elm = window.document.body;
      $scrollHeightElm = window.document.body;
    }
    let active = true, count = 0;
    const internalCallback = (e) => {
      let fullHeight, viewportHeight, scrollTop2;
      if (isBody) {
        viewportHeight = window.innerHeight;
        scrollTop2 = $scrollHeightElm.scrollTop;
        fullHeight = Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight);
      } else {
        viewportHeight = $scrollHeightElm.offsetHeight;
        scrollTop2 = $scrollHeightElm.scrollTop;
        fullHeight = $scrollHeightElm.scrollHeight;
      }
      console.log("is", active);
      console.log($elm, scrollTop2, viewportHeight, fullHeight, finalSettings.offset);
      console.log(scrollTop2 + viewportHeight, fullHeight - finalSettings.offset);
      if (active && scrollTop2 + viewportHeight >= fullHeight - finalSettings.offset) {
        callback();
        count++;
        if (finalSettings.once) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        } else if (finalSettings.times > 0 && count >= finalSettings.times) {
          $scrollListenedElm.removeEventListener("scroll", internalCallback);
          active = false;
        }
      } else if ($scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop < $scrollHeightElm.scrollHeight - finalSettings.offset) {
        active = true;
      }
    };
    console.log($scrollListenedElm);
    $scrollListenedElm.addEventListener("scroll", internalCallback);
  }
  var __css$1 = ".s-filtrable-input {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: inline-block;\n    position: relative;\n\n    /* @sugar.scope.lnf {\n        .s-filtrable-input__list {\n            transition: max-height 0.1s ease-in-out;\n        }\n\n        .s-filtrable-input__list-item-highlight {\n            background-color: sugar.color(current);\n        }\n    } */\n}\n\n    .s-filtrable-input .s-filtrable-input__input {\n    }\n\n    .s-filtrable-input .s-filtrable-input__list {\n        position: absolute;\n        top: 100%;\n        left: 0;\n        overflow-x: hidden;\n        overflow-y: auto;\n        opacity: 0;\n        max-width: calc(100vw - 100px);\n        pointer-events: none;\n        margin: 20px 0;\n    }\n\n    .s-filtrable-input:focus-within .s-filtrable-input__list {\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-filtrable-input.s-filtrable-input--top .s-filtrable-input__list {\n            top: auto;\n            bottom: 100%;\n        }\n\n    .s-filtrable-input .s-filtrable-input__input:focus + .s-filtrable-input__list,\n    .s-filtrable-input .s-filtrable-input__list:focus,\n    .s-filtrable-input .s-filtrable-input__list:focus-within {\n        opacity: 1;\n        pointer-events: all !important;\n    }\n\n    .s-filtrable-input .s-filtrable-input__list-item {\n        position: relative;\n        -webkit-user-select: none;\n           -moz-user-select: none;\n            -ms-user-select: none;\n                user-select: none;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item {\n        cursor: pointer;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item * {\n            pointer-events: none;\n        }\n";
  var __awaiter$4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SFiltrableInput extends SLitComponent {
    constructor() {
      super(__deepMerge({
        litComponent: {
          shadowDom: false
        },
        componentUtils: {
          interface: SHighlightJsComponentInterface
        }
      }));
      this.state = {
        baseTemplates: void 0,
        preselectedItem: void 0,
        preselectedItemIdx: -1,
        selectedItemIdx: -1,
        displayedMaxItems: 0,
        value: "",
        isActive: false,
        isLoading: false,
        items: [],
        filteredItems: []
      };
      this.state.displayedMaxItems = this.props.maxItems;
      if (this.props.items && typeof this.props.items === "string") {
        const $itemsElm = document.querySelector(this.props.items);
        if ($itemsElm) {
          this.state.items = JSON.parse($itemsElm.innerHTML);
          this.requestUpdate();
        }
      }
      this.state.baseTemplates = ({type, item, html: html2}) => {
        switch (type) {
          case "item":
            return html2`
                        <div class="${this.componentUtils.className("__item")}">
                            ${unsafeHTML(typeof this.props.label === "function" ? this.props.label(item) : item[this.props.label])}
                        </div>
                    `;
          case "empty":
            return html2`
                        <div
                            class="${this.componentUtils.className("__empty")}"
                        >
                            ${this.props.emptyText}
                        </div>
                    `;
          case "loading":
            return html2`
                        <div
                            class="${this.componentUtils.className("__loading")}"
                        >
                            ${this.props.loadingText}
                        </div>
                    `;
        }
      };
    }
    static get styles() {
      return css$1`
            ${unsafeCSS(__css$1)}
        `;
    }
    firstUpdated() {
      var _a2;
      return __awaiter$4(this, void 0, void 0, function* () {
        this.$input = this.querySelector("input");
        this.$input.setAttribute("autocomplete", "off");
        if (!this.props.bare) {
          (_a2 = this.$input.classList) === null || _a2 === void 0 ? void 0 : _a2.add("s-input");
        }
        this.$input.addEventListener("keyup", (e) => {
          const value = e.target.value;
          this.state.value = value;
          this.state.displayedMaxItems = this.props.maxItems;
          this.filterItems();
        });
        this.$input.classList.add(this.componentUtils.className("__input"));
        this.$container = this;
        this.$container.classList.add("s-filtrable-input");
        this.$container.classList.add(this.componentUtils.className());
        this.$list = this.querySelector("ul");
        this.prepend(this.$input);
        this.filterItems();
        document.addEventListener("scroll", () => {
          this._updateListSizeAndPosition();
        });
        this.$input.addEventListener("focus", (e) => {
          this.state.isActive = true;
          this.filterItems();
          this._updateListSizeAndPosition();
        });
        this._updateListSizeAndPosition();
        onScrollEnd(this.$list, () => {
          var _a3;
          this.state.displayedMaxItems = ((_a3 = this.state.displayedMaxItems) !== null && _a3 !== void 0 ? _a3 : 0) + this.props.maxItems;
          this.filterItems(false);
        });
        hotkey("escape").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.close();
        });
        hotkey("up").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.state.preselectedItemIdx = this.state.preselectedItemIdx > 0 ? this.state.preselectedItemIdx - 1 : 0;
          this.requestUpdate();
          const $item = this.$list.children[this.state.preselectedItemIdx];
          $item.focus();
        });
        hotkey("down").on("press", (e) => {
          e.preventDefault();
          if (!this.state.isActive)
            return;
          this.state.preselectedItemIdx = this.state.preselectedItemIdx >= this.state.filteredItems.length - 1 ? this.state.filteredItems.length - 1 : this.state.preselectedItemIdx + 1;
          this.requestUpdate();
          const $item = this.$list.children[this.state.preselectedItemIdx];
          $item.focus();
        });
        hotkey("return").on("press", (e) => {
          if (!this.state.isActive)
            return;
          this.validateAndClose();
        });
      });
    }
    get selectedItem() {
      if (this.state.selectedItemIdx === -1)
        return;
      return this.state.filteredItems[this.state.selectedItemIdx];
    }
    get preselectedItem() {
      if (this.state.preselectedItemIdx === -1)
        return;
      return this.state.filteredItems[this.state.preselectedItemIdx];
    }
    validate() {
      if (!this.state.preselectedItem)
        return;
      if (this.state.preselectedItem) {
        if (typeof this.props.value === "string" && this.state.preselectedItem[this.props.value]) {
          this.$input.value = stripTags(this.state.preselectedItem[this.props.value]);
        } else if (typeof this.props.value === "function") {
          const v = this.props.value({
            item: this.state.filteredItems[this.state.preselectedItemIdx]
          });
          if (typeof v !== "string") {
            throw new Error(`<red>[s-filtrable-input]</red> Sorry but the returned value "<yellow>${v}</yellow>" has to be a string...`);
          }
          this.$input.value = stripTags(v);
        }
      }
      this.state.selectedItemIdx = this.state.preselectedItemIdx;
      this.state.value = this.$input.value;
      this.requestUpdate();
    }
    validateAndClose() {
      this.validate();
      setTimeout(() => {
        this.close();
      }, this.props.closeTimeout);
    }
    close() {
      this.$input.focus();
      this.$input.blur();
      this.state.isActive = false;
    }
    refreshItems() {
      return __awaiter$4(this, void 0, void 0, function* () {
        if (typeof this.props.items === "function") {
          this.state.isLoading = true;
          this.requestUpdate();
          const items = yield this.props.items({
            value: this.$input.value
          });
          if (plainObject(items)) {
            this.state.items = Object.values(items);
          } else if (Array.isArray(items)) {
            this.state.items = items;
          } else {
            throw new Error(`Sorry but the "items" MUST be an Array...`);
          }
        }
      });
    }
    filterItems(needUpdate = true) {
      return __awaiter$4(this, void 0, void 0, function* () {
        if (needUpdate)
          yield this.refreshItems();
        let items = this.state.items;
        let matchedItemsCount = 0;
        const filteredItems = items.map((item) => clone(item)).filter((item) => {
          if (matchedItemsCount >= this.state.displayedMaxItems)
            return false;
          if (!this.props.filtrable.length)
            return true;
          let matchFilter = false;
          for (let i = 0; i < Object.keys(item).length; i++) {
            const propName = Object.keys(item)[i], propValue = item[propName];
            if (typeof propValue !== "string")
              continue;
            if (this.props.filtrable.indexOf(propName) !== -1) {
              const reg = new RegExp(this.state.value.split(" ").join("|"), "gi");
              if (propValue.match(reg)) {
                matchFilter = true;
                if (this.state.value && this.state.value !== "") {
                  const reg2 = new RegExp(this.state.value.split(" ").join("|"), "gi");
                  const finalString = propValue.replace(reg2, (str) => {
                    return `<span class="${this.componentUtils.className("__list-item-highlight")} s-highlight"
                                                >${str}</span>`;
                  });
                  item[propName] = finalString;
                }
              }
            }
          }
          if (matchFilter) {
            matchedItemsCount++;
          }
          return matchFilter;
        });
        this.state.filteredItems = filteredItems;
        this.state.isLoading = false;
        this.requestUpdate();
      });
    }
    select(idx) {
      this._setPreselectedItemByIdx(idx);
      this.validate();
    }
    selectAndValidate(idx) {
      this._setPreselectedItemByIdx(idx);
      this.validate();
    }
    selectValidateAndClose(idx) {
      this._setPreselectedItemByIdx(idx);
      this.validateAndClose();
    }
    _setPreselectedItemByIdx(idx) {
      if (this.props.notSelectable)
        return;
      this.state.preselectedItemIdx = idx;
      this.state.preselectedItem = this.state.items[idx];
      this.requestUpdate();
    }
    _updateListSizeAndPosition() {
      if (!this.state.isActive)
        return;
      const marginTop = getStyleProperty(this.$list, "marginTop");
      getStyleProperty(this.$list, "marginLeft");
      getStyleProperty(this.$list, "marginRight");
      const marginBottom = getStyleProperty(this.$list, "marginBottom");
      const distanceTop = fromElementTopToViewportTop(this.$input);
      const distanceBottom = fromElementTopToViewportBottom(this.$input) - this.$input.clientHeight;
      let maxHeight;
      if (distanceTop > distanceBottom) {
        this.$container.classList.add("s-filtrable-input--top");
        this.$list.style.top = `auto`;
        this.$list.style.bottom = `calc(100% - ${marginBottom})`;
        maxHeight = distanceTop - parseInt(marginTop);
      } else {
        this.$container.classList.remove("s-filtrable-input--top");
        this.$list.style.bottom = `auto`;
        this.$list.style.top = `calc(100% - ${marginTop})`;
        maxHeight = distanceBottom - parseInt(marginBottom);
      }
      this.$list.style.maxHeight = `${maxHeight}px`;
    }
    render() {
      var _a2, _b2, _c2, _d2, _e2, _f2;
      return html$2`
            <ul
                class="s-filtrable-input__list ${this.componentUtils.className("__list")}"
            >
                ${this.state.isLoading ? html$2`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-loading ${this.componentUtils.className("__list-item __list-loading")}"
                          >
                              ${(_c2 = (_b2 = (_a2 = this.props).templates) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
        type: "loading",
        html: html$2
      })) !== null && _c2 !== void 0 ? _c2 : this.state.baseTemplates({
        type: "loading",
        html: html$2
      })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length <= 0 ? html$2`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-no-item  ${this.componentUtils.className("__list-item __list-no-item")}"
                          >
                              ${(_f2 = (_e2 = (_d2 = this.props).templates) === null || _e2 === void 0 ? void 0 : _e2.call(_d2, {
        type: "empty",
        html: html$2
      })) !== null && _f2 !== void 0 ? _f2 : this.state.baseTemplates({
        type: "empty",
        html: html$2
      })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length ? this.state.filteredItems.map((item, idx) => {
        var _a3, _b3, _c3;
        return idx < this.state.displayedMaxItems ? html$2`
                                    <li
                                        @click=${() => this.selectAndValidate(idx)}
                                        @dblclick=${() => this.selectValidateAndClose(idx)}
                                        @focus=${() => this._setPreselectedItemByIdx(idx)}
                                        style="z-index: ${999999999 - idx}"
                                        tabindex="0"
                                        class="s-filtrable-input__list-item ${this.componentUtils.className("__list-item") + " " + (this.state.selectedItemIdx === idx ? "active" : "")}"
                                        hoverable
                                    >
                                        ${(_c3 = (_b3 = (_a3 = this.props).templates) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, {
          type: "item",
          html: html$2,
          unsafeHTML,
          item,
          idx
        })) !== null && _c3 !== void 0 ? _c3 : this.state.baseTemplates({
          type: "item",
          html: html$2,
          unsafeHTML,
          item,
          idx
        })}
                                    </li>
                                ` : "";
      }) : ""}
            </ul>
        `;
    }
  }
  function define$2(props = {}, tagName = "s-filtrable-input") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, SFiltrableInput);
  }
  var __awaiter$3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let searchItems;
  define$2({
    value: "name",
    label: (item) => {
      return `${item.type} ${item.namespace}`;
    },
    filtrable: ["namespace", "name", "type"],
    templates: ({type, item, html, unsafeHTML}) => {
      var _a, _b, _c;
      if (type === "item") {
        return html`
                    <div class="__item">
                        <div class="s-flex s-mbe:10">
                            <h4
                                class="__title s-typo:bold s-tc:accent s-flex-item:grow"
                            >
                                ${unsafeHTML(item.name)}
                            </h4>
                            <div>
                                ${item.platform.map((platform) => html`
                                        <i
                                            class="s-platform:${platform.name}"
                                        ></i>
                                    `)}
                                &nbsp;
                                <span class="s-badge s-color:main"
                                    >${unsafeHTML((_a = item.type) !== null && _a !== void 0 ? _a : "")}</span
                                >
                            </div>
                        </div>
                        <p class="__namespace s-opacity:50 s-font:20 s-mbe:20">
                            ${unsafeHTML((_b = item.namespace) !== null && _b !== void 0 ? _b : "")}
                        </p>
                        <p class="__description s-typo:p s-truncate:2">
                            ${unsafeHTML((_c = item.description) !== null && _c !== void 0 ? _c : "")}
                        </p>
                    </div>
                `;
      }
    },
    items: ({value}) => __awaiter$3(void 0, void 0, void 0, function* () {
      function fetchItems() {
        return __awaiter$3(this, void 0, void 0, function* () {
          const request = new SRequest({
            url: "/docmap.json"
          });
          const result = yield request.send();
          searchItems = Object.values(result.data.map);
          window.localStorage.setItem("ck-search-items", JSON.stringify(searchItems));
        });
      }
      const cached = window.localStorage.getItem("ck-search-items");
      if (!cached) {
        const items = yield fetchItems();
        return items;
      }
      fetchItems();
      return JSON.parse(cached);
    })
  }, "ck-search-input");
  class CKSearch extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        }
      });
    }
    firstUpdated() {
      return __awaiter$3(this, void 0, void 0, function* () {
      });
    }
    render() {
      return html$2`
            <div class="ck-search">
                <div class="__background"></div>
                <div class="__content s-color:accent">
                    <ck-search-input>
                        <input
                            placeholder="Keywords based search..."
                            type="text"
                            name="search"
                            class="s-input s-color:accent s-scale:11"
                        />
                    </ck-search-input>
                </div>
            </div>
        `;
    }
  }
  function define$1(props = {}, tagName = "ck-search") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, CKSearch);
  }
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class CkSettings extends SLitComponent {
    constructor() {
      super({
        litComponent: {
          shadowDom: false
        }
      });
      this._settings = {
        darkMode: true,
        colors: {
          accent: void 0,
          complementary: void 0
        }
      };
      (() => __awaiter$2(this, void 0, void 0, function* () {
        this._currentVersion = yield getCurrentVersion();
      }))();
      this._restoreState();
    }
    firstUpdated() {
      return __awaiter$2(this, void 0, void 0, function* () {
        const $root = document.querySelector(":root"), $darkRoot = document.querySelector(".s-theme--coffeekrakenDark"), $theme = $darkRoot !== null && $darkRoot !== void 0 ? $darkRoot : $root;
        const $mainColorPicker = this.querySelector("#setting-main-color");
        const $accentColorPicker = this.querySelector("#setting-accent-color");
        $mainColorPicker.addEventListener("change", (e) => {
          $theme.style.setProperty("--s-theme-color-main-h", e.detail.hsla.h);
          $theme.style.setProperty("--s-theme-color-main-s", e.detail.hsla.s);
          $theme.style.setProperty("--s-theme-color-main-l", e.detail.hsla.l);
        });
        $accentColorPicker.addEventListener("change", (e) => {
          $theme.style.setProperty("--s-theme-color-accent-h", e.detail.hsla.h);
          $theme.style.setProperty("--s-theme-color-accent-s", e.detail.hsla.s);
          $theme.style.setProperty("--s-theme-color-accent-l", e.detail.hsla.l);
        });
      });
    }
    _restoreState() {
      const state = getState();
      this.setDarkMode(state.darkMode);
    }
    _saveState() {
      setState(Object.assign({}, this._settings));
    }
    setDarkMode(mode) {
      this._settings.darkMode = mode;
      if (mode) {
        document.body.classList.add("s-theme--coffeekraken-dark");
      } else {
        document.body.classList.remove("s-theme--coffeekraken-dark");
      }
      this._saveState();
    }
    render() {
      return html$2`
            <div class="s-p:10">
                <ul class="__settings s-bg:odd">
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="theme-switcher">
                            Dark mode
                            <input
                                class="s-switch"
                                type="checkbox"
                                id="theme-switcher"
                                ?checked="${this._settings.darkMode}"
                                @change="${(e) => {
        this.setDarkMode(e.target.checked);
      }}"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="theme-switcher">
                            Dark mode
                            <input
                                class="s-switch s-color:accent"
                                type="checkbox"
                                id="theme-switcher"
                                ?checked="${this._settings.darkMode}"
                                @change="${(e) => {
        this.setDarkMode(e.target.checked);
      }}"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-main-color">
                            Main color
                            <s-color-picker id="setting-main-color" value="#ff0000" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Accent color
                            <s-color-picker id="setting-accent-color" value="#ff0000" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Complementary color
                            <s-color-picker id="setting-complementary-color" value="#ff0000" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <s-range
                                name="hello"
                                class="s-range s-cs"
                                id="setting-spread"
                                tooltip
                                min="0"
                                max="100"
                                step="10"
                            ></s-range>
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <s-range
                                name="coco"
                                class="s-color:accent"
                                id="setting-spread"
                                tooltip
                                min="0"
                                max="100"
                                step="10"
                            ></s-range>
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <input type="text" class="s-input" id="setting-spread" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <input type="text" class="s-input s-color:accent" id="setting-spread" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <input type="text" class="s-input" id="setting-spread" />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label class="s-label s-p:20" for="setting-accent-color">
                            Spread
                            <input type="text" class="s-input" id="setting-spread" />
                        </label>
                    </li>
                </ul>
            </div>
        `;
    }
  }
  function define(props = {}, tagName = "ck-settings") {
    SLitComponent.setDefaultProps(tagName, props);
    customElements.define(tagName, CkSettings);
  }
  var requiresPort = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port)
      return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
  var querystringify$1 = {};
  var has = Object.prototype.hasOwnProperty, undef;
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
      return null;
    }
  }
  function encode(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  }
  function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
    while (part = parser.exec(query)) {
      var key = decode(part[1]), value = decode(part[2]);
      if (key === null || value === null || key in result)
        continue;
      result[key] = value;
    }
    return result;
  }
  function querystringify(obj, prefix) {
    prefix = prefix || "";
    var pairs = [], value, key;
    if (typeof prefix !== "string")
      prefix = "?";
    for (key in obj) {
      if (has.call(obj, key)) {
        value = obj[key];
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = "";
        }
        key = encode(key);
        value = encode(value);
        if (key === null || value === null)
          continue;
        pairs.push(key + "=" + value);
      }
    }
    return pairs.length ? prefix + pairs.join("&") : "";
  }
  querystringify$1.stringify = querystringify;
  querystringify$1.parse = querystring;
  var required = requiresPort, qs = querystringify$1, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/, protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i, whitespace = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]", left = new RegExp("^" + whitespace + "+");
  function trimLeft(str) {
    return (str ? str : "").toString().replace(left, "");
  }
  var rules = [
    ["#", "hash"],
    ["?", "query"],
    function sanitize(address) {
      return address.replace("\\", "/");
    },
    ["/", "pathname"],
    ["@", "auth", 1],
    [NaN, "host", void 0, 1, 1],
    [/:(\d+)$/, "port", void 0, 1],
    [NaN, "hostname", void 0, 1, 1]
  ];
  var ignore = {hash: 1, query: 1};
  function lolcation(loc) {
    var globalVar;
    if (typeof window !== "undefined")
      globalVar = window;
    else if (typeof commonjsGlobal !== "undefined")
      globalVar = commonjsGlobal;
    else if (typeof self !== "undefined")
      globalVar = self;
    else
      globalVar = {};
    var location = globalVar.location || {};
    loc = loc || location;
    var finaldestination = {}, type = typeof loc, key;
    if (loc.protocol === "blob:") {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if (type === "string") {
      finaldestination = new Url(loc, {});
      for (key in ignore)
        delete finaldestination[key];
    } else if (type === "object") {
      for (key in loc) {
        if (key in ignore)
          continue;
        finaldestination[key] = loc[key];
      }
      if (finaldestination.slashes === void 0) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
    return finaldestination;
  }
  function extractProtocol(address) {
    address = trimLeft(address);
    var match = protocolre.exec(address), protocol = match[1] ? match[1].toLowerCase() : "", slashes = !!(match[2] && match[2].length >= 2), rest = match[2] && match[2].length === 1 ? "/" + match[3] : match[3];
    return {
      protocol,
      slashes,
      rest
    };
  }
  function resolve(relative, base) {
    if (relative === "")
      return base;
    var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
    while (i--) {
      if (path[i] === ".") {
        path.splice(i, 1);
      } else if (path[i] === "..") {
        path.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0)
          unshift = true;
        path.splice(i, 1);
        up--;
      }
    }
    if (unshift)
      path.unshift("");
    if (last === "." || last === "..")
      path.push("");
    return path.join("/");
  }
  function Url(address, location, parser) {
    address = trimLeft(address);
    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }
    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
    if (type !== "object" && type !== "string") {
      parser = location;
      location = null;
    }
    if (parser && typeof parser !== "function")
      parser = qs.parse;
    location = lolcation(location);
    extracted = extractProtocol(address || "");
    relative = !extracted.protocol && !extracted.slashes;
    url.slashes = extracted.slashes || relative && location.slashes;
    url.protocol = extracted.protocol || location.protocol || "";
    address = extracted.rest;
    if (!extracted.slashes)
      instructions[3] = [/(.*)/, "pathname"];
    for (; i < instructions.length; i++) {
      instruction = instructions[i];
      if (typeof instruction === "function") {
        address = instruction(address);
        continue;
      }
      parse = instruction[0];
      key = instruction[1];
      if (parse !== parse) {
        url[key] = address;
      } else if (typeof parse === "string") {
        if (~(index = address.indexOf(parse))) {
          if (typeof instruction[2] === "number") {
            url[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if (index = parse.exec(address)) {
        url[key] = index[1];
        address = address.slice(0, index.index);
      }
      url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
      if (instruction[4])
        url[key] = url[key].toLowerCase();
    }
    if (parser)
      url.query = parser(url.query);
    if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
      url.pathname = resolve(url.pathname, location.pathname);
    }
    if (url.pathname.charAt(0) !== "/" && url.hostname) {
      url.pathname = "/" + url.pathname;
    }
    if (!required(url.port, url.protocol)) {
      url.host = url.hostname;
      url.port = "";
    }
    url.username = url.password = "";
    if (url.auth) {
      instruction = url.auth.split(":");
      url.username = instruction[0] || "";
      url.password = instruction[1] || "";
    }
    url.origin = url.protocol && url.host && url.protocol !== "file:" ? url.protocol + "//" + url.host : "null";
    url.href = url.toString();
  }
  function set(part, value, fn) {
    var url = this;
    switch (part) {
      case "query":
        if (typeof value === "string" && value.length) {
          value = (fn || qs.parse)(value);
        }
        url[part] = value;
        break;
      case "port":
        url[part] = value;
        if (!required(value, url.protocol)) {
          url.host = url.hostname;
          url[part] = "";
        } else if (value) {
          url.host = url.hostname + ":" + value;
        }
        break;
      case "hostname":
        url[part] = value;
        if (url.port)
          value += ":" + url.port;
        url.host = value;
        break;
      case "host":
        url[part] = value;
        if (/:\d+$/.test(value)) {
          value = value.split(":");
          url.port = value.pop();
          url.hostname = value.join(":");
        } else {
          url.hostname = value;
          url.port = "";
        }
        break;
      case "protocol":
        url.protocol = value.toLowerCase();
        url.slashes = !fn;
        break;
      case "pathname":
      case "hash":
        if (value) {
          var char = part === "pathname" ? "/" : "#";
          url[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url[part] = value;
        }
        break;
      default:
        url[part] = value;
    }
    for (var i = 0; i < rules.length; i++) {
      var ins = rules[i];
      if (ins[4])
        url[ins[1]] = url[ins[1]].toLowerCase();
    }
    url.origin = url.protocol && url.host && url.protocol !== "file:" ? url.protocol + "//" + url.host : "null";
    url.href = url.toString();
    return url;
  }
  function toString(stringify) {
    if (!stringify || typeof stringify !== "function")
      stringify = qs.stringify;
    var query, url = this, protocol = url.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ":")
      protocol += ":";
    var result = protocol + (url.slashes ? "//" : "");
    if (url.username) {
      result += url.username;
      if (url.password)
        result += ":" + url.password;
      result += "@";
    }
    result += url.host + url.pathname;
    query = typeof url.query === "object" ? stringify(url.query) : url.query;
    if (query)
      result += query.charAt(0) !== "?" ? "?" + query : query;
    if (url.hash)
      result += url.hash;
    return result;
  }
  Url.prototype = {set, toString};
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;
  var urlParse = Url;
  function ease(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  let isUserScrolling = false;
  let userScrollingTimeout;
  let isScrollingHappening = false;
  document.addEventListener("mousewheel", (e) => {
    if (!isScrollingHappening)
      return;
    isUserScrolling = true;
    clearTimeout(userScrollingTimeout);
    userScrollingTimeout = setTimeout(() => {
      isUserScrolling = false;
    }, 200);
  });
  function scrollTo(target, settings = {}) {
    return new Promise((resolve, reject) => {
      settings = Object.assign({duration: 500, easing: ease, offset: 0, align: "top", onFinish: null}, settings);
      const docElem = document.documentElement;
      const windowHeight = window.innerHeight;
      const maxScroll = docElem.scrollHeight - windowHeight;
      const currentY = window.pageYOffset;
      isScrollingHappening = true;
      let targetY = currentY;
      const elementBounds = isNaN(target) ? target.getBoundingClientRect() : 0;
      if (settings.align === "center") {
        targetY += elementBounds.top + elementBounds.height / 2;
        targetY -= windowHeight / 2;
        targetY -= settings.offset;
      } else if (settings.align === "bottom") {
        targetY += elementBounds.bottom;
        targetY -= windowHeight;
        targetY += settings.offset;
      } else {
        targetY += elementBounds.top;
        targetY -= settings.offset;
      }
      targetY = Math.max(Math.min(maxScroll, targetY), 0);
      const deltaY = targetY - currentY;
      const obj = {
        targetY,
        deltaY,
        duration: settings.duration,
        easing: settings.easing,
        onFinish() {
          settings.onFinish && settings.onFinish();
          resolve();
        },
        startTime: Date.now(),
        lastY: currentY,
        step: scrollTo.step
      };
      requestAnimationFrame$1(obj.step.bind(obj));
    });
  }
  scrollTo.step = function() {
    if (this.lastY !== window.pageYOffset && this.onFinish) {
      isScrollingHappening = false;
      this.onFinish();
      return;
    }
    const t = Math.min((Date.now() - this.startTime) / this.duration, 1);
    const y = this.targetY - (1 - this.easing(t)) * this.deltaY;
    window.scrollTo(window.scrollX, y);
    if (t !== 1 && !isUserScrolling) {
      this.lastY = window.pageYOffset;
      requestAnimationFrame$1(this.step.bind(this));
    } else {
      isScrollingHappening = false;
      if (this.onFinish)
        this.onFinish();
    }
  };
  function smoothScrollOnAnchorLinks(settings = {}) {
    settings = __deepMerge$8({
      scroll: {},
      checkPathNames: true
    }, settings);
    querySelectorLive('a:not([is])[href*="#"]', ($link) => {
      $link.addEventListener("click", (e) => {
        const linkUrl = urlParse($link.getAttribute("href"));
        const currentUrl = urlParse();
        if (!linkUrl.hash || linkUrl.hash === "#")
          return;
        if (settings.checkPathNames && currentUrl.pathname !== linkUrl.pathname)
          return;
        const $target = document.querySelector(linkUrl.hash);
        if (!$target)
          return;
        e.preventDefault();
        history.pushState({}, null, linkUrl.hash);
        scrollTo($target, settings.scroll);
      });
    });
  }
  function scrollToLocationHash(settings = {}) {
    settings = __deepMerge$8({
      scroll: {}
    }, settings);
    const hash = document.location.hash;
    if (!hash)
      return;
    const targetElm = document.querySelector(hash);
    if (!targetElm)
      return;
    if ("scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    return scrollTo(targetElm, settings.scroll);
  }
  function smoothScrollOnPageLoad(settings = {}) {
    settings = __deepMerge$8({
      scroll: {}
    }, settings);
    scrollToLocationHash(settings);
  }
  function smoothScrollOnHashChange(settings = {}) {
    settings = __deepMerge$8({
      scroll: {}
    }, settings);
    window.addEventListener("hashchange", (e) => {
      scrollToLocationHash(settings);
    });
  }
  function smoothScroll(settings = {}) {
    settings = __deepMerge$8({
      scroll: {}
    }, settings);
    smoothScrollOnPageLoad(settings);
    smoothScrollOnAnchorLinks(settings);
    smoothScrollOnHashChange(settings);
  }
  function linksStateAttributes(settings = {}) {
    settings = __deepMerge$8({}, settings);
    function handleLink($linkElm) {
      if ($linkElm.getAttribute("href") === document.location.pathname) {
        $linkElm.setAttribute("actual", true);
      } else if ($linkElm.getAttribute("href").startsWith(document.location.pathname)) {
        $linkElm.removeAttribute("actual");
        $linkElm.setAttribute("actual-child", true);
      } else {
        $linkElm.removeAttribute("actual");
        $linkElm.removeAttribute("actual-child");
      }
    }
    querySelectorLive(`[href]`, ($linkElm) => {
      handleLink($linkElm);
    });
    window.addEventListener("locationchange", () => {
      Array.from(document.querySelectorAll("[href]")).forEach(($linkElm) => {
        handleLink($linkElm);
      });
    });
  }
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SFeature extends SClass {
    constructor(name, node, settings = {}) {
      var _a;
      super(__deepMerge$8({
        componentUtils: {},
        feature: {}
      }, settings));
      this.componentUtils = new SComponent(node, node.attributes, {
        componentUtils: Object.assign(Object.assign({}, (_a = this._settings.componentUtils) !== null && _a !== void 0 ? _a : {}), {name})
      });
      this.props = this.componentUtils.props;
      this.name = name;
      this.node = node;
      (() => __awaiter$1(this, void 0, void 0, function* () {
        var _b;
        const mountedCallback = yield this.componentUtils.whenMountState();
        yield (_b = this.mount) === null || _b === void 0 ? void 0 : _b.call(this);
        mountedCallback();
      }))();
    }
    static setDefaultProps(selector, props) {
      SComponent.setDefaultProps(selector, props);
    }
    static registerFeature(name, feature, defaultProps = {}) {
      this.setDefaultProps(name, defaultProps);
      querySelectorLive(`[${name}]`, ($elm) => {
        new feature(name, $elm, SComponent.getDefaultProps(name));
      });
    }
    get featureSettings() {
      return this._settings.feature;
    }
  }
  class SActivateFeatureInterface extends SInterface {
    static get _definition() {
      return {
        href: {
          type: "String",
          default: ""
        },
        group: {
          type: "String"
        },
        toggle: {
          type: {
            type: "Boolean",
            nullishAsTrue: true
          },
          default: false
        },
        history: {
          type: {
            type: "Boolean",
            nullishAsTrue: true
          },
          default: false
        },
        active: {
          type: {
            type: "Boolean",
            nullishAsTrue: true
          },
          default: false,
          physical: true
        },
        activeClass: {
          type: "String",
          description: "Specify the class to apply on target(s) when activate",
          default: "active"
        },
        activeAttribute: {
          type: "String",
          description: "Specify the attribute to apply on target(s) when activate",
          default: "active"
        },
        saveState: {
          type: "Boolean",
          default: false
        },
        activateTimeout: {
          type: "Number",
          default: 0
        },
        unactivateTimeout: {
          type: "Number",
          default: 0
        },
        trigger: {
          type: {
            type: "Array<String>",
            splitChars: [","]
          },
          default: ["click"]
        }
      };
    }
  }
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SActivateFeature extends SFeature {
    constructor(name, node, settings) {
      super(name, node, __deepMerge$8({
        componentUtils: {
          interface: SActivateFeatureInterface
        },
        feature: {}
      }, settings !== null && settings !== void 0 ? settings : {}));
      this.componentUtils.exposeApi({
        activate: this.activate,
        unactivate: this.unactivate,
        isActive: this.isActive
      }, this);
    }
    mount() {
      if (this.props.saveState) {
        if (!this.props.id)
          throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
        if (localStorage.getItem(`s-activate-state-${this.saveStateId}`) === this.props.id) {
          this.props.active = true;
        } else {
          this.props.active = false;
        }
      }
      if (this.props.href) {
        this._hrefSelector = this.props.href;
      }
      let targets;
      if (this._hrefSelector)
        targets = Array.from(document.querySelectorAll(this._hrefSelector));
      if (targets === null || targets === void 0 ? void 0 : targets.length)
        this._$targets = targets;
      if (this.props.group) {
        this._$groupElements = Array.from(document.querySelectorAll(`[${this.name}][group="${this.props.group}"]`));
      }
      this.props.trigger.forEach((trigger) => {
        switch (trigger) {
          case "click":
            this.node.addEventListener("click", (e) => {
              if (this.isActive() && this.props.toggle) {
                this.unactivate();
              } else {
                this.activate();
              }
            });
            break;
          case "mouseover":
            this.node.addEventListener("mouseover", (e) => {
              this.activate();
            });
            break;
          case "mouseout":
          case "mouseleave":
            this.node.addEventListener("mouseleave", (e) => {
              this.unactivate();
            });
            break;
          case "anchor":
            if (document.location.hash === this._hrefSelector) {
              this.activate();
            }
            window.addEventListener("hashchange", (e) => {
              if (document.location.hash === this._hrefSelector) {
                this.activate();
              }
            });
            break;
        }
      });
      if (this.props.active) {
        this.activate(true);
      }
    }
    get saveStateId() {
      return this.props.group ? `group-${this.props.group}` : this.props.id;
    }
    isActive() {
      return this.node.hasAttribute("active");
    }
    activate(force = false) {
      return __awaiter(this, void 0, void 0, function* () {
        clearTimeout(this._unactivateTimeout);
        if (!force && this.isActive())
          return;
        setTimeout(() => {
          if (this.props.saveState) {
            if (!this.props.id)
              throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
            localStorage.setItem(`s-activate-state-${this.saveStateId}`, this.props.id);
          }
          if (this.props.history && this._hrefSelector) {
            document.location.hash = this._hrefSelector;
          }
          if (this._$groupElements) {
            this._$groupElements.forEach(($element) => {
              var _a;
              if ($element === this.node)
                return;
              try {
                (_a = $element.unactivate) === null || _a === void 0 ? void 0 : _a.call($element);
              } catch (e) {
              }
            });
          }
          this.props.active = true;
          if (this._$targets) {
            this._$targets.forEach(($target) => {
              if (this.props.activeClass) {
                $target.classList.add(this.props.activeClass);
              }
              if (this.props.activeAttribute) {
                $target.setAttribute(this.props.activeAttribute, "true");
              }
            });
          }
        }, this.props.activateTimeout);
      });
    }
    unactivate() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isActive())
          return;
        this._unactivateTimeout = setTimeout(() => {
          if (this.props.saveState) {
            if (!this.props.id)
              throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
            localStorage.removeItem(`s-activate-state-${this.props.id}`);
          }
          this.node.removeAttribute("active");
          if (this._$targets) {
            this._$targets.forEach(($target) => {
              if (this.props.activeClass) {
                $target.classList.remove(this.props.activeClass);
              }
              if (this.props.activeAttribute) {
                $target.removeAttribute(this.props.activeAttribute);
              }
            });
          }
        }, this.props.unactivateTimeout);
      });
    }
  }
  function register$1(props = {}, name = "s-activate") {
    SFeature.registerFeature(name, SActivateFeature, props);
  }
  class SFormValidateFeatureInterface extends SInterface {
    static get _definition() {
      return {
        type: {
          type: "String",
          default: "text"
        },
        on: {
          type: "Array<String>",
          values: ["change", "submit", "enter", "reset"],
          default: ["change", "submit", "enter", "reset"]
        },
        wrap: {
          type: "Boolean",
          default: true
        },
        errorClass: {
          type: "String",
          default: "s-form-validate s-form-validate--error s-color--error"
        },
        errorMessageClass: {
          type: "String",
          default: "s-form-validate__error-message"
        },
        validClass: {
          type: "String",
          default: "s-form-validate s-form-validate--valid s-color--success"
        },
        customValidations: {
          type: "Object",
          default: {}
        },
        joiOptions: {
          type: "Object",
          default: {}
        },
        language: {
          type: "String",
          default: "fr"
        },
        displayError: {
          type: "Boolean",
          default: true
        },
        alphanum: {
          type: "Boolean",
          description: "String: Requires the string value to only contain a-z, A-Z, and 0-9."
        },
        base64: {
          type: "Boolean",
          description: "String: Requires the string value to be a valid base64 string; does not check the decoded value."
        },
        case: {
          type: "String",
          values: ["upper", "lower"],
          description: "String: Sets the required string case"
        },
        creditCard: {
          type: "Boolean",
          description: "String: Requires the number to be a credit card number (Using Luhn Algorithm)."
        },
        dataUri: {
          type: "Boolean",
          description: "String: Requires the string value to be a valid data URI string."
        },
        domain: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid domain name."
        },
        email: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid email address."
        },
        guid: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid GUID."
        },
        hex: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid hexadecimal string."
        },
        hostname: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid hostname as per RFC1123."
        },
        insensitive: {
          type: "Boolean|String",
          description: "String: Allows the value to match any value in the allowed list or disallowed list in a case insensitive comparison."
        },
        ip: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid ip address."
        },
        isoDate: {
          type: "Boolean|String",
          description: "String: Requires the string value to be in valid ISO 8601 date format."
        },
        isoDuration: {
          type: "Boolean|String",
          description: "String: Requires the string value to be in valid ISO 8601 duration format."
        },
        length: {
          type: "Number",
          description: "String: Specifies the exact string length required"
        },
        lowercase: {
          type: "Boolean|String",
          description: "String: Requires the string value to be all lowercase. If the validation convert option is on (enabled by default), the string will be forced to lowercase."
        },
        max: {
          type: "Number",
          description: "String: String: Specifies the maximum number of string characters\nDate: Specifies the latest date allowed\nNumber: Specifies the minimum value"
        },
        min: {
          type: "Number",
          description: "String: String: Specifies the minimum number string characters\nDate: Specifies the oldest date allowed\nNumber: Specifies the minimum value"
        },
        normalize: {
          type: "String",
          description: "String: Requires the string value to be in a Unicode normalized form. If the validation convert option is on (enabled by default), the string will be normalized."
        },
        pattern: {
          type: "String",
          description: "String: a regular expression object the string value must match against. Note that if the pattern is a regular expression, for it to match the entire key name, it must begin with ^ and end with $."
        },
        token: {
          type: "Boolean",
          description: "String: Requires the string value to only contain a-z, A-Z, 0-9, and underscore _."
        },
        trim: {
          type: "Boolean",
          description: "String: Requires the string value to contain no whitespace before or after. If the validation convert option is on (enabled by default), the string will be trimmed."
        },
        truncate: {
          type: "Boolean",
          description: "String: Specifies whether the string.max() limit should be used as a truncation."
        },
        uppercase: {
          type: "Boolean",
          description: "String: Requires the string value to be all uppercase. If the validation convert option is on (enabled by default), the string will be forced to uppercase."
        },
        uri: {
          type: "Boolean|String",
          description: "String: Requires the string value to be a valid RFC 3986 URI."
        },
        greater: {
          type: "String",
          description: "String: Date: Specifies that the value must be greater than date (or a reference)\nNumber: Specifies that the value must be greater than limit or a reference."
        },
        less: {
          type: "String",
          description: "String: Date: Specifies that the value must be less than date (or a reference)\nNumber: Specifies that the value must be less than limit or a reference."
        },
        iso: {
          type: "Boolean",
          description: "Date: Requires the string value to be in valid ISO 8601 date format."
        },
        timestamp: {
          type: "Boolean|String",
          description: "Date: Requires the value to be a timestamp interval from Unix Time"
        },
        integer: {
          type: "Boolean",
          description: "Number: Requires the number to be an integer (no floating point)."
        },
        multiple: {
          type: "Number",
          description: "Number: Specifies that the value must be a multiple of base (or a reference):"
        },
        negative: {
          type: "Boolean",
          description: "Number: Requires the number to be negative"
        },
        port: {
          type: "Boolean",
          description: "Number: Requires the number to be a TCP port, so between 0 and 65535."
        },
        positive: {
          type: "Boolean",
          description: "Number: Requires the number to be positive"
        },
        precision: {
          type: "Number",
          description: "Number: Specifies the maximum number of decimal places"
        },
        unsafe: {
          type: "Boolean",
          description: "Number: By default, numbers must be within JavaScript's safety range (Number.MIN_SAFE_INTEGER & Number.MAX_SAFE_INTEGER), and when given a string, should be converted without loss of information. You can allow unsafe numbers at your own risks by calling number.unsafe()."
        }
      };
    }
  }
  var joiBrowser_min = {exports: {}};
  (function(module2, exports) {
    !function(e, t) {
      module2.exports = t();
    }(self, function() {
      return e = {1238: (e2) => {
        e2.exports = {version: "17.4.2"};
      }, 7629: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(9474), o = r(1687), i = r(8652), l = r(8160), c = r(3292), u = r(6354), f = r(8901), m = r(9708), h = r(6914), d = r(2294), p = r(6133), g = r(1152), y = r(8863), b = r(2036), v = {Base: class {
          constructor(e3) {
            this.type = e3, this.$_root = null, this._definition = {}, this._reset();
          }
          _reset() {
            this._ids = new d.Ids(), this._preferences = null, this._refs = new p.Manager(), this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = new Map(), this.$_terms = {}, this.$_temp = {ruleset: null, whens: {}};
          }
          describe() {
            return s(typeof m.describe == "function", "Manifest functionality disabled"), m.describe(this);
          }
          allow(...e3) {
            return l.verifyFlat(e3, "allow"), this._values(e3, "_valids");
          }
          alter(e3) {
            s(e3 && typeof e3 == "object" && !Array.isArray(e3), "Invalid targets argument"), s(!this._inRuleset(), "Cannot set alterations inside a ruleset");
            const t3 = this.clone();
            t3.$_terms.alterations = t3.$_terms.alterations || [];
            for (const r2 in e3) {
              const n2 = e3[r2];
              s(typeof n2 == "function", "Alteration adjuster for", r2, "must be a function"), t3.$_terms.alterations.push({target: r2, adjuster: n2});
            }
            return t3.$_temp.ruleset = false, t3;
          }
          artifact(e3) {
            return s(e3 !== void 0, "Artifact cannot be undefined"), s(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", e3);
          }
          cast(e3) {
            return s(e3 === false || typeof e3 == "string", "Invalid to value"), s(e3 === false || this._definition.cast[e3], "Type", this.type, "does not support casting to", e3), this.$_setFlag("cast", e3 === false ? void 0 : e3);
          }
          default(e3, t3) {
            return this._default("default", e3, t3);
          }
          description(e3) {
            return s(e3 && typeof e3 == "string", "Description must be a non-empty string"), this.$_setFlag("description", e3);
          }
          empty(e3) {
            const t3 = this.clone();
            return e3 !== void 0 && (e3 = t3.$_compile(e3, {override: false})), t3.$_setFlag("empty", e3, {clone: false});
          }
          error(e3) {
            return s(e3, "Missing error"), s(e3 instanceof Error || typeof e3 == "function", "Must provide a valid Error object or a function"), this.$_setFlag("error", e3);
          }
          example(e3, t3 = {}) {
            return s(e3 !== void 0, "Missing example"), l.assertOptions(t3, ["override"]), this._inner("examples", e3, {single: true, override: t3.override});
          }
          external(e3, t3) {
            return typeof e3 == "object" && (s(!t3, "Cannot combine options with description"), t3 = e3.description, e3 = e3.method), s(typeof e3 == "function", "Method must be a function"), s(t3 === void 0 || t3 && typeof t3 == "string", "Description must be a non-empty string"), this._inner("externals", {method: e3, description: t3}, {single: true});
          }
          failover(e3, t3) {
            return this._default("failover", e3, t3);
          }
          forbidden() {
            return this.presence("forbidden");
          }
          id(e3) {
            return e3 ? (s(typeof e3 == "string", "id must be a non-empty string"), s(/^[^\.]+$/.test(e3), "id cannot contain period character"), this.$_setFlag("id", e3)) : this.$_setFlag("id", void 0);
          }
          invalid(...e3) {
            return this._values(e3, "_invalids");
          }
          label(e3) {
            return s(e3 && typeof e3 == "string", "Label name must be a non-empty string"), this.$_setFlag("label", e3);
          }
          meta(e3) {
            return s(e3 !== void 0, "Meta cannot be undefined"), this._inner("metas", e3, {single: true});
          }
          note(...e3) {
            s(e3.length, "Missing notes");
            for (const t3 of e3)
              s(t3 && typeof t3 == "string", "Notes must be non-empty strings");
            return this._inner("notes", e3);
          }
          only(e3 = true) {
            return s(typeof e3 == "boolean", "Invalid mode:", e3), this.$_setFlag("only", e3);
          }
          optional() {
            return this.presence("optional");
          }
          prefs(e3) {
            s(e3, "Missing preferences"), s(e3.context === void 0, "Cannot override context"), s(e3.externals === void 0, "Cannot override externals"), s(e3.warnings === void 0, "Cannot override warnings"), s(e3.debug === void 0, "Cannot override debug"), l.checkPreferences(e3);
            const t3 = this.clone();
            return t3._preferences = l.preferences(t3._preferences, e3), t3;
          }
          presence(e3) {
            return s(["optional", "required", "forbidden"].includes(e3), "Unknown presence mode", e3), this.$_setFlag("presence", e3);
          }
          raw(e3 = true) {
            return this.$_setFlag("result", e3 ? "raw" : void 0);
          }
          result(e3) {
            return s(["raw", "strip"].includes(e3), "Unknown result mode", e3), this.$_setFlag("result", e3);
          }
          required() {
            return this.presence("required");
          }
          strict(e3) {
            const t3 = this.clone(), r2 = e3 !== void 0 && !e3;
            return t3._preferences = l.preferences(t3._preferences, {convert: r2}), t3;
          }
          strip(e3 = true) {
            return this.$_setFlag("result", e3 ? "strip" : void 0);
          }
          tag(...e3) {
            s(e3.length, "Missing tags");
            for (const t3 of e3)
              s(t3 && typeof t3 == "string", "Tags must be non-empty strings");
            return this._inner("tags", e3);
          }
          unit(e3) {
            return s(e3 && typeof e3 == "string", "Unit name must be a non-empty string"), this.$_setFlag("unit", e3);
          }
          valid(...e3) {
            l.verifyFlat(e3, "valid");
            const t3 = this.allow(...e3);
            return t3.$_setFlag("only", !!t3._valids, {clone: false}), t3;
          }
          when(e3, t3) {
            const r2 = this.clone();
            r2.$_terms.whens || (r2.$_terms.whens = []);
            const n2 = c.when(r2, e3, t3);
            if (!["any", "link"].includes(r2.type)) {
              const e4 = n2.is ? [n2] : n2.switch;
              for (const t4 of e4)
                s(!t4.then || t4.then.type === "any" || t4.then.type === r2.type, "Cannot combine", r2.type, "with", t4.then && t4.then.type), s(!t4.otherwise || t4.otherwise.type === "any" || t4.otherwise.type === r2.type, "Cannot combine", r2.type, "with", t4.otherwise && t4.otherwise.type);
            }
            return r2.$_terms.whens.push(n2), r2.$_mutateRebuild();
          }
          cache(e3) {
            s(!this._inRuleset(), "Cannot set caching inside a ruleset"), s(!this._cache, "Cannot override schema cache"), s(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
            const t3 = this.clone();
            return t3._cache = e3 || i.provider.provision(), t3.$_temp.ruleset = false, t3;
          }
          clone() {
            const e3 = Object.create(Object.getPrototypeOf(this));
            return this._assign(e3);
          }
          concat(e3) {
            s(l.isSchema(e3), "Invalid schema object"), s(this.type === "any" || e3.type === "any" || e3.type === this.type, "Cannot merge type", this.type, "with another type:", e3.type), s(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), s(!e3._inRuleset(), "Cannot concatenate a schema with open ruleset");
            let t3 = this.clone();
            if (this.type === "any" && e3.type !== "any") {
              const r2 = e3.clone();
              for (const e4 of Object.keys(t3))
                e4 !== "type" && (r2[e4] = t3[e4]);
              t3 = r2;
            }
            t3._ids.concat(e3._ids), t3._refs.register(e3, p.toSibling), t3._preferences = t3._preferences ? l.preferences(t3._preferences, e3._preferences) : e3._preferences, t3._valids = b.merge(t3._valids, e3._valids, e3._invalids), t3._invalids = b.merge(t3._invalids, e3._invalids, e3._valids);
            for (const r2 of e3._singleRules.keys())
              t3._singleRules.has(r2) && (t3._rules = t3._rules.filter((e4) => e4.keep || e4.name !== r2), t3._singleRules.delete(r2));
            for (const r2 of e3._rules)
              e3._definition.rules[r2.method].multi || t3._singleRules.set(r2.name, r2), t3._rules.push(r2);
            if (t3._flags.empty && e3._flags.empty) {
              t3._flags.empty = t3._flags.empty.concat(e3._flags.empty);
              const r2 = Object.assign({}, e3._flags);
              delete r2.empty, o(t3._flags, r2);
            } else if (e3._flags.empty) {
              t3._flags.empty = e3._flags.empty;
              const r2 = Object.assign({}, e3._flags);
              delete r2.empty, o(t3._flags, r2);
            } else
              o(t3._flags, e3._flags);
            for (const r2 in e3.$_terms) {
              const s2 = e3.$_terms[r2];
              s2 ? t3.$_terms[r2] ? t3.$_terms[r2] = t3.$_terms[r2].concat(s2) : t3.$_terms[r2] = s2.slice() : t3.$_terms[r2] || (t3.$_terms[r2] = s2);
            }
            return this.$_root._tracer && this.$_root._tracer._combine(t3, [this, e3]), t3.$_mutateRebuild();
          }
          extend(e3) {
            return s(!e3.base, "Cannot extend type with another base"), f.type(this, e3);
          }
          extract(e3) {
            return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.reach(e3);
          }
          fork(e3, t3) {
            s(!this._inRuleset(), "Cannot fork inside a ruleset");
            let r2 = this;
            for (let s2 of [].concat(e3))
              s2 = Array.isArray(s2) ? s2 : s2.split("."), r2 = r2._ids.fork(s2, t3, r2);
            return r2.$_temp.ruleset = false, r2;
          }
          rule(e3) {
            const t3 = this._definition;
            l.assertOptions(e3, Object.keys(t3.modifiers)), s(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
            const r2 = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
            s(r2 >= 0 && r2 < this._rules.length, "Cannot apply rules to empty ruleset");
            const a2 = this.clone();
            for (let o2 = r2; o2 < a2._rules.length; ++o2) {
              const r3 = a2._rules[o2], i2 = n(r3);
              for (const n2 in e3)
                t3.modifiers[n2](i2, e3[n2]), s(i2.name === r3.name, "Cannot change rule name");
              a2._rules[o2] = i2, a2._singleRules.get(i2.name) === r3 && a2._singleRules.set(i2.name, i2);
            }
            return a2.$_temp.ruleset = false, a2.$_mutateRebuild();
          }
          get ruleset() {
            s(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
            const e3 = this.clone();
            return e3.$_temp.ruleset = e3._rules.length, e3;
          }
          get $() {
            return this.ruleset;
          }
          tailor(e3) {
            e3 = [].concat(e3), s(!this._inRuleset(), "Cannot tailor inside a ruleset");
            let t3 = this;
            if (this.$_terms.alterations)
              for (const {target: r2, adjuster: n2} of this.$_terms.alterations)
                e3.includes(r2) && (t3 = n2(t3), s(l.isSchema(t3), "Alteration adjuster for", r2, "failed to return a schema object"));
            return t3 = t3.$_modify({each: (t4) => t4.tailor(e3), ref: false}), t3.$_temp.ruleset = false, t3.$_mutateRebuild();
          }
          tracer() {
            return g.location ? g.location(this) : this;
          }
          validate(e3, t3) {
            return y.entry(e3, this, t3);
          }
          validateAsync(e3, t3) {
            return y.entryAsync(e3, this, t3);
          }
          $_addRule(e3) {
            typeof e3 == "string" && (e3 = {name: e3}), s(e3 && typeof e3 == "object", "Invalid options"), s(e3.name && typeof e3.name == "string", "Invalid rule name");
            for (const t4 in e3)
              s(t4[0] !== "_", "Cannot set private rule properties");
            const t3 = Object.assign({}, e3);
            t3._resolve = [], t3.method = t3.method || t3.name;
            const r2 = this._definition.rules[t3.method], n2 = t3.args;
            s(r2, "Unknown rule", t3.method);
            const a2 = this.clone();
            if (n2) {
              s(Object.keys(n2).length === 1 || Object.keys(n2).length === this._definition.rules[t3.name].args.length, "Invalid rule definition for", this.type, t3.name);
              for (const e4 in n2) {
                let o2 = n2[e4];
                if (o2 !== void 0) {
                  if (r2.argsByName) {
                    const i2 = r2.argsByName.get(e4);
                    if (i2.ref && l.isResolvable(o2))
                      t3._resolve.push(e4), a2.$_mutateRegister(o2);
                    else if (i2.normalize && (o2 = i2.normalize(o2), n2[e4] = o2), i2.assert) {
                      const t4 = l.validateArg(o2, e4, i2);
                      s(!t4, t4, "or reference");
                    }
                  }
                  n2[e4] = o2;
                } else
                  delete n2[e4];
              }
            }
            return r2.multi || (a2._ruleRemove(t3.name, {clone: false}), a2._singleRules.set(t3.name, t3)), a2.$_temp.ruleset === false && (a2.$_temp.ruleset = null), r2.priority ? a2._rules.unshift(t3) : a2._rules.push(t3), a2;
          }
          $_compile(e3, t3) {
            return c.schema(this.$_root, e3, t3);
          }
          $_createError(e3, t3, r2, s2, n2, a2 = {}) {
            const o2 = a2.flags !== false ? this._flags : {}, i2 = a2.messages ? h.merge(this._definition.messages, a2.messages) : this._definition.messages;
            return new u.Report(e3, t3, r2, o2, i2, s2, n2);
          }
          $_getFlag(e3) {
            return this._flags[e3];
          }
          $_getRule(e3) {
            return this._singleRules.get(e3);
          }
          $_mapLabels(e3) {
            return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.labels(e3);
          }
          $_match(e3, t3, r2, s2) {
            (r2 = Object.assign({}, r2)).abortEarly = true, r2._externals = false, t3.snapshot();
            const n2 = !y.validate(e3, this, t3, r2, s2).errors;
            return t3.restore(), n2;
          }
          $_modify(e3) {
            return l.assertOptions(e3, ["each", "once", "ref", "schema"]), d.schema(this, e3) || this;
          }
          $_mutateRebuild() {
            return s(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({each: (e3, {source: t3, name: r2, path: s2, key: n2}) => {
              const a2 = this._definition[t3][r2] && this._definition[t3][r2].register;
              a2 !== false && this.$_mutateRegister(e3, {family: a2, key: n2});
            }}), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = false, this;
          }
          $_mutateRegister(e3, {family: t3, key: r2} = {}) {
            this._refs.register(e3, t3), this._ids.register(e3, {key: r2});
          }
          $_property(e3) {
            return this._definition.properties[e3];
          }
          $_reach(e3) {
            return this._ids.reach(e3);
          }
          $_rootReferences() {
            return this._refs.roots();
          }
          $_setFlag(e3, t3, r2 = {}) {
            s(e3[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
            const n2 = this._definition.flags[e3] || {};
            if (a(t3, n2.default) && (t3 = void 0), a(t3, this._flags[e3]))
              return this;
            const o2 = r2.clone !== false ? this.clone() : this;
            return t3 !== void 0 ? (o2._flags[e3] = t3, o2.$_mutateRegister(t3)) : delete o2._flags[e3], e3[0] !== "_" && (o2.$_temp.ruleset = false), o2;
          }
          $_parent(e3, ...t3) {
            return this[e3][l.symbols.parent].call(this, ...t3);
          }
          $_validate(e3, t3, r2) {
            return y.validate(e3, this, t3, r2);
          }
          _assign(e3) {
            e3.type = this.type, e3.$_root = this.$_root, e3.$_temp = Object.assign({}, this.$_temp), e3.$_temp.whens = {}, e3._ids = this._ids.clone(), e3._preferences = this._preferences, e3._valids = this._valids && this._valids.clone(), e3._invalids = this._invalids && this._invalids.clone(), e3._rules = this._rules.slice(), e3._singleRules = n(this._singleRules, {shallow: true}), e3._refs = this._refs.clone(), e3._flags = Object.assign({}, this._flags), e3._cache = null, e3.$_terms = {};
            for (const t3 in this.$_terms)
              e3.$_terms[t3] = this.$_terms[t3] ? this.$_terms[t3].slice() : null;
            e3.$_super = {};
            for (const t3 in this.$_super)
              e3.$_super[t3] = this._super[t3].bind(e3);
            return e3;
          }
          _bare() {
            const e3 = this.clone();
            e3._reset();
            const t3 = e3._definition.terms;
            for (const r2 in t3) {
              const s2 = t3[r2];
              e3.$_terms[r2] = s2.init;
            }
            return e3.$_mutateRebuild();
          }
          _default(e3, t3, r2 = {}) {
            return l.assertOptions(r2, "literal"), s(t3 !== void 0, "Missing", e3, "value"), s(typeof t3 == "function" || !r2.literal, "Only function value supports literal option"), typeof t3 == "function" && r2.literal && (t3 = {[l.symbols.literal]: true, literal: t3}), this.$_setFlag(e3, t3);
          }
          _generate(e3, t3, r2) {
            if (!this.$_terms.whens)
              return {schema: this};
            const s2 = [], n2 = [];
            for (let a3 = 0; a3 < this.$_terms.whens.length; ++a3) {
              const o3 = this.$_terms.whens[a3];
              if (o3.concat) {
                s2.push(o3.concat), n2.push("".concat(a3, ".concat"));
                continue;
              }
              const i2 = o3.ref ? o3.ref.resolve(e3, t3, r2) : e3, l2 = o3.is ? [o3] : o3.switch, c2 = n2.length;
              for (let c3 = 0; c3 < l2.length; ++c3) {
                const {is: u2, then: f2, otherwise: m2} = l2[c3], h2 = "".concat(a3).concat(o3.switch ? "." + c3 : "");
                if (u2.$_match(i2, t3.nest(u2, "".concat(h2, ".is")), r2)) {
                  if (f2) {
                    const a4 = t3.localize([...t3.path, "".concat(h2, ".then")], t3.ancestors, t3.schemas), {schema: o4, id: i3} = f2._generate(e3, a4, r2);
                    s2.push(o4), n2.push("".concat(h2, ".then").concat(i3 ? "(".concat(i3, ")") : ""));
                    break;
                  }
                } else if (m2) {
                  const a4 = t3.localize([...t3.path, "".concat(h2, ".otherwise")], t3.ancestors, t3.schemas), {schema: o4, id: i3} = m2._generate(e3, a4, r2);
                  s2.push(o4), n2.push("".concat(h2, ".otherwise").concat(i3 ? "(".concat(i3, ")") : ""));
                  break;
                }
              }
              if (o3.break && n2.length > c2)
                break;
            }
            const a2 = n2.join(", ");
            if (t3.mainstay.tracer.debug(t3, "rule", "when", a2), !a2)
              return {schema: this};
            if (!t3.mainstay.tracer.active && this.$_temp.whens[a2])
              return {schema: this.$_temp.whens[a2], id: a2};
            let o2 = this;
            this._definition.generate && (o2 = this._definition.generate(this, e3, t3, r2));
            for (const e4 of s2)
              o2 = o2.concat(e4);
            return this.$_root._tracer && this.$_root._tracer._combine(o2, [this, ...s2]), this.$_temp.whens[a2] = o2, {schema: o2, id: a2};
          }
          _inner(e3, t3, r2 = {}) {
            s(!this._inRuleset(), "Cannot set ".concat(e3, " inside a ruleset"));
            const n2 = this.clone();
            return n2.$_terms[e3] && !r2.override || (n2.$_terms[e3] = []), r2.single ? n2.$_terms[e3].push(t3) : n2.$_terms[e3].push(...t3), n2.$_temp.ruleset = false, n2;
          }
          _inRuleset() {
            return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
          }
          _ruleRemove(e3, t3 = {}) {
            if (!this._singleRules.has(e3))
              return this;
            const r2 = t3.clone !== false ? this.clone() : this;
            r2._singleRules.delete(e3);
            const s2 = [];
            for (let t4 = 0; t4 < r2._rules.length; ++t4) {
              const n2 = r2._rules[t4];
              n2.name !== e3 || n2.keep ? s2.push(n2) : r2._inRuleset() && t4 < r2.$_temp.ruleset && --r2.$_temp.ruleset;
            }
            return r2._rules = s2, r2;
          }
          _values(e3, t3) {
            l.verifyFlat(e3, t3.slice(1, -1));
            const r2 = this.clone(), n2 = e3[0] === l.symbols.override;
            if (n2 && (e3 = e3.slice(1)), !r2[t3] && e3.length ? r2[t3] = new b() : n2 && (r2[t3] = e3.length ? new b() : null, r2.$_mutateRebuild()), !r2[t3])
              return r2;
            n2 && r2[t3].override();
            for (const n3 of e3) {
              s(n3 !== void 0, "Cannot call allow/valid/invalid with undefined"), s(n3 !== l.symbols.override, "Override must be the first value");
              const e4 = t3 === "_invalids" ? "_valids" : "_invalids";
              r2[e4] && (r2[e4].remove(n3), r2[e4].length || (s(t3 === "_valids" || !r2._flags.only, "Setting invalid value", n3, "leaves schema rejecting all values due to previous valid rule"), r2[e4] = null)), r2[t3].add(n3, r2._refs);
            }
            return r2;
          }
        }};
        v.Base.prototype[l.symbols.any] = {version: l.version, compile: c.compile, root: "$_root"}, v.Base.prototype.isImmutable = true, v.Base.prototype.deny = v.Base.prototype.invalid, v.Base.prototype.disallow = v.Base.prototype.invalid, v.Base.prototype.equal = v.Base.prototype.valid, v.Base.prototype.exist = v.Base.prototype.required, v.Base.prototype.not = v.Base.prototype.invalid, v.Base.prototype.options = v.Base.prototype.prefs, v.Base.prototype.preferences = v.Base.prototype.prefs, e2.exports = new v.Base();
      }, 8652: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(8160), o = {max: 1e3, supported: new Set(["undefined", "boolean", "number", "string"])};
        t2.provider = {provision: (e3) => new o.Cache(e3)}, o.Cache = class {
          constructor(e3 = {}) {
            a.assertOptions(e3, ["max"]), s(e3.max === void 0 || e3.max && e3.max > 0 && isFinite(e3.max), "Invalid max cache size"), this._max = e3.max || o.max, this._map = new Map(), this._list = new o.List();
          }
          get length() {
            return this._map.size;
          }
          set(e3, t3) {
            if (e3 !== null && !o.supported.has(typeof e3))
              return;
            let r2 = this._map.get(e3);
            if (r2)
              return r2.value = t3, void this._list.first(r2);
            r2 = this._list.unshift({key: e3, value: t3}), this._map.set(e3, r2), this._compact();
          }
          get(e3) {
            const t3 = this._map.get(e3);
            if (t3)
              return this._list.first(t3), n(t3.value);
          }
          _compact() {
            if (this._map.size > this._max) {
              const e3 = this._list.pop();
              this._map.delete(e3.key);
            }
          }
        }, o.List = class {
          constructor() {
            this.tail = null, this.head = null;
          }
          unshift(e3) {
            return e3.next = null, e3.prev = this.head, this.head && (this.head.next = e3), this.head = e3, this.tail || (this.tail = e3), e3;
          }
          first(e3) {
            e3 !== this.head && (this._remove(e3), this.unshift(e3));
          }
          pop() {
            return this._remove(this.tail);
          }
          _remove(e3) {
            const {next: t3, prev: r2} = e3;
            return t3.prev = r2, r2 && (r2.next = t3), e3 === this.tail && (this.tail = t3), e3.prev = null, e3.next = null, e3;
          }
        };
      }, 8160: (e2, t2, r) => {
        const s = r(375), n = r(7916), a = r(1238);
        let o, i;
        const l = {isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};
        t2.version = a.version, t2.defaults = {abortEarly: true, allowUnknown: false, artifacts: false, cache: true, context: null, convert: true, dateFormat: "iso", errors: {escapeHtml: false, label: "path", language: null, render: true, stack: false, wrap: {label: '"', array: "[]"}}, externals: true, messages: {}, nonEnumerables: false, noDefaults: false, presence: "optional", skipFunctions: false, stripUnknown: false, warnings: false}, t2.symbols = {any: Symbol.for("@hapi/joi/schema"), arraySingle: Symbol("arraySingle"), deepDefault: Symbol("deepDefault"), errors: Symbol("errors"), literal: Symbol("literal"), override: Symbol("override"), parent: Symbol("parent"), prefs: Symbol("prefs"), ref: Symbol("ref"), template: Symbol("template"), values: Symbol("values")}, t2.assertOptions = function(e3, t3, r2 = "Options") {
          s(e3 && typeof e3 == "object" && !Array.isArray(e3), "Options must be of type object");
          const n2 = Object.keys(e3).filter((e4) => !t3.includes(e4));
          s(n2.length === 0, "".concat(r2, " contain unknown keys: ").concat(n2));
        }, t2.checkPreferences = function(e3) {
          i = i || r(3378);
          const t3 = i.preferences.validate(e3);
          if (t3.error)
            throw new n([t3.error.details[0].message]);
        }, t2.compare = function(e3, t3, r2) {
          switch (r2) {
            case "=":
              return e3 === t3;
            case ">":
              return e3 > t3;
            case "<":
              return e3 < t3;
            case ">=":
              return e3 >= t3;
            case "<=":
              return e3 <= t3;
          }
        }, t2.default = function(e3, t3) {
          return e3 === void 0 ? t3 : e3;
        }, t2.isIsoDate = function(e3) {
          return l.isoDate.test(e3);
        }, t2.isNumber = function(e3) {
          return typeof e3 == "number" && !isNaN(e3);
        }, t2.isResolvable = function(e3) {
          return !!e3 && (e3[t2.symbols.ref] || e3[t2.symbols.template]);
        }, t2.isSchema = function(e3, r2 = {}) {
          const n2 = e3 && e3[t2.symbols.any];
          return !!n2 && (s(r2.legacy || n2.version === t2.version, "Cannot mix different versions of joi schemas"), true);
        }, t2.isValues = function(e3) {
          return e3[t2.symbols.values];
        }, t2.limit = function(e3) {
          return Number.isSafeInteger(e3) && e3 >= 0;
        }, t2.preferences = function(e3, s2) {
          o = o || r(6914), e3 = e3 || {}, s2 = s2 || {};
          const n2 = Object.assign({}, e3, s2);
          return s2.errors && e3.errors && (n2.errors = Object.assign({}, e3.errors, s2.errors), n2.errors.wrap = Object.assign({}, e3.errors.wrap, s2.errors.wrap)), s2.messages && (n2.messages = o.compile(s2.messages, e3.messages)), delete n2[t2.symbols.prefs], n2;
        }, t2.tryWithPath = function(e3, t3, r2 = {}) {
          try {
            return e3();
          } catch (e4) {
            throw e4.path !== void 0 ? e4.path = t3 + "." + e4.path : e4.path = t3, r2.append && (e4.message = "".concat(e4.message, " (").concat(e4.path, ")")), e4;
          }
        }, t2.validateArg = function(e3, r2, {assert: s2, message: n2}) {
          if (t2.isSchema(s2)) {
            const t3 = s2.validate(e3);
            if (!t3.error)
              return;
            return t3.error.message;
          }
          if (!s2(e3))
            return r2 ? "".concat(r2, " ").concat(n2) : n2;
        }, t2.verifyFlat = function(e3, t3) {
          for (const r2 of e3)
            s(!Array.isArray(r2), "Method no longer accepts array arguments:", t3);
        };
      }, 3292: (e2, t2, r) => {
        const s = r(375), n = r(8160), a = r(6133), o = {};
        t2.schema = function(e3, t3, r2 = {}) {
          n.assertOptions(r2, ["appendPath", "override"]);
          try {
            return o.schema(e3, t3, r2);
          } catch (e4) {
            throw r2.appendPath && e4.path !== void 0 && (e4.message = "".concat(e4.message, " (").concat(e4.path, ")")), e4;
          }
        }, o.schema = function(e3, t3, r2) {
          s(t3 !== void 0, "Invalid undefined schema"), Array.isArray(t3) && (s(t3.length, "Invalid empty array schema"), t3.length === 1 && (t3 = t3[0]));
          const a2 = (t4, ...s2) => r2.override !== false ? t4.valid(e3.override, ...s2) : t4.valid(...s2);
          if (o.simple(t3))
            return a2(e3, t3);
          if (typeof t3 == "function")
            return e3.custom(t3);
          if (s(typeof t3 == "object", "Invalid schema content:", typeof t3), n.isResolvable(t3))
            return a2(e3, t3);
          if (n.isSchema(t3))
            return t3;
          if (Array.isArray(t3)) {
            for (const r3 of t3)
              if (!o.simple(r3))
                return e3.alternatives().try(...t3);
            return a2(e3, ...t3);
          }
          return t3 instanceof RegExp ? e3.string().regex(t3) : t3 instanceof Date ? a2(e3.date(), t3) : (s(Object.getPrototypeOf(t3) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), e3.object().keys(t3));
        }, t2.ref = function(e3, t3) {
          return a.isRef(e3) ? e3 : a.create(e3, t3);
        }, t2.compile = function(e3, r2, a2 = {}) {
          n.assertOptions(a2, ["legacy"]);
          const i = r2 && r2[n.symbols.any];
          if (i)
            return s(a2.legacy || i.version === n.version, "Cannot mix different versions of joi schemas:", i.version, n.version), r2;
          if (typeof r2 != "object" || !a2.legacy)
            return t2.schema(e3, r2, {appendPath: true});
          const l = o.walk(r2);
          return l ? l.compile(l.root, r2) : t2.schema(e3, r2, {appendPath: true});
        }, o.walk = function(e3) {
          if (typeof e3 != "object")
            return null;
          if (Array.isArray(e3)) {
            for (const t4 of e3) {
              const e4 = o.walk(t4);
              if (e4)
                return e4;
            }
            return null;
          }
          const t3 = e3[n.symbols.any];
          if (t3)
            return {root: e3[t3.root], compile: t3.compile};
          s(Object.getPrototypeOf(e3) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
          for (const t4 in e3) {
            const r2 = o.walk(e3[t4]);
            if (r2)
              return r2;
          }
          return null;
        }, o.simple = function(e3) {
          return e3 === null || ["boolean", "string", "number"].includes(typeof e3);
        }, t2.when = function(e3, r2, i) {
          if (i === void 0 && (s(r2 && typeof r2 == "object", "Missing options"), i = r2, r2 = a.create(".")), Array.isArray(i) && (i = {switch: i}), n.assertOptions(i, ["is", "not", "then", "otherwise", "switch", "break"]), n.isSchema(r2))
            return s(i.is === void 0, '"is" can not be used with a schema condition'), s(i.not === void 0, '"not" can not be used with a schema condition'), s(i.switch === void 0, '"switch" can not be used with a schema condition'), o.condition(e3, {is: r2, then: i.then, otherwise: i.otherwise, break: i.break});
          if (s(a.isRef(r2) || typeof r2 == "string", "Invalid condition:", r2), s(i.not === void 0 || i.is === void 0, 'Cannot combine "is" with "not"'), i.switch === void 0) {
            let l2 = i;
            i.not !== void 0 && (l2 = {is: i.not, then: i.otherwise, otherwise: i.then, break: i.break});
            let c = l2.is !== void 0 ? e3.$_compile(l2.is) : e3.$_root.invalid(null, false, 0, "").required();
            return s(l2.then !== void 0 || l2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"'), s(l2.break === void 0 || l2.then === void 0 || l2.otherwise === void 0, "Cannot specify then, otherwise, and break all together"), i.is === void 0 || a.isRef(i.is) || n.isSchema(i.is) || (c = c.required()), o.condition(e3, {ref: t2.ref(r2), is: c, then: l2.then, otherwise: l2.otherwise, break: l2.break});
          }
          s(Array.isArray(i.switch), '"switch" must be an array'), s(i.is === void 0, 'Cannot combine "switch" with "is"'), s(i.not === void 0, 'Cannot combine "switch" with "not"'), s(i.then === void 0, 'Cannot combine "switch" with "then"');
          const l = {ref: t2.ref(r2), switch: [], break: i.break};
          for (let t3 = 0; t3 < i.switch.length; ++t3) {
            const r3 = i.switch[t3], o2 = t3 === i.switch.length - 1;
            n.assertOptions(r3, o2 ? ["is", "then", "otherwise"] : ["is", "then"]), s(r3.is !== void 0, 'Switch statement missing "is"'), s(r3.then !== void 0, 'Switch statement missing "then"');
            const c = {is: e3.$_compile(r3.is), then: e3.$_compile(r3.then)};
            if (a.isRef(r3.is) || n.isSchema(r3.is) || (c.is = c.is.required()), o2) {
              s(i.otherwise === void 0 || r3.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
              const t4 = i.otherwise !== void 0 ? i.otherwise : r3.otherwise;
              t4 !== void 0 && (s(l.break === void 0, "Cannot specify both otherwise and break"), c.otherwise = e3.$_compile(t4));
            }
            l.switch.push(c);
          }
          return l;
        }, o.condition = function(e3, t3) {
          for (const r2 of ["then", "otherwise"])
            t3[r2] === void 0 ? delete t3[r2] : t3[r2] = e3.$_compile(t3[r2]);
          return t3;
        };
      }, 6354: (e2, t2, r) => {
        const s = r(5688), n = r(8160), a = r(3328);
        t2.Report = class {
          constructor(e3, r2, s2, n2, a2, o, i) {
            if (this.code = e3, this.flags = n2, this.messages = a2, this.path = o.path, this.prefs = i, this.state = o, this.value = r2, this.message = null, this.template = null, this.local = s2 || {}, this.local.label = t2.label(this.flags, this.state, this.prefs, this.messages), this.value === void 0 || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
              const e4 = this.path[this.path.length - 1];
              typeof e4 != "object" && (this.local.key = e4);
            }
          }
          _setTemplate(e3) {
            if (this.template = e3, !this.flags.label && this.path.length === 0) {
              const e4 = this._template(this.template, "root");
              e4 && (this.local.label = e4);
            }
          }
          toString() {
            if (this.message)
              return this.message;
            const e3 = this.code;
            if (!this.prefs.errors.render)
              return this.code;
            const t3 = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
            return t3 === void 0 ? 'Error code "'.concat(e3, '" is not defined, your custom type is missing the correct messages definition') : (this.message = t3.render(this.value, this.state, this.prefs, this.local, {errors: this.prefs.errors, messages: [this.prefs.messages, this.messages]}), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message);
          }
          _template(e3, r2) {
            return t2.template(this.value, e3, r2 || this.code, this.state, this.prefs);
          }
        }, t2.path = function(e3) {
          let t3 = "";
          for (const r2 of e3)
            typeof r2 != "object" && (typeof r2 == "string" ? (t3 && (t3 += "."), t3 += r2) : t3 += "[".concat(r2, "]"));
          return t3;
        }, t2.template = function(e3, t3, r2, s2, o) {
          if (!t3)
            return;
          if (a.isTemplate(t3))
            return r2 !== "root" ? t3 : null;
          let i = o.errors.language;
          return n.isResolvable(i) && (i = i.resolve(e3, s2, o)), i && t3[i] && t3[i][r2] !== void 0 ? t3[i][r2] : t3[r2];
        }, t2.label = function(e3, r2, s2, n2) {
          if (e3.label)
            return e3.label;
          if (!s2.errors.label)
            return "";
          let a2 = r2.path;
          s2.errors.label === "key" && r2.path.length > 1 && (a2 = r2.path.slice(-1));
          return t2.path(a2) || t2.template(null, s2.messages, "root", r2, s2) || n2 && t2.template(null, n2, "root", r2, s2) || "value";
        }, t2.process = function(e3, r2, s2) {
          if (!e3)
            return null;
          const {override: n2, message: a2, details: o} = t2.details(e3);
          if (n2)
            return n2;
          if (s2.errors.stack)
            return new t2.ValidationError(a2, o, r2);
          const i = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          const l = new t2.ValidationError(a2, o, r2);
          return Error.stackTraceLimit = i, l;
        }, t2.details = function(e3, t3 = {}) {
          let r2 = [];
          const s2 = [];
          for (const n2 of e3) {
            if (n2 instanceof Error) {
              if (t3.override !== false)
                return {override: n2};
              const e5 = n2.toString();
              r2.push(e5), s2.push({message: e5, type: "override", context: {error: n2}});
              continue;
            }
            const e4 = n2.toString();
            r2.push(e4), s2.push({message: e4, path: n2.path.filter((e5) => typeof e5 != "object"), type: n2.code, context: n2.local});
          }
          return r2.length > 1 && (r2 = [...new Set(r2)]), {message: r2.join(". "), details: s2};
        }, t2.ValidationError = class extends Error {
          constructor(e3, t3, r2) {
            super(e3), this._original = r2, this.details = t3;
          }
          static isError(e3) {
            return e3 instanceof t2.ValidationError;
          }
        }, t2.ValidationError.prototype.isJoi = true, t2.ValidationError.prototype.name = "ValidationError", t2.ValidationError.prototype.annotate = s.error;
      }, 8901: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(8160), o = r(6914), i = {};
        t2.type = function(e3, t3) {
          const r2 = Object.getPrototypeOf(e3), l = n(r2), c = e3._assign(Object.create(l)), u = Object.assign({}, t3);
          delete u.base, l._definition = u;
          const f = r2._definition || {};
          u.messages = o.merge(f.messages, u.messages), u.properties = Object.assign({}, f.properties, u.properties), c.type = u.type, u.flags = Object.assign({}, f.flags, u.flags);
          const m = Object.assign({}, f.terms);
          if (u.terms)
            for (const e4 in u.terms) {
              const t4 = u.terms[e4];
              s(c.$_terms[e4] === void 0, "Invalid term override for", u.type, e4), c.$_terms[e4] = t4.init, m[e4] = t4;
            }
          u.terms = m, u.args || (u.args = f.args), u.prepare = i.prepare(u.prepare, f.prepare), u.coerce && (typeof u.coerce == "function" && (u.coerce = {method: u.coerce}), u.coerce.from && !Array.isArray(u.coerce.from) && (u.coerce = {method: u.coerce.method, from: [].concat(u.coerce.from)})), u.coerce = i.coerce(u.coerce, f.coerce), u.validate = i.validate(u.validate, f.validate);
          const h = Object.assign({}, f.rules);
          if (u.rules)
            for (const e4 in u.rules) {
              const t4 = u.rules[e4];
              s(typeof t4 == "object", "Invalid rule definition for", u.type, e4);
              let r3 = t4.method;
              if (r3 === void 0 && (r3 = function() {
                return this.$_addRule(e4);
              }), r3 && (s(!l[e4], "Rule conflict in", u.type, e4), l[e4] = r3), s(!h[e4], "Rule conflict in", u.type, e4), h[e4] = t4, t4.alias) {
                const e5 = [].concat(t4.alias);
                for (const r4 of e5)
                  l[r4] = t4.method;
              }
              t4.args && (t4.argsByName = new Map(), t4.args = t4.args.map((e5) => (typeof e5 == "string" && (e5 = {name: e5}), s(!t4.argsByName.has(e5.name), "Duplicated argument name", e5.name), a.isSchema(e5.assert) && (e5.assert = e5.assert.strict().label(e5.name)), t4.argsByName.set(e5.name, e5), e5)));
            }
          u.rules = h;
          const d = Object.assign({}, f.modifiers);
          if (u.modifiers)
            for (const e4 in u.modifiers) {
              s(!l[e4], "Rule conflict in", u.type, e4);
              const t4 = u.modifiers[e4];
              s(typeof t4 == "function", "Invalid modifier definition for", u.type, e4);
              const r3 = function(t5) {
                return this.rule({[e4]: t5});
              };
              l[e4] = r3, d[e4] = t4;
            }
          if (u.modifiers = d, u.overrides) {
            l._super = r2, c.$_super = {};
            for (const e4 in u.overrides)
              s(r2[e4], "Cannot override missing", e4), u.overrides[e4][a.symbols.parent] = r2[e4], c.$_super[e4] = r2[e4].bind(c);
            Object.assign(l, u.overrides);
          }
          u.cast = Object.assign({}, f.cast, u.cast);
          const p = Object.assign({}, f.manifest, u.manifest);
          return p.build = i.build(u.manifest && u.manifest.build, f.manifest && f.manifest.build), u.manifest = p, u.rebuild = i.rebuild(u.rebuild, f.rebuild), c;
        }, i.build = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            return t3(e3(r2, s2), s2);
          } : e3 || t3;
        }, i.coerce = function(e3, t3) {
          return e3 && t3 ? {from: e3.from && t3.from ? [...new Set([...e3.from, ...t3.from])] : null, method(r2, s2) {
            let n2;
            if ((!t3.from || t3.from.includes(typeof r2)) && (n2 = t3.method(r2, s2), n2)) {
              if (n2.errors || n2.value === void 0)
                return n2;
              r2 = n2.value;
            }
            if (!e3.from || e3.from.includes(typeof r2)) {
              const t4 = e3.method(r2, s2);
              if (t4)
                return t4;
            }
            return n2;
          }} : e3 || t3;
        }, i.prepare = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            const n2 = e3(r2, s2);
            if (n2) {
              if (n2.errors || n2.value === void 0)
                return n2;
              r2 = n2.value;
            }
            return t3(r2, s2) || n2;
          } : e3 || t3;
        }, i.rebuild = function(e3, t3) {
          return e3 && t3 ? function(r2) {
            t3(r2), e3(r2);
          } : e3 || t3;
        }, i.validate = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            const n2 = t3(r2, s2);
            if (n2) {
              if (n2.errors && (!Array.isArray(n2.errors) || n2.errors.length))
                return n2;
              r2 = n2.value;
            }
            return e3(r2, s2) || n2;
          } : e3 || t3;
        };
      }, 5107: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(8652), o = r(8160), i = r(3292), l = r(6354), c = r(8901), u = r(9708), f = r(6133), m = r(3328), h = r(1152);
        let d;
        const p = {types: {alternatives: r(4946), any: r(8068), array: r(546), boolean: r(4937), date: r(7500), function: r(390), link: r(8785), number: r(3832), object: r(8966), string: r(7417), symbol: r(8826)}, aliases: {alt: "alternatives", bool: "boolean", func: "function"}, root: function() {
          const e3 = {_types: new Set(Object.keys(p.types))};
          for (const t3 of e3._types)
            e3[t3] = function(...e4) {
              return s(!e4.length || ["alternatives", "link", "object"].includes(t3), "The", t3, "type does not allow arguments"), p.generate(this, p.types[t3], e4);
            };
          for (const t3 of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"])
            e3[t3] = function(...e4) {
              return this.any()[t3](...e4);
            };
          Object.assign(e3, p.methods);
          for (const t3 in p.aliases) {
            const r2 = p.aliases[t3];
            e3[t3] = e3[r2];
          }
          return e3.x = e3.expression, h.setup && h.setup(e3), e3;
        }};
        p.methods = {ValidationError: l.ValidationError, version: o.version, cache: a.provider, assert(e3, t3, ...r2) {
          p.assert(e3, t3, true, r2);
        }, attempt: (e3, t3, ...r2) => p.assert(e3, t3, false, r2), build(e3) {
          return s(typeof u.build == "function", "Manifest functionality disabled"), u.build(this, e3);
        }, checkPreferences(e3) {
          o.checkPreferences(e3);
        }, compile(e3, t3) {
          return i.compile(this, e3, t3);
        }, defaults(e3) {
          s(typeof e3 == "function", "modifier must be a function");
          const t3 = Object.assign({}, this);
          for (const r2 of t3._types) {
            const n2 = e3(t3[r2]());
            s(o.isSchema(n2), "modifier must return a valid schema object"), t3[r2] = function(...e4) {
              return p.generate(this, n2, e4);
            };
          }
          return t3;
        }, expression: (...e3) => new m(...e3), extend(...e3) {
          o.verifyFlat(e3, "extend"), d = d || r(3378), s(e3.length, "You need to provide at least one extension"), this.assert(e3, d.extensions);
          const t3 = Object.assign({}, this);
          t3._types = new Set(t3._types);
          for (let r2 of e3) {
            typeof r2 == "function" && (r2 = r2(t3)), this.assert(r2, d.extension);
            const e4 = p.expandExtension(r2, t3);
            for (const r3 of e4) {
              s(t3[r3.type] === void 0 || t3._types.has(r3.type), "Cannot override name", r3.type);
              const e5 = r3.base || this.any(), n2 = c.type(e5, r3);
              t3._types.add(r3.type), t3[r3.type] = function(...e6) {
                return p.generate(this, n2, e6);
              };
            }
          }
          return t3;
        }, isError: l.ValidationError.isError, isExpression: m.isTemplate, isRef: f.isRef, isSchema: o.isSchema, in: (...e3) => f.in(...e3), override: o.symbols.override, ref: (...e3) => f.create(...e3), types() {
          const e3 = {};
          for (const t3 of this._types)
            e3[t3] = this[t3]();
          for (const t3 in p.aliases)
            e3[t3] = this[t3]();
          return e3;
        }}, p.assert = function(e3, t3, r2, s2) {
          const a2 = s2[0] instanceof Error || typeof s2[0] == "string" ? s2[0] : null, i2 = a2 ? s2[1] : s2[0], c2 = t3.validate(e3, o.preferences({errors: {stack: true}}, i2 || {}));
          let u2 = c2.error;
          if (!u2)
            return c2.value;
          if (a2 instanceof Error)
            throw a2;
          const f2 = r2 && typeof u2.annotate == "function" ? u2.annotate() : u2.message;
          throw u2 instanceof l.ValidationError == 0 && (u2 = n(u2)), u2.message = a2 ? "".concat(a2, " ").concat(f2) : f2, u2;
        }, p.generate = function(e3, t3, r2) {
          return s(e3, "Must be invoked on a Joi instance."), t3.$_root = e3, t3._definition.args && r2.length ? t3._definition.args(t3, ...r2) : t3;
        }, p.expandExtension = function(e3, t3) {
          if (typeof e3.type == "string")
            return [e3];
          const r2 = [];
          for (const s2 of t3._types)
            if (e3.type.test(s2)) {
              const n2 = Object.assign({}, e3);
              n2.type = s2, n2.base = t3[s2](), r2.push(n2);
            }
          return r2;
        }, e2.exports = p.root();
      }, 6914: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(3328);
        t2.compile = function(e3, t3) {
          if (typeof e3 == "string")
            return s(!t3, "Cannot set single message string"), new a(e3);
          if (a.isTemplate(e3))
            return s(!t3, "Cannot set single message template"), e3;
          s(typeof e3 == "object" && !Array.isArray(e3), "Invalid message options"), t3 = t3 ? n(t3) : {};
          for (let r2 in e3) {
            const n2 = e3[r2];
            if (r2 === "root" || a.isTemplate(n2)) {
              t3[r2] = n2;
              continue;
            }
            if (typeof n2 == "string") {
              t3[r2] = new a(n2);
              continue;
            }
            s(typeof n2 == "object" && !Array.isArray(n2), "Invalid message for", r2);
            const o = r2;
            for (r2 in t3[o] = t3[o] || {}, n2) {
              const e4 = n2[r2];
              r2 === "root" || a.isTemplate(e4) ? t3[o][r2] = e4 : (s(typeof e4 == "string", "Invalid message for", r2, "in", o), t3[o][r2] = new a(e4));
            }
          }
          return t3;
        }, t2.decompile = function(e3) {
          const t3 = {};
          for (let r2 in e3) {
            const s2 = e3[r2];
            if (r2 === "root") {
              t3[r2] = s2;
              continue;
            }
            if (a.isTemplate(s2)) {
              t3[r2] = s2.describe({compact: true});
              continue;
            }
            const n2 = r2;
            for (r2 in t3[n2] = {}, s2) {
              const e4 = s2[r2];
              t3[n2][r2] = r2 !== "root" ? e4.describe({compact: true}) : e4;
            }
          }
          return t3;
        }, t2.merge = function(e3, r2) {
          if (!e3)
            return t2.compile(r2);
          if (!r2)
            return e3;
          if (typeof r2 == "string")
            return new a(r2);
          if (a.isTemplate(r2))
            return r2;
          const o = n(e3);
          for (let e4 in r2) {
            const t3 = r2[e4];
            if (e4 === "root" || a.isTemplate(t3)) {
              o[e4] = t3;
              continue;
            }
            if (typeof t3 == "string") {
              o[e4] = new a(t3);
              continue;
            }
            s(typeof t3 == "object" && !Array.isArray(t3), "Invalid message for", e4);
            const n2 = e4;
            for (e4 in o[n2] = o[n2] || {}, t3) {
              const r3 = t3[e4];
              e4 === "root" || a.isTemplate(r3) ? o[n2][e4] = r3 : (s(typeof r3 == "string", "Invalid message for", e4, "in", n2), o[n2][e4] = new a(r3));
            }
          }
          return o;
        };
      }, 2294: (e2, t2, r) => {
        function s(e3, t3) {
          var r2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var s2 = Object.getOwnPropertySymbols(e3);
            t3 && (s2 = s2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r2.push.apply(r2, s2);
          }
          return r2;
        }
        function n(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3] != null ? arguments[t3] : {};
            t3 % 2 ? s(Object(r2), true).forEach(function(t4) {
              a(e3, t4, r2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : s(Object(r2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
            });
          }
          return e3;
        }
        function a(e3, t3, r2) {
          return t3 in e3 ? Object.defineProperty(e3, t3, {value: r2, enumerable: true, configurable: true, writable: true}) : e3[t3] = r2, e3;
        }
        const o = r(375), i = r(8160), l = r(6133), c = {};
        t2.Ids = c.Ids = class {
          constructor() {
            this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
          }
          clone() {
            const e3 = new c.Ids();
            return e3._byId = new Map(this._byId), e3._byKey = new Map(this._byKey), e3._schemaChain = this._schemaChain, e3;
          }
          concat(e3) {
            e3._schemaChain && (this._schemaChain = true);
            for (const [t3, r2] of e3._byId.entries())
              o(!this._byKey.has(t3), "Schema id conflicts with existing key:", t3), this._byId.set(t3, r2);
            for (const [t3, r2] of e3._byKey.entries())
              o(!this._byId.has(t3), "Schema key conflicts with existing id:", t3), this._byKey.set(t3, r2);
          }
          fork(e3, t3, r2) {
            const s2 = this._collect(e3);
            s2.push({schema: r2});
            const n2 = s2.shift();
            let a2 = {id: n2.id, schema: t3(n2.schema)};
            o(i.isSchema(a2.schema), "adjuster function failed to return a joi schema type");
            for (const e4 of s2)
              a2 = {id: e4.id, schema: c.fork(e4.schema, a2.id, a2.schema)};
            return a2.schema;
          }
          labels(e3, t3 = []) {
            const r2 = e3[0], s2 = this._get(r2);
            if (!s2)
              return [...t3, ...e3].join(".");
            const n2 = e3.slice(1);
            return t3 = [...t3, s2.schema._flags.label || r2], n2.length ? s2.schema._ids.labels(n2, t3) : t3.join(".");
          }
          reach(e3, t3 = []) {
            const r2 = e3[0], s2 = this._get(r2);
            o(s2, "Schema does not contain path", [...t3, ...e3].join("."));
            const n2 = e3.slice(1);
            return n2.length ? s2.schema._ids.reach(n2, [...t3, r2]) : s2.schema;
          }
          register(e3, {key: t3} = {}) {
            if (!e3 || !i.isSchema(e3))
              return;
            (e3.$_property("schemaChain") || e3._ids._schemaChain) && (this._schemaChain = true);
            const r2 = e3._flags.id;
            if (r2) {
              const t4 = this._byId.get(r2);
              o(!t4 || t4.schema === e3, "Cannot add different schemas with the same id:", r2), o(!this._byKey.has(r2), "Schema id conflicts with existing key:", r2), this._byId.set(r2, {schema: e3, id: r2});
            }
            t3 && (o(!this._byKey.has(t3), "Schema already contains key:", t3), o(!this._byId.has(t3), "Schema key conflicts with existing id:", t3), this._byKey.set(t3, {schema: e3, id: t3}));
          }
          reset() {
            this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
          }
          _collect(e3, t3 = [], r2 = []) {
            const s2 = e3[0], n2 = this._get(s2);
            o(n2, "Schema does not contain path", [...t3, ...e3].join(".")), r2 = [n2, ...r2];
            const a2 = e3.slice(1);
            return a2.length ? n2.schema._ids._collect(a2, [...t3, s2], r2) : r2;
          }
          _get(e3) {
            return this._byId.get(e3) || this._byKey.get(e3);
          }
        }, c.fork = function(e3, r2, s2) {
          const n2 = t2.schema(e3, {each: (e4, {key: t3}) => {
            if (r2 === (e4._flags.id || t3))
              return s2;
          }, ref: false});
          return n2 ? n2.$_mutateRebuild() : e3;
        }, t2.schema = function(e3, t3) {
          let r2;
          for (const s2 in e3._flags) {
            if (s2[0] === "_")
              continue;
            const n2 = c.scan(e3._flags[s2], {source: "flags", name: s2}, t3);
            n2 !== void 0 && (r2 = r2 || e3.clone(), r2._flags[s2] = n2);
          }
          for (let s2 = 0; s2 < e3._rules.length; ++s2) {
            const n2 = e3._rules[s2], a2 = c.scan(n2.args, {source: "rules", name: n2.name}, t3);
            if (a2 !== void 0) {
              r2 = r2 || e3.clone();
              const t4 = Object.assign({}, n2);
              t4.args = a2, r2._rules[s2] = t4, r2._singleRules.get(n2.name) === n2 && r2._singleRules.set(n2.name, t4);
            }
          }
          for (const s2 in e3.$_terms) {
            if (s2[0] === "_")
              continue;
            const n2 = c.scan(e3.$_terms[s2], {source: "terms", name: s2}, t3);
            n2 !== void 0 && (r2 = r2 || e3.clone(), r2.$_terms[s2] = n2);
          }
          return r2;
        }, c.scan = function(e3, t3, r2, s2, a2) {
          const o2 = s2 || [];
          if (e3 === null || typeof e3 != "object")
            return;
          let u;
          if (Array.isArray(e3)) {
            for (let s3 = 0; s3 < e3.length; ++s3) {
              const n2 = t3.source === "terms" && t3.name === "keys" && e3[s3].key, a3 = c.scan(e3[s3], t3, r2, [s3, ...o2], n2);
              a3 !== void 0 && (u = u || e3.slice(), u[s3] = a3);
            }
            return u;
          }
          if (r2.schema !== false && i.isSchema(e3) || r2.ref !== false && l.isRef(e3)) {
            const s3 = r2.each(e3, n(n({}, t3), {}, {path: o2, key: a2}));
            if (s3 === e3)
              return;
            return s3;
          }
          for (const s3 in e3) {
            if (s3[0] === "_")
              continue;
            const n2 = c.scan(e3[s3], t3, r2, [s3, ...o2], a2);
            n2 !== void 0 && (u = u || Object.assign({}, e3), u[s3] = n2);
          }
          return u;
        };
      }, 6133: (e2, t2, r) => {
        function s(e3, t3) {
          var r2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var s2 = Object.getOwnPropertySymbols(e3);
            t3 && (s2 = s2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r2.push.apply(r2, s2);
          }
          return r2;
        }
        function n(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3] != null ? arguments[t3] : {};
            t3 % 2 ? s(Object(r2), true).forEach(function(t4) {
              a(e3, t4, r2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : s(Object(r2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
            });
          }
          return e3;
        }
        function a(e3, t3, r2) {
          return t3 in e3 ? Object.defineProperty(e3, t3, {value: r2, enumerable: true, configurable: true, writable: true}) : e3[t3] = r2, e3;
        }
        const o = r(375), i = r(8571), l = r(9621), c = r(8160);
        let u;
        const f = {symbol: Symbol("ref"), defaults: {adjust: null, in: false, iterables: null, map: null, separator: ".", type: "value"}};
        t2.create = function(e3, t3 = {}) {
          o(typeof e3 == "string", "Invalid reference key:", e3), c.assertOptions(t3, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), o(!t3.prefix || typeof t3.prefix == "object", "options.prefix must be of type object");
          const r2 = Object.assign({}, f.defaults, t3);
          delete r2.prefix;
          const s2 = r2.separator, n2 = f.context(e3, s2, t3.prefix);
          if (r2.type = n2.type, e3 = n2.key, r2.type === "value")
            if (n2.root && (o(!s2 || e3[0] !== s2, "Cannot specify relative path with root prefix"), r2.ancestor = "root", e3 || (e3 = null)), s2 && s2 === e3)
              e3 = null, r2.ancestor = 0;
            else if (r2.ancestor !== void 0)
              o(!s2 || !e3 || e3[0] !== s2, "Cannot combine prefix with ancestor option");
            else {
              const [t4, n3] = f.ancestor(e3, s2);
              n3 && (e3 = e3.slice(n3)) === "" && (e3 = null), r2.ancestor = t4;
            }
          return r2.path = s2 ? e3 === null ? [] : e3.split(s2) : [e3], new f.Ref(r2);
        }, t2.in = function(e3, r2 = {}) {
          return t2.create(e3, n(n({}, r2), {}, {in: true}));
        }, t2.isRef = function(e3) {
          return !!e3 && !!e3[c.symbols.ref];
        }, f.Ref = class {
          constructor(e3) {
            o(typeof e3 == "object", "Invalid reference construction"), c.assertOptions(e3, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), o([false, void 0].includes(e3.separator) || typeof e3.separator == "string" && e3.separator.length === 1, "Invalid separator"), o(!e3.adjust || typeof e3.adjust == "function", "options.adjust must be a function"), o(!e3.map || Array.isArray(e3.map), "options.map must be an array"), o(!e3.map || !e3.adjust, "Cannot set both map and adjust options"), Object.assign(this, f.defaults, e3), o(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay();
          }
          resolve(e3, t3, r2, s2, n2 = {}) {
            return o(!this.in || n2.in, "Invalid in() reference usage"), this.type === "global" ? this._resolve(r2.context, t3, n2) : this.type === "local" ? this._resolve(s2, t3, n2) : this.ancestor ? this.ancestor === "root" ? this._resolve(t3.ancestors[t3.ancestors.length - 1], t3, n2) : (o(this.ancestor <= t3.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(t3.ancestors[this.ancestor - 1], t3, n2)) : this._resolve(e3, t3, n2);
          }
          _resolve(e3, t3, r2) {
            let s2;
            if (this.type === "value" && t3.mainstay.shadow && r2.shadow !== false && (s2 = t3.mainstay.shadow.get(this.absolute(t3))), s2 === void 0 && (s2 = l(e3, this.path, {iterables: this.iterables, functions: true})), this.adjust && (s2 = this.adjust(s2)), this.map) {
              const e4 = this.map.get(s2);
              e4 !== void 0 && (s2 = e4);
            }
            return t3.mainstay && t3.mainstay.tracer.resolve(t3, this, s2), s2;
          }
          toString() {
            return this.display;
          }
          absolute(e3) {
            return [...e3.path.slice(0, -this.ancestor), ...this.path];
          }
          clone() {
            return new f.Ref(this);
          }
          describe() {
            const e3 = {path: this.path};
            this.type !== "value" && (e3.type = this.type), this.separator !== "." && (e3.separator = this.separator), this.type === "value" && this.ancestor !== 1 && (e3.ancestor = this.ancestor), this.map && (e3.map = [...this.map]);
            for (const t3 of ["adjust", "iterables", "render"])
              this[t3] !== null && this[t3] !== void 0 && (e3[t3] = this[t3]);
            return this.in !== false && (e3.in = true), {ref: e3};
          }
          updateDisplay() {
            const e3 = this.key !== null ? this.key : "";
            if (this.type !== "value")
              return void (this.display = "ref:".concat(this.type, ":").concat(e3));
            if (!this.separator)
              return void (this.display = "ref:".concat(e3));
            if (!this.ancestor)
              return void (this.display = "ref:".concat(this.separator).concat(e3));
            if (this.ancestor === "root")
              return void (this.display = "ref:root:".concat(e3));
            if (this.ancestor === 1)
              return void (this.display = "ref:".concat(e3 || ".."));
            const t3 = new Array(this.ancestor + 1).fill(this.separator).join("");
            this.display = "ref:".concat(t3).concat(e3 || "");
          }
        }, f.Ref.prototype[c.symbols.ref] = true, t2.build = function(e3) {
          return (e3 = Object.assign({}, f.defaults, e3)).type === "value" && e3.ancestor === void 0 && (e3.ancestor = 1), new f.Ref(e3);
        }, f.context = function(e3, t3, r2 = {}) {
          if (e3 = e3.trim(), r2) {
            const s2 = r2.global === void 0 ? "$" : r2.global;
            if (s2 !== t3 && e3.startsWith(s2))
              return {key: e3.slice(s2.length), type: "global"};
            const n2 = r2.local === void 0 ? "#" : r2.local;
            if (n2 !== t3 && e3.startsWith(n2))
              return {key: e3.slice(n2.length), type: "local"};
            const a2 = r2.root === void 0 ? "/" : r2.root;
            if (a2 !== t3 && e3.startsWith(a2))
              return {key: e3.slice(a2.length), type: "value", root: true};
          }
          return {key: e3, type: "value"};
        }, f.ancestor = function(e3, t3) {
          if (!t3)
            return [1, 0];
          if (e3[0] !== t3)
            return [1, 0];
          if (e3[1] !== t3)
            return [0, 1];
          let r2 = 2;
          for (; e3[r2] === t3; )
            ++r2;
          return [r2 - 1, r2];
        }, t2.toSibling = 0, t2.toParent = 1, t2.Manager = class {
          constructor() {
            this.refs = [];
          }
          register(e3, s2) {
            if (e3)
              if (s2 = s2 === void 0 ? t2.toParent : s2, Array.isArray(e3))
                for (const t3 of e3)
                  this.register(t3, s2);
              else if (c.isSchema(e3))
                for (const t3 of e3._refs.refs)
                  t3.ancestor - s2 >= 0 && this.refs.push({ancestor: t3.ancestor - s2, root: t3.root});
              else
                t2.isRef(e3) && e3.type === "value" && e3.ancestor - s2 >= 0 && this.refs.push({ancestor: e3.ancestor - s2, root: e3.root}), u = u || r(3328), u.isTemplate(e3) && this.register(e3.refs(), s2);
          }
          get length() {
            return this.refs.length;
          }
          clone() {
            const e3 = new t2.Manager();
            return e3.refs = i(this.refs), e3;
          }
          reset() {
            this.refs = [];
          }
          roots() {
            return this.refs.filter((e3) => !e3.ancestor).map((e3) => e3.root);
          }
        };
      }, 3378: (e2, t2, r) => {
        const s = r(5107), n = {};
        n.wrap = s.string().min(1).max(2).allow(false), t2.preferences = s.object({allowUnknown: s.boolean(), abortEarly: s.boolean(), artifacts: s.boolean(), cache: s.boolean(), context: s.object(), convert: s.boolean(), dateFormat: s.valid("date", "iso", "string", "time", "utc"), debug: s.boolean(), errors: {escapeHtml: s.boolean(), label: s.valid("path", "key", false), language: [s.string(), s.object().ref()], render: s.boolean(), stack: s.boolean(), wrap: {label: n.wrap, array: n.wrap}}, externals: s.boolean(), messages: s.object(), noDefaults: s.boolean(), nonEnumerables: s.boolean(), presence: s.valid("required", "optional", "forbidden"), skipFunctions: s.boolean(), stripUnknown: s.object({arrays: s.boolean(), objects: s.boolean()}).or("arrays", "objects").allow(true, false), warnings: s.boolean()}).strict(), n.nameRx = /^[a-zA-Z0-9]\w*$/, n.rule = s.object({alias: s.array().items(s.string().pattern(n.nameRx)).single(), args: s.array().items(s.string(), s.object({name: s.string().pattern(n.nameRx).required(), ref: s.boolean(), assert: s.alternatives([s.function(), s.object().schema()]).conditional("ref", {is: true, then: s.required()}), normalize: s.function(), message: s.string().when("assert", {is: s.function(), then: s.required()})})), convert: s.boolean(), manifest: s.boolean(), method: s.function().allow(false), multi: s.boolean(), validate: s.function()}), t2.extension = s.object({type: s.alternatives([s.string(), s.object().regex()]).required(), args: s.function(), cast: s.object().pattern(n.nameRx, s.object({from: s.function().maxArity(1).required(), to: s.function().minArity(1).maxArity(2).required()})), base: s.object().schema().when("type", {is: s.object().regex(), then: s.forbidden()}), coerce: [s.function().maxArity(3), s.object({method: s.function().maxArity(3).required(), from: s.array().items(s.string()).single()})], flags: s.object().pattern(n.nameRx, s.object({setter: s.string(), default: s.any()})), manifest: {build: s.function().arity(2)}, messages: [s.object(), s.string()], modifiers: s.object().pattern(n.nameRx, s.function().minArity(1).maxArity(2)), overrides: s.object().pattern(n.nameRx, s.function()), prepare: s.function().maxArity(3), rebuild: s.function().arity(1), rules: s.object().pattern(n.nameRx, n.rule), terms: s.object().pattern(n.nameRx, s.object({init: s.array().allow(null).required(), manifest: s.object().pattern(/.+/, [s.valid("schema", "single"), s.object({mapped: s.object({from: s.string().required(), to: s.string().required()}).required()})])})), validate: s.function().maxArity(3)}).strict(), t2.extensions = s.array().items(s.object(), s.function().arity(1)).strict(), n.desc = {buffer: s.object({buffer: s.string()}), func: s.object({function: s.function().required(), options: {literal: true}}), override: s.object({override: true}), ref: s.object({ref: s.object({type: s.valid("value", "global", "local"), path: s.array().required(), separator: s.string().length(1).allow(false), ancestor: s.number().min(0).integer().allow("root"), map: s.array().items(s.array().length(2)).min(1), adjust: s.function(), iterables: s.boolean(), in: s.boolean(), render: s.boolean()}).required()}), regex: s.object({regex: s.string().min(3)}), special: s.object({special: s.valid("deep").required()}), template: s.object({template: s.string().required(), options: s.object()}), value: s.object({value: s.alternatives([s.object(), s.array()]).required()})}, n.desc.entity = s.alternatives([s.array().items(s.link("...")), s.boolean(), s.function(), s.number(), s.string(), n.desc.buffer, n.desc.func, n.desc.ref, n.desc.regex, n.desc.special, n.desc.template, n.desc.value, s.link("/")]), n.desc.values = s.array().items(null, s.boolean(), s.function(), s.number().allow(1 / 0, -1 / 0), s.string().allow(""), s.symbol(), n.desc.buffer, n.desc.func, n.desc.override, n.desc.ref, n.desc.regex, n.desc.template, n.desc.value), n.desc.messages = s.object().pattern(/.+/, [s.string(), n.desc.template, s.object().pattern(/.+/, [s.string(), n.desc.template])]), t2.description = s.object({type: s.string().required(), flags: s.object({cast: s.string(), default: s.any(), description: s.string(), empty: s.link("/"), failover: n.desc.entity, id: s.string(), label: s.string(), only: true, presence: ["optional", "required", "forbidden"], result: ["raw", "strip"], strip: s.boolean(), unit: s.string()}).unknown(), preferences: {allowUnknown: s.boolean(), abortEarly: s.boolean(), artifacts: s.boolean(), cache: s.boolean(), convert: s.boolean(), dateFormat: ["date", "iso", "string", "time", "utc"], errors: {escapeHtml: s.boolean(), label: ["path", "key"], language: [s.string(), n.desc.ref], wrap: {label: n.wrap, array: n.wrap}}, externals: s.boolean(), messages: n.desc.messages, noDefaults: s.boolean(), nonEnumerables: s.boolean(), presence: ["required", "optional", "forbidden"], skipFunctions: s.boolean(), stripUnknown: s.object({arrays: s.boolean(), objects: s.boolean()}).or("arrays", "objects").allow(true, false), warnings: s.boolean()}, allow: n.desc.values, invalid: n.desc.values, rules: s.array().min(1).items({name: s.string().required(), args: s.object().min(1), keep: s.boolean(), message: [s.string(), n.desc.messages], warn: s.boolean()}), keys: s.object().pattern(/.*/, s.link("/")), link: n.desc.ref}).pattern(/^[a-z]\w*$/, s.any());
      }, 493: (e2, t2, r) => {
        const s = r(8571), n = r(9621), a = r(8160), o = {value: Symbol("value")};
        e2.exports = o.State = class {
          constructor(e3, t3, r2) {
            this.path = e3, this.ancestors = t3, this.mainstay = r2.mainstay, this.schemas = r2.schemas, this.debug = null;
          }
          localize(e3, t3 = null, r2 = null) {
            const s2 = new o.State(e3, t3, this);
            return r2 && s2.schemas && (s2.schemas = [o.schemas(r2), ...s2.schemas]), s2;
          }
          nest(e3, t3) {
            const r2 = new o.State(this.path, this.ancestors, this);
            return r2.schemas = r2.schemas && [o.schemas(e3), ...r2.schemas], r2.debug = t3, r2;
          }
          shadow(e3, t3) {
            this.mainstay.shadow = this.mainstay.shadow || new o.Shadow(), this.mainstay.shadow.set(this.path, e3, t3);
          }
          snapshot() {
            this.mainstay.shadow && (this._snapshot = s(this.mainstay.shadow.node(this.path)));
          }
          restore() {
            this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0);
          }
        }, o.schemas = function(e3) {
          return a.isSchema(e3) ? {schema: e3} : e3;
        }, o.Shadow = class {
          constructor() {
            this._values = null;
          }
          set(e3, t3, r2) {
            if (!e3.length)
              return;
            if (r2 === "strip" && typeof e3[e3.length - 1] == "number")
              return;
            this._values = this._values || new Map();
            let s2 = this._values;
            for (let t4 = 0; t4 < e3.length; ++t4) {
              const r3 = e3[t4];
              let n2 = s2.get(r3);
              n2 || (n2 = new Map(), s2.set(r3, n2)), s2 = n2;
            }
            s2[o.value] = t3;
          }
          get(e3) {
            const t3 = this.node(e3);
            if (t3)
              return t3[o.value];
          }
          node(e3) {
            if (this._values)
              return n(this._values, e3, {iterables: true});
          }
          override(e3, t3) {
            if (!this._values)
              return;
            const r2 = e3.slice(0, -1), s2 = e3[e3.length - 1], a2 = n(this._values, r2, {iterables: true});
            t3 ? a2.set(s2, t3) : a2 && a2.delete(s2);
          }
        };
      }, 3328: (e2, t2, r) => {
        function s(e3, t3) {
          var r2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var s2 = Object.getOwnPropertySymbols(e3);
            t3 && (s2 = s2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r2.push.apply(r2, s2);
          }
          return r2;
        }
        function n(e3, t3, r2) {
          return t3 in e3 ? Object.defineProperty(e3, t3, {value: r2, enumerable: true, configurable: true, writable: true}) : e3[t3] = r2, e3;
        }
        const a = r(375), o = r(8571), i = r(5277), l = r(1447), c = r(8160), u = r(6354), f = r(6133), m = {symbol: Symbol("template"), opens: new Array(1e3).join("\0"), closes: new Array(1e3).join(""), dateFormat: {date: Date.prototype.toDateString, iso: Date.prototype.toISOString, string: Date.prototype.toString, time: Date.prototype.toTimeString, utc: Date.prototype.toUTCString}};
        e2.exports = m.Template = class {
          constructor(e3, t3) {
            a(typeof e3 == "string", "Template source must be a string"), a(!e3.includes("\0") && !e3.includes(""), "Template source cannot contain reserved control characters"), this.source = e3, this.rendered = e3, this._template = null, this._settings = o(t3), this._parse();
          }
          _parse() {
            if (!this.source.includes("{"))
              return;
            const e3 = m.encode(this.source), t3 = m.split(e3);
            let r2 = false;
            const s2 = [], n2 = t3.shift();
            n2 && s2.push(n2);
            for (const e4 of t3) {
              const t4 = e4[0] !== "{", n3 = t4 ? "}" : "}}", a2 = e4.indexOf(n3);
              if (a2 === -1 || e4[1] === "{") {
                s2.push("{".concat(m.decode(e4)));
                continue;
              }
              let o2 = e4.slice(t4 ? 0 : 1, a2);
              const i2 = o2[0] === ":";
              i2 && (o2 = o2.slice(1));
              const l2 = this._ref(m.decode(o2), {raw: t4, wrapped: i2});
              s2.push(l2), typeof l2 != "string" && (r2 = true);
              const c2 = e4.slice(a2 + n3.length);
              c2 && s2.push(m.decode(c2));
            }
            r2 ? this._template = s2 : this.rendered = s2.join("");
          }
          static date(e3, t3) {
            return m.dateFormat[t3.dateFormat].call(e3);
          }
          describe(e3 = {}) {
            if (!this._settings && e3.compact)
              return this.source;
            const t3 = {template: this.source};
            return this._settings && (t3.options = this._settings), t3;
          }
          static build(e3) {
            return new m.Template(e3.template, e3.options);
          }
          isDynamic() {
            return !!this._template;
          }
          static isTemplate(e3) {
            return !!e3 && !!e3[c.symbols.template];
          }
          refs() {
            if (!this._template)
              return;
            const e3 = [];
            for (const t3 of this._template)
              typeof t3 != "string" && e3.push(...t3.refs);
            return e3;
          }
          resolve(e3, t3, r2, s2) {
            return this._template && this._template.length === 1 ? this._part(this._template[0], e3, t3, r2, s2, {}) : this.render(e3, t3, r2, s2);
          }
          _part(e3, ...t3) {
            return e3.ref ? e3.ref.resolve(...t3) : e3.formula.evaluate(t3);
          }
          render(e3, t3, r2, s2, n2 = {}) {
            if (!this.isDynamic())
              return this.rendered;
            const a2 = [];
            for (const o2 of this._template)
              if (typeof o2 == "string")
                a2.push(o2);
              else {
                const l2 = this._part(o2, e3, t3, r2, s2, n2), c2 = m.stringify(l2, e3, t3, r2, s2, n2);
                if (c2 !== void 0) {
                  const e4 = o2.raw || (n2.errors && n2.errors.escapeHtml) === false ? c2 : i(c2);
                  a2.push(m.wrap(e4, o2.wrapped && r2.errors.wrap.label));
                }
              }
            return a2.join("");
          }
          _ref(e3, {raw: t3, wrapped: r2}) {
            const s2 = [], n2 = (e4) => {
              const t4 = f.create(e4, this._settings);
              return s2.push(t4), (e5) => t4.resolve(...e5);
            };
            try {
              var a2 = new l.Parser(e3, {reference: n2, functions: m.functions, constants: m.constants});
            } catch (t4) {
              throw t4.message = 'Invalid template variable "'.concat(e3, '" fails due to: ').concat(t4.message), t4;
            }
            if (a2.single) {
              if (a2.single.type === "reference") {
                const e4 = s2[0];
                return {ref: e4, raw: t3, refs: s2, wrapped: r2 || e4.type === "local" && e4.key === "label"};
              }
              return m.stringify(a2.single.value);
            }
            return {formula: a2, raw: t3, refs: s2};
          }
          toString() {
            return this.source;
          }
        }, m.Template.prototype[c.symbols.template] = true, m.Template.prototype.isImmutable = true, m.encode = function(e3) {
          return e3.replace(/\\(\{+)/g, (e4, t3) => m.opens.slice(0, t3.length)).replace(/\\(\}+)/g, (e4, t3) => m.closes.slice(0, t3.length));
        }, m.decode = function(e3) {
          return e3.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
        }, m.split = function(e3) {
          const t3 = [];
          let r2 = "";
          for (let s2 = 0; s2 < e3.length; ++s2) {
            const n2 = e3[s2];
            if (n2 === "{") {
              let n3 = "";
              for (; s2 + 1 < e3.length && e3[s2 + 1] === "{"; )
                n3 += "{", ++s2;
              t3.push(r2), r2 = n3;
            } else
              r2 += n2;
          }
          return t3.push(r2), t3;
        }, m.wrap = function(e3, t3) {
          return t3 ? t3.length === 1 ? "".concat(t3).concat(e3).concat(t3) : "".concat(t3[0]).concat(e3).concat(t3[1]) : e3;
        }, m.stringify = function(e3, t3, r2, a2, o2, i2) {
          const l2 = typeof e3;
          let c2 = false;
          if (f.isRef(e3) && e3.render && (c2 = e3.in, e3 = e3.resolve(t3, r2, a2, o2, function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r3 = arguments[t4] != null ? arguments[t4] : {};
              t4 % 2 ? s(Object(r3), true).forEach(function(t5) {
                n(e4, t5, r3[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r3)) : s(Object(r3)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r3, t5));
              });
            }
            return e4;
          }({in: e3.in}, i2))), e3 === null)
            return "null";
          if (l2 === "string")
            return e3;
          if (l2 === "number" || l2 === "function" || l2 === "symbol")
            return e3.toString();
          if (l2 !== "object")
            return JSON.stringify(e3);
          if (e3 instanceof Date)
            return m.Template.date(e3, a2);
          if (e3 instanceof Map) {
            const t4 = [];
            for (const [r3, s2] of e3.entries())
              t4.push("".concat(r3.toString(), " -> ").concat(s2.toString()));
            e3 = t4;
          }
          if (!Array.isArray(e3))
            return e3.toString();
          let u2 = "";
          for (const s2 of e3)
            u2 = u2 + (u2.length ? ", " : "") + m.stringify(s2, t3, r2, a2, o2, i2);
          return c2 ? u2 : m.wrap(u2, a2.errors.wrap.array);
        }, m.constants = {true: true, false: false, null: null, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5}, m.functions = {if: (e3, t3, r2) => e3 ? t3 : r2, msg(e3) {
          const [t3, r2, s2, n2, a2] = this, o2 = a2.messages;
          if (!o2)
            return "";
          const i2 = u.template(t3, o2[0], e3, r2, s2) || u.template(t3, o2[1], e3, r2, s2);
          return i2 ? i2.render(t3, r2, s2, n2, a2) : "";
        }, number: (e3) => typeof e3 == "number" ? e3 : typeof e3 == "string" ? parseFloat(e3) : typeof e3 == "boolean" ? e3 ? 1 : 0 : e3 instanceof Date ? e3.getTime() : null};
      }, 4946: (e2, t2, r) => {
        const s = r(375), n = r(1687), a = r(8068), o = r(8160), i = r(3292), l = r(6354), c = r(6133), u = {};
        e2.exports = a.extend({type: "alternatives", flags: {match: {default: "any"}}, terms: {matches: {init: [], register: c.toSibling}}, args: (e3, ...t3) => t3.length === 1 && Array.isArray(t3[0]) ? e3.try(...t3[0]) : e3.try(...t3), validate(e3, t3) {
          const {schema: r2, error: s2, state: a2, prefs: o2} = t3;
          if (r2._flags.match) {
            const t4 = [];
            for (let s3 = 0; s3 < r2.$_terms.matches.length; ++s3) {
              const n2 = r2.$_terms.matches[s3], i3 = a2.nest(n2.schema, "match.".concat(s3));
              i3.snapshot();
              const l2 = n2.schema.$_validate(e3, i3, o2);
              l2.errors ? i3.restore() : t4.push(l2.value);
            }
            return t4.length === 0 ? {errors: s2("alternatives.any")} : r2._flags.match === "one" ? t4.length === 1 ? {value: t4[0]} : {errors: s2("alternatives.one")} : t4.length !== r2.$_terms.matches.length ? {errors: s2("alternatives.all")} : r2.$_terms.matches.reduce((e4, t5) => e4 && t5.schema.type === "object", true) ? {value: t4.reduce((e4, t5) => n(e4, t5, {mergeArrays: false}))} : {value: t4[t4.length - 1]};
          }
          const i2 = [];
          for (let t4 = 0; t4 < r2.$_terms.matches.length; ++t4) {
            const s3 = r2.$_terms.matches[t4];
            if (s3.schema) {
              const r3 = a2.nest(s3.schema, "match.".concat(t4));
              r3.snapshot();
              const n3 = s3.schema.$_validate(e3, r3, o2);
              if (!n3.errors)
                return n3;
              r3.restore(), i2.push({schema: s3.schema, reports: n3.errors});
              continue;
            }
            const n2 = s3.ref ? s3.ref.resolve(e3, a2, o2) : e3, l2 = s3.is ? [s3] : s3.switch;
            for (let r3 = 0; r3 < l2.length; ++r3) {
              const i3 = l2[r3], {is: c2, then: u2, otherwise: f} = i3, m = "match.".concat(t4).concat(s3.switch ? "." + r3 : "");
              if (c2.$_match(n2, a2.nest(c2, "".concat(m, ".is")), o2)) {
                if (u2)
                  return u2.$_validate(e3, a2.nest(u2, "".concat(m, ".then")), o2);
              } else if (f)
                return f.$_validate(e3, a2.nest(f, "".concat(m, ".otherwise")), o2);
            }
          }
          return u.errors(i2, t3);
        }, rules: {conditional: {method(e3, t3) {
          s(!this._flags._endedSwitch, "Unreachable condition"), s(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), s(t3.break === void 0, "Cannot use break option with alternatives conditional");
          const r2 = this.clone(), n2 = i.when(r2, e3, t3), a2 = n2.is ? [n2] : n2.switch;
          for (const e4 of a2)
            if (e4.then && e4.otherwise) {
              r2.$_setFlag("_endedSwitch", true, {clone: false});
              break;
            }
          return r2.$_terms.matches.push(n2), r2.$_mutateRebuild();
        }}, match: {method(e3) {
          if (s(["any", "one", "all"].includes(e3), "Invalid alternatives match mode", e3), e3 !== "any")
            for (const t3 of this.$_terms.matches)
              s(t3.schema, "Cannot combine match mode", e3, "with conditional rules");
          return this.$_setFlag("match", e3);
        }}, try: {method(...e3) {
          s(e3.length, "Missing alternative schemas"), o.verifyFlat(e3, "try"), s(!this._flags._endedSwitch, "Unreachable condition");
          const t3 = this.clone();
          for (const r2 of e3)
            t3.$_terms.matches.push({schema: t3.$_compile(r2)});
          return t3.$_mutateRebuild();
        }}}, overrides: {label(e3) {
          return this.$_parent("label", e3).$_modify({each: (t3, r2) => r2.path[0] !== "is" ? t3.label(e3) : void 0, ref: false});
        }}, rebuild(e3) {
          e3.$_modify({each: (t3) => {
            o.isSchema(t3) && t3.type === "array" && e3.$_setFlag("_arrayItems", true, {clone: false});
          }});
        }, manifest: {build(e3, t3) {
          if (t3.matches)
            for (const r2 of t3.matches) {
              const {schema: t4, ref: s2, is: n2, not: a2, then: o2, otherwise: i2} = r2;
              e3 = t4 ? e3.try(t4) : s2 ? e3.conditional(s2, {is: n2, then: o2, not: a2, otherwise: i2, switch: r2.switch}) : e3.conditional(n2, {then: o2, otherwise: i2});
            }
          return e3;
        }}, messages: {"alternatives.all": "{{#label}} does not match all of the required types", "alternatives.any": "{{#label}} does not match any of the allowed types", "alternatives.match": "{{#label}} does not match any of the allowed types", "alternatives.one": "{{#label}} matches more than one allowed type", "alternatives.types": "{{#label}} must be one of {{#types}}"}}), u.errors = function(e3, {error: t3, state: r2}) {
          if (!e3.length)
            return {errors: t3("alternatives.any")};
          if (e3.length === 1)
            return {errors: e3[0].reports};
          const s2 = new Set(), n2 = [];
          for (const {reports: a2, schema: o2} of e3) {
            if (a2.length > 1)
              return u.unmatched(e3, t3);
            const i2 = a2[0];
            if (i2 instanceof l.Report == 0)
              return u.unmatched(e3, t3);
            if (i2.state.path.length !== r2.path.length) {
              n2.push({type: o2.type, report: i2});
              continue;
            }
            if (i2.code === "any.only") {
              for (const e4 of i2.local.valids)
                s2.add(e4);
              continue;
            }
            const [c2, f] = i2.code.split(".");
            f === "base" ? s2.add(c2) : n2.push({type: o2.type, report: i2});
          }
          return n2.length ? n2.length === 1 ? {errors: n2[0].report} : u.unmatched(e3, t3) : {errors: t3("alternatives.types", {types: [...s2]})};
        }, u.unmatched = function(e3, t3) {
          const r2 = [];
          for (const t4 of e3)
            r2.push(...t4.reports);
          return {errors: t3("alternatives.match", l.details(r2, {override: false}))};
        };
      }, 8068: (e2, t2, r) => {
        const s = r(375), n = r(7629), a = r(8160), o = r(6914);
        e2.exports = n.extend({type: "any", flags: {only: {default: false}}, terms: {alterations: {init: null}, examples: {init: null}, externals: {init: null}, metas: {init: []}, notes: {init: []}, shared: {init: null}, tags: {init: []}, whens: {init: null}}, rules: {custom: {method(e3, t3) {
          return s(typeof e3 == "function", "Method must be a function"), s(t3 === void 0 || t3 && typeof t3 == "string", "Description must be a non-empty string"), this.$_addRule({name: "custom", args: {method: e3, description: t3}});
        }, validate(e3, t3, {method: r2}) {
          try {
            return r2(e3, t3);
          } catch (e4) {
            return t3.error("any.custom", {error: e4});
          }
        }, args: ["method", "description"], multi: true}, messages: {method(e3) {
          return this.prefs({messages: e3});
        }}, shared: {method(e3) {
          s(a.isSchema(e3) && e3._flags.id, "Schema must be a schema with an id");
          const t3 = this.clone();
          return t3.$_terms.shared = t3.$_terms.shared || [], t3.$_terms.shared.push(e3), t3.$_mutateRegister(e3), t3;
        }}, warning: {method(e3, t3) {
          return s(e3 && typeof e3 == "string", "Invalid warning code"), this.$_addRule({name: "warning", args: {code: e3, local: t3}, warn: true});
        }, validate: (e3, t3, {code: r2, local: s2}) => t3.error(r2, s2), args: ["code", "local"], multi: true}}, modifiers: {keep(e3, t3 = true) {
          e3.keep = t3;
        }, message(e3, t3) {
          e3.message = o.compile(t3);
        }, warn(e3, t3 = true) {
          e3.warn = t3;
        }}, manifest: {build(e3, t3) {
          for (const r2 in t3) {
            const s2 = t3[r2];
            if (["examples", "externals", "metas", "notes", "tags"].includes(r2))
              for (const t4 of s2)
                e3 = e3[r2.slice(0, -1)](t4);
            else if (r2 !== "alterations")
              if (r2 !== "whens") {
                if (r2 === "shared")
                  for (const t4 of s2)
                    e3 = e3.shared(t4);
              } else
                for (const t4 of s2) {
                  const {ref: r3, is: s3, not: n2, then: a2, otherwise: o2, concat: i} = t4;
                  e3 = i ? e3.concat(i) : r3 ? e3.when(r3, {is: s3, not: n2, then: a2, otherwise: o2, switch: t4.switch, break: t4.break}) : e3.when(s3, {then: a2, otherwise: o2, break: t4.break});
                }
            else {
              const t4 = {};
              for (const {target: e4, adjuster: r3} of s2)
                t4[e4] = r3;
              e3 = e3.alter(t4);
            }
          }
          return e3;
        }}, messages: {"any.custom": "{{#label}} failed custom validation because {{#error.message}}", "any.default": "{{#label}} threw an error when running default method", "any.failover": "{{#label}} threw an error when running failover method", "any.invalid": "{{#label}} contains an invalid value", "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}', "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}", "any.required": "{{#label}} is required", "any.unknown": "{{#label}} is not allowed"}});
      }, 546: (e2, t2, r) => {
        const s = r(375), n = r(9474), a = r(9621), o = r(8068), i = r(8160), l = r(3292), c = {};
        e2.exports = o.extend({type: "array", flags: {single: {default: false}, sparse: {default: false}}, terms: {items: {init: [], manifest: "schema"}, ordered: {init: [], manifest: "schema"}, _exclusions: {init: []}, _inclusions: {init: []}, _requireds: {init: []}}, coerce: {from: "object", method(e3, {schema: t3, state: r2, prefs: s2}) {
          if (!Array.isArray(e3))
            return;
          const n2 = t3.$_getRule("sort");
          return n2 ? c.sort(t3, e3, n2.args.options, r2, s2) : void 0;
        }}, validate(e3, {schema: t3, error: r2}) {
          if (!Array.isArray(e3)) {
            if (t3._flags.single) {
              const t4 = [e3];
              return t4[i.symbols.arraySingle] = true, {value: t4};
            }
            return {errors: r2("array.base")};
          }
          if (t3.$_getRule("items") || t3.$_terms.externals)
            return {value: e3.slice()};
        }, rules: {has: {method(e3) {
          e3 = this.$_compile(e3, {appendPath: true});
          const t3 = this.$_addRule({name: "has", args: {schema: e3}});
          return t3.$_mutateRegister(e3), t3;
        }, validate(e3, {state: t3, prefs: r2, error: s2}, {schema: n2}) {
          const a2 = [e3, ...t3.ancestors];
          for (let s3 = 0; s3 < e3.length; ++s3) {
            const o3 = t3.localize([...t3.path, s3], a2, n2);
            if (n2.$_match(e3[s3], o3, r2))
              return e3;
          }
          const o2 = n2._flags.label;
          return o2 ? s2("array.hasKnown", {patternLabel: o2}) : s2("array.hasUnknown", null);
        }, multi: true}, items: {method(...e3) {
          i.verifyFlat(e3, "items");
          const t3 = this.$_addRule("items");
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const s2 = i.tryWithPath(() => this.$_compile(e3[r2]), r2, {append: true});
            t3.$_terms.items.push(s2);
          }
          return t3.$_mutateRebuild();
        }, validate(e3, {schema: t3, error: r2, state: s2, prefs: n2, errorsArray: a2}) {
          const o2 = t3.$_terms._requireds.slice(), l2 = t3.$_terms.ordered.slice(), u = [...t3.$_terms._inclusions, ...o2], f = !e3[i.symbols.arraySingle];
          delete e3[i.symbols.arraySingle];
          const m = a2();
          let h = e3.length;
          for (let a3 = 0; a3 < h; ++a3) {
            const i2 = e3[a3];
            let d = false, p = false;
            const g = f ? a3 : new Number(a3), y = [...s2.path, g];
            if (!t3._flags.sparse && i2 === void 0) {
              if (m.push(r2("array.sparse", {key: g, path: y, pos: a3, value: void 0}, s2.localize(y))), n2.abortEarly)
                return m;
              l2.shift();
              continue;
            }
            const b = [e3, ...s2.ancestors];
            for (const e4 of t3.$_terms._exclusions)
              if (e4.$_match(i2, s2.localize(y, b, e4), n2, {presence: "ignore"})) {
                if (m.push(r2("array.excludes", {pos: a3, value: i2}, s2.localize(y))), n2.abortEarly)
                  return m;
                d = true, l2.shift();
                break;
              }
            if (d)
              continue;
            if (t3.$_terms.ordered.length) {
              if (l2.length) {
                const o3 = l2.shift(), u2 = o3.$_validate(i2, s2.localize(y, b, o3), n2);
                if (u2.errors) {
                  if (m.push(...u2.errors), n2.abortEarly)
                    return m;
                } else if (o3._flags.result === "strip")
                  c.fastSplice(e3, a3), --a3, --h;
                else {
                  if (!t3._flags.sparse && u2.value === void 0) {
                    if (m.push(r2("array.sparse", {key: g, path: y, pos: a3, value: void 0}, s2.localize(y))), n2.abortEarly)
                      return m;
                    continue;
                  }
                  e3[a3] = u2.value;
                }
                continue;
              }
              if (!t3.$_terms.items.length) {
                if (m.push(r2("array.orderedLength", {pos: a3, limit: t3.$_terms.ordered.length})), n2.abortEarly)
                  return m;
                break;
              }
            }
            const v = [];
            let _ = o2.length;
            for (let l3 = 0; l3 < _; ++l3) {
              const u2 = s2.localize(y, b, o2[l3]);
              u2.snapshot();
              const f2 = o2[l3].$_validate(i2, u2, n2);
              if (v[l3] = f2, !f2.errors) {
                if (e3[a3] = f2.value, p = true, c.fastSplice(o2, l3), --l3, --_, !t3._flags.sparse && f2.value === void 0 && (m.push(r2("array.sparse", {key: g, path: y, pos: a3, value: void 0}, s2.localize(y))), n2.abortEarly))
                  return m;
                break;
              }
              u2.restore();
            }
            if (p)
              continue;
            const w = n2.stripUnknown && !!n2.stripUnknown.arrays || false;
            _ = u.length;
            for (const l3 of u) {
              let u2;
              const f2 = o2.indexOf(l3);
              if (f2 !== -1)
                u2 = v[f2];
              else {
                const o3 = s2.localize(y, b, l3);
                if (o3.snapshot(), u2 = l3.$_validate(i2, o3, n2), !u2.errors) {
                  l3._flags.result === "strip" ? (c.fastSplice(e3, a3), --a3, --h) : t3._flags.sparse || u2.value !== void 0 ? e3[a3] = u2.value : (m.push(r2("array.sparse", {key: g, path: y, pos: a3, value: void 0}, s2.localize(y))), d = true), p = true;
                  break;
                }
                o3.restore();
              }
              if (_ === 1) {
                if (w) {
                  c.fastSplice(e3, a3), --a3, --h, p = true;
                  break;
                }
                if (m.push(...u2.errors), n2.abortEarly)
                  return m;
                d = true;
                break;
              }
            }
            if (!d && (t3.$_terms._inclusions.length || t3.$_terms._requireds.length) && !p) {
              if (w) {
                c.fastSplice(e3, a3), --a3, --h;
                continue;
              }
              if (m.push(r2("array.includes", {pos: a3, value: i2}, s2.localize(y))), n2.abortEarly)
                return m;
            }
          }
          return o2.length && c.fillMissedErrors(t3, m, o2, e3, s2, n2), l2.length && (c.fillOrderedErrors(t3, m, l2, e3, s2, n2), m.length || c.fillDefault(l2, e3, s2, n2)), m.length ? m : e3;
        }, priority: true, manifest: false}, length: {method(e3) {
          return this.$_addRule({name: "length", args: {limit: e3}, operator: "="});
        }, validate: (e3, t3, {limit: r2}, {name: s2, operator: n2, args: a2}) => i.compare(e3.length, r2, n2) ? e3 : t3.error("array." + s2, {limit: a2.limit, value: e3}), args: [{name: "limit", ref: true, assert: i.limit, message: "must be a positive integer"}]}, max: {method(e3) {
          return this.$_addRule({name: "max", method: "length", args: {limit: e3}, operator: "<="});
        }}, min: {method(e3) {
          return this.$_addRule({name: "min", method: "length", args: {limit: e3}, operator: ">="});
        }}, ordered: {method(...e3) {
          i.verifyFlat(e3, "ordered");
          const t3 = this.$_addRule("items");
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const s2 = i.tryWithPath(() => this.$_compile(e3[r2]), r2, {append: true});
            c.validateSingle(s2, t3), t3.$_mutateRegister(s2), t3.$_terms.ordered.push(s2);
          }
          return t3.$_mutateRebuild();
        }}, single: {method(e3) {
          const t3 = e3 === void 0 || !!e3;
          return s(!t3 || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", t3);
        }}, sort: {method(e3 = {}) {
          i.assertOptions(e3, ["by", "order"]);
          const t3 = {order: e3.order || "ascending"};
          return e3.by && (t3.by = l.ref(e3.by, {ancestor: 0}), s(!t3.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({name: "sort", args: {options: t3}});
        }, validate(e3, {error: t3, state: r2, prefs: s2, schema: n2}, {options: a2}) {
          const {value: o2, errors: i2} = c.sort(n2, e3, a2, r2, s2);
          if (i2)
            return i2;
          for (let r3 = 0; r3 < e3.length; ++r3)
            if (e3[r3] !== o2[r3])
              return t3("array.sort", {order: a2.order, by: a2.by ? a2.by.key : "value"});
          return e3;
        }, convert: true}, sparse: {method(e3) {
          const t3 = e3 === void 0 || !!e3;
          return this._flags.sparse === t3 ? this : (t3 ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", t3, {clone: false});
        }}, unique: {method(e3, t3 = {}) {
          s(!e3 || typeof e3 == "function" || typeof e3 == "string", "comparator must be a function or a string"), i.assertOptions(t3, ["ignoreUndefined", "separator"]);
          const r2 = {name: "unique", args: {options: t3, comparator: e3}};
          if (e3)
            if (typeof e3 == "string") {
              const s2 = i.default(t3.separator, ".");
              r2.path = s2 ? e3.split(s2) : [e3];
            } else
              r2.comparator = e3;
          return this.$_addRule(r2);
        }, validate(e3, {state: t3, error: r2, schema: o2}, {comparator: i2, options: l2}, {comparator: c2, path: u}) {
          const f = {string: Object.create(null), number: Object.create(null), undefined: Object.create(null), boolean: Object.create(null), object: new Map(), function: new Map(), custom: new Map()}, m = c2 || n, h = l2.ignoreUndefined;
          for (let n2 = 0; n2 < e3.length; ++n2) {
            const o3 = u ? a(e3[n2], u) : e3[n2], l3 = c2 ? f.custom : f[typeof o3];
            if (s(l3, "Failed to find unique map container for type", typeof o3), l3 instanceof Map) {
              const s2 = l3.entries();
              let a2;
              for (; !(a2 = s2.next()).done; )
                if (m(a2.value[0], o3)) {
                  const s3 = t3.localize([...t3.path, n2], [e3, ...t3.ancestors]), o4 = {pos: n2, value: e3[n2], dupePos: a2.value[1], dupeValue: e3[a2.value[1]]};
                  return u && (o4.path = i2), r2("array.unique", o4, s3);
                }
              l3.set(o3, n2);
            } else {
              if ((!h || o3 !== void 0) && l3[o3] !== void 0) {
                const s2 = {pos: n2, value: e3[n2], dupePos: l3[o3], dupeValue: e3[l3[o3]]};
                return u && (s2.path = i2), r2("array.unique", s2, t3.localize([...t3.path, n2], [e3, ...t3.ancestors]));
              }
              l3[o3] = n2;
            }
          }
          return e3;
        }, args: ["comparator", "options"], multi: true}}, cast: {set: {from: Array.isArray, to: (e3, t3) => new Set(e3)}}, rebuild(e3) {
          e3.$_terms._inclusions = [], e3.$_terms._exclusions = [], e3.$_terms._requireds = [];
          for (const t3 of e3.$_terms.items)
            c.validateSingle(t3, e3), t3._flags.presence === "required" ? e3.$_terms._requireds.push(t3) : t3._flags.presence === "forbidden" ? e3.$_terms._exclusions.push(t3) : e3.$_terms._inclusions.push(t3);
          for (const t3 of e3.$_terms.ordered)
            c.validateSingle(t3, e3);
        }, manifest: {build: (e3, t3) => (t3.items && (e3 = e3.items(...t3.items)), t3.ordered && (e3 = e3.ordered(...t3.ordered)), e3)}, messages: {"array.base": "{{#label}} must be an array", "array.excludes": "{{#label}} contains an excluded value", "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}", "array.hasUnknown": "{{#label}} does not contain at least one required match", "array.includes": "{{#label}} does not match any of the allowed types", "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)", "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}", "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)", "array.length": "{{#label}} must contain {{#limit}} items", "array.max": "{{#label}} must contain less than or equal to {{#limit}} items", "array.min": "{{#label}} must contain at least {{#limit}} items", "array.orderedLength": "{{#label}} must contain at most {{#limit}} items", "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}", "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types", "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}", "array.sparse": "{{#label}} must not be a sparse array item", "array.unique": "{{#label}} contains a duplicate value"}}), c.fillMissedErrors = function(e3, t3, r2, s2, n2, a2) {
          const o2 = [];
          let i2 = 0;
          for (const e4 of r2) {
            const t4 = e4._flags.label;
            t4 ? o2.push(t4) : ++i2;
          }
          o2.length ? i2 ? t3.push(e3.$_createError("array.includesRequiredBoth", s2, {knownMisses: o2, unknownMisses: i2}, n2, a2)) : t3.push(e3.$_createError("array.includesRequiredKnowns", s2, {knownMisses: o2}, n2, a2)) : t3.push(e3.$_createError("array.includesRequiredUnknowns", s2, {unknownMisses: i2}, n2, a2));
        }, c.fillOrderedErrors = function(e3, t3, r2, s2, n2, a2) {
          const o2 = [];
          for (const e4 of r2)
            e4._flags.presence === "required" && o2.push(e4);
          o2.length && c.fillMissedErrors(e3, t3, o2, s2, n2, a2);
        }, c.fillDefault = function(e3, t3, r2, s2) {
          const n2 = [];
          let a2 = true;
          for (let o2 = e3.length - 1; o2 >= 0; --o2) {
            const i2 = e3[o2], l2 = [t3, ...r2.ancestors], c2 = i2.$_validate(void 0, r2.localize(r2.path, l2, i2), s2).value;
            if (a2) {
              if (c2 === void 0)
                continue;
              a2 = false;
            }
            n2.unshift(c2);
          }
          n2.length && t3.push(...n2);
        }, c.fastSplice = function(e3, t3) {
          let r2 = t3;
          for (; r2 < e3.length; )
            e3[r2++] = e3[r2];
          --e3.length;
        }, c.validateSingle = function(e3, t3) {
          (e3.type === "array" || e3._flags._arrayItems) && (s(!t3._flags.single, "Cannot specify array item with single rule enabled"), t3.$_setFlag("_arrayItems", true, {clone: false}));
        }, c.sort = function(e3, t3, r2, s2, n2) {
          const a2 = r2.order === "ascending" ? 1 : -1, o2 = -1 * a2, i2 = a2, l2 = (l3, u) => {
            let f = c.compare(l3, u, o2, i2);
            if (f !== null)
              return f;
            if (r2.by && (l3 = r2.by.resolve(l3, s2, n2), u = r2.by.resolve(u, s2, n2)), f = c.compare(l3, u, o2, i2), f !== null)
              return f;
            const m = typeof l3;
            if (m !== typeof u)
              throw e3.$_createError("array.sort.mismatching", t3, null, s2, n2);
            if (m !== "number" && m !== "string")
              throw e3.$_createError("array.sort.unsupported", t3, {type: m}, s2, n2);
            return m === "number" ? (l3 - u) * a2 : l3 < u ? o2 : i2;
          };
          try {
            return {value: t3.slice().sort(l2)};
          } catch (e4) {
            return {errors: e4};
          }
        }, c.compare = function(e3, t3, r2, s2) {
          return e3 === t3 ? 0 : e3 === void 0 ? 1 : t3 === void 0 ? -1 : e3 === null ? s2 : t3 === null ? r2 : null;
        };
      }, 4937: (e2, t2, r) => {
        const s = r(375), n = r(8068), a = r(8160), o = r(2036), i = {isBool: function(e3) {
          return typeof e3 == "boolean";
        }};
        e2.exports = n.extend({type: "boolean", flags: {sensitive: {default: false}}, terms: {falsy: {init: null, manifest: "values"}, truthy: {init: null, manifest: "values"}}, coerce(e3, {schema: t3}) {
          if (typeof e3 != "boolean") {
            if (typeof e3 == "string") {
              const r2 = t3._flags.sensitive ? e3 : e3.toLowerCase();
              e3 = r2 === "true" || r2 !== "false" && e3;
            }
            return typeof e3 != "boolean" && (e3 = t3.$_terms.truthy && t3.$_terms.truthy.has(e3, null, null, !t3._flags.sensitive) || (!t3.$_terms.falsy || !t3.$_terms.falsy.has(e3, null, null, !t3._flags.sensitive)) && e3), {value: e3};
          }
        }, validate(e3, {error: t3}) {
          if (typeof e3 != "boolean")
            return {value: e3, errors: t3("boolean.base")};
        }, rules: {truthy: {method(...e3) {
          a.verifyFlat(e3, "truthy");
          const t3 = this.clone();
          t3.$_terms.truthy = t3.$_terms.truthy || new o();
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const n2 = e3[r2];
            s(n2 !== void 0, "Cannot call truthy with undefined"), t3.$_terms.truthy.add(n2);
          }
          return t3;
        }}, falsy: {method(...e3) {
          a.verifyFlat(e3, "falsy");
          const t3 = this.clone();
          t3.$_terms.falsy = t3.$_terms.falsy || new o();
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const n2 = e3[r2];
            s(n2 !== void 0, "Cannot call falsy with undefined"), t3.$_terms.falsy.add(n2);
          }
          return t3;
        }}, sensitive: {method(e3 = true) {
          return this.$_setFlag("sensitive", e3);
        }}}, cast: {number: {from: i.isBool, to: (e3, t3) => e3 ? 1 : 0}, string: {from: i.isBool, to: (e3, t3) => e3 ? "true" : "false"}}, manifest: {build: (e3, t3) => (t3.truthy && (e3 = e3.truthy(...t3.truthy)), t3.falsy && (e3 = e3.falsy(...t3.falsy)), e3)}, messages: {"boolean.base": "{{#label}} must be a boolean"}});
      }, 7500: (e2, t2, r) => {
        const s = r(375), n = r(8068), a = r(8160), o = r(3328), i = {isDate: function(e3) {
          return e3 instanceof Date;
        }};
        e2.exports = n.extend({type: "date", coerce: {from: ["number", "string"], method: (e3, {schema: t3}) => ({value: i.parse(e3, t3._flags.format) || e3})}, validate(e3, {schema: t3, error: r2, prefs: s2}) {
          if (e3 instanceof Date && !isNaN(e3.getTime()))
            return;
          const n2 = t3._flags.format;
          return s2.convert && n2 && typeof e3 == "string" ? {value: e3, errors: r2("date.format", {format: n2})} : {value: e3, errors: r2("date.base")};
        }, rules: {compare: {method: false, validate(e3, t3, {date: r2}, {name: s2, operator: n2, args: o2}) {
          const i2 = r2 === "now" ? Date.now() : r2.getTime();
          return a.compare(e3.getTime(), i2, n2) ? e3 : t3.error("date." + s2, {limit: o2.date, value: e3});
        }, args: [{name: "date", ref: true, normalize: (e3) => e3 === "now" ? e3 : i.parse(e3), assert: (e3) => e3 !== null, message: "must have a valid date format"}]}, format: {method(e3) {
          return s(["iso", "javascript", "unix"].includes(e3), "Unknown date format", e3), this.$_setFlag("format", e3);
        }}, greater: {method(e3) {
          return this.$_addRule({name: "greater", method: "compare", args: {date: e3}, operator: ">"});
        }}, iso: {method() {
          return this.format("iso");
        }}, less: {method(e3) {
          return this.$_addRule({name: "less", method: "compare", args: {date: e3}, operator: "<"});
        }}, max: {method(e3) {
          return this.$_addRule({name: "max", method: "compare", args: {date: e3}, operator: "<="});
        }}, min: {method(e3) {
          return this.$_addRule({name: "min", method: "compare", args: {date: e3}, operator: ">="});
        }}, timestamp: {method(e3 = "javascript") {
          return s(["javascript", "unix"].includes(e3), '"type" must be one of "javascript, unix"'), this.format(e3);
        }}}, cast: {number: {from: i.isDate, to: (e3, t3) => e3.getTime()}, string: {from: i.isDate, to: (e3, {prefs: t3}) => o.date(e3, t3)}}, messages: {"date.base": "{{#label}} must be a valid date", "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format', "date.greater": "{{#label}} must be greater than {{:#limit}}", "date.less": "{{#label}} must be less than {{:#limit}}", "date.max": "{{#label}} must be less than or equal to {{:#limit}}", "date.min": "{{#label}} must be greater than or equal to {{:#limit}}", "date.format.iso": "ISO 8601 date", "date.format.javascript": "timestamp or number of milliseconds", "date.format.unix": "timestamp or number of seconds"}}), i.parse = function(e3, t3) {
          if (e3 instanceof Date)
            return e3;
          if (typeof e3 != "string" && (isNaN(e3) || !isFinite(e3)))
            return null;
          if (/^\s*$/.test(e3))
            return null;
          if (t3 === "iso")
            return a.isIsoDate(e3) ? i.date(e3.toString()) : null;
          const r2 = e3;
          if (typeof e3 == "string" && /^[+-]?\d+(\.\d+)?$/.test(e3) && (e3 = parseFloat(e3)), t3) {
            if (t3 === "javascript")
              return i.date(1 * e3);
            if (t3 === "unix")
              return i.date(1e3 * e3);
            if (typeof r2 == "string")
              return null;
          }
          return i.date(e3);
        }, i.date = function(e3) {
          const t3 = new Date(e3);
          return isNaN(t3.getTime()) ? null : t3;
        };
      }, 390: (e2, t2, r) => {
        const s = r(375), n = r(7824);
        e2.exports = n.extend({type: "function", properties: {typeof: "function"}, rules: {arity: {method(e3) {
          return s(Number.isSafeInteger(e3) && e3 >= 0, "n must be a positive integer"), this.$_addRule({name: "arity", args: {n: e3}});
        }, validate: (e3, t3, {n: r2}) => e3.length === r2 ? e3 : t3.error("function.arity", {n: r2})}, class: {method() {
          return this.$_addRule("class");
        }, validate: (e3, t3) => /^\s*class\s/.test(e3.toString()) ? e3 : t3.error("function.class", {value: e3})}, minArity: {method(e3) {
          return s(Number.isSafeInteger(e3) && e3 > 0, "n must be a strict positive integer"), this.$_addRule({name: "minArity", args: {n: e3}});
        }, validate: (e3, t3, {n: r2}) => e3.length >= r2 ? e3 : t3.error("function.minArity", {n: r2})}, maxArity: {method(e3) {
          return s(Number.isSafeInteger(e3) && e3 >= 0, "n must be a positive integer"), this.$_addRule({name: "maxArity", args: {n: e3}});
        }, validate: (e3, t3, {n: r2}) => e3.length <= r2 ? e3 : t3.error("function.maxArity", {n: r2})}}, messages: {"function.arity": "{{#label}} must have an arity of {{#n}}", "function.class": "{{#label}} must be a class", "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}", "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"}});
      }, 7824: (e2, t2, r) => {
        const s = r(978), n = r(375), a = r(8571), o = r(3652), i = r(8068), l = r(8160), c = r(3292), u = r(6354), f = r(6133), m = r(3328), h = {renameDefaults: {alias: false, multiple: false, override: false}};
        e2.exports = i.extend({type: "_keys", properties: {typeof: "object"}, flags: {unknown: {default: false}}, terms: {dependencies: {init: null}, keys: {init: null, manifest: {mapped: {from: "schema", to: "key"}}}, patterns: {init: null}, renames: {init: null}}, args: (e3, t3) => e3.keys(t3), validate(e3, {schema: t3, error: r2, state: s2, prefs: n2}) {
          if (!e3 || typeof e3 !== t3.$_property("typeof") || Array.isArray(e3))
            return {value: e3, errors: r2("object.base", {type: t3.$_property("typeof")})};
          if (!(t3.$_terms.renames || t3.$_terms.dependencies || t3.$_terms.keys || t3.$_terms.patterns || t3.$_terms.externals))
            return;
          e3 = h.clone(e3, n2);
          const a2 = [];
          if (t3.$_terms.renames && !h.rename(t3, e3, s2, n2, a2))
            return {value: e3, errors: a2};
          if (!t3.$_terms.keys && !t3.$_terms.patterns && !t3.$_terms.dependencies)
            return {value: e3, errors: a2};
          const o2 = new Set(Object.keys(e3));
          if (t3.$_terms.keys) {
            const r3 = [e3, ...s2.ancestors];
            for (const i2 of t3.$_terms.keys) {
              const t4 = i2.key, l2 = e3[t4];
              o2.delete(t4);
              const c2 = s2.localize([...s2.path, t4], r3, i2), u2 = i2.schema.$_validate(l2, c2, n2);
              if (u2.errors) {
                if (n2.abortEarly)
                  return {value: e3, errors: u2.errors};
                u2.value !== void 0 && (e3[t4] = u2.value), a2.push(...u2.errors);
              } else
                i2.schema._flags.result === "strip" || u2.value === void 0 && l2 !== void 0 ? delete e3[t4] : u2.value !== void 0 && (e3[t4] = u2.value);
            }
          }
          if (o2.size || t3._flags._hasPatternMatch) {
            const r3 = h.unknown(t3, e3, o2, a2, s2, n2);
            if (r3)
              return r3;
          }
          if (t3.$_terms.dependencies)
            for (const r3 of t3.$_terms.dependencies) {
              if (r3.key && r3.key.resolve(e3, s2, n2, null, {shadow: false}) === void 0)
                continue;
              const o3 = h.dependencies[r3.rel](t3, r3, e3, s2, n2);
              if (o3) {
                const r4 = t3.$_createError(o3.code, e3, o3.context, s2, n2);
                if (n2.abortEarly)
                  return {value: e3, errors: r4};
                a2.push(r4);
              }
            }
          return {value: e3, errors: a2};
        }, rules: {and: {method(...e3) {
          return l.verifyFlat(e3, "and"), h.dependency(this, "and", null, e3);
        }}, append: {method(e3) {
          return e3 == null || Object.keys(e3).length === 0 ? this : this.keys(e3);
        }}, assert: {method(e3, t3, r2) {
          m.isTemplate(e3) || (e3 = c.ref(e3)), n(r2 === void 0 || typeof r2 == "string", "Message must be a string"), t3 = this.$_compile(t3, {appendPath: true});
          const s2 = this.$_addRule({name: "assert", args: {subject: e3, schema: t3, message: r2}});
          return s2.$_mutateRegister(e3), s2.$_mutateRegister(t3), s2;
        }, validate(e3, {error: t3, prefs: r2, state: s2}, {subject: n2, schema: a2, message: o2}) {
          const i2 = n2.resolve(e3, s2, r2), l2 = f.isRef(n2) ? n2.absolute(s2) : [];
          return a2.$_match(i2, s2.localize(l2, [e3, ...s2.ancestors], a2), r2) ? e3 : t3("object.assert", {subject: n2, message: o2});
        }, args: ["subject", "schema", "message"], multi: true}, instance: {method(e3, t3) {
          return n(typeof e3 == "function", "constructor must be a function"), t3 = t3 || e3.name, this.$_addRule({name: "instance", args: {constructor: e3, name: t3}});
        }, validate: (e3, t3, {constructor: r2, name: s2}) => e3 instanceof r2 ? e3 : t3.error("object.instance", {type: s2, value: e3}), args: ["constructor", "name"]}, keys: {method(e3) {
          n(e3 === void 0 || typeof e3 == "object", "Object schema must be a valid object"), n(!l.isSchema(e3), "Object schema cannot be a joi schema");
          const t3 = this.clone();
          if (e3)
            if (Object.keys(e3).length) {
              t3.$_terms.keys = t3.$_terms.keys ? t3.$_terms.keys.filter((t4) => !e3.hasOwnProperty(t4.key)) : new h.Keys();
              for (const r2 in e3)
                l.tryWithPath(() => t3.$_terms.keys.push({key: r2, schema: this.$_compile(e3[r2])}), r2);
            } else
              t3.$_terms.keys = new h.Keys();
          else
            t3.$_terms.keys = null;
          return t3.$_mutateRebuild();
        }}, length: {method(e3) {
          return this.$_addRule({name: "length", args: {limit: e3}, operator: "="});
        }, validate: (e3, t3, {limit: r2}, {name: s2, operator: n2, args: a2}) => l.compare(Object.keys(e3).length, r2, n2) ? e3 : t3.error("object." + s2, {limit: a2.limit, value: e3}), args: [{name: "limit", ref: true, assert: l.limit, message: "must be a positive integer"}]}, max: {method(e3) {
          return this.$_addRule({name: "max", method: "length", args: {limit: e3}, operator: "<="});
        }}, min: {method(e3) {
          return this.$_addRule({name: "min", method: "length", args: {limit: e3}, operator: ">="});
        }}, nand: {method(...e3) {
          return l.verifyFlat(e3, "nand"), h.dependency(this, "nand", null, e3);
        }}, or: {method(...e3) {
          return l.verifyFlat(e3, "or"), h.dependency(this, "or", null, e3);
        }}, oxor: {method(...e3) {
          return h.dependency(this, "oxor", null, e3);
        }}, pattern: {method(e3, t3, r2 = {}) {
          const s2 = e3 instanceof RegExp;
          s2 || (e3 = this.$_compile(e3, {appendPath: true})), n(t3 !== void 0, "Invalid rule"), l.assertOptions(r2, ["fallthrough", "matches"]), s2 && n(!e3.flags.includes("g") && !e3.flags.includes("y"), "pattern should not use global or sticky mode"), t3 = this.$_compile(t3, {appendPath: true});
          const a2 = this.clone();
          a2.$_terms.patterns = a2.$_terms.patterns || [];
          const o2 = {[s2 ? "regex" : "schema"]: e3, rule: t3};
          return r2.matches && (o2.matches = this.$_compile(r2.matches), o2.matches.type !== "array" && (o2.matches = o2.matches.$_root.array().items(o2.matches)), a2.$_mutateRegister(o2.matches), a2.$_setFlag("_hasPatternMatch", true, {clone: false})), r2.fallthrough && (o2.fallthrough = true), a2.$_terms.patterns.push(o2), a2.$_mutateRegister(t3), a2;
        }}, ref: {method() {
          return this.$_addRule("ref");
        }, validate: (e3, t3) => f.isRef(e3) ? e3 : t3.error("object.refType", {value: e3})}, regex: {method() {
          return this.$_addRule("regex");
        }, validate: (e3, t3) => e3 instanceof RegExp ? e3 : t3.error("object.regex", {value: e3})}, rename: {method(e3, t3, r2 = {}) {
          n(typeof e3 == "string" || e3 instanceof RegExp, "Rename missing the from argument"), n(typeof t3 == "string" || t3 instanceof m, "Invalid rename to argument"), n(t3 !== e3, "Cannot rename key to same name:", e3), l.assertOptions(r2, ["alias", "ignoreUndefined", "override", "multiple"]);
          const a2 = this.clone();
          a2.$_terms.renames = a2.$_terms.renames || [];
          for (const t4 of a2.$_terms.renames)
            n(t4.from !== e3, "Cannot rename the same key multiple times");
          return t3 instanceof m && a2.$_mutateRegister(t3), a2.$_terms.renames.push({from: e3, to: t3, options: s(h.renameDefaults, r2)}), a2;
        }}, schema: {method(e3 = "any") {
          return this.$_addRule({name: "schema", args: {type: e3}});
        }, validate: (e3, t3, {type: r2}) => !l.isSchema(e3) || r2 !== "any" && e3.type !== r2 ? t3.error("object.schema", {type: r2}) : e3}, unknown: {method(e3) {
          return this.$_setFlag("unknown", e3 !== false);
        }}, with: {method(e3, t3, r2 = {}) {
          return h.dependency(this, "with", e3, t3, r2);
        }}, without: {method(e3, t3, r2 = {}) {
          return h.dependency(this, "without", e3, t3, r2);
        }}, xor: {method(...e3) {
          return l.verifyFlat(e3, "xor"), h.dependency(this, "xor", null, e3);
        }}}, overrides: {default(e3, t3) {
          return e3 === void 0 && (e3 = l.symbols.deepDefault), this.$_parent("default", e3, t3);
        }}, rebuild(e3) {
          if (e3.$_terms.keys) {
            const t3 = new o.Sorter();
            for (const r2 of e3.$_terms.keys)
              l.tryWithPath(() => t3.add(r2, {after: r2.schema.$_rootReferences(), group: r2.key}), r2.key);
            e3.$_terms.keys = new h.Keys(...t3.nodes);
          }
        }, manifest: {build(e3, t3) {
          if (t3.keys && (e3 = e3.keys(t3.keys)), t3.dependencies)
            for (const {rel: r2, key: s2 = null, peers: n2, options: a2} of t3.dependencies)
              e3 = h.dependency(e3, r2, s2, n2, a2);
          if (t3.patterns)
            for (const {regex: r2, schema: s2, rule: n2, fallthrough: a2, matches: o2} of t3.patterns)
              e3 = e3.pattern(r2 || s2, n2, {fallthrough: a2, matches: o2});
          if (t3.renames)
            for (const {from: r2, to: s2, options: n2} of t3.renames)
              e3 = e3.rename(r2, s2, n2);
          return e3;
        }}, messages: {"object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}", "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}', "object.base": "{{#label}} must be of type {{#type}}", "object.instance": "{{#label}} must be an instance of {{:#type}}", "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}', "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}', "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}', "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}", "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}", "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}", "object.pattern.match": "{{#label}} keys failed to match pattern requirements", "object.refType": "{{#label}} must be a Joi reference", "object.regex": "{{#label}} must be a RegExp object", "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}", "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists", "object.schema": "{{#label}} must be a Joi schema of {{#type}} type", "object.unknown": "{{#label}} is not allowed", "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}", "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}", "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}), h.clone = function(e3, t3) {
          if (typeof e3 == "object") {
            if (t3.nonEnumerables)
              return a(e3, {shallow: true});
            const r3 = Object.create(Object.getPrototypeOf(e3));
            return Object.assign(r3, e3), r3;
          }
          const r2 = function(...t4) {
            return e3.apply(this, t4);
          };
          return r2.prototype = a(e3.prototype), Object.defineProperty(r2, "name", {value: e3.name, writable: false}), Object.defineProperty(r2, "length", {value: e3.length, writable: false}), Object.assign(r2, e3), r2;
        }, h.dependency = function(e3, t3, r2, s2, a2) {
          n(r2 === null || typeof r2 == "string", t3, "key must be a strings"), a2 || (a2 = s2.length > 1 && typeof s2[s2.length - 1] == "object" ? s2.pop() : {}), l.assertOptions(a2, ["separator"]), s2 = [].concat(s2);
          const o2 = l.default(a2.separator, "."), i2 = [];
          for (const e4 of s2)
            n(typeof e4 == "string", t3, "peers must be strings"), i2.push(c.ref(e4, {separator: o2, ancestor: 0, prefix: false}));
          r2 !== null && (r2 = c.ref(r2, {separator: o2, ancestor: 0, prefix: false}));
          const u2 = e3.clone();
          return u2.$_terms.dependencies = u2.$_terms.dependencies || [], u2.$_terms.dependencies.push(new h.Dependency(t3, r2, i2, s2)), u2;
        }, h.dependencies = {and(e3, t3, r2, s2, n2) {
          const a2 = [], o2 = [], i2 = t3.peers.length;
          for (const e4 of t3.peers)
            e4.resolve(r2, s2, n2, null, {shadow: false}) === void 0 ? a2.push(e4.key) : o2.push(e4.key);
          if (a2.length !== i2 && o2.length !== i2)
            return {code: "object.and", context: {present: o2, presentWithLabels: h.keysToLabels(e3, o2), missing: a2, missingWithLabels: h.keysToLabels(e3, a2)}};
        }, nand(e3, t3, r2, s2, n2) {
          const a2 = [];
          for (const e4 of t3.peers)
            e4.resolve(r2, s2, n2, null, {shadow: false}) !== void 0 && a2.push(e4.key);
          if (a2.length !== t3.peers.length)
            return;
          const o2 = t3.paths[0], i2 = t3.paths.slice(1);
          return {code: "object.nand", context: {main: o2, mainWithLabel: h.keysToLabels(e3, o2), peers: i2, peersWithLabels: h.keysToLabels(e3, i2)}};
        }, or(e3, t3, r2, s2, n2) {
          for (const e4 of t3.peers)
            if (e4.resolve(r2, s2, n2, null, {shadow: false}) !== void 0)
              return;
          return {code: "object.missing", context: {peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths)}};
        }, oxor(e3, t3, r2, s2, n2) {
          const a2 = [];
          for (const e4 of t3.peers)
            e4.resolve(r2, s2, n2, null, {shadow: false}) !== void 0 && a2.push(e4.key);
          if (!a2.length || a2.length === 1)
            return;
          const o2 = {peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths)};
          return o2.present = a2, o2.presentWithLabels = h.keysToLabels(e3, a2), {code: "object.oxor", context: o2};
        }, with(e3, t3, r2, s2, n2) {
          for (const a2 of t3.peers)
            if (a2.resolve(r2, s2, n2, null, {shadow: false}) === void 0)
              return {code: "object.with", context: {main: t3.key.key, mainWithLabel: h.keysToLabels(e3, t3.key.key), peer: a2.key, peerWithLabel: h.keysToLabels(e3, a2.key)}};
        }, without(e3, t3, r2, s2, n2) {
          for (const a2 of t3.peers)
            if (a2.resolve(r2, s2, n2, null, {shadow: false}) !== void 0)
              return {code: "object.without", context: {main: t3.key.key, mainWithLabel: h.keysToLabels(e3, t3.key.key), peer: a2.key, peerWithLabel: h.keysToLabels(e3, a2.key)}};
        }, xor(e3, t3, r2, s2, n2) {
          const a2 = [];
          for (const e4 of t3.peers)
            e4.resolve(r2, s2, n2, null, {shadow: false}) !== void 0 && a2.push(e4.key);
          if (a2.length === 1)
            return;
          const o2 = {peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths)};
          return a2.length === 0 ? {code: "object.missing", context: o2} : (o2.present = a2, o2.presentWithLabels = h.keysToLabels(e3, a2), {code: "object.xor", context: o2});
        }}, h.keysToLabels = function(e3, t3) {
          return Array.isArray(t3) ? t3.map((t4) => e3.$_mapLabels(t4)) : e3.$_mapLabels(t3);
        }, h.rename = function(e3, t3, r2, s2, n2) {
          const a2 = {};
          for (const o2 of e3.$_terms.renames) {
            const i2 = [], l2 = typeof o2.from != "string";
            if (l2)
              for (const e4 in t3) {
                if (t3[e4] === void 0 && o2.options.ignoreUndefined)
                  continue;
                if (e4 === o2.to)
                  continue;
                const r3 = o2.from.exec(e4);
                r3 && i2.push({from: e4, to: o2.to, match: r3});
              }
            else
              !Object.prototype.hasOwnProperty.call(t3, o2.from) || t3[o2.from] === void 0 && o2.options.ignoreUndefined || i2.push(o2);
            for (const c2 of i2) {
              const i3 = c2.from;
              let u2 = c2.to;
              if (u2 instanceof m && (u2 = u2.render(t3, r2, s2, c2.match)), i3 !== u2) {
                if (!o2.options.multiple && a2[u2] && (n2.push(e3.$_createError("object.rename.multiple", t3, {from: i3, to: u2, pattern: l2}, r2, s2)), s2.abortEarly))
                  return false;
                if (Object.prototype.hasOwnProperty.call(t3, u2) && !o2.options.override && !a2[u2] && (n2.push(e3.$_createError("object.rename.override", t3, {from: i3, to: u2, pattern: l2}, r2, s2)), s2.abortEarly))
                  return false;
                t3[i3] === void 0 ? delete t3[u2] : t3[u2] = t3[i3], a2[u2] = true, o2.options.alias || delete t3[i3];
              }
            }
          }
          return true;
        }, h.unknown = function(e3, t3, r2, s2, n2, a2) {
          if (e3.$_terms.patterns) {
            let o2 = false;
            const i2 = e3.$_terms.patterns.map((e4) => {
              if (e4.matches)
                return o2 = true, [];
            }), l2 = [t3, ...n2.ancestors];
            for (const o3 of r2) {
              const c2 = t3[o3], u2 = [...n2.path, o3];
              for (let f2 = 0; f2 < e3.$_terms.patterns.length; ++f2) {
                const m2 = e3.$_terms.patterns[f2];
                if (m2.regex) {
                  const e4 = m2.regex.test(o3);
                  if (n2.mainstay.tracer.debug(n2, "rule", "pattern.".concat(f2), e4 ? "pass" : "error"), !e4)
                    continue;
                } else if (!m2.schema.$_match(o3, n2.nest(m2.schema, "pattern.".concat(f2)), a2))
                  continue;
                r2.delete(o3);
                const h2 = n2.localize(u2, l2, {schema: m2.rule, key: o3}), d = m2.rule.$_validate(c2, h2, a2);
                if (d.errors) {
                  if (a2.abortEarly)
                    return {value: t3, errors: d.errors};
                  s2.push(...d.errors);
                }
                if (m2.matches && i2[f2].push(o3), t3[o3] = d.value, !m2.fallthrough)
                  break;
              }
            }
            if (o2)
              for (let r3 = 0; r3 < i2.length; ++r3) {
                const o3 = i2[r3];
                if (!o3)
                  continue;
                const c2 = e3.$_terms.patterns[r3].matches, f2 = n2.localize(n2.path, l2, c2), m2 = c2.$_validate(o3, f2, a2);
                if (m2.errors) {
                  const r4 = u.details(m2.errors, {override: false});
                  r4.matches = o3;
                  const i3 = e3.$_createError("object.pattern.match", t3, r4, n2, a2);
                  if (a2.abortEarly)
                    return {value: t3, errors: i3};
                  s2.push(i3);
                }
              }
          }
          if (r2.size && (e3.$_terms.keys || e3.$_terms.patterns)) {
            if (a2.stripUnknown && !e3._flags.unknown || a2.skipFunctions) {
              const e4 = !(!a2.stripUnknown || a2.stripUnknown !== true && !a2.stripUnknown.objects);
              for (const s3 of r2)
                e4 ? (delete t3[s3], r2.delete(s3)) : typeof t3[s3] == "function" && r2.delete(s3);
            }
            if (!l.default(e3._flags.unknown, a2.allowUnknown))
              for (const o2 of r2) {
                const r3 = n2.localize([...n2.path, o2], []), i2 = e3.$_createError("object.unknown", t3[o2], {child: o2}, r3, a2, {flags: false});
                if (a2.abortEarly)
                  return {value: t3, errors: i2};
                s2.push(i2);
              }
          }
        }, h.Dependency = class {
          constructor(e3, t3, r2, s2) {
            this.rel = e3, this.key = t3, this.peers = r2, this.paths = s2;
          }
          describe() {
            const e3 = {rel: this.rel, peers: this.paths};
            return this.key !== null && (e3.key = this.key.key), this.peers[0].separator !== "." && (e3.options = {separator: this.peers[0].separator}), e3;
          }
        }, h.Keys = class extends Array {
          concat(e3) {
            const t3 = this.slice(), r2 = new Map();
            for (let e4 = 0; e4 < t3.length; ++e4)
              r2.set(t3[e4].key, e4);
            for (const s2 of e3) {
              const e4 = s2.key, n2 = r2.get(e4);
              n2 !== void 0 ? t3[n2] = {key: e4, schema: t3[n2].schema.concat(s2.schema)} : t3.push(s2);
            }
            return t3;
          }
        };
      }, 8785: (e2, t2, r) => {
        const s = r(375), n = r(8068), a = r(8160), o = r(3292), i = r(6354), l = {};
        e2.exports = n.extend({type: "link", properties: {schemaChain: true}, terms: {link: {init: null, manifest: "single", register: false}}, args: (e3, t3) => e3.ref(t3), validate(e3, {schema: t3, state: r2, prefs: n2}) {
          s(t3.$_terms.link, "Uninitialized link schema");
          const a2 = l.generate(t3, e3, r2, n2), o2 = t3.$_terms.link[0].ref;
          return a2.$_validate(e3, r2.nest(a2, "link:".concat(o2.display, ":").concat(a2.type)), n2);
        }, generate: (e3, t3, r2, s2) => l.generate(e3, t3, r2, s2), rules: {ref: {method(e3) {
          s(!this.$_terms.link, "Cannot reinitialize schema"), e3 = o.ref(e3), s(e3.type === "value" || e3.type === "local", "Invalid reference type:", e3.type), s(e3.type === "local" || e3.ancestor === "root" || e3.ancestor > 0, "Link cannot reference itself");
          const t3 = this.clone();
          return t3.$_terms.link = [{ref: e3}], t3;
        }}, relative: {method(e3 = true) {
          return this.$_setFlag("relative", e3);
        }}}, overrides: {concat(e3) {
          s(this.$_terms.link, "Uninitialized link schema"), s(a.isSchema(e3), "Invalid schema object"), s(e3.type !== "link", "Cannot merge type link with another link");
          const t3 = this.clone();
          return t3.$_terms.whens || (t3.$_terms.whens = []), t3.$_terms.whens.push({concat: e3}), t3.$_mutateRebuild();
        }}, manifest: {build: (e3, t3) => (s(t3.link, "Invalid link description missing link"), e3.ref(t3.link))}}), l.generate = function(e3, t3, r2, s2) {
          let n2 = r2.mainstay.links.get(e3);
          if (n2)
            return n2._generate(t3, r2, s2).schema;
          const a2 = e3.$_terms.link[0].ref, {perspective: o2, path: i2} = l.perspective(a2, r2);
          l.assert(o2, "which is outside of schema boundaries", a2, e3, r2, s2);
          try {
            n2 = i2.length ? o2.$_reach(i2) : o2;
          } catch (t4) {
            l.assert(false, "to non-existing schema", a2, e3, r2, s2);
          }
          return l.assert(n2.type !== "link", "which is another link", a2, e3, r2, s2), e3._flags.relative || r2.mainstay.links.set(e3, n2), n2._generate(t3, r2, s2).schema;
        }, l.perspective = function(e3, t3) {
          if (e3.type === "local") {
            for (const {schema: r2, key: s2} of t3.schemas) {
              if ((r2._flags.id || s2) === e3.path[0])
                return {perspective: r2, path: e3.path.slice(1)};
              if (r2.$_terms.shared) {
                for (const t4 of r2.$_terms.shared)
                  if (t4._flags.id === e3.path[0])
                    return {perspective: t4, path: e3.path.slice(1)};
              }
            }
            return {perspective: null, path: null};
          }
          return e3.ancestor === "root" ? {perspective: t3.schemas[t3.schemas.length - 1].schema, path: e3.path} : {perspective: t3.schemas[e3.ancestor] && t3.schemas[e3.ancestor].schema, path: e3.path};
        }, l.assert = function(e3, t3, r2, n2, a2, o2) {
          e3 || s(false, '"'.concat(i.label(n2._flags, a2, o2), '" contains link reference "').concat(r2.display, '" ').concat(t3));
        };
      }, 3832: (e2, t2, r) => {
        const s = r(375), n = r(8068), a = r(8160), o = {numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i, precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/};
        e2.exports = n.extend({type: "number", flags: {unsafe: {default: false}}, coerce: {from: "string", method(e3, {schema: t3, error: r2}) {
          const s2 = e3.match(o.numberRx);
          if (!s2)
            return;
          e3 = e3.trim();
          const n2 = {value: parseFloat(e3)};
          if (n2.value === 0 && (n2.value = 0), !t3._flags.unsafe)
            if (e3.match(/e/i)) {
              if (o.normalizeExponent("".concat(n2.value / Math.pow(10, s2[1]), "e").concat(s2[1])) !== o.normalizeExponent(e3))
                return n2.errors = r2("number.unsafe"), n2;
            } else {
              const t4 = n2.value.toString();
              if (t4.match(/e/i))
                return n2;
              if (t4 !== o.normalizeDecimal(e3))
                return n2.errors = r2("number.unsafe"), n2;
            }
          return n2;
        }}, validate(e3, {schema: t3, error: r2, prefs: s2}) {
          if (e3 === 1 / 0 || e3 === -1 / 0)
            return {value: e3, errors: r2("number.infinity")};
          if (!a.isNumber(e3))
            return {value: e3, errors: r2("number.base")};
          const n2 = {value: e3};
          if (s2.convert) {
            const e4 = t3.$_getRule("precision");
            if (e4) {
              const t4 = Math.pow(10, e4.args.limit);
              n2.value = Math.round(n2.value * t4) / t4;
            }
          }
          return n2.value === 0 && (n2.value = 0), !t3._flags.unsafe && (e3 > Number.MAX_SAFE_INTEGER || e3 < Number.MIN_SAFE_INTEGER) && (n2.errors = r2("number.unsafe")), n2;
        }, rules: {compare: {method: false, validate: (e3, t3, {limit: r2}, {name: s2, operator: n2, args: o2}) => a.compare(e3, r2, n2) ? e3 : t3.error("number." + s2, {limit: o2.limit, value: e3}), args: [{name: "limit", ref: true, assert: a.isNumber, message: "must be a number"}]}, greater: {method(e3) {
          return this.$_addRule({name: "greater", method: "compare", args: {limit: e3}, operator: ">"});
        }}, integer: {method() {
          return this.$_addRule("integer");
        }, validate: (e3, t3) => Math.trunc(e3) - e3 == 0 ? e3 : t3.error("number.integer")}, less: {method(e3) {
          return this.$_addRule({name: "less", method: "compare", args: {limit: e3}, operator: "<"});
        }}, max: {method(e3) {
          return this.$_addRule({name: "max", method: "compare", args: {limit: e3}, operator: "<="});
        }}, min: {method(e3) {
          return this.$_addRule({name: "min", method: "compare", args: {limit: e3}, operator: ">="});
        }}, multiple: {method(e3) {
          return this.$_addRule({name: "multiple", args: {base: e3}});
        }, validate: (e3, t3, {base: r2}, s2) => e3 % r2 == 0 ? e3 : t3.error("number.multiple", {multiple: s2.args.base, value: e3}), args: [{name: "base", ref: true, assert: (e3) => typeof e3 == "number" && isFinite(e3) && e3 > 0, message: "must be a positive number"}], multi: true}, negative: {method() {
          return this.sign("negative");
        }}, port: {method() {
          return this.$_addRule("port");
        }, validate: (e3, t3) => Number.isSafeInteger(e3) && e3 >= 0 && e3 <= 65535 ? e3 : t3.error("number.port")}, positive: {method() {
          return this.sign("positive");
        }}, precision: {method(e3) {
          return s(Number.isSafeInteger(e3), "limit must be an integer"), this.$_addRule({name: "precision", args: {limit: e3}});
        }, validate(e3, t3, {limit: r2}) {
          const s2 = e3.toString().match(o.precisionRx);
          return Math.max((s2[1] ? s2[1].length : 0) - (s2[2] ? parseInt(s2[2], 10) : 0), 0) <= r2 ? e3 : t3.error("number.precision", {limit: r2, value: e3});
        }, convert: true}, sign: {method(e3) {
          return s(["negative", "positive"].includes(e3), "Invalid sign", e3), this.$_addRule({name: "sign", args: {sign: e3}});
        }, validate: (e3, t3, {sign: r2}) => r2 === "negative" && e3 < 0 || r2 === "positive" && e3 > 0 ? e3 : t3.error("number.".concat(r2))}, unsafe: {method(e3 = true) {
          return s(typeof e3 == "boolean", "enabled must be a boolean"), this.$_setFlag("unsafe", e3);
        }}}, cast: {string: {from: (e3) => typeof e3 == "number", to: (e3, t3) => e3.toString()}}, messages: {"number.base": "{{#label}} must be a number", "number.greater": "{{#label}} must be greater than {{#limit}}", "number.infinity": "{{#label}} cannot be infinity", "number.integer": "{{#label}} must be an integer", "number.less": "{{#label}} must be less than {{#limit}}", "number.max": "{{#label}} must be less than or equal to {{#limit}}", "number.min": "{{#label}} must be greater than or equal to {{#limit}}", "number.multiple": "{{#label}} must be a multiple of {{#multiple}}", "number.negative": "{{#label}} must be a negative number", "number.port": "{{#label}} must be a valid port", "number.positive": "{{#label}} must be a positive number", "number.precision": "{{#label}} must have no more than {{#limit}} decimal places", "number.unsafe": "{{#label}} must be a safe number"}}), o.normalizeExponent = function(e3) {
          return e3.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
        }, o.normalizeDecimal = function(e3) {
          return (e3 = e3.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && e3.endsWith("0") && (e3 = e3.replace(/0+$/, "")), e3 === "-0" ? "0" : e3;
        };
      }, 8966: (e2, t2, r) => {
        const s = r(7824);
        e2.exports = s.extend({type: "object", cast: {map: {from: (e3) => e3 && typeof e3 == "object", to: (e3, t3) => new Map(Object.entries(e3))}}});
      }, 7417: (e2, t2, r) => {
        function s(e3, t3) {
          var r2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var s2 = Object.getOwnPropertySymbols(e3);
            t3 && (s2 = s2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r2.push.apply(r2, s2);
          }
          return r2;
        }
        function n(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3] != null ? arguments[t3] : {};
            t3 % 2 ? s(Object(r2), true).forEach(function(t4) {
              a(e3, t4, r2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : s(Object(r2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
            });
          }
          return e3;
        }
        function a(e3, t3, r2) {
          return t3 in e3 ? Object.defineProperty(e3, t3, {value: r2, enumerable: true, configurable: true, writable: true}) : e3[t3] = r2, e3;
        }
        const o = r(375), i = r(5380), l = r(1745), c = r(9959), u = r(6064), f = r(9926), m = r(5752), h = r(8068), d = r(8160), p = {tlds: f instanceof Set && {tlds: {allow: f, deny: null}}, base64Regex: {true: {true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/}, false: {true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}}, dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/, hexRegex: /^[a-f0-9]+$/i, ipRegex: c.regex().regex, isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/, guidBrackets: {"{": "}", "[": "]", "(": ")", "": ""}, guidVersions: {uuidv1: "1", uuidv2: "2", uuidv3: "3", uuidv4: "4", uuidv5: "5"}, guidSeparators: new Set([void 0, true, false, "-", ":"]), normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]};
        e2.exports = h.extend({type: "string", flags: {insensitive: {default: false}, truncate: {default: false}}, terms: {replacements: {init: null}}, coerce: {from: "string", method(e3, {schema: t3, state: r2, prefs: s2}) {
          const n2 = t3.$_getRule("normalize");
          n2 && (e3 = e3.normalize(n2.args.form));
          const a2 = t3.$_getRule("case");
          a2 && (e3 = a2.args.direction === "upper" ? e3.toLocaleUpperCase() : e3.toLocaleLowerCase());
          const o2 = t3.$_getRule("trim");
          if (o2 && o2.args.enabled && (e3 = e3.trim()), t3.$_terms.replacements)
            for (const r3 of t3.$_terms.replacements)
              e3 = e3.replace(r3.pattern, r3.replacement);
          const i2 = t3.$_getRule("hex");
          if (i2 && i2.args.options.byteAligned && e3.length % 2 != 0 && (e3 = "0".concat(e3)), t3.$_getRule("isoDate")) {
            const t4 = p.isoDate(e3);
            t4 && (e3 = t4);
          }
          if (t3._flags.truncate) {
            const n3 = t3.$_getRule("max");
            if (n3) {
              let a3 = n3.args.limit;
              if (d.isResolvable(a3) && (a3 = a3.resolve(e3, r2, s2), !d.limit(a3)))
                return {value: e3, errors: t3.$_createError("any.ref", a3, {ref: n3.args.limit, arg: "limit", reason: "must be a positive integer"}, r2, s2)};
              e3 = e3.slice(0, a3);
            }
          }
          return {value: e3};
        }}, validate: (e3, {error: t3}) => typeof e3 != "string" ? {value: e3, errors: t3("string.base")} : e3 === "" ? {value: e3, errors: t3("string.empty")} : void 0, rules: {alphanum: {method() {
          return this.$_addRule("alphanum");
        }, validate: (e3, t3) => /^[a-zA-Z0-9]+$/.test(e3) ? e3 : t3.error("string.alphanum")}, base64: {method(e3 = {}) {
          return d.assertOptions(e3, ["paddingRequired", "urlSafe"]), e3 = n({urlSafe: false, paddingRequired: true}, e3), o(typeof e3.paddingRequired == "boolean", "paddingRequired must be boolean"), o(typeof e3.urlSafe == "boolean", "urlSafe must be boolean"), this.$_addRule({name: "base64", args: {options: e3}});
        }, validate: (e3, t3, {options: r2}) => p.base64Regex[r2.paddingRequired][r2.urlSafe].test(e3) ? e3 : t3.error("string.base64")}, case: {method(e3) {
          return o(["lower", "upper"].includes(e3), "Invalid case:", e3), this.$_addRule({name: "case", args: {direction: e3}});
        }, validate: (e3, t3, {direction: r2}) => r2 === "lower" && e3 === e3.toLocaleLowerCase() || r2 === "upper" && e3 === e3.toLocaleUpperCase() ? e3 : t3.error("string.".concat(r2, "case")), convert: true}, creditCard: {method() {
          return this.$_addRule("creditCard");
        }, validate(e3, t3) {
          let r2 = e3.length, s2 = 0, n2 = 1;
          for (; r2--; ) {
            const t4 = e3.charAt(r2) * n2;
            s2 += t4 - 9 * (t4 > 9), n2 ^= 3;
          }
          return s2 > 0 && s2 % 10 == 0 ? e3 : t3.error("string.creditCard");
        }}, dataUri: {method(e3 = {}) {
          return d.assertOptions(e3, ["paddingRequired"]), e3 = n({paddingRequired: true}, e3), o(typeof e3.paddingRequired == "boolean", "paddingRequired must be boolean"), this.$_addRule({name: "dataUri", args: {options: e3}});
        }, validate(e3, t3, {options: r2}) {
          const s2 = e3.match(p.dataUriRegex);
          if (s2) {
            if (!s2[2])
              return e3;
            if (s2[2] !== "base64")
              return e3;
            if (p.base64Regex[r2.paddingRequired].false.test(s2[3]))
              return e3;
          }
          return t3.error("string.dataUri");
        }}, domain: {method(e3) {
          e3 && d.assertOptions(e3, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          const t3 = p.addressOptions(e3);
          return this.$_addRule({name: "domain", args: {options: e3}, address: t3});
        }, validate: (e3, t3, r2, {address: s2}) => i.isValid(e3, s2) ? e3 : t3.error("string.domain")}, email: {method(e3 = {}) {
          d.assertOptions(e3, ["allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), o(e3.multiple === void 0 || typeof e3.multiple == "boolean", "multiple option must be an boolean");
          const t3 = p.addressOptions(e3), r2 = new RegExp("\\s*[".concat(e3.separator ? u(e3.separator) : ",", "]\\s*"));
          return this.$_addRule({name: "email", args: {options: e3}, regex: r2, address: t3});
        }, validate(e3, t3, {options: r2}, {regex: s2, address: n2}) {
          const a2 = r2.multiple ? e3.split(s2) : [e3], o2 = [];
          for (const e4 of a2)
            l.isValid(e4, n2) || o2.push(e4);
          return o2.length ? t3.error("string.email", {value: e3, invalids: o2}) : e3;
        }}, guid: {alias: "uuid", method(e3 = {}) {
          d.assertOptions(e3, ["version", "separator"]);
          let t3 = "";
          if (e3.version) {
            const r3 = [].concat(e3.version);
            o(r3.length >= 1, "version must have at least 1 valid version specified");
            const s3 = new Set();
            for (let e4 = 0; e4 < r3.length; ++e4) {
              const n2 = r3[e4];
              o(typeof n2 == "string", "version at position " + e4 + " must be a string");
              const a2 = p.guidVersions[n2.toLowerCase()];
              o(a2, "version at position " + e4 + " must be one of " + Object.keys(p.guidVersions).join(", ")), o(!s3.has(a2), "version at position " + e4 + " must not be a duplicate"), t3 += a2, s3.add(a2);
            }
          }
          o(p.guidSeparators.has(e3.separator), 'separator must be one of true, false, "-", or ":"');
          const r2 = e3.separator === void 0 ? "[:-]?" : e3.separator === true ? "[:-]" : e3.separator === false ? "[]?" : "\\".concat(e3.separator), s2 = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}(".concat(r2, ")[0-9A-F]{4}\\2?[").concat(t3 || "0-9A-F", "][0-9A-F]{3}\\2?[").concat(t3 ? "89AB" : "0-9A-F", "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"), "i");
          return this.$_addRule({name: "guid", args: {options: e3}, regex: s2});
        }, validate(e3, t3, r2, {regex: s2}) {
          const n2 = s2.exec(e3);
          return n2 ? p.guidBrackets[n2[1]] !== n2[n2.length - 1] ? t3.error("string.guid") : e3 : t3.error("string.guid");
        }}, hex: {method(e3 = {}) {
          return d.assertOptions(e3, ["byteAligned"]), e3 = n({byteAligned: false}, e3), o(typeof e3.byteAligned == "boolean", "byteAligned must be boolean"), this.$_addRule({name: "hex", args: {options: e3}});
        }, validate: (e3, t3, {options: r2}) => p.hexRegex.test(e3) ? r2.byteAligned && e3.length % 2 != 0 ? t3.error("string.hexAlign") : e3 : t3.error("string.hex")}, hostname: {method() {
          return this.$_addRule("hostname");
        }, validate: (e3, t3) => i.isValid(e3, {minDomainSegments: 1}) || p.ipRegex.test(e3) ? e3 : t3.error("string.hostname")}, insensitive: {method() {
          return this.$_setFlag("insensitive", true);
        }}, ip: {method(e3 = {}) {
          d.assertOptions(e3, ["cidr", "version"]);
          const {cidr: t3, versions: r2, regex: s2} = c.regex(e3), n2 = e3.version ? r2 : void 0;
          return this.$_addRule({name: "ip", args: {options: {cidr: t3, version: n2}}, regex: s2});
        }, validate: (e3, t3, {options: r2}, {regex: s2}) => s2.test(e3) ? e3 : r2.version ? t3.error("string.ipVersion", {value: e3, cidr: r2.cidr, version: r2.version}) : t3.error("string.ip", {value: e3, cidr: r2.cidr})}, isoDate: {method() {
          return this.$_addRule("isoDate");
        }, validate: (e3, {error: t3}) => p.isoDate(e3) ? e3 : t3("string.isoDate")}, isoDuration: {method() {
          return this.$_addRule("isoDuration");
        }, validate: (e3, t3) => p.isoDurationRegex.test(e3) ? e3 : t3.error("string.isoDuration")}, length: {method(e3, t3) {
          return p.length(this, "length", e3, "=", t3);
        }, validate(e3, t3, {limit: r2, encoding: s2}, {name: n2, operator: a2, args: o2}) {
          const i2 = !s2 && e3.length;
          return d.compare(i2, r2, a2) ? e3 : t3.error("string." + n2, {limit: o2.limit, value: e3, encoding: s2});
        }, args: [{name: "limit", ref: true, assert: d.limit, message: "must be a positive integer"}, "encoding"]}, lowercase: {method() {
          return this.case("lower");
        }}, max: {method(e3, t3) {
          return p.length(this, "max", e3, "<=", t3);
        }, args: ["limit", "encoding"]}, min: {method(e3, t3) {
          return p.length(this, "min", e3, ">=", t3);
        }, args: ["limit", "encoding"]}, normalize: {method(e3 = "NFC") {
          return o(p.normalizationForms.includes(e3), "normalization form must be one of " + p.normalizationForms.join(", ")), this.$_addRule({name: "normalize", args: {form: e3}});
        }, validate: (e3, {error: t3}, {form: r2}) => e3 === e3.normalize(r2) ? e3 : t3("string.normalize", {value: e3, form: r2}), convert: true}, pattern: {alias: "regex", method(e3, t3 = {}) {
          o(e3 instanceof RegExp, "regex must be a RegExp"), o(!e3.flags.includes("g") && !e3.flags.includes("y"), "regex should not use global or sticky mode"), typeof t3 == "string" && (t3 = {name: t3}), d.assertOptions(t3, ["invert", "name"]);
          const r2 = ["string.pattern", t3.invert ? ".invert" : "", t3.name ? ".name" : ".base"].join("");
          return this.$_addRule({name: "pattern", args: {regex: e3, options: t3}, errorCode: r2});
        }, validate: (e3, t3, {regex: r2, options: s2}, {errorCode: n2}) => r2.test(e3) ^ s2.invert ? e3 : t3.error(n2, {name: s2.name, regex: r2, value: e3}), args: ["regex", "options"], multi: true}, replace: {method(e3, t3) {
          typeof e3 == "string" && (e3 = new RegExp(u(e3), "g")), o(e3 instanceof RegExp, "pattern must be a RegExp"), o(typeof t3 == "string", "replacement must be a String");
          const r2 = this.clone();
          return r2.$_terms.replacements || (r2.$_terms.replacements = []), r2.$_terms.replacements.push({pattern: e3, replacement: t3}), r2;
        }}, token: {method() {
          return this.$_addRule("token");
        }, validate: (e3, t3) => /^\w+$/.test(e3) ? e3 : t3.error("string.token")}, trim: {method(e3 = true) {
          return o(typeof e3 == "boolean", "enabled must be a boolean"), this.$_addRule({name: "trim", args: {enabled: e3}});
        }, validate: (e3, t3, {enabled: r2}) => r2 && e3 !== e3.trim() ? t3.error("string.trim") : e3, convert: true}, truncate: {method(e3 = true) {
          return o(typeof e3 == "boolean", "enabled must be a boolean"), this.$_setFlag("truncate", e3);
        }}, uppercase: {method() {
          return this.case("upper");
        }}, uri: {method(e3 = {}) {
          d.assertOptions(e3, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]), e3.domain && d.assertOptions(e3.domain, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          const {regex: t3, scheme: r2} = m.regex(e3), s2 = e3.domain ? p.addressOptions(e3.domain) : null;
          return this.$_addRule({name: "uri", args: {options: e3}, regex: t3, domain: s2, scheme: r2});
        }, validate(e3, t3, {options: r2}, {regex: s2, domain: n2, scheme: a2}) {
          if (["http:/", "https:/"].includes(e3))
            return t3.error("string.uri");
          const o2 = s2.exec(e3);
          if (o2) {
            const s3 = o2[1] || o2[2];
            return !n2 || r2.allowRelative && !s3 || i.isValid(s3, n2) ? e3 : t3.error("string.domain", {value: s3});
          }
          return r2.relativeOnly ? t3.error("string.uriRelativeOnly") : r2.scheme ? t3.error("string.uriCustomScheme", {scheme: a2, value: e3}) : t3.error("string.uri");
        }}}, manifest: {build(e3, t3) {
          if (t3.replacements)
            for (const {pattern: r2, replacement: s2} of t3.replacements)
              e3 = e3.replace(r2, s2);
          return e3;
        }}, messages: {"string.alphanum": "{{#label}} must only contain alpha-numeric characters", "string.base": "{{#label}} must be a string", "string.base64": "{{#label}} must be a valid base64 string", "string.creditCard": "{{#label}} must be a credit card", "string.dataUri": "{{#label}} must be a valid dataUri string", "string.domain": "{{#label}} must contain a valid domain name", "string.email": "{{#label}} must be a valid email", "string.empty": "{{#label}} is not allowed to be empty", "string.guid": "{{#label}} must be a valid GUID", "string.hex": "{{#label}} must only contain hexadecimal characters", "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned", "string.hostname": "{{#label}} must be a valid hostname", "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR", "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR", "string.isoDate": "{{#label}} must be in iso format", "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration", "string.length": "{{#label}} length must be {{#limit}} characters long", "string.lowercase": "{{#label}} must only contain lowercase characters", "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long", "string.min": "{{#label}} length must be at least {{#limit}} characters long", "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form", "string.token": "{{#label}} must only contain alpha-numeric and underscore characters", "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}", "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern", "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}", "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern", "string.trim": "{{#label}} must not have leading or trailing whitespace", "string.uri": "{{#label}} must be a valid uri", "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern", "string.uriRelativeOnly": "{{#label}} must be a valid relative uri", "string.uppercase": "{{#label}} must only contain uppercase characters"}}), p.addressOptions = function(e3) {
          if (!e3)
            return e3;
          if (o(e3.minDomainSegments === void 0 || Number.isSafeInteger(e3.minDomainSegments) && e3.minDomainSegments > 0, "minDomainSegments must be a positive integer"), o(e3.maxDomainSegments === void 0 || Number.isSafeInteger(e3.maxDomainSegments) && e3.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"), e3.tlds === false)
            return e3;
          if (e3.tlds === true || e3.tlds === void 0)
            return o(p.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, p.tlds);
          o(typeof e3.tlds == "object", "tlds must be true, false, or an object");
          const t3 = e3.tlds.deny;
          if (t3)
            return Array.isArray(t3) && (e3 = Object.assign({}, e3, {tlds: {deny: new Set(t3)}})), o(e3.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), o(!e3.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), p.validateTlds(e3.tlds.deny, "tlds.deny"), e3;
          const r2 = e3.tlds.allow;
          return r2 ? r2 === true ? (o(p.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, p.tlds)) : (Array.isArray(r2) && (e3 = Object.assign({}, e3, {tlds: {allow: new Set(r2)}})), o(e3.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), p.validateTlds(e3.tlds.allow, "tlds.allow"), e3) : e3;
        }, p.validateTlds = function(e3, t3) {
          for (const r2 of e3)
            o(i.isValid(r2, {minDomainSegments: 1, maxDomainSegments: 1}), "".concat(t3, " must contain valid top level domain names"));
        }, p.isoDate = function(e3) {
          if (!d.isIsoDate(e3))
            return null;
          /.*T.*[+-]\d\d$/.test(e3) && (e3 += "00");
          const t3 = new Date(e3);
          return isNaN(t3.getTime()) ? null : t3.toISOString();
        }, p.length = function(e3, t3, r2, s2, n2) {
          return o(!n2 || false, "Invalid encoding:", n2), e3.$_addRule({name: t3, method: "length", args: {limit: r2, encoding: n2}, operator: s2});
        };
      }, 8826: (e2, t2, r) => {
        const s = r(375), n = r(8068), a = {};
        a.Map = class extends Map {
          slice() {
            return new a.Map(this);
          }
        }, e2.exports = n.extend({type: "symbol", terms: {map: {init: new a.Map()}}, coerce: {method(e3, {schema: t3, error: r2}) {
          const s2 = t3.$_terms.map.get(e3);
          return s2 && (e3 = s2), t3._flags.only && typeof e3 != "symbol" ? {value: e3, errors: r2("symbol.map", {map: t3.$_terms.map})} : {value: e3};
        }}, validate(e3, {error: t3}) {
          if (typeof e3 != "symbol")
            return {value: e3, errors: t3("symbol.base")};
        }, rules: {map: {method(e3) {
          e3 && !e3[Symbol.iterator] && typeof e3 == "object" && (e3 = Object.entries(e3)), s(e3 && e3[Symbol.iterator], "Iterable must be an iterable or object");
          const t3 = this.clone(), r2 = [];
          for (const n2 of e3) {
            s(n2 && n2[Symbol.iterator], "Entry must be an iterable");
            const [e4, a2] = n2;
            s(typeof e4 != "object" && typeof e4 != "function" && typeof e4 != "symbol", "Key must not be of type object, function, or Symbol"), s(typeof a2 == "symbol", "Value must be a Symbol"), t3.$_terms.map.set(e4, a2), r2.push(a2);
          }
          return t3.valid(...r2);
        }}}, manifest: {build: (e3, t3) => (t3.map && (e3 = e3.map(t3.map)), e3)}, messages: {"symbol.base": "{{#label}} must be a symbol", "symbol.map": "{{#label}} must be one of {{#map}}"}});
      }, 8863: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(738), o = r(9621), i = r(8160), l = r(6354), c = r(493), u = {result: Symbol("result")};
        t2.entry = function(e3, t3, r2) {
          let n2 = i.defaults;
          r2 && (s(r2.warnings === void 0, "Cannot override warnings preference in synchronous validation"), s(r2.artifacts === void 0, "Cannot override artifacts preference in synchronous validation"), n2 = i.preferences(i.defaults, r2));
          const a2 = u.entry(e3, t3, n2);
          s(!a2.mainstay.externals.length, "Schema with external rules must use validateAsync()");
          const o2 = {value: a2.value};
          return a2.error && (o2.error = a2.error), a2.mainstay.warnings.length && (o2.warning = l.details(a2.mainstay.warnings)), a2.mainstay.debug && (o2.debug = a2.mainstay.debug), a2.mainstay.artifacts && (o2.artifacts = a2.mainstay.artifacts), o2;
        }, t2.entryAsync = function(e3, t3, r2) {
          return __async(this, null, function* () {
            let s2 = i.defaults;
            r2 && (s2 = i.preferences(i.defaults, r2));
            const n2 = u.entry(e3, t3, s2), a2 = n2.mainstay;
            if (n2.error)
              throw a2.debug && (n2.error.debug = a2.debug), n2.error;
            if (a2.externals.length) {
              let e4 = n2.value;
              for (const {method: t4, path: s3, label: n3} of a2.externals) {
                let a3, i2, l2 = e4;
                s3.length && (a3 = s3[s3.length - 1], i2 = o(e4, s3.slice(0, -1)), l2 = i2[a3]);
                try {
                  const s4 = yield t4(l2, {prefs: r2});
                  if (s4 === void 0 || s4 === l2)
                    continue;
                  i2 ? i2[a3] = s4 : e4 = s4;
                } catch (e5) {
                  throw e5.message += " (".concat(n3, ")"), e5;
                }
              }
              n2.value = e4;
            }
            if (!s2.warnings && !s2.debug && !s2.artifacts)
              return n2.value;
            const c2 = {value: n2.value};
            return a2.warnings.length && (c2.warning = l.details(a2.warnings)), a2.debug && (c2.debug = a2.debug), a2.artifacts && (c2.artifacts = a2.artifacts), c2;
          });
        }, u.entry = function(e3, r2, s2) {
          const {tracer: n2, cleanup: a2} = u.tracer(r2, s2), o2 = {externals: [], warnings: [], tracer: n2, debug: s2.debug ? [] : null, links: r2._ids._schemaChain ? new Map() : null}, i2 = r2._ids._schemaChain ? [{schema: r2}] : null, f = new c([], [], {mainstay: o2, schemas: i2}), m = t2.validate(e3, r2, f, s2);
          a2 && r2.$_root.untrace();
          const h = l.process(m.errors, e3, s2);
          return {value: m.value, error: h, mainstay: o2};
        }, u.tracer = function(e3, t3) {
          return e3.$_root._tracer ? {tracer: e3.$_root._tracer._register(e3)} : t3.debug ? (s(e3.$_root.trace, "Debug mode not supported"), {tracer: e3.$_root.trace()._register(e3), cleanup: true}) : {tracer: u.ignore};
        }, t2.validate = function(e3, t3, r2, s2, n2 = {}) {
          if (t3.$_terms.whens && (t3 = t3._generate(e3, r2, s2).schema), t3._preferences && (s2 = u.prefs(t3, s2)), t3._cache && s2.cache) {
            const s3 = t3._cache.get(e3);
            if (r2.mainstay.tracer.debug(r2, "validate", "cached", !!s3), s3)
              return s3;
          }
          const a2 = (n3, a3, o3) => t3.$_createError(n3, e3, a3, o3 || r2, s2), o2 = {original: e3, prefs: s2, schema: t3, state: r2, error: a2, errorsArray: u.errorsArray, warn: (e4, t4, s3) => r2.mainstay.warnings.push(a2(e4, t4, s3)), message: (n3, a3) => t3.$_createError("custom", e3, a3, r2, s2, {messages: n3})};
          r2.mainstay.tracer.entry(t3, r2);
          const l2 = t3._definition;
          if (l2.prepare && e3 !== void 0 && s2.convert) {
            const t4 = l2.prepare(e3, o2);
            if (t4) {
              if (r2.mainstay.tracer.value(r2, "prepare", e3, t4.value), t4.errors)
                return u.finalize(t4.value, [].concat(t4.errors), o2);
              e3 = t4.value;
            }
          }
          if (l2.coerce && e3 !== void 0 && s2.convert && (!l2.coerce.from || l2.coerce.from.includes(typeof e3))) {
            const t4 = l2.coerce.method(e3, o2);
            if (t4) {
              if (r2.mainstay.tracer.value(r2, "coerced", e3, t4.value), t4.errors)
                return u.finalize(t4.value, [].concat(t4.errors), o2);
              e3 = t4.value;
            }
          }
          const c2 = t3._flags.empty;
          c2 && c2.$_match(u.trim(e3, t3), r2.nest(c2), i.defaults) && (r2.mainstay.tracer.value(r2, "empty", e3, void 0), e3 = void 0);
          const f = n2.presence || t3._flags.presence || (t3._flags._endedSwitch ? null : s2.presence);
          if (e3 === void 0) {
            if (f === "forbidden")
              return u.finalize(e3, null, o2);
            if (f === "required")
              return u.finalize(e3, [t3.$_createError("any.required", e3, null, r2, s2)], o2);
            if (f === "optional") {
              if (t3._flags.default !== i.symbols.deepDefault)
                return u.finalize(e3, null, o2);
              r2.mainstay.tracer.value(r2, "default", e3, {}), e3 = {};
            }
          } else if (f === "forbidden")
            return u.finalize(e3, [t3.$_createError("any.unknown", e3, null, r2, s2)], o2);
          const m = [];
          if (t3._valids) {
            const n3 = t3._valids.get(e3, r2, s2, t3._flags.insensitive);
            if (n3)
              return s2.convert && (r2.mainstay.tracer.value(r2, "valids", e3, n3.value), e3 = n3.value), r2.mainstay.tracer.filter(t3, r2, "valid", n3), u.finalize(e3, null, o2);
            if (t3._flags.only) {
              const n4 = t3.$_createError("any.only", e3, {valids: t3._valids.values({display: true})}, r2, s2);
              if (s2.abortEarly)
                return u.finalize(e3, [n4], o2);
              m.push(n4);
            }
          }
          if (t3._invalids) {
            const n3 = t3._invalids.get(e3, r2, s2, t3._flags.insensitive);
            if (n3) {
              r2.mainstay.tracer.filter(t3, r2, "invalid", n3);
              const a3 = t3.$_createError("any.invalid", e3, {invalids: t3._invalids.values({display: true})}, r2, s2);
              if (s2.abortEarly)
                return u.finalize(e3, [a3], o2);
              m.push(a3);
            }
          }
          if (l2.validate) {
            const t4 = l2.validate(e3, o2);
            if (t4 && (r2.mainstay.tracer.value(r2, "base", e3, t4.value), e3 = t4.value, t4.errors)) {
              if (!Array.isArray(t4.errors))
                return m.push(t4.errors), u.finalize(e3, m, o2);
              if (t4.errors.length)
                return m.push(...t4.errors), u.finalize(e3, m, o2);
            }
          }
          return t3._rules.length ? u.rules(e3, m, o2) : u.finalize(e3, m, o2);
        }, u.rules = function(e3, t3, r2) {
          const {schema: s2, state: n2, prefs: a2} = r2;
          for (const o2 of s2._rules) {
            const l2 = s2._definition.rules[o2.method];
            if (l2.convert && a2.convert) {
              n2.mainstay.tracer.log(s2, n2, "rule", o2.name, "full");
              continue;
            }
            let c2, f = o2.args;
            if (o2._resolve.length) {
              f = Object.assign({}, f);
              for (const t4 of o2._resolve) {
                const r3 = l2.argsByName.get(t4), o3 = f[t4].resolve(e3, n2, a2), u2 = r3.normalize ? r3.normalize(o3) : o3, m2 = i.validateArg(u2, null, r3);
                if (m2) {
                  c2 = s2.$_createError("any.ref", o3, {arg: t4, ref: f[t4], reason: m2}, n2, a2);
                  break;
                }
                f[t4] = u2;
              }
            }
            c2 = c2 || l2.validate(e3, r2, f, o2);
            const m = u.rule(c2, o2);
            if (m.errors) {
              if (n2.mainstay.tracer.log(s2, n2, "rule", o2.name, "error"), o2.warn) {
                n2.mainstay.warnings.push(...m.errors);
                continue;
              }
              if (a2.abortEarly)
                return u.finalize(e3, m.errors, r2);
              t3.push(...m.errors);
            } else
              n2.mainstay.tracer.log(s2, n2, "rule", o2.name, "pass"), n2.mainstay.tracer.value(n2, "rule", e3, m.value, o2.name), e3 = m.value;
          }
          return u.finalize(e3, t3, r2);
        }, u.rule = function(e3, t3) {
          return e3 instanceof l.Report ? (u.error(e3, t3), {errors: [e3], value: null}) : Array.isArray(e3) && e3[i.symbols.errors] ? (e3.forEach((e4) => u.error(e4, t3)), {errors: e3, value: null}) : {errors: null, value: e3};
        }, u.error = function(e3, t3) {
          return t3.message && e3._setTemplate(t3.message), e3;
        }, u.finalize = function(e3, t3, r2) {
          t3 = t3 || [];
          const {schema: n2, state: a2, prefs: o2} = r2;
          if (t3.length) {
            const s2 = u.default("failover", void 0, t3, r2);
            s2 !== void 0 && (a2.mainstay.tracer.value(a2, "failover", e3, s2), e3 = s2, t3 = []);
          }
          if (t3.length && n2._flags.error)
            if (typeof n2._flags.error == "function") {
              t3 = n2._flags.error(t3), Array.isArray(t3) || (t3 = [t3]);
              for (const e4 of t3)
                s(e4 instanceof Error || e4 instanceof l.Report, "error() must return an Error object");
            } else
              t3 = [n2._flags.error];
          if (e3 === void 0) {
            const s2 = u.default("default", e3, t3, r2);
            a2.mainstay.tracer.value(a2, "default", e3, s2), e3 = s2;
          }
          if (n2._flags.cast && e3 !== void 0) {
            const t4 = n2._definition.cast[n2._flags.cast];
            if (t4.from(e3)) {
              const s2 = t4.to(e3, r2);
              a2.mainstay.tracer.value(a2, "cast", e3, s2, n2._flags.cast), e3 = s2;
            }
          }
          if (n2.$_terms.externals && o2.externals && o2._externals !== false)
            for (const {method: e4} of n2.$_terms.externals)
              a2.mainstay.externals.push({method: e4, path: a2.path, label: l.label(n2._flags, a2, o2)});
          const i2 = {value: e3, errors: t3.length ? t3 : null};
          return n2._flags.result && (i2.value = n2._flags.result === "strip" ? void 0 : r2.original, a2.mainstay.tracer.value(a2, n2._flags.result, e3, i2.value), a2.shadow(e3, n2._flags.result)), n2._cache && o2.cache !== false && !n2._refs.length && n2._cache.set(r2.original, i2), e3 === void 0 || i2.errors || n2._flags.artifact === void 0 || (a2.mainstay.artifacts = a2.mainstay.artifacts || new Map(), a2.mainstay.artifacts.has(n2._flags.artifact) || a2.mainstay.artifacts.set(n2._flags.artifact, []), a2.mainstay.artifacts.get(n2._flags.artifact).push(a2.path)), i2;
        }, u.prefs = function(e3, t3) {
          const r2 = t3 === i.defaults;
          return r2 && e3._preferences[i.symbols.prefs] ? e3._preferences[i.symbols.prefs] : (t3 = i.preferences(t3, e3._preferences), r2 && (e3._preferences[i.symbols.prefs] = t3), t3);
        }, u.default = function(e3, t3, r2, s2) {
          const {schema: a2, state: o2, prefs: l2} = s2, c2 = a2._flags[e3];
          if (l2.noDefaults || c2 === void 0)
            return t3;
          if (o2.mainstay.tracer.log(a2, o2, "rule", e3, "full"), !c2)
            return c2;
          if (typeof c2 == "function") {
            const t4 = c2.length ? [n(o2.ancestors[0]), s2] : [];
            try {
              return c2(...t4);
            } catch (t5) {
              return void r2.push(a2.$_createError("any.".concat(e3), null, {error: t5}, o2, l2));
            }
          }
          return typeof c2 != "object" ? c2 : c2[i.symbols.literal] ? c2.literal : i.isResolvable(c2) ? c2.resolve(t3, o2, l2) : n(c2);
        }, u.trim = function(e3, t3) {
          if (typeof e3 != "string")
            return e3;
          const r2 = t3.$_getRule("trim");
          return r2 && r2.args.enabled ? e3.trim() : e3;
        }, u.ignore = {active: false, debug: a, entry: a, filter: a, log: a, resolve: a, value: a}, u.errorsArray = function() {
          const e3 = [];
          return e3[i.symbols.errors] = true, e3;
        };
      }, 2036: (e2, t2, r) => {
        const s = r(375), n = r(9474), a = r(8160), o = {};
        e2.exports = o.Values = class {
          constructor(e3, t3) {
            this._values = new Set(e3), this._refs = new Set(t3), this._lowercase = o.lowercases(e3), this._override = false;
          }
          get length() {
            return this._values.size + this._refs.size;
          }
          add(e3, t3) {
            a.isResolvable(e3) ? this._refs.has(e3) || (this._refs.add(e3), t3 && t3.register(e3)) : this.has(e3, null, null, false) || (this._values.add(e3), typeof e3 == "string" && this._lowercase.set(e3.toLowerCase(), e3));
          }
          static merge(e3, t3, r2) {
            if (e3 = e3 || new o.Values(), t3) {
              if (t3._override)
                return t3.clone();
              for (const r3 of [...t3._values, ...t3._refs])
                e3.add(r3);
            }
            if (r2)
              for (const t4 of [...r2._values, ...r2._refs])
                e3.remove(t4);
            return e3.length ? e3 : null;
          }
          remove(e3) {
            a.isResolvable(e3) ? this._refs.delete(e3) : (this._values.delete(e3), typeof e3 == "string" && this._lowercase.delete(e3.toLowerCase()));
          }
          has(e3, t3, r2, s2) {
            return !!this.get(e3, t3, r2, s2);
          }
          get(e3, t3, r2, s2) {
            if (!this.length)
              return false;
            if (this._values.has(e3))
              return {value: e3};
            if (typeof e3 == "string" && e3 && s2) {
              const t4 = this._lowercase.get(e3.toLowerCase());
              if (t4)
                return {value: t4};
            }
            if (!this._refs.size && typeof e3 != "object")
              return false;
            if (typeof e3 == "object") {
              for (const t4 of this._values)
                if (n(t4, e3))
                  return {value: t4};
            }
            if (t3)
              for (const a2 of this._refs) {
                const o2 = a2.resolve(e3, t3, r2, null, {in: true});
                if (o2 === void 0)
                  continue;
                const i = a2.in && typeof o2 == "object" ? Array.isArray(o2) ? o2 : Object.keys(o2) : [o2];
                for (const t4 of i)
                  if (typeof t4 == typeof e3) {
                    if (s2 && e3 && typeof e3 == "string") {
                      if (t4.toLowerCase() === e3.toLowerCase())
                        return {value: t4, ref: a2};
                    } else if (n(t4, e3))
                      return {value: t4, ref: a2};
                  }
              }
            return false;
          }
          override() {
            this._override = true;
          }
          values(e3) {
            if (e3 && e3.display) {
              const e4 = [];
              for (const t3 of [...this._values, ...this._refs])
                t3 !== void 0 && e4.push(t3);
              return e4;
            }
            return Array.from([...this._values, ...this._refs]);
          }
          clone() {
            const e3 = new o.Values(this._values, this._refs);
            return e3._override = this._override, e3;
          }
          concat(e3) {
            s(!e3._override, "Cannot concat override set of values");
            const t3 = new o.Values([...this._values, ...e3._values], [...this._refs, ...e3._refs]);
            return t3._override = this._override, t3;
          }
          describe() {
            const e3 = [];
            this._override && e3.push({override: true});
            for (const t3 of this._values.values())
              e3.push(t3 && typeof t3 == "object" ? {value: t3} : t3);
            for (const t3 of this._refs.values())
              e3.push(t3.describe());
            return e3;
          }
        }, o.Values.prototype[a.symbols.values] = true, o.Values.prototype.slice = o.Values.prototype.clone, o.lowercases = function(e3) {
          const t3 = new Map();
          if (e3)
            for (const r2 of e3)
              typeof r2 == "string" && t3.set(r2.toLowerCase(), r2);
          return t3;
        };
      }, 978: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(1687), o = r(9621), i = {};
        e2.exports = function(e3, t3, r2 = {}) {
          if (s(e3 && typeof e3 == "object", "Invalid defaults value: must be an object"), s(!t3 || t3 === true || typeof t3 == "object", "Invalid source value: must be true, falsy or an object"), s(typeof r2 == "object", "Invalid options: must be an object"), !t3)
            return null;
          if (r2.shallow)
            return i.applyToDefaultsWithShallow(e3, t3, r2);
          const o2 = n(e3);
          if (t3 === true)
            return o2;
          const l = r2.nullOverride !== void 0 && r2.nullOverride;
          return a(o2, t3, {nullOverride: l, mergeArrays: false});
        }, i.applyToDefaultsWithShallow = function(e3, t3, r2) {
          const l = r2.shallow;
          s(Array.isArray(l), "Invalid keys");
          const c = new Map(), u = t3 === true ? null : new Set();
          for (let r3 of l) {
            r3 = Array.isArray(r3) ? r3 : r3.split(".");
            const s2 = o(e3, r3);
            s2 && typeof s2 == "object" ? c.set(s2, u && o(t3, r3) || s2) : u && u.add(r3);
          }
          const f = n(e3, {}, c);
          if (!u)
            return f;
          for (const e4 of u)
            i.reachCopy(f, t3, e4);
          const m = r2.nullOverride !== void 0 && r2.nullOverride;
          return a(f, t3, {nullOverride: m, mergeArrays: false});
        }, i.reachCopy = function(e3, t3, r2) {
          for (const e4 of r2) {
            if (!(e4 in t3))
              return;
            const r3 = t3[e4];
            if (typeof r3 != "object" || r3 === null)
              return;
            t3 = r3;
          }
          const s2 = t3;
          let n2 = e3;
          for (let e4 = 0; e4 < r2.length - 1; ++e4) {
            const t4 = r2[e4];
            typeof n2[t4] != "object" && (n2[t4] = {}), n2 = n2[t4];
          }
          n2[r2[r2.length - 1]] = s2;
        };
      }, 375: (e2, t2, r) => {
        const s = r(7916);
        e2.exports = function(e3, ...t3) {
          if (!e3) {
            if (t3.length === 1 && t3[0] instanceof Error)
              throw t3[0];
            throw new s(t3);
          }
        };
      }, 8571: (e2, t2, r) => {
        const s = r(9621), n = r(4277), a = r(7043), o = {needsProtoHack: new Set([n.set, n.map, n.weakSet, n.weakMap])};
        e2.exports = o.clone = function(e3, t3 = {}, r2 = null) {
          if (typeof e3 != "object" || e3 === null)
            return e3;
          let s2 = o.clone, i = r2;
          if (t3.shallow) {
            if (t3.shallow !== true)
              return o.cloneWithShallow(e3, t3);
            s2 = (e4) => e4;
          } else if (i) {
            const t4 = i.get(e3);
            if (t4)
              return t4;
          } else
            i = new Map();
          const l = n.getInternalProto(e3);
          if (l === n.buffer)
            return false;
          if (l === n.date)
            return new Date(e3.getTime());
          if (l === n.regex)
            return new RegExp(e3);
          const c = o.base(e3, l, t3);
          if (c === e3)
            return e3;
          if (i && i.set(e3, c), l === n.set)
            for (const r3 of e3)
              c.add(s2(r3, t3, i));
          else if (l === n.map)
            for (const [r3, n2] of e3)
              c.set(r3, s2(n2, t3, i));
          const u = a.keys(e3, t3);
          for (const r3 of u) {
            if (r3 === "__proto__")
              continue;
            if (l === n.array && r3 === "length") {
              c.length = e3.length;
              continue;
            }
            const a2 = Object.getOwnPropertyDescriptor(e3, r3);
            a2 ? a2.get || a2.set ? Object.defineProperty(c, r3, a2) : a2.enumerable ? c[r3] = s2(e3[r3], t3, i) : Object.defineProperty(c, r3, {enumerable: false, writable: true, configurable: true, value: s2(e3[r3], t3, i)}) : Object.defineProperty(c, r3, {enumerable: true, writable: true, configurable: true, value: s2(e3[r3], t3, i)});
          }
          return c;
        }, o.cloneWithShallow = function(e3, t3) {
          const r2 = t3.shallow;
          (t3 = Object.assign({}, t3)).shallow = false;
          const n2 = new Map();
          for (const t4 of r2) {
            const r3 = s(e3, t4);
            typeof r3 != "object" && typeof r3 != "function" || n2.set(r3, r3);
          }
          return o.clone(e3, t3, n2);
        }, o.base = function(e3, t3, r2) {
          if (r2.prototype === false)
            return o.needsProtoHack.has(t3) ? new t3.constructor() : t3 === n.array ? [] : {};
          const s2 = Object.getPrototypeOf(e3);
          if (s2 && s2.isImmutable)
            return e3;
          if (t3 === n.array) {
            const e4 = [];
            return s2 !== t3 && Object.setPrototypeOf(e4, s2), e4;
          }
          if (o.needsProtoHack.has(t3)) {
            const e4 = new s2.constructor();
            return s2 !== t3 && Object.setPrototypeOf(e4, s2), e4;
          }
          return Object.create(s2);
        };
      }, 9474: (e2, t2, r) => {
        const s = r(4277), n = {mismatched: null};
        e2.exports = function(e3, t3, r2) {
          return r2 = Object.assign({prototype: true}, r2), !!n.isDeepEqual(e3, t3, r2, []);
        }, n.isDeepEqual = function(e3, t3, r2, a) {
          if (e3 === t3)
            return e3 !== 0 || 1 / e3 == 1 / t3;
          const o = typeof e3;
          if (o !== typeof t3)
            return false;
          if (e3 === null || t3 === null)
            return false;
          if (o === "function") {
            if (!r2.deepFunction || e3.toString() !== t3.toString())
              return false;
          } else if (o !== "object")
            return e3 != e3 && t3 != t3;
          const i = n.getSharedType(e3, t3, !!r2.prototype);
          switch (i) {
            case s.buffer:
              return false;
            case s.promise:
              return e3 === t3;
            case s.regex:
              return e3.toString() === t3.toString();
            case n.mismatched:
              return false;
          }
          for (let r3 = a.length - 1; r3 >= 0; --r3)
            if (a[r3].isSame(e3, t3))
              return true;
          a.push(new n.SeenEntry(e3, t3));
          try {
            return !!n.isDeepEqualObj(i, e3, t3, r2, a);
          } finally {
            a.pop();
          }
        }, n.getSharedType = function(e3, t3, r2) {
          if (r2)
            return Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3) ? n.mismatched : s.getInternalProto(e3);
          const a = s.getInternalProto(e3);
          return a !== s.getInternalProto(t3) ? n.mismatched : a;
        }, n.valueOf = function(e3) {
          const t3 = e3.valueOf;
          if (t3 === void 0)
            return e3;
          try {
            return t3.call(e3);
          } catch (e4) {
            return e4;
          }
        }, n.hasOwnEnumerableProperty = function(e3, t3) {
          return Object.prototype.propertyIsEnumerable.call(e3, t3);
        }, n.isSetSimpleEqual = function(e3, t3) {
          for (const r2 of Set.prototype.values.call(e3))
            if (!Set.prototype.has.call(t3, r2))
              return false;
          return true;
        }, n.isDeepEqualObj = function(e3, t3, r2, a, o) {
          const {isDeepEqual: i, valueOf: l, hasOwnEnumerableProperty: c} = n, {keys: u, getOwnPropertySymbols: f} = Object;
          if (e3 === s.array) {
            if (!a.part) {
              if (t3.length !== r2.length)
                return false;
              for (let e4 = 0; e4 < t3.length; ++e4)
                if (!i(t3[e4], r2[e4], a, o))
                  return false;
              return true;
            }
            for (const e4 of t3)
              for (const t4 of r2)
                if (i(e4, t4, a, o))
                  return true;
          } else if (e3 === s.set) {
            if (t3.size !== r2.size)
              return false;
            if (!n.isSetSimpleEqual(t3, r2)) {
              const e4 = new Set(Set.prototype.values.call(r2));
              for (const r3 of Set.prototype.values.call(t3)) {
                if (e4.delete(r3))
                  continue;
                let t4 = false;
                for (const s2 of e4)
                  if (i(r3, s2, a, o)) {
                    e4.delete(s2), t4 = true;
                    break;
                  }
                if (!t4)
                  return false;
              }
            }
          } else if (e3 === s.map) {
            if (t3.size !== r2.size)
              return false;
            for (const [e4, s2] of Map.prototype.entries.call(t3)) {
              if (s2 === void 0 && !Map.prototype.has.call(r2, e4))
                return false;
              if (!i(s2, Map.prototype.get.call(r2, e4), a, o))
                return false;
            }
          } else if (e3 === s.error && (t3.name !== r2.name || t3.message !== r2.message))
            return false;
          const m = l(t3), h = l(r2);
          if ((t3 !== m || r2 !== h) && !i(m, h, a, o))
            return false;
          const d = u(t3);
          if (!a.part && d.length !== u(r2).length && !a.skip)
            return false;
          let p = 0;
          for (const e4 of d)
            if (a.skip && a.skip.includes(e4))
              r2[e4] === void 0 && ++p;
            else {
              if (!c(r2, e4))
                return false;
              if (!i(t3[e4], r2[e4], a, o))
                return false;
            }
          if (!a.part && d.length - p !== u(r2).length)
            return false;
          if (a.symbols !== false) {
            const e4 = f(t3), s2 = new Set(f(r2));
            for (const n2 of e4) {
              if (!a.skip || !a.skip.includes(n2)) {
                if (c(t3, n2)) {
                  if (!c(r2, n2))
                    return false;
                  if (!i(t3[n2], r2[n2], a, o))
                    return false;
                } else if (c(r2, n2))
                  return false;
              }
              s2.delete(n2);
            }
            for (const e5 of s2)
              if (c(r2, e5))
                return false;
          }
          return true;
        }, n.SeenEntry = class {
          constructor(e3, t3) {
            this.obj = e3, this.ref = t3;
          }
          isSame(e3, t3) {
            return this.obj === e3 && this.ref === t3;
          }
        };
      }, 7916: (e2, t2, r) => {
        const s = r(8761);
        e2.exports = class extends Error {
          constructor(e3) {
            super(e3.filter((e4) => e4 !== "").map((e4) => typeof e4 == "string" ? e4 : e4 instanceof Error ? e4.message : s(e4)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, t2.assert);
          }
        };
      }, 5277: (e2) => {
        const t2 = {};
        e2.exports = function(e3) {
          if (!e3)
            return "";
          let r = "";
          for (let s = 0; s < e3.length; ++s) {
            const n = e3.charCodeAt(s);
            t2.isSafe(n) ? r += e3[s] : r += t2.escapeHtmlChar(n);
          }
          return r;
        }, t2.escapeHtmlChar = function(e3) {
          const r = t2.namedHtml[e3];
          if (r !== void 0)
            return r;
          if (e3 >= 256)
            return "&#" + e3 + ";";
          const s = e3.toString(16).padStart(2, "0");
          return "&#x".concat(s, ";");
        }, t2.isSafe = function(e3) {
          return t2.safeCharCodes[e3] !== void 0;
        }, t2.namedHtml = {38: "&amp;", 60: "&lt;", 62: "&gt;", 34: "&quot;", 160: "&nbsp;", 162: "&cent;", 163: "&pound;", 164: "&curren;", 169: "&copy;", 174: "&reg;"}, t2.safeCharCodes = function() {
          const e3 = {};
          for (let t3 = 32; t3 < 123; ++t3)
            (t3 >= 97 || t3 >= 65 && t3 <= 90 || t3 >= 48 && t3 <= 57 || t3 === 32 || t3 === 46 || t3 === 44 || t3 === 45 || t3 === 58 || t3 === 95) && (e3[t3] = null);
          return e3;
        }();
      }, 6064: (e2) => {
        e2.exports = function(e3) {
          return e3.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
        };
      }, 738: (e2) => {
        e2.exports = function() {
        };
      }, 1687: (e2, t2, r) => {
        const s = r(375), n = r(8571), a = r(7043), o = {};
        e2.exports = o.merge = function(e3, t3, r2) {
          if (s(e3 && typeof e3 == "object", "Invalid target value: must be an object"), s(t3 == null || typeof t3 == "object", "Invalid source value: must be null, undefined, or an object"), !t3)
            return e3;
          if (r2 = Object.assign({nullOverride: true, mergeArrays: true}, r2), Array.isArray(t3)) {
            s(Array.isArray(e3), "Cannot merge array onto an object"), r2.mergeArrays || (e3.length = 0);
            for (let s2 = 0; s2 < t3.length; ++s2)
              e3.push(n(t3[s2], {symbols: r2.symbols}));
            return e3;
          }
          const i = a.keys(t3, r2);
          for (let s2 = 0; s2 < i.length; ++s2) {
            const a2 = i[s2];
            if (a2 === "__proto__" || !Object.prototype.propertyIsEnumerable.call(t3, a2))
              continue;
            const l = t3[a2];
            if (l && typeof l == "object") {
              if (e3[a2] === l)
                continue;
              !e3[a2] || typeof e3[a2] != "object" || Array.isArray(e3[a2]) !== Array.isArray(l) || l instanceof Date || l instanceof RegExp ? e3[a2] = n(l, {symbols: r2.symbols}) : o.merge(e3[a2], l, r2);
            } else
              (l != null || r2.nullOverride) && (e3[a2] = l);
          }
          return e3;
        };
      }, 9621: (e2, t2, r) => {
        const s = r(375), n = {};
        e2.exports = function(e3, t3, r2) {
          if (t3 === false || t3 == null)
            return e3;
          typeof (r2 = r2 || {}) == "string" && (r2 = {separator: r2});
          const a = Array.isArray(t3);
          s(!a || !r2.separator, "Separator option no valid for array-based chain");
          const o = a ? t3 : t3.split(r2.separator || ".");
          let i = e3;
          for (let e4 = 0; e4 < o.length; ++e4) {
            let a2 = o[e4];
            const l = r2.iterables && n.iterables(i);
            if (Array.isArray(i) || l === "set") {
              const e5 = Number(a2);
              Number.isInteger(e5) && (a2 = e5 < 0 ? i.length + e5 : e5);
            }
            if (!i || typeof i == "function" && r2.functions === false || !l && i[a2] === void 0) {
              s(!r2.strict || e4 + 1 === o.length, "Missing segment", a2, "in reach path ", t3), s(typeof i == "object" || r2.functions === true || typeof i != "function", "Invalid segment", a2, "in reach path ", t3), i = r2.default;
              break;
            }
            i = l ? l === "set" ? [...i][a2] : i.get(a2) : i[a2];
          }
          return i;
        }, n.iterables = function(e3) {
          return e3 instanceof Set ? "set" : e3 instanceof Map ? "map" : void 0;
        };
      }, 8761: (e2) => {
        e2.exports = function(...e3) {
          try {
            return JSON.stringify.apply(null, e3);
          } catch (e4) {
            return "[Cannot display object: " + e4.message + "]";
          }
        };
      }, 4277: (e2, t2) => {
        const r = {};
        t2 = e2.exports = {array: Array.prototype, buffer: false, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype}, r.typeMap = new Map([["[object Error]", t2.error], ["[object Map]", t2.map], ["[object Promise]", t2.promise], ["[object Set]", t2.set], ["[object WeakMap]", t2.weakMap], ["[object WeakSet]", t2.weakSet]]), t2.getInternalProto = function(e3) {
          if (Array.isArray(e3))
            return t2.array;
          if (e3 instanceof Date)
            return t2.date;
          if (e3 instanceof RegExp)
            return t2.regex;
          if (e3 instanceof Error)
            return t2.error;
          const s = Object.prototype.toString.call(e3);
          return r.typeMap.get(s) || t2.generic;
        };
      }, 7043: (e2, t2) => {
        t2.keys = function(e3, t3 = {}) {
          return t3.symbols !== false ? Reflect.ownKeys(e3) : Object.getOwnPropertyNames(e3);
        };
      }, 3652: (e2, t2, r) => {
        const s = r(375), n = {};
        t2.Sorter = class {
          constructor() {
            this._items = [], this.nodes = [];
          }
          add(e3, t3) {
            const r2 = [].concat((t3 = t3 || {}).before || []), n2 = [].concat(t3.after || []), a = t3.group || "?", o = t3.sort || 0;
            s(!r2.includes(a), "Item cannot come before itself: ".concat(a)), s(!r2.includes("?"), "Item cannot come before unassociated items"), s(!n2.includes(a), "Item cannot come after itself: ".concat(a)), s(!n2.includes("?"), "Item cannot come after unassociated items"), Array.isArray(e3) || (e3 = [e3]);
            for (const t4 of e3) {
              const e4 = {seq: this._items.length, sort: o, before: r2, after: n2, group: a, node: t4};
              this._items.push(e4);
            }
            if (!t3.manual) {
              const e4 = this._sort();
              s(e4, "item", a !== "?" ? "added into group ".concat(a) : "", "created a dependencies error");
            }
            return this.nodes;
          }
          merge(e3) {
            Array.isArray(e3) || (e3 = [e3]);
            for (const t4 of e3)
              if (t4)
                for (const e4 of t4._items)
                  this._items.push(Object.assign({}, e4));
            this._items.sort(n.mergeSort);
            for (let e4 = 0; e4 < this._items.length; ++e4)
              this._items[e4].seq = e4;
            const t3 = this._sort();
            return s(t3, "merge created a dependencies error"), this.nodes;
          }
          sort() {
            const e3 = this._sort();
            return s(e3, "sort created a dependencies error"), this.nodes;
          }
          _sort() {
            const e3 = {}, t3 = Object.create(null), r2 = Object.create(null);
            for (const s3 of this._items) {
              const n3 = s3.seq, a2 = s3.group;
              r2[a2] = r2[a2] || [], r2[a2].push(n3), e3[n3] = s3.before;
              for (const e4 of s3.after)
                t3[e4] = t3[e4] || [], t3[e4].push(n3);
            }
            for (const t4 in e3) {
              const s3 = [];
              for (const n3 in e3[t4]) {
                const a2 = e3[t4][n3];
                r2[a2] = r2[a2] || [], s3.push(...r2[a2]);
              }
              e3[t4] = s3;
            }
            for (const s3 in t3)
              if (r2[s3])
                for (const n3 of r2[s3])
                  e3[n3].push(...t3[s3]);
            const s2 = {};
            for (const t4 in e3) {
              const r3 = e3[t4];
              for (const e4 of r3)
                s2[e4] = s2[e4] || [], s2[e4].push(t4);
            }
            const n2 = {}, a = [];
            for (let e4 = 0; e4 < this._items.length; ++e4) {
              let t4 = e4;
              if (s2[e4]) {
                t4 = null;
                for (let e5 = 0; e5 < this._items.length; ++e5) {
                  if (n2[e5] === true)
                    continue;
                  s2[e5] || (s2[e5] = []);
                  const r3 = s2[e5].length;
                  let a2 = 0;
                  for (let t5 = 0; t5 < r3; ++t5)
                    n2[s2[e5][t5]] && ++a2;
                  if (a2 === r3) {
                    t4 = e5;
                    break;
                  }
                }
              }
              t4 !== null && (n2[t4] = true, a.push(t4));
            }
            if (a.length !== this._items.length)
              return false;
            const o = {};
            for (const e4 of this._items)
              o[e4.seq] = e4;
            this._items = [], this.nodes = [];
            for (const e4 of a) {
              const t4 = o[e4];
              this.nodes.push(t4.node), this._items.push(t4);
            }
            return true;
          }
        }, n.mergeSort = (e3, t3) => e3.sort === t3.sort ? 0 : e3.sort < t3.sort ? -1 : 1;
      }, 5380: (e2, t2, r) => {
        const s = r(443), n = r(2178), a = {minDomainSegments: 2, nonAsciiRx: /[^\x00-\x7f]/, domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/, tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, URL: s.URL || URL};
        t2.analyze = function(e3, t3 = {}) {
          if (typeof e3 != "string")
            throw new Error("Invalid input: domain must be a string");
          if (!e3)
            return n.code("DOMAIN_NON_EMPTY_STRING");
          if (e3.length > 256)
            return n.code("DOMAIN_TOO_LONG");
          if (a.nonAsciiRx.test(e3)) {
            if (t3.allowUnicode === false)
              return n.code("DOMAIN_INVALID_UNICODE_CHARS");
            e3 = e3.normalize("NFC");
          }
          if (a.domainControlRx.test(e3))
            return n.code("DOMAIN_INVALID_CHARS");
          e3 = a.punycode(e3);
          const r2 = t3.minDomainSegments || a.minDomainSegments, s2 = e3.split(".");
          if (s2.length < r2)
            return n.code("DOMAIN_SEGMENTS_COUNT");
          if (t3.maxDomainSegments && s2.length > t3.maxDomainSegments)
            return n.code("DOMAIN_SEGMENTS_COUNT_MAX");
          const o = t3.tlds;
          if (o) {
            const e4 = s2[s2.length - 1].toLowerCase();
            if (o.deny && o.deny.has(e4) || o.allow && !o.allow.has(e4))
              return n.code("DOMAIN_FORBIDDEN_TLDS");
          }
          for (let e4 = 0; e4 < s2.length; ++e4) {
            const t4 = s2[e4];
            if (!t4.length)
              return n.code("DOMAIN_EMPTY_SEGMENT");
            if (t4.length > 63)
              return n.code("DOMAIN_LONG_SEGMENT");
            if (e4 < s2.length - 1) {
              if (!a.domainSegmentRx.test(t4))
                return n.code("DOMAIN_INVALID_CHARS");
            } else if (!a.tldSegmentRx.test(t4))
              return n.code("DOMAIN_INVALID_TLDS_CHARS");
          }
          return null;
        }, t2.isValid = function(e3, r2) {
          return !t2.analyze(e3, r2);
        }, a.punycode = function(e3) {
          try {
            return new a.URL("http://".concat(e3)).host;
          } catch (t3) {
            return e3;
          }
        };
      }, 1745: (e2, t2, r) => {
        const s = r(9848), n = r(5380), a = r(2178), o = {nonAsciiRx: /[^\x00-\x7f]/, encoder: new (s.TextEncoder || TextEncoder)()};
        t2.analyze = function(e3, t3) {
          return o.email(e3, t3);
        }, t2.isValid = function(e3, t3) {
          return !o.email(e3, t3);
        }, o.email = function(e3, t3 = {}) {
          if (typeof e3 != "string")
            throw new Error("Invalid input: email must be a string");
          if (!e3)
            return a.code("EMPTY_STRING");
          const r2 = !o.nonAsciiRx.test(e3);
          if (!r2) {
            if (t3.allowUnicode === false)
              return a.code("FORBIDDEN_UNICODE");
            e3 = e3.normalize("NFC");
          }
          const s2 = e3.split("@");
          if (s2.length !== 2)
            return s2.length > 2 ? a.code("MULTIPLE_AT_CHAR") : a.code("MISSING_AT_CHAR");
          const [i, l] = s2;
          if (!i)
            return a.code("EMPTY_LOCAL");
          if (!t3.ignoreLength) {
            if (e3.length > 254)
              return a.code("ADDRESS_TOO_LONG");
            if (o.encoder.encode(i).length > 64)
              return a.code("LOCAL_TOO_LONG");
          }
          return o.local(i, r2) || n.analyze(l, t3);
        }, o.local = function(e3, t3) {
          const r2 = e3.split(".");
          for (const e4 of r2) {
            if (!e4.length)
              return a.code("EMPTY_LOCAL_SEGMENT");
            if (t3) {
              if (!o.atextRx.test(e4))
                return a.code("INVALID_LOCAL_CHARS");
            } else
              for (const t4 of e4) {
                if (o.atextRx.test(t4))
                  continue;
                const e5 = o.binary(t4);
                if (!o.atomRx.test(e5))
                  return a.code("INVALID_LOCAL_CHARS");
              }
          }
        }, o.binary = function(e3) {
          return Array.from(o.encoder.encode(e3)).map((e4) => String.fromCharCode(e4)).join("");
        }, o.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, o.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));
      }, 2178: (e2, t2) => {
        t2.codes = {EMPTY_STRING: "Address must be a non-empty string", FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters", MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character", MISSING_AT_CHAR: "Address must contain one @ character", EMPTY_LOCAL: "Address local part cannot be empty", ADDRESS_TOO_LONG: "Address too long", LOCAL_TOO_LONG: "Address local part too long", EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment", INVALID_LOCAL_CHARS: "Address local part contains invalid character", DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string", DOMAIN_TOO_LONG: "Domain too long", DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters", DOMAIN_INVALID_CHARS: "Domain contains invalid character", DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character", DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments", DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments", DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD", DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment", DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"}, t2.code = function(e3) {
          return {code: e3, error: t2.codes[e3]};
        };
      }, 9959: (e2, t2, r) => {
        const s = r(375), n = r(5752);
        t2.regex = function(e3 = {}) {
          s(e3.cidr === void 0 || typeof e3.cidr == "string", "options.cidr must be a string");
          const t3 = e3.cidr ? e3.cidr.toLowerCase() : "optional";
          s(["required", "optional", "forbidden"].includes(t3), "options.cidr must be one of required, optional, forbidden"), s(e3.version === void 0 || typeof e3.version == "string" || Array.isArray(e3.version), "options.version must be a string or an array of string");
          let r2 = e3.version || ["ipv4", "ipv6", "ipvfuture"];
          Array.isArray(r2) || (r2 = [r2]), s(r2.length >= 1, "options.version must have at least 1 version specified");
          for (let e4 = 0; e4 < r2.length; ++e4)
            s(typeof r2[e4] == "string", "options.version must only contain strings"), r2[e4] = r2[e4].toLowerCase(), s(["ipv4", "ipv6", "ipvfuture"].includes(r2[e4]), "options.version contains unknown version " + r2[e4] + " - must be one of ipv4, ipv6, ipvfuture");
          r2 = Array.from(new Set(r2));
          const a = r2.map((e4) => {
            if (t3 === "forbidden")
              return n.ip[e4];
            const r3 = "\\/".concat(e4 === "ipv4" ? n.ip.v4Cidr : n.ip.v6Cidr);
            return t3 === "required" ? "".concat(n.ip[e4]).concat(r3) : "".concat(n.ip[e4], "(?:").concat(r3, ")?");
          }), o = "(?:".concat(a.join("|"), ")"), i = new RegExp("^".concat(o, "$"));
          return {cidr: t3, versions: r2, regex: i, raw: o};
        };
      }, 5752: (e2, t2, r) => {
        const s = r(375), n = r(6064), a = {generate: function() {
          const e3 = {}, t3 = "!\\$&'\\(\\)\\*\\+,;=", r2 = "\\w-\\.~%\\dA-Fa-f" + t3 + ":@", s2 = "[" + r2 + "]", n2 = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
          e3.ipv4address = "(?:" + n2 + "\\.){3}" + n2;
          const a2 = "[\\dA-Fa-f]{1,4}", o = "(?:" + a2 + ":" + a2 + "|" + e3.ipv4address + ")", i = "(?:" + a2 + ":){6}" + o, l = "::(?:" + a2 + ":){5}" + o, c = "(?:" + a2 + ")?::(?:" + a2 + ":){4}" + o, u = "(?:(?:" + a2 + ":){0,1}" + a2 + ")?::(?:" + a2 + ":){3}" + o, f = "(?:(?:" + a2 + ":){0,2}" + a2 + ")?::(?:" + a2 + ":){2}" + o, m = "(?:(?:" + a2 + ":){0,3}" + a2 + ")?::" + a2 + ":" + o, h = "(?:(?:" + a2 + ":){0,4}" + a2 + ")?::" + o;
          e3.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", e3.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", e3.ipv6address = "(?:" + i + "|" + l + "|" + c + "|" + u + "|" + f + "|" + m + "|" + h + "|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)", e3.ipvFuture = "v[\\dA-Fa-f]+\\.[\\w-\\.~" + t3 + ":]+", e3.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", e3.schemeRegex = new RegExp(e3.scheme);
          const d = "[\\w-\\.~%\\dA-Fa-f" + t3 + ":]*", p = "(?:\\[(?:" + e3.ipv6address + "|" + e3.ipvFuture + ")\\]|" + e3.ipv4address + "|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})", g = "(?:" + d + "@)?" + p + "(?::\\d*)?", y = "(?:" + d + "@)?(" + p + ")(?::\\d*)?", b = s2 + "+", v = "(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*", _ = "\\/(?:" + b + v + ")?", w = b + v, $ = "[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+" + v;
          return e3.hierPart = "(?:(?:\\/\\/" + g + v + ")|" + _ + "|" + w + "|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))", e3.hierPartCapture = "(?:(?:\\/\\/" + y + v + ")|" + _ + "|" + w + ")", e3.relativeRef = "(?:(?:\\/\\/" + g + v + ")|" + _ + "|" + $ + "|)", e3.relativeRefCapture = "(?:(?:\\/\\/" + y + v + ")|" + _ + "|" + $ + "|)", e3.query = "[" + r2 + "\\/\\?]*(?=#|$)", e3.queryWithSquareBrackets = "[" + r2 + "\\[\\]\\/\\?]*(?=#|$)", e3.fragment = "[" + r2 + "\\/\\?]*", e3;
        }};
        a.rfc3986 = a.generate(), t2.ip = {v4Cidr: a.rfc3986.ipv4Cidr, v6Cidr: a.rfc3986.ipv6Cidr, ipv4: a.rfc3986.ipv4address, ipv6: a.rfc3986.ipv6address, ipvfuture: a.rfc3986.ipvFuture}, a.createRegex = function(e3) {
          const t3 = a.rfc3986, r2 = "(?:\\?" + (e3.allowQuerySquareBrackets ? t3.queryWithSquareBrackets : t3.query) + ")?(?:#" + t3.fragment + ")?", o = e3.domain ? t3.relativeRefCapture : t3.relativeRef;
          if (e3.relativeOnly)
            return a.wrap(o + r2);
          let i = "";
          if (e3.scheme) {
            s(e3.scheme instanceof RegExp || typeof e3.scheme == "string" || Array.isArray(e3.scheme), "scheme must be a RegExp, String, or Array");
            const r3 = [].concat(e3.scheme);
            s(r3.length >= 1, "scheme must have at least 1 scheme specified");
            const a2 = [];
            for (let e4 = 0; e4 < r3.length; ++e4) {
              const o2 = r3[e4];
              s(o2 instanceof RegExp || typeof o2 == "string", "scheme at position " + e4 + " must be a RegExp or String"), o2 instanceof RegExp ? a2.push(o2.source.toString()) : (s(t3.schemeRegex.test(o2), "scheme at position " + e4 + " must be a valid scheme"), a2.push(n(o2)));
            }
            i = a2.join("|");
          }
          const l = "(?:" + (i ? "(?:" + i + ")" : t3.scheme) + ":" + (e3.domain ? t3.hierPartCapture : t3.hierPart) + ")", c = e3.allowRelative ? "(?:" + l + "|" + o + ")" : l;
          return a.wrap(c + r2, i);
        }, a.wrap = function(e3, t3) {
          return {raw: e3 = "(?=.)(?!https?:/$)".concat(e3), regex: new RegExp("^".concat(e3, "$")), scheme: t3};
        }, a.uriRegex = a.createRegex({}), t2.regex = function(e3 = {}) {
          return e3.scheme || e3.allowRelative || e3.relativeOnly || e3.allowQuerySquareBrackets || e3.domain ? a.createRegex(e3) : a.uriRegex;
        };
      }, 1447: (e2, t2) => {
        const r = {operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"], operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"], operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]], operatorsPrefix: ["!", "n"], literals: {'"': '"', "`": "`", "'": "'", "[": "]"}, numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/, tokenRx: /^[\w\$\#\.\@\:\{\}]+$/, symbol: Symbol("formula"), settings: Symbol("settings")};
        t2.Parser = class {
          constructor(e3, t3 = {}) {
            if (!t3[r.settings] && t3.constants)
              for (const e4 in t3.constants) {
                const r2 = t3.constants[e4];
                if (r2 !== null && !["boolean", "number", "string"].includes(typeof r2))
                  throw new Error("Formula constant ".concat(e4, " contains invalid ").concat(typeof r2, " value type"));
              }
            this.settings = t3[r.settings] ? t3 : Object.assign({[r.settings]: true, constants: {}, functions: {}}, t3), this.single = null, this._parts = null, this._parse(e3);
          }
          _parse(e3) {
            let s = [], n = "", a = 0, o = false;
            const i = (e4) => {
              if (a)
                throw new Error("Formula missing closing parenthesis");
              const i2 = s.length ? s[s.length - 1] : null;
              if (o || n || e4) {
                if (i2 && i2.type === "reference" && e4 === ")")
                  return i2.type = "function", i2.value = this._subFormula(n, i2.value), void (n = "");
                if (e4 === ")") {
                  const e5 = new t2.Parser(n, this.settings);
                  s.push({type: "segment", value: e5});
                } else if (o) {
                  if (o === "]")
                    return s.push({type: "reference", value: n}), void (n = "");
                  s.push({type: "literal", value: n});
                } else if (r.operatorCharacters.includes(n))
                  i2 && i2.type === "operator" && r.operators.includes(i2.value + n) ? i2.value += n : s.push({type: "operator", value: n});
                else if (n.match(r.numberRx))
                  s.push({type: "constant", value: parseFloat(n)});
                else if (this.settings.constants[n] !== void 0)
                  s.push({type: "constant", value: this.settings.constants[n]});
                else {
                  if (!n.match(r.tokenRx))
                    throw new Error("Formula contains invalid token: ".concat(n));
                  s.push({type: "reference", value: n});
                }
                n = "";
              }
            };
            for (const t3 of e3)
              o ? t3 === o ? (i(), o = false) : n += t3 : a ? t3 === "(" ? (n += t3, ++a) : t3 === ")" ? (--a, a ? n += t3 : i(t3)) : n += t3 : t3 in r.literals ? o = r.literals[t3] : t3 === "(" ? (i(), ++a) : r.operatorCharacters.includes(t3) ? (i(), n = t3, i()) : t3 !== " " ? n += t3 : i();
            i(), s = s.map((e4, t3) => e4.type !== "operator" || e4.value !== "-" || t3 && s[t3 - 1].type !== "operator" ? e4 : {type: "operator", value: "n"});
            let l = false;
            for (const e4 of s) {
              if (e4.type === "operator") {
                if (r.operatorsPrefix.includes(e4.value))
                  continue;
                if (!l)
                  throw new Error("Formula contains an operator in invalid position");
                if (!r.operators.includes(e4.value))
                  throw new Error("Formula contains an unknown operator ".concat(e4.value));
              } else if (l)
                throw new Error("Formula missing expected operator");
              l = !l;
            }
            if (!l)
              throw new Error("Formula contains invalid trailing operator");
            s.length === 1 && ["reference", "literal", "constant"].includes(s[0].type) && (this.single = {type: s[0].type === "reference" ? "reference" : "value", value: s[0].value}), this._parts = s.map((e4) => {
              if (e4.type === "operator")
                return r.operatorsPrefix.includes(e4.value) ? e4 : e4.value;
              if (e4.type !== "reference")
                return e4.value;
              if (this.settings.tokenRx && !this.settings.tokenRx.test(e4.value))
                throw new Error("Formula contains invalid reference ".concat(e4.value));
              return this.settings.reference ? this.settings.reference(e4.value) : r.reference(e4.value);
            });
          }
          _subFormula(e3, s) {
            const n = this.settings.functions[s];
            if (typeof n != "function")
              throw new Error("Formula contains unknown function ".concat(s));
            let a = [];
            if (e3) {
              let t3 = "", n2 = 0, o = false;
              const i = () => {
                if (!t3)
                  throw new Error("Formula contains function ".concat(s, " with invalid arguments ").concat(e3));
                a.push(t3), t3 = "";
              };
              for (let s2 = 0; s2 < e3.length; ++s2) {
                const a2 = e3[s2];
                o ? (t3 += a2, a2 === o && (o = false)) : a2 in r.literals && !n2 ? (t3 += a2, o = r.literals[a2]) : a2 !== "," || n2 ? (t3 += a2, a2 === "(" ? ++n2 : a2 === ")" && --n2) : i();
              }
              i();
            }
            return a = a.map((e4) => new t2.Parser(e4, this.settings)), function(e4) {
              const t3 = [];
              for (const r2 of a)
                t3.push(r2.evaluate(e4));
              return n.call(e4, ...t3);
            };
          }
          evaluate(e3) {
            const t3 = this._parts.slice();
            for (let s = t3.length - 2; s >= 0; --s) {
              const n = t3[s];
              if (n && n.type === "operator") {
                const a = t3[s + 1];
                t3.splice(s + 1, 1);
                const o = r.evaluate(a, e3);
                t3[s] = r.single(n.value, o);
              }
            }
            return r.operatorsOrder.forEach((s) => {
              for (let n = 1; n < t3.length - 1; )
                if (s.includes(t3[n])) {
                  const s2 = t3[n], a = r.evaluate(t3[n - 1], e3), o = r.evaluate(t3[n + 1], e3);
                  t3.splice(n, 2);
                  const i = r.calculate(s2, a, o);
                  t3[n - 1] = i === 0 ? 0 : i;
                } else
                  n += 2;
            }), r.evaluate(t3[0], e3);
          }
        }, t2.Parser.prototype[r.symbol] = true, r.reference = function(e3) {
          return function(t3) {
            return t3 && t3[e3] !== void 0 ? t3[e3] : null;
          };
        }, r.evaluate = function(e3, t3) {
          return e3 === null ? null : typeof e3 == "function" ? e3(t3) : e3[r.symbol] ? e3.evaluate(t3) : e3;
        }, r.single = function(e3, t3) {
          if (e3 === "!")
            return !t3;
          const r2 = -t3;
          return r2 === 0 ? 0 : r2;
        }, r.calculate = function(e3, t3, s) {
          if (e3 === "??")
            return r.exists(t3) ? t3 : s;
          if (typeof t3 == "string" || typeof s == "string") {
            if (e3 === "+")
              return (t3 = r.exists(t3) ? t3 : "") + (r.exists(s) ? s : "");
          } else
            switch (e3) {
              case "^":
                return Math.pow(t3, s);
              case "*":
                return t3 * s;
              case "/":
                return t3 / s;
              case "%":
                return t3 % s;
              case "+":
                return t3 + s;
              case "-":
                return t3 - s;
            }
          switch (e3) {
            case "<":
              return t3 < s;
            case "<=":
              return t3 <= s;
            case ">":
              return t3 > s;
            case ">=":
              return t3 >= s;
            case "==":
              return t3 === s;
            case "!=":
              return t3 !== s;
            case "&&":
              return t3 && s;
            case "||":
              return t3 || s;
          }
          return null;
        }, r.exists = function(e3) {
          return e3 != null;
        };
      }, 9926: () => {
      }, 5688: () => {
      }, 9708: () => {
      }, 1152: () => {
      }, 443: () => {
      }, 9848: () => {
      }}, t = {}, function r(s) {
        var n = t[s];
        if (n !== void 0)
          return n.exports;
        var a = t[s] = {exports: {}};
        return e[s](a, a.exports, r), a.exports;
      }(5107);
      var e, t;
    });
  })(joiBrowser_min);
  var __joi = joiBrowser_min.exports;
  function wrap($elm, $wrapper) {
    if (typeof $wrapper === "string") {
      $wrapper = document.createElement($wrapper);
    }
    const $parent = $elm.parentNode;
    const $sibling = $elm.nextSibling;
    if ($sibling) {
      $parent.insertBefore($wrapper, $sibling);
    } else {
      $parent.appendChild($wrapper);
    }
    return $wrapper.appendChild($elm);
  }
  function insertAfter(elm, refElm) {
    const nextSibling = refElm.nextSibling;
    if (!nextSibling) {
      refElm.parentNode.appendChild(elm);
    } else {
      refElm.parentNode.insertBefore(elm, nextSibling);
    }
    return elm;
  }
  var __css = ".s-form-validate.s-form-validate--error[s-form-validate-error-container] > *:first-child {\n            margin-bottom: 0 !important;\n        }\n    .s-form-validate .s-form-validate__error-message {\n        text-align: end;\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n        overflow: hidden;\n        max-height: 0;\n        line-height: 1;\n        margin: 0;\n        -webkit-animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n                animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n    }\n    @-webkit-keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n    @keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n";
  class SFormValidateFeature extends SFeature {
    constructor(name, node, settings) {
      var _a;
      Object.keys((_a = SComponent.getDefaultProps(name)) === null || _a === void 0 ? void 0 : _a.customValidations).forEach((validationName) => {
        if (SFormValidateFeatureInterface.definition[validationName])
          return;
        SFormValidateFeatureInterface.definition[validationName] = {
          type: "String|Boolean"
        };
      });
      super(name, node, __deepMerge$8({
        componentUtils: {
          interface: SFormValidateFeatureInterface,
          style: __css
        }
      }, settings !== null && settings !== void 0 ? settings : {}));
      this._validationType = "string";
      this._isValidating = false;
      this.componentUtils.exposeApi({
        validate: this.validate
      }, this);
    }
    mount() {
      this._$field = this.node;
      const $insideField = this.node.querySelector("input,textarea,select");
      if ($insideField)
        this._$field = $insideField;
      if (this.props.type) {
        if (this.props.type === "text")
          this._validationType = "string";
        else
          this._validationType = this.props.type;
      }
      this.props.on.forEach((on) => {
        var _a, _b;
        if (on === "enter") {
          this._$field.addEventListener("keyup", (e) => {
            if (e.keyCode !== 13)
              return;
            this.validate(e);
          });
        } else if (on === "reset") {
          (_a = this._$field.form) === null || _a === void 0 ? void 0 : _a.addEventListener(on, (e) => {
            setTimeout(() => {
              this.validate(e);
            });
          });
        } else if (on === "submit") {
          (_b = this._$field.form) === null || _b === void 0 ? void 0 : _b.addEventListener(on, (e) => {
            this.validate(e);
          });
        } else {
          this.node.addEventListener(on, (e) => {
            this.validate(e);
          });
        }
      });
      let schema = __joi[this._validationType]();
      let isCustom = false;
      Object.keys(this.props).forEach((prop) => {
        if (isCustom)
          return;
        if (this.props.customValidations[prop]) {
          isCustom = true;
          schema = schema.custom(this.props.customValidations[prop], prop);
        } else {
          const propValue = this.props[prop];
          if (propValue === true && typeof schema[prop] === "function") {
            let options = {};
            if (prop === "email" || prop === "domain") {
              options = {
                tlds: false
              };
            }
            schema = schema[prop](options);
          } else if (typeof schema[prop] === "function") {
            schema = schema[prop](autoCast$1(propValue));
          }
        }
      });
      this._schema = schema;
    }
    validate(event) {
      var _a;
      if (((_a = event === null || event === void 0 ? void 0 : event.currentTarget) === null || _a === void 0 ? void 0 : _a.tagName.toLowerCase()) === "form" && event.type !== "reset") {
        event.preventDefault();
      }
      if (this._isValidating)
        return;
      this._isValidating = true;
      setTimeout(() => {
        this._isValidating = false;
      });
      let resultObj;
      if (this._$field.type === "checkbox") {
        resultObj = this._validateCheckbox();
      } else if (this._$field.type === "range") {
        resultObj = this._validateRange();
      } else if (this._$field.tagName.toLowerCase() === "select") {
        resultObj = this._validateSelect();
      } else {
        resultObj = this._schema.validate(this._$field.value, __deepMerge$8({
          errors: {
            label: false,
            language: this.props.language
          }
        }, this.props.joiOptions));
      }
      if (event.type === "reset") {
        resultObj = {};
      }
      this._applyResult(resultObj, event);
    }
    _validateCheckbox() {
      const checkboxesValues = Array.from(this.node.querySelectorAll('input[type="checkbox"]:checked')).map(($item) => $item.value);
      let schema = __joi.array();
      if (this.props.min) {
        schema = schema.min(this.props.min);
      }
      if (this.props.max) {
        schema = schema.max(this.props.max);
      }
      return schema.validate(checkboxesValues, __deepMerge$8({
        errors: {
          label: false,
          language: this.props.language
        }
      }, this.props.joiOptions));
    }
    _validateRange() {
      const value = parseFloat(this._$field.value);
      let schema = __joi.number();
      if (this.props.min) {
        schema = schema.min(this.props.min);
      }
      if (this.props.max) {
        schema = schema.max(this.props.max);
      }
      return schema.validate(value, __deepMerge$8({
        errors: {
          label: false,
          language: this.props.language
        }
      }, this.props.joiOptions));
    }
    _validateSelect() {
      const selectedItems = Array.from(this._$field.querySelectorAll("option")).filter(($item) => $item.selected).map(($item) => $item.value);
      let schema = __joi.array();
      if (this.props.min) {
        schema = schema.min(this.props.min);
      }
      if (this.props.max) {
        schema = schema.max(this.props.max);
      }
      return schema.validate(selectedItems, __deepMerge$8({
        errors: {
          label: false,
          language: this.props.language
        }
      }, this.props.joiOptions));
    }
    _applyResult(res, event) {
      var _a, _b;
      if (res.error) {
        const marginBottom = getComputedStyle(this.node).marginBottom;
        let $container = ((_b = (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.hasAttribute) === null || _b === void 0 ? void 0 : _b.call(_a, "s-form-validate-error-container")) ? this.node.parentNode : void 0;
        if (!$container && this.props.wrap) {
          $container = document.createElement("div");
          $container.setAttribute("s-form-validate-error-container", "true");
          $container.classList.remove(...this.props.validClass.split(" "));
          $container.classList.add(...this.props.errorClass.split(" "));
          wrap(this.node, $container);
        }
        if (!this.props.wrap) {
          this.node.classList.add(...this.props.errorClass.split(" "));
        }
        this.node.classList.remove(...this.props.validClass.split(" "));
        if (this.props.displayError) {
          const alreadyExists = !!($container === null || $container === void 0 ? void 0 : $container.querySelector("p[s-form-validate-error-message]"));
          const $error = alreadyExists ? $container === null || $container === void 0 ? void 0 : $container.querySelector("p[s-form-validate-error-message]") : document.createElement("p");
          if (!alreadyExists) {
            $error.setAttribute("s-form-validate-error-message", "true");
            $error.setAttribute("class", this.props.errorMessageClass);
            $error.innerHTML = res.error.message;
            $error.style.marginBottom = marginBottom;
            if ($container) {
              $container.appendChild($error);
            } else {
              insertAfter($error, this.node);
            }
          } else {
            $error.innerHTML = res.error.message;
          }
        }
      } else if (!res.error) {
        if (event.type !== "reset") {
          this.node.classList.add(...this.props.validClass.split(" "));
        } else {
          this.node.classList.remove(...this.props.validClass.split(" "));
        }
        if (this.props.wrap) {
          const $container = this.node.parentNode;
          if (!$container.hasAttribute("s-form-validate-error-container"))
            return;
          insertAfter(this.node, $container);
          $container === null || $container === void 0 ? void 0 : $container.remove();
        } else {
          const $errorMessage = this.node.nextSibling;
          if ($errorMessage === null || $errorMessage === void 0 ? void 0 : $errorMessage.hasAttribute("s-form-validate-error-message")) {
            $errorMessage === null || $errorMessage === void 0 ? void 0 : $errorMessage.remove();
          }
        }
      }
    }
  }
  function register(props = {}, name = "s-form-validate") {
    SFeature.registerFeature(name, SFormValidateFeature, props);
  }
  if (!window.env)
    window.env = {SUGAR: {}};
  window.env.SUGAR = JSON.parse(`{"platform":"browser","env":"dev","config":{"datetime":{"dateFormat":"D MMM YYYY","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"dev":{"colors":{"yellow":"#ffdc89","cyan":"#65c1cd","green":"#a7cb8b","magenta":"#d190e3","red":"#e78287","blue":"#71bdf2","primary":"#ffdc89","secondary":"#65c1cd","grey":"#e2e5e9","gray":"#e2e5e9","black":"#343a43","white":"#e2e5e9"}},"discord":{"server":{"id":"Coffeekraken","url":"https://discord.gg/ERsX54UE"}},"doc":{"layout":{}},"license":{"layout":{"headerImageUrl":"/dist/img/doc/licenseHeader.jpg"}},"themeCoffeekraken":{"themeName":"coffeekraken","variants":{"dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"#776D91","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"ui":{"color":"#7a738c","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"primary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"secondary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}}}},"themeCoffeekrakenDark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"#776D91","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"ui":{"color":"#7a738c","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"primary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"secondary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"env":{"env":"development"},"themeUi":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"theme":{"theme":"default","variant":"light","cssVariables":["*"],"themes":{"coffeekraken-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"#776D91","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"ui":{"color":"#7a738c","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"primary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"secondary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"default-light":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"accent":{"color":"#ffbb00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"complementary":{"color":"#5100ff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"success":{"color":"#91ff00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"warning":{"color":"#ffd500","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"error":{"color":"#ff003b","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"info":{"color":"#00ffff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"defaultColor":"main"},"default-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"defaultColor":"main"}}},"themeBase":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}}},"themeDarkBase":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"themeDefault":{"themeName":"default","variants":{"light":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"accent":{"color":"#ffbb00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"complementary":{"color":"#5100ff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"success":{"color":"#91ff00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"warning":{"color":"#ffd500","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"error":{"color":"#ff003b","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"info":{"color":"#00ffff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"defaultColor":"main"},"dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"defaultColor":"main"}}},"themeDefaultDark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"defaultColor":"main"},"themeDefaultLight":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"accent":{"color":"#ffbb00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"complementary":{"color":"#5100ff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"success":{"color":"#91ff00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"warning":{"color":"#ffd500","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"error":{"color":"#ff003b","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"info":{"color":"#00ffff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"current":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"primary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"secondary":{"color":"hsla(198,10,50,1)","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"defaultColor":"main"},"themeLightBase":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{}},"ui":{"filtrableInput":{"defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"darken":15,"desaturate":20},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":49},"surfaceForeground":{"darken":45},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}}},"themeTypo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"frontendServer":{"routes":{"/config/explorer/*":{"handler":"view","request":{"params":{"0":"pages/config/explorer"}}},"/config/explorer":{"handler":"view","request":{"params":{"0":"pages/config/explorer"}}},"/doc/api":{"handler":"view","request":{"params":{"0":"pages/doc/list"}}}}},"imagesBuilder":{"specificParams":{"idflood/**/*":{"width":100,"resolution":[1]}}},"sitemap":{"sources":{"coffeekrakenio":{"active":true,"settings":{},"path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/websites/coffeekraken-io/src/node/sitemap"}}},"postcss":{},"purgecss":{},"vite":{},"$":{"hash":"2153e13ddf89e2c7a9a90e0c29acca0b","loadedAt":1636380377000}}}`);
  new SDuration();
  console.log("LOADED");
  SLitComponent.setDefaultProps("*", {
    mountWhen: "inViewport"
  });
  SLitComponent.setDefaultProps(["s-side-panel", "ck-settings"], {
    mountWhen: "direct"
  });
  expandPleasantCssClassnamesLive();
  register$1();
  define$3();
  define$1();
  document.addEventListener("scroll", (e) => {
    if (window.scrollY >= 10) {
      document.body.classList.add("scrolled");
    } else {
      document.body.classList.remove("scrolled");
    }
  });
  console.log("LOADED", 2);
  define();
  define$8();
  define$7();
  define$5();
  define$6();
  define$4();
  console.log("LOADED", 3);
  register({
    customValidations: {
      coffeekraken: (value, helpers) => {
        if (value === "coffeekraken") {
          return helpers.message("Are you sure? Krakens are dangerous...");
        }
        return value;
      }
    }
  });
  smoothScroll({
    scroll: {
      offset: 188
    }
  });
  linksStateAttributes();
})();

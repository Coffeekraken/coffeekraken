var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) =>
    key in obj
        ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
        : (obj[key] = value);
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        };
        var rejected = (value) => {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        };
        var step = (x) => (x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected));
        step((generator = generator.apply(__this, __arguments)).next());
    });
};
(function () {
    'use strict';
    /* Riot v5.4.2, @license MIT */
    function camelToDashCase(string) {
        return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    function dashToCamelCase(string) {
        return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
    }
    function DOMattributesToObject(element) {
        return Array.from(element.attributes).reduce((acc, attribute) => {
            acc[dashToCamelCase(attribute.name)] = attribute.value;
            return acc;
        }, {});
    }
    function moveChildren(source, target) {
        if (source.firstChild) {
            target.appendChild(source.firstChild);
            moveChildren(source, target);
        }
    }
    function cleanNode(node) {
        clearChildren(node.childNodes);
    }
    function clearChildren(children) {
        Array.from(children).forEach(removeChild);
    }
    const removeChild = (node) => node && node.parentNode && node.parentNode.removeChild(node);
    const insertBefore = (newNode, refNode) =>
        refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
    const replaceChild = (newNode, replaced) =>
        replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);
    const COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),
        DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),
        PLUGINS_SET$1 = new Set(),
        IS_DIRECTIVE = 'is',
        VALUE_ATTRIBUTE = 'value',
        MOUNT_METHOD_KEY = 'mount',
        UPDATE_METHOD_KEY = 'update',
        UNMOUNT_METHOD_KEY = 'unmount',
        SHOULD_UPDATE_KEY = 'shouldUpdate',
        ON_BEFORE_MOUNT_KEY = 'onBeforeMount',
        ON_MOUNTED_KEY = 'onMounted',
        ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',
        ON_UPDATED_KEY = 'onUpdated',
        ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',
        ON_UNMOUNTED_KEY = 'onUnmounted',
        PROPS_KEY = 'props',
        STATE_KEY = 'state',
        SLOTS_KEY = 'slots',
        ROOT_KEY = 'root',
        IS_PURE_SYMBOL = Symbol('pure'),
        IS_COMPONENT_UPDATING = Symbol('is_updating'),
        PARENT_KEY_SYMBOL = Symbol('parent'),
        ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),
        TEMPLATE_KEY_SYMBOL = Symbol('template');
    var globals = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
        DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
        PLUGINS_SET: PLUGINS_SET$1,
        IS_DIRECTIVE,
        VALUE_ATTRIBUTE,
        MOUNT_METHOD_KEY,
        UPDATE_METHOD_KEY,
        UNMOUNT_METHOD_KEY,
        SHOULD_UPDATE_KEY,
        ON_BEFORE_MOUNT_KEY,
        ON_MOUNTED_KEY,
        ON_BEFORE_UPDATE_KEY,
        ON_UPDATED_KEY,
        ON_BEFORE_UNMOUNT_KEY,
        ON_UNMOUNTED_KEY,
        PROPS_KEY,
        STATE_KEY,
        SLOTS_KEY,
        ROOT_KEY,
        IS_PURE_SYMBOL,
        IS_COMPONENT_UPDATING,
        PARENT_KEY_SYMBOL,
        ATTRIBUTES_KEY_SYMBOL,
        TEMPLATE_KEY_SYMBOL,
    });
    const EACH = 0;
    const IF = 1;
    const SIMPLE = 2;
    const TAG = 3;
    const SLOT = 4;
    var bindingTypes = {
        EACH,
        IF,
        SIMPLE,
        TAG,
        SLOT,
    };
    const ATTRIBUTE = 0;
    const EVENT = 1;
    const TEXT = 2;
    const VALUE = 3;
    var expressionTypes = {
        ATTRIBUTE,
        EVENT,
        TEXT,
        VALUE,
    };
    const HEAD_SYMBOL = Symbol('head');
    const TAIL_SYMBOL = Symbol('tail');
    function createHeadTailPlaceholders() {
        const head = document.createComment('fragment head');
        const tail = document.createComment('fragment tail');
        head[HEAD_SYMBOL] = true;
        tail[TAIL_SYMBOL] = true;
        return {
            head,
            tail,
        };
    }
    function createTemplateMeta(componentTemplate) {
        const fragment = componentTemplate.dom.cloneNode(true);
        const { head, tail } = createHeadTailPlaceholders();
        return {
            avoidDOMInjection: true,
            fragment,
            head,
            tail,
            children: [head, ...Array.from(fragment.childNodes), tail],
        };
    }
    function getFragmentChildren(_ref) {
        let { head, tail } = _ref;
        const nodes = walkNodes([head], head.nextSibling, (n) => n === tail, false);
        nodes.push(tail);
        return nodes;
    }
    function walkNodes(children, node, check, isFilterActive) {
        const { nextSibling } = node;
        if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {
            children.push(node);
        }
        if (!nextSibling || check(node)) return children;
        return walkNodes(
            children,
            nextSibling,
            check,
            (isFilterActive && !node[TAIL_SYMBOL]) || nextSibling[HEAD_SYMBOL],
        );
    }
    function checkType(element, type) {
        return typeof element === type;
    }
    function isSvg(el) {
        const owner = el.ownerSVGElement;
        return !!owner || owner === null;
    }
    function isTemplate(el) {
        return !isNil(el.content);
    }
    function isFunction$5(value) {
        return checkType(value, 'function');
    }
    function isBoolean$3(value) {
        return checkType(value, 'boolean');
    }
    function isObject$6(value) {
        return !isNil(value) && value.constructor === Object;
    }
    function isNil(value) {
        return value === null || value === void 0;
    }
    var udomdiff = (a, b, get, before) => {
        const bLength = b.length;
        let aEnd = a.length;
        let bEnd = bLength;
        let aStart = 0;
        let bStart = 0;
        let map = null;
        while (aStart < aEnd || bStart < bEnd) {
            if (aEnd === aStart) {
                const node =
                    bEnd < bLength ? (bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0)) : before;
                while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);
            } else if (bEnd === bStart) {
                while (aStart < aEnd) {
                    if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));
                    aStart++;
                }
            } else if (a[aStart] === b[bStart]) {
                aStart++;
                bStart++;
            } else if (a[aEnd - 1] === b[bEnd - 1]) {
                aEnd--;
                bEnd--;
            } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
                const node = get(a[--aEnd], -1).nextSibling;
                insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
                insertBefore(get(b[--bEnd], 1), node);
                a[aEnd] = b[bEnd];
            } else {
                if (!map) {
                    map = new Map();
                    let i = bStart;
                    while (i < bEnd) map.set(b[i], i++);
                }
                if (map.has(a[aStart])) {
                    const index = map.get(a[aStart]);
                    if (bStart < index && index < bEnd) {
                        let i = aStart;
                        let sequence = 1;
                        while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++;
                        if (sequence > index - bStart) {
                            const node = get(a[aStart], 0);
                            while (bStart < index) insertBefore(get(b[bStart++], 1), node);
                        } else {
                            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
                        }
                    } else aStart++;
                } else removeChild(get(a[aStart++], -1));
            }
        }
        return b;
    };
    const UNMOUNT_SCOPE = Symbol('unmount');
    const EachBinding = {
        nodes: [],
        mount(scope, parentScope) {
            return this.update(scope, parentScope);
        },
        update(scope, parentScope) {
            const { placeholder, nodes, childrenMap } = this;
            const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
            const items = collection ? Array.from(collection) : [];
            const { newChildrenMap, batches, futureNodes } = createPatch(items, scope, parentScope, this);
            udomdiff(nodes, futureNodes, patch$2(Array.from(childrenMap.values()), parentScope), placeholder);
            batches.forEach((fn) => fn());
            this.childrenMap = newChildrenMap;
            this.nodes = futureNodes;
            markEdgeNodes(this.nodes);
            return this;
        },
        unmount(scope, parentScope) {
            this.update(UNMOUNT_SCOPE, parentScope);
            return this;
        },
    };
    function patch$2(redundant, parentScope) {
        return (item, info) => {
            if (info < 0) {
                const element = redundant[redundant.length - 1];
                if (element) {
                    const { template, nodes, context } = element;
                    nodes.pop();
                    if (nodes.length === 0) {
                        redundant.pop();
                        template.unmount(context, parentScope, null);
                    }
                }
            }
            return item;
        };
    }
    function mustFilterItem(condition, context) {
        return condition ? Boolean(condition(context)) === false : false;
    }
    function extendScope(scope, _ref) {
        let { itemName, indexName, index, item } = _ref;
        scope[itemName] = item;
        if (indexName) scope[indexName] = index;
        return scope;
    }
    function markEdgeNodes(nodes) {
        const first = nodes[0];
        const last = nodes[nodes.length - 1];
        if (first) first[HEAD_SYMBOL] = true;
        if (last) last[TAIL_SYMBOL] = true;
    }
    function createPatch(items, scope, parentScope, binding) {
        const { condition, template, childrenMap, itemName, getKey, indexName, root, isTemplateTag } = binding;
        const newChildrenMap = new Map();
        const batches = [];
        const futureNodes = [];
        items.forEach((item, index) => {
            const context = extendScope(Object.create(scope), {
                itemName,
                indexName,
                index,
                item,
            });
            const key = getKey ? getKey(context) : index;
            const oldItem = childrenMap.get(key);
            const nodes = [];
            if (mustFilterItem(condition, context)) {
                return;
            }
            const mustMount = !oldItem;
            const componentTemplate = oldItem ? oldItem.template : template.clone();
            const el = componentTemplate.el || root.cloneNode();
            const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;
            if (mustMount) {
                batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
            } else {
                batches.push(() => componentTemplate.update(context, parentScope));
            }
            if (isTemplateTag) {
                nodes.push(...(mustMount ? meta.children : getFragmentChildren(meta)));
            } else {
                nodes.push(el);
            }
            childrenMap.delete(key);
            futureNodes.push(...nodes);
            newChildrenMap.set(key, {
                nodes,
                template: componentTemplate,
                context,
                index,
            });
        });
        return {
            newChildrenMap,
            batches,
            futureNodes,
        };
    }
    function create$6(node, _ref2) {
        let { evaluate, condition, itemName, indexName, getKey, template } = _ref2;
        const placeholder = document.createTextNode('');
        const root = node.cloneNode();
        insertBefore(placeholder, node);
        removeChild(node);
        return Object.assign({}, EachBinding, {
            childrenMap: new Map(),
            node,
            root,
            condition,
            evaluate,
            isTemplateTag: isTemplate(root),
            template: template.createDOM(node),
            getKey,
            indexName,
            itemName,
            placeholder,
        });
    }
    const IfBinding = {
        mount(scope, parentScope) {
            return this.update(scope, parentScope);
        },
        update(scope, parentScope) {
            const value = !!this.evaluate(scope);
            const mustMount = !this.value && value;
            const mustUnmount = this.value && !value;
            const mount = () => {
                const pristine = this.node.cloneNode();
                insertBefore(pristine, this.placeholder);
                this.template = this.template.clone();
                this.template.mount(pristine, scope, parentScope);
            };
            switch (true) {
                case mustMount:
                    mount();
                    break;
                case mustUnmount:
                    this.unmount(scope);
                    break;
                default:
                    if (value) this.template.update(scope, parentScope);
            }
            this.value = value;
            return this;
        },
        unmount(scope, parentScope) {
            this.template.unmount(scope, parentScope, true);
            return this;
        },
    };
    function create$5(node, _ref) {
        let { evaluate, template } = _ref;
        const placeholder = document.createTextNode('');
        insertBefore(placeholder, node);
        removeChild(node);
        return Object.assign({}, IfBinding, {
            node,
            evaluate,
            placeholder,
            template: template.createDOM(node),
        });
    }
    function panic(message) {
        throw new Error(message);
    }
    function memoize(fn) {
        const cache = new Map();
        const cached = (val) => {
            return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
        };
        cached.cache = cache;
        return cached;
    }
    function evaluateAttributeExpressions(attributes) {
        return attributes.reduce((acc, attribute) => {
            const { value, type } = attribute;
            switch (true) {
                case !attribute.name && type === ATTRIBUTE:
                    return Object.assign({}, acc, value);
                case type === VALUE:
                    acc.value = attribute.value;
                    break;
                default:
                    acc[dashToCamelCase(attribute.name)] = attribute.value;
            }
            return acc;
        }, {});
    }
    const ElementProto$1 = typeof Element === 'undefined' ? {} : Element.prototype;
    const isNativeHtmlProperty = memoize((name2) => ElementProto$1.hasOwnProperty(name2));
    function setAllAttributes(node, attributes) {
        Object.entries(attributes).forEach((_ref) => {
            let [name2, value] = _ref;
            return attributeExpression(
                node,
                {
                    name: name2,
                },
                value,
            );
        });
    }
    function removeAllAttributes(node, newAttributes, oldAttributes) {
        const newKeys = newAttributes ? Object.keys(newAttributes) : [];
        Object.keys(oldAttributes)
            .filter((name2) => !newKeys.includes(name2))
            .forEach((attribute) => node.removeAttribute(attribute));
    }
    function canRenderAttribute(value) {
        return value === true || ['string', 'number'].includes(typeof value);
    }
    function shouldRemoveAttribute(value) {
        return isNil(value) || value === false || value === '';
    }
    function attributeExpression(node, _ref2, value, oldValue) {
        let { name: name2 } = _ref2;
        if (!name2) {
            if (oldValue) {
                removeAllAttributes(node, value, oldValue);
            }
            if (value) {
                setAllAttributes(node, value);
            }
            return;
        }
        if (!isNativeHtmlProperty(name2) && (isBoolean$3(value) || isObject$6(value) || isFunction$5(value))) {
            node[name2] = value;
        }
        if (shouldRemoveAttribute(value)) {
            node.removeAttribute(name2);
        } else if (canRenderAttribute(value)) {
            node.setAttribute(name2, normalizeValue(name2, value));
        }
    }
    function normalizeValue(name2, value) {
        if (value === true) return name2;
        return value;
    }
    const RE_EVENTS_PREFIX = /^on/;
    const getCallbackAndOptions = (value) => (Array.isArray(value) ? value : [value, false]);
    const EventListener = {
        handleEvent(event2) {
            this[event2.type](event2);
        },
    };
    const ListenersWeakMap = new WeakMap();
    const createListener = (node) => {
        const listener = Object.create(EventListener);
        ListenersWeakMap.set(node, listener);
        return listener;
    };
    function eventExpression(node, _ref, value) {
        let { name: name2 } = _ref;
        const normalizedEventName = name2.replace(RE_EVENTS_PREFIX, '');
        const eventListener = ListenersWeakMap.get(node) || createListener(node);
        const [callback, options] = getCallbackAndOptions(value);
        const handler = eventListener[normalizedEventName];
        const mustRemoveEvent = handler && !callback;
        const mustAddEvent = callback && !handler;
        if (mustRemoveEvent) {
            node.removeEventListener(normalizedEventName, eventListener);
        }
        if (mustAddEvent) {
            node.addEventListener(normalizedEventName, eventListener, options);
        }
        eventListener[normalizedEventName] = callback;
    }
    function normalizeStringValue(value) {
        return isNil(value) ? '' : value;
    }
    const getTextNode = (node, childNodeIndex) => {
        const target = node.childNodes[childNodeIndex];
        if (target.nodeType === Node.COMMENT_NODE) {
            const textNode = document.createTextNode('');
            node.replaceChild(textNode, target);
            return textNode;
        }
        return target;
    };
    function textExpression(node, data, value) {
        node.data = normalizeStringValue(value);
    }
    function valueExpression(node, expression, value) {
        node.value = normalizeStringValue(value);
    }
    var expressions = {
        [ATTRIBUTE]: attributeExpression,
        [EVENT]: eventExpression,
        [TEXT]: textExpression,
        [VALUE]: valueExpression,
    };
    const Expression = {
        mount(scope) {
            this.value = this.evaluate(scope);
            apply(this, this.value);
            return this;
        },
        update(scope) {
            const value = this.evaluate(scope);
            if (this.value !== value) {
                apply(this, value);
                this.value = value;
            }
            return this;
        },
        unmount() {
            if (this.type === EVENT) apply(this, null);
            return this;
        },
    };
    function apply(expression, value) {
        return expressions[expression.type](expression.node, expression, value, expression.value);
    }
    function create$4(node, data) {
        return Object.assign({}, Expression, data, {
            node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node,
        });
    }
    function flattenCollectionMethods(collection, methods, context) {
        return methods.reduce((acc, method) => {
            return Object.assign({}, acc, {
                [method]: (scope) => {
                    return collection.map((item) => item[method](scope)) && context;
                },
            });
        }, {});
    }
    function create$3(node, _ref) {
        let { expressions } = _ref;
        return Object.assign(
            {},
            flattenCollectionMethods(
                expressions.map((expression) => create$4(node, expression)),
                ['mount', 'update', 'unmount'],
            ),
        );
    }
    function extendParentScope(attributes, scope, parentScope) {
        if (!attributes || !attributes.length) return parentScope;
        const expressions = attributes.map((attr) =>
            Object.assign({}, attr, {
                value: attr.evaluate(scope),
            }),
        );
        return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));
    }
    const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;
    const SlotBinding = {
        attributes: [],
        getTemplateScope(scope, parentScope) {
            return extendParentScope(this.attributes, scope, parentScope);
        },
        mount(scope, parentScope) {
            const templateData = scope.slots
                ? scope.slots.find((_ref) => {
                      let { id } = _ref;
                      return id === this.name;
                  })
                : false;
            const { parentNode } = this.node;
            const realParent = getRealParent(scope, parentScope);
            this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);
            if (this.template) {
                this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
                this.template.children = Array.from(this.node.childNodes);
                moveSlotInnerContent(this.node);
            }
            removeChild(this.node);
            return this;
        },
        update(scope, parentScope) {
            if (this.template) {
                const realParent = getRealParent(scope, parentScope);
                this.template.update(this.getTemplateScope(scope, realParent), realParent);
            }
            return this;
        },
        unmount(scope, parentScope, mustRemoveRoot) {
            if (this.template) {
                this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
            }
            return this;
        },
    };
    function moveSlotInnerContent(slot) {
        const child = slot && slot.firstChild;
        if (!child) return;
        insertBefore(child, slot);
        moveSlotInnerContent(slot);
    }
    function createSlot(node, _ref2) {
        let { name: name2, attributes } = _ref2;
        return Object.assign({}, SlotBinding, {
            attributes,
            node,
            name: name2,
        });
    }
    function getTag(component, slots, attributes) {
        if (slots === void 0) {
            slots = [];
        }
        if (attributes === void 0) {
            attributes = [];
        }
        if (component) {
            return component({
                slots,
                attributes,
            });
        }
        return create(slotsToMarkup(slots), [
            ...slotBindings(slots),
            {
                expressions: attributes.map((attr) => {
                    return Object.assign(
                        {
                            type: ATTRIBUTE,
                        },
                        attr,
                    );
                }),
            },
        ]);
    }
    function slotBindings(slots) {
        return slots.reduce((acc, _ref) => {
            let { bindings } = _ref;
            return acc.concat(bindings);
        }, []);
    }
    function slotsToMarkup(slots) {
        return slots.reduce((acc, slot) => {
            return acc + slot.html;
        }, '');
    }
    const TagBinding = {
        mount(scope) {
            return this.update(scope);
        },
        update(scope, parentScope) {
            const name2 = this.evaluate(scope);
            if (name2 && name2 === this.name) {
                this.tag.update(scope);
            } else {
                this.unmount(scope, parentScope, true);
                this.name = name2;
                this.tag = getTag(this.getComponent(name2), this.slots, this.attributes);
                this.tag.mount(this.node, scope);
            }
            return this;
        },
        unmount(scope, parentScope, keepRootTag) {
            if (this.tag) {
                this.tag.unmount(keepRootTag);
            }
            return this;
        },
    };
    function create$2(node, _ref2) {
        let { evaluate, getComponent, slots, attributes } = _ref2;
        return Object.assign({}, TagBinding, {
            node,
            evaluate,
            slots,
            attributes,
            getComponent,
        });
    }
    var bindings = {
        [IF]: create$5,
        [SIMPLE]: create$3,
        [EACH]: create$6,
        [TAG]: create$2,
        [SLOT]: createSlot,
    };
    function fixTextExpressionsOffset(expressions, textExpressionsOffset) {
        return expressions.map((e) =>
            e.type === TEXT
                ? Object.assign({}, e, {
                      childNodeIndex: e.childNodeIndex + textExpressionsOffset,
                  })
                : e,
        );
    }
    function create$1(root, binding, templateTagOffset) {
        const { selector, type, redundantAttribute, expressions } = binding;
        const node = selector ? root.querySelector(selector) : root;
        if (redundantAttribute) node.removeAttribute(redundantAttribute);
        const bindingExpressions = expressions || [];
        return (bindings[type] || bindings[SIMPLE])(
            node,
            Object.assign({}, binding, {
                expressions:
                    templateTagOffset && !selector
                        ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset)
                        : bindingExpressions,
            }),
        );
    }
    function createHTMLTree(html, root) {
        const template = isTemplate(root) ? root : document.createElement('template');
        template.innerHTML = html;
        return template.content;
    }
    function createSVGTree(html, container) {
        const svgNode = container.ownerDocument.importNode(
            new window.DOMParser().parseFromString(
                `<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`,
                'application/xml',
            ).documentElement,
            true,
        );
        return svgNode;
    }
    function createDOMTree(root, html) {
        if (isSvg(root)) return createSVGTree(html, root);
        return createHTMLTree(html, root);
    }
    function injectDOM(el, dom) {
        switch (true) {
            case isSvg(el):
                moveChildren(dom, el);
                break;
            case isTemplate(el):
                el.parentNode.replaceChild(dom, el);
                break;
            default:
                el.appendChild(dom);
        }
    }
    function createTemplateDOM(el, html) {
        return html && (typeof html === 'string' ? createDOMTree(el, html) : html);
    }
    const TemplateChunk = Object.freeze({
        createDOM(el) {
            this.dom = this.dom || createTemplateDOM(el, this.html);
            return this;
        },
        mount(el, scope, parentScope, meta) {
            if (meta === void 0) {
                meta = {};
            }
            if (!el) throw new Error('Please provide DOM node to mount properly your template');
            if (this.el) this.unmount(scope);
            const { fragment, children, avoidDOMInjection } = meta;
            const { parentNode } = children ? children[0] : el;
            const isTemplateTag = isTemplate(el);
            const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;
            this.isTemplateTag = isTemplateTag;
            this.createDOM(el);
            if (this.dom) {
                this.fragment = fragment || this.dom.cloneNode(true);
            }
            this.el = this.isTemplateTag ? parentNode : el;
            this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null;
            if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment);
            this.bindings = this.bindingsData.map((binding) => create$1(this.el, binding, templateTagOffset));
            this.bindings.forEach((b) => b.mount(scope, parentScope));
            this.meta = meta;
            return this;
        },
        update(scope, parentScope) {
            this.bindings.forEach((b) => b.update(scope, parentScope));
            return this;
        },
        unmount(scope, parentScope, mustRemoveRoot) {
            if (this.el) {
                this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));
                switch (true) {
                    case this.el[IS_PURE_SYMBOL]:
                        break;
                    case this.children && mustRemoveRoot !== null:
                        clearChildren(this.children);
                        break;
                    case mustRemoveRoot === true:
                        removeChild(this.el);
                        break;
                    case mustRemoveRoot !== null:
                        cleanNode(this.el);
                        break;
                }
                this.el = null;
            }
            return this;
        },
        clone() {
            return Object.assign({}, this, {
                meta: {},
                el: null,
            });
        },
    });
    function create(html, bindings) {
        if (bindings === void 0) {
            bindings = [];
        }
        return Object.assign({}, TemplateChunk, {
            html,
            bindingsData: bindings,
        });
    }
    function noop$3() {
        return this;
    }
    function autobindMethods(source, methods) {
        methods.forEach((method) => {
            source[method] = source[method].bind(source);
        });
        return source;
    }
    function callOrAssign(source) {
        return isFunction$5(source)
            ? source.prototype && source.prototype.constructor
                ? new source()
                : source()
            : source;
    }
    function defineProperty(source, key, value, options) {
        if (options === void 0) {
            options = {};
        }
        Object.defineProperty(
            source,
            key,
            Object.assign(
                {
                    value,
                    enumerable: false,
                    writable: false,
                    configurable: true,
                },
                options,
            ),
        );
        return source;
    }
    function defineProperties(source, properties, options) {
        Object.entries(properties).forEach((_ref) => {
            let [key, value] = _ref;
            defineProperty(source, key, value, options);
        });
        return source;
    }
    function defineDefaults(source, defaults) {
        Object.entries(defaults).forEach((_ref2) => {
            let [key, value] = _ref2;
            if (!source[key]) source[key] = value;
        });
        return source;
    }
    function domToArray(els) {
        if (!Array.isArray(els)) {
            if (
                /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) &&
                typeof els.length === 'number'
            )
                return Array.from(els);
            else return [els];
        }
        return els;
    }
    function $(selector, ctx) {
        return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);
    }
    const normalize = (values) => (values.length === 1 ? values[0] : values);
    function parseNodes(els, name2, method) {
        const names = typeof name2 === 'string' ? [name2] : name2;
        return normalize(
            domToArray(els).map((el) => {
                return normalize(names.map((n) => el[method](n)));
            }),
        );
    }
    function set$2(els, name2, value) {
        const attrs =
            typeof name2 === 'object'
                ? name2
                : {
                      [name2]: value,
                  };
        const props = Object.keys(attrs);
        domToArray(els).forEach((el) => {
            props.forEach((prop) => el.setAttribute(prop, attrs[prop]));
        });
        return els;
    }
    function get$4(els, name2) {
        return parseNodes(els, name2, 'getAttribute');
    }
    const CSS_BY_NAME = new Map();
    const STYLE_NODE_SELECTOR = 'style[riot]';
    const getStyleNode = ((style) => {
        return () => {
            if (style) return style;
            style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');
            set$2(style, 'type', 'text/css');
            if (!style.parentNode) document.head.appendChild(style);
            return style;
        };
    })();
    var cssManager = {
        CSS_BY_NAME,
        add(name2, css) {
            if (!CSS_BY_NAME.has(name2)) {
                CSS_BY_NAME.set(name2, css);
                this.inject();
            }
            return this;
        },
        inject() {
            getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\n');
            return this;
        },
        remove(name2) {
            if (CSS_BY_NAME.has(name2)) {
                CSS_BY_NAME.delete(name2);
                this.inject();
            }
            return this;
        },
    };
    function curry(fn) {
        for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            acc[_key - 1] = arguments[_key];
        }
        return function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }
            args = [...acc, ...args];
            return args.length < fn.length ? curry(fn, ...args) : fn(...args);
        };
    }
    function getName(element) {
        return get$4(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
    }
    const COMPONENT_CORE_HELPERS = Object.freeze({
        $(selector) {
            return $(selector, this.root)[0];
        },
        $$(selector) {
            return $(selector, this.root);
        },
    });
    const PURE_COMPONENT_API = Object.freeze({
        [MOUNT_METHOD_KEY]: noop$3,
        [UPDATE_METHOD_KEY]: noop$3,
        [UNMOUNT_METHOD_KEY]: noop$3,
    });
    const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
        [SHOULD_UPDATE_KEY]: noop$3,
        [ON_BEFORE_MOUNT_KEY]: noop$3,
        [ON_MOUNTED_KEY]: noop$3,
        [ON_BEFORE_UPDATE_KEY]: noop$3,
        [ON_UPDATED_KEY]: noop$3,
        [ON_BEFORE_UNMOUNT_KEY]: noop$3,
        [ON_UNMOUNTED_KEY]: noop$3,
    });
    const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
        clone: noop$3,
        createDOM: noop$3,
    });
    const memoizedCreateComponent = memoize(createComponent);
    function evaluateInitialProps(element, initialProps) {
        if (initialProps === void 0) {
            initialProps = {};
        }
        return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
    }
    const bindDOMNodeToComponentObject = (node, component) => (node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component);
    function createCoreAPIMethods(mapFunction) {
        return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
            acc[method] = mapFunction(method);
            return acc;
        }, {});
    }
    function componentTemplateFactory(template, componentShell) {
        const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});
        return template(create, expressionTypes, bindingTypes, (name2) => {
            if (name2 === componentShell.name) return memoizedCreateComponent(componentShell);
            return components[name2] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name2);
        });
    }
    function createPureComponent(pureFactoryFunction, _ref) {
        let { slots, attributes, props, css, template } = _ref;
        if (template) panic('Pure components can not have html');
        if (css) panic('Pure components do not have css');
        const component = defineDefaults(
            pureFactoryFunction({
                slots,
                attributes,
                props,
            }),
            PURE_COMPONENT_API,
        );
        return createCoreAPIMethods(
            (method) =>
                function () {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    if (method === MOUNT_METHOD_KEY) {
                        const [el] = args;
                        el[IS_PURE_SYMBOL] = true;
                        bindDOMNodeToComponentObject(el, component);
                    }
                    component[method](...args);
                    return component;
                },
        );
    }
    function createComponent(componentShell) {
        const { css, template, exports, name: name2 } = componentShell;
        const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;
        return (_ref2) => {
            let { slots, attributes, props } = _ref2;
            if (exports && exports[IS_PURE_SYMBOL])
                return createPureComponent(exports, {
                    slots,
                    attributes,
                    props,
                    css,
                    template,
                });
            const componentAPI = callOrAssign(exports) || {};
            const component = defineComponent({
                css,
                template: templateFn,
                componentAPI,
                name: name2,
            })({
                slots,
                attributes,
                props,
            });
            return {
                mount(element, parentScope, state) {
                    return component.mount(element, state, parentScope);
                },
                update(parentScope, state) {
                    return component.update(state, parentScope);
                },
                unmount(preserveRoot) {
                    return component.unmount(preserveRoot);
                },
            };
        };
    }
    function defineComponent(_ref3) {
        let { css, template, componentAPI, name: name2 } = _ref3;
        if (css && name2) cssManager.add(name2, css);
        return curry(enhanceComponentAPI)(
            defineProperties(
                defineDefaults(
                    componentAPI,
                    Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
                        [PROPS_KEY]: {},
                        [STATE_KEY]: {},
                    }),
                ),
                Object.assign(
                    {
                        [SLOTS_KEY]: null,
                        [ROOT_KEY]: null,
                    },
                    COMPONENT_CORE_HELPERS,
                    {
                        name: name2,
                        css,
                        template,
                    },
                ),
            ),
        );
    }
    function createAttributeBindings(node, attributes) {
        if (attributes === void 0) {
            attributes = [];
        }
        const expressions = attributes.map((a) => create$4(node, a));
        const binding = {};
        return Object.assign(
            binding,
            Object.assign(
                {
                    expressions,
                },
                createCoreAPIMethods((method) => (scope) => {
                    expressions.forEach((e) => e[method](scope));
                    return binding;
                }),
            ),
        );
    }
    function createSubcomponents(components) {
        if (components === void 0) {
            components = {};
        }
        return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {
            let [key, value] = _ref4;
            acc[camelToDashCase(key)] = createComponent(value);
            return acc;
        }, {});
    }
    function runPlugins(component) {
        return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);
    }
    function computeState(oldState, newState) {
        return Object.assign({}, oldState, callOrAssign(newState));
    }
    function addCssHook(element, name2) {
        if (getName(element) !== name2) {
            set$2(element, IS_DIRECTIVE, name2);
        }
    }
    function enhanceComponentAPI(component, _ref5) {
        let { slots, attributes, props } = _ref5;
        return autobindMethods(
            runPlugins(
                defineProperties(isObject$6(component) ? Object.create(component) : component, {
                    mount(element, state, parentScope) {
                        if (state === void 0) {
                            state = {};
                        }
                        this[PARENT_KEY_SYMBOL] = parentScope;
                        this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
                        defineProperty(
                            this,
                            PROPS_KEY,
                            Object.freeze(
                                Object.assign(
                                    {},
                                    evaluateInitialProps(element, props),
                                    evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions),
                                ),
                            ),
                        );
                        this[STATE_KEY] = computeState(this[STATE_KEY], state);
                        this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();
                        bindDOMNodeToComponentObject(element, this);
                        component.name && addCssHook(element, component.name);
                        defineProperty(this, ROOT_KEY, element);
                        defineProperty(this, SLOTS_KEY, slots);
                        this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
                        this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        return this;
                    },
                    update(state, parentScope) {
                        if (state === void 0) {
                            state = {};
                        }
                        if (parentScope) {
                            this[PARENT_KEY_SYMBOL] = parentScope;
                            this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
                        }
                        const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
                        if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;
                        defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
                        this[STATE_KEY] = computeState(this[STATE_KEY], state);
                        this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        if (!this[IS_COMPONENT_UPDATING]) {
                            this[IS_COMPONENT_UPDATING] = true;
                            this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
                        }
                        this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        this[IS_COMPONENT_UPDATING] = false;
                        return this;
                    },
                    unmount(preserveRoot) {
                        this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        this[ATTRIBUTES_KEY_SYMBOL].unmount();
                        this[TEMPLATE_KEY_SYMBOL].unmount(
                            this,
                            this[PARENT_KEY_SYMBOL],
                            preserveRoot === null ? null : !preserveRoot,
                        );
                        this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
                        return this;
                    },
                }),
            ),
            Object.keys(component).filter((prop) => isFunction$5(component[prop])),
        );
    }
    function mountComponent(element, initialProps, componentName) {
        const name2 = componentName || getName(element);
        if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name2)) panic(`The component named "${name2}" was never registered`);
        const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name2)({
            props: initialProps,
        });
        return component.mount(element);
    }
    const { DOM_COMPONENT_INSTANCE_PROPERTY, COMPONENTS_IMPLEMENTATION_MAP, PLUGINS_SET } = globals;
    function register(name2, _ref) {
        let { css, template, exports } = _ref;
        if (COMPONENTS_IMPLEMENTATION_MAP.has(name2)) panic(`The component "${name2}" was already registered`);
        COMPONENTS_IMPLEMENTATION_MAP.set(
            name2,
            createComponent({
                name: name2,
                css,
                template,
                exports,
            }),
        );
        return COMPONENTS_IMPLEMENTATION_MAP;
    }
    function mount(selector, initialProps, name2) {
        return $(selector).map((element) => mountComponent(element, initialProps, name2));
    }
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
        if (!getRandomValues) {
            getRandomValues =
                (typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                (typeof msCrypto !== 'undefined' &&
                    typeof msCrypto.getRandomValues === 'function' &&
                    msCrypto.getRandomValues.bind(msCrypto));
            if (!getRandomValues) {
                throw new Error(
                    'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported',
                );
            }
        }
        return getRandomValues(rnds8);
    }
    var REGEX =
        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function validate$1(uuid) {
        return typeof uuid === 'string' && REGEX.test(uuid);
    }
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify$4(arr) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var uuid = (
            byteToHex[arr[offset + 0]] +
            byteToHex[arr[offset + 1]] +
            byteToHex[arr[offset + 2]] +
            byteToHex[arr[offset + 3]] +
            '-' +
            byteToHex[arr[offset + 4]] +
            byteToHex[arr[offset + 5]] +
            '-' +
            byteToHex[arr[offset + 6]] +
            byteToHex[arr[offset + 7]] +
            '-' +
            byteToHex[arr[offset + 8]] +
            byteToHex[arr[offset + 9]] +
            '-' +
            byteToHex[arr[offset + 10]] +
            byteToHex[arr[offset + 11]] +
            byteToHex[arr[offset + 12]] +
            byteToHex[arr[offset + 13]] +
            byteToHex[arr[offset + 14]] +
            byteToHex[arr[offset + 15]]
        ).toLowerCase();
        if (!validate$1(uuid)) {
            throw TypeError('Stringified UUID is invalid');
        }
        return uuid;
    }
    function v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || rng)();
        rnds[6] = (rnds[6] & 15) | 64;
        rnds[8] = (rnds[8] & 63) | 128;
        if (buf) {
            offset = offset || 0;
            for (var i = 0; i < 16; ++i) {
                buf[offset + i] = rnds[i];
            }
            return buf;
        }
        return stringify$4(rnds);
    }
    function getMethods(toCheck) {
        let props = [];
        let obj = toCheck;
        do {
            const _props = Object.getOwnPropertyNames(obj);
            if (_props.indexOf('__defineGetter__') !== -1) continue;
            props = props.concat(_props);
        } while ((obj = Object.getPrototypeOf(obj)));
        return props.sort().filter(function (e, i, arr) {
            if (e != arr[i + 1] && typeof toCheck[e] == 'function') return true;
        });
    }
    var commonjsGlobal$1 =
        typeof globalThis !== 'undefined'
            ? globalThis
            : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
            ? global
            : typeof self !== 'undefined'
            ? self
            : {};
    function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }
    function getAugmentedNamespace$1(n) {
        if (n.__esModule) return n;
        var a = Object.defineProperty({}, '__esModule', { value: true });
        Object.keys(n).forEach(function (k) {
            var d = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(
                a,
                k,
                d.get
                    ? d
                    : {
                          enumerable: true,
                          get: function () {
                              return n[k];
                          },
                      },
            );
        });
        return a;
    }
    var isClass = { exports: {} };
    (function (module2, exports) {
        (function (root) {
            const toString = Function.prototype.toString;
            function fnBody(fn) {
                return toString
                    .call(fn)
                    .replace(/^[^{]*{\s*/, '')
                    .replace(/\s*}[^}]*$/, '');
            }
            function isClass(fn) {
                if (typeof fn !== 'function') {
                    return false;
                }
                if (/^class[\s{]/.test(toString.call(fn))) {
                    return true;
                }
                const body = fnBody(fn);
                return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
            }
            {
                if (module2.exports) {
                    exports = module2.exports = isClass;
                }
                exports.isClass = isClass;
            }
        })();
    })(isClass, isClass.exports);
    var __isClass = isClass.exports;
    function cls$1(cls) {
        if (!Array.isArray(cls)) cls = [cls];
        for (let i = 0; i < cls.length; i++) {
            if (!__isClass(cls[i])) return false;
        }
        return true;
    }
    const fn$7 = function (cls, settings = {}) {
        const stack = {};
        if (!cls$1(cls)) {
            cls = cls.constructor;
        }
        if (settings.includeBaseClass === true) {
            stack[cls.name] = cls;
        }
        let baseClass = cls;
        while (baseClass) {
            const newBaseClass = Object.getPrototypeOf(baseClass);
            if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
                stack[newBaseClass.name] = newBaseClass;
                baseClass = newBaseClass;
            } else {
                break;
            }
        }
        return stack;
    };
    function plainObject$3(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name !== 'Object') return false;
        if (Object.prototype.toString.call(object) !== '[object Object]') return false;
        if (object !== Object(object)) return false;
        return true;
    }
    function unique(array) {
        const a = array.concat();
        for (let i = 0; i < a.length; ++i) {
            for (let j = i + 1; j < a.length; ++j) {
                if (a[i] === a[j]) a.splice(j--, 1);
            }
        }
        return a;
    }
    var lodash_clone = { exports: {} };
    (function (module2, exports) {
        var LARGE_ARRAY_SIZE = 200;
        var HASH_UNDEFINED = '__lodash_hash_undefined__';
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            weakMapTag = '[object WeakMap]';
        var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reFlags = /\w*$/;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var cloneableTags = {};
        cloneableTags[argsTag] =
            cloneableTags[arrayTag] =
            cloneableTags[arrayBufferTag] =
            cloneableTags[dataViewTag] =
            cloneableTags[boolTag] =
            cloneableTags[dateTag] =
            cloneableTags[float32Tag] =
            cloneableTags[float64Tag] =
            cloneableTags[int8Tag] =
            cloneableTags[int16Tag] =
            cloneableTags[int32Tag] =
            cloneableTags[mapTag] =
            cloneableTags[numberTag] =
            cloneableTags[objectTag] =
            cloneableTags[regexpTag] =
            cloneableTags[setTag] =
            cloneableTags[stringTag] =
            cloneableTags[symbolTag] =
            cloneableTags[uint8Tag] =
            cloneableTags[uint8ClampedTag] =
            cloneableTags[uint16Tag] =
            cloneableTags[uint32Tag] =
                true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var freeGlobal =
            typeof commonjsGlobal$1 == 'object' &&
            commonjsGlobal$1 &&
            commonjsGlobal$1.Object === Object &&
            commonjsGlobal$1;
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function('return this')();
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        function addMapEntry(map, pair) {
            map.set(pair[0], pair[1]);
            return map;
        }
        function addSetEntry(set, value) {
            set.add(value);
            return set;
        }
        function arrayEach(array, iteratee) {
            var index = -1,
                length = array ? array.length : 0;
            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayPush(array, values) {
            var index = -1,
                length = values.length,
                offset = array.length;
            while (++index < length) {
                array[offset + index] = values[index];
            }
            return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1,
                length = array ? array.length : 0;
            if (initAccum && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        function baseTimes(n, iteratee) {
            var index = -1,
                result = Array(n);
            while (++index < n) {
                result[index] = iteratee(index);
            }
            return result;
        }
        function getValue(object, key) {
            return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
            var result = false;
            if (value != null && typeof value.toString != 'function') {
                try {
                    result = !!(value + '');
                } catch (e) {}
            }
            return result;
        }
        function mapToArray(map) {
            var index = -1,
                result = Array(map.size);
            map.forEach(function (value, key) {
                result[++index] = [key, value];
            });
            return result;
        }
        function overArg(func, transform) {
            return function (arg) {
                return func(transform(arg));
            };
        }
        function setToArray(set) {
            var index = -1,
                result = Array(set.size);
            set.forEach(function (value) {
                result[++index] = value;
            });
            return result;
        }
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;
        var coreJsData = root['__core-js_shared__'];
        var maskSrcKey = (function () {
            var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
        })();
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp(
            '^' +
                funcToString
                    .call(hasOwnProperty)
                    .replace(reRegExpChar, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
                '$',
        );
        var Buffer2 = moduleExports ? root.Buffer : void 0,
            Symbol2 = root.Symbol,
            Uint8Array2 = root.Uint8Array,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice;
        var nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0,
            nativeKeys = overArg(Object.keys, Object);
        var DataView = getNative(root, 'DataView'),
            Map2 = getNative(root, 'Map'),
            Promise2 = getNative(root, 'Promise'),
            Set2 = getNative(root, 'Set'),
            WeakMap2 = getNative(root, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map2),
            promiseCtorString = toSource(Promise2),
            setCtorString = toSource(Set2),
            weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0,
            symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function Hash(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [];
        }
        function listCacheDelete(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) {
                return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
                data.pop();
            } else {
                splice.call(data, index, 1);
            }
            return true;
        }
        function listCacheGet(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) {
                data.push([key, value]);
            } else {
                data[index][1] = value;
            }
            return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapCacheClear() {
            this.__data__ = {
                hash: new Hash(),
                map: new (Map2 || ListCache)(),
                string: new Hash(),
            };
        }
        function mapCacheDelete(key) {
            return getMapData(this, key)['delete'](key);
        }
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function Stack(entries) {
            this.__data__ = new ListCache(entries);
        }
        function stackClear() {
            this.__data__ = new ListCache();
        }
        function stackDelete(key) {
            return this.__data__['delete'](key);
        }
        function stackGet(key) {
            return this.__data__.get(key);
        }
        function stackHas(key) {
            return this.__data__.has(key);
        }
        function stackSet(key, value) {
            var cache = this.__data__;
            if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    return this;
                }
                cache = this.__data__ = new MapCache(pairs);
            }
            cache.set(key, value);
            return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
            var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
            var length = result.length,
                skipIndexes = !!length;
            for (var key in value) {
                if (
                    (inherited || hasOwnProperty.call(value, key)) &&
                    !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                    result.push(key);
                }
            }
            return result;
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === void 0 && !(key in object))) {
                object[key] = value;
            }
        }
        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
                if (eq(array[length][0], key)) {
                    return length;
                }
            }
            return -1;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== void 0) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return copyArray(value, result);
                }
            } else {
                var tag = getTag(value),
                    isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                    if (isHostObject(value)) {
                        return object ? value : {};
                    }
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return copySymbols(value, baseAssign(result, value));
                    }
                } else {
                    if (!cloneableTags[tag]) {
                        return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
                return stacked;
            }
            stack.set(value, result);
            if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
            }
            arrayEach(props || value, function (subValue, key2) {
                if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                }
                assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
            });
            return result;
        }
        function baseCreate(proto) {
            return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
            return objectToString.call(value);
        }
        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
                return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function baseKeys(object) {
            if (!isPrototype(object)) {
                return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                }
            }
            return result;
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
                return buffer.slice();
            }
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
            return result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function copyArray(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
                length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                assignValue(object, key, newValue === void 0 ? source[key] : newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
        }
        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
        var getTag = baseGetTag;
        if (
            (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map2 && getTag(new Map2()) != mapTag) ||
            (Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
            (Set2 && getTag(new Set2()) != setTag) ||
            (WeakMap2 && getTag(new WeakMap2()) != weakMapTag)
        ) {
            getTag = function (value) {
                var result = objectToString.call(value),
                    Ctor = result == objectTag ? value.constructor : void 0,
                    ctorString = Ctor ? toSource(Ctor) : void 0;
                if (ctorString) {
                    switch (ctorString) {
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag;
                    }
                }
                return result;
            };
        }
        function initCloneArray(array) {
            var length = array.length,
                result = array.constructor(length);
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object)
                ? baseCreate(getPrototype(object))
                : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
                case arrayBufferTag:
                    return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                    return new Ctor(+object);
                case dataViewTag:
                    return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                    return new Ctor(object);
                case regexpTag:
                    return cloneRegExp(object);
                case setTag:
                    return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                    return cloneSymbol(object);
            }
        }
        function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                value > -1 &&
                value % 1 == 0 &&
                value < length
            );
        }
        function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
                ? value !== '__proto__'
                : value === null;
        }
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor,
                proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
            return value === proto;
        }
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + '';
                } catch (e) {}
            }
            return '';
        }
        function clone(value) {
            return baseClone(value, false, true);
        }
        function eq(value, other) {
            return value === other || (value !== value && other !== other);
        }
        function isArguments(value) {
            return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag)
            );
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
        }
        function isObjectLike(value) {
            return !!value && typeof value == 'object';
        }
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function stubArray() {
            return [];
        }
        function stubFalse() {
            return false;
        }
        module2.exports = clone;
    })(lodash_clone, lodash_clone.exports);
    var __clone = lodash_clone.exports;
    var lodash_clonedeep = { exports: {} };
    (function (module2, exports) {
        var LARGE_ARRAY_SIZE = 200;
        var HASH_UNDEFINED = '__lodash_hash_undefined__';
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            weakMapTag = '[object WeakMap]';
        var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reFlags = /\w*$/;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var cloneableTags = {};
        cloneableTags[argsTag] =
            cloneableTags[arrayTag] =
            cloneableTags[arrayBufferTag] =
            cloneableTags[dataViewTag] =
            cloneableTags[boolTag] =
            cloneableTags[dateTag] =
            cloneableTags[float32Tag] =
            cloneableTags[float64Tag] =
            cloneableTags[int8Tag] =
            cloneableTags[int16Tag] =
            cloneableTags[int32Tag] =
            cloneableTags[mapTag] =
            cloneableTags[numberTag] =
            cloneableTags[objectTag] =
            cloneableTags[regexpTag] =
            cloneableTags[setTag] =
            cloneableTags[stringTag] =
            cloneableTags[symbolTag] =
            cloneableTags[uint8Tag] =
            cloneableTags[uint8ClampedTag] =
            cloneableTags[uint16Tag] =
            cloneableTags[uint32Tag] =
                true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var freeGlobal =
            typeof commonjsGlobal$1 == 'object' &&
            commonjsGlobal$1 &&
            commonjsGlobal$1.Object === Object &&
            commonjsGlobal$1;
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function('return this')();
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        function addMapEntry(map, pair) {
            map.set(pair[0], pair[1]);
            return map;
        }
        function addSetEntry(set, value) {
            set.add(value);
            return set;
        }
        function arrayEach(array, iteratee) {
            var index = -1,
                length = array ? array.length : 0;
            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayPush(array, values) {
            var index = -1,
                length = values.length,
                offset = array.length;
            while (++index < length) {
                array[offset + index] = values[index];
            }
            return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1,
                length = array ? array.length : 0;
            if (initAccum && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        function baseTimes(n, iteratee) {
            var index = -1,
                result = Array(n);
            while (++index < n) {
                result[index] = iteratee(index);
            }
            return result;
        }
        function getValue(object, key) {
            return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
            var result = false;
            if (value != null && typeof value.toString != 'function') {
                try {
                    result = !!(value + '');
                } catch (e) {}
            }
            return result;
        }
        function mapToArray(map) {
            var index = -1,
                result = Array(map.size);
            map.forEach(function (value, key) {
                result[++index] = [key, value];
            });
            return result;
        }
        function overArg(func, transform) {
            return function (arg) {
                return func(transform(arg));
            };
        }
        function setToArray(set) {
            var index = -1,
                result = Array(set.size);
            set.forEach(function (value) {
                result[++index] = value;
            });
            return result;
        }
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;
        var coreJsData = root['__core-js_shared__'];
        var maskSrcKey = (function () {
            var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
        })();
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp(
            '^' +
                funcToString
                    .call(hasOwnProperty)
                    .replace(reRegExpChar, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
                '$',
        );
        var Buffer2 = moduleExports ? root.Buffer : void 0,
            Symbol2 = root.Symbol,
            Uint8Array2 = root.Uint8Array,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice;
        var nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0,
            nativeKeys = overArg(Object.keys, Object);
        var DataView = getNative(root, 'DataView'),
            Map2 = getNative(root, 'Map'),
            Promise2 = getNative(root, 'Promise'),
            Set2 = getNative(root, 'Set'),
            WeakMap2 = getNative(root, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map2),
            promiseCtorString = toSource(Promise2),
            setCtorString = toSource(Set2),
            weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0,
            symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function Hash(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [];
        }
        function listCacheDelete(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) {
                return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
                data.pop();
            } else {
                splice.call(data, index, 1);
            }
            return true;
        }
        function listCacheGet(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) {
                data.push([key, value]);
            } else {
                data[index][1] = value;
            }
            return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapCacheClear() {
            this.__data__ = {
                hash: new Hash(),
                map: new (Map2 || ListCache)(),
                string: new Hash(),
            };
        }
        function mapCacheDelete(key) {
            return getMapData(this, key)['delete'](key);
        }
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function Stack(entries) {
            this.__data__ = new ListCache(entries);
        }
        function stackClear() {
            this.__data__ = new ListCache();
        }
        function stackDelete(key) {
            return this.__data__['delete'](key);
        }
        function stackGet(key) {
            return this.__data__.get(key);
        }
        function stackHas(key) {
            return this.__data__.has(key);
        }
        function stackSet(key, value) {
            var cache = this.__data__;
            if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    return this;
                }
                cache = this.__data__ = new MapCache(pairs);
            }
            cache.set(key, value);
            return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
            var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
            var length = result.length,
                skipIndexes = !!length;
            for (var key in value) {
                if (
                    (inherited || hasOwnProperty.call(value, key)) &&
                    !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                    result.push(key);
                }
            }
            return result;
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === void 0 && !(key in object))) {
                object[key] = value;
            }
        }
        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
                if (eq(array[length][0], key)) {
                    return length;
                }
            }
            return -1;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== void 0) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return copyArray(value, result);
                }
            } else {
                var tag = getTag(value),
                    isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                    if (isHostObject(value)) {
                        return object ? value : {};
                    }
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return copySymbols(value, baseAssign(result, value));
                    }
                } else {
                    if (!cloneableTags[tag]) {
                        return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
                return stacked;
            }
            stack.set(value, result);
            if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
            }
            arrayEach(props || value, function (subValue, key2) {
                if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                }
                assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
            });
            return result;
        }
        function baseCreate(proto) {
            return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
            return objectToString.call(value);
        }
        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
                return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function baseKeys(object) {
            if (!isPrototype(object)) {
                return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                }
            }
            return result;
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
                return buffer.slice();
            }
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
            return result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function copyArray(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
                length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                assignValue(object, key, newValue === void 0 ? source[key] : newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
        }
        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
        var getTag = baseGetTag;
        if (
            (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map2 && getTag(new Map2()) != mapTag) ||
            (Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
            (Set2 && getTag(new Set2()) != setTag) ||
            (WeakMap2 && getTag(new WeakMap2()) != weakMapTag)
        ) {
            getTag = function (value) {
                var result = objectToString.call(value),
                    Ctor = result == objectTag ? value.constructor : void 0,
                    ctorString = Ctor ? toSource(Ctor) : void 0;
                if (ctorString) {
                    switch (ctorString) {
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag;
                    }
                }
                return result;
            };
        }
        function initCloneArray(array) {
            var length = array.length,
                result = array.constructor(length);
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object)
                ? baseCreate(getPrototype(object))
                : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
                case arrayBufferTag:
                    return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                    return new Ctor(+object);
                case dataViewTag:
                    return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                    return new Ctor(object);
                case regexpTag:
                    return cloneRegExp(object);
                case setTag:
                    return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                    return cloneSymbol(object);
            }
        }
        function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                value > -1 &&
                value % 1 == 0 &&
                value < length
            );
        }
        function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
                ? value !== '__proto__'
                : value === null;
        }
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor,
                proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
            return value === proto;
        }
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + '';
                } catch (e) {}
            }
            return '';
        }
        function cloneDeep(value) {
            return baseClone(value, true, true);
        }
        function eq(value, other) {
            return value === other || (value !== value && other !== other);
        }
        function isArguments(value) {
            return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag)
            );
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
        }
        function isObjectLike(value) {
            return !!value && typeof value == 'object';
        }
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function stubArray() {
            return [];
        }
        function stubFalse() {
            return false;
        }
        module2.exports = cloneDeep;
    })(lodash_clonedeep, lodash_clonedeep.exports);
    var __deepClone = lodash_clonedeep.exports;
    function clone$4(object, settings = {}) {
        settings = Object.assign({ deep: false }, settings);
        if (settings.deep) {
            return __deepClone(object);
        }
        return __clone(object);
    }
    function deepAssign(referenceObj, ...objects) {
        const settings = {
            array: false,
            object: true,
            cloneChilds: true,
        };
        function merge(refObj, mixWithObj) {
            for (const key of Object.keys(mixWithObj)) {
                if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
                    const newArray = unique([...refObj[key], ...mixWithObj[key]]);
                    refObj[key] = newArray;
                    continue;
                }
                if (settings.object === true && plainObject$3(refObj[key]) && plainObject$3(mixWithObj[key])) {
                    refObj[key] = merge(refObj[key], mixWithObj[key]);
                    continue;
                }
                if (plainObject$3(mixWithObj[key]) && settings.cloneChilds) {
                    refObj[key] = clone$4(mixWithObj[key], {
                        deep: true,
                    });
                } else {
                    refObj[key] = mixWithObj[key];
                }
            }
            return refObj;
        }
        const potentialSettingsObj = objects[objects.length - 1] || {};
        if (
            (potentialSettingsObj.array && typeof potentialSettingsObj.array === 'boolean') ||
            (potentialSettingsObj.object && typeof potentialSettingsObj.object === 'boolean')
        ) {
            if (potentialSettingsObj.array !== void 0) settings.array = potentialSettingsObj.array;
            if (potentialSettingsObj.object !== void 0) settings.object = potentialSettingsObj.object;
            objects.pop();
        }
        for (let i = 0; i < objects.length; i++) {
            const toMergeObj = objects[i] || {};
            merge(referenceObj, toMergeObj);
        }
        return referenceObj;
    }
    function deepMerge(...args) {
        function merge(firstObj, secondObj) {
            const newObj = {};
            if (!firstObj && secondObj) return secondObj;
            if (!secondObj && firstObj) return firstObj;
            if (!firstObj && !secondObj) return {};
            const firstProps = Object.getOwnPropertyNames(firstObj);
            firstProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(firstObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else {
                    newObj[key] = firstObj[key];
                }
            });
            const secondProps = Object.getOwnPropertyNames(secondObj);
            secondProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(secondObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else if (plainObject$3(newObj[key]) && plainObject$3(secondObj[key])) {
                    newObj[key] = merge(newObj[key], secondObj[key]);
                } else {
                    newObj[key] = secondObj[key];
                }
            });
            return newObj;
        }
        let currentObj = {};
        for (let i = 0; i < args.length; i++) {
            const toMergeObj = args[i];
            currentObj = merge(currentObj, toMergeObj);
        }
        return currentObj;
    }
    function unquote(string, quotesToRemove = ['"', "'", '\u201D', '`']) {
        string = string.trim();
        quotesToRemove.forEach((quote) => {
            if (string.substr(0, 1) === quote && string.substr(-1) === quote) {
                string = string.substr(1);
                string = string.substr(0, string.length - 1);
                return;
            }
        });
        return string;
    }
    function get$3(obj, path, settings = {}) {
        settings = Object.assign({}, settings);
        if (obj[path] !== void 0) return obj[path];
        if (!path || path === '' || path === '.') return obj;
        path = path.replace(/\[(\w+)\]/g, '.$1');
        path = path.replace(/^\./, '');
        let potentialPaths = [path.replace(/\?/gm, '')];
        const parts = path.split('.');
        for (let i = parts.length - 1; i >= 0; i--) {
            const part = parts[i];
            if (part.match(/\?$/)) {
                const before = parts.slice(0, i);
                const after = parts.slice(i + 1);
                potentialPaths.push([...before, ...after].join('.'));
                potentialPaths.push([...before, ...after.filter((a) => !a.match(/\?$/))].join('.'));
            }
        }
        potentialPaths = unique(potentialPaths.map((s) => s.replace(/\?/gm, '')));
        for (let i = 0; i < potentialPaths.length; i++) {
            const path2 = potentialPaths[i];
            const result = __get(obj, path2, settings);
            if (result !== void 0) return result;
        }
    }
    function __get(obj, path, settings = {}) {
        settings = Object.assign({}, settings);
        if (obj[path] !== void 0) return obj[path];
        if (!path || path === '' || path === '.') return obj;
        const a = path.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => unquote(p));
        let o = obj;
        while (a.length) {
            const n = a.shift().replace(/\?$/, '');
            if (typeof o !== 'object' || !(n in o)) {
                return;
            }
            o = o[n];
        }
        return o;
    }
    var md5$3 = { exports: {} };
    var core$3 = { exports: {} };
    var __viteBrowserExternal_crypto$2 = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_crypto$3 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_crypto$2,
    });
    var require$$0$6 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_crypto$3);
    (function (module2, exports) {
        (function (root, factory) {
            {
                module2.exports = factory();
            }
        })(commonjsGlobal$1, function () {
            var CryptoJS =
                CryptoJS ||
                (function (Math2, undefined$1) {
                    var crypto2;
                    if (typeof window !== 'undefined' && window.crypto) {
                        crypto2 = window.crypto;
                    }
                    if (!crypto2 && typeof window !== 'undefined' && window.msCrypto) {
                        crypto2 = window.msCrypto;
                    }
                    if (!crypto2 && typeof commonjsGlobal$1 !== 'undefined' && commonjsGlobal$1.crypto) {
                        crypto2 = commonjsGlobal$1.crypto;
                    }
                    if (!crypto2 && typeof require === 'function') {
                        try {
                            crypto2 = require$$0$6;
                        } catch (err) {}
                    }
                    var cryptoSecureRandomInt = function () {
                        if (crypto2) {
                            if (typeof crypto2.getRandomValues === 'function') {
                                try {
                                    return crypto2.getRandomValues(new Uint32Array(1))[0];
                                } catch (err) {}
                            }
                            if (typeof crypto2.randomBytes === 'function') {
                                try {
                                    return crypto2.randomBytes(4).readInt32LE();
                                } catch (err) {}
                            }
                        }
                        throw new Error('Native crypto module could not be used to get secure random number.');
                    };
                    var create =
                        Object.create ||
                        (function () {
                            function F() {}
                            return function (obj) {
                                var subtype;
                                F.prototype = obj;
                                subtype = new F();
                                F.prototype = null;
                                return subtype;
                            };
                        })();
                    var C = {};
                    var C_lib = (C.lib = {});
                    var Base = (C_lib.Base = (function () {
                        return {
                            extend: function (overrides) {
                                var subtype = create(this);
                                if (overrides) {
                                    subtype.mixIn(overrides);
                                }
                                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                                    subtype.init = function () {
                                        subtype.$super.init.apply(this, arguments);
                                    };
                                }
                                subtype.init.prototype = subtype;
                                subtype.$super = this;
                                return subtype;
                            },
                            create: function () {
                                var instance = this.extend();
                                instance.init.apply(instance, arguments);
                                return instance;
                            },
                            init: function () {},
                            mixIn: function (properties) {
                                for (var propertyName in properties) {
                                    if (properties.hasOwnProperty(propertyName)) {
                                        this[propertyName] = properties[propertyName];
                                    }
                                }
                                if (properties.hasOwnProperty('toString')) {
                                    this.toString = properties.toString;
                                }
                            },
                            clone: function () {
                                return this.init.prototype.extend(this);
                            },
                        };
                    })());
                    var WordArray = (C_lib.WordArray = Base.extend({
                        init: function (words, sigBytes) {
                            words = this.words = words || [];
                            if (sigBytes != undefined$1) {
                                this.sigBytes = sigBytes;
                            } else {
                                this.sigBytes = words.length * 4;
                            }
                        },
                        toString: function (encoder) {
                            return (encoder || Hex).stringify(this);
                        },
                        concat: function (wordArray) {
                            var thisWords = this.words;
                            var thatWords = wordArray.words;
                            var thisSigBytes = this.sigBytes;
                            var thatSigBytes = wordArray.sigBytes;
                            this.clamp();
                            if (thisSigBytes % 4) {
                                for (var i = 0; i < thatSigBytes; i++) {
                                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                    thisWords[(thisSigBytes + i) >>> 2] |=
                                        thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                                }
                            } else {
                                for (var i = 0; i < thatSigBytes; i += 4) {
                                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                                }
                            }
                            this.sigBytes += thatSigBytes;
                            return this;
                        },
                        clamp: function () {
                            var words = this.words;
                            var sigBytes = this.sigBytes;
                            words[sigBytes >>> 2] &= 4294967295 << (32 - (sigBytes % 4) * 8);
                            words.length = Math2.ceil(sigBytes / 4);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone.words = this.words.slice(0);
                            return clone;
                        },
                        random: function (nBytes) {
                            var words = [];
                            for (var i = 0; i < nBytes; i += 4) {
                                words.push(cryptoSecureRandomInt());
                            }
                            return new WordArray.init(words, nBytes);
                        },
                    }));
                    var C_enc = (C.enc = {});
                    var Hex = (C_enc.Hex = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var hexChars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                hexChars.push((bite >>> 4).toString(16));
                                hexChars.push((bite & 15).toString(16));
                            }
                            return hexChars.join('');
                        },
                        parse: function (hexStr) {
                            var hexStrLength = hexStr.length;
                            var words = [];
                            for (var i = 0; i < hexStrLength; i += 2) {
                                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                            }
                            return new WordArray.init(words, hexStrLength / 2);
                        },
                    });
                    var Latin1 = (C_enc.Latin1 = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var latin1Chars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                latin1Chars.push(String.fromCharCode(bite));
                            }
                            return latin1Chars.join('');
                        },
                        parse: function (latin1Str) {
                            var latin1StrLength = latin1Str.length;
                            var words = [];
                            for (var i = 0; i < latin1StrLength; i++) {
                                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << (24 - (i % 4) * 8);
                            }
                            return new WordArray.init(words, latin1StrLength);
                        },
                    });
                    var Utf8 = (C_enc.Utf8 = {
                        stringify: function (wordArray) {
                            try {
                                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                            } catch (e) {
                                throw new Error('Malformed UTF-8 data');
                            }
                        },
                        parse: function (utf8Str) {
                            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                        },
                    });
                    var BufferedBlockAlgorithm = (C_lib.BufferedBlockAlgorithm = Base.extend({
                        reset: function () {
                            this._data = new WordArray.init();
                            this._nDataBytes = 0;
                        },
                        _append: function (data) {
                            if (typeof data == 'string') {
                                data = Utf8.parse(data);
                            }
                            this._data.concat(data);
                            this._nDataBytes += data.sigBytes;
                        },
                        _process: function (doFlush) {
                            var processedWords;
                            var data = this._data;
                            var dataWords = data.words;
                            var dataSigBytes = data.sigBytes;
                            var blockSize = this.blockSize;
                            var blockSizeBytes = blockSize * 4;
                            var nBlocksReady = dataSigBytes / blockSizeBytes;
                            if (doFlush) {
                                nBlocksReady = Math2.ceil(nBlocksReady);
                            } else {
                                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                            }
                            var nWordsReady = nBlocksReady * blockSize;
                            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                            if (nWordsReady) {
                                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                                    this._doProcessBlock(dataWords, offset);
                                }
                                processedWords = dataWords.splice(0, nWordsReady);
                                data.sigBytes -= nBytesReady;
                            }
                            return new WordArray.init(processedWords, nBytesReady);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone._data = this._data.clone();
                            return clone;
                        },
                        _minBufferSize: 0,
                    }));
                    C_lib.Hasher = BufferedBlockAlgorithm.extend({
                        cfg: Base.extend(),
                        init: function (cfg) {
                            this.cfg = this.cfg.extend(cfg);
                            this.reset();
                        },
                        reset: function () {
                            BufferedBlockAlgorithm.reset.call(this);
                            this._doReset();
                        },
                        update: function (messageUpdate) {
                            this._append(messageUpdate);
                            this._process();
                            return this;
                        },
                        finalize: function (messageUpdate) {
                            if (messageUpdate) {
                                this._append(messageUpdate);
                            }
                            var hash = this._doFinalize();
                            return hash;
                        },
                        blockSize: 512 / 32,
                        _createHelper: function (hasher) {
                            return function (message, cfg) {
                                return new hasher.init(cfg).finalize(message);
                            };
                        },
                        _createHmacHelper: function (hasher) {
                            return function (message, key) {
                                return new C_algo.HMAC.init(hasher, key).finalize(message);
                            };
                        },
                    });
                    var C_algo = (C.algo = {});
                    return C;
                })(Math);
            return CryptoJS;
        });
    })(core$3);
    (function (module2, exports) {
        (function (root, factory) {
            {
                module2.exports = factory(core$3.exports);
            }
        })(commonjsGlobal$1, function (CryptoJS) {
            (function (Math2) {
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;
                var T = [];
                (function () {
                    for (var i = 0; i < 64; i++) {
                        T[i] = (Math2.abs(Math2.sin(i + 1)) * 4294967296) | 0;
                    }
                })();
                var MD5 = (C_algo.MD5 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
                    },
                    _doProcessBlock: function (M, offset) {
                        for (var i = 0; i < 16; i++) {
                            var offset_i = offset + i;
                            var M_offset_i = M[offset_i];
                            M[offset_i] =
                                (((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) |
                                (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360);
                        }
                        var H = this._hash.words;
                        var M_offset_0 = M[offset + 0];
                        var M_offset_1 = M[offset + 1];
                        var M_offset_2 = M[offset + 2];
                        var M_offset_3 = M[offset + 3];
                        var M_offset_4 = M[offset + 4];
                        var M_offset_5 = M[offset + 5];
                        var M_offset_6 = M[offset + 6];
                        var M_offset_7 = M[offset + 7];
                        var M_offset_8 = M[offset + 8];
                        var M_offset_9 = M[offset + 9];
                        var M_offset_10 = M[offset + 10];
                        var M_offset_11 = M[offset + 11];
                        var M_offset_12 = M[offset + 12];
                        var M_offset_13 = M[offset + 13];
                        var M_offset_14 = M[offset + 14];
                        var M_offset_15 = M[offset + 15];
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                        a = II(a, b, c, d, M_offset_0, 6, T[48]);
                        d = II(d, a, b, c, M_offset_7, 10, T[49]);
                        c = II(c, d, a, b, M_offset_14, 15, T[50]);
                        b = II(b, c, d, a, M_offset_5, 21, T[51]);
                        a = II(a, b, c, d, M_offset_12, 6, T[52]);
                        d = II(d, a, b, c, M_offset_3, 10, T[53]);
                        c = II(c, d, a, b, M_offset_10, 15, T[54]);
                        b = II(b, c, d, a, M_offset_1, 21, T[55]);
                        a = II(a, b, c, d, M_offset_8, 6, T[56]);
                        d = II(d, a, b, c, M_offset_15, 10, T[57]);
                        c = II(c, d, a, b, M_offset_6, 15, T[58]);
                        b = II(b, c, d, a, M_offset_13, 21, T[59]);
                        a = II(a, b, c, d, M_offset_4, 6, T[60]);
                        d = II(d, a, b, c, M_offset_11, 10, T[61]);
                        c = II(c, d, a, b, M_offset_2, 15, T[62]);
                        b = II(b, c, d, a, M_offset_9, 21, T[63]);
                        H[0] = (H[0] + a) | 0;
                        H[1] = (H[1] + b) | 0;
                        H[2] = (H[2] + c) | 0;
                        H[3] = (H[3] + d) | 0;
                    },
                    _doFinalize: function () {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                        var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                        var nBitsTotalL = nBitsTotal;
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] =
                            (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 16711935) |
                            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 4278255360);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] =
                            (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 16711935) |
                            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 4278255360);
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 4; i++) {
                            var H_i = H[i];
                            H[i] =
                                (((H_i << 8) | (H_i >>> 24)) & 16711935) | (((H_i << 24) | (H_i >>> 8)) & 4278255360);
                        }
                        return hash;
                    },
                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                    },
                }));
                function FF(a, b, c, d, x, s, t) {
                    var n = a + ((b & c) | (~b & d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function GG(a, b, c, d, x, s, t) {
                    var n = a + ((b & d) | (c & ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function HH(a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function II(a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                C.MD5 = Hasher._createHelper(MD5);
                C.HmacMD5 = Hasher._createHmacHelper(MD5);
            })(Math);
            return CryptoJS.MD5;
        });
    })(md5$3);
    var md5$2 = md5$3.exports;
    var ansiStyles$1 = { exports: {} };
    var colorName = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
    };
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$3 = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
    };
    var conversions$2 = convert$3;
    for (const model of Object.keys(convert$3)) {
        if (!('channels' in convert$3[model])) {
            throw new Error('missing channels property: ' + model);
        }
        if (!('labels' in convert$3[model])) {
            throw new Error('missing channel labels property: ' + model);
        }
        if (convert$3[model].labels.length !== convert$3[model].channels) {
            throw new Error('channel and label counts mismatch: ' + model);
        }
        const { channels, labels } = convert$3[model];
        delete convert$3[model].channels;
        delete convert$3[model].labels;
        Object.defineProperty(convert$3[model], 'channels', { value: channels });
        Object.defineProperty(convert$3[model], 'labels', { value: labels });
    }
    convert$3.rgb.hsl = function (rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const delta = max - min;
        let h;
        let s;
        if (max === min) {
            h = 0;
        } else if (r === max) {
            h = (g - b) / delta;
        } else if (g === max) {
            h = 2 + (b - r) / delta;
        } else if (b === max) {
            h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
            h += 360;
        }
        const l = (min + max) / 2;
        if (max === min) {
            s = 0;
        } else if (l <= 0.5) {
            s = delta / (max + min);
        } else {
            s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
    };
    convert$3.rgb.hsv = function (rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = function (c) {
            return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
            h = 0;
            s = 0;
        } else {
            s = diff / v;
            rdif = diffc(r);
            gdif = diffc(g);
            bdif = diffc(b);
            if (r === v) {
                h = bdif - gdif;
            } else if (g === v) {
                h = 1 / 3 + rdif - bdif;
            } else if (b === v) {
                h = 2 / 3 + gdif - rdif;
            }
            if (h < 0) {
                h += 1;
            } else if (h > 1) {
                h -= 1;
            }
        }
        return [h * 360, s * 100, v * 100];
    };
    convert$3.rgb.hwb = function (rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert$3.rgb.hsl(rgb)[0];
        const w = (1 / 255) * Math.min(r, Math.min(g, b));
        b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
    };
    convert$3.rgb.cmyk = function (rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
        return __pow(x[0] - y[0], 2) + __pow(x[1] - y[1], 2) + __pow(x[2] - y[2], 2);
    }
    convert$3.rgb.keyword = function (rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
            return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
            const value = cssKeywords[keyword];
            const distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
                currentClosestDistance = distance;
                currentClosestKeyword = keyword;
            }
        }
        return currentClosestKeyword;
    };
    convert$3.keyword.rgb = function (keyword) {
        return cssKeywords[keyword];
    };
    convert$3.rgb.xyz = function (rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? __pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? __pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? __pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
    };
    convert$3.rgb.lab = function (rgb) {
        const xyz = convert$3.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
    };
    convert$3.hsl.rgb = function (hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
            val = l * 255;
            return [val, val, val];
        }
        if (l < 0.5) {
            t2 = l * (1 + s);
        } else {
            t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
            t3 = h + (1 / 3) * -(i - 1);
            if (t3 < 0) {
                t3++;
            }
            if (t3 > 1) {
                t3--;
            }
            if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
            } else if (2 * t3 < 1) {
                val = t2;
            } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            } else {
                val = t1;
            }
            rgb[i] = val * 255;
        }
        return rgb;
    };
    convert$3.hsl.hsv = function (hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
        return [h, sv * 100, v * 100];
    };
    convert$3.hsv.rgb = function (hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f);
        const t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
            case 0:
                return [v, t, p];
            case 1:
                return [q, v, p];
            case 2:
                return [p, v, t];
            case 3:
                return [p, q, v];
            case 4:
                return [t, p, v];
            case 5:
                return [v, p, q];
        }
    };
    convert$3.hsv.hsl = function (hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
    };
    convert$3.hwb.rgb = function (hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        if (ratio > 1) {
            wh /= ratio;
            bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
            f = 1 - f;
        }
        const n = wh + f * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
            default:
            case 6:
            case 0:
                r = v;
                g = n;
                b = wh;
                break;
            case 1:
                r = n;
                g = v;
                b = wh;
                break;
            case 2:
                r = wh;
                g = v;
                b = n;
                break;
            case 3:
                r = wh;
                g = n;
                b = v;
                break;
            case 4:
                r = n;
                g = wh;
                b = v;
                break;
            case 5:
                r = v;
                g = wh;
                b = n;
                break;
        }
        return [r * 255, g * 255, b * 255];
    };
    convert$3.cmyk.rgb = function (cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
    };
    convert$3.xyz.rgb = function (xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * __pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * __pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * __pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
    };
    convert$3.xyz.lab = function (xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
    };
    convert$3.lab.xyz = function (lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = __pow(y, 3);
        const x2 = __pow(x, 3);
        const z2 = __pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
    };
    convert$3.lab.lch = function (lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = (hr * 360) / 2 / Math.PI;
        if (h < 0) {
            h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
    };
    convert$3.lch.lab = function (lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = (h / 360) * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
    };
    convert$3.rgb.ansi16 = function (args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert$3.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
            return 30;
        }
        let ansi = 30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255));
        if (value === 2) {
            ansi += 60;
        }
        return ansi;
    };
    convert$3.hsv.ansi16 = function (args) {
        return convert$3.rgb.ansi16(convert$3.hsv.rgb(args), args[2]);
    };
    convert$3.rgb.ansi256 = function (args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
            if (r < 8) {
                return 16;
            }
            if (r > 248) {
                return 231;
            }
            return Math.round(((r - 8) / 247) * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round((r / 255) * 5) + 6 * Math.round((g / 255) * 5) + Math.round((b / 255) * 5);
        return ansi;
    };
    convert$3.ansi16.rgb = function (args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
            if (args > 50) {
                color += 3.5;
            }
            color = (color / 10.5) * 255;
            return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = ((color >> 1) & 1) * mult * 255;
        const b = ((color >> 2) & 1) * mult * 255;
        return [r, g, b];
    };
    convert$3.ansi256.rgb = function (args) {
        if (args >= 232) {
            const c = (args - 232) * 10 + 8;
            return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = (Math.floor(args / 36) / 5) * 255;
        const g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
        const b = ((rem % 6) / 5) * 255;
        return [r, g, b];
    };
    convert$3.rgb.hex = function (args) {
        const integer =
            ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return '000000'.substring(string.length) + string;
    };
    convert$3.hex.rgb = function (args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
            return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
            colorString = colorString
                .split('')
                .map((char) => {
                    return char + char;
                })
                .join('');
        }
        const integer = parseInt(colorString, 16);
        const r = (integer >> 16) & 255;
        const g = (integer >> 8) & 255;
        const b = integer & 255;
        return [r, g, b];
    };
    convert$3.rgb.hcg = function (rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max = Math.max(Math.max(r, g), b);
        const min = Math.min(Math.min(r, g), b);
        const chroma = max - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
            grayscale = min / (1 - chroma);
        } else {
            grayscale = 0;
        }
        if (chroma <= 0) {
            hue = 0;
        } else if (max === r) {
            hue = ((g - b) / chroma) % 6;
        } else if (max === g) {
            hue = 2 + (b - r) / chroma;
        } else {
            hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$3.hsl.hcg = function (hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        if (c < 1) {
            f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
    };
    convert$3.hsv.hcg = function (hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f = 0;
        if (c < 1) {
            f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
    };
    convert$3.hcg.rgb = function (hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
            return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = (h % 1) * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
            case 0:
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;
            case 1:
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;
            case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;
            case 3:
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;
            case 4:
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;
            default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
        }
        mg = (1 - c) * g;
        return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };
    convert$3.hcg.hsv = function (hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f = 0;
        if (v > 0) {
            f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
    };
    convert$3.hcg.hsl = function (hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
            s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
            s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
    };
    convert$3.hcg.hwb = function (hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$3.hwb.hcg = function (hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
            g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
    };
    convert$3.apple.rgb = function (apple) {
        return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
    };
    convert$3.rgb.apple = function (rgb) {
        return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
    };
    convert$3.gray.rgb = function (args) {
        return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
    };
    convert$3.gray.hsl = function (args) {
        return [0, 0, args[0]];
    };
    convert$3.gray.hsv = convert$3.gray.hsl;
    convert$3.gray.hwb = function (gray) {
        return [0, 100, gray[0]];
    };
    convert$3.gray.cmyk = function (gray) {
        return [0, 0, 0, gray[0]];
    };
    convert$3.gray.lab = function (gray) {
        return [gray[0], 0, 0];
    };
    convert$3.gray.hex = function (gray) {
        const val = Math.round((gray[0] / 100) * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return '000000'.substring(string.length) + string;
    };
    convert$3.rgb.gray = function (rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [(val / 255) * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions$1);
        for (let len = models.length, i = 0; i < len; i++) {
            graph[models[i]] = {
                distance: -1,
                parent: null,
            };
        }
        return graph;
    }
    function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
            const current = queue.pop();
            const adjacents = Object.keys(conversions$1[current]);
            for (let len = adjacents.length, i = 0; i < len; i++) {
                const adjacent = adjacents[i];
                const node = graph[adjacent];
                if (node.distance === -1) {
                    node.distance = graph[current].distance + 1;
                    node.parent = current;
                    queue.unshift(adjacent);
                }
            }
        }
        return graph;
    }
    function link$2(from, to) {
        return function (args) {
            return to(from(args));
        };
    }
    function wrapConversion(toModel, graph) {
        const path = [graph[toModel].parent, toModel];
        let fn = conversions$1[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link$2(conversions$1[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
        }
        fn.conversion = path;
        return fn;
    }
    var route$1 = function (fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
            const toModel = models[i];
            const node = graph[toModel];
            if (node.parent === null) {
                continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert$2 = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
        const wrappedFn = function (...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
                return arg0;
            }
            if (arg0.length > 1) {
                args = arg0;
            }
            return fn(args);
        };
        if ('conversion' in fn) {
            wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
    }
    function wrapRounded(fn) {
        const wrappedFn = function (...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
                return arg0;
            }
            if (arg0.length > 1) {
                args = arg0;
            }
            const result = fn(args);
            if (typeof result === 'object') {
                for (let len = result.length, i = 0; i < len; i++) {
                    result[i] = Math.round(result[i]);
                }
            }
            return result;
        };
        if ('conversion' in fn) {
            wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
    }
    models.forEach((fromModel) => {
        convert$2[fromModel] = {};
        Object.defineProperty(convert$2[fromModel], 'channels', { value: conversions[fromModel].channels });
        Object.defineProperty(convert$2[fromModel], 'labels', { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
            const fn = routes[toModel];
            convert$2[fromModel][toModel] = wrapRounded(fn);
            convert$2[fromModel][toModel].raw = wrapRaw(fn);
        });
    });
    var colorConvert = convert$2;
    (function (module2) {
        const wrapAnsi16 =
            (fn, offset) =>
            (...args) => {
                const code = fn(...args);
                return `[${code + offset}m`;
            };
        const wrapAnsi256 =
            (fn, offset) =>
            (...args) => {
                const code = fn(...args);
                return `[${38 + offset};5;${code}m`;
            };
        const wrapAnsi16m =
            (fn, offset) =>
            (...args) => {
                const rgb = fn(...args);
                return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
            };
        const ansi2ansi = (n) => n;
        const rgb2rgb = (r, g, b) => [r, g, b];
        const setLazyProperty = (object, property, get) => {
            Object.defineProperty(object, property, {
                get: () => {
                    const value = get();
                    Object.defineProperty(object, property, {
                        value,
                        enumerable: true,
                        configurable: true,
                    });
                    return value;
                },
                enumerable: true,
                configurable: true,
            });
        };
        let colorConvert$1;
        const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
            if (colorConvert$1 === void 0) {
                colorConvert$1 = colorConvert;
            }
            const offset = isBackground ? 10 : 0;
            const styles = {};
            for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
                const name2 = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
                if (sourceSpace === targetSpace) {
                    styles[name2] = wrap(identity, offset);
                } else if (typeof suite === 'object') {
                    styles[name2] = wrap(suite[targetSpace], offset);
                }
            }
            return styles;
        };
        function assembleStyles() {
            const codes = new Map();
            const styles = {
                modifier: {
                    reset: [0, 0],
                    bold: [1, 22],
                    dim: [2, 22],
                    italic: [3, 23],
                    underline: [4, 24],
                    inverse: [7, 27],
                    hidden: [8, 28],
                    strikethrough: [9, 29],
                },
                color: {
                    black: [30, 39],
                    red: [31, 39],
                    green: [32, 39],
                    yellow: [33, 39],
                    blue: [34, 39],
                    magenta: [35, 39],
                    cyan: [36, 39],
                    white: [37, 39],
                    blackBright: [90, 39],
                    redBright: [91, 39],
                    greenBright: [92, 39],
                    yellowBright: [93, 39],
                    blueBright: [94, 39],
                    magentaBright: [95, 39],
                    cyanBright: [96, 39],
                    whiteBright: [97, 39],
                },
                bgColor: {
                    bgBlack: [40, 49],
                    bgRed: [41, 49],
                    bgGreen: [42, 49],
                    bgYellow: [43, 49],
                    bgBlue: [44, 49],
                    bgMagenta: [45, 49],
                    bgCyan: [46, 49],
                    bgWhite: [47, 49],
                    bgBlackBright: [100, 49],
                    bgRedBright: [101, 49],
                    bgGreenBright: [102, 49],
                    bgYellowBright: [103, 49],
                    bgBlueBright: [104, 49],
                    bgMagentaBright: [105, 49],
                    bgCyanBright: [106, 49],
                    bgWhiteBright: [107, 49],
                },
            };
            styles.color.gray = styles.color.blackBright;
            styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
            styles.color.grey = styles.color.blackBright;
            styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
            for (const [groupName, group] of Object.entries(styles)) {
                for (const [styleName, style] of Object.entries(group)) {
                    styles[styleName] = {
                        open: `[${style[0]}m`,
                        close: `[${style[1]}m`,
                    };
                    group[styleName] = styles[styleName];
                    codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                    value: group,
                    enumerable: false,
                });
            }
            Object.defineProperty(styles, 'codes', {
                value: codes,
                enumerable: false,
            });
            styles.color.close = '[39m';
            styles.bgColor.close = '[49m';
            setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
            setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
            setLazyProperty(styles.bgColor, 'ansi256', () =>
                makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true),
            );
            setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
            return styles;
        }
        Object.defineProperty(module2, 'exports', {
            enumerable: true,
            get: assembleStyles,
        });
    })(ansiStyles$1);
    var browser = {
        stdout: false,
        stderr: false,
    };
    const stringReplaceAll$1 = (string, substring, replacer) => {
        let index = string.indexOf(substring);
        if (index === -1) {
            return string;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = '';
        do {
            returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
            endIndex = index + substringLength;
            index = string.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
    };
    const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = '';
        do {
            const gotCR = string[index - 1] === '\r';
            returnValue +=
                string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) +
                prefix +
                (gotCR ? '\r\n' : '\n') +
                postfix;
            endIndex = index + 1;
            index = string.indexOf('\n', endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
    };
    var util$3 = {
        stringReplaceAll: stringReplaceAll$1,
        stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1,
    };
    const TEMPLATE_REGEX =
        /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    const ESCAPES = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '	'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', ''],
        ['a', '\x07'],
    ]);
    function unescape$1(c) {
        const u = c[0] === 'u';
        const bracket = c[1] === '{';
        if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
            return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
            return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
    }
    function parseArguments(name2, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
            const number = Number(chunk);
            if (!Number.isNaN(number)) {
                results.push(number);
            } else if ((matches = chunk.match(STRING_REGEX))) {
                results.push(
                    matches[2].replace(ESCAPE_REGEX, (m, escape2, character) =>
                        escape2 ? unescape$1(escape2) : character,
                    ),
                );
            } else {
                throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
            }
        }
        return results;
    }
    function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
            const name2 = matches[1];
            if (matches[2]) {
                const args = parseArguments(name2, matches[2]);
                results.push([name2].concat(args));
            } else {
                results.push([name2]);
            }
        }
        return results;
    }
    function buildStyle(chalk, styles) {
        const enabled = {};
        for (const layer of styles) {
            for (const style of layer.styles) {
                enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
        }
        let current = chalk;
        for (const [styleName, styles2] of Object.entries(enabled)) {
            if (!Array.isArray(styles2)) {
                continue;
            }
            if (!(styleName in current)) {
                throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
    }
    var templates = (chalk, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
            if (escapeCharacter) {
                chunk.push(unescape$1(escapeCharacter));
            } else if (style) {
                const string = chunk.join('');
                chunk = [];
                chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
                styles.push({ inverse, styles: parseStyle(style) });
            } else if (close) {
                if (styles.length === 0) {
                    throw new Error('Found extraneous } in Chalk template literal');
                }
                chunks.push(buildStyle(chalk, styles)(chunk.join('')));
                chunk = [];
                styles.pop();
            } else {
                chunk.push(character);
            }
        });
        chunks.push(chunk.join(''));
        if (styles.length > 0) {
            const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${
                styles.length === 1 ? '' : 's'
            } (\`}\`)`;
            throw new Error(errMessage);
        }
        return chunks.join('');
    };
    const ansiStyles = ansiStyles$1.exports;
    const { stdout: stdoutColor, stderr: stderrColor } = browser;
    const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = util$3;
    const { isArray: isArray$a } = Array;
    const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
    const styles = Object.create(null);
    const applyOptions = (object, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
            throw new Error('The `level` option should be an integer from 0 to 3');
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object.level = options.level === void 0 ? colorLevel : options.level;
    };
    class ChalkClass {
        constructor(options) {
            return chalkFactory(options);
        }
    }
    const chalkFactory = (options) => {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = () => {
            throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
        };
        chalk.template.Instance = ChalkClass;
        return chalk.template;
    };
    function Chalk(options) {
        return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
            get() {
                const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
                Object.defineProperty(this, styleName, { value: builder });
                return builder;
            },
        };
    }
    styles.visible = {
        get() {
            const builder = createBuilder(this, this._styler, true);
            Object.defineProperty(this, 'visible', { value: builder });
            return builder;
        },
    };
    const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
    for (const model of usedModels) {
        styles[model] = {
            get() {
                const { level } = this;
                return function (...arguments_) {
                    const styler = createStyler(
                        ansiStyles.color[levelMapping[level]][model](...arguments_),
                        ansiStyles.color.close,
                        this._styler,
                    );
                    return createBuilder(this, styler, this._isEmpty);
                };
            },
        };
    }
    for (const model of usedModels) {
        const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
            get() {
                const { level } = this;
                return function (...arguments_) {
                    const styler = createStyler(
                        ansiStyles.bgColor[levelMapping[level]][model](...arguments_),
                        ansiStyles.bgColor.close,
                        this._styler,
                    );
                    return createBuilder(this, styler, this._isEmpty);
                };
            },
        };
    }
    const proto$3 = Object.defineProperties(
        () => {},
        __spreadProps(__spreadValues({}, styles), {
            level: {
                enumerable: true,
                get() {
                    return this._generator.level;
                },
                set(level) {
                    this._generator.level = level;
                },
            },
        }),
    );
    const createStyler = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
            openAll = open;
            closeAll = close;
        } else {
            openAll = parent.openAll + open;
            closeAll = close + parent.closeAll;
        }
        return {
            open,
            close,
            openAll,
            closeAll,
            parent,
        };
    };
    const createBuilder = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
            if (isArray$a(arguments_[0]) && isArray$a(arguments_[0].raw)) {
                return applyStyle(builder, chalkTag(builder, ...arguments_));
            }
            return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
        };
        Object.setPrototypeOf(builder, proto$3);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
    };
    const applyStyle = (self2, string) => {
        if (self2.level <= 0 || !string) {
            return self2._isEmpty ? '' : string;
        }
        let styler = self2._styler;
        if (styler === void 0) {
            return string;
        }
        const { openAll, closeAll } = styler;
        if (string.indexOf('') !== -1) {
            while (styler !== void 0) {
                string = stringReplaceAll(string, styler.close, styler.open);
                styler = styler.parent;
            }
        }
        const lfIndex = string.indexOf('\n');
        if (lfIndex !== -1) {
            string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
        }
        return openAll + string + closeAll;
    };
    let template;
    const chalkTag = (chalk, ...strings) => {
        const [firstString] = strings;
        if (!isArray$a(firstString) || !isArray$a(firstString.raw)) {
            return strings.join(' ');
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
            parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
        }
        if (template === void 0) {
            template = templates;
        }
        return template(chalk, parts.join(''));
    };
    Object.defineProperties(Chalk.prototype, styles);
    const chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    var source$5 = chalk;
    function classInstance$2(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name === 'Object') return false;
        if (Object.prototype.toString.call(object) === '[object Object]') return false;
        if (object.constructor === Object) return false;
        return true;
    }
    function deepMap$2(objectOrArray, processor, settings = {}, _path = []) {
        settings = deepMerge(
            {
                classInstances: false,
                array: true,
                privateProps: false,
                cloneFirst: true,
            },
            settings,
        );
        const isArray = Array.isArray(objectOrArray);
        let newObject = isArray ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
        Object.keys(objectOrArray).forEach((prop) => {
            if (!settings.privateProps && prop.match(/^_/)) return;
            if (
                plainObject$3(objectOrArray[prop]) ||
                (classInstance$2(objectOrArray[prop]) && settings.classInstances) ||
                (Array.isArray(objectOrArray[prop]) && settings.array)
            ) {
                const res2 = deepMap$2(objectOrArray[prop], processor, settings, [..._path, prop]);
                if (isArray) {
                    newObject.push(res2);
                } else {
                    if (prop === '...' && plainObject$3(res2)) {
                        newObject = Object.assign(Object.assign({}, newObject), res2);
                    } else {
                        newObject[prop] = res2;
                    }
                }
                return;
            }
            const res = processor({
                object: objectOrArray,
                prop,
                value: objectOrArray[prop],
                path: [..._path, prop].join('.'),
            });
            if (res === -1) {
                delete objectOrArray[prop];
                return;
            }
            if (isArray) newObject.push(res);
            else {
                if (prop === '...' && plainObject$3(res)) {
                    newObject = Object.assign(Object.assign({}, newObject), res);
                } else {
                    newObject[prop] = res;
                }
            }
        });
        return newObject;
    }
    function isMap$2(value) {
        return value instanceof Map;
    }
    function isArray$9(value) {
        return value && typeof value === 'object' && value.constructor === Array;
    }
    function isBoolean$2(value) {
        return typeof value === 'boolean';
    }
    function isFunction$4(value) {
        return value && {}.toString.call(value) === '[object Function]';
    }
    function isJson$2(value) {
        try {
            const res = JSON.parse(value);
            if (Object.keys(res).length) return true;
            return false;
        } catch (e) {
            return false;
        }
        return true;
    }
    function isObject$5(value) {
        return value && typeof value === 'object' && value.constructor === Object;
    }
    function mapToObject$2(map) {
        const obj = {};
        for (const [k, v] of map) obj[k] = v;
        return obj;
    }
    var decycle_1;
    const isArray$8 = (e) => Array.isArray(e),
        isObject$4 = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Object',
        validate = (e) => {
            if (e === void 0) throw new Error('This method requires one parameter');
            if (!isArray$8(e) && !isObject$4(e)) throw new TypeError('This method only accepts arrays and objects');
        },
        isRef = (e) =>
            isObject$4(e) &&
            e.hasOwnProperty('$ref') &&
            Object.keys(e).length === 1 &&
            !!e.$ref &&
            e.$ref.charAt(0) === '$',
        encycle = (arg) => {
            validate(arg);
            const recurs = (value) =>
                isArray$8(value) || isObject$4(value)
                    ? isArray$8(value)
                        ? value.map((elem, i) =>
                              isRef(elem) ? ((value[i] = eval('arg' + elem.$ref.slice(1))), value) : recurs(elem),
                          )
                        : Object.keys(value).reduce(
                              (accum, key) => (
                                  (accum[key] = isRef(value[key])
                                      ? eval('arg' + value[key].$ref.slice(1))
                                      : recurs(value[key])),
                                  accum
                              ),
                              value,
                          )
                    : value;
            return recurs(arg);
        },
        findRef = (e, r) => Object.keys(r).find((a) => r[a] === e),
        decycle = (e) => {
            validate(e);
            let r = {};
            const a = (e2, c = '$') => {
                const s = findRef(e2, r);
                return s
                    ? { $ref: s }
                    : isArray$8(e2) || isObject$4(e2)
                    ? ((r[c] = e2),
                      isArray$8(e2)
                          ? e2.map((e3, r2) => a(e3, `${c}[${r2}]`))
                          : Object.keys(e2).reduce((r2, s2) => ((r2[s2] = a(e2[s2], `${c}.${s2}`)), r2), {}))
                    : e2;
            };
            return a(e);
        };
    (decycle_1 = decycle), encycle;
    function fn$6(value, settings = {}) {
        settings = deepMerge(
            {
                beautify: true,
                highlight: true,
                verbose: true,
                theme: {
                    number: source$5.yellow,
                    default: source$5.white,
                    keyword: source$5.blue,
                    regexp: source$5.red,
                    string: source$5.whiteBright,
                    class: source$5.yellow,
                    function: source$5.yellow,
                    comment: source$5.gray,
                    variable: source$5.red,
                    attr: source$5.green,
                },
            },
            settings,
        );
        if (typeof value === 'string') return value;
        if (value === null) return null;
        if (value === void 0) return void 0;
        if (value instanceof Error) {
            const errorStr = value.toString();
            const stackStr = value.stack;
            const messageStr = value.message;
            if (settings.verbose) {
                return [`<red>${value.constructor.name || 'Error'}</red>`, '', messageStr, '', stackStr].join('\n');
            }
            return errorStr;
        }
        if (isMap$2(value)) {
            value = mapToObject$2(value);
        }
        if (isObject$5(value) || isArray$9(value) || isJson$2(value)) {
            try {
                value = decycle_1(value);
            } catch (e) {}
            value = deepMap$2(value, ({ value: value2 }) => {
                if (value2 instanceof Map) return mapToObject$2(value2);
                return value2;
            });
            let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
            prettyString = prettyString.replace(/"([^"]+)":/g, '$1:').replace(/\uFFFF/g, '\\"');
            if (settings.highlight);
            return prettyString;
        }
        if (isBoolean$2(value)) {
            if (value) return 'true';
            else return 'false';
        }
        if (isFunction$4(value)) {
            return '' + value;
        }
        let returnString = '';
        try {
            value = decycle_1(value);
            returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
        } catch (e) {
            try {
                returnString = value.toString();
            } catch (e2) {
                returnString = value;
            }
        }
        return returnString;
    }
    var __parse = (value) => {
        if (typeof value !== 'string') return value;
        value = value.split('\u2800').join('').trim();
        try {
            return Function(`
      "use strict";
      return (${value});
    `)();
        } catch (e) {
            return value;
        }
    };
    const __encryptedMessages$2 = {};
    var __md5$2 = {
        encrypt: function (message) {
            if (typeof message !== 'string') message = fn$6(message);
            const string = md5$2(message).toString();
            __encryptedMessages$2[string] = message;
            return string;
        },
        decrypt: function (message) {
            if (!__encryptedMessages$2[message]) {
                console.warn(`The message "${message}" cannot be decrypted...`);
                return;
            }
            const string = __encryptedMessages$2[message];
            delete __encryptedMessages$2[message];
            return __parse(string);
        },
    };
    function availableColors(settings) {
        settings = Object.assign({ excludeBasics: false }, settings !== null && settings !== void 0 ? settings : {});
        const _colors = ['yellow', 'cyan', 'green', 'magenta', 'red', 'blue', 'grey', 'gray'];
        let colors = _colors;
        if (settings.excludeBasics) {
            colors = _colors.filter((c) => {
                return c !== 'white' && c !== 'black' && c !== 'grey' && c !== 'gray';
            });
        }
        return colors;
    }
    function pickRandom(array) {
        return array[Math.round(Math.random() * (array.length - 1))];
    }
    const _colorUsedByScope = {};
    const _colorsStack = {};
    function getColorFor(ref, settings) {
        settings = deepMerge(
            {
                scope: 'default',
                excludeBasics: true,
            },
            settings !== null && settings !== void 0 ? settings : {},
        );
        const availableColors$1 = availableColors(settings);
        const scopeId = __md5$2.encrypt(settings.scope);
        const refId = __md5$2.encrypt(ref);
        if (_colorsStack[`${scopeId}.${refId}`]) return _colorsStack[`${scopeId}.${refId}`];
        if (!_colorUsedByScope[scopeId]) _colorUsedByScope[scopeId] = [];
        if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
            const color = pickRandom(availableColors$1);
            _colorsStack[`${scopeId}.${refId}`] = color;
            return color;
        } else {
            for (let i = 0; i < availableColors$1.length; i++) {
                if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i]) === -1) {
                    _colorUsedByScope[scopeId].push(availableColors$1[i]);
                    _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i];
                    return availableColors$1[i];
                }
            }
        }
    }
    var __set = (obj, path, value, settings = {}) => {
        settings = Object.assign({}, settings);
        if (!path || path === '' || path === '.') {
            obj = value;
            return;
        }
        path = path.replace(/\[(\w+)\]/g, '.[$1]');
        const a = unquote(path)
            .split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm)
            .map((p) => unquote(p));
        let o = obj;
        while (a.length - 1) {
            const n = a.shift();
            if (!(n in o)) {
                if (a[0].match(/^\[[0-9]+\]$/)) o[n] = [];
                else o[n] = {};
            }
            o = o[n];
        }
        if (a[0].match(/^\[[0-9]+\]$/)) {
            if (!Array.isArray(o)) o = [];
            o.push(value);
        } else {
            o[a[0]] = value;
        }
        return get$3(obj, path);
    };
    function toJson(object) {
        const newObj = {};
        deepMap$2(
            object,
            ({ value, path }) => {
                __set(newObj, path, value);
                return value;
            },
            {
                privateProps: false,
                classInstances: true,
            },
        );
        return newObj;
    }
    class SClass {
        constructor(settings = {}) {
            this._settings = {};
            this._interfacesStack = {};
            generateInterfacesStack(this);
            setSettings(this, settings);
            applyInterfaces(this);
            this.metas = getMetas(this);
            Object.defineProperty(this, 'metas', {
                enumerable: true,
                value: getMetas(this),
            });
        }
        get formattedName() {
            var _a, _b, _c;
            let name2 = `<yellow>${((_a = this.metas) === null || _a === void 0 ? void 0 : _a.name) || ''}</yellow>`;
            if ((_b = this.metas) === null || _b === void 0 ? void 0 : _b.id) {
                name2 += ` <cyan>${(_c = this.metas) === null || _c === void 0 ? void 0 : _c.id}</cyan>`;
            }
            return name2;
        }
        static extends(Cls) {
            class SClass extends Cls {
                constructor(settings, ...args) {
                    super(...args);
                    this._settings = {};
                    this._interfacesStack = {};
                    generateInterfacesStack(this);
                    setSettings(this, settings);
                    applyInterfaces(this);
                    this.metas = getMetas(this);
                    Object.defineProperty(this, 'metas', {
                        enumerable: true,
                        value: getMetas(this),
                    });
                }
                get formattedName() {
                    let name2 = `<yellow>${this.name || ''}</yellow>`;
                    if (this.id) {
                        name2 += ` <cyan>${this.id}</cyan>`;
                    }
                    return name2;
                }
                expose(instance, settings) {
                    return expose(this, instance, settings);
                }
                applyInterface(name2, on) {
                    return applyInterface(this, name2, on);
                }
                getInterface(name2) {
                    return getInterface(this, name2);
                }
                toPlainObject() {
                    return toPlainObject(this);
                }
            }
            return SClass;
        }
        expose(instance, settings) {
            return expose(this, instance, settings);
        }
        applyInterface(name2, on) {
            return applyInterface(this, name2, on);
        }
        getInterface(name2) {
            return getInterface(this, name2);
        }
        toPlainObject() {
            return toPlainObject(this);
        }
    }
    function getMetas(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let name2 = `<yellow>${
            ((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.name) || ''
        }</yellow>`;
        if ((_b = ctx._settings.metas) === null || _b === void 0 ? void 0 : _b.id) {
            name2 += ` <cyan>${ctx._settings.metas.id}</cyan>`;
        }
        const metasObj = {
            id:
                (_d = (_c = ctx._settings.metas) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0
                    ? _d
                    : ctx.constructor.name,
            name:
                (_f = (_e = ctx._settings.metas) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0
                    ? _f
                    : ctx.constructor.name,
            formattedName: name2,
            color:
                (_h = (_g = ctx._settings.metas) === null || _g === void 0 ? void 0 : _g.color) !== null &&
                _h !== void 0
                    ? _h
                    : 'yellow',
        };
        return metasObj;
    }
    function generateInterfacesStack(ctx) {
        const extendsStack = fn$7(ctx, {
            includeBaseClass: true,
        });
        Object.keys(extendsStack).forEach((className) => {
            const cls = extendsStack[className];
            if (cls.interfaces) {
                ctx._interfacesStack[className] = cls.interfaces;
            }
        });
    }
    function expose(ctx, instance, settings) {
        settings = deepMerge(
            {
                as: void 0,
                props: [],
            },
            settings,
        );
        if (settings.as && typeof settings.as === 'string') {
            ctx[settings.as] = instance;
        }
        if (settings.props) {
            settings.props.forEach((prop) => {
                if (instance[prop].bind && typeof instance[prop].bind === 'function') {
                    ctx[prop] = instance[prop].bind(instance);
                } else {
                    ctx[prop] = instance[prop];
                }
            });
        }
    }
    function getInterfaceObj(ctx, name2) {
        let interfaceObj = get$3(ctx._interfacesStack, name2);
        if (!interfaceObj) {
            const keys = Object.keys(ctx._interfacesStack);
            for (let i = 0; i < keys.length; i++) {
                const interfacesObj = ctx._interfacesStack[keys[i]];
                if (interfacesObj[name2] !== void 0) {
                    if (plainObject$3(interfacesObj[name2])) {
                        interfaceObj = interfacesObj[name2];
                    } else {
                        interfaceObj = {
                            apply: true,
                            on: name2 === 'settings' ? '_settings' : name2 === 'this' ? ctx : void 0,
                            class: interfacesObj[name2],
                        };
                    }
                    break;
                }
            }
        }
        if (name2 === 'settings' && interfaceObj.on === void 0) {
            if (ctx.settings !== void 0) interfaceObj.on = 'settings';
            else if (ctx._settings !== void 0) interfaceObj.on = '_settings';
        }
        return interfaceObj;
    }
    function toPlainObject(ctx) {
        return toJson(ctx);
    }
    function getInterface(ctx, name2) {
        const interfaceObj = getInterfaceObj(ctx, name2);
        if (plainObject$3(interfaceObj)) return interfaceObj.class;
        return interfaceObj;
    }
    function applyInterfaces(ctx) {
        const keys = Object.keys(ctx._interfacesStack);
        for (let i = keys.length - 1; i >= 0; i--) {
            const interfacesObj = ctx._interfacesStack[keys[i]];
            const className = keys[i];
            Object.keys(interfacesObj).forEach((name2) => {
                const interfaceObj = interfacesObj[name2];
                let settings;
                if (plainObject$3(interfaceObj)) {
                    settings = Object.assign(
                        {},
                        Object.assign(
                            { apply: true, on: name2 === 'settings' ? '_settings' : name2 === 'this' ? ctx : void 0 },
                            interfaceObj,
                        ),
                    );
                } else {
                    settings = Object.assign(
                        {},
                        {
                            apply: true,
                            on: name2 === 'settings' ? '_settings' : name2 === 'this' ? ctx : void 0,
                            class: interfaceObj,
                        },
                    );
                }
                if (settings.apply !== true) return;
                if (settings.on) {
                    if (typeof settings.on === 'string' && get$3(ctx, settings.on) !== void 0) {
                        applyInterface(ctx, `${className}.${name2}`, settings.on);
                    } else if (typeof settings.on === 'object') {
                        applyInterface(ctx, `${className}.${name2}`, settings.on);
                    } else if (ctx[name2] !== void 0) {
                        applyInterface(ctx, `${className}.${name2}`);
                    }
                }
            });
        }
    }
    function applyInterface(ctx, name2, on = null) {
        const interfaceObj = getInterfaceObj(ctx, `${name2}`);
        if (!interfaceObj) {
            throw new Error(
                `You try to apply the interface named "<yellow>${name2}</yellow>" on the context "<cyan>${ctx.name}</cyan>" but it does not exists...`,
            );
        }
        if (on !== void 0) interfaceObj.on = on;
        if (!interfaceObj) {
            throw `Sorry the the asked interface "<yellow>${name2}</yellow>" does not exists on the class "<cyan>${ctx.constructor.name}</cyan>"`;
        }
        if (name2.includes('.')) {
            name2 = name2.split('.').slice(1).join('.');
        }
        if (plainObject$3(interfaceObj)) {
            let onValue;
            if (interfaceObj.on && typeof interfaceObj.on === 'string') {
                onValue = get$3(ctx, interfaceObj.on);
            } else if (interfaceObj.on && typeof interfaceObj.on === 'object') {
                onValue = interfaceObj.on;
            } else {
                onValue = get$3(ctx, name2);
            }
            let applyId = ctx.constructor.name;
            if (ctx.id) applyId += `(${ctx.id})`;
            if (name2) applyId += `.${name2}`;
            if (interfaceObj.on && interfaceObj.on.constructor) applyId += `.${interfaceObj.on.constructor.name}`;
            if (interfaceObj.on && interfaceObj.on.id) applyId += `(${interfaceObj.on.id})`;
            let res;
            if (name2 === 'this') {
                res = interfaceObj.class.apply(onValue || {}, {
                    id: applyId,
                    throw: true,
                });
                deepAssign(ctx, res.value);
                return ctx;
            } else {
                res = interfaceObj.class.apply(onValue, {
                    id: applyId,
                    throw: true,
                });
                if (interfaceObj.on && typeof interfaceObj.on === 'object') {
                    const returnValue = deepAssign(interfaceObj.on, res);
                    return returnValue;
                } else if (interfaceObj.on && typeof interfaceObj.on === 'string') {
                    return deepAssign(get$3(ctx, interfaceObj.on), res);
                } else if (ctx[name2] !== void 0) {
                    return ctx[name2];
                } else {
                    return res;
                }
            }
        }
    }
    function setSettings(ctx, settings = {}) {
        var _a;
        ctx._settings = settings;
        if (!ctx._settings.metas) ctx._settings.metas = {};
        if (!((_a = ctx._settings.metas) === null || _a === void 0 ? void 0 : _a.id))
            ctx._settings.metas.id = ctx.constructor.name;
        if (!ctx.constructor.name.match(/^SConfig/)) {
            if (!ctx._settings.metas.color)
                ctx._settings.metas.color = getColorFor(ctx.constructor.name, {
                    scope: 'class',
                });
        } else if (!ctx._settings.metas.color) ctx._settings.metas.color = 'yellow';
    }
    var __viteBrowserExternal_path = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "path" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_path,
    });
    var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_path$1);
    var concatMap$1 = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray$7(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };
    var isArray$7 =
        Array.isArray ||
        function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };
    var balancedMatch = balanced$1;
    function balanced$1(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);
        var r = range(a, b, str);
        return (
            r && {
                start: r[0],
                end: r[1],
                pre: str.slice(0, r[0]),
                body: str.slice(r[0] + a.length, r[1]),
                post: str.slice(r[1] + b.length),
            }
        );
    }
    function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
    }
    balanced$1.range = range;
    function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
            if (a === b) {
                return [ai, bi];
            }
            begs = [];
            left = str.length;
            while (i >= 0 && !result) {
                if (i == ai) {
                    begs.push(i);
                    ai = str.indexOf(a, i + 1);
                } else if (begs.length == 1) {
                    result = [begs.pop(), bi];
                } else {
                    beg = begs.pop();
                    if (beg < left) {
                        left = beg;
                        right = bi;
                    }
                    bi = str.indexOf(b, i + 1);
                }
                i = ai < bi && ai >= 0 ? ai : bi;
            }
            if (begs.length) {
                result = [left, right];
            }
        }
        return result;
    }
    var concatMap = concatMap$1;
    var balanced = balancedMatch;
    var braceExpansion = expandTop;
    var escSlash = '\0SLASH' + Math.random() + '\0';
    var escOpen = '\0OPEN' + Math.random() + '\0';
    var escClose = '\0CLOSE' + Math.random() + '\0';
    var escComma = '\0COMMA' + Math.random() + '\0';
    var escPeriod = '\0PERIOD' + Math.random() + '\0';
    function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
        return str
            .split('\\\\')
            .join(escSlash)
            .split('\\{')
            .join(escOpen)
            .split('\\}')
            .join(escClose)
            .split('\\,')
            .join(escComma)
            .split('\\.')
            .join(escPeriod);
    }
    function unescapeBraces(str) {
        return str
            .split(escSlash)
            .join('\\')
            .split(escOpen)
            .join('{')
            .split(escClose)
            .join('}')
            .split(escComma)
            .join(',')
            .split(escPeriod)
            .join('.');
    }
    function parseCommaParts(str) {
        if (!str) return [''];
        var parts = [];
        var m = balanced('{', '}', str);
        if (!m) return str.split(',');
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(',');
        p[p.length - 1] += '{' + body + '}';
        var postParts = parseCommaParts(post);
        if (post.length) {
            p[p.length - 1] += postParts.shift();
            p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
    }
    function expandTop(str) {
        if (!str) return [];
        if (str.substr(0, 2) === '{}') {
            str = '\\{\\}' + str.substr(2);
        }
        return expand$1(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
        return '{' + str + '}';
    }
    function isPadded(el) {
        return /^-?0\d/.test(el);
    }
    function lte(i, y) {
        return i <= y;
    }
    function gte(i, y) {
        return i >= y;
    }
    function expand$1(str, isTop) {
        var expansions = [];
        var m = balanced('{', '}', str);
        if (!m || /\$$/.test(m.pre)) return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(',') >= 0;
        if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post;
                return expand$1(str);
            }
            return [str];
        }
        var n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
                n = expand$1(n[0], false).map(embrace);
                if (n.length === 1) {
                    var post = m.post.length ? expand$1(m.post, false) : [''];
                    return post.map(function (p) {
                        return m.pre + n[0] + p;
                    });
                }
            }
        }
        var pre = m.pre;
        var post = m.post.length ? expand$1(m.post, false) : [''];
        var N;
        if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
                var c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === '\\') c = '';
                } else {
                    c = String(i);
                    if (pad) {
                        var need = width - c.length;
                        if (need > 0) {
                            var z = new Array(need + 1).join('0');
                            if (i < 0) c = '-' + z + c.slice(1);
                            else c = z + c;
                        }
                    }
                }
                N.push(c);
            }
        } else {
            N = concatMap(n, function (el) {
                return expand$1(el, false);
            });
        }
        for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
        }
        return expansions;
    }
    var minimatch_1 = minimatch;
    minimatch.Minimatch = Minimatch;
    var path$h = { sep: '/' };
    try {
        path$h = require$$3$1;
    } catch (er) {}
    var GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {});
    var expand = braceExpansion;
    var plTypes = {
        '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
        '?': { open: '(?:', close: ')?' },
        '+': { open: '(?:', close: ')+' },
        '*': { open: '(?:', close: ')*' },
        '@': { open: '(?:', close: ')' },
    };
    var qmark = '[^/]';
    var star = qmark + '*?';
    var twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
    var twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
    var reSpecials = charSet('().*{}+?[]^$\\!');
    function charSet(s) {
        return s.split('').reduce(function (set, c) {
            set[c] = true;
            return set;
        }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter$1;
    function filter$1(pattern, options) {
        options = options || {};
        return function (p, i, list) {
            return minimatch(p, pattern, options);
        };
    }
    function ext(a, b) {
        a = a || {};
        b = b || {};
        var t = {};
        Object.keys(b).forEach(function (k) {
            t[k] = b[k];
        });
        Object.keys(a).forEach(function (k) {
            t[k] = a[k];
        });
        return t;
    }
    minimatch.defaults = function (def) {
        if (!def || !Object.keys(def).length) return minimatch;
        var orig = minimatch;
        var m = function minimatch(p, pattern, options) {
            return orig.minimatch(p, pattern, ext(def, options));
        };
        m.Minimatch = function Minimatch(pattern, options) {
            return new orig.Minimatch(pattern, ext(def, options));
        };
        return m;
    };
    Minimatch.defaults = function (def) {
        if (!def || !Object.keys(def).length) return Minimatch;
        return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
        if (typeof pattern !== 'string') {
            throw new TypeError('glob pattern string required');
        }
        if (!options) options = {};
        if (!options.nocomment && pattern.charAt(0) === '#') {
            return false;
        }
        if (pattern.trim() === '') return p === '';
        return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) {
            return new Minimatch(pattern, options);
        }
        if (typeof pattern !== 'string') {
            throw new TypeError('glob pattern string required');
        }
        if (!options) options = {};
        pattern = pattern.trim();
        if (path$h.sep !== '/') {
            pattern = pattern.split(path$h.sep).join('/');
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.make();
    }
    Minimatch.prototype.debug = function () {};
    Minimatch.prototype.make = make;
    function make() {
        if (this._made) return;
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        this.parseNegate();
        var set = (this.globSet = this.braceExpand());
        if (options.debug) this.debug = console.error;
        this.debug(this.pattern, set);
        set = this.globParts = set.map(function (s) {
            return s.split(slashSplit);
        });
        this.debug(this.pattern, set);
        set = set.map(function (s, si, set2) {
            return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set);
        set = set.filter(function (s) {
            return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set);
        this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate) return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
    }
    minimatch.braceExpand = function (pattern, options) {
        return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
        if (!options) {
            if (this instanceof Minimatch) {
                options = this.options;
            } else {
                options = {};
            }
        }
        pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
        if (typeof pattern === 'undefined') {
            throw new TypeError('undefined pattern');
        }
        if (options.nobrace || !pattern.match(/\{.*\}/)) {
            return [pattern];
        }
        return expand(pattern);
    }
    Minimatch.prototype.parse = parse$3;
    var SUBPARSE = {};
    function parse$3(pattern, isSub) {
        if (pattern.length > 1024 * 64) {
            throw new TypeError('pattern is too long');
        }
        var options = this.options;
        if (!options.noglobstar && pattern === '**') return GLOBSTAR;
        if (pattern === '') return '';
        var re = '';
        var hasMagic = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))' : '(?!\\.)';
        var self2 = this;
        function clearStateChar() {
            if (stateChar) {
                switch (stateChar) {
                    case '*':
                        re += star;
                        hasMagic = true;
                        break;
                    case '?':
                        re += qmark;
                        hasMagic = true;
                        break;
                    default:
                        re += '\\' + stateChar;
                        break;
                }
                self2.debug('clearStateChar %j %j', stateChar, re);
                stateChar = false;
            }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
            this.debug('%s	%s %s %j', pattern, i, re, c);
            if (escaping && reSpecials[c]) {
                re += '\\' + c;
                escaping = false;
                continue;
            }
            switch (c) {
                case '/':
                    return false;
                case '\\':
                    clearStateChar();
                    escaping = true;
                    continue;
                case '?':
                case '*':
                case '+':
                case '@':
                case '!':
                    this.debug('%s	%s %s %j <-- stateChar', pattern, i, re, c);
                    if (inClass) {
                        this.debug('  in class');
                        if (c === '!' && i === classStart + 1) c = '^';
                        re += c;
                        continue;
                    }
                    self2.debug('call clearStateChar %j', stateChar);
                    clearStateChar();
                    stateChar = c;
                    if (options.noext) clearStateChar();
                    continue;
                case '(':
                    if (inClass) {
                        re += '(';
                        continue;
                    }
                    if (!stateChar) {
                        re += '\\(';
                        continue;
                    }
                    patternListStack.push({
                        type: stateChar,
                        start: i - 1,
                        reStart: re.length,
                        open: plTypes[stateChar].open,
                        close: plTypes[stateChar].close,
                    });
                    re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
                    this.debug('plType %j %j', stateChar, re);
                    stateChar = false;
                    continue;
                case ')':
                    if (inClass || !patternListStack.length) {
                        re += '\\)';
                        continue;
                    }
                    clearStateChar();
                    hasMagic = true;
                    var pl = patternListStack.pop();
                    re += pl.close;
                    if (pl.type === '!') {
                        negativeLists.push(pl);
                    }
                    pl.reEnd = re.length;
                    continue;
                case '|':
                    if (inClass || !patternListStack.length || escaping) {
                        re += '\\|';
                        escaping = false;
                        continue;
                    }
                    clearStateChar();
                    re += '|';
                    continue;
                case '[':
                    clearStateChar();
                    if (inClass) {
                        re += '\\' + c;
                        continue;
                    }
                    inClass = true;
                    classStart = i;
                    reClassStart = re.length;
                    re += c;
                    continue;
                case ']':
                    if (i === classStart + 1 || !inClass) {
                        re += '\\' + c;
                        escaping = false;
                        continue;
                    }
                    if (inClass) {
                        var cs = pattern.substring(classStart + 1, i);
                        try {
                            RegExp('[' + cs + ']');
                        } catch (er) {
                            var sp = this.parse(cs, SUBPARSE);
                            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                            hasMagic = hasMagic || sp[1];
                            inClass = false;
                            continue;
                        }
                    }
                    hasMagic = true;
                    inClass = false;
                    re += c;
                    continue;
                default:
                    clearStateChar();
                    if (escaping) {
                        escaping = false;
                    } else if (reSpecials[c] && !(c === '^' && inClass)) {
                        re += '\\';
                    }
                    re += c;
            }
        }
        if (inClass) {
            cs = pattern.substr(classStart + 1);
            sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0];
            hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
            var tail = re.slice(pl.reStart + pl.open.length);
            this.debug('setting tail', re, pl);
            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
                if (!$2) {
                    $2 = '\\';
                }
                return $1 + $1 + $2 + '|';
            });
            this.debug('tail=%j\n   %s', tail, tail, pl, re);
            var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
            hasMagic = true;
            re = re.slice(0, pl.reStart) + t + '\\(' + tail;
        }
        clearStateChar();
        if (escaping) {
            re += '\\\\';
        }
        var addPatternStart = false;
        switch (re.charAt(0)) {
            case '.':
            case '[':
            case '(':
                addPatternStart = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
            var nl = negativeLists[n];
            var nlBefore = re.slice(0, nl.reStart);
            var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
            var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
            var nlAfter = re.slice(nl.reEnd);
            nlLast += nlAfter;
            var openParensBefore = nlBefore.split('(').length - 1;
            var cleanAfter = nlAfter;
            for (i = 0; i < openParensBefore; i++) {
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
            }
            nlAfter = cleanAfter;
            var dollar = '';
            if (nlAfter === '' && isSub !== SUBPARSE) {
                dollar = '$';
            }
            var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
            re = newRe;
        }
        if (re !== '' && hasMagic) {
            re = '(?=.)' + re;
        }
        if (addPatternStart) {
            re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
            return [re, hasMagic];
        }
        if (!hasMagic) {
            return globUnescape(pattern);
        }
        var flags = options.nocase ? 'i' : '';
        try {
            var regExp = new RegExp('^' + re + '$', flags);
        } catch (er) {
            return new RegExp('$.');
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
    }
    minimatch.makeRe = function (pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        var set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        var flags = options.nocase ? 'i' : '';
        var re = set
            .map(function (pattern) {
                return pattern
                    .map(function (p) {
                        return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
                    })
                    .join('\\/');
            })
            .join('|');
        re = '^(?:' + re + ')$';
        if (this.negate) re = '^(?!' + re + ').*$';
        try {
            this.regexp = new RegExp(re, flags);
        } catch (ex) {
            this.regexp = false;
        }
        return this.regexp;
    }
    minimatch.match = function (list, pattern, options) {
        options = options || {};
        var mm = new Minimatch(pattern, options);
        list = list.filter(function (f) {
            return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
            list.push(pattern);
        }
        return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
        this.debug('match', f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === '';
        if (f === '/' && partial) return true;
        var options = this.options;
        if (path$h.sep !== '/') {
            f = f.split(path$h.sep).join('/');
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, 'split', f);
        var set = this.set;
        this.debug(this.pattern, 'set', set);
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
            filename = f[i];
            if (filename) break;
        }
        for (i = 0; i < set.length; i++) {
            var pattern = set[i];
            var file = f;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            var hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) return true;
                return !this.negate;
            }
        }
        if (options.flipNegate) return false;
        return this.negate;
    }
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
        var options = this.options;
        this.debug('matchOne', { this: this, file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            if (p === false) return false;
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' || file[fi] === '..' || (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        return true;
                    } else {
                        if (swallowee === '.' || swallowee === '..' || (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                if (partial) {
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) return true;
                }
                return false;
            }
            var hit;
            if (typeof p === 'string') {
                if (options.nocase) {
                    hit = f.toLowerCase() === p.toLowerCase();
                } else {
                    hit = f === p;
                }
                this.debug('string match', p, f, hit);
            } else {
                hit = f.match(p);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
            return true;
        } else if (fi === fl) {
            return partial;
        } else if (pi === pl) {
            var emptyFileEnd = fi === fl - 1 && file[fi] === '';
            return emptyFileEnd;
        }
        throw new Error('wtf?');
    };
    function globUnescape(s) {
        return s.replace(/\\(.)/g, '$1');
    }
    function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }
    function uniqid$2() {
        return v4();
    }
    var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
        const pattern = [
            '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
            '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
        ].join('|');
        return new RegExp(pattern, onlyFirst ? void 0 : 'g');
    };
    const ansiRegex = ansiRegex$1;
    var stripAnsi$1 = (string) => (typeof string === 'string' ? string.replace(ansiRegex(), '') : string);
    function stripAnsi(string) {
        return stripAnsi$1(string);
    }
    function isTestEnv() {
        var _a;
        return (
            ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0
                ? void 0
                : _a.NODE_ENV) === 'test'
        );
    }
    function isChildProcess() {
        if (isTestEnv()) return false;
        return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
    }
    var __awaiter$g = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SEventEmitter extends SClass {
        constructor(settings = {}) {
            super(
                deepMerge(
                    {
                        eventEmitter: {
                            emitter: void 0,
                            asyncStart: false,
                            defaultCallTime: {},
                            bufferTimeout: 1e3,
                            bufferedEvents: [],
                            forceObject: ['log', 'warn', 'error'],
                            defaults: {},
                            bind: void 0,
                        },
                    },
                    settings || {},
                ),
            );
            this._asyncStarted = false;
            this._buffer = [];
            this._eventsStacks = {};
            this._onStackById = {};
        }
        static get global() {
            if (!this._globalInstance) {
                this._globalInstance = new SEventEmitter({
                    metas: {
                        id: 'sugarEventSPromise',
                    },
                });
            }
            return this._globalInstance;
        }
        static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
            const set = Object.assign(
                {
                    events: '*',
                    prefixEvent: false,
                    prefixValue: void 0,
                    stripAnsi: false,
                    trim: true,
                    keepLineBreak: true,
                    overrideEmitter: 'bind',
                    processor: void 0,
                    exclude: ['finally', 'resolve', 'reject', 'cancel', 'catch'],
                    filter: void 0,
                },
                settings !== null && settings !== void 0 ? settings : {},
            );
            if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== 'function')
                return sourceSEventEmitter;
            sourceSEventEmitter.on(set.events || '*', (value, metas) =>
                __awaiter$g(this, void 0, void 0, function* () {
                    var _a;
                    if (!metas) {
                        return;
                    }
                    if (set.exclude && set.exclude.indexOf(metas.event) !== -1) return;
                    if (set.filter && !set.filter(value, metas)) return;
                    if (set.stripAnsi) {
                        if (value && value.value && typeof value.value === 'string')
                            value.value = stripAnsi(value.value);
                        else if (typeof value === 'string') value = stripAnsi(value);
                    }
                    if (set.trim) {
                        if (value && value.value && typeof value.value === 'string') value.value = value.value.trim();
                        else if (typeof value === 'string') value = value.trim();
                    }
                    if (set.keepLineBreak === false) {
                        if (value && value.value && typeof value.value === 'string')
                            value.value = value.value.replace(/\r?\n|\r/g, '');
                        else if (typeof value === 'string') value = value.replace(/\r?\n|\r/g, '');
                    }
                    if (set.processor) {
                        const res = set.processor(value, metas);
                        if (Array.isArray(res) && res.length === 2) {
                            value = res[0];
                            metas = res[1];
                        } else if (typeof res === 'object' && res.value !== void 0 && res.metas !== void 0) {
                            value = res.value;
                            metas = res.metas;
                        } else {
                            value = res;
                        }
                    }
                    if (set.prefixValue) {
                        if (value && value.value && typeof value.value === 'string') {
                            value.value = `${set.prefixValue}${value.value}`;
                        } else if (typeof value === 'string') {
                            value = `${set.prefixValue}${value}`;
                        }
                    }
                    if (metas && metas.event) {
                        let emitStack = metas.event;
                        if (!metas.emitter) {
                            metas.emitter = this;
                        }
                        if (set.prefixEvent) {
                            if (typeof set.prefixEvent === 'string') {
                                emitStack = `${set.prefixEvent}.${metas.event}`;
                            } else {
                                emitStack = `${metas.name}`;
                            }
                            metas.event = emitStack;
                        }
                        const emitMetas = Object.assign(Object.assign({}, metas), {
                            level:
                                ((_a = metas === null || metas === void 0 ? void 0 : metas.level) !== null &&
                                _a !== void 0
                                    ? _a
                                    : 0) + 1,
                        });
                        if (destSEventEmitter instanceof SEventEmitter) {
                            if (set.overrideEmitter === 'bind' && destSEventEmitter.eventEmitterSettings.bind) {
                                emitMetas.emitter = destSEventEmitter.eventEmitterSettings.bind;
                            } else if (set.overrideEmitter === true) {
                                emitMetas.emitter = destSEventEmitter;
                            }
                        }
                        if (destSEventEmitter === process && isChildProcess() && process.send) {
                            if (value.value && value.value instanceof Error) {
                                value.value = fn$6(value.value);
                            }
                            process.send({
                                value,
                                metas: emitMetas,
                            });
                        } else {
                            destSEventEmitter.emit(metas.event, value, emitMetas);
                        }
                    }
                }),
            );
        }
        get eventEmitterSettings() {
            return this._settings.eventEmitter;
        }
        pipe(input, settings) {
            SEventEmitter.pipe(input, this, settings);
            return input;
        }
        pipeError(input, settings) {
            SEventEmitter.pipe(input, this, Object.assign(Object.assign({}, settings), { events: 'error' }));
            return input;
        }
        pipeFrom(input, settings) {
            return this.pipe(input, settings);
        }
        pipeTo(dest, settings) {
            SEventEmitter.pipe(this, dest, settings);
            return this;
        }
        start() {
            if (!this.eventEmitterSettings.asyncStart) return;
            this._asyncStarted = true;
            this._processBuffer();
        }
        _createMetas(event2, metas = {}) {
            var _a, _b, _c;
            return deepMerge(
                {
                    event: event2,
                    name: event2,
                    emitter:
                        (_b =
                            (_a = this.eventEmitterSettings.bind) !== null && _a !== void 0
                                ? _a
                                : metas === null || metas === void 0
                                ? void 0
                                : metas.emitter) !== null && _b !== void 0
                            ? _b
                            : this,
                    originalEmitter:
                        (_c = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null &&
                        _c !== void 0
                            ? _c
                            : this,
                    time: Date.now(),
                    level: 0,
                    id: uniqid$2(),
                },
                metas !== null && metas !== void 0 ? metas : {},
            );
        }
        emit(event2, value, metas) {
            return new Promise((resolve, reject) =>
                __awaiter$g(this, void 0, void 0, function* () {
                    let metasObj = this._createMetas(event2, metas);
                    const isFirstLevel = !metasObj.level;
                    if (
                        (this.eventEmitterSettings.forceObject === true ||
                            (Array.isArray(this.eventEmitterSettings.forceObject) &&
                                this.eventEmitterSettings.forceObject.indexOf(event2) !== -1)) &&
                        !plainObject$3(value)
                    ) {
                        value = {
                            value,
                        };
                    }
                    if (plainObject$3(value)) {
                        Object.keys(this.eventEmitterSettings.defaults).forEach((key) => {
                            var _a;
                            const parts = key.split(',').map((l) => l.trim());
                            if (parts.indexOf(event2) === -1 && parts.indexOf('*') === -1) return;
                            value = deepMerge(
                                value,
                                (_a = this.eventEmitterSettings.defaults) === null || _a === void 0 ? void 0 : _a[key],
                            );
                        });
                    }
                    if (event2 === 'ask') {
                        if (isFirstLevel) {
                            metasObj.askId = uniqid$2();
                        }
                    }
                    if (!this._asyncStarted && this.eventEmitterSettings.asyncStart) {
                        this._buffer.push({
                            event: event2,
                            value,
                            metas: metasObj,
                            resolve,
                            reject,
                        });
                        return;
                    }
                    this._emit({
                        event: event2,
                        value,
                        metas: metasObj,
                        resolve,
                        reject,
                    });
                }),
            );
        }
        _emit(logObj) {
            return __awaiter$g(this, void 0, void 0, function* () {
                if (logObj.event === 'ask') {
                    this.constructor.global.on(`answer.${logObj.metas.askId}:1`, (answer, metas) => {
                        logObj.resolve(answer);
                    });
                    this._emitEvents(logObj.event, logObj.value, logObj.metas);
                } else {
                    const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
                    logObj.resolve(res);
                }
            });
        }
        _registerNewEventsStacks(events) {
            if (typeof events === 'string') events = events.split(',').map((s) => s.trim());
            events.forEach((event2) => {
                if (!this._eventsStacks[event2]) {
                    this._eventsStacks[event2] = {
                        buffer: [],
                        callStack: [],
                    };
                }
            });
        }
        _registerCallbackInEventStack(event2, callback, settings = {}) {
            settings = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, settings);
            if (settings.id) {
                if (!this._onStackById[settings.id]) this._onStackById[settings.id] = [];
                this._onStackById[settings.id].push({
                    event: event2,
                    callback,
                    settings,
                });
            }
            if (!this._eventsStacks[event2]) {
                this._registerNewEventsStacks(event2);
            }
            const eventStackObj = this._eventsStacks[event2];
            let callNumber = settings.callNumber;
            if (callNumber === void 0 && this.eventEmitterSettings.defaultCallTime[event2] !== void 0) {
                callNumber = this.eventEmitterSettings.defaultCallTime[event2];
            } else if (callNumber === void 0) {
                callNumber = -1;
            }
            if (typeof callback === 'function')
                eventStackObj.callStack.push({
                    callback,
                    callNumber,
                    filter: settings.filter,
                    processor: settings.processor,
                    called: 0,
                });
            this._processBuffer();
            return this;
        }
        _processBuffer() {
            if (this._buffer.length > 0) {
                setTimeout(() => {
                    this._buffer = this._buffer.filter((item) => {
                        this._emit(item);
                        return false;
                    });
                }, this.eventEmitterSettings.bufferTimeout);
            }
        }
        _emitEventStack(event2, initialValue, metasObj) {
            return __awaiter$g(this, void 0, void 0, function* () {
                let currentCallbackReturnedValue = initialValue;
                if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
                    return currentCallbackReturnedValue;
                if (!this._eventsStacks[event2]) {
                    this._registerNewEventsStacks(event2);
                }
                let eventStackArray = [];
                const eventStackObj = this._eventsStacks[event2];
                if (eventStackObj && eventStackObj.callStack) {
                    eventStackArray = [...eventStackArray, ...eventStackObj.callStack];
                }
                Object.keys(this._eventsStacks).forEach((stackName) => {
                    if (stackName === event2) return;
                    if (minimatch_1(event2, stackName) && this._eventsStacks[stackName] !== void 0) {
                        eventStackArray = [...eventStackArray, ...this._eventsStacks[stackName].callStack];
                    }
                });
                eventStackArray.map((item) => item.called++);
                eventStackArray = eventStackArray.filter((item) => {
                    if (item.callNumber === -1) return true;
                    if (item.called <= item.callNumber) return true;
                    return false;
                });
                for (let i = 0; i < eventStackArray.length; i++) {
                    const item = eventStackArray[i];
                    if (!item.callback) return currentCallbackReturnedValue;
                    if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj)) continue;
                    if (item.processor) {
                        const res = item.processor(currentCallbackReturnedValue, metasObj);
                        if (Array.isArray(res) && res.length === 2) {
                            currentCallbackReturnedValue = res[0];
                            metasObj = res[1];
                        } else if (typeof res === 'object' && res.value !== void 0 && res.metas !== void 0) {
                            currentCallbackReturnedValue = res.value;
                            metasObj = res.metas;
                        } else {
                            currentCallbackReturnedValue = res;
                        }
                    }
                    const callbackResult = yield item.callback(
                        currentCallbackReturnedValue,
                        metasObj,
                        (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId)
                            ? (answer) => {
                                  this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
                              }
                            : void 0,
                    );
                    if (callbackResult !== void 0) {
                        currentCallbackReturnedValue = callbackResult;
                    }
                }
                return currentCallbackReturnedValue;
            });
        }
        _emitEvents(events, initialValue, metas) {
            return new Promise((resolve, reject) =>
                __awaiter$g(this, void 0, void 0, function* () {
                    if (!events) return this;
                    if (typeof events === 'string') events = events.split(',').map((s) => s.trim());
                    let currentStackResult = initialValue;
                    for (let i = 0; i < events.length; i++) {
                        const stackResult = yield this._emitEventStack(events[i], currentStackResult, metas);
                        if (stackResult !== void 0) {
                            currentStackResult = stackResult;
                        }
                    }
                    resolve(currentStackResult);
                }),
            );
        }
        on(events, callback, settings) {
            const set = deepMerge(
                {
                    filter: void 0,
                    processor: void 0,
                    id: void 0,
                },
                settings,
            );
            if (typeof events === 'string') events = events.split(',').map((s) => s.trim());
            events.forEach((name2) => {
                const splitedName = name2.split(':');
                let callNumber = -1;
                if (splitedName.length === 2) {
                    name2 = splitedName[0];
                    callNumber = parseInt(splitedName[1]);
                }
                this._registerCallbackInEventStack(name2, callback, {
                    callNumber,
                    filter: set.filter,
                    processor: set.processor,
                    id: set.id,
                });
            });
            return this;
        }
        off(event2, callback) {
            if (!callback) {
                if (this._eventsStacks[event2]) {
                    delete this._eventsStacks[event2];
                } else if (this._onStackById[event2]) {
                    this._onStackById[event2].forEach((onStackByIdObj) => {
                        this.off(onStackByIdObj.event, onStackByIdObj.callback);
                    });
                    delete this._onStackById[event2];
                }
                return this;
            }
            const eventStackObj = this._eventsStacks[event2];
            if (!eventStackObj) return this;
            eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
                if (item.callback === callback) return false;
                return true;
            });
            this._eventsStacks[event2] = eventStackObj;
            return this;
        }
        destroy() {
            this._eventsStacks = {};
        }
    }
    SEventEmitter.usableAsMixin = true;
    function plainObject$2(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name !== 'Object') return false;
        if (Object.prototype.toString.call(object) !== '[object Object]') return false;
        if (object !== Object(object)) return false;
        return true;
    }
    function __deepMerge$2(...args) {
        function merge(firstObj, secondObj) {
            const newObj = {};
            if (!firstObj && secondObj) return secondObj;
            if (!secondObj && firstObj) return firstObj;
            if (!firstObj && !secondObj) return {};
            const firstProps = Object.getOwnPropertyNames(firstObj);
            firstProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(firstObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else {
                    newObj[key] = firstObj[key];
                }
            });
            const secondProps = Object.getOwnPropertyNames(secondObj);
            secondProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(secondObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else if (plainObject$2(newObj[key]) && plainObject$2(secondObj[key])) {
                    newObj[key] = merge(newObj[key], secondObj[key]);
                } else {
                    newObj[key] = secondObj[key];
                }
            });
            return newObj;
        }
        let currentObj = {};
        for (let i = 0; i < args.length; i++) {
            const toMergeObj = args[i];
            currentObj = merge(currentObj, toMergeObj);
        }
        return currentObj;
    }
    function wait$1(timeout = 0) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, timeout);
        });
    }
    const fn$5 = function treatAsValue(promise, settings = {}) {
        settings = Object.assign({ during: -1 }, settings);
        let during = settings.during || -1;
        try {
            const proxy = Proxy.revocable(promise, {
                get(target, prop, receiver) {
                    if (prop === 'then') {
                        return target;
                    }
                    if (during > 0) during--;
                    else if (during === 0) {
                        proxy.revoke();
                    }
                    return Reflect.get(...arguments);
                },
            });
            proxy.proxy.restorePromiseBehavior = () => {
                proxy.revoke();
                return promise;
            };
            return proxy.proxy;
        } catch (e) {
            return promise;
        }
    };
    var __awaiter$f = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SPromise extends SClass.extends(Promise) {
        constructor(executorFnOrSettings = {}, settings) {
            let executorFn,
                resolvers = {};
            super(
                __deepMerge$2(
                    {
                        promise: {
                            treatCancelAs: 'resolve',
                            destroyTimeout: 1,
                            preventRejectOnThrow: true,
                            emitErrorEventOnThrow: true,
                            proxies: {
                                resolve: [],
                                reject: [],
                            },
                        },
                    },
                    typeof executorFnOrSettings === 'object' ? executorFnOrSettings : {},
                    settings !== null && settings !== void 0 ? settings : {},
                ),
                (resolve, reject) => {
                    resolvers.resolve = resolve;
                    new Promise((rejectPromiseResolve, rejectPromiseReject) => {
                        resolvers.reject = (...args) => {
                            rejectPromiseReject(...args);
                            if (this.promiseSettings.preventRejectOnThrow) {
                                resolve(...args);
                            } else {
                                reject(...args);
                            }
                        };
                    }).catch((e) => {
                        this.emit('catch', e);
                    });
                },
            );
            this._promiseState = 'pending';
            this._eventEmitter = new SEventEmitter(
                __deepMerge$2(
                    {
                        metas: this.metas,
                        eventEmitter: {},
                    },
                    this._settings,
                ),
            );
            this.expose(this._eventEmitter, {
                as: 'eventEmitter',
                props: ['on', 'off', 'emit', 'pipe', 'pipeError', 'pipeFrom', 'pipeTo', 'eventEmitterSettings'],
            });
            this._resolvers = resolvers;
            if (this._settings.promise.destroyTimeout !== -1) {
                this.on('finally', (v, m) => {
                    setTimeout(() => {
                        this.destroy();
                    }, this._settings.promise.destroyTimeout);
                });
            }
            executorFn = typeof executorFnOrSettings === 'function' ? executorFnOrSettings : null;
            if (executorFn) {
                const api = {};
                getMethods(this).forEach((func) => {
                    if (func.slice(0, 1) === '_') return;
                    api[func] = this[func].bind(this);
                });
                (() =>
                    __awaiter$f(this, void 0, void 0, function* () {
                        yield wait$1(0);
                        try {
                            yield executorFn(api);
                        } catch (e) {
                            if (this.promiseSettings.emitErrorEventOnThrow) {
                                this.emit('error', e);
                            }
                            this.reject(e);
                        }
                    }))();
            }
        }
        static treatAsValue(promise, settings = {}) {
            return fn$5(promise, settings);
        }
        get promiseSettings() {
            return this._settings.promise;
        }
        static get [Symbol.species]() {
            return Promise;
        }
        get [Symbol.toStringTag]() {
            return 'SPromise';
        }
        get promiseState() {
            return this._promiseState;
        }
        treatAsValue(settings = {}) {
            return fn$5(this, settings);
        }
        registerProxy(point, proxy) {
            const ar = point.split(',').map((l) => l.trim());
            ar.forEach((a) => {
                this._settings.promise.proxies[a].push(proxy);
            });
        }
        is(status) {
            const statusArray = status.split(',').map((l) => l.trim());
            if (statusArray.indexOf(this._promiseState) !== -1) return true;
            return false;
        }
        isPending() {
            return this._promiseState === 'pending';
        }
        isResolved() {
            return this._promiseState === 'resolved';
        }
        isRejected() {
            return this._promiseState === 'rejected';
        }
        isCanceled() {
            return this._promiseState === 'canceled';
        }
        isDestroyed() {
            return this._promiseState === 'destroyed';
        }
        resolve(arg, stacksOrder = 'resolve,finally') {
            return this._resolve(arg, stacksOrder);
        }
        _resolve(arg, stacksOrder = 'resolve,finally') {
            return __awaiter$f(this, void 0, void 0, function* () {
                if (this._promiseState === 'destroyed') return;
                this._promiseState = 'resolved';
                const stacksOrderArray = stacksOrder.split(',').map((l) => l.trim());
                for (let i = 0; i < stacksOrderArray.length; i++) {
                    const stack = stacksOrderArray[i];
                    arg = yield this.eventEmitter.emit(stack, arg);
                }
                for (const proxyFn of this._settings.promise.proxies.resolve || []) {
                    arg = yield proxyFn(arg);
                }
                this._resolvers.resolve(arg);
                return arg;
            });
        }
        reject(arg, stacksOrder = `catch,reject,finally`) {
            return this._reject(arg, stacksOrder);
        }
        _reject(arg, stacksOrder = `catch,reject,finally`) {
            return __awaiter$f(this, void 0, void 0, function* () {
                if (this._promiseState === 'destroyed') return;
                this._promiseState = 'rejected';
                const stacksOrderArray = stacksOrder.split(',').map((l) => l.trim());
                for (let i = 0; i < stacksOrderArray.length; i++) {
                    const stack = stacksOrderArray[i];
                    arg = yield this.eventEmitter.emit(stack, arg);
                }
                for (const proxyFn of this._settings.promise.proxies.reject || []) {
                    arg = yield proxyFn(arg);
                }
                this._resolvers.reject(arg);
                return arg;
            });
        }
        cancel(arg, stacksOrder = 'cancel,finally') {
            return this._cancel(arg, stacksOrder);
        }
        _cancel(arg, stacksOrder = 'cancel,finally') {
            if (this._promiseState === 'destroyed') return;
            return new Promise((resolve, reject) =>
                __awaiter$f(this, void 0, void 0, function* () {
                    this._promiseState = 'canceled';
                    const stacksOrderArray = stacksOrder.split(',').map((l) => l.trim());
                    for (let i = 0; i < stacksOrderArray.length; i++) {
                        const stack = stacksOrderArray[i];
                        arg = yield this.eventEmitter.emit(stack, arg);
                    }
                    if (this._settings.promise.treatCancelAs === 'reject') {
                        this._resolvers.reject(arg);
                    } else {
                        this._resolvers.resolve(arg);
                    }
                    resolve(arg);
                }),
            );
        }
        catch(...args) {
            super.catch(...args);
            return this.on('catch', ...args);
        }
        finally(...args) {
            return this.on('finally', ...args);
        }
        destroy() {
            this._eventEmitter.destroy();
            this._promiseState = 'destroyed';
        }
    }
    function isInteger(data) {
        return (
            typeof data === 'number' &&
            !isNaN(data) &&
            (function (x) {
                return (x | 0) === x;
            })(parseFloat(data))
        );
    }
    function upperFirst(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function typeOf(value, settings = {}) {
        settings = deepMerge(
            {
                of: false,
                customClass: true,
            },
            settings,
        );
        let type;
        if (Array.isArray(value)) type = 'Array';
        else if (value instanceof Map) type = 'Map';
        else if (value === null) type = 'Null';
        else if (value === void 0) type = 'Undefined';
        else if (typeof value === 'string') type = 'String';
        else if (isInteger(value)) type = 'Integer';
        else if (typeof value === 'number') type = 'Number';
        else if (typeof value === 'boolean') type = 'Boolean';
        else if (value instanceof RegExp) type = 'RegExp';
        else if (settings.customClass === true && cls$1(value) && value.name !== void 0) {
            type = upperFirst(value.name);
        } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
            type = upperFirst(value.constructor.name);
        } else if (settings.customClass === false && cls$1(value)) {
            type = 'Class';
        } else if (typeof value === 'function') type = 'Function';
        else if (typeof value === 'object') type = 'Object';
        else type = 'Unknown';
        const avoidTypes = ['Null', 'Undefined', 'String', 'Integer', 'Number', 'Boolean', 'Unknown'];
        if (settings.of === true && !avoidTypes.includes(type)) {
            const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
            const receivedTypes = [];
            loopOn.forEach((valueIndex) => {
                const valueToCheck = value[valueIndex];
                const childType = typeOf(valueToCheck, {
                    of: false,
                    customClass: settings.customClass,
                });
                if (!receivedTypes.includes(childType)) {
                    receivedTypes.push(childType);
                }
            });
            type += `<${receivedTypes.join('|')}>`;
        }
        return type;
    }
    const fn$4 = function (stack, callback, settings = {}) {
        settings = Object.assign({ newStack: false }, settings);
        const stackType = typeOf(stack).toLowerCase();
        let loopOnKeys;
        if (stackType === 'object') loopOnKeys = Object.keys(stack);
        else if (stackType === 'array') loopOnKeys = Array.from(Array(stack.length).keys());
        else if (stackType === 'number' || stackType === 'integer')
            loopOnKeys = Array.from(Array(Math.round(stack)).keys());
        else if (stackType === 'string') loopOnKeys = Array.from(stack);
        else if (stackType === 'set') loopOnKeys = Array.from(stack);
        else loopOnKeys = Array.from(stack.keys());
        if (stackType === 'string' || stackType === 'number' || stackType === 'integer' || stackType === 'set')
            settings.newStack = true;
        let newStack = [];
        if (stackType === 'object') newStack = {};
        else if (stackType === 'map') newStack = new Map();
        else if (stackType === 'set') newStack = new Set();
        let value;
        let newValue;
        const _get = (s, k) => {
            switch (typeOf(s).toLowerCase()) {
                case 'array':
                case 'object':
                    return s[k];
                case 'string':
                    return k;
                case 'number':
                case 'integer':
                    return k;
                case 'map':
                    return s.get(k);
                case 'set':
                    return k;
            }
        };
        const _set = (s, k, v) => {
            switch (typeOf(s).toLowerCase()) {
                case 'array':
                    if (settings.newStack === true) s.push(v);
                    else s[k] = v;
                    break;
                case 'object':
                    s[k] = v;
                    break;
                case 'number':
                case 'integer':
                case 'string':
                    s.push(v);
                    break;
                case 'map':
                    s.set(k, v);
                    break;
                case 'set':
                    s.add(v);
                    break;
            }
        };
        for (let i = 0; i < loopOnKeys.length; i++) {
            const key = loopOnKeys[i];
            value = _get(stack, key);
            newValue = callback({ key, prop: key, value, i, idx: i });
            if (newValue === -1) break;
            _set(settings.newStack ? newStack : stack, key, newValue);
        }
        if (stackType === 'string') {
            return newStack.join('');
        }
        return settings.newStack ? newStack : stack;
    };
    source$5.level = 3;
    const tagsMap = {
        black: (tag, content) => source$5.black(content),
        red: (tag, content) => source$5.red(content),
        green: (tag, content) => source$5.green(content),
        yellow: (tag, content) => source$5.yellow(content),
        blue: (tag, content) => source$5.blue(content),
        magenta: (tag, content) => source$5.magenta(content),
        cyan: (tag, content) => source$5.cyan(content),
        white: (tag, content) => source$5.white(content),
        grey: (tag, content) => source$5.grey(content),
        bgBlack: (tag, content) => source$5.bgBlack(content),
        bgRed: (tag, content) => source$5.bgRed(content),
        bgGreen: (tag, content) => source$5.bgGreen(content),
        bgYellow: (tag, content) => source$5.bgYellow(content),
        bgBlue: (tag, content) => source$5.bgBlue(content),
        bgMagenta: (tag, content) => source$5.bgMagenta(content),
        bgCyan: (tag, content) => source$5.bgCyan(content),
        bgWhite: (tag, content) => source$5.bgWhite(content),
        bold: (tag, content) => source$5.bold(content),
        dim: (tag, content) => source$5.dim(content),
        italic: (tag, content) => source$5.italic(content),
        underline: (tag, content) => source$5.underline(content),
        strike: (tag, content) => source$5.strike(content),
        h1: (tag, content) => {
            return source$5.underline(source$5.bold(content)) + '\n\n';
        },
        h2: (tag, content) => {
            return source$5.bold(content) + '\n';
        },
        date: (tag, content) =>
            new Date().getDate().toString().padStart('0', 2) +
            '-' +
            (new Date().getMonth() + 1).toString().padStart('0', 2) +
            '-' +
            new Date().getFullYear().toString().padStart('0', 2),
        time: (tag, content) =>
            new Date().getHours().toString().padStart('0', 2) +
            ':' +
            new Date().getMinutes().toString().padStart('0', 2) +
            ':' +
            new Date().getMinutes().toString().padStart('0', 2),
        day: (tag, content) => new Date().getDate().toString().padStart('0', 2),
        days: (tag, content) => new Date().getDate().toString().padStart('0', 2),
        month: (tag, content) => new Date().getMonth().toString().padStart('0', 2),
        months: (tag, content) => new Date().getMonth().toString().padStart('0', 2),
        year: (tag, content) => new Date().getFullYear().toString().padStart('0', 2),
        years: (tag, content) => new Date().getFullYear().toString().padStart('0', 2),
        hour: (tag, content) => new Date().getHours().toString().padStart('0', 2),
        hours: (tag, content) => new Date().getHours().toString().padStart('0', 2),
        minute: (tag, content) => new Date().getMinutes().toString().padStart('0', 2),
        minutes: (tag, content) => new Date().getMinutes().toString().padStart('0', 2),
        second: (tag, content) => new Date().getSeconds().toString().padStart('0', 2),
        seconds: (tag, content) => new Date().getSeconds().toString().padStart('0', 2),
        br: (tag, content) => '\n',
    };
    function replaceTags(text, tags) {
        if (!text) text = '';
        text = fn$6(text);
        let oneLineText = text.replace(/\r\n/g, '|rn|');
        oneLineText = oneLineText.replace(/\n/g, '|n|');
        oneLineText = oneLineText.replace(/\r/g, '|r|');
        Object.keys(tags).forEach((tagName) => {
            const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, 'g');
            const tagsArray = oneLineText.match(reg);
            const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, 'g');
            const singleTagsArray = oneLineText.match(singleReg);
            if (tagsArray) {
                for (let i = 0; i < tagsArray.length; i++) {
                    const t = tagsArray[i];
                    const tagArgs = t.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
                    if (!tagArgs) continue;
                    const tagToReplace = tagArgs[0];
                    const tagContent = tagArgs[1];
                    oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
                }
            }
            if (singleTagsArray) {
                for (let i = 0; i < singleTagsArray.length; i++) {
                    const t = singleTagsArray[i];
                    const tagArgs = t.match(`\\s?<${tagName}\\s?/>\\s?`);
                    if (!tagArgs) continue;
                    const tagToReplace = tagArgs[0];
                    const tagContent = '';
                    oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
                }
            }
        });
        oneLineText = oneLineText.replace(/\|rn\|/g, '\r\n');
        oneLineText = oneLineText.replace(/\|n\|/g, '\n');
        oneLineText = oneLineText.replace(/\|r\|/g, '\r');
        return oneLineText;
    }
    function parseHtml(message) {
        let isArray = false;
        if (Array.isArray(message)) {
            isArray = true;
        } else {
            message = [message];
        }
        message = message.map((m) => {
            return replaceTags(m, tagsMap);
        });
        if (isArray) return message;
        return message[0];
    }
    var parseHtml$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: parseHtml,
    });
    function parseSingleTypeString(typeString) {
        let ofStr = '',
            typeStr = typeString;
        const ofPartsString = typeString.match(/<(.+)>$/gm);
        if (ofPartsString && ofPartsString.length) {
            ofStr = ofPartsString[0].replace('<', '').replace('>', '');
        }
        if (ofStr !== '') {
            typeStr = typeStr.replace(`<${ofStr}>`, '');
        }
        let ofTypes = ofStr !== '' ? [ofStr.toLowerCase()] : void 0;
        if (ofStr !== void 0 && ofStr.includes('|')) {
            ofTypes = ofStr.split('|').map((t) => t.trim().toLowerCase());
        }
        return {
            type: typeStr,
            of: ofTypes,
        };
    }
    const fn$3 = function parseTypeString(typeString) {
        typeString = typeString.toLowerCase().trim();
        typeString = typeString
            .split('|')
            .map((part) => {
                part = part.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, 'array<$1>');
                return part;
            })
            .join('|');
        typeString = typeString
            .split('|')
            .map((part) => {
                part = part.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, 'object<$1>');
                return part;
            })
            .join('|');
        let types = [],
            inGroup = false,
            currentStr = '';
        for (let i = 0; i < typeString.length; i++) {
            const char = typeString[i];
            if (char === '<') {
                inGroup = true;
                currentStr += char;
            } else if (char === '>') {
                inGroup = false;
                currentStr += char;
            } else if (char === '|') {
                if (inGroup === false) {
                    types.push(currentStr);
                    currentStr = '';
                } else {
                    currentStr += char;
                }
            } else {
                currentStr += char;
            }
        }
        types.push(currentStr);
        const finalTypes = [];
        types.forEach((type) => {
            finalTypes.push(parseSingleTypeString(type));
        });
        const res = {
            raw: typeString,
            types: finalTypes,
        };
        return res;
    };
    var __isNode$2 = () => {
        return typeof process !== 'undefined' && process.release && process.release.name === 'node';
    };
    class STypeResult {
        constructor(data) {
            this._data = data;
        }
        get typeString() {
            return this._data.typeString;
        }
        get value() {
            return this._data.value;
        }
        get received() {
            return this._data.received;
        }
        get expected() {
            return this._data.expected;
        }
        get issues() {
            return this._data.issues;
        }
        get settings() {
            return this._data.settings;
        }
        hasIssues() {
            if (this._data) return true;
            return false;
        }
        toString() {
            if (__isNode$2()) {
                return this.toConsole();
            } else {
                return `The method "toHtml" has not being integrated for now...`;
            }
        }
        toConsole() {
            const headerArray = [
                `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
                '',
                '<underline>Received value</underline>',
                '',
                `${fn$6(this._data.value, {
                    beautify: true,
                })}`,
                '',
            ];
            const issuesArray = [];
            Object.keys(this._data.issues).forEach((ruleId) => {
                const issueObj = this._data.issues[ruleId];
                const message = [];
                if (issueObj.expected.type) {
                    message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
                }
                if (issueObj.received.type) {
                    message.push(`- Received "<red>${issueObj.received.type}</red>"`);
                }
                if (issueObj.message) {
                    message.push(['<underline>Details:</underline>', issueObj.message].join('\n'));
                }
                issuesArray.push(message.join('\n'));
            });
            const settingsArray = [
                '',
                `<underline>Settings</underline>`,
                '',
                `${fn$6(this._data.settings, {
                    beautify: true,
                })}`,
            ];
            return parseHtml(`
${headerArray.join('\n')}
${issuesArray.join('\n')}
${this.settings.verbose ? settingsArray.join('\n') : ''}
    `).trim();
        }
    }
    class SType {
        constructor(typeString, settings = {}) {
            this.typeString = typeString;
            typeString = typeString.toLowerCase().trim();
            if (this.constructor._instanciatedTypes[typeString] !== void 0)
                return this.constructor._instanciatedTypes[typeString];
            this.types = fn$3(typeString).types;
            this._settings = deepMerge(
                {
                    id: this.constructor.name,
                    name: this.constructor.name,
                    customTypes: true,
                    interfaces: true,
                },
                settings,
            );
            this.constructor._instanciatedTypes[typeString] = this;
        }
        static registerType(type) {
            if (type.id === void 0 || typeof type.id !== 'string') {
                throw new Error(
                    `Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`,
                );
            }
            this._registeredTypes[type.id] = type;
        }
        is(value, settings = {}) {
            const res = this.check(value, settings);
            if (res === true) return true;
            else if (res instanceof STypeResult) return !res.hasIssues();
            return true;
        }
        check(value, settings = {}) {
            settings = deepMerge(this._settings, settings);
            const issues = {};
            for (let i = 0; i < this.types.length; i++) {
                const typeObj = this.types[i],
                    typeId = typeObj.type;
                const res2 = this._isType(value, typeId, settings);
                if (res2 === true) {
                    if (typeObj.of === void 0) return true;
                    const typeOf$1 = typeOf(value);
                    if (typeOf$1 !== 'Array' && typeOf$1 !== 'Object' && typeOf$1 !== 'Map') {
                        throw new Error(
                            `Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf$1}</cyan>" that does not support "child" value(s)...`,
                        );
                    }
                    const loopOn = typeOf$1 === 'Object' ? Object.keys(value) : Array.from(value.keys());
                    if (!loopOn.length) return true;
                    for (let k = 0; k < loopOn.length; k++) {
                        for (let j = 0; j < typeObj.of.length; j++) {
                            const type = typeObj.of[j];
                            const idx = loopOn[k];
                            const v = typeOf$1 === 'Map' ? value.get(idx) : value[idx];
                            const ofRes = this._isType(v, type, settings);
                            if (ofRes !== true) {
                                issues[typeObj.type] = {
                                    expected: {
                                        type: typeObj.type,
                                    },
                                    received: {
                                        type: typeOf(v),
                                        value: v,
                                    },
                                };
                            } else {
                                return true;
                            }
                        }
                    }
                } else {
                    const issueObj = {
                        expected: {
                            type: typeObj.type,
                        },
                        received: {
                            type: typeOf(value),
                            value,
                        },
                    };
                    if (
                        res2 !== void 0 &&
                        res2 !== null &&
                        res2 !== false &&
                        res2.toString &&
                        typeof res2.toString === 'function'
                    ) {
                        issueObj.message = res2.toString();
                    }
                    issues[typeObj.type] = issueObj;
                }
            }
            const res = new STypeResult({
                typeString: this.typeString,
                value,
                expected: {
                    type: this.typeString,
                },
                received: {
                    type: typeOf(value),
                },
                issues,
                settings,
            });
            return res;
        }
        _isType(value, type, settings = {}) {
            settings = deepMerge(this._settings, settings);
            if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
                if (settings.interfaces === true) {
                    const availableInterfaceTypes = SInterface.getAvailableTypes();
                    if (availableInterfaceTypes[type] !== void 0) {
                        const res = availableInterfaceTypes[type].apply(value, {});
                        return res;
                    }
                }
                if (settings.customTypes === true) {
                    const typeOf$1 = typeOf(value).toLowerCase();
                    const extendsStack = Object.keys(fn$7(value)).map((s) => s.toLowerCase());
                    if (type === typeOf$1 || extendsStack.indexOf(type) !== -1) return true;
                }
                throw new Error(
                    `Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`,
                );
            }
            return this.constructor._registeredTypes[type.toLowerCase()].is(value);
        }
        cast(value, params, settings) {
            settings = deepMerge(this._settings, settings);
            const verboseObj = {
                value,
                issues: {},
                settings,
                toString() {
                    const strAr = Object.entries(this.issues);
                    return strAr.map((l) => l[1]).join('\n');
                },
            };
            if (this.is(value)) {
                return value;
            }
            for (let i = 0; i < this.types.length; i++) {
                const typeObj = this.types[i],
                    typeId = typeObj.type;
                const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
                if (descriptorObj === void 0) {
                    continue;
                }
                if (descriptorObj.cast === void 0) continue;
                let castedValue;
                castedValue = descriptorObj.cast(value, params);
                if (castedValue instanceof Error) {
                    verboseObj.issues[typeId] = castedValue.toString();
                    continue;
                }
                if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
                    const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join(
                        '|',
                    )}</green>" but this type can not have child(s)`;
                    throw new Error(parseHtml(issueStr));
                } else if (typeObj.of !== void 0) {
                    const sTypeInstance = new SType(typeObj.of.join('|'));
                    castedValue = fn$4(castedValue, ({ value: value2 }) => {
                        return sTypeInstance.cast(value2, params, settings);
                    });
                }
                if (castedValue === null && descriptorObj.id === 'null') return null;
                if (castedValue === void 0 && descriptorObj.id === 'undefined') return void 0;
                if (castedValue !== null && castedValue !== void 0) return castedValue;
                verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
            }
            const stack = [
                `Sorry but the value of type "<cyan>${typeOf(value)}</cyan>" passed to be casted in type "<yellow>${
                    this.typeString
                }</yellow>" can not be casted correctly. Here's why:
`,
            ];
            Object.keys(verboseObj.issues).forEach((descriptorId) => {
                stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
            });
            throw new Error(parseHtml(stack.join('\n')));
        }
        canHaveChilds(value) {
            const type = typeOf(value);
            return type === 'Array' || type === 'Object' || type === 'Map';
        }
        get name() {
            return this._settings.name;
        }
        get id() {
            return this._settings.id;
        }
    }
    SType._instanciatedTypes = {};
    SType._registeredTypes = {};
    function isString$2(value) {
        return typeof value === 'string' || value instanceof String;
    }
    const descriptor$g = {
        name: 'String',
        id: 'string',
        is: (value) => isString$2(value),
        cast: (value) =>
            fn$6(value, {
                beautify: true,
            }),
    };
    const descriptor$f = {
        name: 'Map',
        id: 'map',
        is: (value) => isMap$2(value),
        cast: (value) => {
            if (isMap$2(value)) return value;
            const map = new Map();
            map.set('value', value);
            return map;
        },
    };
    const descriptor$e = {
        name: 'Object',
        id: 'object',
        is: (value) => isObject$5(value),
        cast: (value) => {
            if (isObject$5(value)) return value;
            return {
                value,
            };
        },
    };
    const descriptor$d = {
        name: 'Array',
        id: 'array',
        is: (value) => {
            return Array.isArray(value);
        },
        cast: (value, params = {}) => {
            if (!value) return [];
            if (params.splitChars && Array.isArray(params.splitChars)) {
                value = value
                    .split(new RegExp(`(${params.splitChars.join('|')})`, 'gm'))
                    .filter((l) => l.trim() !== '' && params.splitChars.indexOf(l) === -1);
            }
            if (Array.isArray(value)) return value;
            return [value];
        },
    };
    const descriptor$c = {
        name: 'Integer',
        id: 'integer',
        is: (value) => Number.isInteger(value),
        cast: (value) => {
            if (typeof value !== 'string' && typeof value !== 'number') {
                return new Error(
                    `Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`,
                );
            }
            const res = parseInt(value);
            if (isNaN(res))
                return new Error(
                    `Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`,
                );
            return res;
        },
    };
    const descriptor$b = {
        name: 'Number',
        id: 'number',
        is: (value) => typeof value === 'number',
        cast: (value) => {
            if (typeof value !== 'string') {
                return new Error(`Sorry but only strings can be casted to numbers...`);
            }
            const res = parseFloat(value);
            if (isNaN(res))
                return new Error(
                    `Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`,
                );
            return res;
        },
    };
    const descriptor$a = {
        name: 'Boolean',
        id: 'boolean',
        is: (value) => typeof value === 'boolean',
        cast: (value, params = {}) => {
            if (value !== false && params && params.nullishAsTrue && !value) {
                return true;
            }
            if (typeof value === 'boolean') return value;
            if (value === null || value === void 0) return false;
            if (typeof value === 'number') {
                if (value > 0) return true;
                return false;
            }
            if (typeof value === 'string') {
                return value.length > 0 ? true : false;
            }
            if (Array.isArray(value)) {
                if (value.length > 0) return true;
                return false;
            }
            if (typeof value === 'object') {
                return Object.keys(value).length > 0 ? true : false;
            }
            return new Error(
                [
                    `Sorry but for now only these types can be casted to boolean:`,
                    '- <yellow>null</yellow>: Will be casted as <red>false</red>',
                    '- <yellow>undefined</yellow>: Will be casted as <red>false</red>',
                    '- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise',
                    '- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise',
                    '- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise',
                    '- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise',
                ].join('\n'),
            );
        },
    };
    const descriptor$9 = {
        name: 'Undefined',
        id: 'undefined',
        is: (value) => value === void 0,
        cast: (value) => {
            return void 0;
        },
    };
    const descriptor$8 = {
        name: 'Null',
        id: 'null',
        is: (value) => value === null,
        cast: (value) => {
            return null;
        },
    };
    const descriptor$7 = {
        name: 'Symbol',
        id: 'symbol',
        is: (value) => typeof value === 'symbol',
        cast: (value) => {
            if (typeof value === 'symbol') return value;
            return Symbol(value);
        },
    };
    const descriptor$6 = {
        name: 'Bigint',
        id: 'bigint',
        is: (value) => typeof value === 'bigint',
        cast: (value) => {
            if (typeof value === 'bigint') return value;
            if (typeof value !== 'string' && typeof value !== 'number') {
                return new Error(
                    `Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`,
                );
            }
            let res;
            try {
                res = BigInt(value);
            } catch (e) {
                res = new Error(
                    `It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`,
                );
            }
            return res;
        },
    };
    const descriptor$5 = {
        name: 'Date',
        id: 'date',
        is: (value) => value instanceof Date,
        cast: (value) => {
            if (typeof value === 'string') {
                return new Date(value);
            }
            if (typeof value === 'number') {
                return new Date(Math.round(value));
            }
            if (plainObject$3(value)) {
                const now = new Date();
                let year = now.getFullYear(),
                    month = 0,
                    day = 1,
                    hours = 0,
                    minutes = 0,
                    seconds = 0,
                    milliseconds = 0;
                if (value.year && typeof value.year === 'number') {
                    year = value.year;
                }
                if (value.month && typeof value.month === 'number') {
                    month = value.month;
                }
                if (value.day && typeof value.day === 'number') {
                    day = value.day;
                }
                if (value.hours && typeof value.hours === 'number') {
                    hours = value.hours;
                }
                if (value.minutes && typeof value.minutes === 'number') {
                    minutes = value.minutes;
                }
                if (value.seconds && typeof value.seconds === 'number') {
                    seconds = value.seconds;
                }
                if (value.milliseconds && typeof value.milliseconds === 'number') {
                    milliseconds = value.milliseconds;
                }
                return new Date(year, month, day, hours, minutes, seconds, milliseconds);
            }
            return new Error(
                `Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`,
            );
        },
    };
    const descriptor$4 = {
        name: 'Function',
        id: 'function',
        is: (value) => typeof value === 'function',
        cast: (value) => {
            return new Error(`Sorry but nothing is castable to a Function`);
        },
    };
    const descriptor$3 = {
        name: 'WeakMap',
        id: 'weakmap',
        is: (value) => value instanceof WeakMap,
        cast: (value) => {
            return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
        },
    };
    const descriptor$2 = {
        name: 'WeakSet',
        id: 'weakset',
        is: (value) => value instanceof WeakSet,
        cast: (value) => {
            return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
        },
    };
    const descriptor$1 = {
        name: 'Set',
        id: 'set',
        is: (value) => value instanceof Set,
        cast: (value) => {
            if (value instanceof Set) return value;
            const set = new Set();
            set.add(value);
            return set;
        },
    };
    const descriptor = {
        name: 'Class',
        id: 'class',
        is: (value) => cls$1(value),
        cast: (value) => {
            return new Error(`Sorry but nothing is castable to a Class`);
        },
    };
    SType.registerType(descriptor$g);
    SType.registerType(descriptor$f);
    SType.registerType(descriptor$e);
    SType.registerType(descriptor$d);
    SType.registerType(descriptor$c);
    SType.registerType(descriptor$b);
    SType.registerType(descriptor$a);
    SType.registerType(descriptor$9);
    SType.registerType(descriptor$8);
    SType.registerType(descriptor$7);
    SType.registerType(descriptor$6);
    SType.registerType(descriptor$5);
    SType.registerType(descriptor$4);
    SType.registerType(descriptor$3);
    SType.registerType(descriptor$2);
    SType.registerType(descriptor$1);
    SType.registerType(descriptor);
    function ofType(value, typeString, settings = {}) {
        settings = Object.assign({ verbose: false }, settings);
        const typeInstance = new SType(typeString, settings);
        const res = typeInstance.is(value);
        return res;
    }
    class SDescriptorResult extends SClass {
        constructor(descriptor, value, descriptorSettings) {
            super({});
            this._issues = {};
            this._descriptor = descriptor;
            this._descriptorSettings = descriptorSettings;
            try {
                this._originalValue = clone$4(value, { deep: true });
            } catch (e) {
                this._originalValue = value;
            }
            this.value = value;
        }
        hasIssues() {
            return Object.keys(this._issues).length >= 1;
        }
        add(ruleResult) {
            if (!ruleResult.__ruleObj.id) return;
            this._issues[ruleResult.__ruleObj.id] = ruleResult;
        }
        toString() {
            if (__isNode$2()) {
                return this.toConsole();
            } else {
                return this.toConsole();
            }
        }
        toConsole() {
            const headerArray = [
                `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
                '',
                `${fn$6(this.value, {
                    beautify: true,
                })}`,
                '',
            ];
            const issuesArray = [];
            Object.keys(this._issues).forEach((ruleId) => {
                const ruleResult = this._issues[ruleId];
                let message = '';
                if (ruleResult.__error && ruleResult.__error instanceof Error) {
                    message = ruleResult.__error.message;
                } else if (
                    ruleResult.__ruleObj.message !== void 0 &&
                    typeof ruleResult.__ruleObj.message === 'function'
                ) {
                    message = ruleResult.__ruleObj.message(ruleResult);
                } else if (
                    ruleResult.__ruleObj.message !== void 0 &&
                    typeof ruleResult.__ruleObj.message === 'string'
                ) {
                    message = ruleResult.__ruleObj.message;
                }
                issuesArray.push(
                    `-${
                        typeof ruleResult.__propName === 'string'
                            ? ` [<magenta>${ruleResult.__propName}</magenta>]`
                            : ''
                    } <red>${ruleId}</red>: ${message}`,
                );
            });
            const settingsArray = [
                '',
                `<underline>Settings</underline>`,
                '',
                `${fn$6(this._descriptorSettings, {
                    beautify: true,
                })}`,
            ];
            return parseHtml(`
${headerArray.join('\n')}
${issuesArray.join('\n')}
${settingsArray.join('\n')}
    `).trim();
        }
    }
    /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2016, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    var isExtglob$1 = function isExtglob(str) {
        if (typeof str !== 'string' || str === '') {
            return false;
        }
        var match;
        while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
            if (match[2]) return true;
            str = str.slice(match.index + match[0].length);
        }
        return false;
    };
    /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    var isExtglob = isExtglob$1;
    var chars = { '{': '}', '(': ')', '[': ']' };
    var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
    var isGlob = function isGlob(str, options) {
        if (typeof str !== 'string' || str === '') {
            return false;
        }
        if (isExtglob(str)) {
            return true;
        }
        var regex = strictRegex;
        var match;
        if (options && options.strict === false) {
            regex = relaxedRegex;
        }
        while ((match = regex.exec(str))) {
            if (match[2]) return true;
            var idx = match.index + match[0].length;
            var open = match[1];
            var close = open ? chars[open] : null;
            if (open && close) {
                var n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    };
    var __isGlob = (string) => {
        return isGlob(string);
    };
    class SDescriptor extends SClass {
        constructor(settings) {
            super(
                deepMerge(
                    {
                        descriptor: {
                            rules: {},
                            type: 'Object',
                            arrayAsValue: false,
                            throwOnMissingRule: false,
                            defaults: true,
                        },
                    },
                    settings !== null && settings !== void 0 ? settings : {},
                ),
            );
        }
        static registerRule(rule) {
            if (rule.id === void 0 || typeof rule.id !== 'string') {
                throw new Error(
                    `Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`,
                );
            }
            this._registeredRules[rule.id] = rule;
        }
        get descriptorSettings() {
            return this._settings.descriptor;
        }
        apply(value, settings) {
            const set = deepMerge(this.descriptorSettings, settings || {});
            if (value === void 0 || value === null) value = {};
            const valuesObjToProcess = {},
                finalValuesObj = {};
            this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set));
            const rules = set.rules;
            if (!ofType(value, set.type)) {
                throw new Error(
                    `Sorry but this descriptor "<yellow>${
                        this.metas.name
                    }</yellow>" does not accept values of type "<cyan>${typeOf(value)}</cyan>" but only "<green>${
                        set.type
                    }</green>"...`,
                );
            }
            if (Array.isArray(value) && !set.arrayAsValue) {
                throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
            } else if (typeof value === 'object' && value !== null && value !== void 0) {
                Object.keys(rules).forEach((propName) => {
                    if (__isGlob(propName) && value);
                    else {
                        valuesObjToProcess[propName] = get$3(value, propName);
                    }
                });
                Object.keys(valuesObjToProcess).forEach((propName) => {
                    const ruleObj = rules[propName];
                    if (valuesObjToProcess[propName] === void 0 && set.defaults && ruleObj.default !== void 0) {
                        valuesObjToProcess[propName] = ruleObj.default;
                    }
                    if (ruleObj.interface !== void 0) {
                        const interfaceValue = valuesObjToProcess[propName];
                        valuesObjToProcess[propName] = ruleObj.interface.apply(interfaceValue || {}, {});
                    }
                    const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj, set);
                    if (validationResult !== void 0 && validationResult !== null) {
                        __set(finalValuesObj, propName, validationResult);
                    }
                });
            } else {
                console.warn(value);
                throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
            }
            if (this._descriptorResult.hasIssues()) {
                throw new Error(this._descriptorResult.toString());
            }
            return this._descriptorResult;
        }
        _validate(value, propName, rulesObj, settings) {
            if (rulesObj === void 0) return value;
            if (rulesObj.required === void 0 || rulesObj.required === false) {
                if (value === void 0 || value === null) return value;
            }
            let rulesNamesInOrder = Object.keys(rulesObj).filter((l) => l !== 'default');
            rulesNamesInOrder = rulesNamesInOrder
                .sort((a, b) => {
                    const objA = this.constructor._registeredRules[a];
                    const objB = this.constructor._registeredRules[b];
                    if (!objA) return -1;
                    if (!objB) return 1;
                    if (objA.priority === void 0) objA.priority = 9999999999;
                    if (objB.priority === void 0) objB.priority = 9999999999;
                    return objA.priotity - objB.priority;
                })
                .reverse();
            let resultValue = value;
            rulesNamesInOrder.forEach((ruleName) => {
                const ruleValue = rulesObj[ruleName];
                if (this.constructor._registeredRules[ruleName] === void 0) {
                    if (settings.throwOnMissingRule) {
                        throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join('\n- ')}`);
                    }
                } else {
                    const ruleObj = this.constructor._registeredRules[ruleName];
                    const params = ruleObj.processParams !== void 0 ? ruleObj.processParams(ruleValue) : ruleValue;
                    const ruleSettings = ruleObj.settings !== void 0 ? ruleObj.settings : {};
                    if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
                        let newResultValue = [];
                        resultValue.forEach((v) => {
                            const processedValue = this._processRule(
                                v,
                                ruleObj,
                                propName,
                                params,
                                ruleSettings,
                                settings,
                            );
                            if (Array.isArray(processedValue)) {
                                newResultValue = [...newResultValue, ...processedValue];
                            } else {
                                newResultValue.push(processedValue);
                            }
                        });
                        resultValue = newResultValue;
                    } else {
                        const processedValue = this._processRule(
                            resultValue,
                            ruleObj,
                            propName,
                            params,
                            ruleSettings,
                            settings,
                        );
                        resultValue = processedValue;
                    }
                }
            });
            return resultValue;
        }
        _processRule(value, ruleObj, propName, params, ruleSettings, settings) {
            const ruleResult = ruleObj.apply(
                value,
                params,
                ruleSettings,
                Object.assign(Object.assign({}, settings), { propName, name: `${settings.name}.${propName}` }),
            );
            if (params && params.type && params.type.toLowerCase() === 'boolean' && ruleResult === true) {
                return true;
            }
            if (ruleResult instanceof Error) {
                const obj = {
                    __error: ruleResult,
                    __ruleObj: ruleObj,
                    __propName: propName,
                };
                if (this._descriptorResult) {
                    this._descriptorResult.add(obj);
                    throw new Error(this._descriptorResult.toString());
                }
            } else {
                return ruleResult;
            }
        }
    }
    SDescriptor._registeredRules = {};
    SDescriptor.rules = {};
    SDescriptor.type = 'Object';
    const ruleObj$3 = {
        priority: 1,
        name: 'Required',
        id: 'required',
        settings: {
            when: [void 0, null],
        },
        message: 'This value is required',
        processParams: (params) => {
            return { value: params };
        },
        apply: (value, params, ruleSettings, settings) => {
            if (params.value === true) {
                if (ruleSettings.when.indexOf(value) !== -1) {
                    return new Error('This property is <yellow>required</yellow>');
                }
            }
            return value;
        },
    };
    const ruleObj$2 = {
        prority: 10,
        name: 'Type',
        id: 'type',
        settings: {},
        processParams: (params) => {
            var _a, _b;
            if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== 'string') {
                throw new Error(
                    `<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`,
                );
            }
            return Object.assign(Object.assign({}, typeof params !== 'string' ? params : {}), {
                type: (_a = params.type) !== null && _a !== void 0 ? _a : params,
                cast: (_b = params.cast) !== null && _b !== void 0 ? _b : true,
            });
        },
        apply: (value, params, ruleSettings, settings) => {
            const type = new SType(params.type, {
                metas: {
                    id: settings.id,
                },
            });
            if (params.cast && !type.is(value)) {
                value = type.cast(value, params);
            }
            if (!type.is(value)) {
                return new Error(
                    `The value must be of type "<yellow>${
                        params.type
                    }</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`,
                );
            }
            return value;
        },
    };
    const ruleObj$1 = {
        name: 'Min',
        id: 'min',
        settings: {},
        accept: 'Number',
        message: (resultObj) => {
            return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
        },
        processParams: (params) => {
            return { value: params };
        },
        apply: (value, params, ruleSettings, settings) => {
            if (value < params.value) {
                return new Error(
                    `<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`,
                );
            }
            return value;
        },
    };
    const ruleObj = {
        name: 'Max',
        id: 'max',
        settings: {},
        accept: 'Number',
        message: (resultObj) => {
            return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
        },
        processParams: (params) => {
            return { value: params };
        },
        apply: (value, params, ruleSettings, settings) => {
            if (value > params.value) {
                return new Error(
                    `<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`,
                );
            }
            return value;
        },
    };
    SDescriptor.registerRule(ruleObj$3);
    SDescriptor.registerRule(ruleObj$2);
    SDescriptor.registerRule(ruleObj$1);
    SDescriptor.registerRule(ruleObj);
    function parseArgs(string, settings = {}) {
        settings = deepMerge(
            {
                throw: true,
                defaultObj: {},
                cast: true,
                valueQuote: void 0,
            },
            settings,
        );
        string = string.trim();
        string = string.replace(/(["'`])--/gm, '$1--\xA7 --');
        let valueQuote = settings.valueQuote;
        if (!valueQuote) {
            for (let i = 0; i < string.length; i++) {
                const char = string[i];
                if (char === '"' || char === '`' || char === "'") {
                    valueQuote = char;
                    break;
                }
            }
            if (!valueQuote) valueQuote = '"';
        }
        let stringArray = [];
        let isFunctionStyle = false;
        if (string.match(/^\(/) && string.match(/\)$/)) {
            isFunctionStyle = true;
            string = string.slice(1, -1);
            let currentStr = '';
            let parenthesisCount = 0;
            let quotesCount = 0;
            for (let i = 0; i < string.length; i++) {
                const char = string[i];
                const previousChar = string[i - 1] || string[0];
                if (char === valueQuote && previousChar !== '\\' && !quotesCount) {
                    quotesCount++;
                } else if (char === valueQuote && previousChar !== '\\' && quotesCount) {
                    quotesCount--;
                }
                if (!quotesCount && char === '(') {
                    parenthesisCount++;
                } else if (!quotesCount && char === ')') {
                    parenthesisCount--;
                }
                if (char === ',') {
                    if (quotesCount || parenthesisCount) {
                        currentStr += char;
                    } else {
                        stringArray.push(currentStr.trim());
                        currentStr = '';
                    }
                } else {
                    currentStr += char;
                }
            }
            if (parenthesisCount) currentStr += ')'.repeat(parenthesisCount);
            stringArray.push(currentStr.trim());
        } else {
            let currentStr = '';
            let quotesCount = false;
            for (let i = 0; i < string.length; i++) {
                const char = string[i];
                const previousChar = string[i - 1] || string[0];
                if (char === valueQuote && previousChar !== '\\' && !quotesCount) {
                    quotesCount = true;
                } else if (char === valueQuote && previousChar !== '\\' && quotesCount) {
                    quotesCount = false;
                }
                if (char === ' ') {
                    if (quotesCount) {
                        currentStr += char;
                    } else {
                        stringArray.push(currentStr.trim());
                        currentStr = '';
                    }
                } else {
                    currentStr += char;
                }
            }
            stringArray.push(currentStr.trim());
        }
        stringArray = stringArray.map((item) => unquote(item));
        const argsObj = {};
        let currentArgName = void 0;
        let currentValue;
        stringArray = stringArray.forEach((part, i) => {
            if (!isFunctionStyle && !part.includes(' ') && (part.slice(0, 2) === '--' || part.slice(0, 1) === '-')) {
                if (
                    currentValue === void 0 &&
                    currentArgName !== -1 &&
                    currentArgName &&
                    argsObj[currentArgName] === void 0
                ) {
                    argsObj[currentArgName] = true;
                }
                currentArgName = part.replace(/^[-]{1,2}/, '');
                if (argsObj[currentArgName] === void 0) {
                    argsObj[currentArgName] = true;
                }
            } else {
                let value;
                if (part && typeof part === 'string') {
                    value = part
                        .replace(/^\\\\\\`/, '')
                        .replace(/\\\\\\`$/, '')
                        .replace(/^'/, '')
                        .replace(/'$/, '')
                        .replace(/^"/, '')
                        .replace(/"$/, '');
                    if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
                        const parts = part.split(':');
                        currentArgName = parts[0].trim().replace(/^\$/, '');
                        value = parts.slice(1).join(':').trim();
                    }
                }
                currentValue = __parse(value);
                if (typeof currentValue === 'string') {
                    currentValue = currentValue.replace('--\xA7 ', '');
                }
                if (currentArgName !== void 0) {
                    if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
                        if (!Array.isArray(argsObj[currentArgName])) {
                            argsObj[currentArgName] = [argsObj[currentArgName]];
                        }
                        argsObj[currentArgName].push(currentValue);
                    } else {
                        argsObj[currentArgName] = currentValue;
                    }
                    currentValue = void 0;
                    currentArgName = void 0;
                } else {
                    argsObj[i] = currentValue;
                }
            }
        });
        Object.keys(argsObj).forEach((key) => {
            const value = argsObj[key];
            if (value === void 0) delete argsObj[key];
        });
        return argsObj;
    }
    function getAvailableInterfaceTypes() {
        if (global !== void 0) return global._registeredInterfacesTypes || {};
        else if (window !== void 0) return window._registeredInterfacesTypes || {};
        else return {};
    }
    if (__isNode$2()) global._registeredInterfacesTypes = {};
    else window._registeredInterfacesTypes = {};
    class SInterface extends SClass {
        constructor(settings) {
            super(
                deepMerge(
                    {
                        interface: {},
                    },
                    settings !== null && settings !== void 0 ? settings : {},
                ),
            );
            this._definition = {};
            this._definition = this.constructor.definition;
        }
        static get definition() {
            if (!this._definition.help) {
                this._definition.help = {
                    type: 'Boolean',
                    description: `Display the help for this "<yellow>${this.name}</yellow>" interface...`,
                    default: false,
                };
            }
            return this._definition;
        }
        static set definition(value) {
            this._definition = value;
        }
        get interfaceSettings() {
            return this._settings.interface;
        }
        static registerRenderer(rendererClass) {
            if (!rendererClass.id) {
                throw new Error(
                    `Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`,
                );
            }
            this._registeredRenderers[rendererClass.id] = rendererClass;
        }
        static override(definition) {
            const _this = this;
            class SInterfaceOverrided extends this {}
            SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
            SInterfaceOverrided.definition = deepMerge(_this.definition, definition);
            return SInterfaceOverrided;
        }
        static getAvailableTypes() {
            return getAvailableInterfaceTypes();
        }
        static makeAvailableAsType(name2 = null) {
            const n = (name2 || this.name).toLowerCase();
            if (global !== void 0) {
                global._registeredInterfacesTypes[n] = this;
                global._registeredInterfacesTypes[n.replace('interface', '')] = this;
            } else if (window !== void 0) {
                window._registeredInterfacesTypes[n] = this;
                window._registeredInterfacesTypes[n.replace('interface', '')] = this;
            }
        }
        static toObject() {
            var _a;
            return {
                name: this.name,
                description: (_a = this.description) !== null && _a !== void 0 ? _a : '',
                definition: Object.assign({}, this.definition),
            };
        }
        static defaults() {
            const defaults = {};
            Object.keys(this.definition).forEach((key) => {
                const propObj = this.definition[key];
                if (propObj.default !== void 0) {
                    defaults[key] = propObj.default;
                }
            });
            return defaults;
        }
        static apply(objectOrString, settings) {
            const int = new this({
                interface: settings !== null && settings !== void 0 ? settings : {},
            });
            return int.apply(objectOrString);
        }
        static render(renderer = 'terminal', settings) {
            const set = deepMerge(
                {
                    renderer: 'terminal',
                    exclude: ['help'],
                },
                settings,
            );
            if (!this._registeredRenderers[renderer]) {
                throw new Error(
                    `Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(
                        this._registeredRenderers,
                    ).join(', ')}</green>`,
                );
            }
            const rendererInstance = new this._registeredRenderers[renderer](this, set);
            return rendererInstance.render();
        }
        apply(objectOrString, settings) {
            var _a;
            const set = deepMerge(this.interfaceSettings, settings !== null && settings !== void 0 ? settings : {});
            let objectOnWhichToApplyInterface = objectOrString;
            if (typeof objectOrString === 'string') {
                objectOnWhichToApplyInterface = parseArgs(objectOrString);
                Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
                    for (let i = 0; i < Object.keys(this._definition).length; i++) {
                        const defArgName = Object.keys(this._definition)[i];
                        const obj = this._definition[defArgName];
                        if (obj.explicit) {
                            if (obj.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj.alias}\\s`))) return;
                            else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`))) return;
                            delete objectOnWhichToApplyInterface[argName];
                        }
                    }
                });
                Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
                    for (let i = 0; i < Object.keys(this._definition).length; i++) {
                        const defArgName = Object.keys(this._definition)[i];
                        const obj = this._definition[defArgName];
                        if (!obj.alias) continue;
                        if (obj.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
                            objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
                            delete objectOnWhichToApplyInterface[argName];
                        }
                    }
                });
                Object.keys(objectOnWhichToApplyInterface).forEach((argName, i) => {
                    if (argName === `${i}`) {
                        const definitionKeys = Object.keys(this._definition);
                        if (definitionKeys[i]) {
                            objectOnWhichToApplyInterface[definitionKeys[i]] = objectOnWhichToApplyInterface[argName];
                        }
                        delete objectOnWhichToApplyInterface[argName];
                    }
                });
            }
            const descriptor = new SDescriptor({
                descriptor: Object.assign(
                    { type: 'Object', rules: this._definition },
                    (_a = set.descriptor) !== null && _a !== void 0 ? _a : {},
                ),
            });
            if (set.baseObj) {
                objectOnWhichToApplyInterface = deepMerge(set.baseObj, objectOnWhichToApplyInterface);
            }
            const descriptorResult = descriptor.apply(objectOnWhichToApplyInterface);
            if (descriptorResult.hasIssues()) {
                throw new Error(descriptorResult.toString());
            }
            return descriptorResult.value;
        }
    }
    SInterface._definition = {};
    SInterface.description = '';
    SInterface._registeredRenderers = {};
    function uniqid$1() {
        return v4();
    }
    function matches$2(el, selector) {
        if (el.nodeName == '#comment' || el.nodeName == '#text') {
            return false;
        }
        const p = Element.prototype;
        const f =
            p.matches ||
            p.webkitMatchesSelector ||
            p.mozMatchesSelector ||
            p.msMatchesSelector ||
            function (s) {
                return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
            };
        return f.call(el, selector);
    }
    let _observer$2;
    const _selectors$2 = {};
    function querySelectorLive$2(selector, cb = null, settings = {}) {
        const id = `${selector} - ${uniqid$1()}`;
        settings = Object.assign(
            {},
            {
                rootNode: document,
                once: true,
            },
            settings,
        );
        if (!_selectors$2[selector]) {
            _selectors$2[selector] = [
                {
                    id,
                    selector,
                    cb,
                    lastMutationId: null,
                    settings,
                },
            ];
        } else {
            _selectors$2[selector].push({
                id,
                selector,
                cb,
                lastMutationId: null,
                settings,
            });
        }
        return new SPromise(({ resolve, reject, emit }) => {
            function pushNewNode(node, sel, mutationId) {
                const objs = _selectors$2[sel];
                if (!objs) return;
                objs.forEach((obj) => {
                    if (obj.lastMutationId && obj.lastMutationId === mutationId) return;
                    if (obj.settings.once) {
                        if (!node._querySelectorLive) {
                            node._querySelectorLive = {};
                        }
                        if (node._querySelectorLive[obj.id]) return;
                        node._querySelectorLive[obj.id] = true;
                    }
                    emit('node', node);
                    obj.cb &&
                        obj.cb(node, () => {
                            delete _selectors$2[obj.selector];
                        });
                });
            }
            if (!_observer$2) {
                _observer$2 = new MutationObserver((mutations) => {
                    const mutationId = `mutation-${uniqid$1()}`;
                    mutations.forEach((mutation) => {
                        if (mutation.addedNodes && mutation.addedNodes.length) {
                            [].forEach.call(mutation.addedNodes, (node) => {
                                const selectors = Object.keys(_selectors$2);
                                selectors.forEach((sel) => {
                                    if (matches$2(node, sel)) {
                                        pushNewNode(node, sel, mutationId);
                                    }
                                });
                                if (!node.querySelectorAll) return;
                                selectors.forEach((sel) => {
                                    const nestedNodes = node.querySelectorAll(sel);
                                    [].forEach.call(nestedNodes, (nestedNode) => {
                                        pushNewNode(nestedNode, sel, mutationId);
                                    });
                                });
                            });
                        } else if (mutation.attributeName) {
                            const selectors = Object.keys(_selectors$2);
                            selectors.forEach((sel) => {
                                if (matches$2(mutation.target, sel)) {
                                    pushNewNode(mutation.target, sel, mutationId);
                                }
                            });
                        }
                    });
                });
                _observer$2.observe(settings.rootNode, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class', 'id'],
                });
            }
            [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
                pushNewNode(node, selector, 'init');
            });
        });
    }
    class SDocblockToHtmlComponentInterface extends SInterface {}
    SDocblockToHtmlComponentInterface.definition = {
        src: {
            type: 'String',
            required: true,
            alias: 's',
        },
    };
    const Component$1 = {
        css: ``,
        exports: {
            onBeforeMount() {
                return __async(this, null, function* () {
                    this.$props = SDocblockToHtmlComponentInterface.apply(this.props);
                    const response = yield fetch(this.$props.src);
                    const value = yield response.text();
                    this.root.innerHTML = value;
                });
            },
        },
        template: null,
        name: 's-inline-svg',
    };
    register('s-inline-svg', Component$1);
    querySelectorLive$2('s-inline-svg:not([mounted])', ($elm) => {
        const id = $elm.id || 's-inline-svg-' + uniqid$1();
        $elm.setAttribute('id', id);
        mount('#' + id);
    });
    Component$1.mount = () => {
        mount('s-inline-svg');
    };
    var axios$2 = { exports: {} };
    var bind$2 = function bind(fn, thisArg) {
        return function wrap() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
            }
            return fn.apply(thisArg, args);
        };
    };
    var bind$1 = bind$2;
    var toString$2 = Object.prototype.toString;
    function isArray$6(val) {
        return toString$2.call(val) === '[object Array]';
    }
    function isUndefined$1(val) {
        return typeof val === 'undefined';
    }
    function isBuffer(val) {
        return (
            val !== null &&
            !isUndefined$1(val) &&
            val.constructor !== null &&
            !isUndefined$1(val.constructor) &&
            typeof val.constructor.isBuffer === 'function' &&
            val.constructor.isBuffer(val)
        );
    }
    function isArrayBuffer(val) {
        return toString$2.call(val) === '[object ArrayBuffer]';
    }
    function isFormData(val) {
        return typeof FormData !== 'undefined' && val instanceof FormData;
    }
    function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
            result = ArrayBuffer.isView(val);
        } else {
            result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
    }
    function isString$1(val) {
        return typeof val === 'string';
    }
    function isNumber$1(val) {
        return typeof val === 'number';
    }
    function isObject$3(val) {
        return val !== null && typeof val === 'object';
    }
    function isPlainObject(val) {
        if (toString$2.call(val) !== '[object Object]') {
            return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
    }
    function isDate$1(val) {
        return toString$2.call(val) === '[object Date]';
    }
    function isFile$1(val) {
        return toString$2.call(val) === '[object File]';
    }
    function isBlob(val) {
        return toString$2.call(val) === '[object Blob]';
    }
    function isFunction$3(val) {
        return toString$2.call(val) === '[object Function]';
    }
    function isStream(val) {
        return isObject$3(val) && isFunction$3(val.pipe);
    }
    function isURLSearchParams(val) {
        return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }
    function trim(str) {
        return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }
    function isStandardBrowserEnv() {
        if (
            typeof navigator !== 'undefined' &&
            (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')
        ) {
            return false;
        }
        return typeof window !== 'undefined' && typeof document !== 'undefined';
    }
    function forEach(obj, fn) {
        if (obj === null || typeof obj === 'undefined') {
            return;
        }
        if (typeof obj !== 'object') {
            obj = [obj];
        }
        if (isArray$6(obj)) {
            for (var i = 0, l = obj.length; i < l; i++) {
                fn.call(null, obj[i], i, obj);
            }
        } else {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    fn.call(null, obj[key], key, obj);
                }
            }
        }
    }
    function merge$1() {
        var result = {};
        function assignValue(val, key) {
            if (isPlainObject(result[key]) && isPlainObject(val)) {
                result[key] = merge$1(result[key], val);
            } else if (isPlainObject(val)) {
                result[key] = merge$1({}, val);
            } else if (isArray$6(val)) {
                result[key] = val.slice();
            } else {
                result[key] = val;
            }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
            forEach(arguments[i], assignValue);
        }
        return result;
    }
    function extend$2(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
            if (thisArg && typeof val === 'function') {
                a[key] = bind$1(val, thisArg);
            } else {
                a[key] = val;
            }
        });
        return a;
    }
    function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
            content = content.slice(1);
        }
        return content;
    }
    var utils$e = {
        isArray: isArray$6,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString: isString$1,
        isNumber: isNumber$1,
        isObject: isObject$3,
        isPlainObject,
        isUndefined: isUndefined$1,
        isDate: isDate$1,
        isFile: isFile$1,
        isBlob,
        isFunction: isFunction$3,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge: merge$1,
        extend: extend$2,
        trim,
        stripBOM,
    };
    var utils$d = utils$e;
    function encode$1(val) {
        return encodeURIComponent(val)
            .replace(/%3A/gi, ':')
            .replace(/%24/g, '$')
            .replace(/%2C/gi, ',')
            .replace(/%20/g, '+')
            .replace(/%5B/gi, '[')
            .replace(/%5D/gi, ']');
    }
    var buildURL$2 = function buildURL(url, params, paramsSerializer) {
        if (!params) {
            return url;
        }
        var serializedParams;
        if (paramsSerializer) {
            serializedParams = paramsSerializer(params);
        } else if (utils$d.isURLSearchParams(params)) {
            serializedParams = params.toString();
        } else {
            var parts = [];
            utils$d.forEach(params, function serialize(val, key) {
                if (val === null || typeof val === 'undefined') {
                    return;
                }
                if (utils$d.isArray(val)) {
                    key = key + '[]';
                } else {
                    val = [val];
                }
                utils$d.forEach(val, function parseValue(v) {
                    if (utils$d.isDate(v)) {
                        v = v.toISOString();
                    } else if (utils$d.isObject(v)) {
                        v = JSON.stringify(v);
                    }
                    parts.push(encode$1(key) + '=' + encode$1(v));
                });
            });
            serializedParams = parts.join('&');
        }
        if (serializedParams) {
            var hashmarkIndex = url.indexOf('#');
            if (hashmarkIndex !== -1) {
                url = url.slice(0, hashmarkIndex);
            }
            url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
        }
        return url;
    };
    var utils$c = utils$e;
    function InterceptorManager$1() {
        this.handlers = [];
    }
    InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
        this.handlers.push({
            fulfilled,
            rejected,
        });
        return this.handlers.length - 1;
    };
    InterceptorManager$1.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
            this.handlers[id] = null;
        }
    };
    InterceptorManager$1.prototype.forEach = function forEach(fn) {
        utils$c.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
                fn(h);
            }
        });
    };
    var InterceptorManager_1 = InterceptorManager$1;
    var utils$b = utils$e;
    var transformData$1 = function transformData(data, headers, fns) {
        utils$b.forEach(fns, function transform(fn) {
            data = fn(data, headers);
        });
        return data;
    };
    var isCancel$1 = function isCancel(value) {
        return !!(value && value.__CANCEL__);
    };
    var utils$a = utils$e;
    var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
        utils$a.forEach(headers, function processHeader(value, name2) {
            if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
                headers[normalizedName] = value;
                delete headers[name2];
            }
        });
    };
    var enhanceError$1 = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
            error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: this.config,
                code: this.code,
            };
        };
        return error;
    };
    var enhanceError = enhanceError$1;
    var createError$2 = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
    };
    var createError$1 = createError$2;
    var settle$1 = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
            resolve(response);
        } else {
            reject(
                createError$1(
                    'Request failed with status code ' + response.status,
                    response.config,
                    null,
                    response.request,
                    response,
                ),
            );
        }
    };
    var utils$9 = utils$e;
    var cookies$1 = utils$9.isStandardBrowserEnv()
        ? (function standardBrowserEnv() {
              return {
                  write: function write(name2, value, expires, path, domain, secure) {
                      var cookie = [];
                      cookie.push(name2 + '=' + encodeURIComponent(value));
                      if (utils$9.isNumber(expires)) {
                          cookie.push('expires=' + new Date(expires).toGMTString());
                      }
                      if (utils$9.isString(path)) {
                          cookie.push('path=' + path);
                      }
                      if (utils$9.isString(domain)) {
                          cookie.push('domain=' + domain);
                      }
                      if (secure === true) {
                          cookie.push('secure');
                      }
                      document.cookie = cookie.join('; ');
                  },
                  read: function read(name2) {
                      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name2 + ')=([^;]*)'));
                      return match ? decodeURIComponent(match[3]) : null;
                  },
                  remove: function remove(name2) {
                      this.write(name2, '', Date.now() - 864e5);
                  },
              };
          })()
        : (function nonStandardBrowserEnv() {
              return {
                  write: function write() {},
                  read: function read() {
                      return null;
                  },
                  remove: function remove() {},
              };
          })();
    var isAbsoluteURL$1 = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
    };
    var isAbsoluteURL = isAbsoluteURL$1;
    var combineURLs = combineURLs$1;
    var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
            return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
    };
    var utils$8 = utils$e;
    var ignoreDuplicateOf = [
        'age',
        'authorization',
        'content-length',
        'content-type',
        'etag',
        'expires',
        'from',
        'host',
        'if-modified-since',
        'if-unmodified-since',
        'last-modified',
        'location',
        'max-forwards',
        'proxy-authorization',
        'referer',
        'retry-after',
        'user-agent',
    ];
    var parseHeaders$1 = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
            return parsed;
        }
        utils$8.forEach(headers.split('\n'), function parser(line) {
            i = line.indexOf(':');
            key = utils$8.trim(line.substr(0, i)).toLowerCase();
            val = utils$8.trim(line.substr(i + 1));
            if (key) {
                if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                    return;
                }
                if (key === 'set-cookie') {
                    parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
                } else {
                    parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                }
            }
        });
        return parsed;
    };
    var utils$7 = utils$e;
    var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv()
        ? (function standardBrowserEnv() {
              var msie = /(msie|trident)/i.test(navigator.userAgent);
              var urlParsingNode = document.createElement('a');
              var originURL;
              function resolveURL(url) {
                  var href = url;
                  if (msie) {
                      urlParsingNode.setAttribute('href', href);
                      href = urlParsingNode.href;
                  }
                  urlParsingNode.setAttribute('href', href);
                  return {
                      href: urlParsingNode.href,
                      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                      host: urlParsingNode.host,
                      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                      hostname: urlParsingNode.hostname,
                      port: urlParsingNode.port,
                      pathname:
                          urlParsingNode.pathname.charAt(0) === '/'
                              ? urlParsingNode.pathname
                              : '/' + urlParsingNode.pathname,
                  };
              }
              originURL = resolveURL(window.location.href);
              return function isURLSameOrigin(requestURL) {
                  var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                  return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
              };
          })()
        : (function nonStandardBrowserEnv() {
              return function isURLSameOrigin() {
                  return true;
              };
          })();
    var utils$6 = utils$e;
    var settle = settle$1;
    var cookies = cookies$1;
    var buildURL$1 = buildURL$2;
    var buildFullPath = buildFullPath$1;
    var parseHeaders = parseHeaders$1;
    var isURLSameOrigin = isURLSameOrigin$1;
    var createError = createError$2;
    var xhr = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
            var requestData = config.data;
            var requestHeaders = config.headers;
            if (utils$6.isFormData(requestData)) {
                delete requestHeaders['Content-Type'];
            }
            var request = new XMLHttpRequest();
            if (config.auth) {
                var username = config.auth.username || '';
                var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
                requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
            }
            var fullPath = buildFullPath(config.baseURL, config.url);
            request.open(
                config.method.toUpperCase(),
                buildURL$1(fullPath, config.params, config.paramsSerializer),
                true,
            );
            request.timeout = config.timeout;
            request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                    return;
                }
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                    return;
                }
                var responseHeaders =
                    'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
                var responseData =
                    !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
                var response = {
                    data: responseData,
                    status: request.status,
                    statusText: request.statusText,
                    headers: responseHeaders,
                    config,
                    request,
                };
                settle(resolve, reject, response);
                request = null;
            };
            request.onabort = function handleAbort() {
                if (!request) {
                    return;
                }
                reject(createError('Request aborted', config, 'ECONNABORTED', request));
                request = null;
            };
            request.onerror = function handleError() {
                reject(createError('Network Error', config, null, request));
                request = null;
            };
            request.ontimeout = function handleTimeout() {
                var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
                if (config.timeoutErrorMessage) {
                    timeoutErrorMessage = config.timeoutErrorMessage;
                }
                reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request));
                request = null;
            };
            if (utils$6.isStandardBrowserEnv()) {
                var xsrfValue =
                    (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName
                        ? cookies.read(config.xsrfCookieName)
                        : void 0;
                if (xsrfValue) {
                    requestHeaders[config.xsrfHeaderName] = xsrfValue;
                }
            }
            if ('setRequestHeader' in request) {
                utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
                    if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
                        delete requestHeaders[key];
                    } else {
                        request.setRequestHeader(key, val);
                    }
                });
            }
            if (!utils$6.isUndefined(config.withCredentials)) {
                request.withCredentials = !!config.withCredentials;
            }
            if (config.responseType) {
                try {
                    request.responseType = config.responseType;
                } catch (e) {
                    if (config.responseType !== 'json') {
                        throw e;
                    }
                }
            }
            if (typeof config.onDownloadProgress === 'function') {
                request.addEventListener('progress', config.onDownloadProgress);
            }
            if (typeof config.onUploadProgress === 'function' && request.upload) {
                request.upload.addEventListener('progress', config.onUploadProgress);
            }
            if (config.cancelToken) {
                config.cancelToken.promise.then(function onCanceled(cancel) {
                    if (!request) {
                        return;
                    }
                    request.abort();
                    reject(cancel);
                    request = null;
                });
            }
            if (!requestData) {
                requestData = null;
            }
            request.send(requestData);
        });
    };
    var utils$5 = utils$e;
    var normalizeHeaderName = normalizeHeaderName$1;
    var DEFAULT_CONTENT_TYPE = {
        'Content-Type': 'application/x-www-form-urlencoded',
    };
    function setContentTypeIfUnset(headers, value) {
        if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers['Content-Type'])) {
            headers['Content-Type'] = value;
        }
    }
    function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== 'undefined') {
            adapter = xhr;
        } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
            adapter = xhr;
        }
        return adapter;
    }
    var defaults$4 = {
        adapter: getDefaultAdapter(),
        transformRequest: [
            function transformRequest(data, headers) {
                normalizeHeaderName(headers, 'Accept');
                normalizeHeaderName(headers, 'Content-Type');
                if (
                    utils$5.isFormData(data) ||
                    utils$5.isArrayBuffer(data) ||
                    utils$5.isBuffer(data) ||
                    utils$5.isStream(data) ||
                    utils$5.isFile(data) ||
                    utils$5.isBlob(data)
                ) {
                    return data;
                }
                if (utils$5.isArrayBufferView(data)) {
                    return data.buffer;
                }
                if (utils$5.isURLSearchParams(data)) {
                    setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
                    return data.toString();
                }
                if (utils$5.isObject(data)) {
                    setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
                    return JSON.stringify(data);
                }
                return data;
            },
        ],
        transformResponse: [
            function transformResponse(data) {
                if (typeof data === 'string') {
                    try {
                        data = JSON.parse(data);
                    } catch (e) {}
                }
                return data;
            },
        ],
        timeout: 0,
        xsrfCookieName: 'XSRF-TOKEN',
        xsrfHeaderName: 'X-XSRF-TOKEN',
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
        },
    };
    defaults$4.headers = {
        common: {
            Accept: 'application/json, text/plain, */*',
        },
    };
    utils$5.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
        defaults$4.headers[method] = {};
    });
    utils$5.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
        defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults$4;
    var utils$4 = utils$e;
    var transformData = transformData$1;
    var isCancel = isCancel$1;
    var defaults$3 = defaults_1;
    function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
        }
    }
    var dispatchRequest$1 = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData(config.data, config.headers, config.transformRequest);
        config.headers = utils$4.merge(
            config.headers.common || {},
            config.headers[config.method] || {},
            config.headers,
        );
        utils$4.forEach(
            ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
            function cleanHeaderConfig(method) {
                delete config.headers[method];
            },
        );
        var adapter = config.adapter || defaults$3.adapter;
        return adapter(config).then(
            function onAdapterResolution(response) {
                throwIfCancellationRequested(config);
                response.data = transformData(response.data, response.headers, config.transformResponse);
                return response;
            },
            function onAdapterRejection(reason) {
                if (!isCancel(reason)) {
                    throwIfCancellationRequested(config);
                    if (reason && reason.response) {
                        reason.response.data = transformData(
                            reason.response.data,
                            reason.response.headers,
                            config.transformResponse,
                        );
                    }
                }
                return Promise.reject(reason);
            },
        );
    };
    var utils$3 = utils$e;
    var mergeConfig$2 = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        var valueFromConfig2Keys = ['url', 'method', 'data'];
        var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
        var defaultToConfig2Keys = [
            'baseURL',
            'transformRequest',
            'transformResponse',
            'paramsSerializer',
            'timeout',
            'timeoutMessage',
            'withCredentials',
            'adapter',
            'responseType',
            'xsrfCookieName',
            'xsrfHeaderName',
            'onUploadProgress',
            'onDownloadProgress',
            'decompress',
            'maxContentLength',
            'maxBodyLength',
            'maxRedirects',
            'transport',
            'httpAgent',
            'httpsAgent',
            'cancelToken',
            'socketPath',
            'responseEncoding',
        ];
        var directMergeKeys = ['validateStatus'];
        function getMergedValue(target, source) {
            if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
                return utils$3.merge(target, source);
            } else if (utils$3.isPlainObject(source)) {
                return utils$3.merge({}, source);
            } else if (utils$3.isArray(source)) {
                return source.slice();
            }
            return source;
        }
        function mergeDeepProperties(prop) {
            if (!utils$3.isUndefined(config2[prop])) {
                config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (!utils$3.isUndefined(config1[prop])) {
                config[prop] = getMergedValue(void 0, config1[prop]);
            }
        }
        utils$3.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
            if (!utils$3.isUndefined(config2[prop])) {
                config[prop] = getMergedValue(void 0, config2[prop]);
            }
        });
        utils$3.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
        utils$3.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
            if (!utils$3.isUndefined(config2[prop])) {
                config[prop] = getMergedValue(void 0, config2[prop]);
            } else if (!utils$3.isUndefined(config1[prop])) {
                config[prop] = getMergedValue(void 0, config1[prop]);
            }
        });
        utils$3.forEach(directMergeKeys, function merge(prop) {
            if (prop in config2) {
                config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (prop in config1) {
                config[prop] = getMergedValue(void 0, config1[prop]);
            }
        });
        var axiosKeys = valueFromConfig2Keys
            .concat(mergeDeepPropertiesKeys)
            .concat(defaultToConfig2Keys)
            .concat(directMergeKeys);
        var otherKeys = Object.keys(config1)
            .concat(Object.keys(config2))
            .filter(function filterAxiosKeys(key) {
                return axiosKeys.indexOf(key) === -1;
            });
        utils$3.forEach(otherKeys, mergeDeepProperties);
        return config;
    };
    var utils$2 = utils$e;
    var buildURL = buildURL$2;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    function Axios$1(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager(),
        };
    }
    Axios$1.prototype.request = function request(config) {
        if (typeof config === 'string') {
            config = arguments[1] || {};
            config.url = arguments[0];
        } else {
            config = config || {};
        }
        config = mergeConfig$1(this.defaults, config);
        if (config.method) {
            config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
            config.method = this.defaults.method.toLowerCase();
        } else {
            config.method = 'get';
        }
        var chain = [dispatchRequest, void 0];
        var promise = Promise.resolve(config);
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            chain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            chain.push(interceptor.fulfilled, interceptor.rejected);
        });
        while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
    };
    Axios$1.prototype.getUri = function getUri(config) {
        config = mergeConfig$1(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };
    utils$2.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
        Axios$1.prototype[method] = function (url, config) {
            return this.request(
                mergeConfig$1(config || {}, {
                    method,
                    url,
                    data: (config || {}).data,
                }),
            );
        };
    });
    utils$2.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
        Axios$1.prototype[method] = function (url, data, config) {
            return this.request(
                mergeConfig$1(config || {}, {
                    method,
                    url,
                    data,
                }),
            );
        };
    });
    var Axios_1 = Axios$1;
    function Cancel$1(message) {
        this.message = message;
    }
    Cancel$1.prototype.toString = function toString() {
        return 'Cancel' + (this.message ? ': ' + this.message : '');
    };
    Cancel$1.prototype.__CANCEL__ = true;
    var Cancel_1 = Cancel$1;
    var Cancel = Cancel_1;
    function CancelToken(executor) {
        if (typeof executor !== 'function') {
            throw new TypeError('executor must be a function.');
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        var token = this;
        executor(function cancel(message) {
            if (token.reason) {
                return;
            }
            token.reason = new Cancel(message);
            resolvePromise(token.reason);
        });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
            throw this.reason;
        }
    };
    CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel,
        };
    };
    var CancelToken_1 = CancelToken;
    var spread = function spread(callback) {
        return function wrap(arr) {
            return callback.apply(null, arr);
        };
    };
    var isAxiosError = function isAxiosError(payload) {
        return typeof payload === 'object' && payload.isAxiosError === true;
    };
    var utils$1 = utils$e;
    var bind = bind$2;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults$2 = defaults_1;
    function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils$1.extend(instance, Axios.prototype, context);
        utils$1.extend(instance, context);
        return instance;
    }
    var axios$1 = createInstance(defaults$2);
    axios$1.Axios = Axios;
    axios$1.create = function create(instanceConfig) {
        return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
    };
    axios$1.Cancel = Cancel_1;
    axios$1.CancelToken = CancelToken_1;
    axios$1.isCancel = isCancel$1;
    axios$1.all = function all(promises) {
        return Promise.all(promises);
    };
    axios$1.spread = spread;
    axios$1.isAxiosError = isAxiosError;
    axios$2.exports = axios$1;
    axios$2.exports.default = axios$1;
    var axios = axios$2.exports;
    function strToHtml(string) {
        if (document !== void 0 && document.createElement !== void 0) {
            const cont = document.createElement('div');
            cont.innerHTML = string;
            if (cont.children.length === 1) {
                return cont.children[0];
            } else {
                return cont;
            }
        }
        return string;
    }
    function toStringFn(html, deep = true) {
        if (document !== void 0 && document.createElement !== void 0) {
            const cont = document.createElement('div');
            cont.appendChild(html.cloneNode(deep));
            return cont.innerHTML;
        }
        return html;
    }
    function convert$1(from, to = 'ms') {
        let fromMs = from;
        if (typeof from === 'string') {
            const fromNumber = parseFloat(from);
            const fromLength = fromNumber.toString().length;
            const fromString = from.slice(fromLength);
            if (fromString === 'ms' || fromString === 'millisecond' || fromString === 'milliseconds') {
                fromMs = fromNumber;
            } else if (fromString === 's' || fromString === 'second' || fromString === 'seconds') {
                fromMs = fromNumber * 1e3;
            } else if (fromString === 'm' || fromString === 'minute' || fromString === 'minutes') {
                fromMs = fromNumber * 60 * 1e3;
            } else if (fromString === 'h' || fromString === 'hour' || fromString === 'hours') {
                fromMs = fromNumber * 60 * 60 * 1e3;
            } else if (fromString === 'd' || fromString === 'day' || fromString === 'days') {
                fromMs = fromNumber * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'w' || fromString === 'week' || fromString === 'weeks') {
                fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'month' || fromString === 'months') {
                fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'y' || fromString === 'year' || fromString === 'years') {
                fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
            }
        }
        switch (to) {
            case 'ms':
            case 'millisecond':
            case 'milliseconds':
                return fromMs;
            case 's':
            case 'second':
            case 'seconds':
                return fromMs / 1e3;
            case 'm':
            case 'minute':
            case 'minutes':
                return fromMs / 1e3 / 60;
            case 'h':
            case 'hour':
            case 'hours':
                return fromMs / 1e3 / 60 / 60;
            case 'd':
            case 'day':
            case 'days':
                return fromMs / 1e3 / 60 / 60 / 24;
            case 'w':
            case 'week':
            case 'weeks':
                return fromMs / 1e3 / 60 / 60 / 24 / 7;
            case 'month':
            case 'months':
                return fromMs / 1e3 / 60 / 60 / 24 / 31;
            case 'y':
            case 'year':
            case 'years':
                return fromMs / 1e3 / 60 / 60 / 24 / 365;
            default:
                throw new Error(
                    `You try to convert "${from}" to "${to}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`,
                );
        }
    }
    convert$1.MILLISECOND = 'ms';
    convert$1.SECOND = 's';
    convert$1.MINUTE = 'm';
    convert$1.HOUR = 'h';
    convert$1.DAY = 'd';
    convert$1.WEEK = 'w';
    convert$1.MONTH = 'month';
    convert$1.YEAR = 'y';
    class SRequestConfig {
        constructor(params) {
            this.url = null;
            this.baseURL = null;
            this.method = 'GET';
            this.headers = {};
            this.params = {};
            this.data = {};
            this.timeout = 0;
            this.sendInterval = 1e3;
            this.sendCount = 1;
            this.everyResponse = null;
            this.responseType = 'json';
            if (params.timeout && typeof params.timeout === 'string') params.timeout = convert$1(params.timeout, 'ms');
            if (params.sendInterval && typeof params.sendInterval === 'string')
                params.sendInterval = convert$1(params.sendInterval, 'ms');
            Object.assign(this, params);
        }
    }
    class SRequest extends SClass {
        constructor(request, settings) {
            super(
                deepMerge(
                    {
                        request: {},
                    },
                    settings !== null && settings !== void 0 ? settings : {},
                ),
            );
            this._defaultRequestSettings = {};
            this._currentRequestSettings = {};
            this._requestsCount = 0;
            if (!(request instanceof SRequestConfig)) {
                this._defaultRequestSettings = new SRequestConfig(request);
            } else {
                this._defaultRequestSettings = request;
            }
        }
        get requestSettings() {
            return this._settings.request;
        }
        _onSuccess(response) {
            let finalResponse = response.data;
            const contentType = response.headers['content-type'] || 'text/plain';
            const hash =
                this._currentRequestSettings.url.indexOf('#') !== -1
                    ? this._currentRequestSettings.url.split('#')[1]
                    : false;
            if (
                contentType === 'text/html' &&
                hash !== false &&
                document !== void 0 &&
                document.querySelector !== void 0
            ) {
                const $html = strToHtml(response.data);
                if ($html.id === hash) {
                    finalResponse = toStringFn($html);
                } else {
                    const $part = $html.querySelector(`#${hash}`);
                    if ($part) {
                        finalResponse = toStringFn($part);
                    }
                }
            } else if (contentType === 'application/json') {
                finalResponse = JSON.parse(response.data);
            }
            response.data = finalResponse;
            delete response.config;
            delete response.request;
            this._responsesArray.push(response);
            if (this._currentRequestSettings.everyResponse) {
                this._currentRequestSettings.everyResponse(Object.assign({}, response), this._requestsCount);
            }
            if (this._requestsCount >= this._currentRequestSettings.sendCount) {
                this._resolve(this._responsesArray.length <= 1 ? this._responsesArray[0] : this._responsesArray);
            } else {
                this._send();
            }
        }
        _onError(error) {
            console.log('EEE', error);
            this._reject(error);
        }
        _send(requestSettings = {}) {
            this._requestsCount++;
            requestSettings = deepMerge(this._defaultRequestSettings, requestSettings);
            if (requestSettings.beforeSend) {
                requestSettings = requestSettings.beforeSend(requestSettings, this._requestsCount);
            }
            this._currentRequestSettings = Object.assign(requestSettings);
            axios(requestSettings).then(this._onSuccess.bind(this)).catch(this._onError.bind(this));
        }
        retry() {
            return this.send();
        }
        send(requestSettings = {}) {
            return new Promise((resolve, reject) => {
                this._requestsCount = 0;
                this._responsesArray = [];
                this._resolve = resolve;
                this._reject = reject;
                this._send(requestSettings);
            });
        }
    }
    function camelize(text) {
        let res = '';
        const reg = /(?:^|[_-\s])(\w)/g;
        res = text.replace(reg, function (_, c) {
            return c ? c.toUpperCase() : '';
        });
        res = res.substr(0, 1).toLowerCase() + res.slice(1);
        return res.trim();
    }
    function camelCase(text) {
        return camelize(text);
    }
    var __awaiter$e = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    function whenInViewport(elm, settings = {}) {
        settings = Object.assign({ offset: 250 }, settings);
        return new Promise((resolve) =>
            __awaiter$e(this, void 0, void 0, function* () {
                const options = {
                    root: null,
                    rootMargin: `${settings.offset}px`,
                    threshold: 1,
                };
                function onChange(changes, observer2) {
                    changes.forEach((change) => {
                        if (change.intersectionRatio > 0) {
                            observer2.disconnect();
                            resolve(elm);
                        }
                    });
                }
                const observer = new IntersectionObserver(onChange, options);
                observer.observe(elm);
            }),
        );
    }
    function injectStyle(style, node = document.head) {
        const $tag = document.createElement('style');
        $tag.type = 'text/css';
        $tag.innerHTML = style;
        node.appendChild($tag);
        return $tag;
    }
    /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
    var __assign$1 = function () {
        __assign$1 =
            Object.assign ||
            function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
        return __assign$1.apply(this, arguments);
    };
    function lowerCase(str) {
        return str.toLowerCase();
    }
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    function noCase(input, options) {
        if (options === void 0) {
            options = {};
        }
        var _a = options.splitRegexp,
            splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a,
            _b = options.stripRegexp,
            stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b,
            _c = options.transform,
            transform = _c === void 0 ? lowerCase : _c,
            _d = options.delimiter,
            delimiter = _d === void 0 ? ' ' : _d;
        var result = replace(replace(input, splitRegexp, '$1\0$2'), stripRegexp, '\0');
        var start = 0;
        var end = result.length;
        while (result.charAt(start) === '\0') start++;
        while (result.charAt(end - 1) === '\0') end--;
        return result.slice(start, end).split('\0').map(transform).join(delimiter);
    }
    function replace(input, re, value) {
        if (re instanceof RegExp) return input.replace(re, value);
        return re.reduce(function (input2, re2) {
            return input2.replace(re2, value);
        }, input);
    }
    function dotCase(input, options) {
        if (options === void 0) {
            options = {};
        }
        return noCase(input, __assign$1({ delimiter: '.' }, options));
    }
    function paramCase(input, options) {
        if (options === void 0) {
            options = {};
        }
        return dotCase(input, __assign$1({ delimiter: '-' }, options));
    }
    function dashCase(text) {
        return paramCase(text);
    }
    var __awaiter$d = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SComponentUtilsDefaultInterface extends SInterface {}
    SComponentUtilsDefaultInterface.definition = {
        id: {
            type: 'String',
            physical: true,
        },
        mounted: {
            type: 'Boolean',
            default: false,
            physical: true,
        },
        mountWhen: {
            type: 'String',
            values: ['directly', 'inViewport'],
            default: 'directly',
        },
        adoptStyle: {
            type: 'Boolean',
            default: true,
            physical: true,
        },
        defaultStyle: {
            type: 'Boolean',
            default: false,
            physical: true,
        },
    };
    class SComponentUtils extends SClass {
        constructor(name2, node, props, settings = {}) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            var _l;
            super(
                deepMerge(
                    {
                        componentUtils: {
                            get rootNode() {
                                var _a2;
                                return (_a2 = node.shadowRoot) === null || _a2 === void 0
                                    ? void 0
                                    : _a2.querySelector('*:first-child');
                            },
                        },
                    },
                    settings,
                ),
            );
            this.$targets = [];
            this.shouldUpdate = false;
            this.name = name2;
            this.node = node;
            if (!this.node.tagName) this.node = this.node.parentNode;
            if (
                ((_b = (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.tagName) === null ||
                _b === void 0
                    ? void 0
                    : _b.toLowerCase()) === this.name
            ) {
                this.node = node.parentNode;
            }
            let InterfaceToApply =
                ((_l = class InlineComponentUtilsInterface extends SInterface {}), (_l.definition = {}), _l);
            InterfaceToApply.definition = Object.assign(
                Object.assign({}, Object.assign({}, SComponentUtilsDefaultInterface.definition)),
                (_d =
                    (_c = this.componentUtilsSettings.interface) === null || _c === void 0 ? void 0 : _c.definition) !==
                    null && _d !== void 0
                    ? _d
                    : {},
            );
            this._InterfaceToApply = InterfaceToApply;
            const defaultProps = deepMerge(
                InterfaceToApply.defaults(),
                (_e = this.componentUtilsSettings.defaultProps) !== null && _e !== void 0 ? _e : {},
                (_f = this.constructor._defaultProps['*']) !== null && _f !== void 0 ? _f : {},
                (_g = this.constructor._defaultProps[this.name]) !== null && _g !== void 0 ? _g : {},
            );
            let passedProps = {};
            if (props.constructor.name === 'NamedNodeMap') {
                Object.keys(props).forEach((key) => {
                    var _a2, _b2, _c2;
                    let value;
                    if (((_a2 = props[key]) === null || _a2 === void 0 ? void 0 : _a2.nodeValue) !== void 0) {
                        if (props[key].nodeValue === '') value = true;
                        else value = props[key].nodeValue;
                    }
                    if (!value) return;
                    passedProps[
                        camelCase(
                            (_c2 = (_b2 = props[key]) === null || _b2 === void 0 ? void 0 : _b2.name) !== null &&
                                _c2 !== void 0
                                ? _c2
                                : key,
                        )
                    ] = value;
                });
            } else {
                passedProps = props;
            }
            this.props = deepMerge(
                defaultProps,
                InterfaceToApply.apply(passedProps, {
                    descriptor: {
                        defaults: false,
                    },
                }),
            );
            Object.keys(this.props).forEach((prop) => {
                this.node[prop] = this.props[prop];
            });
            const nodeFirstUpdated =
                (_h = this.node.firstUpdated) === null || _h === void 0 ? void 0 : _h.bind(this.node);
            this.node.firstUpdated = () =>
                __awaiter$d(this, void 0, void 0, function* () {
                    if (nodeFirstUpdated) {
                        yield nodeFirstUpdated();
                    }
                    this.node.mounted = true;
                });
            const nodeShouldUpdate =
                (_j = this.node.shouldUpdate) === null || _j === void 0 ? void 0 : _j.bind(this.node);
            this.node.shouldUpdate = () => {
                if (nodeShouldUpdate) {
                    const res = nodeShouldUpdate();
                    if (!res) return false;
                }
                return this.shouldUpdate;
            };
            const styleStr = this.node.constructor.styles;
            this.injectStyle(
                (_k = styleStr === null || styleStr === void 0 ? void 0 : styleStr.cssText) !== null && _k !== void 0
                    ? _k
                    : '',
            );
            switch (this.props.mountWhen) {
                case 'inViewport':
                    (() =>
                        __awaiter$d(this, void 0, void 0, function* () {
                            yield whenInViewport(this.node);
                            this.mount();
                        }))();
                    break;
                case 'direct':
                case 'directly':
                default:
                    this.mount();
                    break;
            }
        }
        static setDefaultProps(selector, props) {
            Array.from(selector).forEach((sel) => {
                var _a;
                this._defaultProps[sel] = Object.assign(
                    Object.assign({}, (_a = this._defaultProps[sel]) !== null && _a !== void 0 ? _a : {}),
                    props,
                );
            });
        }
        get componentUtilsSettings() {
            return this._settings.componentUtils;
        }
        static getFinalInterface(int) {
            class InlineComponentUtilsInterface extends SInterface {}
            InlineComponentUtilsInterface.definition = SComponentUtilsDefaultInterface.definition;
            if (int) {
                InlineComponentUtilsInterface.definition = Object.assign(
                    Object.assign({}, SComponentUtilsDefaultInterface.definition),
                    int.definition,
                );
            }
            return InlineComponentUtilsInterface;
        }
        static properties(properties, int) {
            const propertiesObj = {};
            const InterfaceToApply = this.getFinalInterface(int);
            Object.keys(InterfaceToApply.definition).forEach((prop) => {
                var _a, _b, _c, _d, _e, _f;
                const definition = InterfaceToApply.definition[prop];
                propertiesObj[prop] = Object.assign({}, (_a = definition.lit) !== null && _a !== void 0 ? _a : {});
                if (
                    definition.physical ||
                    ((_c = (_b = definition.type) === null || _b === void 0 ? void 0 : _b.toLowerCase) === null ||
                    _c === void 0
                        ? void 0
                        : _c.call(_b)) === 'boolean' ||
                    ((_f =
                        (_e = (_d = definition.type) === null || _d === void 0 ? void 0 : _d.type) === null ||
                        _e === void 0
                            ? void 0
                            : _e.toLowerCase) === null || _f === void 0
                        ? void 0
                        : _f.call(_e)) === 'boolean'
                ) {
                    propertiesObj[prop].reflect = true;
                    propertiesObj[prop].attribute = dashCase(prop);
                    propertiesObj[prop].converter = {
                        toAttribute(value) {
                            if (value === false || value === null) return null;
                            return String(value);
                        },
                    };
                }
            });
            const props = Object.assign(
                Object.assign({}, propertiesObj),
                properties !== null && properties !== void 0 ? properties : {},
            );
            return props;
        }
        injectStyle(css, id = this.node.tagName) {
            if (this.constructor._injectedStyles.indexOf(id) !== -1) return;
            this.constructor._injectedStyles.push(id);
            injectStyle(css);
        }
        mount() {
            return __awaiter$d(this, void 0, void 0, function* () {
                if (this.props.adoptStyle) yield this._adoptStyle();
                this.shouldUpdate = true;
                this.node.requestUpdate();
            });
        }
        _adoptStyle() {
            return __awaiter$d(this, void 0, void 0, function* () {
                const $links = document.querySelectorAll('link[rel="stylesheet"]');
                if ($links && this.node.shadowRoot) {
                    Array.from($links).forEach(($link) =>
                        __awaiter$d(this, void 0, void 0, function* () {
                            var _a, _b;
                            if (
                                Array.isArray(this.props.adoptStyle) &&
                                this.props.adoptStyle.indexOf((_a = $link.id) !== null && _a !== void 0 ? _a : '') ===
                                    -1
                            ) {
                                return;
                            }
                            if ($link._stylesheet) {
                                this.node.shadowRoot.adoptedStyleSheets = [
                                    ...this.node.shadowRoot.adoptedStyleSheets,
                                    $link._stylesheet,
                                ];
                                return;
                            }
                            (_b = this.node.shadowRoot) === null || _b === void 0
                                ? void 0
                                : _b.appendChild($link.cloneNode());
                            if (this.constructor._styleNodes.indexOf($link) !== -1) return;
                            this.constructor._styleNodes.push($link);
                            const res = yield fetch($link.href, {
                                headers: {
                                    Accept: 'text/css,*/*;q=0.1',
                                },
                            });
                            let cssStr = yield res.text();
                            const stylesheet = new CSSStyleSheet();
                            stylesheet.replace(cssStr);
                            $link._stylesheet = stylesheet;
                        }),
                    );
                }
                const $styles = document.querySelectorAll('style');
                if ($styles && this.node.shadowRoot) {
                    Array.from($styles).forEach(($style) => {
                        var _a;
                        if (
                            Array.isArray(this.props.adoptStyle) &&
                            this.props.adoptStyle.indexOf((_a = $style.id) !== null && _a !== void 0 ? _a : '') === -1
                        ) {
                            return;
                        }
                        if ($style._stylesheet) {
                            this.node.shadowRoot.adoptedStyleSheets = [
                                ...this.node.shadowRoot.adoptedStyleSheets,
                                $style._stylesheet,
                            ];
                            return;
                        }
                        const stylesheet = new CSSStyleSheet();
                        stylesheet.replace($style.innerHTML);
                        $style._stylesheet = stylesheet;
                        this.node.shadowRoot.adoptedStyleSheets = [
                            ...this.node.shadowRoot.adoptedStyleSheets,
                            $style._stylesheet,
                        ];
                    });
                }
                return true;
            });
        }
        exposeApi(apiObj) {
            setTimeout(() => {
                var _a;
                let $on = this.node;
                if ((_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a._component) {
                    $on = this.node.parentNode;
                }
                Object.keys(apiObj).forEach((apiFnName) => {
                    const apiFn = apiObj[apiFnName];
                    $on[apiFnName] = apiFn;
                });
            });
        }
        className(cls = '', style = '') {
            let clsString = cls
                .split(' ')
                .map((clsName) => `${this.name}${clsName && !clsName.match(/^__/) ? '-' : ''}${clsName}`)
                .join(' ');
            if (style && this.props.defaultStyle) {
                clsString += ` ${style}`;
            }
            return clsString;
        }
        isMounted() {
            var _a;
            return (_a = this.node) === null || _a === void 0 ? void 0 : _a.hasAttribute('mounted');
        }
        decodeHtml(input) {
            const e = document.createElement('textarea');
            e.innerHTML = input;
            return e.childNodes.length === 0 ? '' : e.childNodes[0].nodeValue;
        }
        dispatchSyncEvent(name2, details) {
            return new Promise((resolve, reject) => {
                let hasListeners = false;
                this.node.dispatchEvent(
                    new CustomEvent(name2, {
                        detail: Object.assign(Object.assign({}, details), {
                            onPing() {
                                hasListeners = true;
                            },
                            onResolve(data) {
                                resolve(data);
                            },
                        }),
                    }),
                );
                setTimeout(() => {
                    if (!hasListeners) reject();
                });
            });
        }
        addSyncEventListener(name2, handler) {
            this.node.addEventListener(name2, (e) =>
                __awaiter$d(this, void 0, void 0, function* () {
                    var _a;
                    if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing)) return handler(e);
                    e.detail.onPing();
                    const res = yield handler(e);
                    e.detail.onResolve(res);
                }),
            );
        }
        addSyncEventListenerOn($targets, name2, handler) {
            $targets.forEach(($target) => {
                $target.addEventListener(name2, (e) =>
                    __awaiter$d(this, void 0, void 0, function* () {
                        var _a;
                        if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing)) return handler(e);
                        e.detail.onPing();
                        const res = yield handler(e);
                        e.detail.onResolve(res);
                    }),
                );
            });
        }
        addTargetsEventListener(name2, handler) {
            this.$targets.forEach(($target) => {
                $target.addEventListener(name2, (e) =>
                    __awaiter$d(this, void 0, void 0, function* () {
                        var _a;
                        if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.onPing)) return handler(e);
                        e.detail.onPing();
                        const res = yield handler(e);
                        e.detail.onResolve(res);
                    }),
                );
            });
        }
    }
    SComponentUtils._defaultProps = {};
    SComponentUtils._injectedStyles = [];
    SComponentUtils._styleNodes = [];
    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const supportsAdoptingStyleSheets$1 =
        window.ShadowRoot &&
        (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) &&
        'adoptedStyleSheets' in Document.prototype &&
        'replace' in CSSStyleSheet.prototype;
    const constructionToken$1 = Symbol();
    const styleSheetCache = new Map();
    class CSSResult$1 {
        constructor(cssText, safeToken) {
            this['_$cssResult$'] = true;
            if (safeToken !== constructionToken$1) {
                throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
            }
            this.cssText = cssText;
        }
        get styleSheet() {
            let styleSheet = styleSheetCache.get(this.cssText);
            if (supportsAdoptingStyleSheets$1 && styleSheet === void 0) {
                styleSheetCache.set(this.cssText, (styleSheet = new CSSStyleSheet()));
                styleSheet.replaceSync(this.cssText);
            }
            return styleSheet;
        }
        toString() {
            return this.cssText;
        }
    }
    const textFromCSSResult = (value) => {
        if (value['_$cssResult$'] === true) {
            return value.cssText;
        } else if (typeof value === 'number') {
            return value;
        } else {
            throw new Error(
                `Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`,
            );
        }
    };
    const unsafeCSS$1 = (value) =>
        new CSSResult$1(typeof value === 'string' ? value : String(value), constructionToken$1);
    const css$1 = (strings, ...values) => {
        const cssText =
            strings.length === 1
                ? strings[0]
                : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
        return new CSSResult$1(cssText, constructionToken$1);
    };
    const adoptStyles = (renderRoot, styles) => {
        if (supportsAdoptingStyleSheets$1) {
            renderRoot.adoptedStyleSheets = styles.map((s) => (s instanceof CSSStyleSheet ? s : s.styleSheet));
        } else {
            styles.forEach((s) => {
                const style = document.createElement('style');
                style.textContent = s.cssText;
                renderRoot.appendChild(style);
            });
        }
    };
    const cssResultFromStyleSheet = (sheet) => {
        let cssText = '';
        for (const rule of sheet.cssRules) {
            cssText += rule.cssText;
        }
        return unsafeCSS$1(cssText);
    };
    const getCompatibleStyle = supportsAdoptingStyleSheets$1
        ? (s) => s
        : (s) => (s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s);
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _a$6, _b$5, _c$5, _d$4;
    var _e$4;
    var _f$4;
    let requestUpdateThenable;
    {
        console.warn(`Running in dev mode. Do not use in production!`);
        if (
            ((_a$6 = window.ShadyDOM) === null || _a$6 === void 0 ? void 0 : _a$6.inUse) &&
            globalThis['reactiveElementPlatformSupport'] === void 0
        ) {
            console.warn(
                `Shadow DOM is being polyfilled via ShadyDOM but the \`polyfill-support\` module has not been loaded.`,
            );
        }
        requestUpdateThenable = {
            then: (onfulfilled, _onrejected) => {
                console.warn(`\`requestUpdate\` no longer returns a Promise.Use \`updateComplete\` instead.`);
                if (onfulfilled !== void 0) {
                    onfulfilled(false);
                }
            },
        };
    }
    const JSCompiler_renameProperty$1 = (prop, _obj) => prop;
    const defaultConverter$1 = {
        toAttribute(value, type) {
            switch (type) {
                case Boolean:
                    value = value ? '' : null;
                    break;
                case Object:
                case Array:
                    value = value == null ? value : JSON.stringify(value);
                    break;
            }
            return value;
        },
        fromAttribute(value, type) {
            let fromValue = value;
            switch (type) {
                case Boolean:
                    fromValue = value !== null;
                    break;
                case Number:
                    fromValue = value === null ? null : Number(value);
                    break;
                case Object:
                case Array:
                    try {
                        fromValue = JSON.parse(value);
                    } catch (e) {
                        fromValue = null;
                    }
                    break;
            }
            return fromValue;
        },
    };
    const notEqual$1 = (value, old) => {
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration$1 = {
        attribute: true,
        type: String,
        converter: defaultConverter$1,
        reflect: false,
        hasChanged: notEqual$1,
    };
    const finalized$1 = 'finalized';
    class ReactiveElement extends HTMLElement {
        constructor() {
            super();
            this.__instanceProperties = new Map();
            this.isUpdatePending = false;
            this.hasUpdated = false;
            this.__reflectingProperty = null;
            this._initialize();
        }
        static addInitializer(initializer) {
            var _a;
            (_a = this._initializers) !== null && _a !== void 0 ? _a : (this._initializers = []);
            this._initializers.push(initializer);
        }
        static get observedAttributes() {
            this.finalize();
            const attributes = [];
            this.elementProperties.forEach((v, p) => {
                const attr = this.__attributeNameForProperty(p, v);
                if (attr !== void 0) {
                    this.__attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            });
            return attributes;
        }
        static createProperty(name2, options = defaultPropertyDeclaration$1) {
            if (options.state) {
                options.attribute = false;
            }
            this.finalize();
            this.elementProperties.set(name2, options);
            if (!options.noAccessor && !this.prototype.hasOwnProperty(name2)) {
                const key = typeof name2 === 'symbol' ? Symbol() : `__${name2}`;
                const descriptor = this.getPropertyDescriptor(name2, key, options);
                if (descriptor !== void 0) {
                    Object.defineProperty(this.prototype, name2, descriptor);
                }
            }
        }
        static getPropertyDescriptor(name2, key, options) {
            return {
                get() {
                    return this[key];
                },
                set(value) {
                    const oldValue = this[name2];
                    this[key] = value;
                    this.requestUpdate(name2, oldValue, options);
                },
                configurable: true,
                enumerable: true,
            };
        }
        static getPropertyOptions(name2) {
            return this.elementProperties.get(name2) || defaultPropertyDeclaration$1;
        }
        static finalize() {
            if (this.hasOwnProperty(finalized$1)) {
                return false;
            }
            this[finalized$1] = true;
            const superCtor = Object.getPrototypeOf(this);
            superCtor.finalize();
            this.elementProperties = new Map(superCtor.elementProperties);
            this.__attributeToPropertyMap = new Map();
            if (this.hasOwnProperty(JSCompiler_renameProperty$1('properties'))) {
                const props = this.properties;
                const propKeys = [...Object.getOwnPropertyNames(props), ...Object.getOwnPropertySymbols(props)];
                for (const p of propKeys) {
                    this.createProperty(p, props[p]);
                }
            }
            this.elementStyles = this.finalizeStyles(this.styles);
            {
                const warnRemoved = (obj, name2) => {
                    if (obj[name2] !== void 0) {
                        console.warn(
                            `\`${name2}\` is implemented. It has been removed from this version of ReactiveElement. See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`,
                        );
                    }
                };
                [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach((name2) =>
                    warnRemoved(this.prototype, name2),
                );
            }
            return true;
        }
        static finalizeStyles(styles) {
            const elementStyles = [];
            if (Array.isArray(styles)) {
                const set = new Set(styles.flat(Infinity).reverse());
                for (const s of set) {
                    elementStyles.unshift(getCompatibleStyle(s));
                }
            } else if (styles !== void 0) {
                elementStyles.push(getCompatibleStyle(styles));
            }
            return elementStyles;
        }
        static __attributeNameForProperty(name2, options) {
            const attribute = options.attribute;
            return attribute === false
                ? void 0
                : typeof attribute === 'string'
                ? attribute
                : typeof name2 === 'string'
                ? name2.toLowerCase()
                : void 0;
        }
        _initialize() {
            var _a;
            this.__updatePromise = new Promise((res) => (this.enableUpdating = res));
            this._$changedProperties = new Map();
            this.__saveInstanceProperties();
            this.requestUpdate();
            (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));
        }
        addController(controller) {
            var _a, _b;
            ((_a = this.__controllers) !== null && _a !== void 0 ? _a : (this.__controllers = [])).push(controller);
            if (this.renderRoot !== void 0 && this.isConnected) {
                (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);
            }
        }
        removeController(controller) {
            var _a;
            (_a = this.__controllers) === null || _a === void 0
                ? void 0
                : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
        }
        __saveInstanceProperties() {
            this.constructor.elementProperties.forEach((_v, p) => {
                if (this.hasOwnProperty(p)) {
                    this.__instanceProperties.set(p, this[p]);
                    delete this[p];
                }
            });
        }
        createRenderRoot() {
            var _a;
            const renderRoot =
                (_a = this.shadowRoot) !== null && _a !== void 0
                    ? _a
                    : this.attachShadow(this.constructor.shadowRootOptions);
            adoptStyles(renderRoot, this.constructor.elementStyles);
            return renderRoot;
        }
        connectedCallback() {
            var _a;
            if (this.renderRoot === void 0) {
                this.renderRoot = this.createRenderRoot();
            }
            this.enableUpdating(true);
            (_a = this.__controllers) === null || _a === void 0
                ? void 0
                : _a.forEach((c) => {
                      var _a2;
                      return (_a2 = c.hostConnected) === null || _a2 === void 0 ? void 0 : _a2.call(c);
                  });
        }
        enableUpdating(_requestedUpdate) {}
        disconnectedCallback() {
            var _a;
            (_a = this.__controllers) === null || _a === void 0
                ? void 0
                : _a.forEach((c) => {
                      var _a2;
                      return (_a2 = c.hostDisconnected) === null || _a2 === void 0 ? void 0 : _a2.call(c);
                  });
        }
        attributeChangedCallback(name2, _old, value) {
            this._$attributeToProperty(name2, value);
        }
        __propertyToAttribute(name2, value, options = defaultPropertyDeclaration$1) {
            var _a, _b;
            const attr = this.constructor.__attributeNameForProperty(name2, options);
            if (attr !== void 0 && options.reflect === true) {
                const toAttribute =
                    (_b = (_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== null &&
                    _b !== void 0
                        ? _b
                        : defaultConverter$1.toAttribute;
                const attrValue = toAttribute(value, options.type);
                if (this.constructor.enabledWarnings.indexOf('migration') >= 0 && attrValue === void 0) {
                    console.warn(
                        `The attribute value for the ${name2} property is undefined. The attribute will be removed, but in the previous version of ReactiveElement, the attribute would not have changed.`,
                    );
                }
                this.__reflectingProperty = name2;
                if (attrValue == null) {
                    this.removeAttribute(attr);
                } else {
                    this.setAttribute(attr, attrValue);
                }
                this.__reflectingProperty = null;
            }
        }
        _$attributeToProperty(name2, value) {
            var _a, _b, _c;
            const ctor = this.constructor;
            const propName = ctor.__attributeToPropertyMap.get(name2);
            if (propName !== void 0 && this.__reflectingProperty !== propName) {
                const options = ctor.getPropertyOptions(propName);
                const converter = options.converter;
                const fromAttribute =
                    (_c =
                        (_b = (_a = converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== null &&
                        _b !== void 0
                            ? _b
                            : typeof converter === 'function'
                            ? converter
                            : null) !== null && _c !== void 0
                        ? _c
                        : defaultConverter$1.fromAttribute;
                this.__reflectingProperty = propName;
                this[propName] = fromAttribute(value, options.type);
                this.__reflectingProperty = null;
            }
        }
        requestUpdate(name2, oldValue, options) {
            let shouldRequestUpdate = true;
            if (name2 !== void 0) {
                options = options || this.constructor.getPropertyOptions(name2);
                const hasChanged = options.hasChanged || notEqual$1;
                if (hasChanged(this[name2], oldValue)) {
                    if (!this._$changedProperties.has(name2)) {
                        this._$changedProperties.set(name2, oldValue);
                    }
                    if (options.reflect === true && this.__reflectingProperty !== name2) {
                        if (this.__reflectingProperties === void 0) {
                            this.__reflectingProperties = new Map();
                        }
                        this.__reflectingProperties.set(name2, options);
                    }
                } else {
                    shouldRequestUpdate = false;
                }
            }
            if (!this.isUpdatePending && shouldRequestUpdate) {
                this.__updatePromise = this.__enqueueUpdate();
            }
            return requestUpdateThenable;
        }
        __enqueueUpdate() {
            return __async(this, null, function* () {
                this.isUpdatePending = true;
                try {
                    yield this.__updatePromise;
                } catch (e) {
                    Promise.reject(e);
                }
                const result = this.performUpdate();
                if (result != null) {
                    yield result;
                }
                return !this.isUpdatePending;
            });
        }
        performUpdate() {
            var _a;
            if (!this.isUpdatePending) {
                return;
            }
            if (!this.hasUpdated) {
                {
                    const shadowedProperties = [];
                    this.constructor.elementProperties.forEach((_v, p) => {
                        var _a2;
                        if (
                            this.hasOwnProperty(p) &&
                            !((_a2 = this.__instanceProperties) === null || _a2 === void 0 ? void 0 : _a2.has(p))
                        ) {
                            shadowedProperties.push(p);
                        }
                    });
                    if (shadowedProperties.length) {
                        console.warn(
                            `The following properties will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(
                                ', ',
                            )}. Native class fields and some compiled output will overwrite accessors used for detecting changes. To fix this issue, either initialize properties in the constructor or adjust your compiler settings; for example, for TypeScript set \`useDefineForClassFields: false\` in your \`tsconfig.json\`.`,
                        );
                    }
                }
            }
            if (this.__instanceProperties) {
                this.__instanceProperties.forEach((v, p) => (this[p] = v));
                this.__instanceProperties = void 0;
            }
            let shouldUpdate = false;
            const changedProperties = this._$changedProperties;
            try {
                shouldUpdate = this.shouldUpdate(changedProperties);
                if (shouldUpdate) {
                    this.willUpdate(changedProperties);
                    (_a = this.__controllers) === null || _a === void 0
                        ? void 0
                        : _a.forEach((c) => {
                              var _a2;
                              return (_a2 = c.hostUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(c);
                          });
                    this.update(changedProperties);
                } else {
                    this.__markUpdated();
                }
            } catch (e) {
                shouldUpdate = false;
                this.__markUpdated();
                throw e;
            }
            if (shouldUpdate) {
                this._$didUpdate(changedProperties);
            }
        }
        willUpdate(_changedProperties) {}
        _$didUpdate(changedProperties) {
            var _a;
            (_a = this.__controllers) === null || _a === void 0
                ? void 0
                : _a.forEach((c) => {
                      var _a2;
                      return (_a2 = c.hostUpdated) === null || _a2 === void 0 ? void 0 : _a2.call(c);
                  });
            if (!this.hasUpdated) {
                this.hasUpdated = true;
                this.firstUpdated(changedProperties);
            }
            this.updated(changedProperties);
            if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf('change-in-update') >= 0) {
                console.warn(
                    `An update was requested (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`,
                );
            }
        }
        __markUpdated() {
            this._$changedProperties = new Map();
            this.isUpdatePending = false;
        }
        get updateComplete() {
            return this.getUpdateComplete();
        }
        getUpdateComplete() {
            return this.__updatePromise;
        }
        shouldUpdate(_changedProperties) {
            return true;
        }
        update(_changedProperties) {
            if (this.__reflectingProperties !== void 0) {
                this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
                this.__reflectingProperties = void 0;
            }
            this.__markUpdated();
        }
        updated(_changedProperties) {}
        firstUpdated(_changedProperties) {}
    }
    _f$4 = finalized$1;
    ReactiveElement[_f$4] = true;
    ReactiveElement.elementProperties = new Map();
    ReactiveElement.elementStyles = [];
    ReactiveElement.shadowRootOptions = { mode: 'open' };
    (_c$5 = (_b$5 = globalThis)['reactiveElementPlatformSupport']) === null || _c$5 === void 0
        ? void 0
        : _c$5.call(_b$5, { ReactiveElement });
    {
        ReactiveElement.enabledWarnings = ['change-in-update'];
        const ensureOwnWarnings = function (ctor) {
            if (!ctor.hasOwnProperty(JSCompiler_renameProperty$1('enabledWarnings'))) {
                ctor.enabledWarnings = ctor.enabledWarnings.slice();
            }
        };
        ReactiveElement.enableWarning = function (warning) {
            ensureOwnWarnings(this);
            if (this.enabledWarnings.indexOf(warning) < 0) {
                this.enabledWarnings.push(warning);
            }
        };
        ReactiveElement.disableWarning = function (warning) {
            ensureOwnWarnings(this);
            const i = this.enabledWarnings.indexOf(warning);
            if (i >= 0) {
                this.enabledWarnings.splice(i, 1);
            }
        };
    }
    ((_d$4 = (_e$4 = globalThis)['reactiveElementVersions']) !== null && _d$4 !== void 0
        ? _d$4
        : (_e$4['reactiveElementVersions'] = [])
    ).push('1.0.0-rc.3');
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _a$5, _b$4, _c$4, _d$3, _e$3;
    var _f$3;
    {
        console.warn('lit-html is in dev mode. Not recommended for production!');
    }
    const wrap$2 =
        ((_a$5 = window.ShadyDOM) === null || _a$5 === void 0 ? void 0 : _a$5.inUse) &&
        ((_b$4 = window.ShadyDOM) === null || _b$4 === void 0 ? void 0 : _b$4.noPatch) === true
            ? window.ShadyDOM.wrap
            : (node) => node;
    const trustedTypes$3 = globalThis.trustedTypes;
    const policy$3 = trustedTypes$3
        ? trustedTypes$3.createPolicy('lit-html', {
              createHTML: (s) => s,
          })
        : void 0;
    const identityFunction$2 = (value) => value;
    const noopSanitizer$2 = (_node, _name, _type) => identityFunction$2;
    const setSanitizer = (newSanitizer) => {
        if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
            throw new Error(
                `Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`,
            );
        }
        sanitizerFactoryInternal$2 = newSanitizer;
    };
    const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
        sanitizerFactoryInternal$2 = noopSanitizer$2;
    };
    const createSanitizer$2 = (node, name2, type) => {
        return sanitizerFactoryInternal$2(node, name2, type);
    };
    const boundAttributeSuffix$3 = '$lit$';
    const marker$3 = `lit$${String(Math.random()).slice(9)}$`;
    const markerMatch$2 = '?' + marker$3;
    const nodeMarker$3 = `<${markerMatch$2}>`;
    const d$2 = document;
    const createMarker$3 = (v = '') => d$2.createComment(v);
    const isPrimitive$3 = (value) => value === null || (typeof value != 'object' && typeof value != 'function');
    const isArray$5 = Array.isArray;
    const isIterable$3 = (value) => {
        var _a;
        return (
            isArray$5(value) ||
            typeof ((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]) === 'function'
        );
    };
    const SPACE_CHAR$2 = `[ 	
\f\r]`;
    const ATTR_VALUE_CHAR$2 = `[^ 	
\f\r"'\`<>=]`;
    const NAME_CHAR$2 = `[^\\s"'>=/]`;
    const textEndRegex$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    const COMMENT_START$2 = 1;
    const TAG_NAME$2 = 2;
    const DYNAMIC_TAG_NAME$2 = 3;
    const commentEndRegex$2 = /-->/g;
    const comment2EndRegex$2 = />/g;
    const tagEndRegex$2 = new RegExp(
        `>|${SPACE_CHAR$2}(?:(${NAME_CHAR$2}+)(${SPACE_CHAR$2}*=${SPACE_CHAR$2}*(?:${ATTR_VALUE_CHAR$2}|("|')|))|$)`,
        'g',
    );
    const ENTIRE_MATCH$2 = 0;
    const ATTRIBUTE_NAME$2 = 1;
    const SPACES_AND_EQUALS$2 = 2;
    const QUOTE_CHAR$2 = 3;
    const singleQuoteAttrEndRegex$2 = /'/g;
    const doubleQuoteAttrEndRegex$2 = /"/g;
    const rawTextElement$2 = /^(?:script|style|textarea)$/i;
    const HTML_RESULT$2 = 1;
    const SVG_RESULT$2 = 2;
    const ATTRIBUTE_PART$2 = 1;
    const CHILD_PART$2 = 2;
    const PROPERTY_PART$2 = 3;
    const BOOLEAN_ATTRIBUTE_PART$2 = 4;
    const EVENT_PART$2 = 5;
    const ELEMENT_PART$2 = 6;
    const COMMENT_PART$2 = 7;
    const tag$2 =
        (type) =>
        (strings, ...values) => {
            if (strings.some((s) => s === void 0)) {
                console.warn(
                    'Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.',
                );
            }
            return {
                ['_$litType$']: type,
                strings,
                values,
            };
        };
    const html$4 = tag$2(HTML_RESULT$2);
    const noChange$3 = Symbol.for('lit-noChange');
    const nothing$3 = Symbol.for('lit-nothing');
    const templateCache$2 = new WeakMap();
    const render$2 = (value, container, options) => {
        var _a, _b, _c;
        const partOwnerNode =
            (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0
                ? _a
                : container;
        let part = partOwnerNode['_$litPart$'];
        if (part === void 0) {
            const endNode =
                (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0
                    ? _b
                    : null;
            if (((_c = options) === null || _c === void 0 ? void 0 : _c.clearContainerForLit2MigrationOnly) === true) {
                let n = container.firstChild;
                while (n && n !== endNode) {
                    const next = n.nextSibling;
                    n.remove();
                    n = next;
                }
            }
            partOwnerNode['_$litPart$'] = part = new ChildPart$2(
                container.insertBefore(createMarker$3(), endNode),
                endNode,
                void 0,
                options !== null && options !== void 0 ? options : {},
            );
        }
        part._$setValue(value);
        return part;
    };
    {
        render$2.setSanitizer = setSanitizer;
        render$2.createSanitizer = createSanitizer$2;
        {
            render$2._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
        }
    }
    const walker$2 = d$2.createTreeWalker(d$2, 129, null, false);
    let sanitizerFactoryInternal$2 = noopSanitizer$2;
    const getTemplateHtml$2 = (strings, type) => {
        const l = strings.length - 1;
        const attrNames = [];
        let html = type === SVG_RESULT$2 ? '<svg>' : '';
        let rawTextEndRegex;
        let regex = textEndRegex$2;
        for (let i = 0; i < l; i++) {
            const s = strings[i];
            let attrNameEndIndex = -1;
            let attrName;
            let lastIndex = 0;
            let match;
            while (lastIndex < s.length) {
                regex.lastIndex = lastIndex;
                match = regex.exec(s);
                if (match === null) {
                    break;
                }
                lastIndex = regex.lastIndex;
                if (regex === textEndRegex$2) {
                    if (match[COMMENT_START$2] === '!--') {
                        regex = commentEndRegex$2;
                    } else if (match[COMMENT_START$2] !== void 0) {
                        regex = comment2EndRegex$2;
                    } else if (match[TAG_NAME$2] !== void 0) {
                        if (rawTextElement$2.test(match[TAG_NAME$2])) {
                            rawTextEndRegex = new RegExp(`</${match[TAG_NAME$2]}`, 'g');
                        }
                        regex = tagEndRegex$2;
                    } else if (match[DYNAMIC_TAG_NAME$2] !== void 0) {
                        regex = tagEndRegex$2;
                    }
                } else if (regex === tagEndRegex$2) {
                    if (match[ENTIRE_MATCH$2] === '>') {
                        regex =
                            rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$2;
                        attrNameEndIndex = -1;
                    } else if (match[ATTRIBUTE_NAME$2] === void 0) {
                        attrNameEndIndex = -2;
                    } else {
                        attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS$2].length;
                        attrName = match[ATTRIBUTE_NAME$2];
                        regex =
                            match[QUOTE_CHAR$2] === void 0
                                ? tagEndRegex$2
                                : match[QUOTE_CHAR$2] === '"'
                                ? doubleQuoteAttrEndRegex$2
                                : singleQuoteAttrEndRegex$2;
                    }
                } else if (regex === doubleQuoteAttrEndRegex$2 || regex === singleQuoteAttrEndRegex$2) {
                    regex = tagEndRegex$2;
                } else if (regex === commentEndRegex$2 || regex === comment2EndRegex$2) {
                    regex = textEndRegex$2;
                } else {
                    regex = tagEndRegex$2;
                    rawTextEndRegex = void 0;
                }
            }
            {
                console.assert(
                    attrNameEndIndex === -1 ||
                        regex === tagEndRegex$2 ||
                        regex === singleQuoteAttrEndRegex$2 ||
                        regex === doubleQuoteAttrEndRegex$2,
                    'unexpected parse state B',
                );
            }
            const end = regex === tagEndRegex$2 && strings[i + 1].startsWith('/>') ? ' ' : '';
            html +=
                regex === textEndRegex$2
                    ? s + nodeMarker$3
                    : attrNameEndIndex >= 0
                    ? (attrNames.push(attrName),
                      s.slice(0, attrNameEndIndex) + boundAttributeSuffix$3 + s.slice(attrNameEndIndex)) +
                      marker$3 +
                      end
                    : s + marker$3 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
        }
        const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT$2 ? '</svg>' : '');
        return [policy$3 !== void 0 ? policy$3.createHTML(htmlResult) : htmlResult, attrNames];
    };
    class Template$3 {
        constructor({ strings, ['_$litType$']: type }, options) {
            this.parts = [];
            let node;
            let nodeIndex = 0;
            let attrNameIndex = 0;
            const partCount = strings.length - 1;
            const parts = this.parts;
            const [html, attrNames] = getTemplateHtml$2(strings, type);
            this.el = Template$3.createElement(html, options);
            walker$2.currentNode = this.el.content;
            if (type === SVG_RESULT$2) {
                const content = this.el.content;
                const svgElement = content.firstChild;
                svgElement.remove();
                content.append(...svgElement.childNodes);
            }
            while ((node = walker$2.nextNode()) !== null && parts.length < partCount) {
                if (node.nodeType === 1) {
                    if (node.hasAttributes()) {
                        const attrsToRemove = [];
                        for (const name2 of node.getAttributeNames()) {
                            if (name2.endsWith(boundAttributeSuffix$3) || name2.startsWith(marker$3)) {
                                const realName = attrNames[attrNameIndex++];
                                attrsToRemove.push(name2);
                                if (realName !== void 0) {
                                    const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$3);
                                    const statics = value.split(marker$3);
                                    const m = /([.?@])?(.*)/.exec(realName);
                                    parts.push({
                                        type: ATTRIBUTE_PART$2,
                                        index: nodeIndex,
                                        name: m[2],
                                        strings: statics,
                                        ctor:
                                            m[1] === '.'
                                                ? PropertyPart$3
                                                : m[1] === '?'
                                                ? BooleanAttributePart$3
                                                : m[1] === '@'
                                                ? EventPart$3
                                                : AttributePart$3,
                                    });
                                } else {
                                    parts.push({
                                        type: ELEMENT_PART$2,
                                        index: nodeIndex,
                                    });
                                }
                            }
                        }
                        for (const name2 of attrsToRemove) {
                            node.removeAttribute(name2);
                        }
                    }
                    if (rawTextElement$2.test(node.tagName)) {
                        const strings2 = node.textContent.split(marker$3);
                        const lastIndex = strings2.length - 1;
                        if (lastIndex > 0) {
                            node.textContent = trustedTypes$3 ? trustedTypes$3.emptyScript : '';
                            for (let i = 0; i < lastIndex; i++) {
                                node.append(strings2[i], createMarker$3());
                                walker$2.nextNode();
                                parts.push({ type: CHILD_PART$2, index: ++nodeIndex });
                            }
                            node.append(strings2[lastIndex], createMarker$3());
                        }
                    }
                } else if (node.nodeType === 8) {
                    const data = node.data;
                    if (data === markerMatch$2) {
                        parts.push({ type: CHILD_PART$2, index: nodeIndex });
                    } else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker$3, i + 1)) !== -1) {
                            parts.push({ type: COMMENT_PART$2, index: nodeIndex });
                            i += marker$3.length - 1;
                        }
                    }
                }
                nodeIndex++;
            }
        }
        static createElement(html, _options) {
            const el = d$2.createElement('template');
            el.innerHTML = html;
            return el;
        }
    }
    function resolveDirective$2(part, value, parent = part, attributeIndex) {
        var _a, _b, _c;
        var _d;
        if (value === noChange$3) {
            return value;
        }
        let currentDirective =
            attributeIndex !== void 0
                ? (_a = parent.__directives) === null || _a === void 0
                    ? void 0
                    : _a[attributeIndex]
                : parent.__directive;
        const nextDirectiveConstructor = isPrimitive$3(value) ? void 0 : value['_$litDirective$'];
        if (
            (currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !==
            nextDirectiveConstructor
        ) {
            (_b =
                currentDirective === null || currentDirective === void 0
                    ? void 0
                    : currentDirective['_$notifyDirectiveConnectionChanged']) === null || _b === void 0
                ? void 0
                : _b.call(currentDirective, false);
            if (nextDirectiveConstructor === void 0) {
                currentDirective = void 0;
            } else {
                currentDirective = new nextDirectiveConstructor(part);
                currentDirective._$initialize(part, parent, attributeIndex);
            }
            if (attributeIndex !== void 0) {
                ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[
                    attributeIndex
                ] = currentDirective;
            } else {
                parent.__directive = currentDirective;
            }
        }
        if (currentDirective !== void 0) {
            value = resolveDirective$2(
                part,
                currentDirective._$resolve(part, value.values),
                currentDirective,
                attributeIndex,
            );
        }
        return value;
    }
    class TemplateInstance$3 {
        constructor(template, parent) {
            this._parts = [];
            this._$disconnectableChildren = void 0;
            this._$template = template;
            this._$parent = parent;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _clone(options) {
            var _a;
            const {
                el: { content },
                parts,
            } = this._$template;
            const fragment = (
                (_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0
                    ? _a
                    : d$2
            ).importNode(content, true);
            walker$2.currentNode = fragment;
            let node = walker$2.nextNode();
            let nodeIndex = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            while (templatePart !== void 0) {
                if (nodeIndex === templatePart.index) {
                    let part;
                    if (templatePart.type === CHILD_PART$2) {
                        part = new ChildPart$2(node, node.nextSibling, this, options);
                    } else if (templatePart.type === ATTRIBUTE_PART$2) {
                        part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
                    } else if (templatePart.type === ELEMENT_PART$2) {
                        part = new ElementPart$2(node, this, options);
                    }
                    this._parts.push(part);
                    templatePart = parts[++partIndex];
                }
                if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
                    node = walker$2.nextNode();
                    nodeIndex++;
                }
            }
            return fragment;
        }
        _update(values) {
            let i = 0;
            for (const part of this._parts) {
                if (part !== void 0) {
                    if (part.strings !== void 0) {
                        part._$setValue(values, part, i);
                        i += part.strings.length - 2;
                    } else {
                        part._$setValue(values[i]);
                    }
                }
                i++;
            }
        }
    }
    class ChildPart$2 {
        constructor(startNode, endNode, parent, options) {
            this.type = CHILD_PART$2;
            this.__isConnected = true;
            this._$disconnectableChildren = void 0;
            this._$startNode = startNode;
            this._$endNode = endNode;
            this._$parent = parent;
            this.options = options;
            {
                this._textSanitizer = void 0;
            }
        }
        get _$isConnected() {
            var _a, _b;
            return (_b = (_a = this._$parent) === null || _a === void 0 ? void 0 : _a._$isConnected) !== null &&
                _b !== void 0
                ? _b
                : this.__isConnected;
        }
        get parentNode() {
            return wrap$2(this._$startNode).parentNode;
        }
        get startNode() {
            return this._$startNode;
        }
        get endNode() {
            return this._$endNode;
        }
        _$setValue(value, directiveParent = this) {
            value = resolveDirective$2(this, value, directiveParent);
            if (isPrimitive$3(value)) {
                if (value === nothing$3 || value == null || value === '') {
                    if (this._$committedValue !== nothing$3) {
                        this._$clear();
                    }
                    this._$committedValue = nothing$3;
                } else if (value !== this._$committedValue && value !== noChange$3) {
                    this._commitText(value);
                }
            } else if (value['_$litType$'] !== void 0) {
                this._commitTemplateResult(value);
            } else if (value.nodeType !== void 0) {
                this._commitNode(value);
            } else if (isIterable$3(value)) {
                this._commitIterable(value);
            } else {
                this._commitText(value);
            }
        }
        _insert(node, ref = this._$endNode) {
            return wrap$2(wrap$2(this._$startNode).parentNode).insertBefore(node, ref);
        }
        _commitNode(value) {
            var _a;
            if (this._$committedValue !== value) {
                this._$clear();
                if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
                    const parentNodeName =
                        (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;
                    if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {
                        this._insert(new Text('/* lit-html will not write TemplateResults to scripts and styles */'));
                        return;
                    }
                }
                this._$committedValue = this._insert(value);
            }
        }
        _commitText(value) {
            const node = wrap$2(this._$startNode).nextSibling;
            if (
                node !== null &&
                node.nodeType === 3 &&
                (this._$endNode === null
                    ? wrap$2(node).nextSibling === null
                    : node === wrap$2(this._$endNode).previousSibling)
            ) {
                {
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer$2(node, 'data', 'property');
                    }
                    value = this._textSanitizer(value);
                }
                node.data = value;
            } else {
                {
                    const textNode = document.createTextNode('');
                    this._commitNode(textNode);
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer$2(textNode, 'data', 'property');
                    }
                    value = this._textSanitizer(value);
                    textNode.data = value;
                }
            }
            this._$committedValue = value;
        }
        _commitTemplateResult(result) {
            var _a;
            const { values, ['_$litType$']: type } = result;
            const template =
                typeof type === 'number'
                    ? this._$getTemplate(result)
                    : (type.el === void 0 && (type.el = Template$3.createElement(type.h, this.options)), type);
            if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {
                this._$committedValue._update(values);
            } else {
                const instance = new TemplateInstance$3(template, this);
                const fragment = instance._clone(this.options);
                instance._update(values);
                this._commitNode(fragment);
                this._$committedValue = instance;
            }
        }
        _$getTemplate(result) {
            let template = templateCache$2.get(result.strings);
            if (template === void 0) {
                templateCache$2.set(result.strings, (template = new Template$3(result)));
            }
            return template;
        }
        _commitIterable(value) {
            if (!isArray$5(this._$committedValue)) {
                this._$committedValue = [];
                this._$clear();
            }
            const itemParts = this._$committedValue;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                if (partIndex === itemParts.length) {
                    itemParts.push(
                        (itemPart = new ChildPart$2(
                            this._insert(createMarker$3()),
                            this._insert(createMarker$3()),
                            this,
                            this.options,
                        )),
                    );
                } else {
                    itemPart = itemParts[partIndex];
                }
                itemPart._$setValue(item);
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                this._$clear(itemPart && wrap$2(itemPart._$endNode).nextSibling, partIndex);
                itemParts.length = partIndex;
            }
        }
        _$clear(start = wrap$2(this._$startNode).nextSibling, from) {
            var _a;
            (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);
            while (start && start !== this._$endNode) {
                const n = wrap$2(start).nextSibling;
                wrap$2(start).remove();
                start = n;
            }
        }
        setConnected(isConnected) {
            var _a;
            if (this._$parent === void 0) {
                this.__isConnected = isConnected;
                (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);
            } else {
                throw new Error('part.setConnected() may only be called on a RootPart returned from render().');
            }
        }
    }
    class AttributePart$3 {
        constructor(element, name2, strings, parent, options) {
            this.type = ATTRIBUTE_PART$2;
            this._$committedValue = nothing$3;
            this._$disconnectableChildren = void 0;
            this.element = element;
            this.name = name2;
            this._$parent = parent;
            this.options = options;
            if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
                this._$committedValue = new Array(strings.length - 1).fill(nothing$3);
                this.strings = strings;
            } else {
                this._$committedValue = nothing$3;
            }
            {
                this._sanitizer = void 0;
            }
        }
        get tagName() {
            return this.element.tagName;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value, directiveParent = this, valueIndex, noCommit) {
            const strings = this.strings;
            let change = false;
            if (strings === void 0) {
                value = resolveDirective$2(this, value, directiveParent, 0);
                change = !isPrimitive$3(value) || (value !== this._$committedValue && value !== noChange$3);
                if (change) {
                    this._$committedValue = value;
                }
            } else {
                const values = value;
                value = strings[0];
                let i, v;
                for (i = 0; i < strings.length - 1; i++) {
                    v = resolveDirective$2(this, values[valueIndex + i], directiveParent, i);
                    if (v === noChange$3) {
                        v = this._$committedValue[i];
                    }
                    change || (change = !isPrimitive$3(v) || v !== this._$committedValue[i]);
                    if (v === nothing$3) {
                        value = nothing$3;
                    } else if (value !== nothing$3) {
                        value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
                    }
                    this._$committedValue[i] = v;
                }
            }
            if (change && !noCommit) {
                this._commitValue(value);
            }
        }
        _commitValue(value) {
            if (value === nothing$3) {
                wrap$2(this.element).removeAttribute(this.name);
            } else {
                {
                    if (this._sanitizer === void 0) {
                        this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, 'attribute');
                    }
                    value = this._sanitizer(value !== null && value !== void 0 ? value : '');
                }
                wrap$2(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : '');
            }
        }
    }
    class PropertyPart$3 extends AttributePart$3 {
        constructor() {
            super(...arguments);
            this.type = PROPERTY_PART$2;
        }
        _commitValue(value) {
            {
                if (this._sanitizer === void 0) {
                    this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, 'property');
                }
                value = this._sanitizer(value);
            }
            this.element[this.name] = value === nothing$3 ? void 0 : value;
        }
    }
    class BooleanAttributePart$3 extends AttributePart$3 {
        constructor() {
            super(...arguments);
            this.type = BOOLEAN_ATTRIBUTE_PART$2;
        }
        _commitValue(value) {
            if (value && value !== nothing$3) {
                wrap$2(this.element).setAttribute(this.name, '');
            } else {
                wrap$2(this.element).removeAttribute(this.name);
            }
        }
    }
    class EventPart$3 extends AttributePart$3 {
        constructor() {
            super(...arguments);
            this.type = EVENT_PART$2;
        }
        _$setValue(newListener, directiveParent = this) {
            var _a;
            newListener =
                (_a = resolveDirective$2(this, newListener, directiveParent, 0)) !== null && _a !== void 0
                    ? _a
                    : nothing$3;
            if (newListener === noChange$3) {
                return;
            }
            const oldListener = this._$committedValue;
            const shouldRemoveListener =
                (newListener === nothing$3 && oldListener !== nothing$3) ||
                newListener.capture !== oldListener.capture ||
                newListener.once !== oldListener.once ||
                newListener.passive !== oldListener.passive;
            const shouldAddListener = newListener !== nothing$3 && (oldListener === nothing$3 || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.name, this, oldListener);
            }
            if (shouldAddListener) {
                this.element.addEventListener(this.name, this, newListener);
            }
            this._$committedValue = newListener;
        }
        handleEvent(event2) {
            var _a, _b;
            if (typeof this._$committedValue === 'function') {
                this._$committedValue.call(
                    (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0
                        ? _b
                        : this.element,
                    event2,
                );
            } else {
                this._$committedValue.handleEvent(event2);
            }
        }
    }
    class ElementPart$2 {
        constructor(element, parent, options) {
            this.element = element;
            this.type = ELEMENT_PART$2;
            this._$disconnectableChildren = void 0;
            this._$parent = parent;
            this.options = options;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value) {
            resolveDirective$2(this, value);
        }
    }
    (_d$3 = (_c$4 = globalThis)['litHtmlPlatformSupport']) === null || _d$3 === void 0
        ? void 0
        : _d$3.call(_c$4, Template$3, ChildPart$2);
    ((_e$3 = (_f$3 = globalThis)['litHtmlVersions']) !== null && _e$3 !== void 0
        ? _e$3
        : (_f$3['litHtmlVersions'] = [])
    ).push('2.0.0-rc.4');
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _a$4, _b$3, _c$3, _d$2, _e$2;
    var _f$2;
    class LitElement$1 extends ReactiveElement {
        constructor() {
            super(...arguments);
            this.renderOptions = { host: this };
            this.__childPart = void 0;
        }
        createRenderRoot() {
            var _a;
            var _b;
            const renderRoot = super.createRenderRoot();
            (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0
                ? _a
                : (_b.renderBefore = renderRoot.firstChild);
            return renderRoot;
        }
        update(changedProperties) {
            const value = this.render();
            super.update(changedProperties);
            this.__childPart = render$2(value, this.renderRoot, this.renderOptions);
        }
        connectedCallback() {
            var _a;
            super.connectedCallback();
            (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);
        }
        disconnectedCallback() {
            var _a;
            super.disconnectedCallback();
            (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);
        }
        render() {
            return noChange$3;
        }
    }
    LitElement$1['finalized'] = true;
    LitElement$1['_$litElement$'] = true;
    (_b$3 = (_a$4 = globalThis)['litElementHydrateSupport']) === null || _b$3 === void 0
        ? void 0
        : _b$3.call(_a$4, { LitElement: LitElement$1 });
    (_d$2 = (_c$3 = globalThis)['litElementPlatformSupport']) === null || _d$2 === void 0
        ? void 0
        : _d$2.call(_c$3, { LitElement: LitElement$1 });
    {
        LitElement$1['finalize'] = function () {
            const finalized = ReactiveElement.finalize.call(this);
            if (!finalized) {
                return false;
            }
            const warnRemoved = (obj, name2) => {
                if (obj[name2] !== void 0) {
                    console.warn(`\`${name2}\` is implemented. It has been removed from this version of LitElement. `);
                }
            };
            [`render`, `getStyles`].forEach((name2) => warnRemoved(this, name2));
            [`adoptStyles`].forEach((name2) => warnRemoved(this.prototype, name2));
            return true;
        };
    }
    ((_e$2 = (_f$2 = globalThis)['litElementVersions']) !== null && _e$2 !== void 0
        ? _e$2
        : (_f$2['litElementVersions'] = [])
    ).push('3.0.0-rc.3');
    class SLitElement extends LitElement$1 {}
    let scriptRel;
    const seen = {};
    const __vitePreload = function preload(baseModule, deps) {
        if (true) {
            return baseModule();
        }
        if (scriptRel === void 0) {
            const relList = document.createElement('link').relList;
            scriptRel = relList && relList.supports && relList.supports('modulepreload') ? 'modulepreload' : 'preload';
        }
        return Promise.all(
            deps.map((dep) => {
                if (dep in seen) return;
                seen[dep] = true;
                const isCss = dep.endsWith('.css');
                const cssSelector = isCss ? '[rel="stylesheet"]' : '';
                if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
                    return;
                }
                const link = document.createElement('link');
                link.rel = isCss ? 'stylesheet' : scriptRel;
                if (!isCss) {
                    link.as = 'script';
                    link.crossOrigin = '';
                }
                link.href = dep;
                document.head.appendChild(link);
                if (isCss) {
                    return new Promise((res, rej) => {
                        link.addEventListener('load', res);
                        link.addEventListener('error', rej);
                    });
                }
            }),
        ).then(() => baseModule());
    };
    function classInstance$1(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name === 'Object') return false;
        if (Object.prototype.toString.call(object) === '[object Object]') return false;
        if (object.constructor === Object) return false;
        return true;
    }
    function deepMap$1(objectOrArray, processor, settings = {}, _path = []) {
        settings = __deepMerge$2(
            {
                classInstances: false,
                array: true,
                privateProps: false,
                cloneFirst: true,
            },
            settings,
        );
        const isArray = Array.isArray(objectOrArray);
        let newObject = isArray ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
        Object.keys(objectOrArray).forEach((prop) => {
            if (!settings.privateProps && prop.match(/^_/)) return;
            if (
                plainObject$2(objectOrArray[prop]) ||
                (classInstance$1(objectOrArray[prop]) && settings.classInstances) ||
                (Array.isArray(objectOrArray[prop]) && settings.array)
            ) {
                const res2 = deepMap$1(objectOrArray[prop], processor, settings, [..._path, prop]);
                if (isArray) {
                    newObject.push(res2);
                } else {
                    if (prop === '...' && plainObject$2(res2)) {
                        newObject = Object.assign(Object.assign({}, newObject), res2);
                    } else {
                        newObject[prop] = res2;
                    }
                }
                return;
            }
            const res = processor({
                object: objectOrArray,
                prop,
                value: objectOrArray[prop],
                path: [..._path, prop].join('.'),
            });
            if (res === -1) {
                delete objectOrArray[prop];
                return;
            }
            if (isArray) newObject.push(res);
            else {
                if (prop === '...' && plainObject$2(res)) {
                    newObject = Object.assign(Object.assign({}, newObject), res);
                } else {
                    newObject[prop] = res;
                }
            }
        });
        return newObject;
    }
    function isMap$1(value) {
        return value instanceof Map;
    }
    function isArray$4(value) {
        return value && typeof value === 'object' && value.constructor === Array;
    }
    function isBoolean$1(value) {
        return typeof value === 'boolean';
    }
    function isFunction$2(value) {
        return value && {}.toString.call(value) === '[object Function]';
    }
    function isJson$1(value) {
        try {
            const res = JSON.parse(value);
            if (Object.keys(res).length) return true;
            return false;
        } catch (e) {
            return false;
        }
        return true;
    }
    function isObject$2(value) {
        return value && typeof value === 'object' && value.constructor === Object;
    }
    function mapToObject$1(map) {
        const obj = {};
        for (const [k, v] of map) obj[k] = v;
        return obj;
    }
    function fn$2(value, settings = {}) {
        settings = __deepMerge$2(
            {
                beautify: true,
                highlight: true,
                verbose: true,
                theme: {
                    number: source$5.yellow,
                    default: source$5.white,
                    keyword: source$5.blue,
                    regexp: source$5.red,
                    string: source$5.whiteBright,
                    class: source$5.yellow,
                    function: source$5.yellow,
                    comment: source$5.gray,
                    variable: source$5.red,
                    attr: source$5.green,
                },
            },
            settings,
        );
        if (typeof value === 'string') return value;
        if (value === null) return null;
        if (value === void 0) return void 0;
        if (value instanceof Error) {
            const errorStr = value.toString();
            const stackStr = value.stack;
            const messageStr = value.message;
            if (settings.verbose) {
                return [`<red>${value.constructor.name || 'Error'}</red>`, '', messageStr, '', stackStr].join('\n');
            }
            return errorStr;
        }
        if (isMap$1(value)) {
            value = mapToObject$1(value);
        }
        if (isObject$2(value) || isArray$4(value) || isJson$1(value)) {
            try {
                value = decycle_1(value);
            } catch (e) {}
            value = deepMap$1(value, ({ value: value2 }) => {
                if (value2 instanceof Map) return mapToObject$1(value2);
                return value2;
            });
            let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
            prettyString = prettyString.replace(/"([^"]+)":/g, '$1:').replace(/\uFFFF/g, '\\"');
            if (settings.highlight);
            return prettyString;
        }
        if (isBoolean$1(value)) {
            if (value) return 'true';
            else return 'false';
        }
        if (isFunction$2(value)) {
            return '' + value;
        }
        let returnString = '';
        try {
            value = decycle_1(value);
            returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
        } catch (e) {
            try {
                returnString = value.toString();
            } catch (e2) {
                returnString = value;
            }
        }
        return returnString;
    }
    var parse$2 = (value) => {
        if (typeof value !== 'string') return value;
        value = value.split('\u2800').join('').trim();
        try {
            return Function(`
      "use strict";
      return (${value});
    `)();
        } catch (e) {
            return value;
        }
    };
    const __encryptedMessages$1 = {};
    var __md5$1 = {
        encrypt: function (message) {
            if (typeof message !== 'string') message = fn$2(message);
            const string = md5$2(message).toString();
            __encryptedMessages$1[string] = message;
            return string;
        },
        decrypt: function (message) {
            if (!__encryptedMessages$1[message]) {
                console.warn(`The message "${message}" cannot be decrypted...`);
                return;
            }
            const string = __encryptedMessages$1[message];
            delete __encryptedMessages$1[message];
            return parse$2(string);
        },
    };
    function cls(cls) {
        if (!Array.isArray(cls)) cls = [cls];
        for (let i = 0; i < cls.length; i++) {
            if (!__isClass(cls[i])) return false;
        }
        return true;
    }
    function convert(from, to = 'ms') {
        let fromMs = from;
        if (typeof from === 'string') {
            const fromNumber = parseFloat(from);
            const fromLength = fromNumber.toString().length;
            const fromString = from.slice(fromLength);
            if (fromString === 'ms' || fromString === 'millisecond' || fromString === 'milliseconds') {
                fromMs = fromNumber;
            } else if (fromString === 's' || fromString === 'second' || fromString === 'seconds') {
                fromMs = fromNumber * 1e3;
            } else if (fromString === 'm' || fromString === 'minute' || fromString === 'minutes') {
                fromMs = fromNumber * 60 * 1e3;
            } else if (fromString === 'h' || fromString === 'hour' || fromString === 'hours') {
                fromMs = fromNumber * 60 * 60 * 1e3;
            } else if (fromString === 'd' || fromString === 'day' || fromString === 'days') {
                fromMs = fromNumber * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'w' || fromString === 'week' || fromString === 'weeks') {
                fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'month' || fromString === 'months') {
                fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
            } else if (fromString === 'y' || fromString === 'year' || fromString === 'years') {
                fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
            }
        }
        switch (to) {
            case 'ms':
            case 'millisecond':
            case 'milliseconds':
                return fromMs;
            case 's':
            case 'second':
            case 'seconds':
                return fromMs / 1e3;
            case 'm':
            case 'minute':
            case 'minutes':
                return fromMs / 1e3 / 60;
            case 'h':
            case 'hour':
            case 'hours':
                return fromMs / 1e3 / 60 / 60;
            case 'd':
            case 'day':
            case 'days':
                return fromMs / 1e3 / 60 / 60 / 24;
            case 'w':
            case 'week':
            case 'weeks':
                return fromMs / 1e3 / 60 / 60 / 24 / 7;
            case 'month':
            case 'months':
                return fromMs / 1e3 / 60 / 60 / 24 / 31;
            case 'y':
            case 'year':
            case 'years':
                return fromMs / 1e3 / 60 / 60 / 24 / 365;
            default:
                throw new Error(
                    `You try to convert "${from}" to "${to}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`,
                );
        }
    }
    convert.MILLISECOND = 'ms';
    convert.SECOND = 's';
    convert.MINUTE = 'm';
    convert.HOUR = 'h';
    convert.DAY = 'd';
    convert.WEEK = 'w';
    convert.MONTH = 'month';
    convert.YEAR = 'y';
    class SCacheAdapter$1 extends SClass {
        constructor(settings = {}) {
            super(
                __deepMerge$2(
                    {
                        cacheAdapter: {},
                    },
                    settings,
                ),
            );
        }
        setCache(cache) {
            this.cache = cache;
        }
    }
    var __awaiter$c = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SCacheLsAdapter extends SCacheAdapter$1 {
        constructor(settings = {}) {
            super(__deepMerge$2({}, settings));
        }
        set(name2, value) {
            return __awaiter$c(this, void 0, void 0, function* () {
                window.localStorage.setItem(`${this.cache.id}.${name2}`, value);
                return true;
            });
        }
        get(name2) {
            return __awaiter$c(this, void 0, void 0, function* () {
                return window.localStorage.getItem(`${this.cache.id}.${name2}`);
            });
        }
        delete(name2) {
            return __awaiter$c(this, void 0, void 0, function* () {
                window.localStorage.removeItem(`${this.cache.id}.${name2}`);
                return true;
            });
        }
        clear() {
            return __awaiter$c(this, void 0, void 0, function* () {
                const keys = Object.keys(window.localStorage);
                const keysToDelete = keys.filter((key) => {
                    return key.startsWith(`${this.cache.id}.`);
                });
                keysToDelete.forEach((k) => {
                    window.localStorage.removeItem(k);
                });
                return true;
            });
        }
        keys() {
            return __awaiter$c(this, void 0, void 0, function* () {
                const keys = Object.keys(window.localStorage);
                const cacheKeys = keys.filter((key) => {
                    return key.startsWith(`${this.cache.id}.`);
                });
                return cacheKeys;
            });
        }
    }
    SCacheLsAdapter.id = 'ls';
    var __isNode$1 = () => {
        return typeof process !== 'undefined' && process.release && process.release.name === 'node';
    };
    class SCacheSettingsInterface extends SInterface {}
    SCacheSettingsInterface.definition = {
        name: {
            type: 'String',
            required: true,
            default: 'SCache',
        },
        ttl: {
            type: 'Number',
            required: true,
            default: -1,
        },
        deleteOnExpire: {
            type: 'Boolean',
            required: true,
            default: true,
        },
        adapter: {
            type: 'String',
            required: true,
            default: __isNode$1() ? 'fs' : 'ls',
        },
        parse: {
            type: 'Function',
            required: true,
            default: JSON.parse,
        },
        stringify: {
            type: 'Function',
            required: true,
            default: JSON.stringify,
        },
    };
    var __awaiter$b = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SCache extends SClass {
        constructor(id, settings = {}) {
            super(
                __deepMerge$2(
                    {
                        cache: {
                            clearOnExit: false,
                        },
                    },
                    settings,
                ),
            );
            this.id = id;
            (() =>
                __awaiter$b(this, void 0, void 0, function* () {
                    if (__isNode$2()) {
                        this.constructor.registerAdapter(
                            (yield __vitePreload(
                                () =>
                                    Promise.resolve().then(function () {
                                        return SCacheFsAdapter$1;
                                    }),
                                false ? '__VITE_PRELOAD__' : void 0,
                            )).default,
                        );
                        if (this.cacheSettings.clearOnExit) {
                            const { default: __onProcessExit } = yield __vitePreload(
                                () =>
                                    Promise.resolve().then(function () {
                                        return onProcessExit$1;
                                    }),
                                false ? '__VITE_PRELOAD__' : void 0,
                            );
                            const { default: __parseHtml } = yield __vitePreload(
                                () =>
                                    Promise.resolve().then(function () {
                                        return parseHtml$1;
                                    }),
                                false ? '__VITE_PRELOAD__' : void 0,
                            );
                            __onProcessExit(() =>
                                __awaiter$b(this, void 0, void 0, function* () {
                                    console.log(
                                        __parseHtml(
                                            `<yellow>[${this.constructor.name}.${this.id}]</yellow> Clearing the cache`,
                                        ),
                                    );
                                    yield this.clear();
                                }),
                            );
                        }
                    } else {
                        this.constructor.registerAdapter(SCacheLsAdapter);
                    }
                }))();
            if (!id) {
                throw new Error(
                    `The SCache instance need an id. To set it, pass the "id" as the first argument of the constructor...`,
                );
            }
            if (!/^[a-zA-Z0-9-_\.]+$/.test(id)) {
                throw new Error(
                    `The name of an SCache instance can contain only letters like <green>[a-zA-Z0-9_-.]</green> but you've passed "<red>${name}</red>"...`,
                );
            }
        }
        get cacheSettings() {
            return this._settings.cache;
        }
        static registerAdapter(adapter, id) {
            if (this.registeredAdapters[id || adapter.id]) return;
            this.registeredAdapters[id || adapter.id] = adapter;
        }
        get adapter() {
            if (this._adapter) return this._adapter;
            const adptr = this.constructor.registeredAdapters[this.cacheSettings.adapter];
            if (!adptr) {
                throw `Sorry but it seems that the requested SCache adapter "<yellow>${this.cacheSettings.adapter}</yellow>" does not exists...`;
            }
            if (cls(adptr)) {
                this._adapter = new adptr();
            } else if (adptr !== void 0) {
                this._adapter = adptr;
            }
            this._adapter && this._adapter.setCache(this);
            return this._adapter;
        }
        get(name2, settings) {
            return __awaiter$b(this, void 0, void 0, function* () {
                const set = Object.assign({ valueOnly: true }, settings || {});
                if (typeof name2 !== 'string') {
                    name2 = __md5$1.encrypt(fn$2(name2));
                }
                const adapter = this.adapter;
                const rawValue = yield adapter.get(name2);
                if (!rawValue || typeof rawValue !== 'string') return null;
                const value = adapter.parse ? adapter.parse(rawValue) : this._parse(rawValue);
                let contextHash = void 0;
                if (set.context !== void 0) contextHash = __md5$1.encrypt(set.context);
                if (contextHash && value.contextHash !== void 0 && contextHash !== value.contextHash) {
                    yield adapter.delete(name2);
                    return null;
                }
                if (value.deleteAt !== -1 && value.deleteAt < new Date().getTime()) {
                    if (value.deleteOnExpire) yield adapter.delete(name2);
                    return null;
                }
                if (set.valueOnly) return value.value;
                return value;
            });
        }
        set(name2, value, settings) {
            return __awaiter$b(this, void 0, void 0, function* () {
                const set = Object.assign({}, settings || {});
                if (typeof name2 !== 'string') {
                    name2 = __md5$1.encrypt(fn$2(name2)).toString();
                }
                let contextHash = null;
                if (set.context !== void 0) {
                    contextHash = __md5$1.encrypt(set.context);
                }
                const adapter = this.adapter;
                const existingValue = yield this.get(
                    name2,
                    Object.assign(Object.assign({}, set), { valueOnly: false }),
                );
                const finalSettings = __deepMerge$2(
                    {
                        ttl: this.cacheSettings.ttl,
                        deleteOnExpire: this.cacheSettings.deleteOnExpire,
                    },
                    set,
                );
                const deleteAt =
                    finalSettings.ttl === -1
                        ? -1
                        : new Date().getTime() +
                          convert(
                              typeof finalSettings.ttl === 'number' ? `${finalSettings.ttl}s` : finalSettings.ttl,
                              'ms',
                          );
                const valueToSave = {
                    name: name2,
                    value,
                    contextHash,
                    created: existingValue ? existingValue.created : new Date().getTime(),
                    updated: new Date().getTime(),
                    deleteAt,
                    settings: finalSettings,
                };
                const stringifiedValueToSave = adapter.stringify
                    ? adapter.stringify(valueToSave)
                    : this._stringify(valueToSave);
                return adapter.set(name2, stringifiedValueToSave);
            });
        }
        exists(name2) {
            return __awaiter$b(this, void 0, void 0, function* () {
                const value = yield this.get(name2);
                if (value) return true;
                return false;
            });
        }
        delete(name2) {
            return __awaiter$b(this, void 0, void 0, function* () {
                const adapter = this.adapter;
                return adapter.delete(name2);
            });
        }
        clear() {
            return __awaiter$b(this, void 0, void 0, function* () {
                const adapter = this.adapter;
                return adapter.clear();
            });
        }
        _parse(rawValue) {
            return this.cacheSettings.parse(rawValue);
        }
        _stringify(object) {
            return this.cacheSettings.stringify(object);
        }
    }
    SCache.interfaces = {
        settings: {
            apply: true,
            on: '_settings.cache',
            class: SCacheSettingsInterface,
        },
    };
    SCache.registeredAdapters = {};
    function uniqid() {
        return v4();
    }
    function matches$1(el, selector) {
        if (el.nodeName == '#comment' || el.nodeName == '#text') {
            return false;
        }
        const p = Element.prototype;
        const f =
            p.matches ||
            p.webkitMatchesSelector ||
            p.mozMatchesSelector ||
            p.msMatchesSelector ||
            function (s) {
                return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
            };
        return f.call(el, selector);
    }
    let _observer$1;
    const _selectors$1 = {};
    function querySelectorLive$1(selector, cb = null, settings = {}) {
        const id = `${selector} - ${uniqid()}`;
        settings = Object.assign(
            {},
            {
                rootNode: document,
                once: true,
            },
            settings,
        );
        if (!_selectors$1[selector]) {
            _selectors$1[selector] = [
                {
                    id,
                    selector,
                    cb,
                    lastMutationId: null,
                    settings,
                },
            ];
        } else {
            _selectors$1[selector].push({
                id,
                selector,
                cb,
                lastMutationId: null,
                settings,
            });
        }
        return new SPromise(({ resolve, reject, emit }) => {
            function pushNewNode(node, sel, mutationId) {
                const objs = _selectors$1[sel];
                if (!objs) return;
                objs.forEach((obj) => {
                    if (obj.lastMutationId && obj.lastMutationId === mutationId) return;
                    if (obj.settings.once) {
                        if (!node._querySelectorLive) {
                            node._querySelectorLive = {};
                        }
                        if (node._querySelectorLive[obj.id]) return;
                        node._querySelectorLive[obj.id] = true;
                    }
                    emit('node', node);
                    obj.cb &&
                        obj.cb(node, () => {
                            delete _selectors$1[obj.selector];
                        });
                });
            }
            if (!_observer$1) {
                _observer$1 = new MutationObserver((mutations) => {
                    const mutationId = `mutation-${uniqid()}`;
                    mutations.forEach((mutation) => {
                        if (mutation.addedNodes && mutation.addedNodes.length) {
                            [].forEach.call(mutation.addedNodes, (node) => {
                                const selectors = Object.keys(_selectors$1);
                                selectors.forEach((sel) => {
                                    if (matches$1(node, sel)) {
                                        pushNewNode(node, sel, mutationId);
                                    }
                                });
                                if (!node.querySelectorAll) return;
                                selectors.forEach((sel) => {
                                    const nestedNodes = node.querySelectorAll(sel);
                                    [].forEach.call(nestedNodes, (nestedNode) => {
                                        pushNewNode(nestedNode, sel, mutationId);
                                    });
                                });
                            });
                        } else if (mutation.attributeName) {
                            const selectors = Object.keys(_selectors$1);
                            selectors.forEach((sel) => {
                                if (matches$1(mutation.target, sel)) {
                                    pushNewNode(mutation.target, sel, mutationId);
                                }
                            });
                        }
                    });
                });
                _observer$1.observe(settings.rootNode, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class', 'id'],
                });
            }
            [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
                pushNewNode(node, selector, 'init');
            });
        });
    }
    class SActivateComponentInterface$1 extends SInterface {}
    SActivateComponentInterface$1.definition = {
        method: {
            type: 'String',
            values: ['get', 'post'],
            default: 'get',
        },
        url: {
            type: 'String',
            required: true,
        },
        trigger: {
            type: 'String',
            values: ['event'],
            default: 'event',
        },
        on: {
            type: 'String',
        },
        cache: {
            type: 'String|Boolean',
            default: false,
        },
    };
    var commonjsGlobal =
        typeof globalThis !== 'undefined'
            ? globalThis
            : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
            ? global
            : typeof self !== 'undefined'
            ? self
            : {};
    function getAugmentedNamespace(n) {
        if (n.__esModule) return n;
        var a = Object.defineProperty({}, '__esModule', { value: true });
        Object.keys(n).forEach(function (k) {
            var d = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(
                a,
                k,
                d.get
                    ? d
                    : {
                          enumerable: true,
                          get: function () {
                              return n[k];
                          },
                      },
            );
        });
        return a;
    }
    var md5$1 = { exports: {} };
    var core$2 = { exports: {} };
    var __viteBrowserExternal_crypto = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_crypto$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_crypto,
    });
    var require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_crypto$1);
    (function (module2, exports) {
        (function (root, factory) {
            {
                module2.exports = factory();
            }
        })(commonjsGlobal, function () {
            var CryptoJS =
                CryptoJS ||
                (function (Math2, undefined$1) {
                    var crypto2;
                    if (typeof window !== 'undefined' && window.crypto) {
                        crypto2 = window.crypto;
                    }
                    if (!crypto2 && typeof window !== 'undefined' && window.msCrypto) {
                        crypto2 = window.msCrypto;
                    }
                    if (!crypto2 && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
                        crypto2 = commonjsGlobal.crypto;
                    }
                    if (!crypto2 && typeof require === 'function') {
                        try {
                            crypto2 = require$$0$5;
                        } catch (err) {}
                    }
                    var cryptoSecureRandomInt = function () {
                        if (crypto2) {
                            if (typeof crypto2.getRandomValues === 'function') {
                                try {
                                    return crypto2.getRandomValues(new Uint32Array(1))[0];
                                } catch (err) {}
                            }
                            if (typeof crypto2.randomBytes === 'function') {
                                try {
                                    return crypto2.randomBytes(4).readInt32LE();
                                } catch (err) {}
                            }
                        }
                        throw new Error('Native crypto module could not be used to get secure random number.');
                    };
                    var create =
                        Object.create ||
                        (function () {
                            function F() {}
                            return function (obj) {
                                var subtype;
                                F.prototype = obj;
                                subtype = new F();
                                F.prototype = null;
                                return subtype;
                            };
                        })();
                    var C = {};
                    var C_lib = (C.lib = {});
                    var Base = (C_lib.Base = (function () {
                        return {
                            extend: function (overrides) {
                                var subtype = create(this);
                                if (overrides) {
                                    subtype.mixIn(overrides);
                                }
                                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                                    subtype.init = function () {
                                        subtype.$super.init.apply(this, arguments);
                                    };
                                }
                                subtype.init.prototype = subtype;
                                subtype.$super = this;
                                return subtype;
                            },
                            create: function () {
                                var instance = this.extend();
                                instance.init.apply(instance, arguments);
                                return instance;
                            },
                            init: function () {},
                            mixIn: function (properties) {
                                for (var propertyName in properties) {
                                    if (properties.hasOwnProperty(propertyName)) {
                                        this[propertyName] = properties[propertyName];
                                    }
                                }
                                if (properties.hasOwnProperty('toString')) {
                                    this.toString = properties.toString;
                                }
                            },
                            clone: function () {
                                return this.init.prototype.extend(this);
                            },
                        };
                    })());
                    var WordArray = (C_lib.WordArray = Base.extend({
                        init: function (words, sigBytes) {
                            words = this.words = words || [];
                            if (sigBytes != undefined$1) {
                                this.sigBytes = sigBytes;
                            } else {
                                this.sigBytes = words.length * 4;
                            }
                        },
                        toString: function (encoder) {
                            return (encoder || Hex).stringify(this);
                        },
                        concat: function (wordArray) {
                            var thisWords = this.words;
                            var thatWords = wordArray.words;
                            var thisSigBytes = this.sigBytes;
                            var thatSigBytes = wordArray.sigBytes;
                            this.clamp();
                            if (thisSigBytes % 4) {
                                for (var i = 0; i < thatSigBytes; i++) {
                                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                    thisWords[(thisSigBytes + i) >>> 2] |=
                                        thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                                }
                            } else {
                                for (var i = 0; i < thatSigBytes; i += 4) {
                                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                                }
                            }
                            this.sigBytes += thatSigBytes;
                            return this;
                        },
                        clamp: function () {
                            var words = this.words;
                            var sigBytes = this.sigBytes;
                            words[sigBytes >>> 2] &= 4294967295 << (32 - (sigBytes % 4) * 8);
                            words.length = Math2.ceil(sigBytes / 4);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone.words = this.words.slice(0);
                            return clone;
                        },
                        random: function (nBytes) {
                            var words = [];
                            for (var i = 0; i < nBytes; i += 4) {
                                words.push(cryptoSecureRandomInt());
                            }
                            return new WordArray.init(words, nBytes);
                        },
                    }));
                    var C_enc = (C.enc = {});
                    var Hex = (C_enc.Hex = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var hexChars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                hexChars.push((bite >>> 4).toString(16));
                                hexChars.push((bite & 15).toString(16));
                            }
                            return hexChars.join('');
                        },
                        parse: function (hexStr) {
                            var hexStrLength = hexStr.length;
                            var words = [];
                            for (var i = 0; i < hexStrLength; i += 2) {
                                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                            }
                            return new WordArray.init(words, hexStrLength / 2);
                        },
                    });
                    var Latin1 = (C_enc.Latin1 = {
                        stringify: function (wordArray) {
                            var words = wordArray.words;
                            var sigBytes = wordArray.sigBytes;
                            var latin1Chars = [];
                            for (var i = 0; i < sigBytes; i++) {
                                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                                latin1Chars.push(String.fromCharCode(bite));
                            }
                            return latin1Chars.join('');
                        },
                        parse: function (latin1Str) {
                            var latin1StrLength = latin1Str.length;
                            var words = [];
                            for (var i = 0; i < latin1StrLength; i++) {
                                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << (24 - (i % 4) * 8);
                            }
                            return new WordArray.init(words, latin1StrLength);
                        },
                    });
                    var Utf8 = (C_enc.Utf8 = {
                        stringify: function (wordArray) {
                            try {
                                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                            } catch (e) {
                                throw new Error('Malformed UTF-8 data');
                            }
                        },
                        parse: function (utf8Str) {
                            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                        },
                    });
                    var BufferedBlockAlgorithm = (C_lib.BufferedBlockAlgorithm = Base.extend({
                        reset: function () {
                            this._data = new WordArray.init();
                            this._nDataBytes = 0;
                        },
                        _append: function (data) {
                            if (typeof data == 'string') {
                                data = Utf8.parse(data);
                            }
                            this._data.concat(data);
                            this._nDataBytes += data.sigBytes;
                        },
                        _process: function (doFlush) {
                            var processedWords;
                            var data = this._data;
                            var dataWords = data.words;
                            var dataSigBytes = data.sigBytes;
                            var blockSize = this.blockSize;
                            var blockSizeBytes = blockSize * 4;
                            var nBlocksReady = dataSigBytes / blockSizeBytes;
                            if (doFlush) {
                                nBlocksReady = Math2.ceil(nBlocksReady);
                            } else {
                                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                            }
                            var nWordsReady = nBlocksReady * blockSize;
                            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                            if (nWordsReady) {
                                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                                    this._doProcessBlock(dataWords, offset);
                                }
                                processedWords = dataWords.splice(0, nWordsReady);
                                data.sigBytes -= nBytesReady;
                            }
                            return new WordArray.init(processedWords, nBytesReady);
                        },
                        clone: function () {
                            var clone = Base.clone.call(this);
                            clone._data = this._data.clone();
                            return clone;
                        },
                        _minBufferSize: 0,
                    }));
                    C_lib.Hasher = BufferedBlockAlgorithm.extend({
                        cfg: Base.extend(),
                        init: function (cfg) {
                            this.cfg = this.cfg.extend(cfg);
                            this.reset();
                        },
                        reset: function () {
                            BufferedBlockAlgorithm.reset.call(this);
                            this._doReset();
                        },
                        update: function (messageUpdate) {
                            this._append(messageUpdate);
                            this._process();
                            return this;
                        },
                        finalize: function (messageUpdate) {
                            if (messageUpdate) {
                                this._append(messageUpdate);
                            }
                            var hash = this._doFinalize();
                            return hash;
                        },
                        blockSize: 512 / 32,
                        _createHelper: function (hasher) {
                            return function (message, cfg) {
                                return new hasher.init(cfg).finalize(message);
                            };
                        },
                        _createHmacHelper: function (hasher) {
                            return function (message, key) {
                                return new C_algo.HMAC.init(hasher, key).finalize(message);
                            };
                        },
                    });
                    var C_algo = (C.algo = {});
                    return C;
                })(Math);
            return CryptoJS;
        });
    })(core$2);
    (function (module2, exports) {
        (function (root, factory) {
            {
                module2.exports = factory(core$2.exports);
            }
        })(commonjsGlobal, function (CryptoJS) {
            (function (Math2) {
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;
                var T = [];
                (function () {
                    for (var i = 0; i < 64; i++) {
                        T[i] = (Math2.abs(Math2.sin(i + 1)) * 4294967296) | 0;
                    }
                })();
                var MD5 = (C_algo.MD5 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
                    },
                    _doProcessBlock: function (M, offset) {
                        for (var i = 0; i < 16; i++) {
                            var offset_i = offset + i;
                            var M_offset_i = M[offset_i];
                            M[offset_i] =
                                (((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) |
                                (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360);
                        }
                        var H = this._hash.words;
                        var M_offset_0 = M[offset + 0];
                        var M_offset_1 = M[offset + 1];
                        var M_offset_2 = M[offset + 2];
                        var M_offset_3 = M[offset + 3];
                        var M_offset_4 = M[offset + 4];
                        var M_offset_5 = M[offset + 5];
                        var M_offset_6 = M[offset + 6];
                        var M_offset_7 = M[offset + 7];
                        var M_offset_8 = M[offset + 8];
                        var M_offset_9 = M[offset + 9];
                        var M_offset_10 = M[offset + 10];
                        var M_offset_11 = M[offset + 11];
                        var M_offset_12 = M[offset + 12];
                        var M_offset_13 = M[offset + 13];
                        var M_offset_14 = M[offset + 14];
                        var M_offset_15 = M[offset + 15];
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                        a = II(a, b, c, d, M_offset_0, 6, T[48]);
                        d = II(d, a, b, c, M_offset_7, 10, T[49]);
                        c = II(c, d, a, b, M_offset_14, 15, T[50]);
                        b = II(b, c, d, a, M_offset_5, 21, T[51]);
                        a = II(a, b, c, d, M_offset_12, 6, T[52]);
                        d = II(d, a, b, c, M_offset_3, 10, T[53]);
                        c = II(c, d, a, b, M_offset_10, 15, T[54]);
                        b = II(b, c, d, a, M_offset_1, 21, T[55]);
                        a = II(a, b, c, d, M_offset_8, 6, T[56]);
                        d = II(d, a, b, c, M_offset_15, 10, T[57]);
                        c = II(c, d, a, b, M_offset_6, 15, T[58]);
                        b = II(b, c, d, a, M_offset_13, 21, T[59]);
                        a = II(a, b, c, d, M_offset_4, 6, T[60]);
                        d = II(d, a, b, c, M_offset_11, 10, T[61]);
                        c = II(c, d, a, b, M_offset_2, 15, T[62]);
                        b = II(b, c, d, a, M_offset_9, 21, T[63]);
                        H[0] = (H[0] + a) | 0;
                        H[1] = (H[1] + b) | 0;
                        H[2] = (H[2] + c) | 0;
                        H[3] = (H[3] + d) | 0;
                    },
                    _doFinalize: function () {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                        var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                        var nBitsTotalL = nBitsTotal;
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] =
                            (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 16711935) |
                            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 4278255360);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] =
                            (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 16711935) |
                            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 4278255360);
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 4; i++) {
                            var H_i = H[i];
                            H[i] =
                                (((H_i << 8) | (H_i >>> 24)) & 16711935) | (((H_i << 24) | (H_i >>> 8)) & 4278255360);
                        }
                        return hash;
                    },
                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                    },
                }));
                function FF(a, b, c, d, x, s, t) {
                    var n = a + ((b & c) | (~b & d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function GG(a, b, c, d, x, s, t) {
                    var n = a + ((b & d) | (c & ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function HH(a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                function II(a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                C.MD5 = Hasher._createHelper(MD5);
                C.HmacMD5 = Hasher._createHmacHelper(MD5);
            })(Math);
            return CryptoJS.MD5;
        });
    })(md5$1);
    var md5 = md5$1.exports;
    function plainObject$1(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name !== 'Object') return false;
        if (Object.prototype.toString.call(object) !== '[object Object]') return false;
        if (object !== Object(object)) return false;
        return true;
    }
    function __deepMerge$1(...args) {
        function merge(firstObj, secondObj) {
            const newObj = {};
            if (!firstObj && secondObj) return secondObj;
            if (!secondObj && firstObj) return firstObj;
            if (!firstObj && !secondObj) return {};
            const firstProps = Object.getOwnPropertyNames(firstObj);
            firstProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(firstObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else {
                    newObj[key] = firstObj[key];
                }
            });
            const secondProps = Object.getOwnPropertyNames(secondObj);
            secondProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(secondObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else if (plainObject$1(newObj[key]) && plainObject$1(secondObj[key])) {
                    newObj[key] = merge(newObj[key], secondObj[key]);
                } else {
                    newObj[key] = secondObj[key];
                }
            });
            return newObj;
        }
        let currentObj = {};
        for (let i = 0; i < args.length; i++) {
            const toMergeObj = args[i];
            currentObj = merge(currentObj, toMergeObj);
        }
        return currentObj;
    }
    function classInstance(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name === 'Object') return false;
        if (Object.prototype.toString.call(object) === '[object Object]') return false;
        if (object.constructor === Object) return false;
        return true;
    }
    function deepMap(objectOrArray, processor, settings = {}, _path = []) {
        settings = __deepMerge$1(
            {
                classInstances: false,
                array: true,
                privateProps: false,
                cloneFirst: true,
            },
            settings,
        );
        const isArray2 = Array.isArray(objectOrArray);
        let newObject = isArray2 ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
        Object.keys(objectOrArray).forEach((prop) => {
            if (!settings.privateProps && prop.match(/^_/)) return;
            if (
                plainObject$1(objectOrArray[prop]) ||
                (classInstance(objectOrArray[prop]) && settings.classInstances) ||
                (Array.isArray(objectOrArray[prop]) && settings.array)
            ) {
                const res2 = deepMap(objectOrArray[prop], processor, settings, [..._path, prop]);
                if (isArray2) {
                    newObject.push(res2);
                } else {
                    if (prop === '...' && plainObject$1(res2)) {
                        newObject = Object.assign(Object.assign({}, newObject), res2);
                    } else {
                        newObject[prop] = res2;
                    }
                }
                return;
            }
            const res = processor({
                object: objectOrArray,
                prop,
                value: objectOrArray[prop],
                path: [..._path, prop].join('.'),
            });
            if (res === -1) {
                delete objectOrArray[prop];
                return;
            }
            if (isArray2) newObject.push(res);
            else {
                if (prop === '...' && plainObject$1(res)) {
                    newObject = Object.assign(Object.assign({}, newObject), res);
                } else {
                    newObject[prop] = res;
                }
            }
        });
        return newObject;
    }
    function isMap(value) {
        return value instanceof Map;
    }
    function isArray$3(value) {
        return value && typeof value === 'object' && value.constructor === Array;
    }
    function isBoolean(value) {
        return typeof value === 'boolean';
    }
    function isFunction$1(value) {
        return value && {}.toString.call(value) === '[object Function]';
    }
    function isJson(value) {
        try {
            const res = JSON.parse(value);
            if (Object.keys(res).length) return true;
            return false;
        } catch (e) {
            return false;
        }
        return true;
    }
    function isObject$1(value) {
        return value && typeof value === 'object' && value.constructor === Object;
    }
    function mapToObject(map) {
        const obj = {};
        for (const [k, v] of map) obj[k] = v;
        return obj;
    }
    function fn$1(value, settings = {}) {
        settings = __deepMerge$1(
            {
                beautify: true,
                highlight: true,
                verbose: true,
                theme: {
                    number: source$5.yellow,
                    default: source$5.white,
                    keyword: source$5.blue,
                    regexp: source$5.red,
                    string: source$5.whiteBright,
                    class: source$5.yellow,
                    function: source$5.yellow,
                    comment: source$5.gray,
                    variable: source$5.red,
                    attr: source$5.green,
                },
            },
            settings,
        );
        if (typeof value === 'string') return value;
        if (value === null) return null;
        if (value === void 0) return void 0;
        if (value instanceof Error) {
            const errorStr = value.toString();
            const stackStr = value.stack;
            const messageStr = value.message;
            if (settings.verbose) {
                return [`<red>${value.constructor.name || 'Error'}</red>`, '', messageStr, '', stackStr].join('\n');
            }
            return errorStr;
        }
        if (isMap(value)) {
            value = mapToObject(value);
        }
        if (isObject$1(value) || isArray$3(value) || isJson(value)) {
            try {
                value = decycle_1(value);
            } catch (e) {}
            value = deepMap(value, ({ value: value2 }) => {
                if (value2 instanceof Map) return mapToObject(value2);
                return value2;
            });
            let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
            prettyString = prettyString.replace(/"([^"]+)":/g, '$1:').replace(/\uFFFF/g, '\\"');
            if (settings.highlight);
            return prettyString;
        }
        if (isBoolean(value)) {
            if (value) return 'true';
            else return 'false';
        }
        if (isFunction$1(value)) {
            return '' + value;
        }
        let returnString = '';
        try {
            value = decycle_1(value);
            returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
        } catch (e) {
            try {
                returnString = value.toString();
            } catch (e2) {
                returnString = value;
            }
        }
        return returnString;
    }
    var parse$1 = (value) => {
        if (typeof value !== 'string') return value;
        value = value.split('\u2800').join('').trim();
        try {
            return Function(`
      "use strict";
      return (${value});
    `)();
        } catch (e) {
            return value;
        }
    };
    const __encryptedMessages = {};
    var __md5 = {
        encrypt: function (message) {
            if (typeof message !== 'string') message = fn$1(message);
            const string = md5(message).toString();
            __encryptedMessages[string] = message;
            return string;
        },
        decrypt: function (message) {
            if (!__encryptedMessages[message]) {
                console.warn(`The message "${message}" cannot be decrypted...`);
                return;
            }
            const string = __encryptedMessages[message];
            delete __encryptedMessages[message];
            return parse$1(string);
        },
    };
    const Component = {
        css: ``,
        exports: {
            _inlineProxyObj: void 0,
            onBeforeMount() {
                return __async(this, null, function* () {
                    this.component = new SComponentUtils(this.root, this.props, {
                        interface: SActivateComponentInterface$1,
                    });
                    const $script = this.root.querySelector('script');
                    if ($script) {
                        const id = uniqid();
                        let scriptText = $script.innerText.trim();
                        scriptText = scriptText.replace(/^export default /, `window['${`s-request-script-${id}`}'] = `);
                        const $newScript = document.createElement('script');
                        $newScript.text = scriptText;
                        $script.parentNode.insertBefore($newScript, $script);
                        $script.remove();
                        this._inlineProxyObj = window[`s-request-script-${id}`];
                    }
                    if (this.component.props.cache) {
                        this._cache = new SCache('s-request');
                    }
                    this.root.request = this.request.bind(this);
                    this.root.getData = this.getData.bind(this);
                });
            },
            getData(payload) {
                return __async(this, null, function* () {
                    return this.request(payload);
                });
            },
            request(data) {
                return __async(this, null, function* () {
                    var _a, _b, _c;
                    let payload = {
                        type: (_a = this.component.props.type) != null ? _a : 'get',
                        url: this.component.props.url,
                        data,
                        headers: {
                            'Cache-Control': 'no-cache',
                            Pragma: 'no-cache',
                            Expires: '0',
                        },
                    };
                    if ((_b = this._inlineProxyObj) == null ? void 0 : _b.request) {
                        payload = this._inlineProxyObj.request(payload);
                    }
                    const cacheHash = __md5.encrypt(payload);
                    const request = new SRequest(payload);
                    let res = yield request.send();
                    for (let i = 0; i < 2; i++) {
                        try {
                            if (this.component.props.cache !== false) {
                                yield this._cache.set(cacheHash, res.data, {
                                    ttl:
                                        typeof this.component.props.cache === 'string'
                                            ? this.component.props.cache
                                            : -1,
                                });
                            }
                            break;
                        } catch (e) {
                            this._cache.clear();
                        }
                    }
                    if ((_c = this._inlineProxyObj) == null ? void 0 : _c.response) {
                        res = this._inlineProxyObj.response(res);
                    }
                    if (res.data && res.status && res.headers) res = res.data;
                    return res;
                });
            },
            onMounted() {},
        },
        template: null,
        name: 's-request',
    };
    register('s-request', Component);
    querySelectorLive$1('s-request:not([mounted])', ($elm) => {
        const id = $elm.id || 's-request-' + uniqid();
        $elm.setAttribute('id', id);
        mount('#' + id);
    });
    Component.mount = () => {
        mount('s-request');
    };
    /*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var clipboardCopy_1 = clipboardCopy;
    function makeError() {
        return new DOMException('The request is not allowed', 'NotAllowedError');
    }
    function copyClipboardApi(text) {
        return __async(this, null, function* () {
            if (!navigator.clipboard) {
                throw makeError();
            }
            return navigator.clipboard.writeText(text);
        });
    }
    function copyExecCommand(text) {
        return __async(this, null, function* () {
            const span = document.createElement('span');
            span.textContent = text;
            span.style.whiteSpace = 'pre';
            span.style.webkitUserSelect = 'auto';
            span.style.userSelect = 'all';
            document.body.appendChild(span);
            const selection = window.getSelection();
            const range = window.document.createRange();
            selection.removeAllRanges();
            range.selectNode(span);
            selection.addRange(range);
            let success = false;
            try {
                success = window.document.execCommand('copy');
            } finally {
                selection.removeAllRanges();
                window.document.body.removeChild(span);
            }
            if (!success) throw makeError();
        });
    }
    function clipboardCopy(text) {
        return __async(this, null, function* () {
            try {
                yield copyClipboardApi(text);
            } catch (err) {
                try {
                    yield copyExecCommand(text);
                } catch (err2) {
                    throw err2 || err || makeError();
                }
            }
        });
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$6 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$6 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$6(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$6(options, protoOrDescriptor, name2)
                : standardProperty$6(options, protoOrDescriptor);
    }
    class SHighlightJsComponentInterface extends SInterface {}
    SHighlightJsComponentInterface.definition = {
        successTimeout: {
            type: 'Number',
            default: 1500,
        },
        errorTimeout: {
            type: 'Number',
            default: 3e3,
        },
    };
    function copy$3(text) {
        return clipboardCopy_1(text);
    }
    var __css$5 =
        ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0) + var(--s-theme-color-success-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-success-l, 0) + var(--s-theme-color-success-lightness-offset, 0)) * 1%),var(--s-theme-color-success-a, 1));\n    }\n\n    .s-clipboard-copy[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + var(--s-theme-color-error-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + var(--s-theme-color-error-lightness-offset, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    }\n\n    .s-clipboard-copy[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n";
    var __decorate$8 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class SClipboardCopy extends SLitElement {
        constructor() {
            super();
            this._state = 'pending';
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SHighlightJsComponentInterface,
                    defaultProps: {},
                },
            });
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(__css$5)}
        `;
        }
        copy(text) {
            this._state = 'copy';
            copy$3(text)
                .then(() => {
                    this._state = 'success';
                    setTimeout(() => {
                        this._state = 'pending';
                    }, this._component.props.successTimeout);
                })
                .catch((e) => {
                    this._state = 'error';
                    setTimeout(() => {
                        this._state = 'pending';
                    }, this._component.props.errorTimeout);
                });
        }
        render() {
            return html$4`
            <div class="${this._component.className('')}" state="${this._state}">
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z" fill="currentColor" />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z" fill="currentColor" />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
        }
    }
    __decorate$8([property$6()], SClipboardCopy.prototype, '_state', void 0);
    function webcomponent$a(props = {}, tagName = 's-clipboard-copy') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SClipboardCopy);
    }
    function wait(timeout = 0) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, timeout);
        });
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _a$3, _b$2, _c$2, _d$1, _e$1;
    var _f$1;
    {
        console.warn('lit-html is in dev mode. Not recommended for production!');
    }
    const wrap$1 =
        ((_a$3 = window.ShadyDOM) === null || _a$3 === void 0 ? void 0 : _a$3.inUse) &&
        ((_b$2 = window.ShadyDOM) === null || _b$2 === void 0 ? void 0 : _b$2.noPatch) === true
            ? window.ShadyDOM.wrap
            : (node) => node;
    const trustedTypes$2 = globalThis.trustedTypes;
    const policy$2 = trustedTypes$2
        ? trustedTypes$2.createPolicy('lit-html', {
              createHTML: (s) => s,
          })
        : void 0;
    const identityFunction$1 = (value) => value;
    const noopSanitizer$1 = (_node, _name, _type) => identityFunction$1;
    const createSanitizer$1 = (node, name2, type) => {
        return sanitizerFactoryInternal$1();
    };
    const boundAttributeSuffix$2 = '$lit$';
    const marker$2 = `lit$${String(Math.random()).slice(9)}$`;
    const markerMatch$1 = '?' + marker$2;
    const nodeMarker$2 = `<${markerMatch$1}>`;
    const d$1 = document;
    const createMarker$2 = (v = '') => d$1.createComment(v);
    const isPrimitive$2 = (value) => value === null || (typeof value != 'object' && typeof value != 'function');
    const isArray$2 = Array.isArray;
    const isIterable$2 = (value) => {
        var _a2;
        return (
            isArray$2(value) ||
            typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === 'function'
        );
    };
    const SPACE_CHAR$1 = `[ 	
\f\r]`;
    const ATTR_VALUE_CHAR$1 = `[^ 	
\f\r"'\`<>=]`;
    const NAME_CHAR$1 = `[^\\s"'>=/]`;
    const textEndRegex$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    const COMMENT_START$1 = 1;
    const TAG_NAME$1 = 2;
    const DYNAMIC_TAG_NAME$1 = 3;
    const commentEndRegex$1 = /-->/g;
    const comment2EndRegex$1 = />/g;
    const tagEndRegex$1 = new RegExp(
        `>|${SPACE_CHAR$1}(?:(${NAME_CHAR$1}+)(${SPACE_CHAR$1}*=${SPACE_CHAR$1}*(?:${ATTR_VALUE_CHAR$1}|("|')|))|$)`,
        'g',
    );
    const ENTIRE_MATCH$1 = 0;
    const ATTRIBUTE_NAME$1 = 1;
    const SPACES_AND_EQUALS$1 = 2;
    const QUOTE_CHAR$1 = 3;
    const singleQuoteAttrEndRegex$1 = /'/g;
    const doubleQuoteAttrEndRegex$1 = /"/g;
    const rawTextElement$1 = /^(?:script|style|textarea)$/i;
    const HTML_RESULT$1 = 1;
    const SVG_RESULT$1 = 2;
    const ATTRIBUTE_PART$1 = 1;
    const CHILD_PART$1 = 2;
    const PROPERTY_PART$1 = 3;
    const BOOLEAN_ATTRIBUTE_PART$1 = 4;
    const EVENT_PART$1 = 5;
    const ELEMENT_PART$1 = 6;
    const COMMENT_PART$1 = 7;
    const tag$1 =
        (type) =>
        (strings, ...values) => {
            if (strings.some((s) => s === void 0)) {
                console.warn(
                    'Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.',
                );
            }
            return {
                ['_$litType$']: type,
                strings,
                values,
            };
        };
    const html$1$1 = tag$1(HTML_RESULT$1);
    const noChange$2 = Symbol.for('lit-noChange');
    const nothing$2 = Symbol.for('lit-nothing');
    const templateCache$1 = new WeakMap();
    const walker$1 = d$1.createTreeWalker(d$1, 129, null, false);
    let sanitizerFactoryInternal$1 = noopSanitizer$1;
    const getTemplateHtml$1 = (strings, type) => {
        const l = strings.length - 1;
        const attrNames = [];
        let html2 = type === SVG_RESULT$1 ? '<svg>' : '';
        let rawTextEndRegex;
        let regex = textEndRegex$1;
        for (let i = 0; i < l; i++) {
            const s = strings[i];
            let attrNameEndIndex = -1;
            let attrName;
            let lastIndex = 0;
            let match;
            while (lastIndex < s.length) {
                regex.lastIndex = lastIndex;
                match = regex.exec(s);
                if (match === null) {
                    break;
                }
                lastIndex = regex.lastIndex;
                if (regex === textEndRegex$1) {
                    if (match[COMMENT_START$1] === '!--') {
                        regex = commentEndRegex$1;
                    } else if (match[COMMENT_START$1] !== void 0) {
                        regex = comment2EndRegex$1;
                    } else if (match[TAG_NAME$1] !== void 0) {
                        if (rawTextElement$1.test(match[TAG_NAME$1])) {
                            rawTextEndRegex = new RegExp(`</${match[TAG_NAME$1]}`, 'g');
                        }
                        regex = tagEndRegex$1;
                    } else if (match[DYNAMIC_TAG_NAME$1] !== void 0) {
                        regex = tagEndRegex$1;
                    }
                } else if (regex === tagEndRegex$1) {
                    if (match[ENTIRE_MATCH$1] === '>') {
                        regex =
                            rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$1;
                        attrNameEndIndex = -1;
                    } else if (match[ATTRIBUTE_NAME$1] === void 0) {
                        attrNameEndIndex = -2;
                    } else {
                        attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS$1].length;
                        attrName = match[ATTRIBUTE_NAME$1];
                        regex =
                            match[QUOTE_CHAR$1] === void 0
                                ? tagEndRegex$1
                                : match[QUOTE_CHAR$1] === '"'
                                ? doubleQuoteAttrEndRegex$1
                                : singleQuoteAttrEndRegex$1;
                    }
                } else if (regex === doubleQuoteAttrEndRegex$1 || regex === singleQuoteAttrEndRegex$1) {
                    regex = tagEndRegex$1;
                } else if (regex === commentEndRegex$1 || regex === comment2EndRegex$1) {
                    regex = textEndRegex$1;
                } else {
                    regex = tagEndRegex$1;
                    rawTextEndRegex = void 0;
                }
            }
            {
                console.assert(
                    attrNameEndIndex === -1 ||
                        regex === tagEndRegex$1 ||
                        regex === singleQuoteAttrEndRegex$1 ||
                        regex === doubleQuoteAttrEndRegex$1,
                    'unexpected parse state B',
                );
            }
            const end = regex === tagEndRegex$1 && strings[i + 1].startsWith('/>') ? ' ' : '';
            html2 +=
                regex === textEndRegex$1
                    ? s + nodeMarker$2
                    : attrNameEndIndex >= 0
                    ? (attrNames.push(attrName),
                      s.slice(0, attrNameEndIndex) + boundAttributeSuffix$2 + s.slice(attrNameEndIndex)) +
                      marker$2 +
                      end
                    : s + marker$2 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
        }
        const htmlResult = html2 + (strings[l] || '<?>') + (type === SVG_RESULT$1 ? '</svg>' : '');
        return [policy$2 !== void 0 ? policy$2.createHTML(htmlResult) : htmlResult, attrNames];
    };
    class Template$2 {
        constructor({ strings, ['_$litType$']: type }, options) {
            this.parts = [];
            let node;
            let nodeIndex = 0;
            let attrNameIndex = 0;
            const partCount = strings.length - 1;
            const parts = this.parts;
            const [html2, attrNames] = getTemplateHtml$1(strings, type);
            this.el = Template$2.createElement(html2, options);
            walker$1.currentNode = this.el.content;
            if (type === SVG_RESULT$1) {
                const content = this.el.content;
                const svgElement = content.firstChild;
                svgElement.remove();
                content.append(...svgElement.childNodes);
            }
            while ((node = walker$1.nextNode()) !== null && parts.length < partCount) {
                if (node.nodeType === 1) {
                    if (node.hasAttributes()) {
                        const attrsToRemove = [];
                        for (const name2 of node.getAttributeNames()) {
                            if (name2.endsWith(boundAttributeSuffix$2) || name2.startsWith(marker$2)) {
                                const realName = attrNames[attrNameIndex++];
                                attrsToRemove.push(name2);
                                if (realName !== void 0) {
                                    const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$2);
                                    const statics = value.split(marker$2);
                                    const m = /([.?@])?(.*)/.exec(realName);
                                    parts.push({
                                        type: ATTRIBUTE_PART$1,
                                        index: nodeIndex,
                                        name: m[2],
                                        strings: statics,
                                        ctor:
                                            m[1] === '.'
                                                ? PropertyPart$2
                                                : m[1] === '?'
                                                ? BooleanAttributePart$2
                                                : m[1] === '@'
                                                ? EventPart$2
                                                : AttributePart$2,
                                    });
                                } else {
                                    parts.push({
                                        type: ELEMENT_PART$1,
                                        index: nodeIndex,
                                    });
                                }
                            }
                        }
                        for (const name2 of attrsToRemove) {
                            node.removeAttribute(name2);
                        }
                    }
                    if (rawTextElement$1.test(node.tagName)) {
                        const strings2 = node.textContent.split(marker$2);
                        const lastIndex = strings2.length - 1;
                        if (lastIndex > 0) {
                            node.textContent = trustedTypes$2 ? trustedTypes$2.emptyScript : '';
                            for (let i = 0; i < lastIndex; i++) {
                                node.append(strings2[i], createMarker$2());
                                walker$1.nextNode();
                                parts.push({ type: CHILD_PART$1, index: ++nodeIndex });
                            }
                            node.append(strings2[lastIndex], createMarker$2());
                        }
                    }
                } else if (node.nodeType === 8) {
                    const data = node.data;
                    if (data === markerMatch$1) {
                        parts.push({ type: CHILD_PART$1, index: nodeIndex });
                    } else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker$2, i + 1)) !== -1) {
                            parts.push({ type: COMMENT_PART$1, index: nodeIndex });
                            i += marker$2.length - 1;
                        }
                    }
                }
                nodeIndex++;
            }
        }
        static createElement(html2, _options) {
            const el = d$1.createElement('template');
            el.innerHTML = html2;
            return el;
        }
    }
    function resolveDirective$1(part, value, parent = part, attributeIndex) {
        var _a2, _b2, _c2;
        var _d2;
        if (value === noChange$2) {
            return value;
        }
        let currentDirective =
            attributeIndex !== void 0
                ? (_a2 = parent.__directives) === null || _a2 === void 0
                    ? void 0
                    : _a2[attributeIndex]
                : parent.__directive;
        const nextDirectiveConstructor = isPrimitive$2(value) ? void 0 : value['_$litDirective$'];
        if (
            (currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !==
            nextDirectiveConstructor
        ) {
            (_b2 =
                currentDirective === null || currentDirective === void 0
                    ? void 0
                    : currentDirective['_$notifyDirectiveConnectionChanged']) === null || _b2 === void 0
                ? void 0
                : _b2.call(currentDirective, false);
            if (nextDirectiveConstructor === void 0) {
                currentDirective = void 0;
            } else {
                currentDirective = new nextDirectiveConstructor(part);
                currentDirective._$initialize(part, parent, attributeIndex);
            }
            if (attributeIndex !== void 0) {
                ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : (_d2.__directives = []))[
                    attributeIndex
                ] = currentDirective;
            } else {
                parent.__directive = currentDirective;
            }
        }
        if (currentDirective !== void 0) {
            value = resolveDirective$1(
                part,
                currentDirective._$resolve(part, value.values),
                currentDirective,
                attributeIndex,
            );
        }
        return value;
    }
    class TemplateInstance$2 {
        constructor(template, parent) {
            this._parts = [];
            this._$disconnectableChildren = void 0;
            this._$template = template;
            this._$parent = parent;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _clone(options) {
            var _a2;
            const {
                el: { content },
                parts,
            } = this._$template;
            const fragment = (
                (_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null &&
                _a2 !== void 0
                    ? _a2
                    : d$1
            ).importNode(content, true);
            walker$1.currentNode = fragment;
            let node = walker$1.nextNode();
            let nodeIndex = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            while (templatePart !== void 0) {
                if (nodeIndex === templatePart.index) {
                    let part;
                    if (templatePart.type === CHILD_PART$1) {
                        part = new ChildPart$1(node, node.nextSibling, this, options);
                    } else if (templatePart.type === ATTRIBUTE_PART$1) {
                        part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
                    } else if (templatePart.type === ELEMENT_PART$1) {
                        part = new ElementPart$1(node, this, options);
                    }
                    this._parts.push(part);
                    templatePart = parts[++partIndex];
                }
                if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
                    node = walker$1.nextNode();
                    nodeIndex++;
                }
            }
            return fragment;
        }
        _update(values) {
            let i = 0;
            for (const part of this._parts) {
                if (part !== void 0) {
                    if (part.strings !== void 0) {
                        part._$setValue(values, part, i);
                        i += part.strings.length - 2;
                    } else {
                        part._$setValue(values[i]);
                    }
                }
                i++;
            }
        }
    }
    class ChildPart$1 {
        constructor(startNode, endNode, parent, options) {
            this.type = CHILD_PART$1;
            this.__isConnected = true;
            this._$disconnectableChildren = void 0;
            this._$startNode = startNode;
            this._$endNode = endNode;
            this._$parent = parent;
            this.options = options;
            {
                this._textSanitizer = void 0;
            }
        }
        get _$isConnected() {
            var _a2, _b2;
            return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null &&
                _b2 !== void 0
                ? _b2
                : this.__isConnected;
        }
        get parentNode() {
            return wrap$1(this._$startNode).parentNode;
        }
        get startNode() {
            return this._$startNode;
        }
        get endNode() {
            return this._$endNode;
        }
        _$setValue(value, directiveParent = this) {
            value = resolveDirective$1(this, value, directiveParent);
            if (isPrimitive$2(value)) {
                if (value === nothing$2 || value == null || value === '') {
                    if (this._$committedValue !== nothing$2) {
                        this._$clear();
                    }
                    this._$committedValue = nothing$2;
                } else if (value !== this._$committedValue && value !== noChange$2) {
                    this._commitText(value);
                }
            } else if (value['_$litType$'] !== void 0) {
                this._commitTemplateResult(value);
            } else if (value.nodeType !== void 0) {
                this._commitNode(value);
            } else if (isIterable$2(value)) {
                this._commitIterable(value);
            } else {
                this._commitText(value);
            }
        }
        _insert(node, ref = this._$endNode) {
            return wrap$1(wrap$1(this._$startNode).parentNode).insertBefore(node, ref);
        }
        _commitNode(value) {
            var _a2;
            if (this._$committedValue !== value) {
                this._$clear();
                if (sanitizerFactoryInternal$1 !== noopSanitizer$1) {
                    const parentNodeName =
                        (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
                    if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {
                        this._insert(new Text('/* lit-html will not write TemplateResults to scripts and styles */'));
                        return;
                    }
                }
                this._$committedValue = this._insert(value);
            }
        }
        _commitText(value) {
            const node = wrap$1(this._$startNode).nextSibling;
            if (
                node !== null &&
                node.nodeType === 3 &&
                (this._$endNode === null
                    ? wrap$1(node).nextSibling === null
                    : node === wrap$1(this._$endNode).previousSibling)
            ) {
                {
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer$1();
                    }
                    value = this._textSanitizer(value);
                }
                node.data = value;
            } else {
                {
                    const textNode = document.createTextNode('');
                    this._commitNode(textNode);
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer$1();
                    }
                    value = this._textSanitizer(value);
                    textNode.data = value;
                }
            }
            this._$committedValue = value;
        }
        _commitTemplateResult(result) {
            var _a2;
            const { values, ['_$litType$']: type } = result;
            const template =
                typeof type === 'number'
                    ? this._$getTemplate(result)
                    : (type.el === void 0 && (type.el = Template$2.createElement(type.h, this.options)), type);
            if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template) {
                this._$committedValue._update(values);
            } else {
                const instance = new TemplateInstance$2(template, this);
                const fragment = instance._clone(this.options);
                instance._update(values);
                this._commitNode(fragment);
                this._$committedValue = instance;
            }
        }
        _$getTemplate(result) {
            let template = templateCache$1.get(result.strings);
            if (template === void 0) {
                templateCache$1.set(result.strings, (template = new Template$2(result)));
            }
            return template;
        }
        _commitIterable(value) {
            if (!isArray$2(this._$committedValue)) {
                this._$committedValue = [];
                this._$clear();
            }
            const itemParts = this._$committedValue;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                if (partIndex === itemParts.length) {
                    itemParts.push(
                        (itemPart = new ChildPart$1(
                            this._insert(createMarker$2()),
                            this._insert(createMarker$2()),
                            this,
                            this.options,
                        )),
                    );
                } else {
                    itemPart = itemParts[partIndex];
                }
                itemPart._$setValue(item);
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                this._$clear(itemPart && wrap$1(itemPart._$endNode).nextSibling, partIndex);
                itemParts.length = partIndex;
            }
        }
        _$clear(start = wrap$1(this._$startNode).nextSibling, from) {
            var _a2;
            (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0
                ? void 0
                : _a2.call(this, false, true, from);
            while (start && start !== this._$endNode) {
                const n = wrap$1(start).nextSibling;
                wrap$1(start).remove();
                start = n;
            }
        }
        setConnected(isConnected) {
            var _a2;
            if (this._$parent === void 0) {
                this.__isConnected = isConnected;
                (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0
                    ? void 0
                    : _a2.call(this, isConnected);
            } else {
                throw new Error('part.setConnected() may only be called on a RootPart returned from render().');
            }
        }
    }
    class AttributePart$2 {
        constructor(element, name2, strings, parent, options) {
            this.type = ATTRIBUTE_PART$1;
            this._$committedValue = nothing$2;
            this._$disconnectableChildren = void 0;
            this.element = element;
            this.name = name2;
            this._$parent = parent;
            this.options = options;
            if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
                this._$committedValue = new Array(strings.length - 1).fill(nothing$2);
                this.strings = strings;
            } else {
                this._$committedValue = nothing$2;
            }
            {
                this._sanitizer = void 0;
            }
        }
        get tagName() {
            return this.element.tagName;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value, directiveParent = this, valueIndex, noCommit) {
            const strings = this.strings;
            let change = false;
            if (strings === void 0) {
                value = resolveDirective$1(this, value, directiveParent, 0);
                change = !isPrimitive$2(value) || (value !== this._$committedValue && value !== noChange$2);
                if (change) {
                    this._$committedValue = value;
                }
            } else {
                const values = value;
                value = strings[0];
                let i, v;
                for (i = 0; i < strings.length - 1; i++) {
                    v = resolveDirective$1(this, values[valueIndex + i], directiveParent, i);
                    if (v === noChange$2) {
                        v = this._$committedValue[i];
                    }
                    change || (change = !isPrimitive$2(v) || v !== this._$committedValue[i]);
                    if (v === nothing$2) {
                        value = nothing$2;
                    } else if (value !== nothing$2) {
                        value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
                    }
                    this._$committedValue[i] = v;
                }
            }
            if (change && !noCommit) {
                this._commitValue(value);
            }
        }
        _commitValue(value) {
            if (value === nothing$2) {
                wrap$1(this.element).removeAttribute(this.name);
            } else {
                {
                    if (this._sanitizer === void 0) {
                        this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
                    }
                    value = this._sanitizer(value !== null && value !== void 0 ? value : '');
                }
                wrap$1(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : '');
            }
        }
    }
    class PropertyPart$2 extends AttributePart$2 {
        constructor() {
            super(...arguments);
            this.type = PROPERTY_PART$1;
        }
        _commitValue(value) {
            {
                if (this._sanitizer === void 0) {
                    this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
                }
                value = this._sanitizer(value);
            }
            this.element[this.name] = value === nothing$2 ? void 0 : value;
        }
    }
    class BooleanAttributePart$2 extends AttributePart$2 {
        constructor() {
            super(...arguments);
            this.type = BOOLEAN_ATTRIBUTE_PART$1;
        }
        _commitValue(value) {
            if (value && value !== nothing$2) {
                wrap$1(this.element).setAttribute(this.name, '');
            } else {
                wrap$1(this.element).removeAttribute(this.name);
            }
        }
    }
    class EventPart$2 extends AttributePart$2 {
        constructor() {
            super(...arguments);
            this.type = EVENT_PART$1;
        }
        _$setValue(newListener, directiveParent = this) {
            var _a2;
            newListener =
                (_a2 = resolveDirective$1(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0
                    ? _a2
                    : nothing$2;
            if (newListener === noChange$2) {
                return;
            }
            const oldListener = this._$committedValue;
            const shouldRemoveListener =
                (newListener === nothing$2 && oldListener !== nothing$2) ||
                newListener.capture !== oldListener.capture ||
                newListener.once !== oldListener.once ||
                newListener.passive !== oldListener.passive;
            const shouldAddListener = newListener !== nothing$2 && (oldListener === nothing$2 || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.name, this, oldListener);
            }
            if (shouldAddListener) {
                this.element.addEventListener(this.name, this, newListener);
            }
            this._$committedValue = newListener;
        }
        handleEvent(event2) {
            var _a2, _b2;
            if (typeof this._$committedValue === 'function') {
                this._$committedValue.call(
                    (_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null &&
                        _b2 !== void 0
                        ? _b2
                        : this.element,
                    event2,
                );
            } else {
                this._$committedValue.handleEvent(event2);
            }
        }
    }
    class ElementPart$1 {
        constructor(element, parent, options) {
            this.element = element;
            this.type = ELEMENT_PART$1;
            this._$disconnectableChildren = void 0;
            this._$parent = parent;
            this.options = options;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value) {
            resolveDirective$1(this, value);
        }
    }
    (_d$1 = (_c$2 = globalThis)['litHtmlPlatformSupport']) === null || _d$1 === void 0
        ? void 0
        : _d$1.call(_c$2, Template$2, ChildPart$1);
    ((_e$1 = (_f$1 = globalThis)['litHtmlVersions']) !== null && _e$1 !== void 0
        ? _e$1
        : (_f$1['litHtmlVersions'] = [])
    ).push('2.0.0-rc.4');
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const stringsCache$1 = new Map();
    const withStatic$1 =
        (coreTag) =>
        (strings, ...values) => {
            var _a2;
            const l = values.length;
            let staticValue;
            let dynamicValue;
            const staticStrings = [];
            const dynamicValues = [];
            let i = 0;
            let hasStatics = false;
            let s;
            while (i < l) {
                s = strings[i];
                while (
                    i < l &&
                    ((dynamicValue = values[i]),
                    (staticValue = (_a2 = dynamicValue) === null || _a2 === void 0 ? void 0 : _a2['_$litStatic$'])) !==
                        void 0
                ) {
                    s += staticValue + strings[++i];
                    hasStatics = true;
                }
                dynamicValues.push(dynamicValue);
                staticStrings.push(s);
                i++;
            }
            if (i === l) {
                staticStrings.push(strings[l]);
            }
            if (hasStatics) {
                const key = staticStrings.join('$$lit$$');
                strings = stringsCache$1.get(key);
                if (strings === void 0) {
                    stringsCache$1.set(key, (strings = staticStrings));
                }
                values = dynamicValues;
            }
            return coreTag(strings, ...values);
        };
    const html$3 = withStatic$1(html$1$1);
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$5 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$5 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$5(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$5(options, protoOrDescriptor, name2)
                : standardProperty$5(options, protoOrDescriptor);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const decorateProperty$2 =
        ({ finisher, descriptor }) =>
        (protoOrDescriptor, name2) => {
            var _a2;
            if (name2 !== void 0) {
                const ctor = protoOrDescriptor.constructor;
                if (descriptor !== void 0) {
                    Object.defineProperty(protoOrDescriptor, name2, descriptor(name2));
                }
                finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
            } else {
                const key =
                    (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
                const info =
                    descriptor != void 0
                        ? {
                              kind: 'method',
                              placement: 'prototype',
                              key,
                              descriptor: descriptor(protoOrDescriptor.key),
                          }
                        : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
                if (finisher != void 0) {
                    info.finisher = function (ctor) {
                        finisher(ctor, key);
                    };
                }
                return info;
            }
        };
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    function query$1(selector, cache) {
        return decorateProperty$2({
            descriptor: (name2) => {
                const descriptor = {
                    get() {
                        var _a2;
                        return (_a2 = this.renderRoot) === null || _a2 === void 0
                            ? void 0
                            : _a2.querySelector(selector);
                    },
                    enumerable: true,
                    configurable: true,
                };
                if (cache) {
                    const key = typeof name2 === 'symbol' ? Symbol() : `__${name2}`;
                    descriptor.get = function () {
                        var _a2;
                        if (this[key] === void 0) {
                            this[key] =
                                (_a2 = this.renderRoot) === null || _a2 === void 0
                                    ? void 0
                                    : _a2.querySelector(selector);
                        }
                        return this[key];
                    };
                }
                return descriptor;
            },
        });
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const ElementProto = Element.prototype;
    const legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
    function queryAssignedNodes(slotName = '', flatten = false, selector = '') {
        return decorateProperty$2({
            descriptor: (_name) => ({
                get() {
                    var _a2, _b2;
                    const slotSelector = `slot${slotName ? `[name=${slotName}]` : ':not([name])'}`;
                    const slot =
                        (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(slotSelector);
                    let nodes = (_b2 = slot) === null || _b2 === void 0 ? void 0 : _b2.assignedNodes({ flatten });
                    if (nodes && selector) {
                        nodes = nodes.filter(
                            (node) =>
                                node.nodeType === Node.ELEMENT_NODE &&
                                (node.matches ? node.matches(selector) : legacyMatches.call(node, selector)),
                        );
                    }
                    return nodes;
                },
                enumerable: true,
                configurable: true,
            }),
        });
    }
    var deepFreezeEs6 = { exports: {} };
    function deepFreeze(obj) {
        if (obj instanceof Map) {
            obj.clear =
                obj.delete =
                obj.set =
                    function () {
                        throw new Error('map is read-only');
                    };
        } else if (obj instanceof Set) {
            obj.add =
                obj.clear =
                obj.delete =
                    function () {
                        throw new Error('set is read-only');
                    };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach(function (name2) {
            var prop = obj[name2];
            if (typeof prop == 'object' && !Object.isFrozen(prop)) {
                deepFreeze(prop);
            }
        });
        return obj;
    }
    deepFreezeEs6.exports = deepFreeze;
    deepFreezeEs6.exports.default = deepFreeze;
    var deepFreeze$1 = deepFreezeEs6.exports;
    class Response {
        constructor(mode) {
            if (mode.data === void 0) mode.data = {};
            this.data = mode.data;
            this.isMatchIgnored = false;
        }
        ignoreMatch() {
            this.isMatchIgnored = true;
        }
    }
    function escapeHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    function inherit$1(original, ...objects) {
        const result = Object.create(null);
        for (const key in original) {
            result[key] = original[key];
        }
        objects.forEach(function (obj) {
            for (const key in obj) {
                result[key] = obj[key];
            }
        });
        return result;
    }
    const SPAN_CLOSE = '</span>';
    const emitsWrappingTags = (node) => {
        return !!node.kind;
    };
    const expandScopeName = (name2, { prefix }) => {
        if (name2.includes('.')) {
            const pieces = name2.split('.');
            return [`${prefix}${pieces.shift()}`, ...pieces.map((x, i) => `${x}${'_'.repeat(i + 1)}`)].join(' ');
        }
        return `${prefix}${name2}`;
    };
    class HTMLRenderer {
        constructor(parseTree, options) {
            this.buffer = '';
            this.classPrefix = options.classPrefix;
            parseTree.walk(this);
        }
        addText(text) {
            this.buffer += escapeHTML(text);
        }
        openNode(node) {
            if (!emitsWrappingTags(node)) return;
            let scope = node.kind;
            if (node.sublanguage) {
                scope = `language-${scope}`;
            } else {
                scope = expandScopeName(scope, { prefix: this.classPrefix });
            }
            this.span(scope);
        }
        closeNode(node) {
            if (!emitsWrappingTags(node)) return;
            this.buffer += SPAN_CLOSE;
        }
        value() {
            return this.buffer;
        }
        span(className) {
            this.buffer += `<span class="${className}">`;
        }
    }
    class TokenTree {
        constructor() {
            this.rootNode = { children: [] };
            this.stack = [this.rootNode];
        }
        get top() {
            return this.stack[this.stack.length - 1];
        }
        get root() {
            return this.rootNode;
        }
        add(node) {
            this.top.children.push(node);
        }
        openNode(kind) {
            const node = { kind, children: [] };
            this.add(node);
            this.stack.push(node);
        }
        closeNode() {
            if (this.stack.length > 1) {
                return this.stack.pop();
            }
            return void 0;
        }
        closeAllNodes() {
            while (this.closeNode());
        }
        toJSON() {
            return JSON.stringify(this.rootNode, null, 4);
        }
        walk(builder) {
            return this.constructor._walk(builder, this.rootNode);
        }
        static _walk(builder, node) {
            if (typeof node === 'string') {
                builder.addText(node);
            } else if (node.children) {
                builder.openNode(node);
                node.children.forEach((child) => this._walk(builder, child));
                builder.closeNode(node);
            }
            return builder;
        }
        static _collapse(node) {
            if (typeof node === 'string') return;
            if (!node.children) return;
            if (node.children.every((el) => typeof el === 'string')) {
                node.children = [node.children.join('')];
            } else {
                node.children.forEach((child) => {
                    TokenTree._collapse(child);
                });
            }
        }
    }
    class TokenTreeEmitter extends TokenTree {
        constructor(options) {
            super();
            this.options = options;
        }
        addKeyword(text, kind) {
            if (text === '') {
                return;
            }
            this.openNode(kind);
            this.addText(text);
            this.closeNode();
        }
        addText(text) {
            if (text === '') {
                return;
            }
            this.add(text);
        }
        addSublanguage(emitter, name2) {
            const node = emitter.root;
            node.kind = name2;
            node.sublanguage = true;
            this.add(node);
        }
        toHTML() {
            const renderer = new HTMLRenderer(this, this.options);
            return renderer.value();
        }
        finalize() {
            return true;
        }
    }
    function source$4(re) {
        if (!re) return null;
        if (typeof re === 'string') return re;
        return re.source;
    }
    function lookahead$3(re) {
        return concat$4('(?=', re, ')');
    }
    function concat$4(...args) {
        const joined = args.map((x) => source$4(x)).join('');
        return joined;
    }
    function stripOptionsFromArgs$1(args) {
        const opts = args[args.length - 1];
        if (typeof opts === 'object' && opts.constructor === Object) {
            args.splice(args.length - 1, 1);
            return opts;
        } else {
            return {};
        }
    }
    function either$1(...args) {
        const opts = stripOptionsFromArgs$1(args);
        const joined = '(' + (opts.capture ? '' : '?:') + args.map((x) => source$4(x)).join('|') + ')';
        return joined;
    }
    function countMatchGroups(re) {
        return new RegExp(re.toString() + '|').exec('').length - 1;
    }
    function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
    }
    const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences(regexps, { joinWith }) {
        let numCaptures = 0;
        return regexps
            .map((regex) => {
                numCaptures += 1;
                const offset = numCaptures;
                let re = source$4(regex);
                let out = '';
                while (re.length > 0) {
                    const match = BACKREF_RE.exec(re);
                    if (!match) {
                        out += re;
                        break;
                    }
                    out += re.substring(0, match.index);
                    re = re.substring(match.index + match[0].length);
                    if (match[0][0] === '\\' && match[1]) {
                        out += '\\' + String(Number(match[1]) + offset);
                    } else {
                        out += match[0];
                        if (match[0] === '(') {
                            numCaptures++;
                        }
                    }
                }
                return out;
            })
            .map((re) => `(${re})`)
            .join(joinWith);
    }
    const MATCH_NOTHING_RE = /\b\B/;
    const IDENT_RE$1 = '[a-zA-Z]\\w*';
    const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
    const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
    const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)';
    const BINARY_NUMBER_RE = '\\b(0b[01]+)';
    const RE_STARTERS_RE =
        '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
    const SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
            opts.begin = concat$4(beginShebang, /.*\b/, opts.binary, /\b.*/);
        }
        return inherit$1(
            {
                scope: 'meta',
                begin: beginShebang,
                end: /$/,
                relevance: 0,
                'on:begin': (m, resp) => {
                    if (m.index !== 0) resp.ignoreMatch();
                },
            },
            opts,
        );
    };
    const BACKSLASH_ESCAPE = {
        begin: '\\\\[\\s\\S]',
        relevance: 0,
    };
    const APOS_STRING_MODE = {
        scope: 'string',
        begin: "'",
        end: "'",
        illegal: '\\n',
        contains: [BACKSLASH_ESCAPE],
    };
    const QUOTE_STRING_MODE = {
        scope: 'string',
        begin: '"',
        end: '"',
        illegal: '\\n',
        contains: [BACKSLASH_ESCAPE],
    };
    const PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
    };
    const COMMENT = function (begin, end, modeOptions = {}) {
        const mode = inherit$1(
            {
                scope: 'comment',
                begin,
                end,
                contains: [],
            },
            modeOptions,
        );
        mode.contains.push({
            scope: 'doctag',
            begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
            end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
            excludeBegin: true,
            relevance: 0,
        });
        const ENGLISH_WORD = either$1(
            'I',
            'a',
            'is',
            'so',
            'us',
            'to',
            'at',
            'if',
            'in',
            'it',
            'on',
            /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
            /[A-Za-z]+[-][a-z]+/,
            /[A-Za-z][a-z]{2,}/,
        );
        mode.contains.push({
            begin: concat$4(/[ ]+/, '(', ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, '){3}'),
        });
        return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT('//', '$');
    const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
    const HASH_COMMENT_MODE = COMMENT('#', '$');
    const NUMBER_MODE = {
        scope: 'number',
        begin: NUMBER_RE,
        relevance: 0,
    };
    const C_NUMBER_MODE = {
        scope: 'number',
        begin: C_NUMBER_RE,
        relevance: 0,
    };
    const BINARY_NUMBER_MODE = {
        scope: 'number',
        begin: BINARY_NUMBER_RE,
        relevance: 0,
    };
    const REGEXP_MODE = {
        begin: /(?=\/[^/\n]*\/)/,
        contains: [
            {
                scope: 'regexp',
                begin: /\//,
                end: /\/[gimuy]*/,
                illegal: /\n/,
                contains: [
                    BACKSLASH_ESCAPE,
                    {
                        begin: /\[/,
                        end: /\]/,
                        relevance: 0,
                        contains: [BACKSLASH_ESCAPE],
                    },
                ],
            },
        ],
    };
    const TITLE_MODE = {
        scope: 'title',
        begin: IDENT_RE$1,
        relevance: 0,
    };
    const UNDERSCORE_TITLE_MODE = {
        scope: 'title',
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0,
    };
    const METHOD_GUARD = {
        begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
        relevance: 0,
    };
    const END_SAME_AS_BEGIN = function (mode) {
        return Object.assign(mode, {
            'on:begin': (m, resp) => {
                resp.data._beginMatch = m[1];
            },
            'on:end': (m, resp) => {
                if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
            },
        });
    };
    var MODES$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE,
        IDENT_RE: IDENT_RE$1,
        UNDERSCORE_IDENT_RE,
        NUMBER_RE,
        C_NUMBER_RE,
        BINARY_NUMBER_RE,
        RE_STARTERS_RE,
        SHEBANG,
        BACKSLASH_ESCAPE,
        APOS_STRING_MODE,
        QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE,
        COMMENT,
        C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE,
        NUMBER_MODE,
        C_NUMBER_MODE,
        BINARY_NUMBER_MODE,
        REGEXP_MODE,
        TITLE_MODE,
        UNDERSCORE_TITLE_MODE,
        METHOD_GUARD,
        END_SAME_AS_BEGIN,
    });
    function skipIfHasPrecedingDot(match, response) {
        const before = match.input[match.index - 1];
        if (before === '.') {
            response.ignoreMatch();
        }
    }
    function scopeClassName(mode, _parent) {
        if (mode.className !== void 0) {
            mode.scope = mode.className;
            delete mode.className;
        }
    }
    function beginKeywords(mode, parent) {
        if (!parent) return;
        if (!mode.beginKeywords) return;
        mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
        mode.__beforeBegin = skipIfHasPrecedingDot;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0) mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
        if (!Array.isArray(mode.illegal)) return;
        mode.illegal = either$1(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
        if (!mode.match) return;
        if (mode.begin || mode.end) throw new Error('begin & end are not supported with match');
        mode.begin = mode.match;
        delete mode.match;
    }
    function compileRelevance(mode, _parent) {
        if (mode.relevance === void 0) mode.relevance = 1;
    }
    const beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch) return;
        if (mode.starts) throw new Error('beforeMatch cannot be used with starts');
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
            delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat$4(originalMode.beforeMatch, lookahead$3(originalMode.begin));
        mode.starts = {
            relevance: 0,
            contains: [Object.assign(originalMode, { endsParent: true })],
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
    };
    const COMMON_KEYWORDS = ['of', 'and', 'for', 'in', 'not', 'or', 'if', 'then', 'parent', 'list', 'value'];
    const DEFAULT_KEYWORD_SCOPE = 'keyword';
    function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
        const compiledKeywords = Object.create(null);
        if (typeof rawKeywords === 'string') {
            compileList(scopeName, rawKeywords.split(' '));
        } else if (Array.isArray(rawKeywords)) {
            compileList(scopeName, rawKeywords);
        } else {
            Object.keys(rawKeywords).forEach(function (scopeName2) {
                Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
            });
        }
        return compiledKeywords;
        function compileList(scopeName2, keywordList) {
            if (caseInsensitive) {
                keywordList = keywordList.map((x) => x.toLowerCase());
            }
            keywordList.forEach(function (keyword) {
                const pair = keyword.split('|');
                compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
            });
        }
    }
    function scoreForKeyword(keyword, providedScore) {
        if (providedScore) {
            return Number(providedScore);
        }
        return commonKeyword(keyword) ? 0 : 1;
    }
    function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }
    const seenDeprecations = {};
    const error = (message) => {
        console.error(message);
    };
    const warn$1 = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
    };
    const deprecated = (version2, message) => {
        if (seenDeprecations[`${version2}/${message}`]) return;
        console.log(`Deprecated as of ${version2}. ${message}`);
        seenDeprecations[`${version2}/${message}`] = true;
    };
    const MultiClassError = new Error();
    function remapScopeNames(mode, regexes, { key }) {
        let offset = 0;
        const scopeNames = mode[key];
        const emit = {};
        const positions = {};
        for (let i = 1; i <= regexes.length; i++) {
            positions[i + offset] = scopeNames[i];
            emit[i + offset] = true;
            offset += countMatchGroups(regexes[i - 1]);
        }
        mode[key] = positions;
        mode[key]._emit = emit;
        mode[key]._multi = true;
    }
    function beginMultiClass(mode) {
        if (!Array.isArray(mode.begin)) return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
            error('skip, excludeBegin, returnBegin not compatible with beginScope: {}');
            throw MultiClassError;
        }
        if (typeof mode.beginScope !== 'object' || mode.beginScope === null) {
            error('beginScope must be object');
            throw MultiClassError;
        }
        remapScopeNames(mode, mode.begin, { key: 'beginScope' });
        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: '' });
    }
    function endMultiClass(mode) {
        if (!Array.isArray(mode.end)) return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
            error('skip, excludeEnd, returnEnd not compatible with endScope: {}');
            throw MultiClassError;
        }
        if (typeof mode.endScope !== 'object' || mode.endScope === null) {
            error('endScope must be object');
            throw MultiClassError;
        }
        remapScopeNames(mode, mode.end, { key: 'endScope' });
        mode.end = _rewriteBackreferences(mode.end, { joinWith: '' });
    }
    function scopeSugar(mode) {
        if (mode.scope && typeof mode.scope === 'object' && mode.scope !== null) {
            mode.beginScope = mode.scope;
            delete mode.scope;
        }
    }
    function MultiClass(mode) {
        scopeSugar(mode);
        if (typeof mode.beginScope === 'string') {
            mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === 'string') {
            mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass(mode);
        endMultiClass(mode);
    }
    function compileLanguage(language) {
        function langRe(value, global2) {
            return new RegExp(source$4(value), 'm' + (language.case_insensitive ? 'i' : '') + (global2 ? 'g' : ''));
        }
        class MultiRegex {
            constructor() {
                this.matchIndexes = {};
                this.regexes = [];
                this.matchAt = 1;
                this.position = 0;
            }
            addRule(re, opts) {
                opts.position = this.position++;
                this.matchIndexes[this.matchAt] = opts;
                this.regexes.push([opts, re]);
                this.matchAt += countMatchGroups(re) + 1;
            }
            compile() {
                if (this.regexes.length === 0) {
                    this.exec = () => null;
                }
                const terminators = this.regexes.map((el) => el[1]);
                this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);
                this.lastIndex = 0;
            }
            exec(s) {
                this.matcherRe.lastIndex = this.lastIndex;
                const match = this.matcherRe.exec(s);
                if (!match) {
                    return null;
                }
                const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
                const matchData = this.matchIndexes[i];
                match.splice(0, i);
                return Object.assign(match, matchData);
            }
        }
        class ResumableMultiRegex {
            constructor() {
                this.rules = [];
                this.multiRegexes = [];
                this.count = 0;
                this.lastIndex = 0;
                this.regexIndex = 0;
            }
            getMatcher(index) {
                if (this.multiRegexes[index]) return this.multiRegexes[index];
                const matcher = new MultiRegex();
                this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
                matcher.compile();
                this.multiRegexes[index] = matcher;
                return matcher;
            }
            resumingScanAtSamePosition() {
                return this.regexIndex !== 0;
            }
            considerAll() {
                this.regexIndex = 0;
            }
            addRule(re, opts) {
                this.rules.push([re, opts]);
                if (opts.type === 'begin') this.count++;
            }
            exec(s) {
                const m = this.getMatcher(this.regexIndex);
                m.lastIndex = this.lastIndex;
                let result = m.exec(s);
                if (this.resumingScanAtSamePosition()) {
                    if (result && result.index === this.lastIndex);
                    else {
                        const m2 = this.getMatcher(0);
                        m2.lastIndex = this.lastIndex + 1;
                        result = m2.exec(s);
                    }
                }
                if (result) {
                    this.regexIndex += result.position + 1;
                    if (this.regexIndex === this.count) {
                        this.considerAll();
                    }
                }
                return result;
            }
        }
        function buildModeRegex(mode) {
            const mm = new ResumableMultiRegex();
            mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: 'begin' }));
            if (mode.terminatorEnd) {
                mm.addRule(mode.terminatorEnd, { type: 'end' });
            }
            if (mode.illegal) {
                mm.addRule(mode.illegal, { type: 'illegal' });
            }
            return mm;
        }
        function compileMode(mode, parent) {
            const cmode = mode;
            if (mode.isCompiled) return cmode;
            [scopeClassName, compileMatch, MultiClass, beforeMatchExt].forEach((ext) => ext(mode, parent));
            language.compilerExtensions.forEach((ext) => ext(mode, parent));
            mode.__beforeBegin = null;
            [beginKeywords, compileIllegal, compileRelevance].forEach((ext) => ext(mode, parent));
            mode.isCompiled = true;
            let keywordPattern = null;
            if (typeof mode.keywords === 'object' && mode.keywords.$pattern) {
                mode.keywords = Object.assign({}, mode.keywords);
                keywordPattern = mode.keywords.$pattern;
                delete mode.keywords.$pattern;
            }
            keywordPattern = keywordPattern || /\w+/;
            if (mode.keywords) {
                mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
            }
            cmode.keywordPatternRe = langRe(keywordPattern, true);
            if (parent) {
                if (!mode.begin) mode.begin = /\B|\b/;
                cmode.beginRe = langRe(mode.begin);
                if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
                if (mode.end) cmode.endRe = langRe(mode.end);
                cmode.terminatorEnd = source$4(mode.end) || '';
                if (mode.endsWithParent && parent.terminatorEnd) {
                    cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
                }
            }
            if (mode.illegal) cmode.illegalRe = langRe(mode.illegal);
            if (!mode.contains) mode.contains = [];
            mode.contains = [].concat(
                ...mode.contains.map(function (c) {
                    return expandOrCloneMode(c === 'self' ? mode : c);
                }),
            );
            mode.contains.forEach(function (c) {
                compileMode(c, cmode);
            });
            if (mode.starts) {
                compileMode(mode.starts, parent);
            }
            cmode.matcher = buildModeRegex(cmode);
            return cmode;
        }
        if (!language.compilerExtensions) language.compilerExtensions = [];
        if (language.contains && language.contains.includes('self')) {
            throw new Error(
                'ERR: contains `self` is not supported at the top-level of a language.  See documentation.',
            );
        }
        language.classNameAliases = inherit$1(language.classNameAliases || {});
        return compileMode(language);
    }
    function dependencyOnParent(mode) {
        if (!mode) return false;
        return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cachedVariants) {
            mode.cachedVariants = mode.variants.map(function (variant) {
                return inherit$1(mode, { variants: null }, variant);
            });
        }
        if (mode.cachedVariants) {
            return mode.cachedVariants;
        }
        if (dependencyOnParent(mode)) {
            return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
            return inherit$1(mode);
        }
        return mode;
    }
    var version$1 = '11.1.0';
    const escape$2 = escapeHTML;
    const inherit = inherit$1;
    const NO_MATCH = Symbol('nomatch');
    const MAX_KEYWORD_HITS = 7;
    const HLJS = function (hljs) {
        const languages = Object.create(null);
        const aliases = Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND =
            "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };
        let options = {
            ignoreUnescapedHTML: false,
            noHighlightRe: /^(no-?highlight)$/i,
            languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
            classPrefix: 'hljs-',
            cssSelector: 'pre code',
            languages: null,
            __emitter: TokenTreeEmitter,
        };
        function shouldNotHighlight(languageName) {
            return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
            let classes = block.className + ' ';
            classes += block.parentNode ? block.parentNode.className : '';
            const match = options.languageDetectRe.exec(classes);
            if (match) {
                const language = getLanguage(match[1]);
                if (!language) {
                    warn$1(LANGUAGE_NOT_FOUND.replace('{}', match[1]));
                    warn$1('Falling back to no-highlight mode for this block.', block);
                }
                return language ? match[1] : 'no-highlight';
            }
            return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
            let code = '';
            let languageName = '';
            if (typeof optionsOrCode === 'object') {
                code = codeOrLanguageName;
                ignoreIllegals = optionsOrCode.ignoreIllegals;
                languageName = optionsOrCode.language;
            } else {
                deprecated('10.7.0', 'highlight(lang, code, ...args) has been deprecated.');
                deprecated(
                    '10.7.0',
                    'Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277',
                );
                languageName = codeOrLanguageName;
                code = optionsOrCode;
            }
            if (ignoreIllegals === void 0) {
                ignoreIllegals = true;
            }
            const context = {
                code,
                language: languageName,
            };
            fire('before:highlight', context);
            const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
            result.code = context.code;
            fire('after:highlight', result);
            return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
            const keywordHits = Object.create(null);
            function keywordData(mode, matchText) {
                return mode.keywords[matchText];
            }
            function processKeywords() {
                if (!top.keywords) {
                    emitter.addText(modeBuffer);
                    return;
                }
                let lastIndex = 0;
                top.keywordPatternRe.lastIndex = 0;
                let match = top.keywordPatternRe.exec(modeBuffer);
                let buf = '';
                while (match) {
                    buf += modeBuffer.substring(lastIndex, match.index);
                    const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
                    const data = keywordData(top, word);
                    if (data) {
                        const [kind, keywordRelevance] = data;
                        emitter.addText(buf);
                        buf = '';
                        keywordHits[word] = (keywordHits[word] || 0) + 1;
                        if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;
                        if (kind.startsWith('_')) {
                            buf += match[0];
                        } else {
                            const cssClass = language.classNameAliases[kind] || kind;
                            emitter.addKeyword(match[0], cssClass);
                        }
                    } else {
                        buf += match[0];
                    }
                    lastIndex = top.keywordPatternRe.lastIndex;
                    match = top.keywordPatternRe.exec(modeBuffer);
                }
                buf += modeBuffer.substr(lastIndex);
                emitter.addText(buf);
            }
            function processSubLanguage() {
                if (modeBuffer === '') return;
                let result2 = null;
                if (typeof top.subLanguage === 'string') {
                    if (!languages[top.subLanguage]) {
                        emitter.addText(modeBuffer);
                        return;
                    }
                    result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
                    continuations[top.subLanguage] = result2._top;
                } else {
                    result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
                }
                if (top.relevance > 0) {
                    relevance += result2.relevance;
                }
                emitter.addSublanguage(result2._emitter, result2.language);
            }
            function processBuffer() {
                if (top.subLanguage != null) {
                    processSubLanguage();
                } else {
                    processKeywords();
                }
                modeBuffer = '';
            }
            function emitMultiClass(scope, match) {
                let i = 1;
                while (match[i] !== void 0) {
                    if (!scope._emit[i]) {
                        i++;
                        continue;
                    }
                    const klass = language.classNameAliases[scope[i]] || scope[i];
                    const text = match[i];
                    if (klass) {
                        emitter.addKeyword(text, klass);
                    } else {
                        modeBuffer = text;
                        processKeywords();
                        modeBuffer = '';
                    }
                    i++;
                }
            }
            function startNewMode(mode, match) {
                if (mode.scope && typeof mode.scope === 'string') {
                    emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
                }
                if (mode.beginScope) {
                    if (mode.beginScope._wrap) {
                        emitter.addKeyword(
                            modeBuffer,
                            language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap,
                        );
                        modeBuffer = '';
                    } else if (mode.beginScope._multi) {
                        emitMultiClass(mode.beginScope, match);
                        modeBuffer = '';
                    }
                }
                top = Object.create(mode, { parent: { value: top } });
                return top;
            }
            function endOfMode(mode, match, matchPlusRemainder) {
                let matched = startsWith(mode.endRe, matchPlusRemainder);
                if (matched) {
                    if (mode['on:end']) {
                        const resp = new Response(mode);
                        mode['on:end'](match, resp);
                        if (resp.isMatchIgnored) matched = false;
                    }
                    if (matched) {
                        while (mode.endsParent && mode.parent) {
                            mode = mode.parent;
                        }
                        return mode;
                    }
                }
                if (mode.endsWithParent) {
                    return endOfMode(mode.parent, match, matchPlusRemainder);
                }
            }
            function doIgnore(lexeme) {
                if (top.matcher.regexIndex === 0) {
                    modeBuffer += lexeme[0];
                    return 1;
                } else {
                    resumeScanAtSamePosition = true;
                    return 0;
                }
            }
            function doBeginMatch(match) {
                const lexeme = match[0];
                const newMode = match.rule;
                const resp = new Response(newMode);
                const beforeCallbacks = [newMode.__beforeBegin, newMode['on:begin']];
                for (const cb of beforeCallbacks) {
                    if (!cb) continue;
                    cb(match, resp);
                    if (resp.isMatchIgnored) return doIgnore(lexeme);
                }
                if (newMode.skip) {
                    modeBuffer += lexeme;
                } else {
                    if (newMode.excludeBegin) {
                        modeBuffer += lexeme;
                    }
                    processBuffer();
                    if (!newMode.returnBegin && !newMode.excludeBegin) {
                        modeBuffer = lexeme;
                    }
                }
                startNewMode(newMode, match);
                return newMode.returnBegin ? 0 : lexeme.length;
            }
            function doEndMatch(match) {
                const lexeme = match[0];
                const matchPlusRemainder = codeToHighlight.substr(match.index);
                const endMode = endOfMode(top, match, matchPlusRemainder);
                if (!endMode) {
                    return NO_MATCH;
                }
                const origin = top;
                if (top.endScope && top.endScope._wrap) {
                    processBuffer();
                    emitter.addKeyword(lexeme, top.endScope._wrap);
                } else if (top.endScope && top.endScope._multi) {
                    processBuffer();
                    emitMultiClass(top.endScope, match);
                } else if (origin.skip) {
                    modeBuffer += lexeme;
                } else {
                    if (!(origin.returnEnd || origin.excludeEnd)) {
                        modeBuffer += lexeme;
                    }
                    processBuffer();
                    if (origin.excludeEnd) {
                        modeBuffer = lexeme;
                    }
                }
                do {
                    if (top.scope && !top.isMultiClass) {
                        emitter.closeNode();
                    }
                    if (!top.skip && !top.subLanguage) {
                        relevance += top.relevance;
                    }
                    top = top.parent;
                } while (top !== endMode.parent);
                if (endMode.starts) {
                    startNewMode(endMode.starts, match);
                }
                return origin.returnEnd ? 0 : lexeme.length;
            }
            function processContinuations() {
                const list = [];
                for (let current = top; current !== language; current = current.parent) {
                    if (current.scope) {
                        list.unshift(current.scope);
                    }
                }
                list.forEach((item) => emitter.openNode(item));
            }
            let lastMatch = {};
            function processLexeme(textBeforeMatch, match) {
                const lexeme = match && match[0];
                modeBuffer += textBeforeMatch;
                if (lexeme == null) {
                    processBuffer();
                    return 0;
                }
                if (
                    lastMatch.type === 'begin' &&
                    match.type === 'end' &&
                    lastMatch.index === match.index &&
                    lexeme === ''
                ) {
                    modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
                    if (!SAFE_MODE) {
                        const err = new Error(`0 width match regex (${languageName})`);
                        err.languageName = languageName;
                        err.badRule = lastMatch.rule;
                        throw err;
                    }
                    return 1;
                }
                lastMatch = match;
                if (match.type === 'begin') {
                    return doBeginMatch(match);
                } else if (match.type === 'illegal' && !ignoreIllegals) {
                    const err = new Error(
                        'Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || '<unnamed>') + '"',
                    );
                    err.mode = top;
                    throw err;
                } else if (match.type === 'end') {
                    const processed = doEndMatch(match);
                    if (processed !== NO_MATCH) {
                        return processed;
                    }
                }
                if (match.type === 'illegal' && lexeme === '') {
                    return 1;
                }
                if (iterations > 1e5 && iterations > match.index * 3) {
                    const err = new Error('potential infinite loop, way more iterations than matches');
                    throw err;
                }
                modeBuffer += lexeme;
                return lexeme.length;
            }
            const language = getLanguage(languageName);
            if (!language) {
                error(LANGUAGE_NOT_FOUND.replace('{}', languageName));
                throw new Error('Unknown language: "' + languageName + '"');
            }
            const md = compileLanguage(language);
            let result = '';
            let top = continuation || md;
            const continuations = {};
            const emitter = new options.__emitter(options);
            processContinuations();
            let modeBuffer = '';
            let relevance = 0;
            let index = 0;
            let iterations = 0;
            let resumeScanAtSamePosition = false;
            try {
                top.matcher.considerAll();
                for (;;) {
                    iterations++;
                    if (resumeScanAtSamePosition) {
                        resumeScanAtSamePosition = false;
                    } else {
                        top.matcher.considerAll();
                    }
                    top.matcher.lastIndex = index;
                    const match = top.matcher.exec(codeToHighlight);
                    if (!match) break;
                    const beforeMatch = codeToHighlight.substring(index, match.index);
                    const processedCount = processLexeme(beforeMatch, match);
                    index = match.index + processedCount;
                }
                processLexeme(codeToHighlight.substr(index));
                emitter.closeAllNodes();
                emitter.finalize();
                result = emitter.toHTML();
                return {
                    language: languageName,
                    value: result,
                    relevance,
                    illegal: false,
                    _emitter: emitter,
                    _top: top,
                };
            } catch (err) {
                if (err.message && err.message.includes('Illegal')) {
                    return {
                        language: languageName,
                        value: escape$2(codeToHighlight),
                        illegal: true,
                        relevance: 0,
                        _illegalBy: {
                            message: err.message,
                            index,
                            context: codeToHighlight.slice(index - 100, index + 100),
                            mode: err.mode,
                            resultSoFar: result,
                        },
                        _emitter: emitter,
                    };
                } else if (SAFE_MODE) {
                    return {
                        language: languageName,
                        value: escape$2(codeToHighlight),
                        illegal: false,
                        relevance: 0,
                        errorRaised: err,
                        _emitter: emitter,
                        _top: top,
                    };
                } else {
                    throw err;
                }
            }
        }
        function justTextHighlightResult(code) {
            const result = {
                value: escape$2(code),
                illegal: false,
                relevance: 0,
                _top: PLAINTEXT_LANGUAGE,
                _emitter: new options.__emitter(options),
            };
            result._emitter.addText(code);
            return result;
        }
        function highlightAuto(code, languageSubset) {
            languageSubset = languageSubset || options.languages || Object.keys(languages);
            const plaintext = justTextHighlightResult(code);
            const results = languageSubset
                .filter(getLanguage)
                .filter(autoDetection)
                .map((name2) => _highlight(name2, code, false));
            results.unshift(plaintext);
            const sorted = results.sort((a, b) => {
                if (a.relevance !== b.relevance) return b.relevance - a.relevance;
                if (a.language && b.language) {
                    if (getLanguage(a.language).supersetOf === b.language) {
                        return 1;
                    } else if (getLanguage(b.language).supersetOf === a.language) {
                        return -1;
                    }
                }
                return 0;
            });
            const [best, secondBest] = sorted;
            const result = best;
            result.secondBest = secondBest;
            return result;
        }
        function updateClassName(element, currentLang, resultLang) {
            const language = (currentLang && aliases[currentLang]) || resultLang;
            element.classList.add('hljs');
            element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
            let node = null;
            const language = blockLanguage(element);
            if (shouldNotHighlight(language)) return;
            fire('before:highlightElement', { el: element, language });
            if (!options.ignoreUnescapedHTML && element.children.length > 0) {
                console.warn(
                    'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.',
                );
                console.warn('https://github.com/highlightjs/highlight.js/issues/2886');
                console.warn(element);
            }
            node = element;
            const text = node.textContent;
            const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
            element.innerHTML = result.value;
            updateClassName(element, language, result.language);
            element.result = {
                language: result.language,
                re: result.relevance,
                relevance: result.relevance,
            };
            if (result.secondBest) {
                element.secondBest = {
                    language: result.secondBest.language,
                    relevance: result.secondBest.relevance,
                };
            }
            fire('after:highlightElement', { el: element, result, text });
        }
        function configure(userOptions) {
            options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
            highlightAll();
            deprecated('10.6.0', 'initHighlighting() deprecated.  Use highlightAll() now.');
        };
        function initHighlightingOnLoad() {
            highlightAll();
            deprecated('10.6.0', 'initHighlightingOnLoad() deprecated.  Use highlightAll() now.');
        }
        let wantsHighlight = false;
        function highlightAll() {
            if (document.readyState === 'loading') {
                wantsHighlight = true;
                return;
            }
            const blocks = document.querySelectorAll(options.cssSelector);
            blocks.forEach(highlightElement);
        }
        function boot() {
            if (wantsHighlight) highlightAll();
        }
        if (typeof window !== 'undefined' && window.addEventListener) {
            window.addEventListener('DOMContentLoaded', boot, false);
        }
        function registerLanguage(languageName, languageDefinition) {
            let lang = null;
            try {
                lang = languageDefinition(hljs);
            } catch (error$1) {
                error("Language definition for '{}' could not be registered.".replace('{}', languageName));
                if (!SAFE_MODE) {
                    throw error$1;
                } else {
                    error(error$1);
                }
                lang = PLAINTEXT_LANGUAGE;
            }
            if (!lang.name) lang.name = languageName;
            languages[languageName] = lang;
            lang.rawDefinition = languageDefinition.bind(null, hljs);
            if (lang.aliases) {
                registerAliases(lang.aliases, { languageName });
            }
        }
        function unregisterLanguage(languageName) {
            delete languages[languageName];
            for (const alias of Object.keys(aliases)) {
                if (aliases[alias] === languageName) {
                    delete aliases[alias];
                }
            }
        }
        function listLanguages() {
            return Object.keys(languages);
        }
        function getLanguage(name2) {
            name2 = (name2 || '').toLowerCase();
            return languages[name2] || languages[aliases[name2]];
        }
        function registerAliases(aliasList, { languageName }) {
            if (typeof aliasList === 'string') {
                aliasList = [aliasList];
            }
            aliasList.forEach((alias) => {
                aliases[alias.toLowerCase()] = languageName;
            });
        }
        function autoDetection(name2) {
            const lang = getLanguage(name2);
            return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
            if (plugin['before:highlightBlock'] && !plugin['before:highlightElement']) {
                plugin['before:highlightElement'] = (data) => {
                    plugin['before:highlightBlock'](Object.assign({ block: data.el }, data));
                };
            }
            if (plugin['after:highlightBlock'] && !plugin['after:highlightElement']) {
                plugin['after:highlightElement'] = (data) => {
                    plugin['after:highlightBlock'](Object.assign({ block: data.el }, data));
                };
            }
        }
        function addPlugin(plugin) {
            upgradePluginAPI(plugin);
            plugins.push(plugin);
        }
        function fire(event2, args) {
            const cb = event2;
            plugins.forEach(function (plugin) {
                if (plugin[cb]) {
                    plugin[cb](args);
                }
            });
        }
        function deprecateHighlightBlock(el) {
            deprecated('10.7.0', 'highlightBlock will be removed entirely in v12.0');
            deprecated('10.7.0', 'Please use highlightElement now.');
            return highlightElement(el);
        }
        Object.assign(hljs, {
            highlight: highlight2,
            highlightAuto,
            highlightAll,
            highlightElement,
            highlightBlock: deprecateHighlightBlock,
            configure,
            initHighlighting,
            initHighlightingOnLoad,
            registerLanguage,
            unregisterLanguage,
            listLanguages,
            getLanguage,
            registerAliases,
            autoDetection,
            inherit,
            addPlugin,
        });
        hljs.debugMode = function () {
            SAFE_MODE = false;
        };
        hljs.safeMode = function () {
            SAFE_MODE = true;
        };
        hljs.versionString = version$1;
        for (const key in MODES$1) {
            if (typeof MODES$1[key] === 'object') {
                deepFreeze$1(MODES$1[key]);
            }
        }
        Object.assign(hljs, MODES$1);
        return hljs;
    };
    var highlight = HLJS({});
    var core$1 = highlight;
    const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
    const KEYWORDS = [
        'as',
        'in',
        'of',
        'if',
        'for',
        'while',
        'finally',
        'var',
        'new',
        'function',
        'do',
        'return',
        'void',
        'else',
        'break',
        'catch',
        'instanceof',
        'with',
        'throw',
        'case',
        'default',
        'try',
        'switch',
        'continue',
        'typeof',
        'delete',
        'let',
        'yield',
        'const',
        'class',
        'debugger',
        'async',
        'await',
        'static',
        'import',
        'from',
        'export',
        'extends',
    ];
    const LITERALS = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'];
    const TYPES = [
        'Intl',
        'DataView',
        'Number',
        'Math',
        'Date',
        'String',
        'RegExp',
        'Object',
        'Function',
        'Boolean',
        'Error',
        'Symbol',
        'Set',
        'Map',
        'WeakSet',
        'WeakMap',
        'Proxy',
        'Reflect',
        'JSON',
        'Promise',
        'Float64Array',
        'Int16Array',
        'Int32Array',
        'Int8Array',
        'Uint16Array',
        'Uint32Array',
        'Float32Array',
        'Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'ArrayBuffer',
        'BigInt64Array',
        'BigUint64Array',
        'BigInt',
    ];
    const ERROR_TYPES = [
        'EvalError',
        'InternalError',
        'RangeError',
        'ReferenceError',
        'SyntaxError',
        'TypeError',
        'URIError',
    ];
    const BUILT_IN_GLOBALS = [
        'setInterval',
        'setTimeout',
        'clearInterval',
        'clearTimeout',
        'require',
        'exports',
        'eval',
        'isFinite',
        'isNaN',
        'parseFloat',
        'parseInt',
        'decodeURI',
        'decodeURIComponent',
        'encodeURI',
        'encodeURIComponent',
        'escape',
        'unescape',
    ];
    const BUILT_IN_VARIABLES = [
        'arguments',
        'this',
        'super',
        'console',
        'window',
        'document',
        'localStorage',
        'module',
        'global',
    ];
    const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
    function source$3(re) {
        if (!re) return null;
        if (typeof re === 'string') return re;
        return re.source;
    }
    function lookahead$2(re) {
        return concat$3('(?=', re, ')');
    }
    function concat$3(...args) {
        const joined = args.map((x) => source$3(x)).join('');
        return joined;
    }
    function javascript(hljs) {
        const hasClosingTag = (match, { after }) => {
            const tag2 = '</' + match[0].slice(1);
            const pos = match.input.indexOf(tag2, after);
            return pos !== -1;
        };
        const IDENT_RE$12 = IDENT_RE;
        const FRAGMENT = {
            begin: '<>',
            end: '</>',
        };
        const XML_TAG = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (match, response) => {
                const afterMatchIndex = match[0].length + match.index;
                const nextChar = match.input[afterMatchIndex];
                if (nextChar === '<') {
                    response.ignoreMatch();
                    return;
                }
                if (nextChar === '>') {
                    if (!hasClosingTag(match, { after: afterMatchIndex })) {
                        response.ignoreMatch();
                    }
                }
            },
        };
        const KEYWORDS$1 = {
            $pattern: IDENT_RE,
            keyword: KEYWORDS,
            literal: LITERALS,
            built_in: BUILT_INS,
            'variable.language': BUILT_IN_VARIABLES,
        };
        const decimalDigits = '[0-9](_?[0-9])*';
        const frac = `\\.(${decimalDigits})`;
        const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
        const NUMBER = {
            className: 'number',
            variants: [
                { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
                { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
                { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
                { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
                { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
                { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
                { begin: '\\b0[0-7]+n?\\b' },
            ],
            relevance: 0,
        };
        const SUBST = {
            className: 'subst',
            begin: '\\$\\{',
            end: '\\}',
            keywords: KEYWORDS$1,
            contains: [],
        };
        const HTML_TEMPLATE = {
            begin: 'html`',
            end: '',
            starts: {
                end: '`',
                returnEnd: false,
                contains: [hljs.BACKSLASH_ESCAPE, SUBST],
                subLanguage: 'xml',
            },
        };
        const CSS_TEMPLATE = {
            begin: 'css`',
            end: '',
            starts: {
                end: '`',
                returnEnd: false,
                contains: [hljs.BACKSLASH_ESCAPE, SUBST],
                subLanguage: 'css',
            },
        };
        const TEMPLATE_STRING = {
            className: 'string',
            begin: '`',
            end: '`',
            contains: [hljs.BACKSLASH_ESCAPE, SUBST],
        };
        const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
            relevance: 0,
            contains: [
                {
                    begin: '(?=@[A-Za-z]+)',
                    relevance: 0,
                    contains: [
                        {
                            className: 'doctag',
                            begin: '@[A-Za-z]+',
                        },
                        {
                            className: 'type',
                            begin: '\\{',
                            end: '\\}',
                            excludeEnd: true,
                            excludeBegin: true,
                            relevance: 0,
                        },
                        {
                            className: 'variable',
                            begin: IDENT_RE$12 + '(?=\\s*(-)|$)',
                            endsParent: true,
                            relevance: 0,
                        },
                        {
                            begin: /(?=[^\n])\s/,
                            relevance: 0,
                        },
                    ],
                },
            ],
        });
        const COMMENT2 = {
            className: 'comment',
            variants: [JSDOC_COMMENT, hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE],
        };
        const SUBST_INTERNALS = [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            HTML_TEMPLATE,
            CSS_TEMPLATE,
            TEMPLATE_STRING,
            NUMBER,
            hljs.REGEXP_MODE,
        ];
        SUBST.contains = SUBST_INTERNALS.concat({
            begin: /\{/,
            end: /\}/,
            keywords: KEYWORDS$1,
            contains: ['self'].concat(SUBST_INTERNALS),
        });
        const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
        const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
            {
                begin: /\(/,
                end: /\)/,
                keywords: KEYWORDS$1,
                contains: ['self'].concat(SUBST_AND_COMMENTS),
            },
        ]);
        const PARAMS = {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS$1,
            contains: PARAMS_CONTAINS,
        };
        const CLASS_OR_EXTENDS = {
            variants: [
                {
                    match: [/class/, /\s+/, IDENT_RE$12],
                    scope: {
                        1: 'keyword',
                        3: 'title.class',
                    },
                },
                {
                    match: [/extends/, /\s+/, concat$3(IDENT_RE$12, '(', concat$3(/\./, IDENT_RE$12), ')*')],
                    scope: {
                        1: 'keyword',
                        3: 'title.class.inherited',
                    },
                },
            ],
        };
        const CLASS_REFERENCE = {
            relevance: 0,
            match: /\b[A-Z][a-z]+([A-Z][a-z]+)*/,
            className: 'title.class',
            keywords: {
                _: [...TYPES, ...ERROR_TYPES],
            },
        };
        const USE_STRICT = {
            label: 'use_strict',
            className: 'meta',
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/,
        };
        const FUNCTION_DEFINITION = {
            variants: [
                {
                    match: [/function/, /\s+/, IDENT_RE$12, /(?=\s*\()/],
                },
                {
                    match: [/function/, /\s*(?=\()/],
                },
            ],
            className: {
                1: 'keyword',
                3: 'title.function',
            },
            label: 'func.def',
            contains: [PARAMS],
            illegal: /%/,
        };
        const UPPER_CASE_CONSTANT = {
            relevance: 0,
            match: /\b[A-Z][A-Z_0-9]+\b/,
            className: 'variable.constant',
        };
        function noneOf(list) {
            return concat$3('(?!', list.join('|'), ')');
        }
        const FUNCTION_CALL = {
            match: concat$3(/\b/, noneOf([...BUILT_IN_GLOBALS, 'super']), IDENT_RE$12, lookahead$2(/\(/)),
            className: 'title.function',
            relevance: 0,
        };
        const PROPERTY_ACCESS = {
            begin: concat$3(/\./, lookahead$2(concat$3(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
            end: IDENT_RE$12,
            excludeBegin: true,
            keywords: 'prototype',
            className: 'property',
            relevance: 0,
        };
        const GETTER_OR_SETTER = {
            match: [/get|set/, /\s+/, IDENT_RE$12, /(?=\()/],
            className: {
                1: 'keyword',
                3: 'title.function',
            },
            contains: [
                {
                    begin: /\(\)/,
                },
                PARAMS,
            ],
        };
        const FUNC_LEAD_IN_RE =
            '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>';
        const FUNCTION_VARIABLE = {
            match: [/const|var|let/, /\s+/, IDENT_RE$12, /\s*/, /=\s*/, lookahead$2(FUNC_LEAD_IN_RE)],
            className: {
                1: 'keyword',
                3: 'title.function',
            },
            contains: [PARAMS],
        };
        return {
            name: 'Javascript',
            aliases: ['js', 'jsx', 'mjs', 'cjs'],
            keywords: KEYWORDS$1,
            exports: { PARAMS_CONTAINS },
            illegal: /#(?![$_A-z])/,
            contains: [
                hljs.SHEBANG({
                    label: 'shebang',
                    binary: 'node',
                    relevance: 5,
                }),
                USE_STRICT,
                hljs.APOS_STRING_MODE,
                hljs.QUOTE_STRING_MODE,
                HTML_TEMPLATE,
                CSS_TEMPLATE,
                TEMPLATE_STRING,
                COMMENT2,
                NUMBER,
                CLASS_REFERENCE,
                {
                    className: 'attr',
                    begin: IDENT_RE$12 + lookahead$2(':'),
                    relevance: 0,
                },
                FUNCTION_VARIABLE,
                {
                    begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                    keywords: 'return throw case',
                    relevance: 0,
                    contains: [
                        COMMENT2,
                        hljs.REGEXP_MODE,
                        {
                            className: 'function',
                            begin: FUNC_LEAD_IN_RE,
                            returnBegin: true,
                            end: '\\s*=>',
                            contains: [
                                {
                                    className: 'params',
                                    variants: [
                                        {
                                            begin: hljs.UNDERSCORE_IDENT_RE,
                                            relevance: 0,
                                        },
                                        {
                                            className: null,
                                            begin: /\(\s*\)/,
                                            skip: true,
                                        },
                                        {
                                            begin: /\(/,
                                            end: /\)/,
                                            excludeBegin: true,
                                            excludeEnd: true,
                                            keywords: KEYWORDS$1,
                                            contains: PARAMS_CONTAINS,
                                        },
                                    ],
                                },
                            ],
                        },
                        {
                            begin: /,/,
                            relevance: 0,
                        },
                        {
                            match: /\s+/,
                            relevance: 0,
                        },
                        {
                            variants: [
                                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                                {
                                    begin: XML_TAG.begin,
                                    'on:begin': XML_TAG.isTrulyOpeningTag,
                                    end: XML_TAG.end,
                                },
                            ],
                            subLanguage: 'xml',
                            contains: [
                                {
                                    begin: XML_TAG.begin,
                                    end: XML_TAG.end,
                                    skip: true,
                                    contains: ['self'],
                                },
                            ],
                        },
                    ],
                },
                FUNCTION_DEFINITION,
                {
                    beginKeywords: 'while if switch catch for',
                },
                {
                    begin:
                        '\\b(?!function)' +
                        hljs.UNDERSCORE_IDENT_RE +
                        '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
                    returnBegin: true,
                    label: 'func.def',
                    contains: [
                        PARAMS,
                        hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: 'title.function' }),
                    ],
                },
                {
                    match: /\.\.\./,
                    relevance: 0,
                },
                PROPERTY_ACCESS,
                {
                    match: '\\$' + IDENT_RE$12,
                    relevance: 0,
                },
                {
                    match: [/\bconstructor(?=\s*\()/],
                    className: { 1: 'title.function' },
                    contains: [PARAMS],
                },
                FUNCTION_CALL,
                UPPER_CASE_CONSTANT,
                CLASS_OR_EXTENDS,
                GETTER_OR_SETTER,
                {
                    match: /\$[(.]/,
                },
            ],
        };
    }
    function source$2(re) {
        if (!re) return null;
        if (typeof re === 'string') return re;
        return re.source;
    }
    function lookahead$1(re) {
        return concat$2('(?=', re, ')');
    }
    function optional(re) {
        return concat$2('(?:', re, ')?');
    }
    function concat$2(...args) {
        const joined = args.map((x) => source$2(x)).join('');
        return joined;
    }
    function stripOptionsFromArgs(args) {
        const opts = args[args.length - 1];
        if (typeof opts === 'object' && opts.constructor === Object) {
            args.splice(args.length - 1, 1);
            return opts;
        } else {
            return {};
        }
    }
    function either(...args) {
        const opts = stripOptionsFromArgs(args);
        const joined = '(' + (opts.capture ? '' : '?:') + args.map((x) => source$2(x)).join('|') + ')';
        return joined;
    }
    function xml(hljs) {
        const TAG_NAME_RE = concat$2(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
        const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
        const XML_ENTITIES = {
            className: 'symbol',
            begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/,
        };
        const XML_META_KEYWORDS = {
            begin: /\s/,
            contains: [
                {
                    className: 'keyword',
                    begin: /#?[a-z_][a-z1-9_-]+/,
                    illegal: /\n/,
                },
            ],
        };
        const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
            begin: /\(/,
            end: /\)/,
        });
        const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
            className: 'string',
        });
        const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
            className: 'string',
        });
        const TAG_INTERNALS = {
            endsWithParent: true,
            illegal: /</,
            relevance: 0,
            contains: [
                {
                    className: 'attr',
                    begin: XML_IDENT_RE,
                    relevance: 0,
                },
                {
                    begin: /=\s*/,
                    relevance: 0,
                    contains: [
                        {
                            className: 'string',
                            endsParent: true,
                            variants: [
                                {
                                    begin: /"/,
                                    end: /"/,
                                    contains: [XML_ENTITIES],
                                },
                                {
                                    begin: /'/,
                                    end: /'/,
                                    contains: [XML_ENTITIES],
                                },
                                {
                                    begin: /[^\s"'=<>`]+/,
                                },
                            ],
                        },
                    ],
                },
            ],
        };
        return {
            name: 'HTML, XML',
            aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist', 'wsf', 'svg'],
            case_insensitive: true,
            contains: [
                {
                    className: 'meta',
                    begin: /<![a-z]/,
                    end: />/,
                    relevance: 10,
                    contains: [
                        XML_META_KEYWORDS,
                        QUOTE_META_STRING_MODE,
                        APOS_META_STRING_MODE,
                        XML_META_PAR_KEYWORDS,
                        {
                            begin: /\[/,
                            end: /\]/,
                            contains: [
                                {
                                    className: 'meta',
                                    begin: /<![a-z]/,
                                    end: />/,
                                    contains: [
                                        XML_META_KEYWORDS,
                                        XML_META_PAR_KEYWORDS,
                                        QUOTE_META_STRING_MODE,
                                        APOS_META_STRING_MODE,
                                    ],
                                },
                            ],
                        },
                    ],
                },
                hljs.COMMENT(/<!--/, /-->/, {
                    relevance: 10,
                }),
                {
                    begin: /<!\[CDATA\[/,
                    end: /\]\]>/,
                    relevance: 10,
                },
                XML_ENTITIES,
                {
                    className: 'meta',
                    begin: /<\?xml/,
                    end: /\?>/,
                    relevance: 10,
                },
                {
                    className: 'tag',
                    begin: /<style(?=\s|>)/,
                    end: />/,
                    keywords: {
                        name: 'style',
                    },
                    contains: [TAG_INTERNALS],
                    starts: {
                        end: /<\/style>/,
                        returnEnd: true,
                        subLanguage: ['css', 'xml'],
                    },
                },
                {
                    className: 'tag',
                    begin: /<script(?=\s|>)/,
                    end: />/,
                    keywords: {
                        name: 'script',
                    },
                    contains: [TAG_INTERNALS],
                    starts: {
                        end: /<\/script>/,
                        returnEnd: true,
                        subLanguage: ['javascript', 'handlebars', 'xml'],
                    },
                },
                {
                    className: 'tag',
                    begin: /<>|<\/>/,
                },
                {
                    className: 'tag',
                    begin: concat$2(/</, lookahead$1(concat$2(TAG_NAME_RE, either(/\/>/, />/, /\s/)))),
                    end: /\/?>/,
                    contains: [
                        {
                            className: 'name',
                            begin: TAG_NAME_RE,
                            relevance: 0,
                            starts: TAG_INTERNALS,
                        },
                    ],
                },
                {
                    className: 'tag',
                    begin: concat$2(/<\//, lookahead$1(concat$2(TAG_NAME_RE, />/))),
                    contains: [
                        {
                            className: 'name',
                            begin: TAG_NAME_RE,
                            relevance: 0,
                        },
                        {
                            begin: />/,
                            relevance: 0,
                            endsParent: true,
                        },
                    ],
                },
            ],
        };
    }
    function source$1(re) {
        if (!re) return null;
        if (typeof re === 'string') return re;
        return re.source;
    }
    function concat$1(...args) {
        const joined = args.map((x) => source$1(x)).join('');
        return joined;
    }
    function bash(hljs) {
        const VAR = {};
        const BRACED_VAR = {
            begin: /\$\{/,
            end: /\}/,
            contains: [
                'self',
                {
                    begin: /:-/,
                    contains: [VAR],
                },
            ],
        };
        Object.assign(VAR, {
            className: 'variable',
            variants: [{ begin: concat$1(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`) }, BRACED_VAR],
        });
        const SUBST = {
            className: 'subst',
            begin: /\$\(/,
            end: /\)/,
            contains: [hljs.BACKSLASH_ESCAPE],
        };
        const HERE_DOC = {
            begin: /<<-?\s*(?=\w+)/,
            starts: {
                contains: [
                    hljs.END_SAME_AS_BEGIN({
                        begin: /(\w+)/,
                        end: /(\w+)/,
                        className: 'string',
                    }),
                ],
            },
        };
        const QUOTE_STRING = {
            className: 'string',
            begin: /"/,
            end: /"/,
            contains: [hljs.BACKSLASH_ESCAPE, VAR, SUBST],
        };
        SUBST.contains.push(QUOTE_STRING);
        const ESCAPED_QUOTE = {
            className: '',
            begin: /\\"/,
        };
        const APOS_STRING = {
            className: 'string',
            begin: /'/,
            end: /'/,
        };
        const ARITHMETIC = {
            begin: /\$\(\(/,
            end: /\)\)/,
            contains: [{ begin: /\d+#[0-9a-f]+/, className: 'number' }, hljs.NUMBER_MODE, VAR],
        };
        const SH_LIKE_SHELLS = ['fish', 'bash', 'zsh', 'sh', 'csh', 'ksh', 'tcsh', 'dash', 'scsh'];
        const KNOWN_SHEBANG = hljs.SHEBANG({
            binary: `(${SH_LIKE_SHELLS.join('|')})`,
            relevance: 10,
        });
        const FUNCTION = {
            className: 'function',
            begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
            returnBegin: true,
            contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
            relevance: 0,
        };
        const KEYWORDS2 = [
            'if',
            'then',
            'else',
            'elif',
            'fi',
            'for',
            'while',
            'in',
            'do',
            'done',
            'case',
            'esac',
            'function',
        ];
        const LITERALS2 = ['true', 'false'];
        return {
            name: 'Bash',
            aliases: ['sh'],
            keywords: {
                $pattern: /\b[a-z._-]+\b/,
                keyword: KEYWORDS2,
                literal: LITERALS2,
                built_in:
                    'break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp',
            },
            contains: [
                KNOWN_SHEBANG,
                hljs.SHEBANG(),
                FUNCTION,
                ARITHMETIC,
                hljs.HASH_COMMENT_MODE,
                HERE_DOC,
                QUOTE_STRING,
                ESCAPED_QUOTE,
                APOS_STRING,
                VAR,
            ],
        };
    }
    function php(hljs) {
        const VARIABLE = {
            className: 'variable',
            begin: `\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])`,
        };
        const PREPROCESSOR = {
            className: 'meta',
            variants: [{ begin: /<\?php/, relevance: 10 }, { begin: /<\?[=]?/ }, { begin: /\?>/ }],
        };
        const SUBST = {
            className: 'subst',
            variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }],
        };
        const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
            illegal: null,
        });
        const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
            illegal: null,
            contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
        });
        const HEREDOC = hljs.END_SAME_AS_BEGIN({
            begin: /<<<[ \t]*(\w+)\n/,
            end: /[ \t]*(\w+)\b/,
            contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
        });
        const STRING = {
            className: 'string',
            contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
            variants: [
                hljs.inherit(SINGLE_QUOTED, {
                    begin: "b'",
                    end: "'",
                }),
                hljs.inherit(DOUBLE_QUOTED, {
                    begin: 'b"',
                    end: '"',
                }),
                DOUBLE_QUOTED,
                SINGLE_QUOTED,
                HEREDOC,
            ],
        };
        const NUMBER = {
            className: 'number',
            variants: [
                { begin: `\\b0b[01]+(?:_[01]+)*\\b` },
                { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` },
                { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` },
                { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?` },
            ],
            relevance: 0,
        };
        const KEYWORDS2 = {
            keyword:
                '__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield',
            literal: 'false null true',
            built_in:
                'Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass',
        };
        return {
            case_insensitive: true,
            keywords: KEYWORDS2,
            contains: [
                hljs.HASH_COMMENT_MODE,
                hljs.COMMENT('//', '$', { contains: [PREPROCESSOR] }),
                hljs.COMMENT('/\\*', '\\*/', {
                    contains: [
                        {
                            className: 'doctag',
                            begin: '@[A-Za-z]+',
                        },
                    ],
                }),
                hljs.COMMENT('__halt_compiler.+?;', false, {
                    endsWithParent: true,
                    keywords: '__halt_compiler',
                }),
                PREPROCESSOR,
                {
                    className: 'keyword',
                    begin: /\$this\b/,
                },
                VARIABLE,
                {
                    begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
                },
                {
                    className: 'function',
                    relevance: 0,
                    beginKeywords: 'fn function',
                    end: /[;{]/,
                    excludeEnd: true,
                    illegal: '[$%\\[]',
                    contains: [
                        {
                            beginKeywords: 'use',
                        },
                        hljs.UNDERSCORE_TITLE_MODE,
                        {
                            begin: '=>',
                            endsParent: true,
                        },
                        {
                            className: 'params',
                            begin: '\\(',
                            end: '\\)',
                            excludeBegin: true,
                            excludeEnd: true,
                            keywords: KEYWORDS2,
                            contains: ['self', VARIABLE, hljs.C_BLOCK_COMMENT_MODE, STRING, NUMBER],
                        },
                    ],
                },
                {
                    className: 'class',
                    variants: [
                        { beginKeywords: 'enum', illegal: /[($"]/ },
                        { beginKeywords: 'class interface trait', illegal: /[:($"]/ },
                    ],
                    relevance: 0,
                    end: /\{/,
                    excludeEnd: true,
                    contains: [{ beginKeywords: 'extends implements' }, hljs.UNDERSCORE_TITLE_MODE],
                },
                {
                    beginKeywords: 'namespace',
                    relevance: 0,
                    end: ';',
                    illegal: /[.']/,
                    contains: [hljs.UNDERSCORE_TITLE_MODE],
                },
                {
                    beginKeywords: 'use',
                    relevance: 0,
                    end: ';',
                    contains: [hljs.UNDERSCORE_TITLE_MODE],
                },
                STRING,
                NUMBER,
            ],
        };
    }
    const MODES = (hljs) => {
        return {
            IMPORTANT: {
                scope: 'meta',
                begin: '!important',
            },
            HEXCOLOR: {
                scope: 'number',
                begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})',
            },
            ATTRIBUTE_SELECTOR_MODE: {
                scope: 'selector-attr',
                begin: /\[/,
                end: /\]/,
                illegal: '$',
                contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE],
            },
            CSS_NUMBER_MODE: {
                scope: 'number',
                begin:
                    hljs.NUMBER_RE +
                    '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
                relevance: 0,
            },
            CSS_VARIABLE: {
                className: 'attr',
                begin: /--[A-Za-z][A-Za-z0-9_-]*/,
            },
        };
    };
    const TAGS = [
        'a',
        'abbr',
        'address',
        'article',
        'aside',
        'audio',
        'b',
        'blockquote',
        'body',
        'button',
        'canvas',
        'caption',
        'cite',
        'code',
        'dd',
        'del',
        'details',
        'dfn',
        'div',
        'dl',
        'dt',
        'em',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'header',
        'hgroup',
        'html',
        'i',
        'iframe',
        'img',
        'input',
        'ins',
        'kbd',
        'label',
        'legend',
        'li',
        'main',
        'mark',
        'menu',
        'nav',
        'object',
        'ol',
        'p',
        'q',
        'quote',
        'samp',
        'section',
        'span',
        'strong',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'tr',
        'ul',
        'var',
        'video',
    ];
    const MEDIA_FEATURES = [
        'any-hover',
        'any-pointer',
        'aspect-ratio',
        'color',
        'color-gamut',
        'color-index',
        'device-aspect-ratio',
        'device-height',
        'device-width',
        'display-mode',
        'forced-colors',
        'grid',
        'height',
        'hover',
        'inverted-colors',
        'monochrome',
        'orientation',
        'overflow-block',
        'overflow-inline',
        'pointer',
        'prefers-color-scheme',
        'prefers-contrast',
        'prefers-reduced-motion',
        'prefers-reduced-transparency',
        'resolution',
        'scan',
        'scripting',
        'update',
        'width',
        'min-width',
        'max-width',
        'min-height',
        'max-height',
    ];
    const PSEUDO_CLASSES = [
        'active',
        'any-link',
        'blank',
        'checked',
        'current',
        'default',
        'defined',
        'dir',
        'disabled',
        'drop',
        'empty',
        'enabled',
        'first',
        'first-child',
        'first-of-type',
        'fullscreen',
        'future',
        'focus',
        'focus-visible',
        'focus-within',
        'has',
        'host',
        'host-context',
        'hover',
        'indeterminate',
        'in-range',
        'invalid',
        'is',
        'lang',
        'last-child',
        'last-of-type',
        'left',
        'link',
        'local-link',
        'not',
        'nth-child',
        'nth-col',
        'nth-last-child',
        'nth-last-col',
        'nth-last-of-type',
        'nth-of-type',
        'only-child',
        'only-of-type',
        'optional',
        'out-of-range',
        'past',
        'placeholder-shown',
        'read-only',
        'read-write',
        'required',
        'right',
        'root',
        'scope',
        'target',
        'target-within',
        'user-invalid',
        'valid',
        'visited',
        'where',
    ];
    const PSEUDO_ELEMENTS = [
        'after',
        'backdrop',
        'before',
        'cue',
        'cue-region',
        'first-letter',
        'first-line',
        'grammar-error',
        'marker',
        'part',
        'placeholder',
        'selection',
        'slotted',
        'spelling-error',
    ];
    const ATTRIBUTES = [
        'align-content',
        'align-items',
        'align-self',
        'animation',
        'animation-delay',
        'animation-direction',
        'animation-duration',
        'animation-fill-mode',
        'animation-iteration-count',
        'animation-name',
        'animation-play-state',
        'animation-timing-function',
        'auto',
        'backface-visibility',
        'background',
        'background-attachment',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'border',
        'border-bottom',
        'border-bottom-color',
        'border-bottom-left-radius',
        'border-bottom-right-radius',
        'border-bottom-style',
        'border-bottom-width',
        'border-collapse',
        'border-color',
        'border-image',
        'border-image-outset',
        'border-image-repeat',
        'border-image-slice',
        'border-image-source',
        'border-image-width',
        'border-left',
        'border-left-color',
        'border-left-style',
        'border-left-width',
        'border-radius',
        'border-right',
        'border-right-color',
        'border-right-style',
        'border-right-width',
        'border-spacing',
        'border-style',
        'border-top',
        'border-top-color',
        'border-top-left-radius',
        'border-top-right-radius',
        'border-top-style',
        'border-top-width',
        'border-width',
        'bottom',
        'box-decoration-break',
        'box-shadow',
        'box-sizing',
        'break-after',
        'break-before',
        'break-inside',
        'caption-side',
        'clear',
        'clip',
        'clip-path',
        'color',
        'column-count',
        'column-fill',
        'column-gap',
        'column-rule',
        'column-rule-color',
        'column-rule-style',
        'column-rule-width',
        'column-span',
        'column-width',
        'columns',
        'content',
        'counter-increment',
        'counter-reset',
        'cursor',
        'direction',
        'display',
        'empty-cells',
        'filter',
        'flex',
        'flex-basis',
        'flex-direction',
        'flex-flow',
        'flex-grow',
        'flex-shrink',
        'flex-wrap',
        'float',
        'font',
        'font-display',
        'font-family',
        'font-feature-settings',
        'font-kerning',
        'font-language-override',
        'font-size',
        'font-size-adjust',
        'font-smoothing',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-variant-ligatures',
        'font-variation-settings',
        'font-weight',
        'height',
        'hyphens',
        'icon',
        'image-orientation',
        'image-rendering',
        'image-resolution',
        'ime-mode',
        'inherit',
        'initial',
        'justify-content',
        'left',
        'letter-spacing',
        'line-height',
        'list-style',
        'list-style-image',
        'list-style-position',
        'list-style-type',
        'margin',
        'margin-bottom',
        'margin-left',
        'margin-right',
        'margin-top',
        'marks',
        'mask',
        'max-height',
        'max-width',
        'min-height',
        'min-width',
        'nav-down',
        'nav-index',
        'nav-left',
        'nav-right',
        'nav-up',
        'none',
        'normal',
        'object-fit',
        'object-position',
        'opacity',
        'order',
        'orphans',
        'outline',
        'outline-color',
        'outline-offset',
        'outline-style',
        'outline-width',
        'overflow',
        'overflow-wrap',
        'overflow-x',
        'overflow-y',
        'padding',
        'padding-bottom',
        'padding-left',
        'padding-right',
        'padding-top',
        'page-break-after',
        'page-break-before',
        'page-break-inside',
        'perspective',
        'perspective-origin',
        'pointer-events',
        'position',
        'quotes',
        'resize',
        'right',
        'src',
        'tab-size',
        'table-layout',
        'text-align',
        'text-align-last',
        'text-decoration',
        'text-decoration-color',
        'text-decoration-line',
        'text-decoration-style',
        'text-indent',
        'text-overflow',
        'text-rendering',
        'text-shadow',
        'text-transform',
        'text-underline-position',
        'top',
        'transform',
        'transform-origin',
        'transform-style',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function',
        'unicode-bidi',
        'vertical-align',
        'visibility',
        'white-space',
        'widows',
        'width',
        'word-break',
        'word-spacing',
        'word-wrap',
        'z-index',
    ].reverse();
    function source(re) {
        if (!re) return null;
        if (typeof re === 'string') return re;
        return re.source;
    }
    function lookahead(re) {
        return concat('(?=', re, ')');
    }
    function concat(...args) {
        const joined = args.map((x) => source(x)).join('');
        return joined;
    }
    function css(hljs) {
        const modes = MODES(hljs);
        const FUNCTION_DISPATCH = {
            className: 'built_in',
            begin: /[\w-]+(?=\()/,
        };
        const VENDOR_PREFIX = {
            begin: /-(webkit|moz|ms|o)-(?=[a-z])/,
        };
        const AT_MODIFIERS = 'and or not only';
        const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
        const IDENT_RE2 = '[a-zA-Z-][a-zA-Z0-9_-]*';
        const STRINGS = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE];
        return {
            name: 'CSS',
            case_insensitive: true,
            illegal: /[=|'\$]/,
            keywords: {
                keyframePosition: 'from to',
            },
            classNameAliases: {
                keyframePosition: 'selector-tag',
            },
            contains: [
                hljs.C_BLOCK_COMMENT_MODE,
                VENDOR_PREFIX,
                modes.CSS_NUMBER_MODE,
                {
                    className: 'selector-id',
                    begin: /#[A-Za-z0-9_-]+/,
                    relevance: 0,
                },
                {
                    className: 'selector-class',
                    begin: '\\.' + IDENT_RE2,
                    relevance: 0,
                },
                modes.ATTRIBUTE_SELECTOR_MODE,
                {
                    className: 'selector-pseudo',
                    variants: [
                        {
                            begin: ':(' + PSEUDO_CLASSES.join('|') + ')',
                        },
                        {
                            begin: '::(' + PSEUDO_ELEMENTS.join('|') + ')',
                        },
                    ],
                },
                modes.CSS_VARIABLE,
                {
                    className: 'attribute',
                    begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b',
                },
                {
                    begin: ':',
                    end: '[;}]',
                    contains: [
                        modes.HEXCOLOR,
                        modes.IMPORTANT,
                        modes.CSS_NUMBER_MODE,
                        ...STRINGS,
                        {
                            begin: /(url|data-uri)\(/,
                            end: /\)/,
                            relevance: 0,
                            keywords: {
                                built_in: 'url data-uri',
                            },
                            contains: [
                                {
                                    className: 'string',
                                    begin: /[^)]/,
                                    endsWithParent: true,
                                    excludeEnd: true,
                                },
                            ],
                        },
                        FUNCTION_DISPATCH,
                    ],
                },
                {
                    begin: lookahead(/@/),
                    end: '[{;]',
                    relevance: 0,
                    illegal: /:/,
                    contains: [
                        {
                            className: 'keyword',
                            begin: AT_PROPERTY_RE,
                        },
                        {
                            begin: /\s/,
                            endsWithParent: true,
                            excludeEnd: true,
                            relevance: 0,
                            keywords: {
                                $pattern: /[a-z-]+/,
                                keyword: AT_MODIFIERS,
                                attribute: MEDIA_FEATURES.join(' '),
                            },
                            contains: [
                                {
                                    begin: /[a-z-]+(?=:)/,
                                    className: 'attribute',
                                },
                                ...STRINGS,
                                modes.CSS_NUMBER_MODE,
                            ],
                        },
                    ],
                },
                {
                    className: 'selector-tag',
                    begin: '\\b(' + TAGS.join('|') + ')\\b',
                },
            ],
        };
    }
    var __css$4 =
        ".hljs {\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-space-30, 24px);\n    background-color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-surface-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-surface-a, 1));\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-surfaceForeground-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-surfaceForeground-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-30-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-30-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-30-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-30-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-30-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-30-lightness-offset, 0)) * 1%),var(--s-theme-color-text-30-a, 1));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-lightness-offset, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0) + var(--s-theme-color-info-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-info-l, 0) + var(--s-theme-color-info-lightness-offset, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0) + var(--s-theme-color-accent-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0) + var(--s-theme-color-accent-lightness-offset, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n    border-radius: var(--s-theme-ui-code-borderRadius, 6px);\n    border: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-border-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-border-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-border-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-border-a, 1)) solid 1px;\n    /* overflow: hidden; */\n\n    /* @sugar.utils.configToCss(ui.code, $only: rhythm-vertical); */\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n    border-bottom-left-radius: 0 !important;\n    border-bottom-right-radius: 0 !important;\n}\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    /* overflow: hidden; */\n    position: relative;\n\n    /* [default-style] & {\n        overflow: auto;\n        @sugar.scrollbar (accent);\n    } */\n}\n\n.s-code-example__code {\n    display: none;\n    border-top-left-radius: 0 !important;\n    border-top-right-radius: 0 !important;\n    /* overflow: hidden; */\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 12px);\n    top: var(--s-theme-space-20, 12px);\n    z-index: 10;\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 12px);\n    top: var(--s-theme-space-20, 12px);\n    /* transform: translate(0, -50%); */\n}\n";
    class SCodeExampleInterface extends SInterface {}
    SCodeExampleInterface.definition = Object.assign(Object.assign({}, SComponentUtilsDefaultInterface.definition), {
        theme: {
            type: 'String',
            default: 'https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css',
        },
        active: {
            type: 'String',
        },
        toolbar: {
            type: 'Array<String>',
            values: ['copy'],
            default: ['copy'],
        },
        toolbarPosition: {
            type: 'String',
            values: ['content', 'nav'],
            default: 'nav',
        },
        languages: {
            type: 'Object',
            default: {},
        },
    });
    var __decorate$7 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d2;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d2 = decorators[i])) r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$a = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    webcomponent$a();
    class SCodeExample extends SLitElement {
        constructor() {
            var _a2;
            super();
            this._$copy = void 0;
            this._items = [];
            this._activeTabId = void 0;
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SCodeExampleInterface,
                    defaultProps: {},
                },
            });
            const languages = Object.assign(
                { html: xml, javascript, js: javascript, php, bash, shell: bash, css },
                (_a2 = this._component.props.languages) !== null && _a2 !== void 0 ? _a2 : {},
            );
            Object.keys(languages).forEach((lang) => {
                core$1.registerLanguage(lang, languages[lang]);
            });
        }
        static get properties() {
            return SComponentUtils.properties({}, SCodeExampleInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(__css$4)}
        `;
        }
        firstUpdated() {
            return __awaiter$a(this, void 0, void 0, function* () {
                this.$templates.forEach(($template) => {
                    var _a2, _b2, _c2, _d2, _e2;
                    if (!$template.getAttribute) return;
                    this._items = [
                        ...this._items,
                        {
                            id:
                                (_c2 =
                                    (_b2 =
                                        (_a2 = $template.getAttribute('id')) !== null && _a2 !== void 0
                                            ? _a2
                                            : $template.getAttribute('language')) !== null && _b2 !== void 0
                                        ? _b2
                                        : $template.getAttribute('lang')) !== null && _c2 !== void 0
                                    ? _c2
                                    : 'html',
                            lang:
                                (_e2 =
                                    (_d2 = $template.getAttribute('language')) !== null && _d2 !== void 0
                                        ? _d2
                                        : $template.getAttribute('lang')) !== null && _e2 !== void 0
                                    ? _e2
                                    : 'html',
                            code: $template.innerHTML,
                        },
                    ];
                    $template.remove();
                });
                if (this.active) {
                    this.setActiveTab(this.active);
                } else {
                    this.setActiveTab(this._items[0].id);
                }
                yield wait(500);
                return true;
            });
        }
        render() {
            var _a2, _b2, _c2, _d2;
            return html$4`
            <div
                class="${(_a2 = this._component) === null || _a2 === void 0 ? void 0 : _a2.className()}"
                ?mounted="${this.mounted}"
                ?default-style="${this.defaultStyle}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                ${
                    this._component
                        ? html$4`<header class="${this._component.className('__nav')}">
                          <ol class="${this._component.className('__tabs', 's-tabs')}">
                              ${((_b2 = this._items) !== null && _b2 !== void 0 ? _b2 : []).map(
                                  (item) => html$4`
                                      <li
                                          class="${this._component.className('__tab')}"
                                          id="${item.id}"
                                          ?active="${this._activeTabId === item.id}"
                                          @click="${this.setActiveTabByTab}"
                                      >
                                          ${item.lang}
                                      </li>
                                  `,
                              )}
                          </ol>
                          ${
                              this.toolbarPosition === 'nav'
                                  ? html$4`
                                        <div class="${this._component.className('__toolbar')}">
                                            <s-clipboard-copy @click="${this.copy}"></s-clipboard-copy>
                                        </div>
                                    `
                                  : ''
                          }
                      </header>`
                        : ''
                }
                ${
                    this._component
                        ? html$4`
                          <div class="${this._component.className('__content')}">
                              ${
                                  this.toolbarPosition !== 'nav'
                                      ? html$4`
                                            <div class="${
                                                (_c2 = this._component) === null || _c2 === void 0
                                                    ? void 0
                                                    : _c2.className('__toolbar')
                                            }">
                                                <s-clipboard-copy @click="${this.copy}"></s-clipboard-copy>
                                            </div>
                                        `
                                      : ''
                              }
                              ${((_d2 = this._items) !== null && _d2 !== void 0 ? _d2 : []).map((item) => {
                                  var _a3, _b3, _c3;
                                  return html$4`
                                      <pre
                                          class="${this._component.className('__code')}"
                                          style="line-height:0;"
                                          id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.lang}"
                                          ?active="${
                                              this._activeTabId ===
                                              ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)
                                          }"
                                      >
                            <code lang="${
                                (_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id
                            }" class="language-${item.lang} ${item.lang} ${
                                      this._component.props.defaultStyle ? 'hljs' : ''
                                  }">
                                
                                ${html$3([item.code])}
                            </code>
                        </pre>
                                  `;
                              })}
                          </div>
                      `
                        : ''
                }
            </div>
        `;
        }
        setActiveTabByTab(e) {
            this.setActiveTab(e.target.id);
        }
        setActiveTab(id) {
            return __awaiter$a(this, void 0, void 0, function* () {
                yield wait();
                this._activeTabId = id;
                this.initPrismOnTab(id);
            });
        }
        initPrismOnTab(id) {
            var _a2;
            const $content =
                (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`pre#${id} code`);
            if ($content.hasAttribute('inited')) return;
            $content.setAttribute('inited', 'true');
            const highlightedCode = core$1
                .highlight(
                    $content === null || $content === void 0
                        ? void 0
                        : $content.innerHTML.replace(/\<\!\-\-\?lit\$.*\$\-\-\>/g, ''),
                    {
                        language: $content.getAttribute('lang'),
                    },
                )
                .value.trim();
            $content.innerHTML = highlightedCode;
        }
        copy() {
            const id = this._activeTabId;
            const item = this._items.filter((i) => i.id === id)[0];
            this.$copy.copy(item.code);
        }
    }
    __decorate$7([property$5()], SCodeExample.prototype, '_items', void 0);
    __decorate$7([property$5()], SCodeExample.prototype, '_activeTabId', void 0);
    __decorate$7(
        [
            property$5({
                type: String,
            }),
        ],
        SCodeExample.prototype,
        'active',
        void 0,
    );
    __decorate$7([property$5()], SCodeExample.prototype, 'props', void 0);
    __decorate$7([query$1('s-clipboard-copy')], SCodeExample.prototype, '$copy', void 0);
    __decorate$7([query$1('.templates')], SCodeExample.prototype, '$templatesContainer', void 0);
    __decorate$7([queryAssignedNodes()], SCodeExample.prototype, '$templates', void 0);
    function webcomponent$9(props = {}, tagName = 's-code-example') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SCodeExample);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$4 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$4 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$4(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$4(options, protoOrDescriptor, name2)
                : standardProperty$4(options, protoOrDescriptor);
    }
    class SActivateComponentInterface extends SInterface {}
    SActivateComponentInterface.definition = {
        href: {
            type: 'String',
            default: '',
        },
        group: {
            type: 'String',
        },
        toggle: {
            type: {
                type: 'Boolean',
                nullishAsTrue: true,
            },
            default: false,
        },
        history: {
            type: {
                type: 'Boolean',
                nullishAsTrue: true,
            },
            default: false,
        },
        active: {
            type: {
                type: 'Boolean',
                nullishAsTrue: true,
            },
            default: false,
        },
        activeClass: {
            type: 'String',
            description: 'Specify the class to apply on target(s) when activate',
            default: 'active',
        },
        activeAttribute: {
            type: 'String',
            description: 'Specify the attribute to apply on target(s) when activate',
            default: 'active',
        },
        saveState: {
            type: 'Boolean',
            default: false,
        },
        activateTimeout: {
            type: 'Number',
            default: 0,
        },
        unactivateTimeout: {
            type: 'Number',
            default: 0,
        },
        trigger: {
            type: {
                type: 'Array<String>',
                splitChars: [','],
            },
            default: ['click'],
        },
    };
    var __decorate$6 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$9 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SActivate extends SLitElement {
        constructor() {
            super();
            this._state = 'pending';
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SActivateComponentInterface,
                    defaultProps: {},
                },
            });
            this._$nodes = Array.from(this.children);
        }
        static get properties() {
            return SComponentUtils.properties({}, SActivateComponentInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(`
            s-activate {
                display: inline-block;
                cursor: pointer;
            }
        `)}
        `;
        }
        createRenderRoot() {
            return this;
        }
        firstUpdated() {
            var _a;
            (_a = this._$nodes) === null || _a === void 0
                ? void 0
                : _a.forEach(($node) => {
                      this.appendChild($node);
                  });
            if (this._component.props.saveState) {
                if (!this.id)
                    throw new Error(
                        `<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`,
                    );
                this.active = localStorage.getItem(`s-activate-state-${this.id}`) !== null;
            }
            if (this._component.props.href) {
                this._hrefSelector = this._component.props.href;
            }
            let targets;
            if (this._hrefSelector) targets = Array.from(document.querySelectorAll(this._hrefSelector));
            if (targets === null || targets === void 0 ? void 0 : targets.length) this._$targets = targets;
            if (this._component.props.group) {
                this._$groupElements = Array.from(
                    document.querySelectorAll(`s-activate[group="${this._component.props.group}"]`),
                );
            }
            this._component.props.trigger.forEach((trigger) => {
                switch (trigger) {
                    case 'click':
                        this.addEventListener('click', (e) => {
                            if (this.isActive() && this._component.props.toggle) {
                                this.unactivate();
                            } else {
                                this.activate();
                            }
                        });
                        break;
                    case 'mouseover':
                        this.addEventListener('mouseover', (e) => {
                            this.activate();
                        });
                        break;
                    case 'mouseout':
                    case 'mouseleave':
                        this.addEventListener('mouseleave', (e) => {
                            this.unactivate();
                        });
                        break;
                    case 'anchor':
                        if (document.location.hash === this._hrefSelector) {
                            this.activate();
                        }
                        window.addEventListener('hashchange', (e) => {
                            if (document.location.hash === this._hrefSelector) {
                                this.activate();
                            }
                        });
                        break;
                }
            });
            if (this._component.props.active) {
                this.activate(true);
            }
        }
        isActive() {
            return this.hasAttribute('active');
        }
        activate(force = false) {
            return __awaiter$9(this, void 0, void 0, function* () {
                clearTimeout(this._unactivateTimeout);
                if (!force && this.isActive()) return;
                setTimeout(() => {
                    if (this._component.props.saveState) {
                        if (!this.id)
                            throw new Error(
                                `<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`,
                            );
                        localStorage.setItem(`s-activate-state-${this.id}`, 'true');
                    }
                    if (this._component.props.history && this._hrefSelector) {
                        document.location.hash = this._hrefSelector;
                    }
                    if (this._$groupElements) {
                        this._$groupElements.forEach(($element) => {
                            if ($element === this) return;
                            try {
                                $element.unactivate();
                            } catch (e) {}
                        });
                    }
                    this.active = true;
                    if (this._$targets) {
                        this._$targets.forEach(($target) => {
                            if (this._component.props.activeClass) {
                                $target.classList.add(this._component.props.activeClass);
                            }
                            if (this._component.props.activeAttribute) {
                                $target.setAttribute(this._component.props.activeAttribute, 'true');
                            }
                        });
                    }
                }, this._component.props.activateTimeout);
            });
        }
        unactivate() {
            return __awaiter$9(this, void 0, void 0, function* () {
                if (!this.isActive()) return;
                this._unactivateTimeout = setTimeout(() => {
                    if (this._component.props.saveState) {
                        if (!this.id)
                            throw new Error(
                                `<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`,
                            );
                        localStorage.removeItem(`s-activate-state-${this.id}`);
                    }
                    this.removeAttribute('active');
                    if (this._$targets) {
                        this._$targets.forEach(($target) => {
                            if (this._component.props.activeClass) {
                                $target.classList.remove(this._component.props.activeClass);
                            }
                            if (this._component.props.activeAttribute) {
                                $target.removeAttribute(this._component.props.activeAttribute);
                            }
                        });
                    }
                }, this._component.props.unactivateTimeout);
            });
        }
        render() {
            return html$4``;
        }
    }
    __decorate$6([property$4()], SActivate.prototype, '_state', void 0);
    function webcomponent$8(props = {}, tagName = 's-activate', settings = {}) {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SActivate, settings);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$3 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$3 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$3(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$3(options, protoOrDescriptor, name2)
                : standardProperty$3(options, protoOrDescriptor);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const decorateProperty$1 =
        ({ finisher, descriptor }) =>
        (protoOrDescriptor, name2) => {
            var _a;
            if (name2 !== void 0) {
                const ctor = protoOrDescriptor.constructor;
                if (descriptor !== void 0) {
                    Object.defineProperty(protoOrDescriptor, name2, descriptor(name2));
                }
                finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
            } else {
                const key = (_a = protoOrDescriptor.originalKey) !== null && _a !== void 0 ? _a : protoOrDescriptor.key;
                const info =
                    descriptor != void 0
                        ? {
                              kind: 'method',
                              placement: 'prototype',
                              key,
                              descriptor: descriptor(protoOrDescriptor.key),
                          }
                        : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
                if (finisher != void 0) {
                    info.finisher = function (ctor) {
                        finisher(ctor, key);
                    };
                }
                return info;
            }
        };
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    function query(selector, cache) {
        return decorateProperty$1({
            descriptor: (name2) => {
                const descriptor = {
                    get() {
                        var _a;
                        return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);
                    },
                    enumerable: true,
                    configurable: true,
                };
                if (cache) {
                    const key = typeof name2 === 'symbol' ? Symbol() : `__${name2}`;
                    descriptor.get = function () {
                        var _a;
                        if (this[key] === void 0) {
                            this[key] =
                                (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);
                        }
                        return this[key];
                    };
                }
                return descriptor;
            },
        });
    }
    class SConfigExplorerComponentInterface extends SInterface {}
    SConfigExplorerComponentInterface.definition = {
        apiUrl: {
            type: 'String',
            default: 'api/config',
        },
        maxItems: {
            type: 'Number',
            default: 30,
        },
    };
    var __decorate$5 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$8 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SConfigExplorer extends SLitElement {
        constructor() {
            super();
            this._displayedConfig = [];
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SConfigExplorerComponentInterface,
                    defaultProps: {},
                },
            });
            (() =>
                __awaiter$8(this, void 0, void 0, function* () {
                    const request = new SRequest({});
                    const response = yield request.send({
                        type: 'GET',
                        url: `/${this._component.props.apiUrl}?flat=1`,
                    });
                    this._config = response.data;
                }))();
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(`
            :host {
                display: block;
            }
        `)}
        `;
        }
        firstUpdated() {
            let timeout;
            this._$dotpath.addEventListener('keyup', (e) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    this._displayedConfig = [];
                    this.requestUpdate();
                }, 100);
            });
        }
        _filter(dotpath) {
            this._$dotpath.value = dotpath;
            this._displayedConfig = [];
            this.requestUpdate();
        }
        createRenderRoot() {
            return this;
        }
        render() {
            var _a, _b, _c;
            return html$4`
            <div class="${(_a = this._component) === null || _a === void 0 ? void 0 : _a.className()}">
                <table class="${
                    (_b = this._component) === null || _b === void 0 ? void 0 : _b.className('__table', 's-table')
                }">
                    <tr>
                        <th>
                            <input
                                class="${
                                    (_c = this._component) === null || _c === void 0
                                        ? void 0
                                        : _c.className('__search', 's-input s-width:100')
                                }"
                                type="text"
                                name="dotpath"
                                placeholder="Filter by dotpath"
                            />
                        </th>
                        <th>Value</th>
                    </tr>
                    ${
                        this._config
                            ? html$4`
                              ${Object.keys(this._config)
                                  .filter((dotpath, i) => {
                                      if (!this._$dotpath.value) {
                                          const splits = dotpath.split('.');
                                          if (this._displayedConfig.indexOf(splits[0]) === -1) {
                                              this._displayedConfig.push(splits[0]);
                                              return true;
                                          }
                                          return false;
                                      }
                                      if (dotpath.startsWith(this._$dotpath.value)) return true;
                                      return minimatch_1(dotpath, this._$dotpath.value, {
                                          matchBase: true,
                                      });
                                  })
                                  .map((dotpath) => {
                                      return html$4`
                                          <tr>
                                              <td>
                                                  ${dotpath.split('.').map((part, i) => {
                                                      if (i < dotpath.split('.').length - 1) {
                                                          return html$4`
                                                              <a
                                                                  @click="${() => {
                                                                      this._filter(
                                                                          dotpath
                                                                              .split('.')
                                                                              .slice(0, i + 1)
                                                                              .join('.'),
                                                                      );
                                                                  }}"
                                                                  >${part}</a
                                                              >${i < dotpath.split('.').length - 1 ? '.' : ''}
                                                          `;
                                                      } else {
                                                          return part;
                                                      }
                                                  })}
                                              </td>
                                              <td>${this._config[dotpath]}</td>
                                          </tr>
                                      `;
                                  })}
                          `
                            : html$4`
                              <tr>
                                  <td colspan="2">Loading configurations please wait...</td>
                              </tr>
                          `
                    }
                </table>
            </div>
        `;
        }
    }
    __decorate$5([property$3()], SConfigExplorer.prototype, '_config', void 0);
    __decorate$5([query('input[name="dotpath"]')], SConfigExplorer.prototype, '_$dotpath', void 0);
    function webcomponent$7(props = {}, tagName = 's-config-explorer', settings = {}) {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SConfigExplorer, settings);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$2 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$2 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$2(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$2(options, protoOrDescriptor, name2)
                : standardProperty$2(options, protoOrDescriptor);
    }
    class SSidePanelComponentInterface extends SInterface {}
    SSidePanelComponentInterface.definition = {
        side: {
            type: 'String',
            values: ['top', 'left', 'bottom', 'right'],
            default: 'left',
        },
        active: {
            type: 'Boolean',
            default: false,
        },
        overlay: {
            type: 'Boolean',
            default: false,
        },
        triggerer: {
            type: 'String',
        },
        closeOn: {
            type: {
                type: 'Array<String>',
                splitChars: [','],
            },
            values: ['click', 'escape'],
            default: ['click', 'escape'],
        },
    };
    /*!
     * hotkeys-js v3.8.5
     * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
     *
     * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
     * http://jaywcjlove.github.io/hotkeys
     *
     * Licensed under the MIT license.
     */
    var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false;
    function addEvent(object, event2, method) {
        if (object.addEventListener) {
            object.addEventListener(event2, method, false);
        } else if (object.attachEvent) {
            object.attachEvent('on'.concat(event2), function () {
                method(window.event);
            });
        }
    }
    function getMods(modifier, key) {
        var mods = key.slice(0, key.length - 1);
        for (var i = 0; i < mods.length; i++) {
            mods[i] = modifier[mods[i].toLowerCase()];
        }
        return mods;
    }
    function getKeys(key) {
        if (typeof key !== 'string') key = '';
        key = key.replace(/\s/g, '');
        var keys = key.split(',');
        var index = keys.lastIndexOf('');
        for (; index >= 0; ) {
            keys[index - 1] += ',';
            keys.splice(index, 1);
            index = keys.lastIndexOf('');
        }
        return keys;
    }
    function compareArray(a1, a2) {
        var arr1 = a1.length >= a2.length ? a1 : a2;
        var arr2 = a1.length >= a2.length ? a2 : a1;
        var isIndex = true;
        for (var i = 0; i < arr1.length; i++) {
            if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
        }
        return isIndex;
    }
    var _keyMap = {
        backspace: 8,
        tab: 9,
        clear: 12,
        enter: 13,
        return: 13,
        esc: 27,
        escape: 27,
        space: 32,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        del: 46,
        delete: 46,
        ins: 45,
        insert: 45,
        home: 36,
        end: 35,
        pageup: 33,
        pagedown: 34,
        capslock: 20,
        num_0: 96,
        num_1: 97,
        num_2: 98,
        num_3: 99,
        num_4: 100,
        num_5: 101,
        num_6: 102,
        num_7: 103,
        num_8: 104,
        num_9: 105,
        num_multiply: 106,
        num_add: 107,
        num_enter: 108,
        num_subtract: 109,
        num_decimal: 110,
        num_divide: 111,
        '\u21EA': 20,
        ',': 188,
        '.': 190,
        '/': 191,
        '`': 192,
        '-': isff ? 173 : 189,
        '=': isff ? 61 : 187,
        ';': isff ? 59 : 186,
        "'": 222,
        '[': 219,
        ']': 221,
        '\\': 220,
    };
    var _modifier = {
        '\u21E7': 16,
        shift: 16,
        '\u2325': 18,
        alt: 18,
        option: 18,
        '\u2303': 17,
        ctrl: 17,
        control: 17,
        '\u2318': 91,
        cmd: 91,
        command: 91,
    };
    var modifierMap = {
        16: 'shiftKey',
        18: 'altKey',
        17: 'ctrlKey',
        91: 'metaKey',
        shiftKey: 16,
        ctrlKey: 17,
        altKey: 18,
        metaKey: 91,
    };
    var _mods = {
        16: false,
        18: false,
        17: false,
        91: false,
    };
    var _handlers = {};
    for (var k = 1; k < 20; k++) {
        _keyMap['f'.concat(k)] = 111 + k;
    }
    var _downKeys = [];
    var _scope = 'all';
    var elementHasBindEvent = [];
    var code = function code2(x) {
        return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
    };
    function setScope(scope) {
        _scope = scope || 'all';
    }
    function getScope() {
        return _scope || 'all';
    }
    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }
    function filter(event2) {
        var target = event2.target || event2.srcElement;
        var tagName = target.tagName;
        var flag = true;
        if (
            target.isContentEditable ||
            ((tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly)
        ) {
            flag = false;
        }
        return flag;
    }
    function isPressed(keyCode) {
        if (typeof keyCode === 'string') {
            keyCode = code(keyCode);
        }
        return _downKeys.indexOf(keyCode) !== -1;
    }
    function deleteScope(scope, newScope) {
        var handlers;
        var i;
        if (!scope) scope = getScope();
        for (var key in _handlers) {
            if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
                handlers = _handlers[key];
                for (i = 0; i < handlers.length; ) {
                    if (handlers[i].scope === scope) handlers.splice(i, 1);
                    else i++;
                }
            }
        }
        if (getScope() === scope) setScope(newScope || 'all');
    }
    function clearModifier(event2) {
        var key = event2.keyCode || event2.which || event2.charCode;
        var i = _downKeys.indexOf(key);
        if (i >= 0) {
            _downKeys.splice(i, 1);
        }
        if (event2.key && event2.key.toLowerCase() === 'meta') {
            _downKeys.splice(0, _downKeys.length);
        }
        if (key === 93 || key === 224) key = 91;
        if (key in _mods) {
            _mods[key] = false;
            for (var k in _modifier) {
                if (_modifier[k] === key) hotkeys[k] = false;
            }
        }
    }
    function unbind(keysInfo) {
        if (!keysInfo) {
            Object.keys(_handlers).forEach(function (key) {
                return delete _handlers[key];
            });
        } else if (Array.isArray(keysInfo)) {
            keysInfo.forEach(function (info) {
                if (info.key) eachUnbind(info);
            });
        } else if (typeof keysInfo === 'object') {
            if (keysInfo.key) eachUnbind(keysInfo);
        } else if (typeof keysInfo === 'string') {
            for (
                var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
                _key < _len;
                _key++
            ) {
                args[_key - 1] = arguments[_key];
            }
            var scope = args[0],
                method = args[1];
            if (typeof scope === 'function') {
                method = scope;
                scope = '';
            }
            eachUnbind({
                key: keysInfo,
                scope,
                method,
                splitKey: '+',
            });
        }
    }
    var eachUnbind = function eachUnbind2(_ref) {
        var key = _ref.key,
            scope = _ref.scope,
            method = _ref.method,
            _ref$splitKey = _ref.splitKey,
            splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;
        var multipleKeys = getKeys(key);
        multipleKeys.forEach(function (originKey) {
            var unbindKeys = originKey.split(splitKey);
            var len = unbindKeys.length;
            var lastKey = unbindKeys[len - 1];
            var keyCode = lastKey === '*' ? '*' : code(lastKey);
            if (!_handlers[keyCode]) return;
            if (!scope) scope = getScope();
            var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
            _handlers[keyCode] = _handlers[keyCode].map(function (record) {
                var isMatchingMethod = method ? record.method === method : true;
                if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
                    return {};
                }
                return record;
            });
        });
    };
    function eventHandler(event2, handler, scope) {
        var modifiersMatch;
        if (handler.scope === scope || handler.scope === 'all') {
            modifiersMatch = handler.mods.length > 0;
            for (var y in _mods) {
                if (Object.prototype.hasOwnProperty.call(_mods, y)) {
                    if ((!_mods[y] && handler.mods.indexOf(+y) > -1) || (_mods[y] && handler.mods.indexOf(+y) === -1)) {
                        modifiersMatch = false;
                    }
                }
            }
            if (
                (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) ||
                modifiersMatch ||
                handler.shortcut === '*'
            ) {
                if (handler.method(event2, handler) === false) {
                    if (event2.preventDefault) event2.preventDefault();
                    else event2.returnValue = false;
                    if (event2.stopPropagation) event2.stopPropagation();
                    if (event2.cancelBubble) event2.cancelBubble = true;
                }
            }
        }
    }
    function dispatch(event2) {
        var asterisk = _handlers['*'];
        var key = event2.keyCode || event2.which || event2.charCode;
        if (!hotkeys.filter.call(this, event2)) return;
        if (key === 93 || key === 224) key = 91;
        if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
        ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
            var keyNum = modifierMap[keyName];
            if (event2[keyName] && _downKeys.indexOf(keyNum) === -1) {
                _downKeys.push(keyNum);
            } else if (!event2[keyName] && _downKeys.indexOf(keyNum) > -1) {
                _downKeys.splice(_downKeys.indexOf(keyNum), 1);
            } else if (keyName === 'metaKey' && event2[keyName] && _downKeys.length === 3) {
                if (!(event2.ctrlKey || event2.shiftKey || event2.altKey)) {
                    _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
                }
            }
        });
        if (key in _mods) {
            _mods[key] = true;
            for (var k in _modifier) {
                if (_modifier[k] === key) hotkeys[k] = true;
            }
            if (!asterisk) return;
        }
        for (var e in _mods) {
            if (Object.prototype.hasOwnProperty.call(_mods, e)) {
                _mods[e] = event2[modifierMap[e]];
            }
        }
        if (event2.getModifierState && !(event2.altKey && !event2.ctrlKey) && event2.getModifierState('AltGraph')) {
            if (_downKeys.indexOf(17) === -1) {
                _downKeys.push(17);
            }
            if (_downKeys.indexOf(18) === -1) {
                _downKeys.push(18);
            }
            _mods[17] = true;
            _mods[18] = true;
        }
        var scope = getScope();
        if (asterisk) {
            for (var i = 0; i < asterisk.length; i++) {
                if (
                    asterisk[i].scope === scope &&
                    ((event2.type === 'keydown' && asterisk[i].keydown) ||
                        (event2.type === 'keyup' && asterisk[i].keyup))
                ) {
                    eventHandler(event2, asterisk[i], scope);
                }
            }
        }
        if (!(key in _handlers)) return;
        for (var _i = 0; _i < _handlers[key].length; _i++) {
            if (
                (event2.type === 'keydown' && _handlers[key][_i].keydown) ||
                (event2.type === 'keyup' && _handlers[key][_i].keyup)
            ) {
                if (_handlers[key][_i].key) {
                    var record = _handlers[key][_i];
                    var splitKey = record.splitKey;
                    var keyShortcut = record.key.split(splitKey);
                    var _downKeysCurrent = [];
                    for (var a = 0; a < keyShortcut.length; a++) {
                        _downKeysCurrent.push(code(keyShortcut[a]));
                    }
                    if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
                        eventHandler(event2, record, scope);
                    }
                }
            }
        }
    }
    function isElementBind(element) {
        return elementHasBindEvent.indexOf(element) > -1;
    }
    function hotkeys(key, option, method) {
        _downKeys = [];
        var keys = getKeys(key);
        var mods = [];
        var scope = 'all';
        var element = document;
        var i = 0;
        var keyup = false;
        var keydown = true;
        var splitKey = '+';
        if (method === void 0 && typeof option === 'function') {
            method = option;
        }
        if (Object.prototype.toString.call(option) === '[object Object]') {
            if (option.scope) scope = option.scope;
            if (option.element) element = option.element;
            if (option.keyup) keyup = option.keyup;
            if (option.keydown !== void 0) keydown = option.keydown;
            if (typeof option.splitKey === 'string') splitKey = option.splitKey;
        }
        if (typeof option === 'string') scope = option;
        for (; i < keys.length; i++) {
            key = keys[i].split(splitKey);
            mods = [];
            if (key.length > 1) mods = getMods(_modifier, key);
            key = key[key.length - 1];
            key = key === '*' ? '*' : code(key);
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({
                keyup,
                keydown,
                scope,
                mods,
                shortcut: keys[i],
                method,
                key: keys[i],
                splitKey,
            });
        }
        if (typeof element !== 'undefined' && !isElementBind(element) && window) {
            elementHasBindEvent.push(element);
            addEvent(element, 'keydown', function (e) {
                dispatch(e);
            });
            addEvent(window, 'focus', function () {
                _downKeys = [];
            });
            addEvent(element, 'keyup', function (e) {
                dispatch(e);
                clearModifier(e);
            });
        }
    }
    var _api = {
        setScope,
        getScope,
        deleteScope,
        getPressedKeyCodes,
        isPressed,
        filter,
        unbind,
    };
    for (var a in _api) {
        if (Object.prototype.hasOwnProperty.call(_api, a)) {
            hotkeys[a] = _api[a];
        }
    }
    if (typeof window !== 'undefined') {
        var _hotkeys = window.hotkeys;
        hotkeys.noConflict = function (deep) {
            if (deep && window.hotkeys === hotkeys) {
                window.hotkeys = _hotkeys;
            }
            return hotkeys;
        };
        window.hotkeys = hotkeys;
    }
    var hotkeys_common = hotkeys;
    hotkeys_common.filter = function () {
        return true;
    };
    function hotkey(hotkey2, settings = {}) {
        return new SPromise(
            ({ resolve, reject, emit, cancel }) => {
                settings = Object.assign(
                    { element: null, keyup: false, keydown: true, once: false, splitKey: '+' },
                    settings,
                );
                hotkeys_common(hotkey2, settings, (e, h) => {
                    emit('press', e);
                    if (settings.once) cancel();
                });
            },
            {
                id: 'hotkey',
            },
        ).on('finally', () => {
            hotkeys_common.unbind(hotkey2);
        });
    }
    var __css$3 =
        "s-side-panel {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 9999;\n    pointer-events: none;\n}\n\n    s-side-panel[active] {\n        pointer-events: all;\n    }\n\n    s-side-panel:not([mounted]) > * {\n        display: none;\n    }\n\n.s-side-panel__overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n    width: 100%;\n    height: 100%;\n}\n\n[default-style] .s-side-panel__overlay {\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-lightness-offset, 0)) * 1%),var(--s-theme-color-main-a, 0.3));\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n        opacity: 0;\n    }\n\n[default-style][active] .s-side-panel__overlay {\n        opacity: 1;\n    }\n\n.s-side-panel__container {\n    display: none;\n    position: absolute;\n    z-index: 1;\n}\n\n[mounted] .s-side-panel__container {\n        display: block;\n    }\n\n[default-style] .s-side-panel__container {\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n[side='left'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        height: 100%;\n        transform: translateX(-100%);\n    }\n\n[side='top'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(-100%);\n    }\n\n[side='right'] .s-side-panel__container {\n        right: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        transform: translateX(100%);\n    }\n\n[side='bottom'] .s-side-panel__container {\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(100%);\n    }\n\n[active] .s-side-panel__container {\n        transform: translateX(0) translateY(0);\n    }\n\n.s-side-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n.s-side-panel[active] {\n        pointer-events: all;\n    }\n";
    var __decorate$4 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class SSidePanel extends SLitElement {
        constructor() {
            super();
            this._component = void 0;
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SSidePanelComponentInterface,
                    defaultProps: {},
                },
            });
            if (this._component.props.closeOn.indexOf('click') !== -1) {
                this.addEventListener('click', (e) => {
                    if (this._$container.contains(e.target)) return;
                    if (this.constructor._activePanels.slice(-1)[0] !== this) return;
                    this.constructor._activePanels.pop();
                    this.active = false;
                });
            }
            if (this._component.props.closeOn.indexOf('escape') !== -1) {
                hotkey('escape').on('press', () => {
                    if (this.constructor._activePanels.slice(-1)[0] !== this) return;
                    this.constructor._activePanels.pop();
                    this.active = false;
                });
            }
            if (this._component.props.defaultStyle) {
                this.setAttribute('default-style', true);
            }
            this._$nodes = Array.from(this.children);
            if (this._component.props.triggerer) {
                const $triggerers = Array.from(document.querySelectorAll(this._component.props.triggerer));
                $triggerers.forEach(($triggerer) => {
                    $triggerer.addEventListener('click', (e) => {
                        this.open();
                    });
                });
            }
        }
        static get properties() {
            return SComponentUtils.properties({}, SSidePanelComponentInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(__css$3)}
        `;
        }
        set active(value) {
            this._active = value;
            if (value && this.constructor._activePanels.indexOf(this) === -1) {
                this.constructor._activePanels.push(this);
            }
            if (value) {
                this.setAttribute('active', true);
            } else this.removeAttribute('active');
            this.requestUpdate();
        }
        get active() {
            return this._active;
        }
        firstUpdated() {
            this._$container = this.querySelector('.s-side-panel__container');
            this._$nodes.forEach(($node) => {
                var _a;
                (_a = this._$container) === null || _a === void 0 ? void 0 : _a.appendChild($node);
            });
        }
        createRenderRoot() {
            return this;
        }
        open() {
            this.active = true;
        }
        close() {
            this.active = false;
        }
        render() {
            return html$4`
            ${this.overlay ? html$4` <div class="${this._component.className('__overlay')}"></div> ` : ''}
            <div class="${this._component.className('__container')}"></div>
        `;
        }
    }
    SSidePanel._activePanels = [];
    __decorate$4([property$2()], SSidePanel.prototype, 'overlay', void 0);
    function webcomponent$6(props = {}, tagName = 's-side-panel') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SSidePanel);
    }
    class SSugarConfig {
        static get(dotpath) {
            var _a, _b, _c;
            return get$3(
                (_c =
                    (_b = (_a = window.env) === null || _a === void 0 ? void 0 : _a.SUGAR) === null || _b === void 0
                        ? void 0
                        : _b.config) !== null && _c !== void 0
                    ? _c
                    : {},
                dotpath,
            );
        }
    }
    console.log('JS');
    var pikaday = { exports: {} };
    //! moment.js
    //! version : 2.29.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray$1(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }
    function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }
    function isUndefined(input) {
        return input === void 0;
    }
    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map$1(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function extend$1(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;
            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend$1(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;
    function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend$1(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2);
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name2, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name2, msg);
        }
        if (!deprecations[name2]) {
            warn(msg);
            deprecations[name2] = true;
        }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }
    function set$1(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source,
        );
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend$1({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend$1(res[prop], parentConfig[prop]);
                    extend$1(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                res[prop] = extend$1({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }
    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function (mom) {
            var output = '',
                i2;
            for (i2 = 0; i2 < length; i2++) {
                output += isFunction(array[i2]) ? array[i2].call(mom, format) : array[i2];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }
    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }
    function set$1$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    var match1 = /\d/,
        match2 = /\d\d/,
        match3 = /\d{3}/,
        match4 = /\d{4}/,
        match6 = /[+-]?\d{6}/,
        match1to2 = /\d\d?/,
        match3to4 = /\d\d\d\d?/,
        match5to6 = /\d\d\d\d\d\d?/,
        match1to3 = /\d{1,3}/,
        match1to4 = /\d{1,4}/,
        match1to6 = /[+-]?\d{1,6}/,
        matchUnsigned = /\d+/,
        matchSigned = /[+-]?\d+/,
        matchOffset = /Z|[+-]\d\d:?\d\d/gi,
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;
    regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(
            s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
            }),
        );
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token2) {
            config._w = config._w || {};
            callback(input, config._w, config, token2);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;
    function mod(n, x) {
        return ((n % x) + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : 31 - ((modMonth % 7) % 2);
    }
    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addUnitPriority('month', 8);
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;
    function localeMonths(m, format) {
        if (!m) {
            return isArray$1(this._months) ? this._months : this._months['standalone'];
        }
        return isArray$1(this._months)
            ? this._months[m.month()]
            : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][
                  m.month()
              ];
    }
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray$1(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray$1(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2e3, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }
    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addUnitPriority('year', 1);
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet('FullYear', true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
    }
    function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy,
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear,
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6,
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format) {
        var weekdays = isArray$1(this._weekdays)
            ? this._weekdays
            : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = createUTC([2e3, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i',
                );
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    addUnitPriority('hour', 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return (input + '').toLowerCase().charAt(0) === 'p';
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        getSetHour = makeGetSet('Hours', true);
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse,
    };
    var locales = {},
        localeFamilies = {},
        globalLocale;
    function commonPrefix$1(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && commonPrefix$1(split, next) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }
    function loadLocale(name2) {
        var oldLocale = null,
            aliasedRequire;
        if (locales[name2] === void 0 && typeof module !== 'undefined' && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name2);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                locales[name2] = null;
            }
        }
        return locales[name2];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                }
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name2, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name2;
            if (locales[name2] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.',
                );
                parentConfig = locales[name2]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name2,
                            config,
                        });
                        return null;
                    }
                }
            }
            locales[name2] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name2]) {
                localeFamilies[name2].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }
            getSetGlobalLocale(name2);
            return locales[name2];
        } else {
            delete locales[name2];
            return null;
        }
    }
    function updateLocale(name2, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;
            if (locales[name2] != null && locales[name2].parentLocale != null) {
                locales[name2].set(mergeConfigs(locales[name2]._config, config));
            } else {
                tmpLocale = loadLocale(name2);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    config.abbr = name2;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name2];
                locales[name2] = locale;
            }
            getSetGlobalLocale(name2);
        } else {
            if (locales[name2] != null) {
                if (locales[name2].parentLocale != null) {
                    locales[name2] = locales[name2].parentLocale;
                    if (name2 === getSetGlobalLocale()) {
                        getSetGlobalLocale(name2);
                    }
                } else if (locales[name2] != null) {
                    delete locales[name2];
                }
            }
        }
        return locales[name2];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray$1(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow,
            a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
        return result;
    }
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2e3 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    function preprocessRFC2822(s) {
        return s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        if (config._strict) {
            config._isValid = false;
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        },
    );
    function defaults$1(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
            yearToUse = defaults$1(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults$1(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults$1(w.W, 1);
            weekday = defaults$1(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults$1(w.gg, config._a[YEAR], curWeek.year);
            week = defaults$1(w.w, curWeek.week);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    hooks.ISO_8601 = function () {};
    hooks.RFC_2822 = function () {};
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
                validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }
        extend$1(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map$1([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, 'd');
            res._nextDay = void 0;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i,
            format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || (format === void 0 && input === '')) {
            return createInvalid({ nullInput: true });
        }
        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray$1(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }
        if (!isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray$1(input)) {
            config._a = map$1(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (format === true || format === false) {
            strict = format;
            format = void 0;
        }
        if (locale === true || locale === false) {
            strict = locale;
            locale = void 0;
        }
        if ((isObject(input) && isObjectEmpty(input)) || (isArray$1(input) && input.length === 0)) {
            input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            },
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            },
        );
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray$1(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
    }
    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };
    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }
        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
        return true;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
        if (matches === null) {
            return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function () {};
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {},
            other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var duration = input,
            match = null,
            sign,
            ret,
            diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign,
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }
        return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name2) {
        return function (val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name2,
                    'moment().' +
                        name2 +
                        '(period, number) is deprecated. Please use moment().' +
                        name2 +
                        '(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.',
                );
                tmp = val;
                val = period;
                period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');
    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === void 0
        );
    }
    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
        var arrayTest = isArray$1(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
            i,
            property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }
    function calendar$1(time, formats) {
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = void 0;
                formats = void 0;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = void 0;
            }
        }
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone$3() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units))
        );
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff$2(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break;
            case 'minute':
                output = (this - that) / 6e4;
                break;
            case 'hour':
                output = (this - that) / 36e5;
                break;
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break;
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break;
            default:
                output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
    function toString$1() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    function inspect$2() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format$1(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === void 0) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === void 0) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        },
    );
    function localeData() {
        return this._locale;
    }
    var MS_PER_SECOND = 1e3,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }
    function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }
    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - (this.month() % 3), 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend$1({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }
    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');
    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);
    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });
    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);
    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });
    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }
            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = Infinity;
                    break;
                case 'string':
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }
    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name2,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
            name2 = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;
                    case 'NNNN':
                        if (name2 === eraName) {
                            return eras[i];
                        }
                        break;
                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }
    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }
    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }
        return '';
    }
    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }
        return '';
    }
    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }
        return '';
    }
    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf('day').valueOf();
            if ((eras[i].since <= val && val <= eras[i].until) || (eras[i].until <= val && val <= eras[i].since)) {
                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
        }
        return this.year();
    }
    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
    }
    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy,
        );
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken('Q', 0, 'Qo', 'quarter');
    addUnitAlias('quarter', 'Q');
    addUnitPriority('quarter', 7);
    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + (this.month() % 3));
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addUnitPriority('date', 9);
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addUnitPriority('dayOfYear', 4);
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addUnitPriority('minute', 14);
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addUnitPriority('second', 15);
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1e3;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 1e4;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 1e5;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1e6;
    });
    addUnitAlias('millisecond', 'ms');
    addUnitPriority('millisecond', 16);
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1e3);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone$3;
    proto.diff = diff$2;
    proto.endOf = endOf;
    proto.format = format$1;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect$2;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString$1;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone,
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted,
    );
    function createUnix(input) {
        return createLocal(input * 1e3);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set$1;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = void 0;
        }
        format = format || '';
        if (index != null) {
            return get$1(format, index, field, 'month');
        }
        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = void 0;
            }
            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
                index = format;
                format = void 0;
            }
            format = format || '';
        }
        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }
    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
    });
    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;
    function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return (days * 4800) / 146097;
    }
    function monthsToDays(months) {
        return (months * 146097) / 4800;
    }
    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1e3;
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6
        );
    }
    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');
    function clone$1$1() {
        return createDuration(this);
    }
    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }
    function makeGetter(name2) {
        return function () {
            return this.isValid() ? this._data[name2] : NaN;
        };
    }
    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round,
        thresholds = {
            ss: 44,
            s: 45,
            m: 45,
            h: 22,
            d: 26,
            w: null,
            M: 11,
        };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);
        if (thresholds.w != null) {
            a = a || (weeks <= 1 && ['w']) || (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
            return false;
        }
        if (limit === void 0) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var withSuffix = false,
            th = thresholds,
            locale,
            output;
        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }
        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1e3,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
        if (!total) {
            return 'P0D';
        }
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1,
    );
    proto$2.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = '2.29.1';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        DATE: 'YYYY-MM-DD',
        TIME: 'HH:mm',
        TIME_SECONDS: 'HH:mm:ss',
        TIME_MS: 'HH:mm:ss.SSS',
        WEEK: 'GGGG-[W]WW',
        MONTH: 'YYYY-MM',
    };
    var moment = /* @__PURE__ */ Object.freeze({ __proto__: null, [Symbol.toStringTag]: 'Module', default: hooks });
    var require$$0$4 = /* @__PURE__ */ getAugmentedNamespace$1(moment);
    /*!
     * Pikaday
     *
     * Copyright  2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
     */
    (function (module2, exports) {
        (function (root, factory) {
            var moment;
            {
                try {
                    moment = require$$0$4;
                } catch (e) {}
                module2.exports = factory(moment);
            }
        })(commonjsGlobal$1, function (moment) {
            var hasMoment = typeof moment === 'function',
                hasEventListeners = !!window.addEventListener,
                document2 = window.document,
                sto = window.setTimeout,
                addEvent = function (el, e, callback, capture) {
                    if (hasEventListeners) {
                        el.addEventListener(e, callback, !!capture);
                    } else {
                        el.attachEvent('on' + e, callback);
                    }
                },
                removeEvent = function (el, e, callback, capture) {
                    if (hasEventListeners) {
                        el.removeEventListener(e, callback, !!capture);
                    } else {
                        el.detachEvent('on' + e, callback);
                    }
                },
                trim = function (str) {
                    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
                },
                hasClass = function (el, cn) {
                    return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
                },
                addClass = function (el, cn) {
                    if (!hasClass(el, cn)) {
                        el.className = el.className === '' ? cn : el.className + ' ' + cn;
                    }
                },
                removeClass = function (el, cn) {
                    el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
                },
                isArray = function (obj) {
                    return /Array/.test(Object.prototype.toString.call(obj));
                },
                isDate = function (obj) {
                    return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
                },
                isWeekend = function (date) {
                    var day = date.getDay();
                    return day === 0 || day === 6;
                },
                isLeapYear = function (year) {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                },
                getDaysInMonth = function (year, month) {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
                },
                setToStartOfDay = function (date) {
                    if (isDate(date)) date.setHours(0, 0, 0, 0);
                },
                compareDates = function (a, b) {
                    return a.getTime() === b.getTime();
                },
                extend = function (to, from, overwrite) {
                    var prop, hasProp;
                    for (prop in from) {
                        hasProp = to[prop] !== void 0;
                        if (
                            hasProp &&
                            typeof from[prop] === 'object' &&
                            from[prop] !== null &&
                            from[prop].nodeName === void 0
                        ) {
                            if (isDate(from[prop])) {
                                if (overwrite) {
                                    to[prop] = new Date(from[prop].getTime());
                                }
                            } else if (isArray(from[prop])) {
                                if (overwrite) {
                                    to[prop] = from[prop].slice(0);
                                }
                            } else {
                                to[prop] = extend({}, from[prop], overwrite);
                            }
                        } else if (overwrite || !hasProp) {
                            to[prop] = from[prop];
                        }
                    }
                    return to;
                },
                fireEvent = function (el, eventName, data) {
                    var ev;
                    if (document2.createEvent) {
                        ev = document2.createEvent('HTMLEvents');
                        ev.initEvent(eventName, true, false);
                        ev = extend(ev, data);
                        el.dispatchEvent(ev);
                    } else if (document2.createEventObject) {
                        ev = document2.createEventObject();
                        ev = extend(ev, data);
                        el.fireEvent('on' + eventName, ev);
                    }
                },
                adjustCalendar = function (calendar) {
                    if (calendar.month < 0) {
                        calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
                        calendar.month += 12;
                    }
                    if (calendar.month > 11) {
                        calendar.year += Math.floor(Math.abs(calendar.month) / 12);
                        calendar.month -= 12;
                    }
                    return calendar;
                },
                defaults = {
                    field: null,
                    bound: void 0,
                    ariaLabel: 'Use the arrow keys to pick a date',
                    position: 'bottom left',
                    reposition: true,
                    format: 'YYYY-MM-DD',
                    toString: null,
                    parse: null,
                    defaultDate: null,
                    setDefaultDate: false,
                    firstDay: 0,
                    firstWeekOfYearMinDays: 4,
                    formatStrict: false,
                    minDate: null,
                    maxDate: null,
                    yearRange: 10,
                    showWeekNumber: false,
                    pickWholeWeek: false,
                    minYear: 0,
                    maxYear: 9999,
                    minMonth: void 0,
                    maxMonth: void 0,
                    startRange: null,
                    endRange: null,
                    isRTL: false,
                    yearSuffix: '',
                    showMonthAfterYear: false,
                    showDaysInNextAndPreviousMonths: false,
                    enableSelectionDaysInNextAndPreviousMonths: false,
                    numberOfMonths: 1,
                    mainCalendar: 'left',
                    container: void 0,
                    blurFieldOnSelect: true,
                    i18n: {
                        previousMonth: 'Previous Month',
                        nextMonth: 'Next Month',
                        months: [
                            'January',
                            'February',
                            'March',
                            'April',
                            'May',
                            'June',
                            'July',
                            'August',
                            'September',
                            'October',
                            'November',
                            'December',
                        ],
                        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    },
                    theme: null,
                    events: [],
                    onSelect: null,
                    onOpen: null,
                    onClose: null,
                    onDraw: null,
                    keyboardInput: true,
                },
                renderDayName = function (opts, day, abbr) {
                    day += opts.firstDay;
                    while (day >= 7) {
                        day -= 7;
                    }
                    return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
                },
                renderDay = function (opts) {
                    var arr = [];
                    var ariaSelected = 'false';
                    if (opts.isEmpty) {
                        if (opts.showDaysInNextAndPreviousMonths) {
                            arr.push('is-outside-current-month');
                            if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
                                arr.push('is-selection-disabled');
                            }
                        } else {
                            return '<td class="is-empty"></td>';
                        }
                    }
                    if (opts.isDisabled) {
                        arr.push('is-disabled');
                    }
                    if (opts.isToday) {
                        arr.push('is-today');
                    }
                    if (opts.isSelected) {
                        arr.push('is-selected');
                        ariaSelected = 'true';
                    }
                    if (opts.hasEvent) {
                        arr.push('has-event');
                    }
                    if (opts.isInRange) {
                        arr.push('is-inrange');
                    }
                    if (opts.isStartRange) {
                        arr.push('is-startrange');
                    }
                    if (opts.isEndRange) {
                        arr.push('is-endrange');
                    }
                    return (
                        '<td data-day="' +
                        opts.day +
                        '" class="' +
                        arr.join(' ') +
                        '" aria-selected="' +
                        ariaSelected +
                        '"><button class="pika-button pika-day" type="button" data-pika-year="' +
                        opts.year +
                        '" data-pika-month="' +
                        opts.month +
                        '" data-pika-day="' +
                        opts.day +
                        '">' +
                        opts.day +
                        '</button></td>'
                    );
                },
                isoWeek = function (date, firstWeekOfYearMinDays) {
                    date.setHours(0, 0, 0, 0);
                    var yearDay = date.getDate(),
                        weekDay = date.getDay(),
                        dayInFirstWeek = firstWeekOfYearMinDays,
                        dayShift = dayInFirstWeek - 1,
                        daysPerWeek = 7,
                        prevWeekDay = function (day) {
                            return (day + daysPerWeek - 1) % daysPerWeek;
                        };
                    date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
                    var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek),
                        msPerDay = 24 * 60 * 60 * 1e3,
                        daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay,
                        weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
                    return weekNum;
                },
                renderWeek = function (d, m, y, firstWeekOfYearMinDays) {
                    var date = new Date(y, m, d),
                        week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
                    return '<td class="pika-week">' + week + '</td>';
                },
                renderRow = function (days, isRTL, pickWholeWeek, isRowSelected) {
                    return (
                        '<tr class="pika-row' +
                        (pickWholeWeek ? ' pick-whole-week' : '') +
                        (isRowSelected ? ' is-selected' : '') +
                        '">' +
                        (isRTL ? days.reverse() : days).join('') +
                        '</tr>'
                    );
                },
                renderBody = function (rows) {
                    return '<tbody>' + rows.join('') + '</tbody>';
                },
                renderHead = function (opts) {
                    var i,
                        arr = [];
                    if (opts.showWeekNumber) {
                        arr.push('<th></th>');
                    }
                    for (i = 0; i < 7; i++) {
                        arr.push(
                            '<th scope="col"><abbr title="' +
                                renderDayName(opts, i) +
                                '">' +
                                renderDayName(opts, i, true) +
                                '</abbr></th>',
                        );
                    }
                    return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
                },
                renderTitle = function (instance, c, year, month, refYear, randId) {
                    var i,
                        j,
                        arr,
                        opts = instance._o,
                        isMinYear = year === opts.minYear,
                        isMaxYear = year === opts.maxYear,
                        html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
                        monthHtml,
                        yearHtml,
                        prev = true,
                        next = true;
                    for (arr = [], i = 0; i < 12; i++) {
                        arr.push(
                            '<option value="' +
                                (year === refYear ? i - c : 12 + i - c) +
                                '"' +
                                (i === month ? ' selected="selected"' : '') +
                                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth)
                                    ? ' disabled="disabled"'
                                    : '') +
                                '>' +
                                opts.i18n.months[i] +
                                '</option>',
                        );
                    }
                    monthHtml =
                        '<div class="pika-label">' +
                        opts.i18n.months[month] +
                        '<select class="pika-select pika-select-month" tabindex="-1">' +
                        arr.join('') +
                        '</select></div>';
                    if (isArray(opts.yearRange)) {
                        i = opts.yearRange[0];
                        j = opts.yearRange[1] + 1;
                    } else {
                        i = year - opts.yearRange;
                        j = 1 + year + opts.yearRange;
                    }
                    for (arr = []; i < j && i <= opts.maxYear; i++) {
                        if (i >= opts.minYear) {
                            arr.push(
                                '<option value="' +
                                    i +
                                    '"' +
                                    (i === year ? ' selected="selected"' : '') +
                                    '>' +
                                    i +
                                    '</option>',
                            );
                        }
                    }
                    yearHtml =
                        '<div class="pika-label">' +
                        year +
                        opts.yearSuffix +
                        '<select class="pika-select pika-select-year" tabindex="-1">' +
                        arr.join('') +
                        '</select></div>';
                    if (opts.showMonthAfterYear) {
                        html += yearHtml + monthHtml;
                    } else {
                        html += monthHtml + yearHtml;
                    }
                    if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                        prev = false;
                    }
                    if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                        next = false;
                    }
                    if (c === 0) {
                        html +=
                            '<button class="pika-prev' +
                            (prev ? '' : ' is-disabled') +
                            '" type="button">' +
                            opts.i18n.previousMonth +
                            '</button>';
                    }
                    if (c === instance._o.numberOfMonths - 1) {
                        html +=
                            '<button class="pika-next' +
                            (next ? '' : ' is-disabled') +
                            '" type="button">' +
                            opts.i18n.nextMonth +
                            '</button>';
                    }
                    return (html += '</div>');
                },
                renderTable = function (opts, data, randId) {
                    return (
                        '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' +
                        randId +
                        '">' +
                        renderHead(opts) +
                        renderBody(data) +
                        '</table>'
                    );
                },
                Pikaday = function (options) {
                    var self2 = this,
                        opts = self2.config(options);
                    self2._onMouseDown = function (e) {
                        if (!self2._v) {
                            return;
                        }
                        e = e || window.event;
                        var target = e.target || e.srcElement;
                        if (!target) {
                            return;
                        }
                        if (!hasClass(target, 'is-disabled')) {
                            if (
                                hasClass(target, 'pika-button') &&
                                !hasClass(target, 'is-empty') &&
                                !hasClass(target.parentNode, 'is-disabled')
                            ) {
                                self2.setDate(
                                    new Date(
                                        target.getAttribute('data-pika-year'),
                                        target.getAttribute('data-pika-month'),
                                        target.getAttribute('data-pika-day'),
                                    ),
                                );
                                if (opts.bound) {
                                    sto(function () {
                                        self2.hide();
                                        if (opts.blurFieldOnSelect && opts.field) {
                                            opts.field.blur();
                                        }
                                    }, 100);
                                }
                            } else if (hasClass(target, 'pika-prev')) {
                                self2.prevMonth();
                            } else if (hasClass(target, 'pika-next')) {
                                self2.nextMonth();
                            }
                        }
                        if (!hasClass(target, 'pika-select')) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            } else {
                                e.returnValue = false;
                                return false;
                            }
                        } else {
                            self2._c = true;
                        }
                    };
                    self2._onChange = function (e) {
                        e = e || window.event;
                        var target = e.target || e.srcElement;
                        if (!target) {
                            return;
                        }
                        if (hasClass(target, 'pika-select-month')) {
                            self2.gotoMonth(target.value);
                        } else if (hasClass(target, 'pika-select-year')) {
                            self2.gotoYear(target.value);
                        }
                    };
                    self2._onKeyChange = function (e) {
                        e = e || window.event;
                        if (self2.isVisible()) {
                            switch (e.keyCode) {
                                case 13:
                                case 27:
                                    if (opts.field) {
                                        opts.field.blur();
                                    }
                                    break;
                                case 37:
                                    self2.adjustDate('subtract', 1);
                                    break;
                                case 38:
                                    self2.adjustDate('subtract', 7);
                                    break;
                                case 39:
                                    self2.adjustDate('add', 1);
                                    break;
                                case 40:
                                    self2.adjustDate('add', 7);
                                    break;
                                case 8:
                                case 46:
                                    self2.setDate(null);
                                    break;
                            }
                        }
                    };
                    self2._parseFieldValue = function () {
                        if (opts.parse) {
                            return opts.parse(opts.field.value, opts.format);
                        } else if (hasMoment) {
                            var date = moment(opts.field.value, opts.format, opts.formatStrict);
                            return date && date.isValid() ? date.toDate() : null;
                        } else {
                            return new Date(Date.parse(opts.field.value));
                        }
                    };
                    self2._onInputChange = function (e) {
                        var date;
                        if (e.firedBy === self2) {
                            return;
                        }
                        date = self2._parseFieldValue();
                        if (isDate(date)) {
                            self2.setDate(date);
                        }
                        if (!self2._v) {
                            self2.show();
                        }
                    };
                    self2._onInputFocus = function () {
                        self2.show();
                    };
                    self2._onInputClick = function () {
                        self2.show();
                    };
                    self2._onInputBlur = function () {
                        var pEl = document2.activeElement;
                        do {
                            if (hasClass(pEl, 'pika-single')) {
                                return;
                            }
                        } while ((pEl = pEl.parentNode));
                        if (!self2._c) {
                            self2._b = sto(function () {
                                self2.hide();
                            }, 50);
                        }
                        self2._c = false;
                    };
                    self2._onClick = function (e) {
                        e = e || window.event;
                        var target = e.target || e.srcElement,
                            pEl = target;
                        if (!target) {
                            return;
                        }
                        if (!hasEventListeners && hasClass(target, 'pika-select')) {
                            if (!target.onchange) {
                                target.setAttribute('onchange', 'return;');
                                addEvent(target, 'change', self2._onChange);
                            }
                        }
                        do {
                            if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                                return;
                            }
                        } while ((pEl = pEl.parentNode));
                        if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
                            self2.hide();
                        }
                    };
                    self2.el = document2.createElement('div');
                    self2.el.className =
                        'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');
                    addEvent(self2.el, 'mousedown', self2._onMouseDown, true);
                    addEvent(self2.el, 'touchend', self2._onMouseDown, true);
                    addEvent(self2.el, 'change', self2._onChange);
                    if (opts.keyboardInput) {
                        addEvent(document2, 'keydown', self2._onKeyChange);
                    }
                    if (opts.field) {
                        if (opts.container) {
                            opts.container.appendChild(self2.el);
                        } else if (opts.bound) {
                            document2.body.appendChild(self2.el);
                        } else {
                            opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
                        }
                        addEvent(opts.field, 'change', self2._onInputChange);
                        if (!opts.defaultDate) {
                            opts.defaultDate = self2._parseFieldValue();
                            opts.setDefaultDate = true;
                        }
                    }
                    var defDate = opts.defaultDate;
                    if (isDate(defDate)) {
                        if (opts.setDefaultDate) {
                            self2.setDate(defDate, true);
                        } else {
                            self2.gotoDate(defDate);
                        }
                    } else {
                        self2.gotoDate(new Date());
                    }
                    if (opts.bound) {
                        this.hide();
                        self2.el.className += ' is-bound';
                        addEvent(opts.trigger, 'click', self2._onInputClick);
                        addEvent(opts.trigger, 'focus', self2._onInputFocus);
                        addEvent(opts.trigger, 'blur', self2._onInputBlur);
                    } else {
                        this.show();
                    }
                };
            Pikaday.prototype = {
                config: function (options) {
                    if (!this._o) {
                        this._o = extend({}, defaults, true);
                    }
                    var opts = extend(this._o, options, true);
                    opts.isRTL = !!opts.isRTL;
                    opts.field = opts.field && opts.field.nodeName ? opts.field : null;
                    opts.theme = typeof opts.theme === 'string' && opts.theme ? opts.theme : null;
                    opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
                    opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
                    opts.disableWeekends = !!opts.disableWeekends;
                    opts.disableDayFn = typeof opts.disableDayFn === 'function' ? opts.disableDayFn : null;
                    var nom = parseInt(opts.numberOfMonths, 10) || 1;
                    opts.numberOfMonths = nom > 4 ? 4 : nom;
                    if (!isDate(opts.minDate)) {
                        opts.minDate = false;
                    }
                    if (!isDate(opts.maxDate)) {
                        opts.maxDate = false;
                    }
                    if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
                        opts.maxDate = opts.minDate = false;
                    }
                    if (opts.minDate) {
                        this.setMinDate(opts.minDate);
                    }
                    if (opts.maxDate) {
                        this.setMaxDate(opts.maxDate);
                    }
                    if (isArray(opts.yearRange)) {
                        var fallback = new Date().getFullYear() - 10;
                        opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                        opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
                    } else {
                        opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                        if (opts.yearRange > 100) {
                            opts.yearRange = 100;
                        }
                    }
                    return opts;
                },
                toString: function (format) {
                    format = format || this._o.format;
                    if (!isDate(this._d)) {
                        return '';
                    }
                    if (this._o.toString) {
                        return this._o.toString(this._d, format);
                    }
                    if (hasMoment) {
                        return moment(this._d).format(format);
                    }
                    return this._d.toDateString();
                },
                getMoment: function () {
                    return hasMoment ? moment(this._d) : null;
                },
                setMoment: function (date, preventOnSelect) {
                    if (hasMoment && moment.isMoment(date)) {
                        this.setDate(date.toDate(), preventOnSelect);
                    }
                },
                getDate: function () {
                    return isDate(this._d) ? new Date(this._d.getTime()) : null;
                },
                setDate: function (date, preventOnSelect) {
                    if (!date) {
                        this._d = null;
                        if (this._o.field) {
                            this._o.field.value = '';
                            fireEvent(this._o.field, 'change', { firedBy: this });
                        }
                        return this.draw();
                    }
                    if (typeof date === 'string') {
                        date = new Date(Date.parse(date));
                    }
                    if (!isDate(date)) {
                        return;
                    }
                    var min = this._o.minDate,
                        max = this._o.maxDate;
                    if (isDate(min) && date < min) {
                        date = min;
                    } else if (isDate(max) && date > max) {
                        date = max;
                    }
                    this._d = new Date(date.getTime());
                    setToStartOfDay(this._d);
                    this.gotoDate(this._d);
                    if (this._o.field) {
                        this._o.field.value = this.toString();
                        fireEvent(this._o.field, 'change', { firedBy: this });
                    }
                    if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                        this._o.onSelect.call(this, this.getDate());
                    }
                },
                clear: function () {
                    this.setDate(null);
                },
                gotoDate: function (date) {
                    var newCalendar = true;
                    if (!isDate(date)) {
                        return;
                    }
                    if (this.calendars) {
                        var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                            lastVisibleDate = new Date(
                                this.calendars[this.calendars.length - 1].year,
                                this.calendars[this.calendars.length - 1].month,
                                1,
                            ),
                            visibleDate = date.getTime();
                        lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                        lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                        newCalendar =
                            visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
                    }
                    if (newCalendar) {
                        this.calendars = [
                            {
                                month: date.getMonth(),
                                year: date.getFullYear(),
                            },
                        ];
                        if (this._o.mainCalendar === 'right') {
                            this.calendars[0].month += 1 - this._o.numberOfMonths;
                        }
                    }
                    this.adjustCalendars();
                },
                adjustDate: function (sign, days) {
                    var day = this.getDate() || new Date();
                    var difference = parseInt(days) * 24 * 60 * 60 * 1e3;
                    var newDay;
                    if (sign === 'add') {
                        newDay = new Date(day.valueOf() + difference);
                    } else if (sign === 'subtract') {
                        newDay = new Date(day.valueOf() - difference);
                    }
                    this.setDate(newDay);
                },
                adjustCalendars: function () {
                    this.calendars[0] = adjustCalendar(this.calendars[0]);
                    for (var c = 1; c < this._o.numberOfMonths; c++) {
                        this.calendars[c] = adjustCalendar({
                            month: this.calendars[0].month + c,
                            year: this.calendars[0].year,
                        });
                    }
                    this.draw();
                },
                gotoToday: function () {
                    this.gotoDate(new Date());
                },
                gotoMonth: function (month) {
                    if (!isNaN(month)) {
                        this.calendars[0].month = parseInt(month, 10);
                        this.adjustCalendars();
                    }
                },
                nextMonth: function () {
                    this.calendars[0].month++;
                    this.adjustCalendars();
                },
                prevMonth: function () {
                    this.calendars[0].month--;
                    this.adjustCalendars();
                },
                gotoYear: function (year) {
                    if (!isNaN(year)) {
                        this.calendars[0].year = parseInt(year, 10);
                        this.adjustCalendars();
                    }
                },
                setMinDate: function (value) {
                    if (value instanceof Date) {
                        setToStartOfDay(value);
                        this._o.minDate = value;
                        this._o.minYear = value.getFullYear();
                        this._o.minMonth = value.getMonth();
                    } else {
                        this._o.minDate = defaults.minDate;
                        this._o.minYear = defaults.minYear;
                        this._o.minMonth = defaults.minMonth;
                        this._o.startRange = defaults.startRange;
                    }
                    this.draw();
                },
                setMaxDate: function (value) {
                    if (value instanceof Date) {
                        setToStartOfDay(value);
                        this._o.maxDate = value;
                        this._o.maxYear = value.getFullYear();
                        this._o.maxMonth = value.getMonth();
                    } else {
                        this._o.maxDate = defaults.maxDate;
                        this._o.maxYear = defaults.maxYear;
                        this._o.maxMonth = defaults.maxMonth;
                        this._o.endRange = defaults.endRange;
                    }
                    this.draw();
                },
                setStartRange: function (value) {
                    this._o.startRange = value;
                },
                setEndRange: function (value) {
                    this._o.endRange = value;
                },
                draw: function (force) {
                    if (!this._v && !force) {
                        return;
                    }
                    var opts = this._o,
                        minYear = opts.minYear,
                        maxYear = opts.maxYear,
                        minMonth = opts.minMonth,
                        maxMonth = opts.maxMonth,
                        html = '',
                        randId;
                    if (this._y <= minYear) {
                        this._y = minYear;
                        if (!isNaN(minMonth) && this._m < minMonth) {
                            this._m = minMonth;
                        }
                    }
                    if (this._y >= maxYear) {
                        this._y = maxYear;
                        if (!isNaN(maxMonth) && this._m > maxMonth) {
                            this._m = maxMonth;
                        }
                    }
                    for (var c = 0; c < opts.numberOfMonths; c++) {
                        randId =
                            'pika-title-' +
                            Math.random()
                                .toString(36)
                                .replace(/[^a-z]+/g, '')
                                .substr(0, 2);
                        html +=
                            '<div class="pika-lendar">' +
                            renderTitle(
                                this,
                                c,
                                this.calendars[c].year,
                                this.calendars[c].month,
                                this.calendars[0].year,
                                randId,
                            ) +
                            this.render(this.calendars[c].year, this.calendars[c].month, randId) +
                            '</div>';
                    }
                    this.el.innerHTML = html;
                    if (opts.bound) {
                        if (opts.field.type !== 'hidden') {
                            sto(function () {
                                opts.trigger.focus();
                            }, 1);
                        }
                    }
                    if (typeof this._o.onDraw === 'function') {
                        this._o.onDraw(this);
                    }
                    if (opts.bound) {
                        opts.field.setAttribute('aria-label', opts.ariaLabel);
                    }
                },
                adjustPosition: function () {
                    var field,
                        pEl,
                        width,
                        height,
                        viewportWidth,
                        viewportHeight,
                        scrollTop,
                        left,
                        top,
                        clientRect,
                        leftAligned,
                        bottomAligned;
                    if (this._o.container) return;
                    this.el.style.position = 'absolute';
                    field = this._o.trigger;
                    pEl = field;
                    width = this.el.offsetWidth;
                    height = this.el.offsetHeight;
                    viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
                    viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
                    scrollTop = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
                    leftAligned = true;
                    bottomAligned = true;
                    if (typeof field.getBoundingClientRect === 'function') {
                        clientRect = field.getBoundingClientRect();
                        left = clientRect.left + window.pageXOffset;
                        top = clientRect.bottom + window.pageYOffset;
                    } else {
                        left = pEl.offsetLeft;
                        top = pEl.offsetTop + pEl.offsetHeight;
                        while ((pEl = pEl.offsetParent)) {
                            left += pEl.offsetLeft;
                            top += pEl.offsetTop;
                        }
                    }
                    if (
                        (this._o.reposition && left + width > viewportWidth) ||
                        (this._o.position.indexOf('right') > -1 && left - width + field.offsetWidth > 0)
                    ) {
                        left = left - width + field.offsetWidth;
                        leftAligned = false;
                    }
                    if (
                        (this._o.reposition && top + height > viewportHeight + scrollTop) ||
                        (this._o.position.indexOf('top') > -1 && top - height - field.offsetHeight > 0)
                    ) {
                        top = top - height - field.offsetHeight;
                        bottomAligned = false;
                    }
                    this.el.style.left = left + 'px';
                    this.el.style.top = top + 'px';
                    addClass(this.el, leftAligned ? 'left-aligned' : 'right-aligned');
                    addClass(this.el, bottomAligned ? 'bottom-aligned' : 'top-aligned');
                    removeClass(this.el, !leftAligned ? 'left-aligned' : 'right-aligned');
                    removeClass(this.el, !bottomAligned ? 'bottom-aligned' : 'top-aligned');
                },
                render: function (year, month, randId) {
                    var opts = this._o,
                        now = new Date(),
                        days = getDaysInMonth(year, month),
                        before = new Date(year, month, 1).getDay(),
                        data = [],
                        row = [];
                    setToStartOfDay(now);
                    if (opts.firstDay > 0) {
                        before -= opts.firstDay;
                        if (before < 0) {
                            before += 7;
                        }
                    }
                    var previousMonth = month === 0 ? 11 : month - 1,
                        nextMonth = month === 11 ? 0 : month + 1,
                        yearOfPreviousMonth = month === 0 ? year - 1 : year,
                        yearOfNextMonth = month === 11 ? year + 1 : year,
                        daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
                    var cells = days + before,
                        after = cells;
                    while (after > 7) {
                        after -= 7;
                    }
                    cells += 7 - after;
                    var isWeekSelected = false;
                    for (var i = 0, r = 0; i < cells; i++) {
                        var day = new Date(year, month, 1 + (i - before)),
                            isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                            isToday = compareDates(day, now),
                            hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                            isEmpty = i < before || i >= days + before,
                            dayNumber = 1 + (i - before),
                            monthNumber = month,
                            yearNumber = year,
                            isStartRange = opts.startRange && compareDates(opts.startRange, day),
                            isEndRange = opts.endRange && compareDates(opts.endRange, day),
                            isInRange =
                                opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                            isDisabled =
                                (opts.minDate && day < opts.minDate) ||
                                (opts.maxDate && day > opts.maxDate) ||
                                (opts.disableWeekends && isWeekend(day)) ||
                                (opts.disableDayFn && opts.disableDayFn(day));
                        if (isEmpty) {
                            if (i < before) {
                                dayNumber = daysInPreviousMonth + dayNumber;
                                monthNumber = previousMonth;
                                yearNumber = yearOfPreviousMonth;
                            } else {
                                dayNumber = dayNumber - days;
                                monthNumber = nextMonth;
                                yearNumber = yearOfNextMonth;
                            }
                        }
                        var dayConfig = {
                            day: dayNumber,
                            month: monthNumber,
                            year: yearNumber,
                            hasEvent,
                            isSelected,
                            isToday,
                            isDisabled,
                            isEmpty,
                            isStartRange,
                            isEndRange,
                            isInRange,
                            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths,
                        };
                        if (opts.pickWholeWeek && isSelected) {
                            isWeekSelected = true;
                        }
                        row.push(renderDay(dayConfig));
                        if (++r === 7) {
                            if (opts.showWeekNumber) {
                                row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
                            }
                            data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                            row = [];
                            r = 0;
                            isWeekSelected = false;
                        }
                    }
                    return renderTable(opts, data, randId);
                },
                isVisible: function () {
                    return this._v;
                },
                show: function () {
                    if (!this.isVisible()) {
                        this._v = true;
                        this.draw();
                        removeClass(this.el, 'is-hidden');
                        if (this._o.bound) {
                            addEvent(document2, 'click', this._onClick);
                            this.adjustPosition();
                        }
                        if (typeof this._o.onOpen === 'function') {
                            this._o.onOpen.call(this);
                        }
                    }
                },
                hide: function () {
                    var v = this._v;
                    if (v !== false) {
                        if (this._o.bound) {
                            removeEvent(document2, 'click', this._onClick);
                        }
                        if (!this._o.container) {
                            this.el.style.position = 'static';
                            this.el.style.left = 'auto';
                            this.el.style.top = 'auto';
                        }
                        addClass(this.el, 'is-hidden');
                        this._v = false;
                        if (v !== void 0 && typeof this._o.onClose === 'function') {
                            this._o.onClose.call(this);
                        }
                    }
                },
                destroy: function () {
                    var opts = this._o;
                    this.hide();
                    removeEvent(this.el, 'mousedown', this._onMouseDown, true);
                    removeEvent(this.el, 'touchend', this._onMouseDown, true);
                    removeEvent(this.el, 'change', this._onChange);
                    if (opts.keyboardInput) {
                        removeEvent(document2, 'keydown', this._onKeyChange);
                    }
                    if (opts.field) {
                        removeEvent(opts.field, 'change', this._onInputChange);
                        if (opts.bound) {
                            removeEvent(opts.trigger, 'click', this._onInputClick);
                            removeEvent(opts.trigger, 'focus', this._onInputFocus);
                            removeEvent(opts.trigger, 'blur', this._onInputBlur);
                        }
                    }
                    if (this.el.parentNode) {
                        this.el.parentNode.removeChild(this.el);
                    }
                },
            };
            return Pikaday;
        });
    })(pikaday);
    var __pikaday = pikaday.exports;
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _a$1$1, _b$1, _c$1, _d, _e;
    var _f;
    {
        console.warn('lit-html is in dev mode. Not recommended for production!');
    }
    const wrap =
        ((_a$1$1 = window.ShadyDOM) === null || _a$1$1 === void 0 ? void 0 : _a$1$1.inUse) &&
        ((_b$1 = window.ShadyDOM) === null || _b$1 === void 0 ? void 0 : _b$1.noPatch) === true
            ? window.ShadyDOM.wrap
            : (node) => node;
    const trustedTypes$1 = globalThis.trustedTypes;
    const policy$1 = trustedTypes$1
        ? trustedTypes$1.createPolicy('lit-html', {
              createHTML: (s) => s,
          })
        : void 0;
    const identityFunction = (value) => value;
    const noopSanitizer = (_node, _name, _type) => identityFunction;
    const createSanitizer = (node, name2, type) => {
        return sanitizerFactoryInternal();
    };
    const boundAttributeSuffix$1 = '$lit$';
    const marker$1 = `lit$${String(Math.random()).slice(9)}$`;
    const markerMatch = '?' + marker$1;
    const nodeMarker$1 = `<${markerMatch}>`;
    const d = document;
    const createMarker$1 = (v = '') => d.createComment(v);
    const isPrimitive$1 = (value) => value === null || (typeof value != 'object' && typeof value != 'function');
    const isArray = Array.isArray;
    const isIterable$1 = (value) => {
        var _a2;
        return (
            isArray(value) ||
            typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === 'function'
        );
    };
    const SPACE_CHAR = `[ 	
\f\r]`;
    const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
    const NAME_CHAR = `[^\\s"'>=/]`;
    const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    const COMMENT_START = 1;
    const TAG_NAME = 2;
    const DYNAMIC_TAG_NAME = 3;
    const commentEndRegex = /-->/g;
    const comment2EndRegex = />/g;
    const tagEndRegex = new RegExp(
        `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`,
        'g',
    );
    const ENTIRE_MATCH = 0;
    const ATTRIBUTE_NAME = 1;
    const SPACES_AND_EQUALS = 2;
    const QUOTE_CHAR = 3;
    const singleQuoteAttrEndRegex = /'/g;
    const doubleQuoteAttrEndRegex = /"/g;
    const rawTextElement = /^(?:script|style|textarea)$/i;
    const HTML_RESULT = 1;
    const SVG_RESULT = 2;
    const ATTRIBUTE_PART = 1;
    const CHILD_PART = 2;
    const PROPERTY_PART = 3;
    const BOOLEAN_ATTRIBUTE_PART = 4;
    const EVENT_PART = 5;
    const ELEMENT_PART = 6;
    const COMMENT_PART = 7;
    const tag =
        (type) =>
        (strings, ...values) => {
            if (strings.some((s) => s === void 0)) {
                console.warn(
                    'Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.',
                );
            }
            return {
                ['_$litType$']: type,
                strings,
                values,
            };
        };
    const html$1 = tag(HTML_RESULT);
    const noChange$1 = Symbol.for('lit-noChange');
    const nothing$1 = Symbol.for('lit-nothing');
    const templateCache = new WeakMap();
    const walker = d.createTreeWalker(d, 129, null, false);
    let sanitizerFactoryInternal = noopSanitizer;
    const getTemplateHtml = (strings, type) => {
        const l = strings.length - 1;
        const attrNames = [];
        let html2 = type === SVG_RESULT ? '<svg>' : '';
        let rawTextEndRegex;
        let regex = textEndRegex;
        for (let i = 0; i < l; i++) {
            const s = strings[i];
            let attrNameEndIndex = -1;
            let attrName;
            let lastIndex = 0;
            let match;
            while (lastIndex < s.length) {
                regex.lastIndex = lastIndex;
                match = regex.exec(s);
                if (match === null) {
                    break;
                }
                lastIndex = regex.lastIndex;
                if (regex === textEndRegex) {
                    if (match[COMMENT_START] === '!--') {
                        regex = commentEndRegex;
                    } else if (match[COMMENT_START] !== void 0) {
                        regex = comment2EndRegex;
                    } else if (match[TAG_NAME] !== void 0) {
                        if (rawTextElement.test(match[TAG_NAME])) {
                            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');
                        }
                        regex = tagEndRegex;
                    } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
                        regex = tagEndRegex;
                    }
                } else if (regex === tagEndRegex) {
                    if (match[ENTIRE_MATCH] === '>') {
                        regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
                        attrNameEndIndex = -1;
                    } else if (match[ATTRIBUTE_NAME] === void 0) {
                        attrNameEndIndex = -2;
                    } else {
                        attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
                        attrName = match[ATTRIBUTE_NAME];
                        regex =
                            match[QUOTE_CHAR] === void 0
                                ? tagEndRegex
                                : match[QUOTE_CHAR] === '"'
                                ? doubleQuoteAttrEndRegex
                                : singleQuoteAttrEndRegex;
                    }
                } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
                    regex = tagEndRegex;
                } else if (regex === commentEndRegex || regex === comment2EndRegex) {
                    regex = textEndRegex;
                } else {
                    regex = tagEndRegex;
                    rawTextEndRegex = void 0;
                }
            }
            {
                console.assert(
                    attrNameEndIndex === -1 ||
                        regex === tagEndRegex ||
                        regex === singleQuoteAttrEndRegex ||
                        regex === doubleQuoteAttrEndRegex,
                    'unexpected parse state B',
                );
            }
            const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';
            html2 +=
                regex === textEndRegex
                    ? s + nodeMarker$1
                    : attrNameEndIndex >= 0
                    ? (attrNames.push(attrName),
                      s.slice(0, attrNameEndIndex) + boundAttributeSuffix$1 + s.slice(attrNameEndIndex)) +
                      marker$1 +
                      end
                    : s + marker$1 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
        }
        const htmlResult = html2 + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');
        return [policy$1 !== void 0 ? policy$1.createHTML(htmlResult) : htmlResult, attrNames];
    };
    class Template$1 {
        constructor({ strings, ['_$litType$']: type }, options) {
            this.parts = [];
            let node;
            let nodeIndex = 0;
            let attrNameIndex = 0;
            const partCount = strings.length - 1;
            const parts = this.parts;
            const [html2, attrNames] = getTemplateHtml(strings, type);
            this.el = Template$1.createElement(html2, options);
            walker.currentNode = this.el.content;
            if (type === SVG_RESULT) {
                const content = this.el.content;
                const svgElement = content.firstChild;
                svgElement.remove();
                content.append(...svgElement.childNodes);
            }
            while ((node = walker.nextNode()) !== null && parts.length < partCount) {
                if (node.nodeType === 1) {
                    if (node.hasAttributes()) {
                        const attrsToRemove = [];
                        for (const name2 of node.getAttributeNames()) {
                            if (name2.endsWith(boundAttributeSuffix$1) || name2.startsWith(marker$1)) {
                                const realName = attrNames[attrNameIndex++];
                                attrsToRemove.push(name2);
                                if (realName !== void 0) {
                                    const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$1);
                                    const statics = value.split(marker$1);
                                    const m = /([.?@])?(.*)/.exec(realName);
                                    parts.push({
                                        type: ATTRIBUTE_PART,
                                        index: nodeIndex,
                                        name: m[2],
                                        strings: statics,
                                        ctor:
                                            m[1] === '.'
                                                ? PropertyPart$1
                                                : m[1] === '?'
                                                ? BooleanAttributePart$1
                                                : m[1] === '@'
                                                ? EventPart$1
                                                : AttributePart$1,
                                    });
                                } else {
                                    parts.push({
                                        type: ELEMENT_PART,
                                        index: nodeIndex,
                                    });
                                }
                            }
                        }
                        for (const name2 of attrsToRemove) {
                            node.removeAttribute(name2);
                        }
                    }
                    if (rawTextElement.test(node.tagName)) {
                        const strings2 = node.textContent.split(marker$1);
                        const lastIndex = strings2.length - 1;
                        if (lastIndex > 0) {
                            node.textContent = trustedTypes$1 ? trustedTypes$1.emptyScript : '';
                            for (let i = 0; i < lastIndex; i++) {
                                node.append(strings2[i], createMarker$1());
                                walker.nextNode();
                                parts.push({ type: CHILD_PART, index: ++nodeIndex });
                            }
                            node.append(strings2[lastIndex], createMarker$1());
                        }
                    }
                } else if (node.nodeType === 8) {
                    const data = node.data;
                    if (data === markerMatch) {
                        parts.push({ type: CHILD_PART, index: nodeIndex });
                    } else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker$1, i + 1)) !== -1) {
                            parts.push({ type: COMMENT_PART, index: nodeIndex });
                            i += marker$1.length - 1;
                        }
                    }
                }
                nodeIndex++;
            }
        }
        static createElement(html2, _options) {
            const el = d.createElement('template');
            el.innerHTML = html2;
            return el;
        }
    }
    function resolveDirective(part, value, parent = part, attributeIndex) {
        var _a2, _b2, _c2;
        var _d2;
        if (value === noChange$1) {
            return value;
        }
        let currentDirective =
            attributeIndex !== void 0
                ? (_a2 = parent.__directives) === null || _a2 === void 0
                    ? void 0
                    : _a2[attributeIndex]
                : parent.__directive;
        const nextDirectiveConstructor = isPrimitive$1(value) ? void 0 : value['_$litDirective$'];
        if (
            (currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !==
            nextDirectiveConstructor
        ) {
            (_b2 =
                currentDirective === null || currentDirective === void 0
                    ? void 0
                    : currentDirective['_$notifyDirectiveConnectionChanged']) === null || _b2 === void 0
                ? void 0
                : _b2.call(currentDirective, false);
            if (nextDirectiveConstructor === void 0) {
                currentDirective = void 0;
            } else {
                currentDirective = new nextDirectiveConstructor(part);
                currentDirective._$initialize(part, parent, attributeIndex);
            }
            if (attributeIndex !== void 0) {
                ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : (_d2.__directives = []))[
                    attributeIndex
                ] = currentDirective;
            } else {
                parent.__directive = currentDirective;
            }
        }
        if (currentDirective !== void 0) {
            value = resolveDirective(
                part,
                currentDirective._$resolve(part, value.values),
                currentDirective,
                attributeIndex,
            );
        }
        return value;
    }
    class TemplateInstance$1 {
        constructor(template, parent) {
            this._parts = [];
            this._$disconnectableChildren = void 0;
            this._$template = template;
            this._$parent = parent;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _clone(options) {
            var _a2;
            const {
                el: { content },
                parts,
            } = this._$template;
            const fragment = (
                (_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null &&
                _a2 !== void 0
                    ? _a2
                    : d
            ).importNode(content, true);
            walker.currentNode = fragment;
            let node = walker.nextNode();
            let nodeIndex = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            while (templatePart !== void 0) {
                if (nodeIndex === templatePart.index) {
                    let part;
                    if (templatePart.type === CHILD_PART) {
                        part = new ChildPart(node, node.nextSibling, this, options);
                    } else if (templatePart.type === ATTRIBUTE_PART) {
                        part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
                    } else if (templatePart.type === ELEMENT_PART) {
                        part = new ElementPart(node, this, options);
                    }
                    this._parts.push(part);
                    templatePart = parts[++partIndex];
                }
                if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
                    node = walker.nextNode();
                    nodeIndex++;
                }
            }
            return fragment;
        }
        _update(values) {
            let i = 0;
            for (const part of this._parts) {
                if (part !== void 0) {
                    if (part.strings !== void 0) {
                        part._$setValue(values, part, i);
                        i += part.strings.length - 2;
                    } else {
                        part._$setValue(values[i]);
                    }
                }
                i++;
            }
        }
    }
    class ChildPart {
        constructor(startNode, endNode, parent, options) {
            this.type = CHILD_PART;
            this.__isConnected = true;
            this._$disconnectableChildren = void 0;
            this._$startNode = startNode;
            this._$endNode = endNode;
            this._$parent = parent;
            this.options = options;
            {
                this._textSanitizer = void 0;
            }
        }
        get _$isConnected() {
            var _a2, _b2;
            return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null &&
                _b2 !== void 0
                ? _b2
                : this.__isConnected;
        }
        get parentNode() {
            return wrap(this._$startNode).parentNode;
        }
        get startNode() {
            return this._$startNode;
        }
        get endNode() {
            return this._$endNode;
        }
        _$setValue(value, directiveParent = this) {
            value = resolveDirective(this, value, directiveParent);
            if (isPrimitive$1(value)) {
                if (value === nothing$1 || value == null || value === '') {
                    if (this._$committedValue !== nothing$1) {
                        this._$clear();
                    }
                    this._$committedValue = nothing$1;
                } else if (value !== this._$committedValue && value !== noChange$1) {
                    this._commitText(value);
                }
            } else if (value['_$litType$'] !== void 0) {
                this._commitTemplateResult(value);
            } else if (value.nodeType !== void 0) {
                this._commitNode(value);
            } else if (isIterable$1(value)) {
                this._commitIterable(value);
            } else {
                this._commitText(value);
            }
        }
        _insert(node, ref = this._$endNode) {
            return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);
        }
        _commitNode(value) {
            var _a2;
            if (this._$committedValue !== value) {
                this._$clear();
                if (sanitizerFactoryInternal !== noopSanitizer) {
                    const parentNodeName =
                        (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
                    if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {
                        this._insert(new Text('/* lit-html will not write TemplateResults to scripts and styles */'));
                        return;
                    }
                }
                this._$committedValue = this._insert(value);
            }
        }
        _commitText(value) {
            const node = wrap(this._$startNode).nextSibling;
            if (
                node !== null &&
                node.nodeType === 3 &&
                (this._$endNode === null
                    ? wrap(node).nextSibling === null
                    : node === wrap(this._$endNode).previousSibling)
            ) {
                {
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer();
                    }
                    value = this._textSanitizer(value);
                }
                node.data = value;
            } else {
                {
                    const textNode = document.createTextNode('');
                    this._commitNode(textNode);
                    if (this._textSanitizer === void 0) {
                        this._textSanitizer = createSanitizer();
                    }
                    value = this._textSanitizer(value);
                    textNode.data = value;
                }
            }
            this._$committedValue = value;
        }
        _commitTemplateResult(result) {
            var _a2;
            const { values, ['_$litType$']: type } = result;
            const template =
                typeof type === 'number'
                    ? this._$getTemplate(result)
                    : (type.el === void 0 && (type.el = Template$1.createElement(type.h, this.options)), type);
            if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template) {
                this._$committedValue._update(values);
            } else {
                const instance = new TemplateInstance$1(template, this);
                const fragment = instance._clone(this.options);
                instance._update(values);
                this._commitNode(fragment);
                this._$committedValue = instance;
            }
        }
        _$getTemplate(result) {
            let template = templateCache.get(result.strings);
            if (template === void 0) {
                templateCache.set(result.strings, (template = new Template$1(result)));
            }
            return template;
        }
        _commitIterable(value) {
            if (!isArray(this._$committedValue)) {
                this._$committedValue = [];
                this._$clear();
            }
            const itemParts = this._$committedValue;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                if (partIndex === itemParts.length) {
                    itemParts.push(
                        (itemPart = new ChildPart(
                            this._insert(createMarker$1()),
                            this._insert(createMarker$1()),
                            this,
                            this.options,
                        )),
                    );
                } else {
                    itemPart = itemParts[partIndex];
                }
                itemPart._$setValue(item);
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
                itemParts.length = partIndex;
            }
        }
        _$clear(start = wrap(this._$startNode).nextSibling, from) {
            var _a2;
            (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0
                ? void 0
                : _a2.call(this, false, true, from);
            while (start && start !== this._$endNode) {
                const n = wrap(start).nextSibling;
                wrap(start).remove();
                start = n;
            }
        }
        setConnected(isConnected) {
            var _a2;
            if (this._$parent === void 0) {
                this.__isConnected = isConnected;
                (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0
                    ? void 0
                    : _a2.call(this, isConnected);
            } else {
                throw new Error('part.setConnected() may only be called on a RootPart returned from render().');
            }
        }
    }
    class AttributePart$1 {
        constructor(element, name2, strings, parent, options) {
            this.type = ATTRIBUTE_PART;
            this._$committedValue = nothing$1;
            this._$disconnectableChildren = void 0;
            this.element = element;
            this.name = name2;
            this._$parent = parent;
            this.options = options;
            if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
                this._$committedValue = new Array(strings.length - 1).fill(nothing$1);
                this.strings = strings;
            } else {
                this._$committedValue = nothing$1;
            }
            {
                this._sanitizer = void 0;
            }
        }
        get tagName() {
            return this.element.tagName;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value, directiveParent = this, valueIndex, noCommit) {
            const strings = this.strings;
            let change = false;
            if (strings === void 0) {
                value = resolveDirective(this, value, directiveParent, 0);
                change = !isPrimitive$1(value) || (value !== this._$committedValue && value !== noChange$1);
                if (change) {
                    this._$committedValue = value;
                }
            } else {
                const values = value;
                value = strings[0];
                let i, v;
                for (i = 0; i < strings.length - 1; i++) {
                    v = resolveDirective(this, values[valueIndex + i], directiveParent, i);
                    if (v === noChange$1) {
                        v = this._$committedValue[i];
                    }
                    change || (change = !isPrimitive$1(v) || v !== this._$committedValue[i]);
                    if (v === nothing$1) {
                        value = nothing$1;
                    } else if (value !== nothing$1) {
                        value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
                    }
                    this._$committedValue[i] = v;
                }
            }
            if (change && !noCommit) {
                this._commitValue(value);
            }
        }
        _commitValue(value) {
            if (value === nothing$1) {
                wrap(this.element).removeAttribute(this.name);
            } else {
                {
                    if (this._sanitizer === void 0) {
                        this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
                    }
                    value = this._sanitizer(value !== null && value !== void 0 ? value : '');
                }
                wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : '');
            }
        }
    }
    class PropertyPart$1 extends AttributePart$1 {
        constructor() {
            super(...arguments);
            this.type = PROPERTY_PART;
        }
        _commitValue(value) {
            {
                if (this._sanitizer === void 0) {
                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
                }
                value = this._sanitizer(value);
            }
            this.element[this.name] = value === nothing$1 ? void 0 : value;
        }
    }
    class BooleanAttributePart$1 extends AttributePart$1 {
        constructor() {
            super(...arguments);
            this.type = BOOLEAN_ATTRIBUTE_PART;
        }
        _commitValue(value) {
            if (value && value !== nothing$1) {
                wrap(this.element).setAttribute(this.name, '');
            } else {
                wrap(this.element).removeAttribute(this.name);
            }
        }
    }
    class EventPart$1 extends AttributePart$1 {
        constructor() {
            super(...arguments);
            this.type = EVENT_PART;
        }
        _$setValue(newListener, directiveParent = this) {
            var _a2;
            newListener =
                (_a2 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0
                    ? _a2
                    : nothing$1;
            if (newListener === noChange$1) {
                return;
            }
            const oldListener = this._$committedValue;
            const shouldRemoveListener =
                (newListener === nothing$1 && oldListener !== nothing$1) ||
                newListener.capture !== oldListener.capture ||
                newListener.once !== oldListener.once ||
                newListener.passive !== oldListener.passive;
            const shouldAddListener = newListener !== nothing$1 && (oldListener === nothing$1 || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.name, this, oldListener);
            }
            if (shouldAddListener) {
                this.element.addEventListener(this.name, this, newListener);
            }
            this._$committedValue = newListener;
        }
        handleEvent(event2) {
            var _a2, _b2;
            if (typeof this._$committedValue === 'function') {
                this._$committedValue.call(
                    (_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null &&
                        _b2 !== void 0
                        ? _b2
                        : this.element,
                    event2,
                );
            } else {
                this._$committedValue.handleEvent(event2);
            }
        }
    }
    class ElementPart {
        constructor(element, parent, options) {
            this.element = element;
            this.type = ELEMENT_PART;
            this._$disconnectableChildren = void 0;
            this._$parent = parent;
            this.options = options;
        }
        get _$isConnected() {
            return this._$parent._$isConnected;
        }
        _$setValue(value) {
            resolveDirective(this, value);
        }
    }
    (_d = (_c$1 = globalThis)['litHtmlPlatformSupport']) === null || _d === void 0
        ? void 0
        : _d.call(_c$1, Template$1, ChildPart);
    ((_e = (_f = globalThis)['litHtmlVersions']) !== null && _e !== void 0 ? _e : (_f['litHtmlVersions'] = [])).push(
        '2.0.0-rc.4',
    );
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const stringsCache = new Map();
    const withStatic =
        (coreTag) =>
        (strings, ...values) => {
            var _a2;
            const l = values.length;
            let staticValue;
            let dynamicValue;
            const staticStrings = [];
            const dynamicValues = [];
            let i = 0;
            let hasStatics = false;
            let s;
            while (i < l) {
                s = strings[i];
                while (
                    i < l &&
                    ((dynamicValue = values[i]),
                    (staticValue = (_a2 = dynamicValue) === null || _a2 === void 0 ? void 0 : _a2['_$litStatic$'])) !==
                        void 0
                ) {
                    s += staticValue + strings[++i];
                    hasStatics = true;
                }
                dynamicValues.push(dynamicValue);
                staticStrings.push(s);
                i++;
            }
            if (i === l) {
                staticStrings.push(strings[l]);
            }
            if (hasStatics) {
                const key = staticStrings.join('$$lit$$');
                strings = stringsCache.get(key);
                if (strings === void 0) {
                    stringsCache.set(key, (strings = staticStrings));
                }
                values = dynamicValues;
            }
            return coreTag(strings, ...values);
        };
    const html$2 = withStatic(html$1);
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const decorateProperty =
        ({ finisher, descriptor }) =>
        (protoOrDescriptor, name2) => {
            var _a2;
            if (name2 !== void 0) {
                const ctor = protoOrDescriptor.constructor;
                if (descriptor !== void 0) {
                    Object.defineProperty(protoOrDescriptor, name2, descriptor(name2));
                }
                finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
            } else {
                const key =
                    (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
                const info =
                    descriptor != void 0
                        ? {
                              kind: 'method',
                              placement: 'prototype',
                              key,
                              descriptor: descriptor(protoOrDescriptor.key),
                          }
                        : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
                if (finisher != void 0) {
                    info.finisher = function (ctor) {
                        finisher(ctor, key);
                    };
                }
                return info;
            }
        };
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    function queryAsync$1(selector) {
        return decorateProperty({
            descriptor: (_name) => ({
                get() {
                    return __async(this, null, function* () {
                        var _a2;
                        yield this.updateComplete;
                        return (_a2 = this.renderRoot) === null || _a2 === void 0
                            ? void 0
                            : _a2.querySelector(selector);
                    });
                },
                enumerable: true,
                configurable: true,
            }),
        });
    }
    var __isNode = () => {
        return typeof process !== 'undefined' && process.release && process.release.name === 'node';
    };
    var _a$2, _b, _c;
    class SDatePickerComponentInterface extends SInterface {}
    SDatePickerComponentInterface.definition = {
        name: {
            type: 'String',
            required: true,
        },
        value: {
            type: 'String',
        },
        placeholder: {
            type: 'String',
        },
        format: {
            type: 'String',
            default: (_a$2 = SSugarConfig.get('datetime.dateFormat')) !== null && _a$2 !== void 0 ? _a$2 : 'YYYY-MM-DD',
        },
        firstDay: {
            type: 'Number',
            description: 'Specify the first day of the week. 0 is sunday, 1 monday, etc...',
            default: 1,
        },
        minDate: {
            type: 'String',
            description:
                'the minimum/earliest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())',
        },
        maxDate: {
            type: 'String',
            description:
                'the maximum/latest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())',
        },
        disableWeekends: {
            type: 'Boolean',
            description: 'disallow selection of Saturdays or Sundays',
            default: false,
        },
        yearRange: {
            type: {
                type: 'Array<Number>',
                splitChars: [','],
            },
            description: 'number of years either side (e.g. 10) or array of upper/lower range (e.g. [1900,2015])',
        },
        rtl: {
            type: 'Boolean',
            description: 'reverse the calendar for right-to-left languages',
            default: !__isNode()
                ? ((_b = document.querySelector('html')) === null || _b === void 0
                      ? void 0
                      : _b.getAttribute('dir')) === 'rtl'
                : false,
        },
        i18n: {
            type: 'String',
            description: 'language defaults for month and weekday names',
            default:
                (_c = SSugarConfig.get('datetime.i18n')) !== null && _c !== void 0
                    ? _c
                    : {
                          previousMonth: 'Previous Month',
                          nextMonth: 'Next Month',
                          months: [
                              'January',
                              'February',
                              'March',
                              'April',
                              'May',
                              'June',
                              'July',
                              'August',
                              'September',
                              'October',
                              'November',
                              'December',
                          ],
                          weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                          weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                      },
        },
        numberOfMonths: {
            type: 'Number',
            description: 'number of visible calendars',
            default: 1,
        },
        events: {
            type: {
                type: 'Array<String>',
                splitChars: [','],
            },
            description: `array of dates that you would like to differentiate from regular days (e.g. ['Sat Jun 28 2017', 'Sun Jun 29 2017', 'Tue Jul 01 2017',])`,
            default: [],
        },
        button: {
            type: 'Boolean',
            default: true,
        },
        arrowIcon: {
            type: 'String',
            default:
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.122 24l-4.122-4 8-8-8-8 4.122-4 11.878 12z"/></svg>',
        },
        calendarIcon: {
            type: 'String',
            default:
                '<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="calendar-alt" class="svg-inline--fa fa-calendar-alt fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"></path></svg>',
        },
    };
    function plainObject(object) {
        if (!object) return false;
        if (typeof object !== 'object') return false;
        if (object.constructor && object.constructor.name !== 'Object') return false;
        if (Object.prototype.toString.call(object) !== '[object Object]') return false;
        if (object !== Object(object)) return false;
        return true;
    }
    function __deepMerge(...args) {
        function merge(firstObj, secondObj) {
            const newObj = {};
            if (!firstObj && secondObj) return secondObj;
            if (!secondObj && firstObj) return firstObj;
            if (!firstObj && !secondObj) return {};
            const firstProps = Object.getOwnPropertyNames(firstObj);
            firstProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(firstObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else {
                    newObj[key] = firstObj[key];
                }
            });
            const secondProps = Object.getOwnPropertyNames(secondObj);
            secondProps.forEach((key) => {
                const desc = Object.getOwnPropertyDescriptor(secondObj, key);
                if (desc.set || desc.get) {
                    Object.defineProperty(newObj, key, desc);
                } else if (plainObject(newObj[key]) && plainObject(secondObj[key])) {
                    newObj[key] = merge(newObj[key], secondObj[key]);
                } else {
                    newObj[key] = secondObj[key];
                }
            });
            return newObj;
        }
        let currentObj = {};
        for (let i = 0; i < args.length; i++) {
            const toMergeObj = args[i];
            currentObj = merge(currentObj, toMergeObj);
        }
        return currentObj;
    }
    function whenInteract(elm, settings) {
        return new Promise((resolve, reject) => {
            settings = __deepMerge(
                {
                    mouse: {
                        over: true,
                        out: true,
                        click: true,
                    },
                    touch: {
                        start: true,
                        end: true,
                    },
                    focus: true,
                },
                settings !== null && settings !== void 0 ? settings : {},
            );
            function interacted(interaction) {
                resolve(interaction);
                elm.removeEventListener('mouseover', mouseover);
                elm.removeEventListener('mouseout', mouseout);
                elm.removeEventListener('click', click);
                elm.removeEventListener('touchstart', touchstart);
                elm.removeEventListener('touchend', touchend);
                elm.removeEventListener('focus', focus);
                elm.removeEventListener('focusin', focus);
            }
            function mouseover(e) {
                interacted('mouseover');
            }
            if (settings.mouse === true || settings.mouse.over) {
                elm.addEventListener('mouseover', mouseover);
            }
            function mouseout(e) {
                interacted('mouseout');
            }
            if (settings.mouse === true || settings.mouse.out) {
                elm.addEventListener('mouseout', mouseout);
            }
            function click(e) {
                interacted('click');
            }
            if (settings.mouse === true || settings.mouse.click) {
                elm.addEventListener('click', click);
            }
            function touchstart(e) {
                interacted('touchstart');
            }
            if (settings.touch === true || settings.touch.start) {
                elm.addEventListener('touchstart', touchstart);
            }
            function touchend(e) {
                interacted('touchend');
            }
            if (settings.touch === true || settings.touch.start) {
                elm.addEventListener('touchend', touchend);
            }
            function focus(e) {
                interacted('focus');
            }
            if (settings.focus === true) {
                elm.addEventListener('focus', focus);
                elm.addEventListener('focusin', focus);
            }
        });
    }
    var __css$2 =
        's-date-picker {\n    display: inline-block;\n}\n\n    s-date-picker:not([mounted]) > * {\n        /* display: none; */\n    }\n.s-date-picker {\n    display: flex;\n    width: 100%;\n}\n\n.s-date-picker__input {\n    flex-grow: 1;\n    padding: var(--s-theme-ui-datePicker-padding, 6px 12px);\n}\n.s-date-picker__button {\n    padding: var(--s-theme-ui-datePicker-padding, 6px 12px);\n}\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__input {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n        }\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__button {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__button {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n            order: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__input {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n            order: 1;\n        }\n\n.s-date-picker__button svg {\n        height: 1em;\n    }\n\n.s-date-picker__button svg,\n        .s-date-picker__button svg > * {\n            box-shadow: 0px 0px 3px 0 hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + -10) * 1%),var(--s-theme-color-ui-a, 1));\n        }\n';
    var __themeCss =
        "/**\n * This theme is an example to show how you can create your own.\n */\n\n.pika-lendar {\n    width: auto;\n}\n\n.pika-single.s-pikaday {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-foreground-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-main-foreground-a, 1));\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-surface-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-main-surface-a, 1));\n    border: 1px solid hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-border-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-border-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-border-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-border-a, 1));box-shadow: var(--s-theme-depth-100, 0);\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding: var(--s-theme-ui-colorPicker-padding, 6px 12px);\n}\n\n.s-pikaday .pika-label {\n    background-color: transparent;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    top: -0.5em;\n}\n\n.s-pikaday .pika-prev,\n.s-pikaday .is-rtl .pika-next,\n.s-pikaday .pika-next,\n.s-pikaday .is-rtl .pika-prev {\n    background: none;\n    position: relative;\n    display: inline-block;\n    font-size: 0;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    overflow: visible;\n    background: red;\n    opacity: 1;\n    width: 1em;\n    height: 1em;\n    opacity: 0.7;\n}\n\n.s-pikaday .pika-prev:hover,\n    .s-pikaday .pika-prev:focus,\n    .s-pikaday .is-rtl .pika-next:hover,\n    .s-pikaday .is-rtl .pika-next:focus,\n    .s-pikaday .pika-next:hover,\n    .s-pikaday .pika-next:focus,\n    .s-pikaday .is-rtl .pika-prev:hover,\n    .s-pikaday .is-rtl .pika-prev:focus {\n        opacity: 1;\n    }\n\n.s-pikaday .pika-prev:after, .s-pikaday .is-rtl .pika-next:after, .s-pikaday .pika-next:after, .s-pikaday .is-rtl .pika-prev:after {\n        content: '\u276F';\n        color: inherit;\n        font-size: 1rem;\n        position: absolute;\n        top: 0;\n        left: -2.2em;\n    }\n.s-pikaday .pika-prev:after, .s-pikaday.is-rtl .pika-next:after {\n        transform: rotate(180deg);\n        left: 1em;\n    }\n.s-pikaday.is-rtl .pika-prev:after {\n        transform: rotate(0deg) !important;\n        left: -2em;\n    }\n\n.s-pikaday .pika-table {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding: var(--s-theme-ui-colorPicker-padding, 6px 12px);\n}\n\n.s-pikaday .pika-table th * {\n    text-decoration: none;\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n}\n\n.s-pikaday .pika-button {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    padding: var(--s-theme-ui-colorPicker-padding, 6px 12px);\n}\n\n.s-pikaday .pika-week {\n    text-decoration: none;\n}\n\n.s-pikaday .is-today .pika-button {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    outline: none;\n}\n\n.s-pikaday .is-selected .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 0.5));\n    box-shadow: none !important;\n}\n\n.s-pikaday .is-disabled .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    opacity: 0.3;\n}\n\n.s-pikaday .pika-button:hover {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-foreground-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-foreground-a, 1)) !important;\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1)) !important;\n}\n";
    var __baseCss$1 = `@charset "UTF-8";

/*!
 * Pikaday
 * Copyright \xA9 2014 David Bushell | BSD & MIT license | https://dbushell.com/
 */

.pika-single {
    z-index: 9999;
    display: block;
    position: relative;
    color: #333;
    background: #fff;
    border: 1px solid #ccc;
    border-bottom-color: #bbb;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

/*
clear child float (pika-lendar), using the famous micro clearfix hack
http://nicolasgallagher.com/micro-clearfix-hack/
*/
.pika-single:before,
.pika-single:after {
    content: " ";
    display: table;
}
.pika-single:after { clear: both }

.pika-single.is-hidden {
    display: none;
}

.pika-single.is-bound {
    position: absolute;
    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);
}

.pika-lendar {
    float: left;
    width: 240px;
    margin: 8px;
}

.pika-title {
    position: relative;
    text-align: center;
}

.pika-label {
    display: inline-block;
    position: relative;
    z-index: 9999;
    overflow: hidden;
    margin: 0;
    padding: 5px 3px;
    font-size: 14px;
    line-height: 20px;
    font-weight: bold;
    background-color: #fff;
}
.pika-title select {
    cursor: pointer;
    position: absolute;
    z-index: 9998;
    margin: 0;
    left: 0;
    top: 5px;
    opacity: 0;
}

.pika-prev,
.pika-next {
    display: block;
    cursor: pointer;
    position: relative;
    outline: none;
    border: 0;
    padding: 0;
    width: 20px;
    height: 30px;
    /* hide text using text-indent trick, using width value (it's enough) */
    text-indent: 20px;
    white-space: nowrap;
    overflow: hidden;
    background-color: transparent;
    background-position: center center;
    background-repeat: no-repeat;
    background-size: 75% 75%;
    opacity: .5;
}

.pika-prev:hover,
.pika-next:hover {
    opacity: 1;
}

.pika-prev,
.is-rtl .pika-next {
    float: left;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');
}

.pika-next,
.is-rtl .pika-prev {
    float: right;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');
}

.pika-prev.is-disabled,
.pika-next.is-disabled {
    cursor: default;
    opacity: .2;
}

.pika-select {
    display: inline-block;
}

.pika-table {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    border: 0;
}

.pika-table th,
.pika-table td {
    width: 14.285714285714286%;
    padding: 0;
}

.pika-table th {
    color: #999;
    font-size: 12px;
    line-height: 25px;
    font-weight: bold;
    text-align: center;
}

.pika-button {
    cursor: pointer;
    display: block;
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    outline: none;
    border: 0;
    margin: 0;
    width: 100%;
    padding: 5px;
    color: #666;
    font-size: 12px;
    line-height: 15px;
    text-align: right;
    background: #f5f5f5;
    height: initial;
}

.pika-week {
    font-size: 11px;
    color: #999;
}

.is-today .pika-button {
    color: #33aaff;
    font-weight: bold;
}

.is-selected .pika-button,
.has-event .pika-button {
    color: #fff;
    font-weight: bold;
    background: #33aaff;
    box-shadow: inset 0 1px 3px #178fe5;
    border-radius: 3px;
}

.has-event .pika-button {
    background: #005da9;
    box-shadow: inset 0 1px 3px #0076c9;
}

.is-disabled .pika-button,
.is-inrange .pika-button {
    background: #D5E9F7;
}

.is-startrange .pika-button {
    color: #fff;
    background: #6CB31D;
    box-shadow: none;
    border-radius: 3px;
}

.is-endrange .pika-button {
    color: #fff;
    background: #33aaff;
    box-shadow: none;
    border-radius: 3px;
}

.is-disabled .pika-button {
    pointer-events: none;
    cursor: default;
    color: #999;
    opacity: .3;
}

.is-outside-current-month .pika-button {
    color: #999;
    opacity: .3;
}

.is-selection-disabled {
    pointer-events: none;
    cursor: default;
}

.pika-button:hover,
.pika-row.pick-whole-week:hover .pika-button {
    color: #fff;
    background: #ff8000;
    box-shadow: none;
    border-radius: 3px;
}

/* styling for abbr */
.pika-table abbr {
    border-bottom: none;
    cursor: help;
}
`;
    var __decorate$3 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d2;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d2 = decorators[i])) r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$7 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SDatePicker extends SLitElement {
        constructor() {
            super();
            this._component = void 0;
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SDatePickerComponentInterface,
                    defaultProps: {},
                },
            });
        }
        static get properties() {
            return SComponentUtils.properties({}, SDatePickerComponentInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(`
                ${__baseCss$1}
                ${__css$2}
                ${__themeCss}
            `)}
        `;
        }
        firstUpdated() {
            return __awaiter$7(this, void 0, void 0, function* () {
                const $input = yield this._$input;
                let $button;
                if (this._component.props.button) $button = yield this._$button;
                yield whenInteract(this);
                const _this = this;
                this._picker = new __pikaday({
                    field: $input,
                    format: this._component.props.format,
                    trigger: $button,
                    firstDay: this._component.props.firstDay,
                    minDate: this.parseDate(this._component.props.minDate),
                    maxDate: this.parseDate(this._component.props.maxDate),
                    disableWeekends: this._component.props.disableWeekends,
                    yearRange: this._component.props.yearRange,
                    isRTL: this._component.props.rtl,
                    i18n: this._component.props.i18n,
                    numberOfMonths: this._component.props.numberOfMonths,
                    events: this._component.props.events,
                    defaultDate: this._component.props.value,
                    theme: this._component.props.defaultStyle ? 's-pikaday' : '',
                    toString(date, format) {
                        return _this.dateToString(date, format);
                    },
                    parse(dateString, format) {
                        return _this.parseDate(dateString, format);
                    },
                    onSelect: () => {
                        this._dispatchEvent('select');
                    },
                    onOpen: () => {
                        this._dispatchEvent('open');
                    },
                    onClose: () => {
                        this._dispatchEvent('close');
                    },
                    onDraw: () => {
                        this._dispatchEvent('draw');
                    },
                });
                Array.from(this.classList).forEach((cls) => {
                    if (cls.match(/^s-cs/)) this._picker.el.classList.add(cls);
                });
                [
                    'toString',
                    'getDate',
                    'setDate',
                    'getMoment',
                    'clear',
                    'gotoDate',
                    'gotoToday',
                    'gotoMonth',
                    'nextMonth',
                    'prevMonth',
                    'gotoYear',
                    'setMinDate',
                    'setMaxDate',
                    'setStartRange',
                    'setEndRange',
                    'isVisible',
                    'show',
                    'adjustPosition',
                    'hide',
                    'destroy',
                ].forEach((key) => {
                    this[key] = this._picker[key].bind(this._picker);
                });
            });
        }
        parseDate(dateString, format = this._component.props.format) {
            return hooks(dateString, format).toDate();
        }
        dateToString(date, format = this._component.props.format) {
            return hooks(date).format(format);
        }
        _dispatchEvent(eventName) {
            const event2 = new CustomEvent(eventName, {
                detail: {
                    dateStr: this._picker.toString(),
                    date: this._picker.getDate(),
                },
            });
            this.dispatchEvent(event2);
        }
        createRenderRoot() {
            return this;
        }
        render() {
            return html$4`
            <div class="${this._component.className('')}">
                <input
                    class="${this._component.className('__input', 's-input')}"
                    type="text"
                    name="${this.name}"
                    ?rtl="${this.rtl}"
                    placeholder="${this.placeholder}"
                    autocomplete="off"
                />
                ${
                    this.button
                        ? html$4`
                          <button class="${this._component.className('__button', 's-btn')}">
                              ${html$2([this.calendarIcon])}
                          </button>
                      `
                        : ''
                }
            </div>
        `;
        }
    }
    __decorate$3([queryAsync$1('input')], SDatePicker.prototype, '_$input', void 0);
    __decorate$3([queryAsync$1('button')], SDatePicker.prototype, '_$button', void 0);
    function webcomponent$5(props = {}, tagName = 's-date-picker') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SDatePicker);
    }
    var pickr_min = { exports: {} };
    /*! Pickr 1.8.1 MIT | https://github.com/Simonwep/pickr */
    (function (module2, exports) {
        !(function (t, e) {
            module2.exports = e();
        })(window, function () {
            return (function (t) {
                var e = {};
                function o(n) {
                    if (e[n]) return e[n].exports;
                    var i = (e[n] = { i: n, l: false, exports: {} });
                    return t[n].call(i.exports, i, i.exports, o), (i.l = true), i.exports;
                }
                return (
                    (o.m = t),
                    (o.c = e),
                    (o.d = function (t2, e2, n) {
                        o.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
                    }),
                    (o.r = function (t2) {
                        typeof Symbol != 'undefined' &&
                            Symbol.toStringTag &&
                            Object.defineProperty(t2, Symbol.toStringTag, { value: 'Module' }),
                            Object.defineProperty(t2, '__esModule', { value: true });
                    }),
                    (o.t = function (t2, e2) {
                        if ((1 & e2 && (t2 = o(t2)), 8 & e2)) return t2;
                        if (4 & e2 && typeof t2 == 'object' && t2 && t2.__esModule) return t2;
                        var n = Object.create(null);
                        if (
                            (o.r(n),
                            Object.defineProperty(n, 'default', { enumerable: true, value: t2 }),
                            2 & e2 && typeof t2 != 'string')
                        )
                            for (var i in t2)
                                o.d(
                                    n,
                                    i,
                                    function (e3) {
                                        return t2[e3];
                                    }.bind(null, i),
                                );
                        return n;
                    }),
                    (o.n = function (t2) {
                        var e2 =
                            t2 && t2.__esModule
                                ? function () {
                                      return t2.default;
                                  }
                                : function () {
                                      return t2;
                                  };
                        return o.d(e2, 'a', e2), e2;
                    }),
                    (o.o = function (t2, e2) {
                        return Object.prototype.hasOwnProperty.call(t2, e2);
                    }),
                    (o.p = ''),
                    o((o.s = 0))
                );
            })([
                function (t, e, o) {
                    o.r(e);
                    var n = {};
                    function i(t2, e2, o2, n2, i2 = {}) {
                        e2 instanceof HTMLCollection || e2 instanceof NodeList
                            ? (e2 = Array.from(e2))
                            : Array.isArray(e2) || (e2 = [e2]),
                            Array.isArray(o2) || (o2 = [o2]);
                        for (const r2 of e2)
                            for (const e3 of o2) r2[t2](e3, n2, __spreadValues({ capture: false }, i2));
                        return Array.prototype.slice.call(arguments, 1);
                    }
                    o.r(n),
                        o.d(n, 'on', function () {
                            return r;
                        }),
                        o.d(n, 'off', function () {
                            return s;
                        }),
                        o.d(n, 'createElementFromString', function () {
                            return a;
                        }),
                        o.d(n, 'createFromTemplate', function () {
                            return l;
                        }),
                        o.d(n, 'eventPath', function () {
                            return c;
                        }),
                        o.d(n, 'resolveElement', function () {
                            return p;
                        }),
                        o.d(n, 'adjustableInputNumbers', function () {
                            return u;
                        });
                    const r = i.bind(null, 'addEventListener'),
                        s = i.bind(null, 'removeEventListener');
                    function a(t2) {
                        const e2 = document.createElement('div');
                        return (e2.innerHTML = t2.trim()), e2.firstElementChild;
                    }
                    function l(t2) {
                        const e2 = (t3, e3) => {
                                const o3 = t3.getAttribute(e3);
                                return t3.removeAttribute(e3), o3;
                            },
                            o2 = (t3, n2 = {}) => {
                                const i2 = e2(t3, ':obj'),
                                    r2 = e2(t3, ':ref'),
                                    s2 = i2 ? (n2[i2] = {}) : n2;
                                r2 && (n2[r2] = t3);
                                for (const n3 of Array.from(t3.children)) {
                                    const t4 = e2(n3, ':arr'),
                                        i3 = o2(n3, t4 ? {} : s2);
                                    t4 && (s2[t4] || (s2[t4] = [])).push(Object.keys(i3).length ? i3 : n3);
                                }
                                return n2;
                            };
                        return o2(a(t2));
                    }
                    function c(t2) {
                        let e2 = t2.path || (t2.composedPath && t2.composedPath());
                        if (e2) return e2;
                        let o2 = t2.target.parentElement;
                        for (e2 = [t2.target, o2]; (o2 = o2.parentElement); ) e2.push(o2);
                        return e2.push(document, window), e2;
                    }
                    function p(t2) {
                        return t2 instanceof Element
                            ? t2
                            : typeof t2 == 'string'
                            ? t2
                                  .split(/>>/g)
                                  .reduce(
                                      (t3, e2, o2, n2) => (
                                          (t3 = t3.querySelector(e2)), o2 < n2.length - 1 ? t3.shadowRoot : t3
                                      ),
                                      document,
                                  )
                            : null;
                    }
                    function u(t2, e2 = (t3) => t3) {
                        function o2(o3) {
                            const n2 =
                                [1e-3, 0.01, 0.1][Number(o3.shiftKey || 2 * o3.ctrlKey)] * (o3.deltaY < 0 ? 1 : -1);
                            let i2 = 0,
                                r2 = t2.selectionStart;
                            (t2.value = t2.value.replace(/[\d.]+/g, (t3, o4) =>
                                o4 <= r2 && o4 + t3.length >= r2 ? ((r2 = o4), e2(Number(t3), n2, i2)) : (i2++, t3),
                            )),
                                t2.focus(),
                                t2.setSelectionRange(r2, r2),
                                o3.preventDefault(),
                                t2.dispatchEvent(new Event('input'));
                        }
                        r(t2, 'focus', () => r(window, 'wheel', o2, { passive: false })),
                            r(t2, 'blur', () => s(window, 'wheel', o2));
                    }
                    const { min: h, max: d, floor: f, round: m } = Math;
                    function v(t2, e2, o2) {
                        (e2 /= 100), (o2 /= 100);
                        const n2 = f((t2 = (t2 / 360) * 6)),
                            i2 = t2 - n2,
                            r2 = o2 * (1 - e2),
                            s2 = o2 * (1 - i2 * e2),
                            a2 = o2 * (1 - (1 - i2) * e2),
                            l2 = n2 % 6;
                        return [
                            255 * [o2, s2, r2, r2, a2, o2][l2],
                            255 * [a2, o2, o2, s2, r2, r2][l2],
                            255 * [r2, r2, a2, o2, o2, s2][l2],
                        ];
                    }
                    function b(t2, e2, o2) {
                        const n2 = ((2 - (e2 /= 100)) * (o2 /= 100)) / 2;
                        return (
                            n2 !== 0 &&
                                (e2 = n2 === 1 ? 0 : n2 < 0.5 ? (e2 * o2) / (2 * n2) : (e2 * o2) / (2 - 2 * n2)),
                            [t2, 100 * e2, 100 * n2]
                        );
                    }
                    function y(t2, e2, o2) {
                        const n2 = h((t2 /= 255), (e2 /= 255), (o2 /= 255)),
                            i2 = d(t2, e2, o2),
                            r2 = i2 - n2;
                        let s2, a2;
                        if (r2 === 0) s2 = a2 = 0;
                        else {
                            a2 = r2 / i2;
                            const n3 = ((i2 - t2) / 6 + r2 / 2) / r2,
                                l2 = ((i2 - e2) / 6 + r2 / 2) / r2,
                                c2 = ((i2 - o2) / 6 + r2 / 2) / r2;
                            t2 === i2
                                ? (s2 = c2 - l2)
                                : e2 === i2
                                ? (s2 = 1 / 3 + n3 - c2)
                                : o2 === i2 && (s2 = 2 / 3 + l2 - n3),
                                s2 < 0 ? (s2 += 1) : s2 > 1 && (s2 -= 1);
                        }
                        return [360 * s2, 100 * a2, 100 * i2];
                    }
                    function g(t2, e2, o2, n2) {
                        (e2 /= 100), (o2 /= 100);
                        return [
                            ...y(
                                255 * (1 - h(1, (t2 /= 100) * (1 - (n2 /= 100)) + n2)),
                                255 * (1 - h(1, e2 * (1 - n2) + n2)),
                                255 * (1 - h(1, o2 * (1 - n2) + n2)),
                            ),
                        ];
                    }
                    function _(t2, e2, o2) {
                        e2 /= 100;
                        const n2 = ((2 * (e2 *= (o2 /= 100) < 0.5 ? o2 : 1 - o2)) / (o2 + e2)) * 100,
                            i2 = 100 * (o2 + e2);
                        return [t2, isNaN(n2) ? 0 : n2, i2];
                    }
                    function w(t2) {
                        return y(...t2.match(/.{2}/g).map((t3) => parseInt(t3, 16)));
                    }
                    function A(t2) {
                        t2 = t2.match(/^[a-zA-Z]+$/)
                            ? (function (t3) {
                                  if (t3.toLowerCase() === 'black') return '#000';
                                  const e3 = document.createElement('canvas').getContext('2d');
                                  return (e3.fillStyle = t3), e3.fillStyle === '#000' ? null : e3.fillStyle;
                              })(t2)
                            : t2;
                        const e2 = {
                                cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i,
                                rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                                hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                                hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                                hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i,
                            },
                            o2 = (t3) => t3.map((t4) => (/^(|\d+)\.\d+|\d+$/.test(t4) ? Number(t4) : void 0));
                        let n2;
                        t: for (const i2 in e2) {
                            if (!(n2 = e2[i2].exec(t2))) continue;
                            const r2 = (t3) => !!n2[2] == (typeof t3 == 'number');
                            switch (i2) {
                                case 'cmyk': {
                                    const [, t3, e3, r3, s2] = o2(n2);
                                    if (t3 > 100 || e3 > 100 || r3 > 100 || s2 > 100) break t;
                                    return { values: g(t3, e3, r3, s2), type: i2 };
                                }
                                case 'rgba': {
                                    const [, , , t3, e3, s2, a2] = o2(n2);
                                    if (t3 > 255 || e3 > 255 || s2 > 255 || a2 < 0 || a2 > 1 || !r2(a2)) break t;
                                    return { values: [...y(t3, e3, s2), a2], a: a2, type: i2 };
                                }
                                case 'hexa': {
                                    let [, t3] = n2;
                                    (t3.length !== 4 && t3.length !== 3) ||
                                        (t3 = t3
                                            .split('')
                                            .map((t4) => t4 + t4)
                                            .join(''));
                                    const e3 = t3.substring(0, 6);
                                    let o3 = t3.substring(6);
                                    return (
                                        (o3 = o3 ? parseInt(o3, 16) / 255 : void 0),
                                        { values: [...w(e3), o3], a: o3, type: i2 }
                                    );
                                }
                                case 'hsla': {
                                    const [, , , t3, e3, s2, a2] = o2(n2);
                                    if (t3 > 360 || e3 > 100 || s2 > 100 || a2 < 0 || a2 > 1 || !r2(a2)) break t;
                                    return { values: [..._(t3, e3, s2), a2], a: a2, type: i2 };
                                }
                                case 'hsva': {
                                    const [, , , t3, e3, s2, a2] = o2(n2);
                                    if (t3 > 360 || e3 > 100 || s2 > 100 || a2 < 0 || a2 > 1 || !r2(a2)) break t;
                                    return { values: [t3, e3, s2, a2], a: a2, type: i2 };
                                }
                            }
                        }
                        return { values: null, type: null };
                    }
                    function C(t2 = 0, e2 = 0, o2 = 0, n2 = 1) {
                        const i2 =
                                (t3, e3) =>
                                (o3 = -1) =>
                                    e3(~o3 ? t3.map((t4) => Number(t4.toFixed(o3))) : t3),
                            r2 = {
                                h: t2,
                                s: e2,
                                v: o2,
                                a: n2,
                                toHSVA() {
                                    const t3 = [r2.h, r2.s, r2.v, r2.a];
                                    return (
                                        (t3.toString = i2(t3, (t4) => `hsva(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${r2.a})`)),
                                        t3
                                    );
                                },
                                toHSLA() {
                                    const t3 = [...b(r2.h, r2.s, r2.v), r2.a];
                                    return (
                                        (t3.toString = i2(t3, (t4) => `hsla(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${r2.a})`)),
                                        t3
                                    );
                                },
                                toRGBA() {
                                    const t3 = [...v(r2.h, r2.s, r2.v), r2.a];
                                    return (
                                        (t3.toString = i2(t3, (t4) => `rgba(${t4[0]}, ${t4[1]}, ${t4[2]}, ${r2.a})`)),
                                        t3
                                    );
                                },
                                toCMYK() {
                                    const t3 = (function (t4, e3, o3) {
                                        const n3 = v(t4, e3, o3),
                                            i3 = n3[0] / 255,
                                            r3 = n3[1] / 255,
                                            s2 = n3[2] / 255,
                                            a2 = h(1 - i3, 1 - r3, 1 - s2);
                                        return [
                                            100 * (a2 === 1 ? 0 : (1 - i3 - a2) / (1 - a2)),
                                            100 * (a2 === 1 ? 0 : (1 - r3 - a2) / (1 - a2)),
                                            100 * (a2 === 1 ? 0 : (1 - s2 - a2) / (1 - a2)),
                                            100 * a2,
                                        ];
                                    })(r2.h, r2.s, r2.v);
                                    return (
                                        (t3.toString = i2(
                                            t3,
                                            (t4) => `cmyk(${t4[0]}%, ${t4[1]}%, ${t4[2]}%, ${t4[3]}%)`,
                                        )),
                                        t3
                                    );
                                },
                                toHEXA() {
                                    const t3 = (function (t4, e4, o3) {
                                            return v(t4, e4, o3).map((t5) => m(t5).toString(16).padStart(2, '0'));
                                        })(r2.h, r2.s, r2.v),
                                        e3 =
                                            r2.a >= 1
                                                ? ''
                                                : Number((255 * r2.a).toFixed(0))
                                                      .toString(16)
                                                      .toUpperCase()
                                                      .padStart(2, '0');
                                    return e3 && t3.push(e3), (t3.toString = () => '#' + t3.join('').toUpperCase()), t3;
                                },
                                clone: () => C(r2.h, r2.s, r2.v, r2.a),
                            };
                        return r2;
                    }
                    const k = (t2) => Math.max(Math.min(t2, 1), 0);
                    function $(t2) {
                        const e2 = {
                                options: Object.assign({ lock: null, onchange: () => 0, onstop: () => 0 }, t2),
                                _keyboard(t3) {
                                    const { options: o3 } = e2,
                                        { type: n3, key: i3 } = t3;
                                    if (document.activeElement === o3.wrapper) {
                                        const { lock: o4 } = e2.options,
                                            r2 = i3 === 'ArrowUp',
                                            s2 = i3 === 'ArrowRight',
                                            a2 = i3 === 'ArrowDown',
                                            l2 = i3 === 'ArrowLeft';
                                        if (n3 === 'keydown' && (r2 || s2 || a2 || l2)) {
                                            let n4 = 0,
                                                i4 = 0;
                                            o4 === 'v'
                                                ? (n4 = r2 || s2 ? 1 : -1)
                                                : o4 === 'h'
                                                ? (n4 = r2 || s2 ? -1 : 1)
                                                : ((i4 = r2 ? -1 : a2 ? 1 : 0), (n4 = l2 ? -1 : s2 ? 1 : 0)),
                                                e2.update(k(e2.cache.x + 0.01 * n4), k(e2.cache.y + 0.01 * i4)),
                                                t3.preventDefault();
                                        } else i3.startsWith('Arrow') && (e2.options.onstop(), t3.preventDefault());
                                    }
                                },
                                _tapstart(t3) {
                                    r(document, ['mouseup', 'touchend', 'touchcancel'], e2._tapstop),
                                        r(document, ['mousemove', 'touchmove'], e2._tapmove),
                                        t3.cancelable && t3.preventDefault(),
                                        e2._tapmove(t3);
                                },
                                _tapmove(t3) {
                                    const { options: o3, cache: n3 } = e2,
                                        { lock: i3, element: r2, wrapper: s2 } = o3,
                                        a2 = s2.getBoundingClientRect();
                                    let l2 = 0,
                                        c2 = 0;
                                    if (t3) {
                                        const e3 = t3 && t3.touches && t3.touches[0];
                                        (l2 = t3 ? (e3 || t3).clientX : 0),
                                            (c2 = t3 ? (e3 || t3).clientY : 0),
                                            l2 < a2.left
                                                ? (l2 = a2.left)
                                                : l2 > a2.left + a2.width && (l2 = a2.left + a2.width),
                                            c2 < a2.top
                                                ? (c2 = a2.top)
                                                : c2 > a2.top + a2.height && (c2 = a2.top + a2.height),
                                            (l2 -= a2.left),
                                            (c2 -= a2.top);
                                    } else n3 && ((l2 = n3.x * a2.width), (c2 = n3.y * a2.height));
                                    i3 !== 'h' &&
                                        (r2.style.left = `calc(${(l2 / a2.width) * 100}% - ${r2.offsetWidth / 2}px)`),
                                        i3 !== 'v' &&
                                            (r2.style.top = `calc(${(c2 / a2.height) * 100}% - ${
                                                r2.offsetHeight / 2
                                            }px)`),
                                        (e2.cache = { x: l2 / a2.width, y: c2 / a2.height });
                                    const p2 = k(l2 / a2.width),
                                        u2 = k(c2 / a2.height);
                                    switch (i3) {
                                        case 'v':
                                            return o3.onchange(p2);
                                        case 'h':
                                            return o3.onchange(u2);
                                        default:
                                            return o3.onchange(p2, u2);
                                    }
                                },
                                _tapstop() {
                                    e2.options.onstop(),
                                        s(document, ['mouseup', 'touchend', 'touchcancel'], e2._tapstop),
                                        s(document, ['mousemove', 'touchmove'], e2._tapmove);
                                },
                                trigger() {
                                    e2._tapmove();
                                },
                                update(t3 = 0, o3 = 0) {
                                    const {
                                        left: n3,
                                        top: i3,
                                        width: r2,
                                        height: s2,
                                    } = e2.options.wrapper.getBoundingClientRect();
                                    e2.options.lock === 'h' && (o3 = t3),
                                        e2._tapmove({ clientX: n3 + r2 * t3, clientY: i3 + s2 * o3 });
                                },
                                destroy() {
                                    const { options: t3, _tapstart: o3, _keyboard: n3 } = e2;
                                    s(document, ['keydown', 'keyup'], n3),
                                        s([t3.wrapper, t3.element], 'mousedown', o3),
                                        s([t3.wrapper, t3.element], 'touchstart', o3, { passive: false });
                                },
                            },
                            { options: o2, _tapstart: n2, _keyboard: i2 } = e2;
                        return (
                            r([o2.wrapper, o2.element], 'mousedown', n2),
                            r([o2.wrapper, o2.element], 'touchstart', n2, { passive: false }),
                            r(document, ['keydown', 'keyup'], i2),
                            e2
                        );
                    }
                    function S(t2 = {}) {
                        t2 = Object.assign({ onchange: () => 0, className: '', elements: [] }, t2);
                        const e2 = r(t2.elements, 'click', (e3) => {
                            t2.elements.forEach((o2) =>
                                o2.classList[e3.target === o2 ? 'add' : 'remove'](t2.className),
                            ),
                                t2.onchange(e3),
                                e3.stopPropagation();
                        });
                        return { destroy: () => s(...e2) };
                    }
                    /*! NanoPop 2.1.0 MIT | https://github.com/Simonwep/nanopop */
                    const O = {
                            variantFlipOrder: { start: 'sme', middle: 'mse', end: 'ems' },
                            positionFlipOrder: { top: 'tbrl', right: 'rltb', bottom: 'btrl', left: 'lrbt' },
                            position: 'bottom',
                            margin: 8,
                        },
                        E = (t2, e2, o2) => {
                            const n2 =
                                typeof t2 != 'object' || t2 instanceof HTMLElement
                                    ? __spreadValues({ reference: t2, popper: e2 }, o2)
                                    : t2;
                            return {
                                update(t3 = n2) {
                                    const { reference: e3, popper: o3 } = Object.assign(n2, t3);
                                    if (!o3 || !e3) throw new Error('Popper- or reference-element missing.');
                                    return ((t4, e4, o4) => {
                                        const {
                                                container: n3,
                                                margin: i2,
                                                position: r2,
                                                variantFlipOrder: s2,
                                                positionFlipOrder: a2,
                                            } = __spreadValues(
                                                __spreadValues(
                                                    { container: document.documentElement.getBoundingClientRect() },
                                                    O,
                                                ),
                                                o4,
                                            ),
                                            { left: l2, top: c2 } = e4.style;
                                        (e4.style.left = '0'), (e4.style.top = '0');
                                        const p2 = t4.getBoundingClientRect(),
                                            u2 = e4.getBoundingClientRect(),
                                            h2 = {
                                                t: p2.top - u2.height - i2,
                                                b: p2.bottom + i2,
                                                r: p2.right + i2,
                                                l: p2.left - u2.width - i2,
                                            },
                                            d2 = {
                                                vs: p2.left,
                                                vm: p2.left + p2.width / 2 + -u2.width / 2,
                                                ve: p2.left + p2.width - u2.width,
                                                hs: p2.top,
                                                hm: p2.bottom - p2.height / 2 - u2.height / 2,
                                                he: p2.bottom - u2.height,
                                            },
                                            [f2, m2 = 'middle'] = r2.split('-'),
                                            v2 = a2[f2],
                                            b2 = s2[m2],
                                            { top: y2, left: g2, bottom: _2, right: w2 } = n3;
                                        for (const t5 of v2) {
                                            const o5 = t5 === 't' || t5 === 'b',
                                                n4 = h2[t5],
                                                [i3, r3] = o5 ? ['top', 'left'] : ['left', 'top'],
                                                [s3, a3] = o5 ? [u2.height, u2.width] : [u2.width, u2.height],
                                                [l3, c3] = o5 ? [_2, w2] : [w2, _2],
                                                [p3, f3] = o5 ? [y2, g2] : [g2, y2];
                                            if (!(n4 < p3 || n4 + s3 > l3))
                                                for (const s4 of b2) {
                                                    const l4 = d2[(o5 ? 'v' : 'h') + s4];
                                                    if (!(l4 < f3 || l4 + a3 > c3))
                                                        return (
                                                            (e4.style[r3] = l4 - u2[r3] + 'px'),
                                                            (e4.style[i3] = n4 - u2[i3] + 'px'),
                                                            t5 + s4
                                                        );
                                                }
                                        }
                                        return (e4.style.left = l2), (e4.style.top = c2), null;
                                    })(e3, o3, n2);
                                },
                            };
                        };
                    function L(t2, e2, o2) {
                        return (
                            e2 in t2
                                ? Object.defineProperty(t2, e2, {
                                      value: o2,
                                      enumerable: true,
                                      configurable: true,
                                      writable: true,
                                  })
                                : (t2[e2] = o2),
                            t2
                        );
                    }
                    class x {
                        constructor(t2) {
                            L(this, '_initializingActive', true),
                                L(this, '_recalc', true),
                                L(this, '_nanopop', null),
                                L(this, '_root', null),
                                L(this, '_color', C()),
                                L(this, '_lastColor', C()),
                                L(this, '_swatchColors', []),
                                L(this, '_setupAnimationFrame', null),
                                L(this, '_eventListener', {
                                    init: [],
                                    save: [],
                                    hide: [],
                                    show: [],
                                    clear: [],
                                    change: [],
                                    changestop: [],
                                    cancel: [],
                                    swatchselect: [],
                                }),
                                (this.options = t2 = Object.assign(__spreadValues({}, x.DEFAULT_OPTIONS), t2));
                            const {
                                swatches: e2,
                                components: o2,
                                theme: n2,
                                sliders: i2,
                                lockOpacity: r2,
                                padding: s2,
                            } = t2;
                            ['nano', 'monolith'].includes(n2) && !i2 && (t2.sliders = 'h'),
                                o2.interaction || (o2.interaction = {});
                            const { preview: a2, opacity: l2, hue: c2, palette: p2 } = o2;
                            (o2.opacity = !r2 && l2),
                                (o2.palette = p2 || a2 || l2 || c2),
                                this._preBuild(),
                                this._buildComponents(),
                                this._bindEvents(),
                                this._finalBuild(),
                                e2 && e2.length && e2.forEach((t3) => this.addSwatch(t3));
                            const { button: u2, app: h2 } = this._root;
                            (this._nanopop = E(u2, h2, { margin: s2 })),
                                u2.setAttribute('role', 'button'),
                                u2.setAttribute('aria-label', this._t('btn:toggle'));
                            const d2 = this;
                            this._setupAnimationFrame = requestAnimationFrame(function e3() {
                                if (!h2.offsetWidth) return requestAnimationFrame(e3);
                                d2.setColor(t2.default),
                                    d2._rePositioningPicker(),
                                    t2.defaultRepresentation &&
                                        ((d2._representation = t2.defaultRepresentation),
                                        d2.setColorRepresentation(d2._representation)),
                                    t2.showAlways && d2.show(),
                                    (d2._initializingActive = false),
                                    d2._emit('init');
                            });
                        }
                        _preBuild() {
                            const { options: t2 } = this;
                            for (const e2 of ['el', 'container']) t2[e2] = p(t2[e2]);
                            (this._root = ((t3) => {
                                const {
                                        components: e2,
                                        useAsButton: o2,
                                        inline: n2,
                                        appClass: i2,
                                        theme: r2,
                                        lockOpacity: s2,
                                    } = t3.options,
                                    a2 = (t4) => (t4 ? '' : 'style="display:none" hidden'),
                                    c2 = (e3) => t3._t(e3),
                                    p2 = l(`
      <div :ref="root" class="pickr">

        ${o2 ? '' : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${i2 || ''}" data-theme="${r2}" ${
                                        n2 ? 'style="position: unset"' : ''
                                    } aria-label="${c2('ui:dialog')}" role="window">
          <div class="pcr-selection" ${a2(e2.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${a2(e2.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c2(
                  'btn:last-color',
              )}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c2(
                  'aria:palette',
              )}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${a2(e2.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c2(
                  'aria:hue',
              )}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${a2(e2.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c2(
                  'aria:opacity',
              )}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e2.palette ? '' : 'pcr-last'}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${a2(Object.keys(e2.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${a2(
                e2.interaction.input,
            )} aria-label="${c2('aria:input')}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${s2 ? 'HEX' : 'HEXA'}" type="button" ${a2(
                                        e2.interaction.hex,
                                    )}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${s2 ? 'RGB' : 'RGBA'}" type="button" ${a2(
                                        e2.interaction.rgba,
                                    )}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${s2 ? 'HSL' : 'HSLA'}" type="button" ${a2(
                                        e2.interaction.hsla,
                                    )}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${s2 ? 'HSV' : 'HSVA'}" type="button" ${a2(
                                        e2.interaction.hsva,
                                    )}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${a2(
                e2.interaction.cmyk,
            )}>

            <input :ref="save" class="pcr-save" value="${c2('btn:save')}" type="button" ${a2(
                                        e2.interaction.save,
                                    )} aria-label="${c2('aria:btn:save')}">
            <input :ref="cancel" class="pcr-cancel" value="${c2('btn:cancel')}" type="button" ${a2(
                                        e2.interaction.cancel,
                                    )} aria-label="${c2('aria:btn:cancel')}">
            <input :ref="clear" class="pcr-clear" value="${c2('btn:clear')}" type="button" ${a2(
                                        e2.interaction.clear,
                                    )} aria-label="${c2('aria:btn:clear')}">
          </div>
        </div>
      </div>
    `),
                                    u2 = p2.interaction;
                                return (
                                    u2.options.find((t4) => !t4.hidden && !t4.classList.add('active')),
                                    (u2.type = () => u2.options.find((t4) => t4.classList.contains('active'))),
                                    p2
                                );
                            })(this)),
                                t2.useAsButton && (this._root.button = t2.el),
                                t2.container.appendChild(this._root.root);
                        }
                        _finalBuild() {
                            const t2 = this.options,
                                e2 = this._root;
                            if ((t2.container.removeChild(e2.root), t2.inline)) {
                                const o2 = t2.el.parentElement;
                                t2.el.nextSibling ? o2.insertBefore(e2.app, t2.el.nextSibling) : o2.appendChild(e2.app);
                            } else t2.container.appendChild(e2.app);
                            t2.useAsButton
                                ? t2.inline && t2.el.remove()
                                : t2.el.parentNode.replaceChild(e2.root, t2.el),
                                t2.disabled && this.disable(),
                                t2.comparison ||
                                    ((e2.button.style.transition = 'none'),
                                    t2.useAsButton || (e2.preview.lastColor.style.transition = 'none')),
                                this.hide();
                        }
                        _buildComponents() {
                            const t2 = this,
                                e2 = this.options.components,
                                o2 = (t2.options.sliders || 'v').repeat(2),
                                [n2, i2] = o2.match(/^[vh]+$/g) ? o2 : [],
                                r2 = () => this._color || (this._color = this._lastColor.clone()),
                                s2 = {
                                    palette: $({
                                        element: t2._root.palette.picker,
                                        wrapper: t2._root.palette.palette,
                                        onstop: () => t2._emit('changestop', 'slider', t2),
                                        onchange(o3, n3) {
                                            if (!e2.palette) return;
                                            const i3 = r2(),
                                                { _root: s3, options: a2 } = t2,
                                                { lastColor: l2, currentColor: c2 } = s3.preview;
                                            t2._recalc &&
                                                ((i3.s = 100 * o3),
                                                (i3.v = 100 - 100 * n3),
                                                i3.v < 0 && (i3.v = 0),
                                                t2._updateOutput('slider'));
                                            const p2 = i3.toRGBA().toString(0);
                                            (this.element.style.background = p2),
                                                (this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${i3.a}), transparent),
                        linear-gradient(to left, hsla(${i3.h}, 100%, 50%, ${i3.a}), rgba(255, 255, 255, ${i3.a}))
                    `),
                                                a2.comparison
                                                    ? a2.useAsButton ||
                                                      t2._lastColor ||
                                                      l2.style.setProperty('--pcr-color', p2)
                                                    : ((s3.button.style.color = p2),
                                                      s3.button.classList.remove('clear'));
                                            const u2 = i3.toHEXA().toString();
                                            for (const { el: e3, color: o4 } of t2._swatchColors)
                                                e3.classList[u2 === o4.toHEXA().toString() ? 'add' : 'remove'](
                                                    'pcr-active',
                                                );
                                            c2.style.setProperty('--pcr-color', p2);
                                        },
                                    }),
                                    hue: $({
                                        lock: i2 === 'v' ? 'h' : 'v',
                                        element: t2._root.hue.picker,
                                        wrapper: t2._root.hue.slider,
                                        onstop: () => t2._emit('changestop', 'slider', t2),
                                        onchange(o3) {
                                            if (!e2.hue || !e2.palette) return;
                                            const n3 = r2();
                                            t2._recalc && (n3.h = 360 * o3),
                                                (this.element.style.backgroundColor = `hsl(${n3.h}, 100%, 50%)`),
                                                s2.palette.trigger();
                                        },
                                    }),
                                    opacity: $({
                                        lock: n2 === 'v' ? 'h' : 'v',
                                        element: t2._root.opacity.picker,
                                        wrapper: t2._root.opacity.slider,
                                        onstop: () => t2._emit('changestop', 'slider', t2),
                                        onchange(o3) {
                                            if (!e2.opacity || !e2.palette) return;
                                            const n3 = r2();
                                            t2._recalc && (n3.a = Math.round(100 * o3) / 100),
                                                (this.element.style.background = `rgba(0, 0, 0, ${n3.a})`),
                                                s2.palette.trigger();
                                        },
                                    }),
                                    selectable: S({
                                        elements: t2._root.interaction.options,
                                        className: 'active',
                                        onchange(e3) {
                                            (t2._representation = e3.target.getAttribute('data-type').toUpperCase()),
                                                t2._recalc && t2._updateOutput('swatch');
                                        },
                                    }),
                                };
                            this._components = s2;
                        }
                        _bindEvents() {
                            const { _root: t2, options: e2 } = this,
                                o2 = [
                                    r(t2.interaction.clear, 'click', () => this._clearColor()),
                                    r([t2.interaction.cancel, t2.preview.lastColor], 'click', () => {
                                        this.setHSVA(...(this._lastColor || this._color).toHSVA(), true),
                                            this._emit('cancel');
                                    }),
                                    r(t2.interaction.save, 'click', () => {
                                        !this.applyColor() && !e2.showAlways && this.hide();
                                    }),
                                    r(t2.interaction.result, ['keyup', 'input'], (t3) => {
                                        this.setColor(t3.target.value, true) &&
                                            !this._initializingActive &&
                                            (this._emit('change', this._color, 'input', this),
                                            this._emit('changestop', 'input', this)),
                                            t3.stopImmediatePropagation();
                                    }),
                                    r(t2.interaction.result, ['focus', 'blur'], (t3) => {
                                        (this._recalc = t3.type === 'blur'), this._recalc && this._updateOutput(null);
                                    }),
                                    r(
                                        [
                                            t2.palette.palette,
                                            t2.palette.picker,
                                            t2.hue.slider,
                                            t2.hue.picker,
                                            t2.opacity.slider,
                                            t2.opacity.picker,
                                        ],
                                        ['mousedown', 'touchstart'],
                                        () => (this._recalc = true),
                                        { passive: true },
                                    ),
                                ];
                            if (!e2.showAlways) {
                                const n2 = e2.closeWithKey;
                                o2.push(
                                    r(t2.button, 'click', () => (this.isOpen() ? this.hide() : this.show())),
                                    r(
                                        document,
                                        'keyup',
                                        (t3) => this.isOpen() && (t3.key === n2 || t3.code === n2) && this.hide(),
                                    ),
                                    r(
                                        document,
                                        ['touchstart', 'mousedown'],
                                        (e3) => {
                                            this.isOpen() &&
                                                !c(e3).some((e4) => e4 === t2.app || e4 === t2.button) &&
                                                this.hide();
                                        },
                                        { capture: true },
                                    ),
                                );
                            }
                            if (e2.adjustableNumbers) {
                                const e3 = {
                                    rgba: [255, 255, 255, 1],
                                    hsva: [360, 100, 100, 1],
                                    hsla: [360, 100, 100, 1],
                                    cmyk: [100, 100, 100, 100],
                                };
                                u(t2.interaction.result, (t3, o3, n2) => {
                                    const i2 = e3[this.getColorRepresentation().toLowerCase()];
                                    if (i2) {
                                        const e4 = i2[n2],
                                            r2 = t3 + (e4 >= 100 ? 1e3 * o3 : o3);
                                        return r2 <= 0 ? 0 : Number((r2 < e4 ? r2 : e4).toPrecision(3));
                                    }
                                    return t3;
                                });
                            }
                            if (e2.autoReposition && !e2.inline) {
                                let t3 = null;
                                const n2 = this;
                                o2.push(
                                    r(
                                        window,
                                        ['scroll', 'resize'],
                                        () => {
                                            n2.isOpen() &&
                                                (e2.closeOnScroll && n2.hide(),
                                                t3 === null
                                                    ? ((t3 = setTimeout(() => (t3 = null), 100)),
                                                      requestAnimationFrame(function e3() {
                                                          n2._rePositioningPicker(),
                                                              t3 !== null && requestAnimationFrame(e3);
                                                      }))
                                                    : (clearTimeout(t3), (t3 = setTimeout(() => (t3 = null), 100))));
                                        },
                                        { capture: true },
                                    ),
                                );
                            }
                            this._eventBindings = o2;
                        }
                        _rePositioningPicker() {
                            const { options: t2 } = this;
                            if (!t2.inline) {
                                if (
                                    !this._nanopop.update({
                                        container: document.body.getBoundingClientRect(),
                                        position: t2.position,
                                    })
                                ) {
                                    const t3 = this._root.app,
                                        e2 = t3.getBoundingClientRect();
                                    (t3.style.top = (window.innerHeight - e2.height) / 2 + 'px'),
                                        (t3.style.left = (window.innerWidth - e2.width) / 2 + 'px');
                                }
                            }
                        }
                        _updateOutput(t2) {
                            const { _root: e2, _color: o2, options: n2 } = this;
                            if (e2.interaction.type()) {
                                const t3 = 'to' + e2.interaction.type().getAttribute('data-type');
                                e2.interaction.result.value =
                                    typeof o2[t3] == 'function' ? o2[t3]().toString(n2.outputPrecision) : '';
                            }
                            !this._initializingActive && this._recalc && this._emit('change', o2, t2, this);
                        }
                        _clearColor(t2 = false) {
                            const { _root: e2, options: o2 } = this;
                            o2.useAsButton || (e2.button.style.color = 'rgba(0, 0, 0, 0.15)'),
                                e2.button.classList.add('clear'),
                                o2.showAlways || this.hide(),
                                (this._lastColor = null),
                                this._initializingActive || t2 || (this._emit('save', null), this._emit('clear'));
                        }
                        _parseLocalColor(t2) {
                            const { values: e2, type: o2, a: n2 } = A(t2),
                                { lockOpacity: i2 } = this.options,
                                r2 = n2 !== void 0 && n2 !== 1;
                            return (
                                e2 && e2.length === 3 && (e2[3] = void 0),
                                { values: !e2 || (i2 && r2) ? null : e2, type: o2 }
                            );
                        }
                        _t(t2) {
                            return this.options.i18n[t2] || x.I18N_DEFAULTS[t2];
                        }
                        _emit(t2, ...e2) {
                            this._eventListener[t2].forEach((t3) => t3(...e2, this));
                        }
                        on(t2, e2) {
                            return this._eventListener[t2].push(e2), this;
                        }
                        off(t2, e2) {
                            const o2 = this._eventListener[t2] || [],
                                n2 = o2.indexOf(e2);
                            return ~n2 && o2.splice(n2, 1), this;
                        }
                        addSwatch(t2) {
                            const { values: e2 } = this._parseLocalColor(t2);
                            if (e2) {
                                const { _swatchColors: t3, _root: o2 } = this,
                                    n2 = C(...e2),
                                    i2 = a(
                                        `<button type="button" style="--pcr-color: ${n2
                                            .toRGBA()
                                            .toString(0)}" aria-label="${this._t('btn:swatch')}"/>`,
                                    );
                                return (
                                    o2.swatches.appendChild(i2),
                                    t3.push({ el: i2, color: n2 }),
                                    this._eventBindings.push(
                                        r(i2, 'click', () => {
                                            this.setHSVA(...n2.toHSVA(), true),
                                                this._emit('swatchselect', n2),
                                                this._emit('change', n2, 'swatch', this);
                                        }),
                                    ),
                                    true
                                );
                            }
                            return false;
                        }
                        removeSwatch(t2) {
                            const e2 = this._swatchColors[t2];
                            if (e2) {
                                const { el: o2 } = e2;
                                return this._root.swatches.removeChild(o2), this._swatchColors.splice(t2, 1), true;
                            }
                            return false;
                        }
                        applyColor(t2 = false) {
                            const { preview: e2, button: o2 } = this._root,
                                n2 = this._color.toRGBA().toString(0);
                            return (
                                e2.lastColor.style.setProperty('--pcr-color', n2),
                                this.options.useAsButton || o2.style.setProperty('--pcr-color', n2),
                                o2.classList.remove('clear'),
                                (this._lastColor = this._color.clone()),
                                this._initializingActive || t2 || this._emit('save', this._color),
                                this
                            );
                        }
                        destroy() {
                            cancelAnimationFrame(this._setupAnimationFrame),
                                this._eventBindings.forEach((t2) => s(...t2)),
                                Object.keys(this._components).forEach((t2) => this._components[t2].destroy());
                        }
                        destroyAndRemove() {
                            this.destroy();
                            const { root: t2, app: e2 } = this._root;
                            t2.parentElement && t2.parentElement.removeChild(t2),
                                e2.parentElement.removeChild(e2),
                                Object.keys(this).forEach((t3) => (this[t3] = null));
                        }
                        hide() {
                            return (
                                !!this.isOpen() &&
                                (this._root.app.classList.remove('visible'), this._emit('hide'), true)
                            );
                        }
                        show() {
                            return (
                                !this.options.disabled &&
                                !this.isOpen() &&
                                (this._root.app.classList.add('visible'),
                                this._rePositioningPicker(),
                                this._emit('show', this._color),
                                this)
                            );
                        }
                        isOpen() {
                            return this._root.app.classList.contains('visible');
                        }
                        setHSVA(t2 = 360, e2 = 0, o2 = 0, n2 = 1, i2 = false) {
                            const r2 = this._recalc;
                            if (
                                ((this._recalc = false),
                                t2 < 0 || t2 > 360 || e2 < 0 || e2 > 100 || o2 < 0 || o2 > 100 || n2 < 0 || n2 > 1)
                            )
                                return false;
                            this._color = C(t2, e2, o2, n2);
                            const { hue: s2, opacity: a2, palette: l2 } = this._components;
                            return (
                                s2.update(t2 / 360),
                                a2.update(n2),
                                l2.update(e2 / 100, 1 - o2 / 100),
                                i2 || this.applyColor(),
                                r2 && this._updateOutput(),
                                (this._recalc = r2),
                                true
                            );
                        }
                        setColor(t2, e2 = false) {
                            if (t2 === null) return this._clearColor(e2), true;
                            const { values: o2, type: n2 } = this._parseLocalColor(t2);
                            if (o2) {
                                const t3 = n2.toUpperCase(),
                                    { options: i2 } = this._root.interaction,
                                    r2 = i2.find((e3) => e3.getAttribute('data-type') === t3);
                                if (r2 && !r2.hidden)
                                    for (const t4 of i2) t4.classList[t4 === r2 ? 'add' : 'remove']('active');
                                return !!this.setHSVA(...o2, e2) && this.setColorRepresentation(t3);
                            }
                            return false;
                        }
                        setColorRepresentation(t2) {
                            return (
                                (t2 = t2.toUpperCase()),
                                !!this._root.interaction.options.find(
                                    (e2) => e2.getAttribute('data-type').startsWith(t2) && !e2.click(),
                                )
                            );
                        }
                        getColorRepresentation() {
                            return this._representation;
                        }
                        getColor() {
                            return this._color;
                        }
                        getSelectedColor() {
                            return this._lastColor;
                        }
                        getRoot() {
                            return this._root;
                        }
                        disable() {
                            return (
                                this.hide(),
                                (this.options.disabled = true),
                                this._root.button.classList.add('disabled'),
                                this
                            );
                        }
                        enable() {
                            return (
                                (this.options.disabled = false), this._root.button.classList.remove('disabled'), this
                            );
                        }
                    }
                    L(x, 'utils', n),
                        L(x, 'version', '1.8.1'),
                        L(x, 'I18N_DEFAULTS', {
                            'ui:dialog': 'color picker dialog',
                            'btn:toggle': 'toggle color picker dialog',
                            'btn:swatch': 'color swatch',
                            'btn:last-color': 'use previous color',
                            'btn:save': 'Save',
                            'btn:cancel': 'Cancel',
                            'btn:clear': 'Clear',
                            'aria:btn:save': 'save and close',
                            'aria:btn:cancel': 'cancel and close',
                            'aria:btn:clear': 'clear and close',
                            'aria:input': 'color input field',
                            'aria:palette': 'color selection area',
                            'aria:hue': 'hue selection slider',
                            'aria:opacity': 'selection slider',
                        }),
                        L(x, 'DEFAULT_OPTIONS', {
                            appClass: null,
                            theme: 'classic',
                            useAsButton: false,
                            padding: 8,
                            disabled: false,
                            comparison: true,
                            closeOnScroll: false,
                            outputPrecision: 0,
                            lockOpacity: false,
                            autoReposition: true,
                            container: 'body',
                            components: { interaction: {} },
                            i18n: {},
                            swatches: null,
                            inline: false,
                            sliders: null,
                            default: '#42445a',
                            defaultRepresentation: null,
                            position: 'bottom-middle',
                            adjustableNumbers: true,
                            showAlways: false,
                            closeWithKey: 'Escape',
                        }),
                        L(x, 'create', (t2) => new x(t2));
                    e.default = x;
                },
            ]).default;
        });
    })(pickr_min);
    var __Pickr = /* @__PURE__ */ getDefaultExportFromCjs(pickr_min.exports);
    var __baseCss = `/*! Pickr 1.8.1 MIT | https://github.com/Simonwep/pickr */.pickr{position:relative;overflow:visible;transform:translateY(0)}.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pickr .pcr-button{position:relative;height:2em;width:2em;padding:.5em;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;border-radius:.15em;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" stroke="%2342445A" stroke-width="5px" stroke-linecap="round"><path d="M45,45L5,5"></path><path d="M45,5L5,45"></path></svg>') no-repeat 50%;background-size:0;transition:all .3s}.pickr .pcr-button:before{background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;z-index:-1;z-index:auto}.pickr .pcr-button:after,.pickr .pcr-button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;border-radius:.15em}.pickr .pcr-button:after{transition:background .3s;background:var(--pcr-color)}.pickr .pcr-button.clear{background-size:70%}.pickr .pcr-button.clear:before{opacity:0}.pickr .pcr-button.clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pickr .pcr-button.disabled{cursor:not-allowed}.pcr-app *,.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pcr-app button.pcr-active,.pcr-app button:focus,.pcr-app input.pcr-active,.pcr-app input:focus,.pickr button.pcr-active,.pickr button:focus,.pickr input.pcr-active,.pickr input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pcr-app .pcr-palette,.pcr-app .pcr-slider,.pickr .pcr-palette,.pickr .pcr-slider{transition:box-shadow .3s}.pcr-app .pcr-palette:focus,.pcr-app .pcr-slider:focus,.pickr .pcr-palette:focus,.pickr .pcr-slider:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(0,0,0,.25)}.pcr-app{position:fixed;display:flex;flex-direction:column;z-index:10000;border-radius:.1em;background:#fff;opacity:0;visibility:hidden;transition:opacity .3s,visibility 0s .3s;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;box-shadow:0 .15em 1.5em 0 rgba(0,0,0,.1),0 0 1em 0 rgba(0,0,0,.03);left:0;top:0}.pcr-app.visible{transition:opacity .3s;visibility:visible;opacity:1}.pcr-app .pcr-swatches{display:flex;flex-wrap:wrap;margin-top:.75em}.pcr-app .pcr-swatches.pcr-last{margin:0}@supports (display:grid){.pcr-app .pcr-swatches{display:grid;align-items:center;grid-template-columns:repeat(auto-fit,1.75em)}}.pcr-app .pcr-swatches>button{font-size:1em;position:relative;width:calc(1.75em - 5px);height:calc(1.75em - 5px);border-radius:.15em;cursor:pointer;margin:2.5px;flex-shrink:0;justify-self:center;transition:all .15s;overflow:hidden;background:transparent;z-index:1}.pcr-app .pcr-swatches>button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:6px;border-radius:.15em;z-index:-1}.pcr-app .pcr-swatches>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:var(--pcr-color);border:1px solid rgba(0,0,0,.05);border-radius:.15em;box-sizing:border-box}.pcr-app .pcr-swatches>button:hover{filter:brightness(1.05)}.pcr-app .pcr-swatches>button:not(.pcr-active){box-shadow:none}.pcr-app .pcr-interaction{display:flex;flex-wrap:wrap;align-items:center;margin:0 -.2em}.pcr-app .pcr-interaction>*{margin:0 .2em}.pcr-app .pcr-interaction input{letter-spacing:.07em;font-size:.75em;text-align:center;cursor:pointer;color:#75797e;background:#f1f3f4;border-radius:.15em;transition:all .15s;padding:.45em .5em;margin-top:.75em}.pcr-app .pcr-interaction input:hover{filter:brightness(.975)}.pcr-app .pcr-interaction input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(66,133,244,.75)}.pcr-app .pcr-interaction .pcr-result{color:#75797e;text-align:left;flex:1 1 8em;min-width:8em;transition:all .2s;border-radius:.15em;background:#f1f3f4;cursor:text}.pcr-app .pcr-interaction .pcr-result::-moz-selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-result::selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-type.active{color:#fff;background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear,.pcr-app .pcr-interaction .pcr-save{width:auto;color:#fff}.pcr-app .pcr-interaction .pcr-cancel:hover,.pcr-app .pcr-interaction .pcr-clear:hover,.pcr-app .pcr-interaction .pcr-save:hover{filter:brightness(.925)}.pcr-app .pcr-interaction .pcr-save{background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear{background:#f44250}.pcr-app .pcr-interaction .pcr-cancel:focus,.pcr-app .pcr-interaction .pcr-clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(244,66,80,.75)}.pcr-app .pcr-selection .pcr-picker{position:absolute;height:18px;width:18px;border:2px solid #fff;border-radius:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.pcr-app .pcr-selection .pcr-color-chooser,.pcr-app .pcr-selection .pcr-color-opacity,.pcr-app .pcr-selection .pcr-color-palette{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;cursor:grab;cursor:-webkit-grab}.pcr-app .pcr-selection .pcr-color-chooser:active,.pcr-app .pcr-selection .pcr-color-opacity:active,.pcr-app .pcr-selection .pcr-color-palette:active{cursor:grabbing;cursor:-webkit-grabbing}.pcr-app[data-theme=nano]{width:14.25em;max-width:95vw}.pcr-app[data-theme=nano] .pcr-swatches{margin-top:.6em;padding:0 .6em}.pcr-app[data-theme=nano] .pcr-interaction{padding:0 .6em .6em}.pcr-app[data-theme=nano] .pcr-selection{display:grid;grid-gap:.6em;grid-template-columns:1fr 4fr;grid-template-rows:5fr auto auto;align-items:center;height:10.5em;width:100%;align-self:flex-start}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview{grid-area:2/1/4/1;height:100%;width:100%;display:flex;flex-direction:row;justify-content:center;margin-left:.6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-last-color{display:none}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color{position:relative;background:var(--pcr-color);width:2em;height:2em;border-radius:50em;overflow:hidden}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette{grid-area:1/1/2/3;width:100%;height:100%;z-index:1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette{border-radius:.15em;width:100%;height:100%}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser{grid-area:2/2/2/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{grid-area:3/2/3/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{height:.5em;margin:0 .6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-picker,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-picker{top:50%;transform:translateY(-50%)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{flex-grow:1;border-radius:50em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider{background:linear-gradient(90deg,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{background:linear-gradient(90deg,transparent,#000),url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:100%,.25em}`;
    var __css$1 =
        '.s-color-picker[default-style] {\n}\n\ns-color-picker:not([mounted]) > * {\n        display: none;\n    }\n\n[default-style] .s-color-picker__picker {\n        background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-surface-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-surface-a, 1));\n        overflow: hidden;box-shadow: var(--s-theme-ui-colorPicker-depth, 0);\n        border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n        padding: var(--s-theme-ui-colorPicker-padding, 6px 12px);\n    }\n\n.pickr.s-color-picker__preview {\n    display: inline-block;\n    outline: none;\n    border-radius: 0 !important;\n}\n\n[default-style] .pickr.s-color-picker__preview {\n        transition: var(--s-theme-transition-fast, all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n.pickr.s-color-picker__preview button:focus {\n        display: none;\n    }\n\n.pickr.s-color-picker__preview button {\n        width: 1em;\n        height: 1em;\n        border-radius: 0 !important;\n    }\n\n.pickr.s-color-picker__preview button:before,\n        .pickr.s-color-picker__preview button:after {\n            border-radius: 0 !important;\n        }\n';
    class SColorPickerComponentInterface extends SInterface {}
    SColorPickerComponentInterface.definition = {
        value: {
            type: 'String',
            default: '#ff0000',
        },
    };
    class SColorPicker extends SLitElement {
        constructor() {
            super();
            this._component = void 0;
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SColorPickerComponentInterface,
                    defaultProps: {},
                },
            });
        }
        static get properties() {
            return SComponentUtils.properties({}, SColorPickerComponentInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(`
            ${__baseCss}
            ${__css$1}
        `)}
        `;
        }
        firstUpdated() {
            var _a, _b, _c, _d;
            const pickr = __Pickr.create({
                el:
                    (_a = this.shadowRoot) === null || _a === void 0
                        ? void 0
                        : _a.querySelector('.s-color-picker__preview'),
                theme: 'nano',
                container:
                    (_b = this.shadowRoot) === null || _b === void 0
                        ? void 0
                        : _b.querySelector('.s-color-picker__picker-wrapper'),
                default: this.value,
                comparison: false,
                swatches: [],
                components: {
                    preview: true,
                    opacity: true,
                    hue: true,
                    interaction: {
                        hex: true,
                        rgba: true,
                        hsla: true,
                        input: true,
                        clear: true,
                    },
                },
            });
            function getPickrState() {
                const color = pickr.getColor();
                const hsla = color.toHSLA(),
                    hsva = color.toHSVA(),
                    rgba = color.toRGBA(),
                    hex = color.toHEXA(),
                    cmyk = color.toCMYK();
                return {
                    isOpened: pickr.isOpen(),
                    hsla: {
                        h: hsla[0],
                        s: hsla[1],
                        l: hsla[2],
                        a: hsla[3],
                        string: `hsla(${hsla[0]},${hsla[1]},${hsla[2]},${hsla[3]})`,
                    },
                    hsva: {
                        h: hsva[0],
                        s: hsva[1],
                        v: hsva[2],
                        a: hsva[3],
                        string: `hsva(${hsva[0]},${hsva[1]},${hsva[2]},${hsva[3]})`,
                    },
                    rgba: {
                        r: rgba[0],
                        g: rgba[1],
                        b: rgba[2],
                        a: rgba[3],
                        string: `rgba(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3]})`,
                    },
                    hex: hex.toString(),
                    cmyk: {
                        c: cmyk[0],
                        m: cmyk[1],
                        y: cmyk[2],
                        k: cmyk[3],
                        string: `cmyk(${cmyk[0]},${cmyk[1]},${cmyk[2]},${cmyk[3]})`,
                    },
                };
            }
            pickr.on('change', () => {
                pickr.applyColor();
                const detail = getPickrState();
                const change = new CustomEvent('change', {
                    detail,
                });
                this.dispatchEvent(change);
            });
            pickr.on('show', () => {
                const detail = getPickrState();
                const change = new CustomEvent('show', {
                    detail,
                });
                this.dispatchEvent(change);
            });
            pickr.on('hide', () => {
                const detail = getPickrState();
                const change = new CustomEvent('hide', {
                    detail,
                });
                this.dispatchEvent(change);
            });
            pickr.on('cancel', () => {
                const detail = getPickrState();
                const change = new CustomEvent('cancel', {
                    detail,
                });
                this.dispatchEvent(change);
            });
            const $app = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelector('.pcr-app');
            $app === null || $app === void 0 ? void 0 : $app.classList.add(this._component.className('__picker'));
            const $preview = (_d = this.shadowRoot) === null || _d === void 0 ? void 0 : _d.querySelector('.pickr');
            $preview === null || $preview === void 0
                ? void 0
                : $preview.classList.add(this._component.className('__preview'));
        }
        render() {
            return html$4`
            <div class="${this._component.className('')}">
                <div class="${this._component.className('__picker-wrapper')}"></div>
                <div class="${this._component.className('__preview')}"></div>
            </div>
        `;
        }
    }
    function webcomponent$4(props = {}, tagName = 's-color-picker') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SColorPicker);
    }
    class SRangeComponentInterface extends SInterface {}
    SRangeComponentInterface.definition = {
        name: {
            type: 'String',
            description: 'Specify the name to assign to the internal input[type="range"]',
            required: true,
        },
        value: {
            type: 'String',
            description: 'Specify the initial range value',
        },
        min: {
            type: 'Number',
            description: 'Specify the minimal value or the range',
            default: 0,
        },
        max: {
            type: 'Number',
            description: 'Specify the maximal value of the range',
            default: 100,
        },
        step: {
            type: 'Number',
            description: 'Specify the steps between each values',
        },
        target: {
            type: 'String',
            description:
                'Specify a css selector of any HTMLElement or HTMLInputElement in which to inject the value when the range is updated',
        },
        tooltip: {
            type: 'Boolean',
            description: 'Specify if you want to display the value inside a tooltip on top of the thumb',
            default: false,
        },
    };
    var __css =
        's-range {\n    display: block;\n    width: 100%;\n}\n\n    s-range:not([mounted]) > * {\n        display: none;\n    }\n.s-range {\n    display: flex;\n    width: 100%;\n}\n\n.s-range__input {\n    flex-grow: 1;\n}\n\n.s-range__tooltip {\n    transition: none;\n}\n\ns-range[default-style] {\n}\n';
    var __awaiter$6 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SRange extends SLitElement {
        constructor() {
            super();
            this._component = void 0;
            this._component = new SComponentUtils(this.tagName.toLowerCase(), this, this.attributes, {
                componentUtils: {
                    interface: SRangeComponentInterface,
                    defaultProps: {},
                },
            });
        }
        static get properties() {
            return SComponentUtils.properties({}, SRangeComponentInterface);
        }
        static get styles() {
            return css$1`
            ${unsafeCSS$1(`
                ${__css}
            `)}
        `;
        }
        firstUpdated() {
            return __awaiter$6(this, void 0, void 0, function* () {
                this._$input = this.querySelector('input');
                this._$tooltip = this.querySelector('.s-range__tooltip');
                this._$input.addEventListener('input', (e) => {
                    this._handleTooltip();
                    this._handleTarget();
                });
                if (this._component.props.target) {
                    this._$targets = Array.from(document.querySelectorAll(this._component.props.target));
                }
                this._handleTooltip();
                this._handleTarget();
            });
        }
        _handleTarget() {
            if (!this._$targets) return;
            this._$targets.forEach(($target) => {
                $target.innerHTML = this._$input.value;
                $target.value = this._$input.value;
            });
        }
        _handleTooltip() {
            if (!this._$tooltip) return;
            const val = this._$input.value;
            const min = this._$input.min ? this._$input.min : 0;
            const max = this._$input.max ? this._$input.max : 100;
            const newVal = Number(((val - min) * 100) / (max - min));
            this._$tooltip.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
            this._$tooltip.innerHTML = val;
        }
        _dispatchEvent(eventName) {
            const event2 = new CustomEvent(eventName, {
                detail: {
                    dateStr: this._picker.toString(),
                    date: this._picker.getDate(),
                },
            });
            this.dispatchEvent(event2);
        }
        createRenderRoot() {
            return this;
        }
        render() {
            return html$4`
            <div class="${this._component.className('', 's-tooltip-container')}">
                <input
                    class="${this._component.className('__input', 's-range')}"
                    type="range"
                    name="${this.name}"
                    value="${this.value}"
                    min="${this.min}"
                    max="${this.max}"
                    step="${this.step}"
                />
                ${
                    this._component.props.tooltip
                        ? html$4` <div class="${this._component.className('__tooltip', 's-tooltip')}"></div> `
                        : ''
                }
            </div>
        `;
        }
    }
    function webcomponent$3(props = {}, tagName = 's-range') {
        SComponentUtils.setDefaultProps(tagName, props);
        customElements.define(tagName, SRange);
    }
    function matches(el, selector) {
        if (el.nodeName == '#comment' || el.nodeName == '#text') {
            return false;
        }
        const p = Element.prototype;
        const f =
            p.matches ||
            p.webkitMatchesSelector ||
            p.mozMatchesSelector ||
            p.msMatchesSelector ||
            function (s) {
                return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
            };
        return f.call(el, selector);
    }
    let _observer;
    const _selectors = {};
    function querySelectorLive(selector, cb = null, settings = {}) {
        const id = `${selector} - ${uniqid$2()}`;
        settings = Object.assign(
            {},
            {
                rootNode: document,
                once: true,
            },
            settings,
        );
        if (!_selectors[selector]) {
            _selectors[selector] = [
                {
                    id,
                    selector,
                    cb,
                    lastMutationId: null,
                    settings,
                },
            ];
        } else {
            _selectors[selector].push({
                id,
                selector,
                cb,
                lastMutationId: null,
                settings,
            });
        }
        return new SPromise(({ resolve, reject, emit }) => {
            function pushNewNode(node, sel, mutationId) {
                const objs = _selectors[sel];
                if (!objs) return;
                objs.forEach((obj) => {
                    if (obj.lastMutationId && obj.lastMutationId === mutationId) return;
                    if (obj.settings.once) {
                        if (!node._querySelectorLive) {
                            node._querySelectorLive = {};
                        }
                        if (node._querySelectorLive[obj.id]) return;
                        node._querySelectorLive[obj.id] = true;
                    }
                    emit('node', node);
                    obj.cb &&
                        obj.cb(node, () => {
                            delete _selectors[obj.selector];
                        });
                });
            }
            if (!_observer) {
                _observer = new MutationObserver((mutations) => {
                    const mutationId = `mutation-${uniqid$2()}`;
                    mutations.forEach((mutation) => {
                        if (mutation.addedNodes && mutation.addedNodes.length) {
                            [].forEach.call(mutation.addedNodes, (node) => {
                                const selectors = Object.keys(_selectors);
                                selectors.forEach((sel) => {
                                    if (matches(node, sel)) {
                                        pushNewNode(node, sel, mutationId);
                                    }
                                });
                                if (!node.querySelectorAll) return;
                                selectors.forEach((sel) => {
                                    const nestedNodes = node.querySelectorAll(sel);
                                    [].forEach.call(nestedNodes, (nestedNode) => {
                                        pushNewNode(nestedNode, sel, mutationId);
                                    });
                                });
                            });
                        } else if (mutation.attributeName) {
                            const selectors = Object.keys(_selectors);
                            selectors.forEach((sel) => {
                                if (matches(mutation.target, sel)) {
                                    pushNewNode(mutation.target, sel, mutationId);
                                }
                            });
                        }
                    });
                });
                _observer.observe(settings.rootNode, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class', 'id'],
                });
            }
            [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
                pushNewNode(node, selector, 'init');
            });
        });
    }
    function expandPleasantCssClassname(classesStr) {
        const classesArray = [];
        const classNames = classesStr.split(/\s+/);
        let currentMedia = '';
        classNames.forEach((className) => {
            if (className.slice(0, 1) == '@') {
                currentMedia = className.replace('@', '___');
                return;
            }
            const parts = className.split(':');
            if (parts.length === 1) {
                let name2 = className;
                if (currentMedia !== '') name2 = className + currentMedia;
                classesArray.push(name2);
            } else {
                const firstClass = parts[0];
                let name2 = firstClass;
                if (currentMedia !== '') name2 = firstClass + currentMedia;
                classesArray.push(name2);
                parts.forEach((part, i) => {
                    if (i > 0) {
                        name2 = firstClass + '--' + part;
                        if (currentMedia !== '') name2 = name2 + currentMedia;
                        classesArray.push(name2);
                    }
                });
            }
        });
        return classesArray.join(' ');
    }
    function expandPleasantCssClassnamesLive(settings) {
        settings = Object.assign({ rootNode: document }, settings);
        querySelectorLive(
            '[class*=":"],[class*="@"]',
            ($elm) => {
                const classesStr = $elm.getAttribute('class');
                const newClassesStr = expandPleasantCssClassname(classesStr);
                $elm.setAttribute('class', newClassesStr);
            },
            {
                rootNode: settings === null || settings === void 0 ? void 0 : settings.rootNode,
                once: false,
            },
        );
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const standardProperty$1 = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return __spreadProps(__spreadValues({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                originalKey: element.key,
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty$1 = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property$1(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty$1(options, protoOrDescriptor, name2)
                : standardProperty$1(options, protoOrDescriptor);
    }
    var striptags$1 = { exports: {} };
    (function (module2) {
        (function (global2) {
            if (typeof Symbol2 !== 'function') {
                var Symbol2 = function (name2) {
                    return name2;
                };
                Symbol2.nonNative = true;
            }
            const STATE_PLAINTEXT = Symbol2('plaintext');
            const STATE_HTML = Symbol2('html');
            const STATE_COMMENT = Symbol2('comment');
            const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
            const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
            function striptags(html, allowable_tags, tag_replacement) {
                html = html || '';
                allowable_tags = allowable_tags || [];
                tag_replacement = tag_replacement || '';
                let context = init_context(allowable_tags, tag_replacement);
                return striptags_internal(html, context);
            }
            function init_striptags_stream(allowable_tags, tag_replacement) {
                allowable_tags = allowable_tags || [];
                tag_replacement = tag_replacement || '';
                let context = init_context(allowable_tags, tag_replacement);
                return function striptags_stream(html) {
                    return striptags_internal(html || '', context);
                };
            }
            striptags.init_streaming_mode = init_striptags_stream;
            function init_context(allowable_tags, tag_replacement) {
                allowable_tags = parse_allowable_tags(allowable_tags);
                return {
                    allowable_tags,
                    tag_replacement,
                    state: STATE_PLAINTEXT,
                    tag_buffer: '',
                    depth: 0,
                    in_quote_char: '',
                };
            }
            function striptags_internal(html, context) {
                let allowable_tags = context.allowable_tags;
                let tag_replacement = context.tag_replacement;
                let state = context.state;
                let tag_buffer = context.tag_buffer;
                let depth = context.depth;
                let in_quote_char = context.in_quote_char;
                let output = '';
                for (let idx = 0, length = html.length; idx < length; idx++) {
                    let char = html[idx];
                    if (state === STATE_PLAINTEXT) {
                        switch (char) {
                            case '<':
                                state = STATE_HTML;
                                tag_buffer += char;
                                break;
                            default:
                                output += char;
                                break;
                        }
                    } else if (state === STATE_HTML) {
                        switch (char) {
                            case '<':
                                if (in_quote_char) {
                                    break;
                                }
                                depth++;
                                break;
                            case '>':
                                if (in_quote_char) {
                                    break;
                                }
                                if (depth) {
                                    depth--;
                                    break;
                                }
                                in_quote_char = '';
                                state = STATE_PLAINTEXT;
                                tag_buffer += '>';
                                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                                    output += tag_buffer;
                                } else {
                                    output += tag_replacement;
                                }
                                tag_buffer = '';
                                break;
                            case '"':
                            case "'":
                                if (char === in_quote_char) {
                                    in_quote_char = '';
                                } else {
                                    in_quote_char = in_quote_char || char;
                                }
                                tag_buffer += char;
                                break;
                            case '-':
                                if (tag_buffer === '<!-') {
                                    state = STATE_COMMENT;
                                }
                                tag_buffer += char;
                                break;
                            case ' ':
                            case '\n':
                                if (tag_buffer === '<') {
                                    state = STATE_PLAINTEXT;
                                    output += '< ';
                                    tag_buffer = '';
                                    break;
                                }
                                tag_buffer += char;
                                break;
                            default:
                                tag_buffer += char;
                                break;
                        }
                    } else if (state === STATE_COMMENT) {
                        switch (char) {
                            case '>':
                                if (tag_buffer.slice(-2) == '--') {
                                    state = STATE_PLAINTEXT;
                                }
                                tag_buffer = '';
                                break;
                            default:
                                tag_buffer += char;
                                break;
                        }
                    }
                }
                context.state = state;
                context.tag_buffer = tag_buffer;
                context.depth = depth;
                context.in_quote_char = in_quote_char;
                return output;
            }
            function parse_allowable_tags(allowable_tags) {
                let tag_set = new Set();
                if (typeof allowable_tags === 'string') {
                    let match;
                    while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {
                        tag_set.add(match[1]);
                    }
                } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === 'function') {
                    tag_set = new Set(allowable_tags);
                } else if (typeof allowable_tags.forEach === 'function') {
                    allowable_tags.forEach(tag_set.add, tag_set);
                }
                return tag_set;
            }
            function normalize_tag(tag_buffer) {
                let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
                return match ? match[1].toLowerCase() : null;
            }
            if (module2.exports) {
                module2.exports = striptags;
            } else {
                global2.striptags = striptags;
            }
        })(commonjsGlobal$1);
    })(striptags$1);
    var __striptags = striptags$1.exports;
    function striptags(html, allowedTags = '', tagReplacement = '') {
        return __striptags(html, allowedTags, tagReplacement);
    }
    function ltrim(string, needle, trimResult = true) {
        if (string.substr(0, needle.length) === needle) {
            return trimResult ? string.substr(needle.length).trim() : string.substr(needle.length);
        }
        return string;
    }
    function queryStringToObject(str) {
        str = ltrim(str, '?');
        str = decodeURIComponent(str);
        let chunks = str.split('&');
        const obj = {};
        chunks = chunks.filter((ch) => {
            return ch !== '';
        });
        for (let c = 0; c < chunks.length; c++) {
            const split = chunks[c].split('=', 2);
            obj[split[0]] = split[1];
        }
        return obj;
    }
    /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
    var __assign = function () {
        __assign =
            Object.assign ||
            function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
        return __assign.apply(this, arguments);
    };
    function __values(o) {
        var s = typeof Symbol === 'function' && Symbol.iterator,
            m = s && o[s],
            i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === 'number')
            return {
                next: function () {
                    if (o && i >= o.length) o = void 0;
                    return { value: o && o[i++], done: !o };
                },
            };
        throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
    }
    function __read(o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
            r,
            ar = [],
            e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
            e = { error };
        } finally {
            try {
                if (r && !r.done && (m = i['return'])) m.call(i);
            } finally {
                if (e) throw e.error;
            }
        }
        return ar;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    var ENTRIES = 'ENTRIES';
    var KEYS = 'KEYS';
    var VALUES = 'VALUES';
    var LEAF = '';
    var TreeIterator = (function () {
        function TreeIterator(set, type) {
            var node = set._tree;
            var keys = Object.keys(node);
            this.set = set;
            this._type = type;
            this._path = keys.length > 0 ? [{ node, keys }] : [];
        }
        TreeIterator.prototype.next = function () {
            var value = this.dive();
            this.backtrack();
            return value;
        };
        TreeIterator.prototype.dive = function () {
            if (this._path.length === 0) {
                return { done: true, value: void 0 };
            }
            var _a = last$1(this._path),
                node = _a.node,
                keys = _a.keys;
            if (last$1(keys) === LEAF) {
                return { done: false, value: this.result() };
            }
            this._path.push({ node: node[last$1(keys)], keys: Object.keys(node[last$1(keys)]) });
            return this.dive();
        };
        TreeIterator.prototype.backtrack = function () {
            if (this._path.length === 0) {
                return;
            }
            last$1(this._path).keys.pop();
            if (last$1(this._path).keys.length > 0) {
                return;
            }
            this._path.pop();
            this.backtrack();
        };
        TreeIterator.prototype.key = function () {
            return (
                this.set._prefix +
                this._path
                    .map(function (_a) {
                        var keys = _a.keys;
                        return last$1(keys);
                    })
                    .filter(function (key) {
                        return key !== LEAF;
                    })
                    .join('')
            );
        };
        TreeIterator.prototype.value = function () {
            return last$1(this._path).node[LEAF];
        };
        TreeIterator.prototype.result = function () {
            if (this._type === VALUES) {
                return this.value();
            }
            if (this._type === KEYS) {
                return this.key();
            }
            return [this.key(), this.value()];
        };
        TreeIterator.prototype[Symbol.iterator] = function () {
            return this;
        };
        return TreeIterator;
    })();
    var last$1 = function (array) {
        return array[array.length - 1];
    };
    var NONE = 0;
    var CHANGE = 1;
    var ADD = 2;
    var DELETE = 3;
    var fuzzySearch = function (node, query, maxDistance) {
        var stack = [{ distance: 0, i: 0, key: '', node }];
        var results = {};
        var innerStack = [];
        var _loop_1 = function () {
            var _a = stack.pop(),
                node_1 = _a.node,
                distance = _a.distance,
                key = _a.key,
                i = _a.i,
                edit = _a.edit;
            Object.keys(node_1).forEach(function (k) {
                if (k === LEAF) {
                    var totDistance = distance + (query.length - i);
                    var _a2 = __read(results[key] || [null, Infinity], 2),
                        d = _a2[1];
                    if (totDistance <= maxDistance && totDistance < d) {
                        results[key] = [node_1[k], totDistance];
                    }
                } else {
                    withinDistance(query, k, maxDistance - distance, i, edit, innerStack).forEach(function (_a3) {
                        var d2 = _a3.distance,
                            i2 = _a3.i,
                            edit2 = _a3.edit;
                        stack.push({ node: node_1[k], distance: distance + d2, key: key + k, i: i2, edit: edit2 });
                    });
                }
            });
        };
        while (stack.length > 0) {
            _loop_1();
        }
        return results;
    };
    var withinDistance = function (a, b, maxDistance, i, edit, stack) {
        stack.push({ distance: 0, ia: i, ib: 0, edit });
        var results = [];
        while (stack.length > 0) {
            var _a = stack.pop(),
                distance = _a.distance,
                ia = _a.ia,
                ib = _a.ib,
                edit_1 = _a.edit;
            if (ib === b.length) {
                results.push({ distance, i: ia, edit: edit_1 });
                continue;
            }
            if (a[ia] === b[ib]) {
                stack.push({ distance, ia: ia + 1, ib: ib + 1, edit: NONE });
            } else {
                if (distance >= maxDistance) {
                    continue;
                }
                if (edit_1 !== ADD) {
                    stack.push({ distance: distance + 1, ia, ib: ib + 1, edit: DELETE });
                }
                if (ia < a.length) {
                    if (edit_1 !== DELETE) {
                        stack.push({ distance: distance + 1, ia: ia + 1, ib, edit: ADD });
                    }
                    if (edit_1 !== DELETE && edit_1 !== ADD) {
                        stack.push({ distance: distance + 1, ia: ia + 1, ib: ib + 1, edit: CHANGE });
                    }
                }
            }
        }
        return results;
    };
    var SearchableMap = (function () {
        function SearchableMap(tree, prefix) {
            if (tree === void 0) {
                tree = {};
            }
            if (prefix === void 0) {
                prefix = '';
            }
            this._tree = tree;
            this._prefix = prefix;
        }
        SearchableMap.prototype.atPrefix = function (prefix) {
            var _a;
            if (!prefix.startsWith(this._prefix)) {
                throw new Error('Mismatched prefix');
            }
            var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2),
                node = _b[0],
                path = _b[1];
            if (node === void 0) {
                var _c = __read(last(path), 2),
                    parentNode = _c[0],
                    key_1 = _c[1];
                var nodeKey = Object.keys(parentNode).find(function (k) {
                    return k !== LEAF && k.startsWith(key_1);
                });
                if (nodeKey !== void 0) {
                    return new SearchableMap(
                        ((_a = {}), (_a[nodeKey.slice(key_1.length)] = parentNode[nodeKey]), _a),
                        prefix,
                    );
                }
            }
            return new SearchableMap(node || {}, prefix);
        };
        SearchableMap.prototype.clear = function () {
            delete this._size;
            this._tree = {};
        };
        SearchableMap.prototype.delete = function (key) {
            delete this._size;
            return remove$3(this._tree, key);
        };
        SearchableMap.prototype.entries = function () {
            return new TreeIterator(this, ENTRIES);
        };
        SearchableMap.prototype.forEach = function (fn) {
            var e_1, _a;
            try {
                for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2),
                        key = _d[0],
                        value = _d[1];
                    fn(key, value, this);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
        };
        SearchableMap.prototype.fuzzyGet = function (key, maxEditDistance) {
            return fuzzySearch(this._tree, key, maxEditDistance);
        };
        SearchableMap.prototype.get = function (key) {
            var node = lookup(this._tree, key);
            return node !== void 0 ? node[LEAF] : void 0;
        };
        SearchableMap.prototype.has = function (key) {
            var node = lookup(this._tree, key);
            return node !== void 0 && node.hasOwnProperty(LEAF);
        };
        SearchableMap.prototype.keys = function () {
            return new TreeIterator(this, KEYS);
        };
        SearchableMap.prototype.set = function (key, value) {
            if (typeof key !== 'string') {
                throw new Error('key must be a string');
            }
            delete this._size;
            var node = createPath(this._tree, key);
            node[LEAF] = value;
            return this;
        };
        Object.defineProperty(SearchableMap.prototype, 'size', {
            get: function () {
                var _this = this;
                if (this._size) {
                    return this._size;
                }
                this._size = 0;
                this.forEach(function () {
                    _this._size += 1;
                });
                return this._size;
            },
            enumerable: false,
            configurable: true,
        });
        SearchableMap.prototype.update = function (key, fn) {
            if (typeof key !== 'string') {
                throw new Error('key must be a string');
            }
            delete this._size;
            var node = createPath(this._tree, key);
            node[LEAF] = fn(node[LEAF]);
            return this;
        };
        SearchableMap.prototype.values = function () {
            return new TreeIterator(this, VALUES);
        };
        SearchableMap.prototype[Symbol.iterator] = function () {
            return this.entries();
        };
        SearchableMap.from = function (entries) {
            var e_2, _a;
            var tree = new SearchableMap();
            try {
                for (
                    var entries_1 = __values(entries), entries_1_1 = entries_1.next();
                    !entries_1_1.done;
                    entries_1_1 = entries_1.next()
                ) {
                    var _b = __read(entries_1_1.value, 2),
                        key = _b[0],
                        value = _b[1];
                    tree.set(key, value);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            return tree;
        };
        SearchableMap.fromObject = function (object) {
            return SearchableMap.from(Object.entries(object));
        };
        return SearchableMap;
    })();
    var trackDown = function (tree, key, path) {
        if (path === void 0) {
            path = [];
        }
        if (key.length === 0 || tree == null) {
            return [tree, path];
        }
        var nodeKey = Object.keys(tree).find(function (k) {
            return k !== LEAF && key.startsWith(k);
        });
        if (nodeKey === void 0) {
            path.push([tree, key]);
            return trackDown(void 0, '', path);
        }
        path.push([tree, nodeKey]);
        return trackDown(tree[nodeKey], key.slice(nodeKey.length), path);
    };
    var lookup = function (tree, key) {
        if (key.length === 0 || tree == null) {
            return tree;
        }
        var nodeKey = Object.keys(tree).find(function (k) {
            return k !== LEAF && key.startsWith(k);
        });
        if (nodeKey === void 0) {
            return void 0;
        }
        return lookup(tree[nodeKey], key.slice(nodeKey.length));
    };
    var createPath = function (tree, key) {
        var _a;
        if (key.length === 0 || tree == null) {
            return tree;
        }
        var nodeKey = Object.keys(tree).find(function (k) {
            return k !== LEAF && key.startsWith(k);
        });
        if (nodeKey === void 0) {
            var toSplit = Object.keys(tree).find(function (k) {
                return k !== LEAF && k.startsWith(key[0]);
            });
            if (toSplit === void 0) {
                tree[key] = {};
            } else {
                var prefix = commonPrefix(key, toSplit);
                tree[prefix] = ((_a = {}), (_a[toSplit.slice(prefix.length)] = tree[toSplit]), _a);
                delete tree[toSplit];
                return createPath(tree[prefix], key.slice(prefix.length));
            }
            return tree[key];
        }
        return createPath(tree[nodeKey], key.slice(nodeKey.length));
    };
    var commonPrefix = function (a, b, i, length, prefix) {
        if (i === void 0) {
            i = 0;
        }
        if (length === void 0) {
            length = Math.min(a.length, b.length);
        }
        if (prefix === void 0) {
            prefix = '';
        }
        if (i >= length) {
            return prefix;
        }
        if (a[i] !== b[i]) {
            return prefix;
        }
        return commonPrefix(a, b, i + 1, length, prefix + a[i]);
    };
    var remove$3 = function (tree, key) {
        var _a = __read(trackDown(tree, key), 2),
            node = _a[0],
            path = _a[1];
        if (node === void 0) {
            return;
        }
        delete node[LEAF];
        var keys = Object.keys(node);
        if (keys.length === 0) {
            cleanup(path);
        }
        if (keys.length === 1) {
            merge(path, keys[0], node[keys[0]]);
        }
    };
    var cleanup = function (path) {
        if (path.length === 0) {
            return;
        }
        var _a = __read(last(path), 2),
            node = _a[0],
            key = _a[1];
        delete node[key];
        var keys = Object.keys(node);
        if (keys.length === 0) {
            cleanup(path.slice(0, -1));
        }
        if (keys.length === 1 && keys[0] !== LEAF) {
            merge(path.slice(0, -1), keys[0], node[keys[0]]);
        }
    };
    var merge = function (path, key, value) {
        if (path.length === 0) {
            return;
        }
        var _a = __read(last(path), 2),
            node = _a[0],
            nodeKey = _a[1];
        node[nodeKey + key] = value;
        delete node[nodeKey];
    };
    var last = function (array) {
        return array[array.length - 1];
    };
    var _a$1;
    var OR = 'or';
    var AND = 'and';
    var MiniSearch = (function () {
        function MiniSearch(options) {
            if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
                throw new Error('MiniSearch: option "fields" must be provided');
            }
            this._options = __assign(__assign(__assign({}, defaultOptions), options), {
                searchOptions: __assign(__assign({}, defaultSearchOptions), options.searchOptions || {}),
            });
            this._index = new SearchableMap();
            this._documentCount = 0;
            this._documentIds = {};
            this._fieldIds = {};
            this._fieldLength = {};
            this._averageFieldLength = {};
            this._nextId = 0;
            this._storedFields = {};
            this.addFields(this._options.fields);
        }
        MiniSearch.prototype.add = function (document2) {
            var _this = this;
            var _a = this._options,
                extractField = _a.extractField,
                tokenize = _a.tokenize,
                processTerm = _a.processTerm,
                fields = _a.fields,
                idField = _a.idField;
            var id = extractField(document2, idField);
            if (id == null) {
                throw new Error('MiniSearch: document does not have ID field "' + idField + '"');
            }
            var shortDocumentId = this.addDocumentId(id);
            this.saveStoredFields(shortDocumentId, document2);
            fields.forEach(function (field) {
                var fieldValue = extractField(document2, field);
                if (fieldValue == null) {
                    return;
                }
                var tokens = tokenize(fieldValue.toString(), field);
                _this.addFieldLength(shortDocumentId, _this._fieldIds[field], _this.documentCount - 1, tokens.length);
                tokens.forEach(function (term) {
                    var processedTerm = processTerm(term, field);
                    if (processedTerm) {
                        _this.addTerm(_this._fieldIds[field], shortDocumentId, processedTerm);
                    }
                });
            });
        };
        MiniSearch.prototype.addAll = function (documents) {
            var _this = this;
            documents.forEach(function (document2) {
                return _this.add(document2);
            });
        };
        MiniSearch.prototype.addAllAsync = function (documents, options) {
            var _this = this;
            if (options === void 0) {
                options = {};
            }
            var _a = options.chunkSize,
                chunkSize = _a === void 0 ? 10 : _a;
            var acc = { chunk: [], promise: Promise.resolve() };
            var _b = documents.reduce(function (_a2, document2, i) {
                    var chunk2 = _a2.chunk,
                        promise2 = _a2.promise;
                    chunk2.push(document2);
                    if ((i + 1) % chunkSize === 0) {
                        return {
                            chunk: [],
                            promise: promise2
                                .then(function () {
                                    return new Promise(function (resolve) {
                                        return setTimeout(resolve, 0);
                                    });
                                })
                                .then(function () {
                                    return _this.addAll(chunk2);
                                }),
                        };
                    } else {
                        return { chunk: chunk2, promise: promise2 };
                    }
                }, acc),
                chunk = _b.chunk,
                promise = _b.promise;
            return promise.then(function () {
                return _this.addAll(chunk);
            });
        };
        MiniSearch.prototype.remove = function (document2) {
            var _this = this;
            var _a = this._options,
                tokenize = _a.tokenize,
                processTerm = _a.processTerm,
                extractField = _a.extractField,
                fields = _a.fields,
                idField = _a.idField;
            var id = extractField(document2, idField);
            if (id == null) {
                throw new Error('MiniSearch: document does not have ID field "' + idField + '"');
            }
            var _b = __read(
                    Object.entries(this._documentIds).find(function (_a2) {
                        var _b2 = __read(_a2, 2);
                        _b2[0];
                        var longId = _b2[1];
                        return id === longId;
                    }) || [],
                    1,
                ),
                shortDocumentId = _b[0];
            if (shortDocumentId == null) {
                throw new Error('MiniSearch: cannot remove document with ID ' + id + ': it is not in the index');
            }
            fields.forEach(function (field) {
                var fieldValue = extractField(document2, field);
                if (fieldValue == null) {
                    return;
                }
                var tokens = tokenize(fieldValue.toString(), field);
                tokens.forEach(function (term) {
                    var processedTerm = processTerm(term, field);
                    if (processedTerm) {
                        _this.removeTerm(_this._fieldIds[field], shortDocumentId, processedTerm);
                    }
                });
                _this.removeFieldLength(shortDocumentId, _this._fieldIds[field], _this.documentCount, tokens.length);
            });
            delete this._storedFields[shortDocumentId];
            delete this._documentIds[shortDocumentId];
            delete this._fieldLength[shortDocumentId];
            this._documentCount -= 1;
        };
        MiniSearch.prototype.removeAll = function (documents) {
            var _this = this;
            if (documents) {
                documents.forEach(function (document2) {
                    return _this.remove(document2);
                });
            } else if (arguments.length > 0) {
                throw new Error('Expected documents to be present. Omit the argument to remove all documents.');
            } else {
                this._index = new SearchableMap();
                this._documentCount = 0;
                this._documentIds = {};
                this._fieldLength = {};
                this._averageFieldLength = {};
                this._storedFields = {};
                this._nextId = 0;
            }
        };
        MiniSearch.prototype.search = function (queryString, searchOptions) {
            var _this = this;
            if (searchOptions === void 0) {
                searchOptions = {};
            }
            var _a = this._options,
                tokenize = _a.tokenize,
                processTerm = _a.processTerm,
                globalSearchOptions = _a.searchOptions;
            var options = __assign(__assign({ tokenize, processTerm }, globalSearchOptions), searchOptions);
            var searchTokenize = options.tokenize,
                searchProcessTerm = options.processTerm;
            var terms = searchTokenize(queryString)
                .map(function (term) {
                    return searchProcessTerm(term);
                })
                .filter(function (term) {
                    return !!term;
                });
            var queries = terms.map(termToQuery(options));
            var results = queries.map(function (query) {
                return _this.executeQuery(query, options);
            });
            var combinedResults = this.combineResults(results, options.combineWith);
            return Object.entries(combinedResults)
                .reduce(function (results2, _a2) {
                    var _b = __read(_a2, 2),
                        docId = _b[0],
                        _c = _b[1],
                        score = _c.score,
                        match = _c.match,
                        terms2 = _c.terms;
                    var result = {
                        id: _this._documentIds[docId],
                        terms: uniq(terms2),
                        score,
                        match,
                    };
                    Object.assign(result, _this._storedFields[docId]);
                    if (options.filter == null || options.filter(result)) {
                        results2.push(result);
                    }
                    return results2;
                }, [])
                .sort(function (_a2, _b) {
                    var a = _a2.score;
                    var b = _b.score;
                    return a < b ? 1 : -1;
                });
        };
        MiniSearch.prototype.autoSuggest = function (queryString, options) {
            if (options === void 0) {
                options = {};
            }
            options = __assign(__assign({}, defaultAutoSuggestOptions), options);
            var suggestions = this.search(queryString, options).reduce(function (suggestions2, _a) {
                var score = _a.score,
                    terms = _a.terms;
                var phrase = terms.join(' ');
                if (suggestions2[phrase] == null) {
                    suggestions2[phrase] = { score, terms, count: 1 };
                } else {
                    suggestions2[phrase].score += score;
                    suggestions2[phrase].count += 1;
                }
                return suggestions2;
            }, {});
            return Object.entries(suggestions)
                .map(function (_a) {
                    var _b = __read(_a, 2),
                        suggestion = _b[0],
                        _c = _b[1],
                        score = _c.score,
                        terms = _c.terms,
                        count = _c.count;
                    return { suggestion, terms, score: score / count };
                })
                .sort(function (_a, _b) {
                    var a = _a.score;
                    var b = _b.score;
                    return a < b ? 1 : -1;
                });
        };
        Object.defineProperty(MiniSearch.prototype, 'documentCount', {
            get: function () {
                return this._documentCount;
            },
            enumerable: false,
            configurable: true,
        });
        MiniSearch.loadJSON = function (json, options) {
            if (options == null) {
                throw new Error(
                    'MiniSearch: loadJSON should be given the same options used when serializing the index',
                );
            }
            return MiniSearch.loadJS(JSON.parse(json), options);
        };
        MiniSearch.getDefault = function (optionName) {
            if (defaultOptions.hasOwnProperty(optionName)) {
                return getOwnProperty(defaultOptions, optionName);
            } else {
                throw new Error('MiniSearch: unknown option "' + optionName + '"');
            }
        };
        MiniSearch.loadJS = function (js, options) {
            var index = js.index,
                documentCount = js.documentCount,
                nextId = js.nextId,
                documentIds = js.documentIds,
                fieldIds = js.fieldIds,
                fieldLength = js.fieldLength,
                averageFieldLength = js.averageFieldLength,
                storedFields = js.storedFields;
            var miniSearch = new MiniSearch(options);
            miniSearch._index = new SearchableMap(index._tree, index._prefix);
            miniSearch._documentCount = documentCount;
            miniSearch._nextId = nextId;
            miniSearch._documentIds = documentIds;
            miniSearch._fieldIds = fieldIds;
            miniSearch._fieldLength = fieldLength;
            miniSearch._averageFieldLength = averageFieldLength;
            miniSearch._fieldIds = fieldIds;
            miniSearch._storedFields = storedFields || {};
            return miniSearch;
        };
        MiniSearch.prototype.executeQuery = function (query, searchOptions) {
            var _this = this;
            var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
            var boosts = (options.fields || this._options.fields).reduce(function (boosts2, field) {
                var _a2;
                return __assign(
                    __assign({}, boosts2),
                    ((_a2 = {}), (_a2[field] = getOwnProperty(boosts2, field) || 1), _a2),
                );
            }, options.boost || {});
            var boostDocument = options.boostDocument,
                weights = options.weights;
            var _a = __assign(__assign({}, defaultSearchOptions.weights), weights),
                fuzzyWeight = _a.fuzzy,
                prefixWeight = _a.prefix;
            var exactMatch = this.termResults(query.term, boosts, boostDocument, this._index.get(query.term));
            if (!query.fuzzy && !query.prefix) {
                return exactMatch;
            }
            var results = [exactMatch];
            if (query.prefix) {
                this._index.atPrefix(query.term).forEach(function (term, data) {
                    var weightedDistance = (0.3 * (term.length - query.term.length)) / term.length;
                    results.push(_this.termResults(term, boosts, boostDocument, data, prefixWeight, weightedDistance));
                });
            }
            if (query.fuzzy) {
                var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
                var maxDistance = fuzzy < 1 ? Math.round(query.term.length * fuzzy) : fuzzy;
                Object.entries(this._index.fuzzyGet(query.term, maxDistance)).forEach(function (_a2) {
                    var _b = __read(_a2, 2),
                        term = _b[0],
                        _c = __read(_b[1], 2),
                        data = _c[0],
                        distance = _c[1];
                    var weightedDistance = distance / term.length;
                    results.push(_this.termResults(term, boosts, boostDocument, data, fuzzyWeight, weightedDistance));
                });
            }
            return results.reduce(combinators[OR], {});
        };
        MiniSearch.prototype.combineResults = function (results, combineWith) {
            if (combineWith === void 0) {
                combineWith = OR;
            }
            if (results.length === 0) {
                return {};
            }
            var operator = combineWith.toLowerCase();
            return results.reduce(combinators[operator], null) || {};
        };
        MiniSearch.prototype.toJSON = function () {
            return {
                index: this._index,
                documentCount: this._documentCount,
                nextId: this._nextId,
                documentIds: this._documentIds,
                fieldIds: this._fieldIds,
                fieldLength: this._fieldLength,
                averageFieldLength: this._averageFieldLength,
                storedFields: this._storedFields,
            };
        };
        MiniSearch.prototype.termResults = function (term, boosts, boostDocument, indexData, weight, editDistance) {
            var _this = this;
            if (editDistance === void 0) {
                editDistance = 0;
            }
            if (indexData == null) {
                return {};
            }
            return Object.entries(boosts).reduce(function (results, _a) {
                var _b = __read(_a, 2),
                    field = _b[0],
                    boost = _b[1];
                var fieldId = _this._fieldIds[field];
                var _c = indexData[fieldId] || { ds: {} },
                    df = _c.df,
                    ds = _c.ds;
                Object.entries(ds).forEach(function (_a2) {
                    var _b2 = __read(_a2, 2),
                        documentId = _b2[0],
                        tf = _b2[1];
                    var docBoost = boostDocument ? boostDocument(_this._documentIds[documentId], term) : 1;
                    if (!docBoost) {
                        return;
                    }
                    var normalizedLength = _this._fieldLength[documentId][fieldId] / _this._averageFieldLength[fieldId];
                    results[documentId] = results[documentId] || { score: 0, match: {}, terms: [] };
                    results[documentId].terms.push(term);
                    results[documentId].match[term] = getOwnProperty(results[documentId].match, term) || [];
                    results[documentId].score +=
                        docBoost * score(tf, df, _this._documentCount, normalizedLength, boost, editDistance);
                    results[documentId].match[term].push(field);
                });
                return results;
            }, {});
        };
        MiniSearch.prototype.addTerm = function (fieldId, documentId, term) {
            this._index.update(term, function (indexData) {
                var _a;
                indexData = indexData || {};
                var fieldIndex = indexData[fieldId] || { df: 0, ds: {} };
                if (fieldIndex.ds[documentId] == null) {
                    fieldIndex.df += 1;
                }
                fieldIndex.ds[documentId] = (fieldIndex.ds[documentId] || 0) + 1;
                return __assign(__assign({}, indexData), ((_a = {}), (_a[fieldId] = fieldIndex), _a));
            });
        };
        MiniSearch.prototype.removeTerm = function (fieldId, documentId, term) {
            var _this = this;
            if (!this._index.has(term)) {
                this.warnDocumentChanged(documentId, fieldId, term);
                return;
            }
            this._index.update(term, function (indexData) {
                var _a;
                var fieldIndex = indexData[fieldId];
                if (fieldIndex == null || fieldIndex.ds[documentId] == null) {
                    _this.warnDocumentChanged(documentId, fieldId, term);
                    return indexData;
                }
                if (fieldIndex.ds[documentId] <= 1) {
                    if (fieldIndex.df <= 1) {
                        delete indexData[fieldId];
                        return indexData;
                    }
                    fieldIndex.df -= 1;
                }
                if (fieldIndex.ds[documentId] <= 1) {
                    delete fieldIndex.ds[documentId];
                    return indexData;
                }
                fieldIndex.ds[documentId] -= 1;
                return __assign(__assign({}, indexData), ((_a = {}), (_a[fieldId] = fieldIndex), _a));
            });
            if (Object.keys(this._index.get(term)).length === 0) {
                this._index.delete(term);
            }
        };
        MiniSearch.prototype.warnDocumentChanged = function (shortDocumentId, fieldId, term) {
            if (console == null || console.warn == null) {
                return;
            }
            var fieldName = Object.entries(this._fieldIds).find(function (_a) {
                var _b = __read(_a, 2);
                _b[0];
                var id = _b[1];
                return id === fieldId;
            })[0];
            console.warn(
                'MiniSearch: document with ID ' +
                    this._documentIds[shortDocumentId] +
                    ' has changed before removal: term "' +
                    term +
                    '" was not present in field "' +
                    fieldName +
                    '". Removing a document after it has changed can corrupt the index!',
            );
        };
        MiniSearch.prototype.addDocumentId = function (documentId) {
            var shortDocumentId = this._nextId.toString(36);
            this._documentIds[shortDocumentId] = documentId;
            this._documentCount += 1;
            this._nextId += 1;
            return shortDocumentId;
        };
        MiniSearch.prototype.addFields = function (fields) {
            var _this = this;
            fields.forEach(function (field, i) {
                _this._fieldIds[field] = i;
            });
        };
        MiniSearch.prototype.addFieldLength = function (documentId, fieldId, count, length) {
            this._averageFieldLength[fieldId] = this._averageFieldLength[fieldId] || 0;
            var totalLength = this._averageFieldLength[fieldId] * count + length;
            this._fieldLength[documentId] = this._fieldLength[documentId] || {};
            this._fieldLength[documentId][fieldId] = length;
            this._averageFieldLength[fieldId] = totalLength / (count + 1);
        };
        MiniSearch.prototype.removeFieldLength = function (documentId, fieldId, count, length) {
            var totalLength = this._averageFieldLength[fieldId] * count - length;
            this._averageFieldLength[fieldId] = totalLength / (count - 1);
        };
        MiniSearch.prototype.saveStoredFields = function (documentId, doc) {
            var _this = this;
            var _a = this._options,
                storeFields = _a.storeFields,
                extractField = _a.extractField;
            if (storeFields == null || storeFields.length === 0) {
                return;
            }
            this._storedFields[documentId] = this._storedFields[documentId] || {};
            storeFields.forEach(function (fieldName) {
                var fieldValue = extractField(doc, fieldName);
                if (fieldValue === void 0) {
                    return;
                }
                _this._storedFields[documentId][fieldName] = fieldValue;
            });
        };
        return MiniSearch;
    })();
    var getOwnProperty = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
    };
    var combinators =
        ((_a$1 = {}),
        (_a$1[OR] = function (a, b) {
            return Object.entries(b).reduce(function (combined, _a) {
                var _b;
                var _c = __read(_a, 2),
                    documentId = _c[0],
                    _d = _c[1],
                    score = _d.score,
                    match = _d.match,
                    terms = _d.terms;
                if (combined[documentId] == null) {
                    combined[documentId] = { score, match, terms };
                } else {
                    combined[documentId].score += score;
                    combined[documentId].score *= 1.5;
                    (_b = combined[documentId].terms).push.apply(_b, __spreadArray([], __read(terms)));
                    Object.assign(combined[documentId].match, match);
                }
                return combined;
            }, a || {});
        }),
        (_a$1[AND] = function (a, b) {
            if (a == null) {
                return b;
            }
            return Object.entries(b).reduce(function (combined, _a) {
                var _b = __read(_a, 2),
                    documentId = _b[0],
                    _c = _b[1],
                    score = _c.score,
                    match = _c.match,
                    terms = _c.terms;
                if (a[documentId] === void 0) {
                    return combined;
                }
                combined[documentId] = combined[documentId] || {};
                combined[documentId].score = a[documentId].score + score;
                combined[documentId].match = __assign(__assign({}, a[documentId].match), match);
                combined[documentId].terms = __spreadArray(
                    __spreadArray([], __read(a[documentId].terms)),
                    __read(terms),
                );
                return combined;
            }, {});
        }),
        _a$1);
    var tfIdf = function (tf, df, n) {
        return tf * Math.log(n / df);
    };
    var score = function (termFrequency, documentFrequency, documentCount, normalizedLength, boost, editDistance) {
        var weight = boost / (1 + 0.333 * boost * editDistance);
        return (weight * tfIdf(termFrequency, documentFrequency, documentCount)) / normalizedLength;
    };
    var termToQuery = function (options) {
        return function (term, i, terms) {
            var fuzzy = typeof options.fuzzy === 'function' ? options.fuzzy(term, i, terms) : options.fuzzy || false;
            var prefix =
                typeof options.prefix === 'function' ? options.prefix(term, i, terms) : options.prefix === true;
            return { term, fuzzy, prefix };
        };
    };
    var uniq = function (array) {
        return array.filter(function (element, i, array2) {
            return array2.indexOf(element) === i;
        });
    };
    var defaultOptions = {
        idField: 'id',
        extractField: function (document2, fieldName) {
            return document2[fieldName];
        },
        tokenize: function (text, fieldName) {
            return text.split(SPACE_OR_PUNCTUATION);
        },
        processTerm: function (term, fieldName) {
            return term.toLowerCase();
        },
        fields: void 0,
        searchOptions: void 0,
        storeFields: [],
    };
    var defaultSearchOptions = {
        combineWith: OR,
        prefix: false,
        fuzzy: false,
        boost: {},
        weights: { fuzzy: 0.9, prefix: 0.75 },
    };
    var defaultAutoSuggestOptions = {
        prefix: function (term, i, terms) {
            return i === terms.length - 1;
        },
    };
    var SPACE_OR_PUNCTUATION =
        /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;
    function sameItems(...args) {
        var _a, _b, _c;
        const arrays = args.filter((arg) => Array.isArray(arg));
        const settings = Object.assign(
            { references: true, hash: true },
            (_a = args.filter((arg) => plainObject$3(arg))[0]) !== null && _a !== void 0 ? _a : {},
        );
        if (arrays.length > 2) {
            let newArray = arrays[0];
            arrays.forEach((currentArray) => {
                newArray = sameItems(newArray, currentArray, settings);
            });
            return unique(newArray);
        } else {
            const array1 = (_b = arrays[0]) !== null && _b !== void 0 ? _b : [],
                array2 = (_c = arrays[1]) !== null && _c !== void 0 ? _c : [];
            const sameArray = [];
            array1.forEach((array1Item) => {
                let array1ItemHash = array1Item;
                if (typeof array1Item !== 'string' && settings.hash) {
                    array1ItemHash = __md5$2.encrypt(array1Item);
                }
                array2.forEach((array2Item) => {
                    let array2ItemHash = array2Item;
                    if (typeof array2Item !== 'string' && settings.hash) {
                        array2ItemHash = __md5$2.encrypt(array2Item);
                        if (array1ItemHash === array2ItemHash) {
                            sameArray.push(array1Item);
                            return;
                        }
                    } else if (array1Item === array2Item) {
                        sameArray.push(array1Item);
                        return;
                    }
                });
            });
            return unique(sameArray);
        }
    }
    function onScrollEnd($elm, callback, settings) {
        const finalSettings = Object.assign(
            { offset: 20, once: false, times: -1 },
            settings !== null && settings !== void 0 ? settings : {},
        );
        let isBody = false;
        let $scrollListenedElm = $elm;
        let $scrollHeightElm = $elm;
        if ($elm === window.document.body) {
            isBody = true;
            $scrollListenedElm = document;
            $scrollHeightElm = window.document.body;
        } else if ($elm === window.document) {
            isBody = true;
            $elm = window.document.body;
            $scrollHeightElm = window.document.body;
        }
        let active = true,
            count = 0;
        const internalCallback = (e) => {
            let fullHeight, viewportHeight, scrollTop;
            if (isBody) {
                viewportHeight = window.innerHeight;
                scrollTop = $scrollHeightElm.scrollTop;
                fullHeight = Math.max(
                    window.document.body.scrollHeight,
                    window.document.documentElement.scrollHeight,
                    window.document.body.offsetHeight,
                    window.document.documentElement.offsetHeight,
                    window.document.body.clientHeight,
                    window.document.documentElement.clientHeight,
                );
            } else {
                viewportHeight = $scrollHeightElm.scrollHeight;
                scrollTop = $scrollHeightElm.scrollTop;
                fullHeight = $scrollHeightElm.scrollHeight;
            }
            if (active && scrollTop + viewportHeight >= fullHeight - finalSettings.offset) {
                callback();
                count++;
                if (finalSettings.once) {
                    $scrollListenedElm.removeEventListener('scroll', internalCallback);
                    active = false;
                } else if (finalSettings.times > 0 && count >= finalSettings.times) {
                    $scrollListenedElm.removeEventListener('scroll', internalCallback);
                    active = false;
                }
            } else if (
                $scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop <
                $scrollHeightElm.scrollHeight - finalSettings.offset
            ) {
                active = true;
            }
        };
        $scrollListenedElm.addEventListener('scroll', internalCallback);
    }
    var __awaiter$5 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    function getState() {
        var _a;
        const state = JSON.parse(
            (_a = window.localStorage.getItem('coffeekrakenio')) !== null && _a !== void 0 ? _a : '{}',
        );
        return state;
    }
    function getCurrentVersion() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const docmapJson = yield loadDocmap();
            let version;
            if (document.location.hostname.split('.').length >= 4) {
                version = document.location.hostname.split('.').slice(0, 3).join('.').replace(/^v/, '');
            }
            return version !== null && version !== void 0 ? version : docmapJson.snapshots.slice(-1)[0];
        });
    }
    function setState(stateObj) {
        const state = getState();
        const newState = deepMerge(state, stateObj);
        window.localStorage.setItem('coffeekrakenio', JSON.stringify(newState));
    }
    let _docmap, _docmapPromise;
    function loadDocmap() {
        var _a;
        return __awaiter$5(this, void 0, void 0, function* () {
            const state = getState();
            if (_docmap) return _docmap;
            if (_docmapPromise) return (yield _docmapPromise).data;
            const request = new SRequest({
                url: `/api/docmap?v=${(_a = state.version) !== null && _a !== void 0 ? _a : ''}`,
                method: 'GET',
            });
            const promise = request.send();
            _docmapPromise = promise;
            _docmap = (yield promise).data;
            return _docmap;
        });
    }
    var __decorate$2 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$4 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class DocNav extends SLitElement {
        constructor() {
            super();
            this.maxItems = 10;
            this._maxItemsToDisplay = 10;
            this._filteredItems = {};
            this._docmap = {};
            this._saved = {
                search: '',
                platforms: [],
                types: [],
                statuses: [],
            };
            this._striptags = striptags;
            this._displayItemsCount = 0;
            this._searchTimeout = 0;
            this._renderExample = false;
            console.log('Hello');
            (() =>
                __awaiter$4(this, void 0, void 0, function* () {
                    const docmapJson = yield loadDocmap();
                    this._docmap = docmapJson;
                    this._restoreState();
                    const queryStringObj = queryStringToObject(document.location.search);
                    if (queryStringObj.search) {
                        this._saved.search = queryStringObj.search;
                    }
                    this._filterItems();
                    yield wait$1();
                    onScrollEnd(document.body, () => {
                        this._maxItemsToDisplay += this.maxItems;
                        this._filterItems({
                            reset: false,
                        });
                    });
                }))();
        }
        get availablePlatforms() {
            if (!this._docmap.map) return [];
            const availablePlatforms = [];
            Object.keys(this._docmap.map).forEach((namespace) => {
                const docmapObj = this._docmap.map[namespace];
                if (!docmapObj.platform) return;
                docmapObj.platform.forEach((platform) => {
                    if (availablePlatforms.indexOf(platform.name) === -1) availablePlatforms.push(platform.name);
                });
            });
            return availablePlatforms;
        }
        get availableTypes() {
            if (!this._docmap.map) return [];
            const availableTypes = [];
            Object.keys(this._docmap.map).forEach((namespace) => {
                const docmapObj = this._docmap.map[namespace];
                if (!docmapObj.type) return;
                if (availableTypes.indexOf(docmapObj.type) === -1) availableTypes.push(docmapObj.type);
            });
            return availableTypes;
        }
        get availableStatuses() {
            if (!this._docmap.map) return [];
            const availableStatus = [];
            Object.keys(this._docmap.map).forEach((namespace) => {
                const docmapObj = this._docmap.map[namespace];
                if (!docmapObj.status) return;
                if (availableStatus.indexOf(docmapObj.status) === -1) availableStatus.push(docmapObj.status);
            });
            return availableStatus;
        }
        _filterItems(settings = {}) {
            settings = Object.assign({ reset: true }, settings);
            if (settings.reset) this._maxItemsToDisplay = this.maxItems;
            this._displayItemsCount = 0;
            let items = Object.values(this._docmap.map).map((i) => {
                i.id = i.name;
                return i;
            });
            if (this._saved.search) {
                let miniSearch = new MiniSearch({
                    fields: ['name', 'namespace', 'description', 'since', 'type', 'status'],
                    storeFields: Object.keys(items[0]),
                });
                miniSearch.addAll(items);
                items = miniSearch.search(this._saved.search);
            }
            let newItems = [];
            for (let i = 0; i < items.length; i++) {
                const docmapObj = items[i];
                if (this._displayItemsCount >= this._maxItemsToDisplay) break;
                if (this._saved.platforms.length) {
                    if (!docmapObj.platform) continue;
                    const samePlatforms = sameItems(
                        docmapObj.platform.map((l) => l.name),
                        this._saved.platforms,
                    );
                    if (!samePlatforms.length) continue;
                }
                if (this._saved.types.length) {
                    if (this._saved.types.indexOf(docmapObj.type) === -1) continue;
                }
                if (this._saved.statuses.length) {
                    if (this._saved.statuses.indexOf(docmapObj.status) === -1) continue;
                }
                this._displayItemsCount++;
                newItems.push(docmapObj);
            }
            this._filteredItems = newItems;
        }
        _search(e) {
            clearTimeout(this._searchTimeout);
            this._searchTimeout = setTimeout(() => {
                this._saved = Object.assign(Object.assign({}, this._saved), { search: e.target.value });
                this._filterItems();
                this._saveState();
            }, 300);
        }
        _togglePlatform(platform) {
            const idx = this._saved.platforms.indexOf(platform);
            if (idx !== -1) {
                this._saved.platforms.splice(idx, 1);
                this._saved = Object.assign(Object.assign({}, this._saved), { platforms: this._saved.platforms });
            } else {
                this._saved = Object.assign(Object.assign({}, this._saved), {
                    platforms: [...this._saved.platforms, platform],
                });
            }
            this._filterItems();
            this._saveState();
        }
        _toggleType(type) {
            const idx = this._saved.types.indexOf(type);
            if (idx !== -1) {
                this._saved.types.splice(idx, 1);
                this._saved = Object.assign(Object.assign({}, this._saved), { types: this._saved.types });
            } else {
                this._saved = Object.assign(Object.assign({}, this._saved), { types: [...this._saved.types, type] });
            }
            this._filterItems();
            this._saveState();
        }
        _toggleStatus(status) {
            const idx = this._saved.statuses.indexOf(status);
            if (idx !== -1) {
                this._saved.statuses.splice(idx, 1);
                this._saved = Object.assign(Object.assign({}, this._saved), { statuses: this._saved.statuses });
            } else {
                this._saved = Object.assign(Object.assign({}, this._saved), {
                    statuses: [...this._saved.statuses, status],
                });
            }
            this._filterItems();
            this._saveState();
        }
        _saveState() {
            setState({
                docList: this._saved,
            });
        }
        _restoreState() {
            return __awaiter$4(this, void 0, void 0, function* () {
                const state = yield getState();
                if (!state.docList) return;
                this._saved = state.docList;
            });
        }
        createRenderRoot() {
            return this;
        }
        render() {
            if (!this._renderExampleTimeout) {
                this._renderExample = false;
                this._renderExampleTimeout = setTimeout(() => {
                    this._renderExample = true;
                    this.requestUpdate();
                    setTimeout(() => {
                        this._renderExampleTimeout = null;
                    });
                });
            }
            const tpl = html$4`
            <div class="s-grid:12222">
                <nav class="__nav">
                    <form name="doc">
                        <fieldset class="__nav-search s-mb:30 s-pr:30 s-pt:30">
                            <input
                                type="text"
                                class="s-input s-width:100"
                                name="search"
                                placeholder="Search doc"
                                value="${this._saved.search}"
                                @keyup="${this._search}"
                            />
                        </fieldset>

                        <fieldset class="__nav-platform s-mb:30">
                            <legend class="s-typo:h6 s-mb:30">Platform</legend>
                            <dl class="s-list s-bg:even">
                                ${this.availablePlatforms.map((platform) => {
                                    var _a;
                                    return html$4`
                                        <dt class="s-flex s-font:40 s-p:20 s-pr:30 s-bg:ui-background">
                                            <label class="s-flex-item:grow" for="platform-${platform}">
                                                ${platform}
                                            </label>
                                            <label for="platform-${platform}">
                                                <input
                                                    name="platform-${platform}"
                                                    class="s-switch s-color:accent"
                                                    type="checkbox"
                                                    id="platform-${platform}"
                                                    @change="${() => this._togglePlatform(platform)}"
                                                    ?checked="${
                                                        ((_a = this._saved.platforms) !== null && _a !== void 0
                                                            ? _a
                                                            : []
                                                        ).indexOf(platform) !== -1
                                                    }"
                                                />
                                            </label>
                                        </dt>
                                    `;
                                })}
                            </dl>
                        </fieldset>

                        <fieldset class="__nav-type s-mb:30">
                            <legend class="s-typo:h6 s-mb:30">Type</legend>
                            <dl class="s-list s-bg:even">
                                ${this.availableTypes.map((type) => {
                                    var _a;
                                    return html$4`
                                        <dt class="s-flex s-font:40 s-p:20 s-pr:30 s-bg:ui-background">
                                            <label class="s-flex-item:grow" for="type-${type}"> ${type} </label>
                                            <label for="type-${type}">
                                                <input
                                                    name="type-${type}"
                                                    class="s-switch s-color:accent"
                                                    type="checkbox"
                                                    id="type-${type}"
                                                    @change="${() => this._toggleType(type)}"
                                                    ?checked="${
                                                        ((_a = this._saved.types) !== null && _a !== void 0
                                                            ? _a
                                                            : []
                                                        ).indexOf(type) !== -1
                                                    }"
                                                />
                                            </label>
                                        </dt>
                                    `;
                                })}
                            </dl>
                        </fieldset>

                        <fieldset class="__nav-status s-mb:30">
                            <legend class="s-typo:h6 s-mb:30">Status</legend>
                            <dl class="s-list s-bg:even">
                                ${this.availableStatuses.map((status) => {
                                    var _a;
                                    return html$4`
                                        <dt class="s-flex s-font:40 s-p:20 s-pr:30 s-bg:ui-background">
                                            <label class="s-flex-item:grow" for="status-${status}"> ${status} </label>
                                            <label for="status-${status}">
                                                <input
                                                    name="status-${status}"
                                                    type="checkbox"
                                                    class="s-switch s-color:accent"
                                                    id="status-${status}"
                                                    @change="${() => this._toggleStatus(status)}"
                                                    ?checked="${
                                                        ((_a = this._saved.statuses) !== null && _a !== void 0
                                                            ? _a
                                                            : []
                                                        ).indexOf(status) !== -1
                                                    }"
                                                />
                                            </label>
                                        </dt>
                                    `;
                                })}
                            </dl>
                        </fieldset>
                    </form>
                </nav>
                <section class="__list">
                    ${Object.values(this._filteredItems).map(
                        (item) => html$4`
                            <div class="__list-item">
                                <div class="s-p:50">
                                    <div class="">
                                        <div class="s-flex">
                                            <div class="s-flex-item:grow">
                                                <div>
                                                    ${item.platform.map(
                                                        (platform) => html$4`
                                                            <i
                                                                class="s-platform:${platform.name} s-font:80 s-mb:30 s-mr:10"
                                                            ></i>
                                                        `,
                                                    )}
                                                </div>
                                                <h4
                                                    class="s-font:title s-font:60 s-tc:accent s-mb:10 s-flex-item:grow"
                                                >
                                                    <a
                                                        href="/doc/api/${this._striptags(
                                                            item.namespace,
                                                        )}.${this._striptags(item.name)}"
                                                    >
                                                        ${item.name}
                                                    </a>
                                                </h4>
                                            </div>
                                            <div>
                                                <div class="s-font:40">
                                                    <span class="s-font:30"
                                                        >Since
                                                        <span class="s-tc:complementary"
                                                            >${item.since}</span
                                                        ></span
                                                    >
                                                    &nbsp;
                                                    <span class="s-badge:pill:${item.status}"
                                                        >${item.status}</span
                                                    >
                                                </div>
                                            </div>
                                        </div>
                                        <h5 class="s-tc:complementary s-font:40 s-mb:30">
                                            ${item.namespace}
                                        </h5>
                                        <p class="s-typo:p s-mb:30">${item.description}</p>
                                    </div>
                                    ${
                                        item.example && item.example.length
                                            ? html$4`
                                              <div class="__code">
                                                  ${
                                                      this._renderExample
                                                          ? html$4`
                                                            <s-code-example
                                                                default-style
                                                                style="max-width:100%;"
                                                                class="s-depth:50 s-flex-item:grow:shrink"
                                                            >
                                                                <textarea lang="${item.example[0].language}">
                                                ${item.example[0].code}                    
                                            </textarea
                                                                >
                                                            </s-code-example>
                                                            <div class="s-until:sibling:mounted">
                                                                <i class="s-loader:spinner s-color:accent"></i>
                                                                &nbsp;
                                                                <p class="s-typo:p s-display:inline-block">
                                                                    Loading code example. Please wait...
                                                                </p>
                                                            </div>
                                                        `
                                                          : ''
                                                  }
                                              </div>
                                          `
                                            : ''
                                    }
                                </div>
                            </div>
                        `,
                    )}
                </section>
            </div>
        `;
            return tpl;
        }
    }
    __decorate$2([property$1()], DocNav.prototype, '_maxItemsToDisplay', void 0);
    __decorate$2([property$1()], DocNav.prototype, '_filteredItems', void 0);
    __decorate$2([property$1()], DocNav.prototype, '_docmap', void 0);
    __decorate$2([property$1()], DocNav.prototype, '_saved', void 0);
    function webcomponent$2(tagName = 'doc-nav') {
        SComponentUtils.setDefaultProps({
            mountWhen: 'directly',
        });
        customElements.define(tagName, DocNav);
    }
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isCEPolyfill =
        typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !== void 0;
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    const boundAttributeSuffix = '$lit$';
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            const walker = document.createTreeWalker(element.content, 133, null, false);
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const {
                strings,
                values: { length },
            } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length: length2 } = attributes;
                        let count = 0;
                        for (let i = 0; i < length2; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            const stringForPart = strings[partIndex];
                            const name2 = lastAttributeNameRegex.exec(stringForPart)[2];
                            const attributeLookupName = name2.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name: name2, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                } else if (node.nodeType === 3) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings2 = data.split(markerRegex);
                        const lastIndex = strings2.length - 1;
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings2[i];
                            if (s === '') {
                                insert = createMarker();
                            } else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s =
                                        s.slice(0, match.index) +
                                        match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) +
                                        match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        if (strings2[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        } else {
                            node.data = strings2[lastIndex];
                        }
                        partIndex += lastIndex;
                    }
                } else if (node.nodeType === 8) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        if (node.nextSibling === null) {
                            node.data = '';
                        } else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    } else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    const createMarker = () => document.createComment('');
    const lastAttributeNameRegex =
        /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const walkerNodeFilter = 133;
    function removeNodesFromTemplate(template, nodesToRemove) {
        const {
            element: { content },
            parts,
        } = template;
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let part = parts[partIndex];
        let nodeIndex = -1;
        let removeCount = 0;
        const nodesToRemoveInTemplate = [];
        let currentRemovingNode = null;
        while (walker.nextNode()) {
            nodeIndex++;
            const node = walker.currentNode;
            if (node.previousSibling === currentRemovingNode) {
                currentRemovingNode = null;
            }
            if (nodesToRemove.has(node)) {
                nodesToRemoveInTemplate.push(node);
                if (currentRemovingNode === null) {
                    currentRemovingNode = node;
                }
            }
            if (currentRemovingNode !== null) {
                removeCount++;
            }
            while (part !== void 0 && part.index === nodeIndex) {
                part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                part = parts[partIndex];
            }
        }
        nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
    }
    const countNodes = (node) => {
        let count = node.nodeType === 11 ? 0 : 1;
        const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
        while (walker.nextNode()) {
            count++;
        }
        return count;
    };
    const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
        for (let i = startIndex + 1; i < parts.length; i++) {
            const part = parts[i];
            if (isTemplatePartActive(part)) {
                return i;
            }
        }
        return -1;
    };
    function insertNodeIntoTemplate(template, node, refNode = null) {
        const {
            element: { content },
            parts,
        } = template;
        if (refNode === null || refNode === void 0) {
            content.appendChild(node);
            return;
        }
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let insertCount = 0;
        let walkerIndex = -1;
        while (walker.nextNode()) {
            walkerIndex++;
            const walkerNode = walker.currentNode;
            if (walkerNode === refNode) {
                insertCount = countNodes(node);
                refNode.parentNode.insertBefore(node, refNode);
            }
            while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
                if (insertCount > 0) {
                    while (partIndex !== -1) {
                        parts[partIndex].index += insertCount;
                        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                    }
                    return;
                }
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            }
        }
    }
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };
    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const noChange = {};
    const nothing = {};
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== void 0) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== void 0) {
                    part.commit();
                }
            }
        }
        _clone() {
            const fragment = isCEPolyfill
                ? this.template.element.content.cloneNode(true)
                : document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            const walker = document.createTreeWalker(fragment, 133, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(void 0);
                    partIndex++;
                    continue;
                }
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                if (part.type === 'node') {
                    const part2 = this.processor.handleTextExpression(this.options);
                    part2.insertAfterNode(node.previousSibling);
                    this.__parts.push(part2);
                } else {
                    this.__parts.push(
                        ...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options),
                    );
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                const commentOpen = s.lastIndexOf('<!--');
                isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1;
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                } else {
                    html +=
                        s.substr(0, attributeMatch.index) +
                        attributeMatch[1] +
                        attributeMatch[2] +
                        boundAttributeSuffix +
                        attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== void 0) {
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return value === null || !(typeof value === 'object' || typeof value === 'function');
    };
    const isIterable = (value) => {
        return Array.isArray(value) || !!(value && value[Symbol.iterator]);
    };
    class AttributeCommitter {
        constructor(element, name2, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name2;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== void 0) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    } else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    class AttributePart {
        constructor(committer) {
            this.value = void 0;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    class NodePart {
        constructor(options) {
            this.value = void 0;
            this.__pendingValue = void 0;
            this.options = options;
        }
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        appendIntoPart(part) {
            part.__insert((this.startNode = createMarker()));
            part.__insert((this.endNode = createMarker()));
        }
        insertAfterPart(ref) {
            ref.__insert((this.startNode = createMarker()));
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            } else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            } else if (value instanceof Node) {
                this.__commitNode(value);
            } else if (isIterable(value)) {
                this.__commitIterable(value);
            } else if (value === nothing) {
                this.value = nothing;
                this.clear();
            } else {
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling && node.nodeType === 3) {
                node.data = valueAsString;
            } else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance && this.value.template === template) {
                this.value.update(value.values);
            } else {
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                itemPart = itemParts[partIndex];
                if (itemPart === void 0) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    } else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    class BooleanAttributePart {
        constructor(element, name2, strings) {
            this.value = void 0;
            this.__pendingValue = void 0;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name2;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                } else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name2, strings) {
            super(element, name2, strings);
            this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {}
    let eventOptionsSupported = false;
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                },
            };
            window.addEventListener('test', options, options);
            window.removeEventListener('test', options, options);
        } catch (_e) {}
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = void 0;
            this.__pendingValue = void 0;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener =
                newListener == null ||
                (oldListener != null &&
                    (newListener.capture !== oldListener.capture ||
                        newListener.once !== oldListener.once ||
                        newListener.passive !== oldListener.passive));
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event2) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event2);
            } else {
                this.value.handleEvent(event2);
            }
        }
    }
    const getOptions = (o) =>
        o && (eventOptionsSupported ? { capture: o.capture, passive: o.passive, once: o.once } : o.capture);
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    function templateFactory(result) {
        let templateCache = templateCaches.get(result.type);
        if (templateCache === void 0) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map(),
            };
            templateCaches.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== void 0) {
            return template;
        }
        const key = result.strings.join(marker);
        template = templateCache.keyString.get(key);
        if (template === void 0) {
            template = new Template(result, result.getTemplateElement());
            templateCache.keyString.set(key, template);
        }
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches = new Map();
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    const render$1 = (result, container, options) => {
        let part = parts.get(container);
        if (part === void 0) {
            removeNodes(container, container.firstChild);
            parts.set(container, (part = new NodePart(Object.assign({ templateFactory }, options))));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    class DefaultTemplateProcessor {
        handleAttributeExpressions(element, name2, strings, options) {
            const prefix = name2[0];
            if (prefix === '.') {
                const committer2 = new PropertyCommitter(element, name2.slice(1), strings);
                return committer2.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name2.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name2.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name2, strings);
            return committer.parts;
        }
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
    }
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
    let compatibleShadyCSSVersion = true;
    if (typeof window.ShadyCSS === 'undefined') {
        compatibleShadyCSSVersion = false;
    } else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
        console.warn(
            `Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`,
        );
        compatibleShadyCSSVersion = false;
    }
    const shadyTemplateFactory = (scopeName) => (result) => {
        const cacheKey = getTemplateCacheKey(result.type, scopeName);
        let templateCache = templateCaches.get(cacheKey);
        if (templateCache === void 0) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map(),
            };
            templateCaches.set(cacheKey, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== void 0) {
            return template;
        }
        const key = result.strings.join(marker);
        template = templateCache.keyString.get(key);
        if (template === void 0) {
            const element = result.getTemplateElement();
            if (compatibleShadyCSSVersion) {
                window.ShadyCSS.prepareTemplateDom(element, scopeName);
            }
            template = new Template(result, element);
            templateCache.keyString.set(key, template);
        }
        templateCache.stringsArray.set(result.strings, template);
        return template;
    };
    const TEMPLATE_TYPES = ['html', 'svg'];
    const removeStylesFromLitTemplates = (scopeName) => {
        TEMPLATE_TYPES.forEach((type) => {
            const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
            if (templates !== void 0) {
                templates.keyString.forEach((template) => {
                    const {
                        element: { content },
                    } = template;
                    const styles = new Set();
                    Array.from(content.querySelectorAll('style')).forEach((s) => {
                        styles.add(s);
                    });
                    removeNodesFromTemplate(template, styles);
                });
            }
        });
    };
    const shadyRenderSet = new Set();
    const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
        shadyRenderSet.add(scopeName);
        const templateElement = !!template ? template.element : document.createElement('template');
        const styles = renderedDOM.querySelectorAll('style');
        const { length } = styles;
        if (length === 0) {
            window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
            return;
        }
        const condensedStyle = document.createElement('style');
        for (let i = 0; i < length; i++) {
            const style2 = styles[i];
            style2.parentNode.removeChild(style2);
            condensedStyle.textContent += style2.textContent;
        }
        removeStylesFromLitTemplates(scopeName);
        const content = templateElement.content;
        if (!!template) {
            insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
        } else {
            content.insertBefore(condensedStyle, content.firstChild);
        }
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        const style = content.querySelector('style');
        if (window.ShadyCSS.nativeShadow && style !== null) {
            renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
        } else if (!!template) {
            content.insertBefore(condensedStyle, content.firstChild);
            const removes = new Set();
            removes.add(condensedStyle);
            removeNodesFromTemplate(template, removes);
        }
    };
    const render = (result, container, options) => {
        if (!options || typeof options !== 'object' || !options.scopeName) {
            throw new Error('The `scopeName` option is required.');
        }
        const scopeName = options.scopeName;
        const hasRendered = parts.has(container);
        const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
        const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
        const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
        render$1(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
        if (firstScopeRender) {
            const part = parts.get(renderContainer);
            parts.delete(renderContainer);
            const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
            prepareTemplateStyles(scopeName, renderContainer, template);
            removeNodes(container, container.firstChild);
            container.appendChild(renderContainer);
            parts.set(container, part);
        }
        if (!hasRendered && needsScoping) {
            window.ShadyCSS.styleElement(container.host);
        }
    };
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    var _a;
    window.JSCompiler_renameProperty = (prop, _obj) => prop;
    const defaultConverter = {
        toAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value ? '' : null;
                case Object:
                case Array:
                    return value == null ? value : JSON.stringify(value);
            }
            return value;
        },
        fromAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value !== null;
                case Number:
                    return value === null ? null : Number(value);
                case Object:
                case Array:
                    return JSON.parse(value);
            }
            return value;
        },
    };
    const notEqual = (value, old) => {
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration = {
        attribute: true,
        type: String,
        converter: defaultConverter,
        reflect: false,
        hasChanged: notEqual,
    };
    const STATE_HAS_UPDATED = 1;
    const STATE_UPDATE_REQUESTED = 1 << 2;
    const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
    const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
    const finalized = 'finalized';
    class UpdatingElement extends HTMLElement {
        constructor() {
            super();
            this.initialize();
        }
        static get observedAttributes() {
            this.finalize();
            const attributes = [];
            this._classProperties.forEach((v, p) => {
                const attr = this._attributeNameForProperty(p, v);
                if (attr !== void 0) {
                    this._attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            });
            return attributes;
        }
        static _ensureClassProperties() {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
                this._classProperties = new Map();
                const superProperties = Object.getPrototypeOf(this)._classProperties;
                if (superProperties !== void 0) {
                    superProperties.forEach((v, k) => this._classProperties.set(k, v));
                }
            }
        }
        static createProperty(name2, options = defaultPropertyDeclaration) {
            this._ensureClassProperties();
            this._classProperties.set(name2, options);
            if (options.noAccessor || this.prototype.hasOwnProperty(name2)) {
                return;
            }
            const key = typeof name2 === 'symbol' ? Symbol() : `__${name2}`;
            const descriptor = this.getPropertyDescriptor(name2, key, options);
            if (descriptor !== void 0) {
                Object.defineProperty(this.prototype, name2, descriptor);
            }
        }
        static getPropertyDescriptor(name2, key, options) {
            return {
                get() {
                    return this[key];
                },
                set(value) {
                    const oldValue = this[name2];
                    this[key] = value;
                    this.requestUpdateInternal(name2, oldValue, options);
                },
                configurable: true,
                enumerable: true,
            };
        }
        static getPropertyOptions(name2) {
            return (this._classProperties && this._classProperties.get(name2)) || defaultPropertyDeclaration;
        }
        static finalize() {
            const superCtor = Object.getPrototypeOf(this);
            if (!superCtor.hasOwnProperty(finalized)) {
                superCtor.finalize();
            }
            this[finalized] = true;
            this._ensureClassProperties();
            this._attributeToPropertyMap = new Map();
            if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
                const props = this.properties;
                const propKeys = [
                    ...Object.getOwnPropertyNames(props),
                    ...(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : []),
                ];
                for (const p of propKeys) {
                    this.createProperty(p, props[p]);
                }
            }
        }
        static _attributeNameForProperty(name2, options) {
            const attribute = options.attribute;
            return attribute === false
                ? void 0
                : typeof attribute === 'string'
                ? attribute
                : typeof name2 === 'string'
                ? name2.toLowerCase()
                : void 0;
        }
        static _valueHasChanged(value, old, hasChanged = notEqual) {
            return hasChanged(value, old);
        }
        static _propertyValueFromAttribute(value, options) {
            const type = options.type;
            const converter = options.converter || defaultConverter;
            const fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
            return fromAttribute ? fromAttribute(value, type) : value;
        }
        static _propertyValueToAttribute(value, options) {
            if (options.reflect === void 0) {
                return;
            }
            const type = options.type;
            const converter = options.converter;
            const toAttribute = (converter && converter.toAttribute) || defaultConverter.toAttribute;
            return toAttribute(value, type);
        }
        initialize() {
            this._updateState = 0;
            this._updatePromise = new Promise((res) => (this._enableUpdatingResolver = res));
            this._changedProperties = new Map();
            this._saveInstanceProperties();
            this.requestUpdateInternal();
        }
        _saveInstanceProperties() {
            this.constructor._classProperties.forEach((_v, p) => {
                if (this.hasOwnProperty(p)) {
                    const value = this[p];
                    delete this[p];
                    if (!this._instanceProperties) {
                        this._instanceProperties = new Map();
                    }
                    this._instanceProperties.set(p, value);
                }
            });
        }
        _applyInstanceProperties() {
            this._instanceProperties.forEach((v, p) => (this[p] = v));
            this._instanceProperties = void 0;
        }
        connectedCallback() {
            this.enableUpdating();
        }
        enableUpdating() {
            if (this._enableUpdatingResolver !== void 0) {
                this._enableUpdatingResolver();
                this._enableUpdatingResolver = void 0;
            }
        }
        disconnectedCallback() {}
        attributeChangedCallback(name2, old, value) {
            if (old !== value) {
                this._attributeToProperty(name2, value);
            }
        }
        _propertyToAttribute(name2, value, options = defaultPropertyDeclaration) {
            const ctor = this.constructor;
            const attr = ctor._attributeNameForProperty(name2, options);
            if (attr !== void 0) {
                const attrValue = ctor._propertyValueToAttribute(value, options);
                if (attrValue === void 0) {
                    return;
                }
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
                if (attrValue == null) {
                    this.removeAttribute(attr);
                } else {
                    this.setAttribute(attr, attrValue);
                }
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
            }
        }
        _attributeToProperty(name2, value) {
            if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
                return;
            }
            const ctor = this.constructor;
            const propName = ctor._attributeToPropertyMap.get(name2);
            if (propName !== void 0) {
                const options = ctor.getPropertyOptions(propName);
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
                this[propName] = ctor._propertyValueFromAttribute(value, options);
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
            }
        }
        requestUpdateInternal(name2, oldValue, options) {
            let shouldRequestUpdate = true;
            if (name2 !== void 0) {
                const ctor = this.constructor;
                options = options || ctor.getPropertyOptions(name2);
                if (ctor._valueHasChanged(this[name2], oldValue, options.hasChanged)) {
                    if (!this._changedProperties.has(name2)) {
                        this._changedProperties.set(name2, oldValue);
                    }
                    if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                        if (this._reflectingProperties === void 0) {
                            this._reflectingProperties = new Map();
                        }
                        this._reflectingProperties.set(name2, options);
                    }
                } else {
                    shouldRequestUpdate = false;
                }
            }
            if (!this._hasRequestedUpdate && shouldRequestUpdate) {
                this._updatePromise = this._enqueueUpdate();
            }
        }
        requestUpdate(name2, oldValue) {
            this.requestUpdateInternal(name2, oldValue);
            return this.updateComplete;
        }
        _enqueueUpdate() {
            return __async(this, null, function* () {
                this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
                try {
                    yield this._updatePromise;
                } catch (e) {}
                const result = this.performUpdate();
                if (result != null) {
                    yield result;
                }
                return !this._hasRequestedUpdate;
            });
        }
        get _hasRequestedUpdate() {
            return this._updateState & STATE_UPDATE_REQUESTED;
        }
        get hasUpdated() {
            return this._updateState & STATE_HAS_UPDATED;
        }
        performUpdate() {
            if (!this._hasRequestedUpdate) {
                return;
            }
            if (this._instanceProperties) {
                this._applyInstanceProperties();
            }
            let shouldUpdate = false;
            const changedProperties = this._changedProperties;
            try {
                shouldUpdate = this.shouldUpdate(changedProperties);
                if (shouldUpdate) {
                    this.update(changedProperties);
                } else {
                    this._markUpdated();
                }
            } catch (e) {
                shouldUpdate = false;
                this._markUpdated();
                throw e;
            }
            if (shouldUpdate) {
                if (!(this._updateState & STATE_HAS_UPDATED)) {
                    this._updateState = this._updateState | STATE_HAS_UPDATED;
                    this.firstUpdated(changedProperties);
                }
                this.updated(changedProperties);
            }
        }
        _markUpdated() {
            this._changedProperties = new Map();
            this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
        }
        get updateComplete() {
            return this._getUpdateComplete();
        }
        _getUpdateComplete() {
            return this.getUpdateComplete();
        }
        getUpdateComplete() {
            return this._updatePromise;
        }
        shouldUpdate(_changedProperties) {
            return true;
        }
        update(_changedProperties) {
            if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
                this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
                this._reflectingProperties = void 0;
            }
            this._markUpdated();
        }
        updated(_changedProperties) {}
        firstUpdated(_changedProperties) {}
    }
    _a = finalized;
    UpdatingElement[_a] = true;
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const standardProperty = (options, element) => {
        if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
            return Object.assign(Object.assign({}, element), {
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            });
        } else {
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                },
            };
        }
    };
    const legacyProperty = (options, proto, name2) => {
        proto.constructor.createProperty(name2, options);
    };
    function property(options) {
        return (protoOrDescriptor, name2) =>
            name2 !== void 0
                ? legacyProperty(options, protoOrDescriptor, name2)
                : standardProperty(options, protoOrDescriptor);
    }
    function queryAsync(selector) {
        return (protoOrDescriptor, name2) => {
            const descriptor = {
                get() {
                    return __async(this, null, function* () {
                        yield this.updateComplete;
                        return this.renderRoot.querySelector(selector);
                    });
                },
                enumerable: true,
                configurable: true,
            };
            return name2 !== void 0
                ? legacyQuery(descriptor, protoOrDescriptor, name2)
                : standardQuery(descriptor, protoOrDescriptor);
        };
    }
    const legacyQuery = (descriptor, proto, name2) => {
        Object.defineProperty(proto, name2, descriptor);
    };
    const standardQuery = (descriptor, element) => ({
        kind: 'method',
        placement: 'prototype',
        key: element.key,
        descriptor,
    });
    /**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */
    const supportsAdoptingStyleSheets =
        window.ShadowRoot &&
        (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) &&
        'adoptedStyleSheets' in Document.prototype &&
        'replace' in CSSStyleSheet.prototype;
    const constructionToken = Symbol();
    class CSSResult {
        constructor(cssText, safeToken) {
            if (safeToken !== constructionToken) {
                throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
            }
            this.cssText = cssText;
        }
        get styleSheet() {
            if (this._styleSheet === void 0) {
                if (supportsAdoptingStyleSheets) {
                    this._styleSheet = new CSSStyleSheet();
                    this._styleSheet.replaceSync(this.cssText);
                } else {
                    this._styleSheet = null;
                }
            }
            return this._styleSheet;
        }
        toString() {
            return this.cssText;
        }
    }
    const unsafeCSS = (value) => {
        return new CSSResult(String(value), constructionToken);
    };
    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    (window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.5.1');
    const renderNotImplemented = {};
    class LitElement extends UpdatingElement {
        static getStyles() {
            return this.styles;
        }
        static _getUniqueStyles() {
            if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
                return;
            }
            const userStyles = this.getStyles();
            if (Array.isArray(userStyles)) {
                const addStyles = (styles2, set2) =>
                    styles2.reduceRight(
                        (set3, s) => (Array.isArray(s) ? addStyles(s, set3) : (set3.add(s), set3)),
                        set2,
                    );
                const set = addStyles(userStyles, new Set());
                const styles = [];
                set.forEach((v) => styles.unshift(v));
                this._styles = styles;
            } else {
                this._styles = userStyles === void 0 ? [] : [userStyles];
            }
            this._styles = this._styles.map((s) => {
                if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
                    const cssText = Array.prototype.slice
                        .call(s.cssRules)
                        .reduce((css, rule) => css + rule.cssText, '');
                    return unsafeCSS(cssText);
                }
                return s;
            });
        }
        initialize() {
            super.initialize();
            this.constructor._getUniqueStyles();
            this.renderRoot = this.createRenderRoot();
            if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
                this.adoptStyles();
            }
        }
        createRenderRoot() {
            return this.attachShadow(this.constructor.shadowRootOptions);
        }
        adoptStyles() {
            const styles = this.constructor._styles;
            if (styles.length === 0) {
                return;
            }
            if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
                window.ShadyCSS.ScopingShim.prepareAdoptedCssText(
                    styles.map((s) => s.cssText),
                    this.localName,
                );
            } else if (supportsAdoptingStyleSheets) {
                this.renderRoot.adoptedStyleSheets = styles.map((s) => (s instanceof CSSStyleSheet ? s : s.styleSheet));
            } else {
                this._needsShimAdoptedStyleSheets = true;
            }
        }
        connectedCallback() {
            super.connectedCallback();
            if (this.hasUpdated && window.ShadyCSS !== void 0) {
                window.ShadyCSS.styleElement(this);
            }
        }
        update(changedProperties) {
            const templateResult = this.render();
            super.update(changedProperties);
            if (templateResult !== renderNotImplemented) {
                this.constructor.render(templateResult, this.renderRoot, {
                    scopeName: this.localName,
                    eventContext: this,
                });
            }
            if (this._needsShimAdoptedStyleSheets) {
                this._needsShimAdoptedStyleSheets = false;
                this.constructor._styles.forEach((s) => {
                    const style = document.createElement('style');
                    style.textContent = s.cssText;
                    this.renderRoot.appendChild(style);
                });
            }
        }
        render() {
            return renderNotImplemented;
        }
    }
    LitElement['finalized'] = true;
    LitElement.render = render;
    LitElement.shadowRootOptions = { mode: 'open' };
    var __decorate$1 = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$3 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class VersionSelector extends LitElement {
        constructor() {
            super();
            this._versions = [];
            (() =>
                __awaiter$3(this, void 0, void 0, function* () {
                    const docmapJson = yield loadDocmap();
                    this._versions = docmapJson.snapshots || [];
                    this._currentVersion = yield getCurrentVersion();
                }))();
        }
        createRenderRoot() {
            return this;
        }
        _change(e) {
            setTimeout(() => {
                let newLocation = document.location.href;
                if (document.location.href.match(/^https?:\/\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\./)) {
                    newLocation = document.location.href.replace(
                        /^(https?:\/\/v)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.(.*)/,
                        `$1${e.target.value}.$2`,
                    );
                } else {
                    newLocation = document.location.href.replace(/^(https?:\/\/)(.*)/, `$1v${e.target.value}.$2`);
                }
                document.location = newLocation;
            });
        }
        render() {
            return html`
                <label class="s-select">
                    <select @change="${this._change}">
                        ${this._versions.map(
                            (snap) => html`
                                <option ?selected="${this._currentVersion === snap}" value="${snap}">${snap}</option>
                            `,
                        )}
                    </select>
                </label>
            `;
        }
    }
    __decorate$1([property()], VersionSelector.prototype, '_currentVersion', void 0);
    __decorate$1([property()], VersionSelector.prototype, '_versions', void 0);
    function webcomponent$1(tagName = 'version-selector') {
        customElements.define(tagName, VersionSelector);
    }
    var __decorate = function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter$2 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class CkSettings extends LitElement {
        constructor() {
            super();
            this._settings = {
                darkMode: true,
                colors: {
                    accent: void 0,
                    complementary: void 0,
                },
            };
            (() =>
                __awaiter$2(this, void 0, void 0, function* () {
                    this._currentVersion = yield getCurrentVersion();
                }))();
            this._restoreState();
        }
        firstUpdated() {
            return __awaiter$2(this, void 0, void 0, function* () {
                const $root = document.querySelector(':root'),
                    $darkRoot = document.querySelector('.s-theme--dark'),
                    $theme = $darkRoot !== null && $darkRoot !== void 0 ? $darkRoot : $root;
                const $mainColorPicker = yield this._$mainColorPicker;
                const $accentColorPicker = yield this._$accentColorPicker;
                $mainColorPicker.addEventListener('change', (e) => {
                    $theme.style.setProperty('--s-theme-color-main-h', e.detail.hsla.h);
                    $theme.style.setProperty('--s-theme-color-main-s', e.detail.hsla.s);
                    $theme.style.setProperty('--s-theme-color-main-l', e.detail.hsla.l);
                });
                $accentColorPicker.addEventListener('change', (e) => {
                    $theme.style.setProperty('--s-theme-color-accent-h', e.detail.hsla.h);
                    $theme.style.setProperty('--s-theme-color-accent-s', e.detail.hsla.s);
                    $theme.style.setProperty('--s-theme-color-accent-l', e.detail.hsla.l);
                });
            });
        }
        _restoreState() {
            const state = getState();
            this.setDarkMode(state.darkMode);
        }
        _saveState() {
            setState(Object.assign({}, this._settings));
        }
        setDarkMode(mode) {
            this._settings.darkMode = mode;
            if (mode) {
                document.body.classList.add('s-theme--dark');
            } else {
                document.body.classList.remove('s-theme--dark');
            }
            this._saveState();
        }
        createRenderRoot() {
            return this;
        }
        render() {
            return html`
                <div class="s-p:10">
                    <ul class="__settings s-bg:odd">
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="theme-switcher">
                                Dark mode
                                <input
                                    class="s-switch"
                                    type="checkbox"
                                    id="theme-switcher"
                                    ?checked="${this._settings.darkMode}"
                                    @change="${(e) => {
                                        this.setDarkMode(e.target.checked);
                                    }}"
                                />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="theme-switcher">
                                Dark mode
                                <input
                                    class="s-switch s-color:accent"
                                    type="checkbox"
                                    id="theme-switcher"
                                    ?checked="${this._settings.darkMode}"
                                    @change="${(e) => {
                                        this.setDarkMode(e.target.checked);
                                    }}"
                                />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-main-color">
                                Main color
                                <s-color-picker id="setting-main-color" value="#ff0000" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Accent color
                                <s-color-picker id="setting-accent-color" value="#ff0000" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Complementary color
                                <s-color-picker id="setting-complementary-color" value="#ff0000" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <s-range
                                    name="hello"
                                    class="s-range s-cs"
                                    id="setting-spread"
                                    tooltip
                                    min="0"
                                    max="100"
                                    step="10"
                                ></s-range>
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <s-range
                                    name="coco"
                                    class="s-color:accent"
                                    id="setting-spread"
                                    tooltip
                                    min="0"
                                    max="100"
                                    step="10"
                                ></s-range>
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <input type="text" class="s-input" id="setting-spread" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <input type="text" class="s-input s-color:accent" id="setting-spread" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <input type="text" class="s-input" id="setting-spread" />
                            </label>
                        </li>
                        <li class="s-bg:main-surface">
                            <label class="s-label s-p:20" for="setting-accent-color">
                                Spread
                                <input type="text" class="s-input" id="setting-spread" />
                            </label>
                        </li>
                    </ul>
                </div>
            `;
        }
    }
    __decorate([queryAsync('#setting-main-color')], CkSettings.prototype, '_$mainColorPicker', void 0);
    __decorate([queryAsync('#setting-accent-color')], CkSettings.prototype, '_$accentColorPicker', void 0);
    function webcomponent(tagName = 'ck-settings') {
        customElements.define(tagName, CkSettings);
    }
    var requiresPort = function required(port, protocol) {
        protocol = protocol.split(':')[0];
        port = +port;
        if (!port) return false;
        switch (protocol) {
            case 'http':
            case 'ws':
                return port !== 80;
            case 'https':
            case 'wss':
                return port !== 443;
            case 'ftp':
                return port !== 21;
            case 'gopher':
                return port !== 70;
            case 'file':
                return false;
        }
        return port !== 0;
    };
    var querystringify$1 = {};
    var has = Object.prototype.hasOwnProperty,
        undef;
    function decode(input) {
        try {
            return decodeURIComponent(input.replace(/\+/g, ' '));
        } catch (e) {
            return null;
        }
    }
    function encode(input) {
        try {
            return encodeURIComponent(input);
        } catch (e) {
            return null;
        }
    }
    function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g,
            result = {},
            part;
        while ((part = parser.exec(query))) {
            var key = decode(part[1]),
                value = decode(part[2]);
            if (key === null || value === null || key in result) continue;
            result[key] = value;
        }
        return result;
    }
    function querystringify(obj, prefix) {
        prefix = prefix || '';
        var pairs = [],
            value,
            key;
        if (typeof prefix !== 'string') prefix = '?';
        for (key in obj) {
            if (has.call(obj, key)) {
                value = obj[key];
                if (!value && (value === null || value === undef || isNaN(value))) {
                    value = '';
                }
                key = encode(key);
                value = encode(value);
                if (key === null || value === null) continue;
                pairs.push(key + '=' + value);
            }
        }
        return pairs.length ? prefix + pairs.join('&') : '';
    }
    querystringify$1.stringify = querystringify;
    querystringify$1.parse = querystring;
    var required = requiresPort,
        qs = querystringify$1,
        slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/,
        protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i,
        whitespace =
            '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]',
        left = new RegExp('^' + whitespace + '+');
    function trimLeft(str) {
        return (str ? str : '').toString().replace(left, '');
    }
    var rules = [
        ['#', 'hash'],
        ['?', 'query'],
        function sanitize(address) {
            return address.replace('\\', '/');
        },
        ['/', 'pathname'],
        ['@', 'auth', 1],
        [NaN, 'host', void 0, 1, 1],
        [/:(\d+)$/, 'port', void 0, 1],
        [NaN, 'hostname', void 0, 1, 1],
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
        var globalVar;
        if (typeof window !== 'undefined') globalVar = window;
        else if (typeof commonjsGlobal$1 !== 'undefined') globalVar = commonjsGlobal$1;
        else if (typeof self !== 'undefined') globalVar = self;
        else globalVar = {};
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {},
            type = typeof loc,
            key;
        if (loc.protocol === 'blob:') {
            finaldestination = new Url(unescape(loc.pathname), {});
        } else if (type === 'string') {
            finaldestination = new Url(loc, {});
            for (key in ignore) delete finaldestination[key];
        } else if (type === 'object') {
            for (key in loc) {
                if (key in ignore) continue;
                finaldestination[key] = loc[key];
            }
            if (finaldestination.slashes === void 0) {
                finaldestination.slashes = slashes.test(loc.href);
            }
        }
        return finaldestination;
    }
    function extractProtocol(address) {
        address = trimLeft(address);
        var match = protocolre.exec(address),
            protocol = match[1] ? match[1].toLowerCase() : '',
            slashes = !!(match[2] && match[2].length >= 2),
            rest = match[2] && match[2].length === 1 ? '/' + match[3] : match[3];
        return {
            protocol,
            slashes,
            rest,
        };
    }
    function resolve(relative, base) {
        if (relative === '') return base;
        var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
            i = path.length,
            last = path[i - 1],
            unshift = false,
            up = 0;
        while (i--) {
            if (path[i] === '.') {
                path.splice(i, 1);
            } else if (path[i] === '..') {
                path.splice(i, 1);
                up++;
            } else if (up) {
                if (i === 0) unshift = true;
                path.splice(i, 1);
                up--;
            }
        }
        if (unshift) path.unshift('');
        if (last === '.' || last === '..') path.push('');
        return path.join('/');
    }
    function Url(address, location, parser) {
        address = trimLeft(address);
        if (!(this instanceof Url)) {
            return new Url(address, location, parser);
        }
        var relative,
            extracted,
            parse,
            instruction,
            index,
            key,
            instructions = rules.slice(),
            type = typeof location,
            url = this,
            i = 0;
        if (type !== 'object' && type !== 'string') {
            parser = location;
            location = null;
        }
        if (parser && typeof parser !== 'function') parser = qs.parse;
        location = lolcation(location);
        extracted = extractProtocol(address || '');
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || (relative && location.slashes);
        url.protocol = extracted.protocol || location.protocol || '';
        address = extracted.rest;
        if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];
        for (; i < instructions.length; i++) {
            instruction = instructions[i];
            if (typeof instruction === 'function') {
                address = instruction(address);
                continue;
            }
            parse = instruction[0];
            key = instruction[1];
            if (parse !== parse) {
                url[key] = address;
            } else if (typeof parse === 'string') {
                if (~(index = address.indexOf(parse))) {
                    if (typeof instruction[2] === 'number') {
                        url[key] = address.slice(0, index);
                        address = address.slice(index + instruction[2]);
                    } else {
                        url[key] = address.slice(index);
                        address = address.slice(0, index);
                    }
                }
            } else if ((index = parse.exec(address))) {
                url[key] = index[1];
                address = address.slice(0, index.index);
            }
            url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');
            if (instruction[4]) url[key] = url[key].toLowerCase();
        }
        if (parser) url.query = parser(url.query);
        if (
            relative &&
            location.slashes &&
            url.pathname.charAt(0) !== '/' &&
            (url.pathname !== '' || location.pathname !== '')
        ) {
            url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== '/' && url.hostname) {
            url.pathname = '/' + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
            url.host = url.hostname;
            url.port = '';
        }
        url.username = url.password = '';
        if (url.auth) {
            instruction = url.auth.split(':');
            url.username = instruction[0] || '';
            url.password = instruction[1] || '';
        }
        url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';
        url.href = url.toString();
    }
    function set(part, value, fn) {
        var url = this;
        switch (part) {
            case 'query':
                if (typeof value === 'string' && value.length) {
                    value = (fn || qs.parse)(value);
                }
                url[part] = value;
                break;
            case 'port':
                url[part] = value;
                if (!required(value, url.protocol)) {
                    url.host = url.hostname;
                    url[part] = '';
                } else if (value) {
                    url.host = url.hostname + ':' + value;
                }
                break;
            case 'hostname':
                url[part] = value;
                if (url.port) value += ':' + url.port;
                url.host = value;
                break;
            case 'host':
                url[part] = value;
                if (/:\d+$/.test(value)) {
                    value = value.split(':');
                    url.port = value.pop();
                    url.hostname = value.join(':');
                } else {
                    url.hostname = value;
                    url.port = '';
                }
                break;
            case 'protocol':
                url.protocol = value.toLowerCase();
                url.slashes = !fn;
                break;
            case 'pathname':
            case 'hash':
                if (value) {
                    var char = part === 'pathname' ? '/' : '#';
                    url[part] = value.charAt(0) !== char ? char + value : value;
                } else {
                    url[part] = value;
                }
                break;
            default:
                url[part] = value;
        }
        for (var i = 0; i < rules.length; i++) {
            var ins = rules[i];
            if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';
        url.href = url.toString();
        return url;
    }
    function toString(stringify) {
        if (!stringify || typeof stringify !== 'function') stringify = qs.stringify;
        var query,
            url = this,
            protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
        var result = protocol + (url.slashes ? '//' : '');
        if (url.username) {
            result += url.username;
            if (url.password) result += ':' + url.password;
            result += '@';
        }
        result += url.host + url.pathname;
        query = typeof url.query === 'object' ? stringify(url.query) : url.query;
        if (query) result += query.charAt(0) !== '?' ? '?' + query : query;
        if (url.hash) result += url.hash;
        return result;
    }
    Url.prototype = { set, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    var urlParse = Url;
    function ease(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    var requestAnimationFrame$1 =
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame;
    let isUserScrolling = false;
    let userScrollingTimeout;
    let isScrollingHappening = false;
    document.addEventListener('mousewheel', (e) => {
        if (!isScrollingHappening) return;
        isUserScrolling = true;
        clearTimeout(userScrollingTimeout);
        userScrollingTimeout = setTimeout(() => {
            isUserScrolling = false;
        }, 200);
    });
    function scrollTo(target, settings = {}) {
        return new Promise((resolve, reject) => {
            settings = Object.assign(
                { duration: 500, easing: ease, offset: 0, align: 'top', onFinish: null },
                settings,
            );
            const docElem = document.documentElement;
            const windowHeight = window.innerHeight;
            const maxScroll = docElem.scrollHeight - windowHeight;
            const currentY = window.pageYOffset;
            isScrollingHappening = true;
            let targetY = currentY;
            const elementBounds = isNaN(target) ? target.getBoundingClientRect() : 0;
            if (settings.align === 'center') {
                targetY += elementBounds.top + elementBounds.height / 2;
                targetY -= windowHeight / 2;
                targetY -= settings.offset;
            } else if (settings.align === 'bottom') {
                targetY += elementBounds.bottom;
                targetY -= windowHeight;
                targetY += settings.offset;
            } else {
                targetY += elementBounds.top;
                targetY -= settings.offset;
            }
            targetY = Math.max(Math.min(maxScroll, targetY), 0);
            const deltaY = targetY - currentY;
            const obj = {
                targetY,
                deltaY,
                duration: settings.duration,
                easing: settings.easing,
                onFinish() {
                    settings.onFinish && settings.onFinish();
                    resolve();
                },
                startTime: Date.now(),
                lastY: currentY,
                step: scrollTo.step,
            };
            requestAnimationFrame$1(obj.step.bind(obj));
        });
    }
    scrollTo.step = function () {
        if (this.lastY !== window.pageYOffset && this.onFinish) {
            isScrollingHappening = false;
            this.onFinish();
            return;
        }
        const t = Math.min((Date.now() - this.startTime) / this.duration, 1);
        const y = this.targetY - (1 - this.easing(t)) * this.deltaY;
        window.scrollTo(window.scrollX, y);
        if (t !== 1 && !isUserScrolling) {
            this.lastY = window.pageYOffset;
            requestAnimationFrame$1(this.step.bind(this));
        } else {
            isScrollingHappening = false;
            if (this.onFinish) this.onFinish();
        }
    };
    function smoothScrollOnAnchorLinks(settings = {}) {
        settings = deepMerge(
            {
                scroll: {},
                checkPathNames: true,
            },
            settings,
        );
        querySelectorLive('a:not([is])[href*="#"]', ($link) => {
            $link.addEventListener('click', (e) => {
                const linkUrl = urlParse($link.getAttribute('href'));
                const currentUrl = urlParse();
                if (!linkUrl.hash || linkUrl.hash === '#') return;
                if (settings.checkPathNames && currentUrl.pathname !== linkUrl.pathname) return;
                const $target = document.querySelector(linkUrl.hash);
                if (!$target) return;
                e.preventDefault();
                history.pushState({}, null, linkUrl.hash);
                scrollTo($target, settings.scroll);
            });
        });
    }
    function scrollToLocationHash(settings = {}) {
        settings = deepMerge(
            {
                scroll: {},
            },
            settings,
        );
        const hash = document.location.hash;
        if (!hash) return;
        const targetElm = document.querySelector(hash);
        if (!targetElm) return;
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        return scrollTo(targetElm, settings.scroll);
    }
    function smoothScrollOnPageLoad(settings = {}) {
        settings = deepMerge(
            {
                scroll: {},
            },
            settings,
        );
        scrollToLocationHash(settings);
    }
    function smoothScrollOnHashChange(settings = {}) {
        settings = deepMerge(
            {
                scroll: {},
            },
            settings,
        );
        window.addEventListener('hashchange', (e) => {
            scrollToLocationHash(settings);
        });
    }
    function smoothScroll(settings = {}) {
        settings = deepMerge(
            {
                scroll: {},
            },
            settings,
        );
        smoothScrollOnPageLoad(settings);
        smoothScrollOnAnchorLinks(settings);
        smoothScrollOnHashChange(settings);
    }
    function linksStateAttributes(settings = {}) {
        settings = deepMerge({}, settings);
        function handleLink($linkElm) {
            if ($linkElm.getAttribute('href') === document.location.pathname) {
                $linkElm.setAttribute('actual', true);
            } else if ($linkElm.getAttribute('href').startsWith(document.location.pathname)) {
                $linkElm.removeAttribute('actual');
                $linkElm.setAttribute('actual-child', true);
            } else {
                $linkElm.removeAttribute('actual');
                $linkElm.removeAttribute('actual-child');
            }
        }
        querySelectorLive(`[href]`, ($linkElm) => {
            handleLink($linkElm);
        });
        window.addEventListener('locationchange', () => {
            Array.from(document.querySelectorAll('[href]')).forEach(($linkElm) => {
                handleLink($linkElm);
            });
        });
    }
    if (!window.env) window.env = { SUGAR: {} };
    window.env.SUGAR = JSON.parse(
        `{"platform":"browser","env":"dev","config":{"datetime":{"dateFormat":"D MMM YYYY","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"dev":{"colors":{"yellow":"#ffdc89","cyan":"#65c1cd","green":"#a7cb8b","magenta":"#d190e3","red":"#e78287","blue":"#71bdf2","primary":"#ffdc89","secondary":"#65c1cd","grey":"#e2e5e9","gray":"#e2e5e9","black":"#343a43","white":"#e2e5e9"}},"discord":{"server":{"id":"Coffeekraken","url":"https://discord.gg/ERsX54UE"}},"doc":{"layout":{"headerImageUrl":"/dist/img/doc/docHeader.jpg"}},"license":{"layout":{"headerImageUrl":"/dist/img/doc/licenseHeader.jpg"}},"ratios":{"ratio-21-9":2.3333333333333335,"ratio-9-21":0.42857142857142855,"ratio-16-9":1.7777777777777777,"ratio-9-16":0.5625,"ratio-4-3":1.3333333333333333,"ratio-3-4":0.75,"ratio-1":1},"theme":{"theme":"light","cssVariables":["*"],"themes":{"base":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}}},"light":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeLightBase","colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":0.6},"gradientStart":{},"gradientEnd":{"darken":20}},":active":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":1},"gradientStart":{},"gradientEnd":{"darken":20}}},"color":{"main":{"color":"#787987","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"ui":{"color":"#787987","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"accent":{"color":"#ffbb00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"complementary":{"color":"#5100ff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"success":{"color":"#91ff00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"warning":{"color":"#ffd500","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"error":{"color":"#ff003b","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"info":{"color":"#00ffff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}}},"dark":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeDarkBase","colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":23},"surfaceForeground":{"lighten":50},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":1}}},"color":{"main":{"color":"#776D91","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"ui":{"color":"#7a738c","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}}}}},"themeBase":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}}},"themeDark":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeDarkBase","colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":23},"surfaceForeground":{"lighten":50},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":1}}},"color":{"main":{"color":"#776D91","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"ui":{"color":"#7a738c","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"accent":{"color":"#ffbb00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"complementary":{"color":"#5100ff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"success":{"color":"#91ff00","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"warning":{"color":"#ffd500","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"error":{"color":"#ff003b","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"info":{"color":"#00ffff","default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":55},"5":{"lighten":50},"10":{"lighten":45},"15":{"lighten":40},"20":{"lighten":35},"25":{"lighten":30},"30":{"lighten":25},"35":{"lighten":20},"40":{"lighten":15},"45":{"lighten":10},"50":{"lighten":5},"55":{"darken":0},"60":{"darken":5},"65":{"darken":10},"70":{"darken":15},"75":{"darken":20},"80":{"darken":25},"85":{"darken":30},"90":{"darken":35},"95":{"darken":40},"100":{"darken":45},"background":{"darken":30},"surface":{"darken":23},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":60},"5":{"lighten":55},"10":{"lighten":50},"15":{"lighten":45},"20":{"lighten":40},"25":{"lighten":35},"30":{"lighten":30},"35":{"lighten":25},"40":{"lighten":20},"45":{"lighten":15},"50":{"lighten":10},"55":{"darken":5},"60":{},"65":{"darken":5},"70":{"darken":10},"75":{"darken":15},"80":{"darken":20},"85":{"darken":25},"90":{"darken":30},"95":{"darken":35},"100":{"darken":40},"text":{},"background":{"darken":30},"surface":{"darken":21},"ui":{"darken":13},"border":{"alpha":1}}},"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}}},"themeDarkBase":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeBase","colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":15},"border":{"alpha":0.2}},":hover":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":23},"surfaceForeground":{"lighten":50},"ui":{"darken":14},"border":{"alpha":0.3}},":focus":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":0.6}},":active":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":21},"surfaceForeground":{"lighten":50},"ui":{"darken":13},"border":{"alpha":1}}}},"themeLight":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeLightBase","colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":0.6},"gradientStart":{},"gradientEnd":{"darken":20}},":active":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":1},"gradientStart":{},"gradientEnd":{"darken":20}}},"color":{"main":{"color":"#787987","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"ui":{"color":"#787987","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"accent":{"color":"#ffbb00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"complementary":{"color":"#5100ff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"success":{"color":"#91ff00","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"warning":{"color":"#ffd500","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"error":{"color":"#ff003b","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"info":{"color":"#00ffff","default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":0.6}},":active":{"0":{"darken":60},"5":{"darken":55},"10":{"darken":50},"15":{"darken":45},"20":{"darken":40},"25":{"darken":35},"30":{"darken":30},"35":{"darken":25},"40":{"darken":20},"45":{"darken":15},"50":{"darken":10},"55":{"lighten":5},"60":{},"65":{"lighten":5},"70":{"lighten":10},"75":{"lighten":15},"80":{"lighten":20},"85":{"lighten":25},"90":{"lighten":30},"95":{"lighten":35},"100":{"lighten":40},"text":{},"surface":{"lighten":47},"ui":{"lighten":47},"border":{"alpha":1}}},"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}}},"themeLightBase":{"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"1-1":1,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0 0px 2px rgba(0, 0, 0, 0.2)","20":"0 1px 4px rgba(0, 0, 0, 0.16)","30":"0 2px 6px rgba(0, 0, 0, 0.14)","40":"0 4px 12px rgba(0, 0, 0, 0.1)","50":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","60":"0 0.8px 2px rgba(0, 0, 0, 0.05),\\n            0 6px 16px rgba(0, 0, 0, 0.1)","70":"0 0.6px 1.1px rgba(0, 0, 0, 0.024),\\n            0 2px 3.6px rgba(0, 0, 0, 0.036),\\n            0 9px 16px rgba(0, 0, 0, 0.06)","80":"0 0.5px 0.9px rgba(0, 0, 0, 0.021),\\n            0 1.5px 2.5px rgba(0, 0, 0, 0.03),\\n            0 3.6px 6px rgba(0, 0, 0, 0.039),\\n            0 12px 20px rgba(0, 0, 0, 0.06)","90":"0 0.5px 0.7px rgba(0, 0, 0, 0.019),\\n            0 1.4px 1.7px rgba(0, 0, 0, 0.027),\\n            0 2.8px 3.5px rgba(0, 0, 0, 0.033),\\n            0 5.8px 7.3px rgba(0, 0, 0, 0.041),\\n            0 16px 20px rgba(0, 0, 0, 0.06)","100":"0 0.6px 0.7px rgba(0, 0, 0, 0.017),\\n            0 1.3px 1.7px rgba(0, 0, 0, 0.024),\\n            0 2.5px 3.3px rgba(0, 0, 0, 0.03),\\n            0 4.5px 5.8px rgba(0, 0, 0, 0.036),\\n            0 8.4px 10.9px rgba(0, 0, 0, 0.043),\\n            0 20px 26px rgba(0, 0, 0, 0.06)","default":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"size":{"0":0,"5":"4px","10":"4px","20":"8px","30":"12px","40":"16px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":0,"10":"8px","20":"12px","30":"16px","40":"20px","50":"24px","60":"32px","70":"40px","80":"48px","90":"56px","100":"64px","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","default":"1px"},"radius":{"0":"0px","10":"2px","20":"4px","30":"6px","40":"8px","50":"10px","60":"12px","70":"14px","80":"16px","90":"18px","default":"6px"}},"space":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"margin":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"padding":{"0":"0","10":"6px","20":"12px","30":"24px","40":"36px","50":"48px","60":"60px","70":"72px","80":"84px","90":"96px","100":"108px","default":"48px"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{":rhythmVertical":{"margin-bottom":40}}},"ui":{"default":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"form":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","defaultColor":"accent","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)",":rhythmVertical":{"margin-bottom":40}},"button":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"colorPicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"datePicker":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)"},"input":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"range":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"label":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"select":{"padding":"6px 12px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"switch":{"borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","focusSpread":"5px","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultStyle":"default"},"list":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default"],"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tabs":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultStyle":"default"},"terminal":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"tooltip":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","maxWidth":"30ch","arrowSize":"20px"},"code":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","styles":["default:default"],":rhythmVertical":{"margin-bottom":40}},"blockquote":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0 0.5px 1.5px rgba(0, 0, 0, 0.05),\\n            0 4px 12px rgba(0, 0, 0, 0.1)","defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"table":{"padding":"12px 24px","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0,"defaultColor":"accent",":rhythmVertical":{"margin-bottom":40}},"badge":{"padding":".35em .65em","borderRadius":"6px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":0},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":100,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":40}},"h2":{"font-family":"title","font-size":90,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h3":{"font-family":"title","font-size":80,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h4":{"font-family":"title","font-size":70,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"h5":{"font-family":"title","font-size":60,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"h6":{"font-family":"title","font-size":50,"line-height":1,"max-width":"55ch",":rhythmVertical":{"margin-bottom":20}},"p":{"font-family":"default","font-size":40,"line-height":1.5,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"p-lead":{"font-family":"default","font-size":50,"line-height":1.2,"max-width":"55ch",":rhythmVertical":{"margin-bottom":30}},"hr":{"color":"#787987","opacity":0.2,":rhythmVertical":{"margin-bottom":30}},"pre":{"font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"line-height":1.5,"padding":20,":rhythmVertical":{"margin-bottom":30}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["ui","text"],"background-color":["ui","surface"],"padding":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"extends":"themeBase","colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":49},"surfaceForeground":{},"ui":{"lighten":49},"border":{"alpha":0.2},"gradientStart":{},"gradientEnd":{"darken":20}},":hover":{"0":{"darken":55},"5":{"darken":50},"10":{"darken":45},"15":{"darken":40},"20":{"darken":35},"25":{"darken":30},"30":{"darken":25},"35":{"darken":20},"40":{"darken":15},"45":{"darken":10},"50":{"darken":5},"55":{"lighten":0},"60":{"lighten":5},"65":{"lighten":10},"70":{"lighten":15},"75":{"lighten":20},"80":{"lighten":25},"85":{"lighten":30},"90":{"lighten":35},"95":{"lighten":40},"100":{"lighten":45},"text":{"darken":20},"placeholder":{"lighten":44},"foreground":{"lighten":60},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":48},"ui":{"lighten":48},"surfaceForeground":{},"border":{"alpha":0.3}},":focus":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":0.6},"gradientStart":{},"gradientEnd":{"darken":20}},":active":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{},"surface":{"lighten":47},"surfaceForeground":{},"ui":{"lighten":47},"border":{"alpha":1},"gradientStart":{},"gradientEnd":{"darken":20}}}},"transitions":{"fast":"all 0.1s ease-in-out 0s","default":"all 0.2s ease-in-out 0s","slow":"all 0.5s ease-in-out 0s"},"env":{"env":"development"},"frontendServer":{"routes":{"/doc/api":{"handler":"view","request":{"params":{"0":"pages/doc/list"}}}}},"imagesBuilder":{"specificParams":{"idflood/**/*":{"width":100,"resolution":[1]}}},"frontspec":{"metas":{"lang":"en","title":"Plop","description":"Hello world","author":{"name":"Olivier Bossel","email":"olivier.bossel@gmail.com","url":"https://olivierbossel.com"},"og":{"title":"plop","description":"wiufhweiufh wiuehfiuwehf","type":"website","url":"https://olivierbossel.com","image":"/cool-image.jpg"}},"assets":{"js":{"dev":{"id":"dev","type":"module","defer":true,"src":"http://localhost:3000/src/js/index.ts","env":"development"},"module":{"id":"module","type":"module","defer":true,"src":"./dist/js/module.es.js","env":"production"},"main":{"id":"main","nomodule":true,"defer":true,"src":"./dist/js/index.iife.js","env":"production"}},"css":{"dev":{"id":"dev","defer":true,"src":"http://localhost:3000/src/css/index.css","env":"development"},"main":{"id":"main","defer":true,"src":"./dist/css/index.css","env":"production"}}},"head":{}},"$":{"hash":"25088b0703aef8dcf4163d2b87d5143e","loadedAt":1630338898578}}}`,
    );
    webcomponent$2();
    webcomponent$1();
    webcomponent();
    SComponentUtils.setDefaultProps('*', {
        mountWhen: 'inViewport',
        defaultStyle: true,
    });
    SComponentUtils.setDefaultProps('s-code-example', {
        toolbarPosition: 'nav',
        defaultStyleClasses: {
            main: 's-tabs',
        },
    });
    webcomponent$9();
    webcomponent$8();
    webcomponent$7();
    webcomponent$6();
    webcomponent$4();
    webcomponent$5();
    webcomponent$3();
    smoothScroll({
        scroll: {
            offset: 188,
        },
    });
    linksStateAttributes();
    expandPleasantCssClassnamesLive();
    var lib = { exports: {} };
    var fs$j = {};
    var universalify$1 = {};
    universalify$1.fromCallback = function (fn) {
        return Object.defineProperty(
            function (...args) {
                if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
                else {
                    return new Promise((resolve, reject) => {
                        fn.call(this, ...args, (err, res) => (err != null ? reject(err) : resolve(res)));
                    });
                }
            },
            'name',
            { value: fn.name },
        );
    };
    universalify$1.fromPromise = function (fn) {
        return Object.defineProperty(
            function (...args) {
                const cb = args[args.length - 1];
                if (typeof cb !== 'function') return fn.apply(this, args);
                else fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
            },
            'name',
            { value: fn.name },
        );
    };
    var __fs$1 = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_fs = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __fs$1,
    });
    var require$$2$2 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_fs);
    var __viteBrowserExternal_constants = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "constants" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_constants$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_constants,
    });
    var require$$0$3 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_constants$1);
    var constants = require$$0$3;
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.platform;
    process.cwd = function () {
        if (!cwd) cwd = origCwd.call(process);
        return cwd;
    };
    try {
        process.cwd();
    } catch (er) {}
    if (typeof process.chdir === 'function') {
        var chdir = process.chdir;
        process.chdir = function (d) {
            cwd = null;
            chdir.call(process, d);
        };
        if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var polyfills$1 = patch$1;
    function patch$1(fs) {
        if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
            patchLchmod(fs);
        }
        if (!fs.lutimes) {
            patchLutimes(fs);
        }
        fs.chown = chownFix(fs.chown);
        fs.fchown = chownFix(fs.fchown);
        fs.lchown = chownFix(fs.lchown);
        fs.chmod = chmodFix(fs.chmod);
        fs.fchmod = chmodFix(fs.fchmod);
        fs.lchmod = chmodFix(fs.lchmod);
        fs.chownSync = chownFixSync(fs.chownSync);
        fs.fchownSync = chownFixSync(fs.fchownSync);
        fs.lchownSync = chownFixSync(fs.lchownSync);
        fs.chmodSync = chmodFixSync(fs.chmodSync);
        fs.fchmodSync = chmodFixSync(fs.fchmodSync);
        fs.lchmodSync = chmodFixSync(fs.lchmodSync);
        fs.stat = statFix(fs.stat);
        fs.fstat = statFix(fs.fstat);
        fs.lstat = statFix(fs.lstat);
        fs.statSync = statFixSync(fs.statSync);
        fs.fstatSync = statFixSync(fs.fstatSync);
        fs.lstatSync = statFixSync(fs.lstatSync);
        if (!fs.lchmod) {
            fs.lchmod = function (path, mode, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchmodSync = function () {};
        }
        if (!fs.lchown) {
            fs.lchown = function (path, uid, gid, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchownSync = function () {};
        }
        if (platform === 'win32') {
            fs.rename = (function (fs$rename) {
                return function (from, to, cb) {
                    var start = Date.now();
                    var backoff = 0;
                    fs$rename(from, to, function CB(er) {
                        if (er && (er.code === 'EACCES' || er.code === 'EPERM') && Date.now() - start < 6e4) {
                            setTimeout(function () {
                                fs.stat(to, function (stater, st) {
                                    if (stater && stater.code === 'ENOENT') fs$rename(from, to, CB);
                                    else cb(er);
                                });
                            }, backoff);
                            if (backoff < 100) backoff += 10;
                            return;
                        }
                        if (cb) cb(er);
                    });
                };
            })(fs.rename);
        }
        fs.read = (function (fs$read) {
            function read(fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0;
                    callback = function (er, _, __) {
                        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                        }
                        callback_.apply(this, arguments);
                    };
                }
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
            return read;
        })(fs.read);
        fs.readSync = (function (fs$readSync) {
            return function (fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while (true) {
                    try {
                        return fs$readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                        if (er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            continue;
                        }
                        throw er;
                    }
                }
            };
        })(fs.readSync);
        function patchLchmod(fs2) {
            fs2.lchmod = function (path, mode, callback) {
                fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
                    if (err) {
                        if (callback) callback(err);
                        return;
                    }
                    fs2.fchmod(fd, mode, function (err2) {
                        fs2.close(fd, function (err22) {
                            if (callback) callback(err2 || err22);
                        });
                    });
                });
            };
            fs2.lchmodSync = function (path, mode) {
                var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
                var threw = true;
                var ret;
                try {
                    ret = fs2.fchmodSync(fd, mode);
                    threw = false;
                } finally {
                    if (threw) {
                        try {
                            fs2.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs2.closeSync(fd);
                    }
                }
                return ret;
            };
        }
        function patchLutimes(fs2) {
            if (constants.hasOwnProperty('O_SYMLINK')) {
                fs2.lutimes = function (path, at, mt, cb) {
                    fs2.open(path, constants.O_SYMLINK, function (er, fd) {
                        if (er) {
                            if (cb) cb(er);
                            return;
                        }
                        fs2.futimes(fd, at, mt, function (er2) {
                            fs2.close(fd, function (er22) {
                                if (cb) cb(er2 || er22);
                            });
                        });
                    });
                };
                fs2.lutimesSync = function (path, at, mt) {
                    var fd = fs2.openSync(path, constants.O_SYMLINK);
                    var ret;
                    var threw = true;
                    try {
                        ret = fs2.futimesSync(fd, at, mt);
                        threw = false;
                    } finally {
                        if (threw) {
                            try {
                                fs2.closeSync(fd);
                            } catch (er) {}
                        } else {
                            fs2.closeSync(fd);
                        }
                    }
                    return ret;
                };
            } else {
                fs2.lutimes = function (_a, _b, _c, cb) {
                    if (cb) process.nextTick(cb);
                };
                fs2.lutimesSync = function () {};
            }
        }
        function chmodFix(orig) {
            if (!orig) return orig;
            return function (target, mode, cb) {
                return orig.call(fs, target, mode, function (er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chmodFixSync(orig) {
            if (!orig) return orig;
            return function (target, mode) {
                try {
                    return orig.call(fs, target, mode);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function chownFix(orig) {
            if (!orig) return orig;
            return function (target, uid, gid, cb) {
                return orig.call(fs, target, uid, gid, function (er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chownFixSync(orig) {
            if (!orig) return orig;
            return function (target, uid, gid) {
                try {
                    return orig.call(fs, target, uid, gid);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function statFix(orig) {
            if (!orig) return orig;
            return function (target, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                function callback(er, stats) {
                    if (stats) {
                        if (stats.uid < 0) stats.uid += 4294967296;
                        if (stats.gid < 0) stats.gid += 4294967296;
                    }
                    if (cb) cb.apply(this, arguments);
                }
                return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
            };
        }
        function statFixSync(orig) {
            if (!orig) return orig;
            return function (target, options) {
                var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
                if (stats.uid < 0) stats.uid += 4294967296;
                if (stats.gid < 0) stats.gid += 4294967296;
                return stats;
            };
        }
        function chownErOk(er) {
            if (!er) return true;
            if (er.code === 'ENOSYS') return true;
            var nonroot = !process.getuid || process.getuid() !== 0;
            if (nonroot) {
                if (er.code === 'EINVAL' || er.code === 'EPERM') return true;
            }
            return false;
        }
    }
    var __viteBrowserExternal_stream = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "stream" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_stream$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_stream,
    });
    var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_stream$1);
    var Stream = require$$0$2.Stream;
    var legacyStreams = legacy$1;
    function legacy$1(fs) {
        return {
            ReadStream,
            WriteStream,
        };
        function ReadStream(path, options) {
            if (!(this instanceof ReadStream)) return new ReadStream(path, options);
            Stream.call(this);
            var self2 = this;
            this.path = path;
            this.fd = null;
            this.readable = true;
            this.paused = false;
            this.flags = 'r';
            this.mode = 438;
            this.bufferSize = 64 * 1024;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.encoding) this.setEncoding(this.encoding);
            if (this.start !== void 0) {
                if (typeof this.start !== 'number') {
                    throw TypeError('start must be a Number');
                }
                if (this.end === void 0) {
                    this.end = Infinity;
                } else if (typeof this.end !== 'number') {
                    throw TypeError('end must be a Number');
                }
                if (this.start > this.end) {
                    throw new Error('start must be <= end');
                }
                this.pos = this.start;
            }
            if (this.fd !== null) {
                process.nextTick(function () {
                    self2._read();
                });
                return;
            }
            fs.open(this.path, this.flags, this.mode, function (err, fd) {
                if (err) {
                    self2.emit('error', err);
                    self2.readable = false;
                    return;
                }
                self2.fd = fd;
                self2.emit('open', fd);
                self2._read();
            });
        }
        function WriteStream(path, options) {
            if (!(this instanceof WriteStream)) return new WriteStream(path, options);
            Stream.call(this);
            this.path = path;
            this.fd = null;
            this.writable = true;
            this.flags = 'w';
            this.encoding = 'binary';
            this.mode = 438;
            this.bytesWritten = 0;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.start !== void 0) {
                if (typeof this.start !== 'number') {
                    throw TypeError('start must be a Number');
                }
                if (this.start < 0) {
                    throw new Error('start must be >= zero');
                }
                this.pos = this.start;
            }
            this.busy = false;
            this._queue = [];
            if (this.fd === null) {
                this._open = fs.open;
                this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
                this.flush();
            }
        }
    }
    var clone_1$1 = clone$2;
    var getPrototypeOf =
        Object.getPrototypeOf ||
        function (obj) {
            return obj.__proto__;
        };
    function clone$2(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) };
        else var copy = Object.create(null);
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        });
        return copy;
    }
    var __viteBrowserExternal_util = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "util" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_util$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_util,
    });
    var require$$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_util$1);
    var __viteBrowserExternal_assert = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_assert$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_assert,
    });
    var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_assert$1);
    var fs$i = require$$2$2;
    var polyfills = polyfills$1;
    var legacy = legacyStreams;
    var clone$1 = clone_1$1;
    var util$2 = require$$1;
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
        gracefulQueue = Symbol.for('graceful-fs.queue');
        previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
        gracefulQueue = '___graceful-fs.queue';
        previousSymbol = '___graceful-fs.previous';
    }
    function noop$2() {}
    function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
            get: function () {
                return queue;
            },
        });
    }
    var debug = noop$2;
    if (util$2.debuglog) debug = util$2.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(''))
        debug = function () {
            var m = util$2.format.apply(util$2, arguments);
            m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
            console.error(m);
        };
    if (!fs$i[gracefulQueue]) {
        var queue = commonjsGlobal$1[gracefulQueue] || [];
        publishQueue(fs$i, queue);
        fs$i.close = (function (fs$close) {
            function close(fd, cb) {
                return fs$close.call(fs$i, fd, function (err) {
                    if (!err) {
                        retry();
                    }
                    if (typeof cb === 'function') cb.apply(this, arguments);
                });
            }
            Object.defineProperty(close, previousSymbol, {
                value: fs$close,
            });
            return close;
        })(fs$i.close);
        fs$i.closeSync = (function (fs$closeSync) {
            function closeSync(fd) {
                fs$closeSync.apply(fs$i, arguments);
                retry();
            }
            Object.defineProperty(closeSync, previousSymbol, {
                value: fs$closeSync,
            });
            return closeSync;
        })(fs$i.closeSync);
        if (/\bgfs4\b/i.test('')) {
            process.on('exit', function () {
                debug(fs$i[gracefulQueue]);
                require$$2$1.equal(fs$i[gracefulQueue].length, 0);
            });
        }
    }
    if (!commonjsGlobal$1[gracefulQueue]) {
        publishQueue(commonjsGlobal$1, fs$i[gracefulQueue]);
    }
    var gracefulFs = patch(clone$1(fs$i));
    function patch(fs) {
        polyfills(fs);
        fs.gracefulify = patch;
        fs.createReadStream = createReadStream;
        fs.createWriteStream = createWriteStream;
        var fs$readFile = fs.readFile;
        fs.readFile = readFile;
        function readFile(path, options, cb) {
            if (typeof options === 'function') (cb = options), (options = null);
            return go$readFile(path, options, cb);
            function go$readFile(path2, options2, cb2) {
                return fs$readFile(path2, options2, function (err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                        enqueue([go$readFile, [path2, options2, cb2]]);
                    else {
                        if (typeof cb2 === 'function') cb2.apply(this, arguments);
                        retry();
                    }
                });
            }
        }
        var fs$writeFile = fs.writeFile;
        fs.writeFile = writeFile;
        function writeFile(path, data, options, cb) {
            if (typeof options === 'function') (cb = options), (options = null);
            return go$writeFile(path, data, options, cb);
            function go$writeFile(path2, data2, options2, cb2) {
                return fs$writeFile(path2, data2, options2, function (err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                        enqueue([go$writeFile, [path2, data2, options2, cb2]]);
                    else {
                        if (typeof cb2 === 'function') cb2.apply(this, arguments);
                        retry();
                    }
                });
            }
        }
        var fs$appendFile = fs.appendFile;
        if (fs$appendFile) fs.appendFile = appendFile;
        function appendFile(path, data, options, cb) {
            if (typeof options === 'function') (cb = options), (options = null);
            return go$appendFile(path, data, options, cb);
            function go$appendFile(path2, data2, options2, cb2) {
                return fs$appendFile(path2, data2, options2, function (err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                        enqueue([go$appendFile, [path2, data2, options2, cb2]]);
                    else {
                        if (typeof cb2 === 'function') cb2.apply(this, arguments);
                        retry();
                    }
                });
            }
        }
        var fs$copyFile = fs.copyFile;
        if (fs$copyFile) fs.copyFile = copyFile;
        function copyFile(src, dest, flags, cb) {
            if (typeof flags === 'function') {
                cb = flags;
                flags = 0;
            }
            return fs$copyFile(src, dest, flags, function (err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                    enqueue([fs$copyFile, [src, dest, flags, cb]]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                    retry();
                }
            });
        }
        var fs$readdir = fs.readdir;
        fs.readdir = readdir;
        function readdir(path, options, cb) {
            var args = [path];
            if (typeof options !== 'function') {
                args.push(options);
            } else {
                cb = options;
            }
            args.push(go$readdir$cb);
            return go$readdir(args);
            function go$readdir$cb(err, files) {
                if (files && files.sort) files.sort();
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [args]]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                    retry();
                }
            }
        }
        function go$readdir(args) {
            return fs$readdir.apply(fs, args);
        }
        if (process.version.substr(0, 4) === 'v0.8') {
            var legStreams = legacy(fs);
            ReadStream = legStreams.ReadStream;
            WriteStream = legStreams.WriteStream;
        }
        var fs$ReadStream = fs.ReadStream;
        if (fs$ReadStream) {
            ReadStream.prototype = Object.create(fs$ReadStream.prototype);
            ReadStream.prototype.open = ReadStream$open;
        }
        var fs$WriteStream = fs.WriteStream;
        if (fs$WriteStream) {
            WriteStream.prototype = Object.create(fs$WriteStream.prototype);
            WriteStream.prototype.open = WriteStream$open;
        }
        Object.defineProperty(fs, 'ReadStream', {
            get: function () {
                return ReadStream;
            },
            set: function (val) {
                ReadStream = val;
            },
            enumerable: true,
            configurable: true,
        });
        Object.defineProperty(fs, 'WriteStream', {
            get: function () {
                return WriteStream;
            },
            set: function (val) {
                WriteStream = val;
            },
            enumerable: true,
            configurable: true,
        });
        var FileReadStream = ReadStream;
        Object.defineProperty(fs, 'FileReadStream', {
            get: function () {
                return FileReadStream;
            },
            set: function (val) {
                FileReadStream = val;
            },
            enumerable: true,
            configurable: true,
        });
        var FileWriteStream = WriteStream;
        Object.defineProperty(fs, 'FileWriteStream', {
            get: function () {
                return FileWriteStream;
            },
            set: function (val) {
                FileWriteStream = val;
            },
            enumerable: true,
            configurable: true,
        });
        function ReadStream(path, options) {
            if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
            else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }
        function ReadStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function (err, fd) {
                if (err) {
                    if (that.autoClose) that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                    that.read();
                }
            });
        }
        function WriteStream(path, options) {
            if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
            else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }
        function WriteStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function (err, fd) {
                if (err) {
                    that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                }
            });
        }
        function createReadStream(path, options) {
            return new fs.ReadStream(path, options);
        }
        function createWriteStream(path, options) {
            return new fs.WriteStream(path, options);
        }
        var fs$open = fs.open;
        fs.open = open;
        function open(path, flags, mode, cb) {
            if (typeof mode === 'function') (cb = mode), (mode = null);
            return go$open(path, flags, mode, cb);
            function go$open(path2, flags2, mode2, cb2) {
                return fs$open(path2, flags2, mode2, function (err, fd) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                        enqueue([go$open, [path2, flags2, mode2, cb2]]);
                    else {
                        if (typeof cb2 === 'function') cb2.apply(this, arguments);
                        retry();
                    }
                });
            }
        }
        return fs;
    }
    function enqueue(elem) {
        debug('ENQUEUE', elem[0].name, elem[1]);
        fs$i[gracefulQueue].push(elem);
    }
    function retry() {
        var elem = fs$i[gracefulQueue].shift();
        if (elem) {
            debug('RETRY', elem[0].name, elem[1]);
            elem[0].apply(null, elem[1]);
        }
    }
    (function (exports) {
        const u = universalify$1.fromCallback;
        const fs = gracefulFs;
        const api = [
            'access',
            'appendFile',
            'chmod',
            'chown',
            'close',
            'copyFile',
            'fchmod',
            'fchown',
            'fdatasync',
            'fstat',
            'fsync',
            'ftruncate',
            'futimes',
            'lchmod',
            'lchown',
            'link',
            'lstat',
            'mkdir',
            'mkdtemp',
            'open',
            'opendir',
            'readdir',
            'readFile',
            'readlink',
            'realpath',
            'rename',
            'rm',
            'rmdir',
            'stat',
            'symlink',
            'truncate',
            'unlink',
            'utimes',
            'writeFile',
        ].filter((key) => {
            return typeof fs[key] === 'function';
        });
        Object.keys(fs).forEach((key) => {
            if (key === 'promises') {
                return;
            }
            exports[key] = fs[key];
        });
        api.forEach((method) => {
            exports[method] = u(fs[method]);
        });
        exports.exists = function (filename, callback) {
            if (typeof callback === 'function') {
                return fs.exists(filename, callback);
            }
            return new Promise((resolve) => {
                return fs.exists(filename, resolve);
            });
        };
        exports.read = function (fd, buffer, offset, length, position, callback) {
            if (typeof callback === 'function') {
                return fs.read(fd, buffer, offset, length, position, callback);
            }
            return new Promise((resolve, reject) => {
                fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
                    if (err) return reject(err);
                    resolve({ bytesRead, buffer: buffer2 });
                });
            });
        };
        exports.write = function (fd, buffer, ...args) {
            if (typeof args[args.length - 1] === 'function') {
                return fs.write(fd, buffer, ...args);
            }
            return new Promise((resolve, reject) => {
                fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
                    if (err) return reject(err);
                    resolve({ bytesWritten, buffer: buffer2 });
                });
            });
        };
        if (typeof fs.writev === 'function') {
            exports.writev = function (fd, buffers, ...args) {
                if (typeof args[args.length - 1] === 'function') {
                    return fs.writev(fd, buffers, ...args);
                }
                return new Promise((resolve, reject) => {
                    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
                        if (err) return reject(err);
                        resolve({ bytesWritten, buffers: buffers2 });
                    });
                });
            };
        }
        if (typeof fs.realpath.native === 'function') {
            exports.realpath.native = u(fs.realpath.native);
        }
    })(fs$j);
    var makeDir$1 = {};
    var atLeastNode$2 = (r) => {
        const n = process.versions.node.split('.').map((x) => parseInt(x, 10));
        r = r.split('.').map((x) => parseInt(x, 10));
        return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])));
    };
    const fs$h = fs$j;
    const path$g = require$$3$1;
    const atLeastNode$1 = atLeastNode$2;
    const useNativeRecursiveOption = atLeastNode$1('10.12.0');
    const checkPath = (pth) => {
        if (process.platform === 'win32') {
            const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$g.parse(pth).root, ''));
            if (pathHasInvalidWinCharacters) {
                const error = new Error(`Path contains invalid characters: ${pth}`);
                error.code = 'EINVAL';
                throw error;
            }
        }
    };
    const processOptions = (options) => {
        const defaults = { mode: 511 };
        if (typeof options === 'number') options = { mode: options };
        return __spreadValues(__spreadValues({}, defaults), options);
    };
    const permissionError = (pth) => {
        const error = new Error(`operation not permitted, mkdir '${pth}'`);
        error.code = 'EPERM';
        error.errno = -4048;
        error.path = pth;
        error.syscall = 'mkdir';
        return error;
    };
    makeDir$1.makeDir = (input, options) =>
        __async(this, null, function* () {
            checkPath(input);
            options = processOptions(options);
            if (useNativeRecursiveOption) {
                const pth = path$g.resolve(input);
                return fs$h.mkdir(pth, {
                    mode: options.mode,
                    recursive: true,
                });
            }
            const make = (pth) =>
                __async(this, null, function* () {
                    try {
                        yield fs$h.mkdir(pth, options.mode);
                    } catch (error) {
                        if (error.code === 'EPERM') {
                            throw error;
                        }
                        if (error.code === 'ENOENT') {
                            if (path$g.dirname(pth) === pth) {
                                throw permissionError(pth);
                            }
                            if (error.message.includes('null bytes')) {
                                throw error;
                            }
                            yield make(path$g.dirname(pth));
                            return make(pth);
                        }
                        try {
                            const stats = yield fs$h.stat(pth);
                            if (!stats.isDirectory()) {
                                throw new Error('The path is not a directory');
                            }
                        } catch (e) {
                            throw error;
                        }
                    }
                });
            return make(path$g.resolve(input));
        });
    makeDir$1.makeDirSync = (input, options) => {
        checkPath(input);
        options = processOptions(options);
        if (useNativeRecursiveOption) {
            const pth = path$g.resolve(input);
            return fs$h.mkdirSync(pth, {
                mode: options.mode,
                recursive: true,
            });
        }
        const make = (pth) => {
            try {
                fs$h.mkdirSync(pth, options.mode);
            } catch (error) {
                if (error.code === 'EPERM') {
                    throw error;
                }
                if (error.code === 'ENOENT') {
                    if (path$g.dirname(pth) === pth) {
                        throw permissionError(pth);
                    }
                    if (error.message.includes('null bytes')) {
                        throw error;
                    }
                    make(path$g.dirname(pth));
                    return make(pth);
                }
                try {
                    if (!fs$h.statSync(pth).isDirectory()) {
                        throw new Error('The path is not a directory');
                    }
                } catch (e) {
                    throw error;
                }
            }
        };
        return make(path$g.resolve(input));
    };
    const u$a = universalify$1.fromPromise;
    const { makeDir: _makeDir, makeDirSync } = makeDir$1;
    const makeDir = u$a(_makeDir);
    var mkdirs$2 = {
        mkdirs: makeDir,
        mkdirsSync: makeDirSync,
        mkdirp: makeDir,
        mkdirpSync: makeDirSync,
        ensureDir: makeDir,
        ensureDirSync: makeDirSync,
    };
    const fs$g = gracefulFs;
    function utimesMillis$1(path, atime, mtime, callback) {
        fs$g.open(path, 'r+', (err, fd) => {
            if (err) return callback(err);
            fs$g.futimes(fd, atime, mtime, (futimesErr) => {
                fs$g.close(fd, (closeErr) => {
                    if (callback) callback(futimesErr || closeErr);
                });
            });
        });
    }
    function utimesMillisSync$1(path, atime, mtime) {
        const fd = fs$g.openSync(path, 'r+');
        fs$g.futimesSync(fd, atime, mtime);
        return fs$g.closeSync(fd);
    }
    var utimes = {
        utimesMillis: utimesMillis$1,
        utimesMillisSync: utimesMillisSync$1,
    };
    const fs$f = fs$j;
    const path$f = require$$3$1;
    const util$1 = require$$1;
    const atLeastNode = atLeastNode$2;
    const nodeSupportsBigInt = atLeastNode('10.5.0');
    const stat$4 = (file) => (nodeSupportsBigInt ? fs$f.stat(file, { bigint: true }) : fs$f.stat(file));
    const statSync = (file) => (nodeSupportsBigInt ? fs$f.statSync(file, { bigint: true }) : fs$f.statSync(file));
    function getStats$2(src, dest) {
        return Promise.all([
            stat$4(src),
            stat$4(dest).catch((err) => {
                if (err.code === 'ENOENT') return null;
                throw err;
            }),
        ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
        let destStat;
        const srcStat = statSync(src);
        try {
            destStat = statSync(dest);
        } catch (err) {
            if (err.code === 'ENOENT') return { srcStat, destStat: null };
            throw err;
        }
        return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
        util$1.callbackify(getStats$2)(src, dest, (err, stats) => {
            if (err) return cb(err);
            const { srcStat, destStat } = stats;
            if (destStat && areIdentical(srcStat, destStat)) {
                return cb(new Error('Source and destination must not be the same.'));
            }
            if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return cb(null, { srcStat, destStat });
        });
    }
    function checkPathsSync(src, dest, funcName) {
        const { srcStat, destStat } = getStatsSync(src, dest);
        if (destStat && areIdentical(srcStat, destStat)) {
            throw new Error('Source and destination must not be the same.');
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            throw new Error(errMsg(src, dest, funcName));
        }
        return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
        const srcParent = path$f.resolve(path$f.dirname(src));
        const destParent = path$f.resolve(path$f.dirname(dest));
        if (destParent === srcParent || destParent === path$f.parse(destParent).root) return cb();
        const callback = (err, destStat) => {
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }
            if (areIdentical(srcStat, destStat)) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        };
        if (nodeSupportsBigInt) fs$f.stat(destParent, { bigint: true }, callback);
        else fs$f.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
        const srcParent = path$f.resolve(path$f.dirname(src));
        const destParent = path$f.resolve(path$f.dirname(dest));
        if (destParent === srcParent || destParent === path$f.parse(destParent).root) return;
        let destStat;
        try {
            destStat = statSync(destParent);
        } catch (err) {
            if (err.code === 'ENOENT') return;
            throw err;
        }
        if (areIdentical(srcStat, destStat)) {
            throw new Error(errMsg(src, dest, funcName));
        }
        return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
        if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
                return true;
            }
            if (
                destStat.size === srcStat.size &&
                destStat.mode === srcStat.mode &&
                destStat.nlink === srcStat.nlink &&
                destStat.atimeMs === srcStat.atimeMs &&
                destStat.mtimeMs === srcStat.mtimeMs &&
                destStat.ctimeMs === srcStat.ctimeMs &&
                destStat.birthtimeMs === srcStat.birthtimeMs
            ) {
                return true;
            }
        }
        return false;
    }
    function isSrcSubdir(src, dest) {
        const srcArr = path$f
            .resolve(src)
            .split(path$f.sep)
            .filter((i) => i);
        const destArr = path$f
            .resolve(dest)
            .split(path$f.sep)
            .filter((i) => i);
        return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
        return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    var stat_1 = {
        checkPaths,
        checkPathsSync,
        checkParentPaths,
        checkParentPathsSync,
        isSrcSubdir,
    };
    const fs$e = gracefulFs;
    const path$e = require$$3$1;
    const mkdirsSync$1 = mkdirs$2.mkdirsSync;
    const utimesMillisSync = utimes.utimesMillisSync;
    const stat$3 = stat_1;
    function copySync$2(src, dest, opts) {
        if (typeof opts === 'function') {
            opts = { filter: opts };
        }
        opts = opts || {};
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true;
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber;
        if (opts.preserveTimestamps && process.arch === 'ia32') {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
        }
        const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, 'copy');
        stat$3.checkParentPathsSync(src, srcStat, dest, 'copy');
        return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return;
        const destParent = path$e.dirname(dest);
        if (!fs$e.existsSync(destParent)) mkdirsSync$1(destParent);
        return startCopy$1(destStat, src, dest, opts);
    }
    function startCopy$1(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return;
        return getStats$1(destStat, src, dest, opts);
    }
    function getStats$1(destStat, src, dest, opts) {
        const statSync = opts.dereference ? fs$e.statSync : fs$e.lstatSync;
        const srcStat = statSync(src);
        if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
            return onFile$1(srcStat, destStat, src, dest, opts);
        else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts);
    }
    function onFile$1(srcStat, destStat, src, dest, opts) {
        if (!destStat) return copyFile$1(srcStat, src, dest, opts);
        return mayCopyFile$1(srcStat, src, dest, opts);
    }
    function mayCopyFile$1(srcStat, src, dest, opts) {
        if (opts.overwrite) {
            fs$e.unlinkSync(dest);
            return copyFile$1(srcStat, src, dest, opts);
        } else if (opts.errorOnExist) {
            throw new Error(`'${dest}' already exists`);
        }
    }
    function copyFile$1(srcStat, src, dest, opts) {
        fs$e.copyFileSync(src, dest);
        if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
        return setDestMode$1(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
        if (fileIsNotWritable$1(srcMode)) makeFileWritable$1(dest, srcMode);
        return setDestTimestamps$1(src, dest);
    }
    function fileIsNotWritable$1(srcMode) {
        return (srcMode & 128) === 0;
    }
    function makeFileWritable$1(dest, srcMode) {
        return setDestMode$1(dest, srcMode | 128);
    }
    function setDestMode$1(dest, srcMode) {
        return fs$e.chmodSync(dest, srcMode);
    }
    function setDestTimestamps$1(src, dest) {
        const updatedSrcStat = fs$e.statSync(src);
        return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir$1(srcStat, destStat, src, dest, opts) {
        if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts);
        if (destStat && !destStat.isDirectory()) {
            throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        return copyDir$1(src, dest, opts);
    }
    function mkDirAndCopy$1(srcMode, src, dest, opts) {
        fs$e.mkdirSync(dest);
        copyDir$1(src, dest, opts);
        return setDestMode$1(dest, srcMode);
    }
    function copyDir$1(src, dest, opts) {
        fs$e.readdirSync(src).forEach((item) => copyDirItem$1(item, src, dest, opts));
    }
    function copyDirItem$1(item, src, dest, opts) {
        const srcItem = path$e.join(src, item);
        const destItem = path$e.join(dest, item);
        const { destStat } = stat$3.checkPathsSync(srcItem, destItem, 'copy');
        return startCopy$1(destStat, srcItem, destItem, opts);
    }
    function onLink$1(destStat, src, dest, opts) {
        let resolvedSrc = fs$e.readlinkSync(src);
        if (opts.dereference) {
            resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
            return fs$e.symlinkSync(resolvedSrc, dest);
        } else {
            let resolvedDest;
            try {
                resolvedDest = fs$e.readlinkSync(dest);
            } catch (err) {
                if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$e.symlinkSync(resolvedSrc, dest);
                throw err;
            }
            if (opts.dereference) {
                resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
            }
            if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
                throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
            }
            if (fs$e.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
                throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
            }
            return copyLink$1(resolvedSrc, dest);
        }
    }
    function copyLink$1(resolvedSrc, dest) {
        fs$e.unlinkSync(dest);
        return fs$e.symlinkSync(resolvedSrc, dest);
    }
    var copySync_1 = copySync$2;
    var copySync$1 = {
        copySync: copySync_1,
    };
    const u$9 = universalify$1.fromPromise;
    const fs$d = fs$j;
    function pathExists$6(path) {
        return fs$d
            .access(path)
            .then(() => true)
            .catch(() => false);
    }
    var pathExists_1 = {
        pathExists: u$9(pathExists$6),
        pathExistsSync: fs$d.existsSync,
    };
    const fs$c = gracefulFs;
    const path$d = require$$3$1;
    const mkdirs$1 = mkdirs$2.mkdirs;
    const pathExists$5 = pathExists_1.pathExists;
    const utimesMillis = utimes.utimesMillis;
    const stat$2 = stat_1;
    function copy$2(src, dest, opts, cb) {
        if (typeof opts === 'function' && !cb) {
            cb = opts;
            opts = {};
        } else if (typeof opts === 'function') {
            opts = { filter: opts };
        }
        cb = cb || function () {};
        opts = opts || {};
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true;
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber;
        if (opts.preserveTimestamps && process.arch === 'ia32') {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
        }
        stat$2.checkPaths(src, dest, 'copy', (err, stats) => {
            if (err) return cb(err);
            const { srcStat, destStat } = stats;
            stat$2.checkParentPaths(src, srcStat, dest, 'copy', (err2) => {
                if (err2) return cb(err2);
                if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
                return checkParentDir(destStat, src, dest, opts, cb);
            });
        });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
        const destParent = path$d.dirname(dest);
        pathExists$5(destParent, (err, dirExists) => {
            if (err) return cb(err);
            if (dirExists) return startCopy(destStat, src, dest, opts, cb);
            mkdirs$1(destParent, (err2) => {
                if (err2) return cb(err2);
                return startCopy(destStat, src, dest, opts, cb);
            });
        });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
        Promise.resolve(opts.filter(src, dest)).then(
            (include) => {
                if (include) return onInclude(destStat, src, dest, opts, cb);
                return cb();
            },
            (error) => cb(error),
        );
    }
    function startCopy(destStat, src, dest, opts, cb) {
        if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);
        return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
        const stat = opts.dereference ? fs$c.stat : fs$c.lstat;
        stat(src, (err, srcStat) => {
            if (err) return cb(err);
            if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
                return onFile(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
        });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
        return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
        if (opts.overwrite) {
            fs$c.unlink(dest, (err) => {
                if (err) return cb(err);
                return copyFile(srcStat, src, dest, opts, cb);
            });
        } else if (opts.errorOnExist) {
            return cb(new Error(`'${dest}' already exists`));
        } else return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
        fs$c.copyFile(src, dest, (err) => {
            if (err) return cb(err);
            if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
            return setDestMode(dest, srcStat.mode, cb);
        });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
        if (fileIsNotWritable(srcMode)) {
            return makeFileWritable(dest, srcMode, (err) => {
                if (err) return cb(err);
                return setDestTimestampsAndMode(srcMode, src, dest, cb);
            });
        }
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
        return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
        return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
        setDestTimestamps(src, dest, (err) => {
            if (err) return cb(err);
            return setDestMode(dest, srcMode, cb);
        });
    }
    function setDestMode(dest, srcMode, cb) {
        return fs$c.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
        fs$c.stat(src, (err, updatedSrcStat) => {
            if (err) return cb(err);
            return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
        });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
        if (destStat && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
        }
        return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
        fs$c.mkdir(dest, (err) => {
            if (err) return cb(err);
            copyDir(src, dest, opts, (err2) => {
                if (err2) return cb(err2);
                return setDestMode(dest, srcMode, cb);
            });
        });
    }
    function copyDir(src, dest, opts, cb) {
        fs$c.readdir(src, (err, items) => {
            if (err) return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
        });
    }
    function copyDirItems(items, src, dest, opts, cb) {
        const item = items.pop();
        if (!item) return cb();
        return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
        const srcItem = path$d.join(src, item);
        const destItem = path$d.join(dest, item);
        stat$2.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
            if (err) return cb(err);
            const { destStat } = stats;
            startCopy(destStat, srcItem, destItem, opts, (err2) => {
                if (err2) return cb(err2);
                return copyDirItems(items, src, dest, opts, cb);
            });
        });
    }
    function onLink(destStat, src, dest, opts, cb) {
        fs$c.readlink(src, (err, resolvedSrc) => {
            if (err) return cb(err);
            if (opts.dereference) {
                resolvedSrc = path$d.resolve(process.cwd(), resolvedSrc);
            }
            if (!destStat) {
                return fs$c.symlink(resolvedSrc, dest, cb);
            } else {
                fs$c.readlink(dest, (err2, resolvedDest) => {
                    if (err2) {
                        if (err2.code === 'EINVAL' || err2.code === 'UNKNOWN')
                            return fs$c.symlink(resolvedSrc, dest, cb);
                        return cb(err2);
                    }
                    if (opts.dereference) {
                        resolvedDest = path$d.resolve(process.cwd(), resolvedDest);
                    }
                    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
                        return cb(
                            new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`),
                        );
                    }
                    if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
                        return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                    }
                    return copyLink(resolvedSrc, dest, cb);
                });
            }
        });
    }
    function copyLink(resolvedSrc, dest, cb) {
        fs$c.unlink(dest, (err) => {
            if (err) return cb(err);
            return fs$c.symlink(resolvedSrc, dest, cb);
        });
    }
    var copy_1 = copy$2;
    const u$8 = universalify$1.fromCallback;
    var copy$1 = {
        copy: u$8(copy_1),
    };
    const fs$b = gracefulFs;
    const path$c = require$$3$1;
    const assert = require$$2$1;
    const isWindows = process.platform === 'win32';
    function defaults(options) {
        const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
        methods.forEach((m) => {
            options[m] = options[m] || fs$b[m];
            m = m + 'Sync';
            options[m] = options[m] || fs$b[m];
        });
        options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf$1(p, options, cb) {
        let busyTries = 0;
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        assert(p, 'rimraf: missing path');
        assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
        assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
        assert(options, 'rimraf: invalid options argument provided');
        assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');
        defaults(options);
        rimraf_(p, options, function CB(er) {
            if (er) {
                if (
                    (er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
                    busyTries < options.maxBusyTries
                ) {
                    busyTries++;
                    const time = busyTries * 100;
                    return setTimeout(() => rimraf_(p, options, CB), time);
                }
                if (er.code === 'ENOENT') er = null;
            }
            cb(er);
        });
    }
    function rimraf_(p, options, cb) {
        assert(p);
        assert(options);
        assert(typeof cb === 'function');
        options.lstat(p, (er, st) => {
            if (er && er.code === 'ENOENT') {
                return cb(null);
            }
            if (er && er.code === 'EPERM' && isWindows) {
                return fixWinEPERM(p, options, er, cb);
            }
            if (st && st.isDirectory()) {
                return rmdir(p, options, er, cb);
            }
            options.unlink(p, (er2) => {
                if (er2) {
                    if (er2.code === 'ENOENT') {
                        return cb(null);
                    }
                    if (er2.code === 'EPERM') {
                        return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
                    }
                    if (er2.code === 'EISDIR') {
                        return rmdir(p, options, er2, cb);
                    }
                }
                return cb(er2);
            });
        });
    }
    function fixWinEPERM(p, options, er, cb) {
        assert(p);
        assert(options);
        assert(typeof cb === 'function');
        options.chmod(p, 438, (er2) => {
            if (er2) {
                cb(er2.code === 'ENOENT' ? null : er);
            } else {
                options.stat(p, (er3, stats) => {
                    if (er3) {
                        cb(er3.code === 'ENOENT' ? null : er);
                    } else if (stats.isDirectory()) {
                        rmdir(p, options, er, cb);
                    } else {
                        options.unlink(p, cb);
                    }
                });
            }
        });
    }
    function fixWinEPERMSync(p, options, er) {
        let stats;
        assert(p);
        assert(options);
        try {
            options.chmodSync(p, 438);
        } catch (er2) {
            if (er2.code === 'ENOENT') {
                return;
            } else {
                throw er;
            }
        }
        try {
            stats = options.statSync(p);
        } catch (er3) {
            if (er3.code === 'ENOENT') {
                return;
            } else {
                throw er;
            }
        }
        if (stats.isDirectory()) {
            rmdirSync(p, options, er);
        } else {
            options.unlinkSync(p);
        }
    }
    function rmdir(p, options, originalEr, cb) {
        assert(p);
        assert(options);
        assert(typeof cb === 'function');
        options.rmdir(p, (er) => {
            if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
                rmkids(p, options, cb);
            } else if (er && er.code === 'ENOTDIR') {
                cb(originalEr);
            } else {
                cb(er);
            }
        });
    }
    function rmkids(p, options, cb) {
        assert(p);
        assert(options);
        assert(typeof cb === 'function');
        options.readdir(p, (er, files) => {
            if (er) return cb(er);
            let n = files.length;
            let errState;
            if (n === 0) return options.rmdir(p, cb);
            files.forEach((f) => {
                rimraf$1(path$c.join(p, f), options, (er2) => {
                    if (errState) {
                        return;
                    }
                    if (er2) return cb((errState = er2));
                    if (--n === 0) {
                        options.rmdir(p, cb);
                    }
                });
            });
        });
    }
    function rimrafSync(p, options) {
        let st;
        options = options || {};
        defaults(options);
        assert(p, 'rimraf: missing path');
        assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
        assert(options, 'rimraf: missing options');
        assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');
        try {
            st = options.lstatSync(p);
        } catch (er) {
            if (er.code === 'ENOENT') {
                return;
            }
            if (er.code === 'EPERM' && isWindows) {
                fixWinEPERMSync(p, options, er);
            }
        }
        try {
            if (st && st.isDirectory()) {
                rmdirSync(p, options, null);
            } else {
                options.unlinkSync(p);
            }
        } catch (er) {
            if (er.code === 'ENOENT') {
                return;
            } else if (er.code === 'EPERM') {
                return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
            } else if (er.code !== 'EISDIR') {
                throw er;
            }
            rmdirSync(p, options, er);
        }
    }
    function rmdirSync(p, options, originalEr) {
        assert(p);
        assert(options);
        try {
            options.rmdirSync(p);
        } catch (er) {
            if (er.code === 'ENOTDIR') {
                throw originalEr;
            } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
                rmkidsSync(p, options);
            } else if (er.code !== 'ENOENT') {
                throw er;
            }
        }
    }
    function rmkidsSync(p, options) {
        assert(p);
        assert(options);
        options.readdirSync(p).forEach((f) => rimrafSync(path$c.join(p, f), options));
        if (isWindows) {
            const startTime = Date.now();
            do {
                try {
                    const ret = options.rmdirSync(p, options);
                    return ret;
                } catch (e) {}
            } while (Date.now() - startTime < 500);
        } else {
            const ret = options.rmdirSync(p, options);
            return ret;
        }
    }
    var rimraf_1 = rimraf$1;
    rimraf$1.sync = rimrafSync;
    const u$7 = universalify$1.fromCallback;
    const rimraf = rimraf_1;
    var remove$2 = {
        remove: u$7(rimraf),
        removeSync: rimraf.sync,
    };
    const u$6 = universalify$1.fromCallback;
    const fs$a = gracefulFs;
    const path$b = require$$3$1;
    const mkdir$3 = mkdirs$2;
    const remove$1 = remove$2;
    const emptyDir = u$6(function emptyDir(dir, callback) {
        callback = callback || function () {};
        fs$a.readdir(dir, (err, items) => {
            if (err) return mkdir$3.mkdirs(dir, callback);
            items = items.map((item) => path$b.join(dir, item));
            deleteItem();
            function deleteItem() {
                const item = items.pop();
                if (!item) return callback();
                remove$1.remove(item, (err2) => {
                    if (err2) return callback(err2);
                    deleteItem();
                });
            }
        });
    });
    function emptyDirSync(dir) {
        let items;
        try {
            items = fs$a.readdirSync(dir);
        } catch (e) {
            return mkdir$3.mkdirsSync(dir);
        }
        items.forEach((item) => {
            item = path$b.join(dir, item);
            remove$1.removeSync(item);
        });
    }
    var empty = {
        emptyDirSync,
        emptydirSync: emptyDirSync,
        emptyDir,
        emptydir: emptyDir,
    };
    const u$5 = universalify$1.fromCallback;
    const path$a = require$$3$1;
    const fs$9 = gracefulFs;
    const mkdir$2 = mkdirs$2;
    function createFile(file, callback) {
        function makeFile() {
            fs$9.writeFile(file, '', (err) => {
                if (err) return callback(err);
                callback();
            });
        }
        fs$9.stat(file, (err, stats) => {
            if (!err && stats.isFile()) return callback();
            const dir = path$a.dirname(file);
            fs$9.stat(dir, (err2, stats2) => {
                if (err2) {
                    if (err2.code === 'ENOENT') {
                        return mkdir$2.mkdirs(dir, (err3) => {
                            if (err3) return callback(err3);
                            makeFile();
                        });
                    }
                    return callback(err2);
                }
                if (stats2.isDirectory()) makeFile();
                else {
                    fs$9.readdir(dir, (err3) => {
                        if (err3) return callback(err3);
                    });
                }
            });
        });
    }
    function createFileSync(file) {
        let stats;
        try {
            stats = fs$9.statSync(file);
        } catch (e) {}
        if (stats && stats.isFile()) return;
        const dir = path$a.dirname(file);
        try {
            if (!fs$9.statSync(dir).isDirectory()) {
                fs$9.readdirSync(dir);
            }
        } catch (err) {
            if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);
            else throw err;
        }
        fs$9.writeFileSync(file, '');
    }
    var file$1 = {
        createFile: u$5(createFile),
        createFileSync,
    };
    const u$4 = universalify$1.fromCallback;
    const path$9 = require$$3$1;
    const fs$8 = gracefulFs;
    const mkdir$1 = mkdirs$2;
    const pathExists$4 = pathExists_1.pathExists;
    function createLink(srcpath, dstpath, callback) {
        function makeLink(srcpath2, dstpath2) {
            fs$8.link(srcpath2, dstpath2, (err) => {
                if (err) return callback(err);
                callback(null);
            });
        }
        pathExists$4(dstpath, (err, destinationExists) => {
            if (err) return callback(err);
            if (destinationExists) return callback(null);
            fs$8.lstat(srcpath, (err2) => {
                if (err2) {
                    err2.message = err2.message.replace('lstat', 'ensureLink');
                    return callback(err2);
                }
                const dir = path$9.dirname(dstpath);
                pathExists$4(dir, (err3, dirExists) => {
                    if (err3) return callback(err3);
                    if (dirExists) return makeLink(srcpath, dstpath);
                    mkdir$1.mkdirs(dir, (err4) => {
                        if (err4) return callback(err4);
                        makeLink(srcpath, dstpath);
                    });
                });
            });
        });
    }
    function createLinkSync(srcpath, dstpath) {
        const destinationExists = fs$8.existsSync(dstpath);
        if (destinationExists) return void 0;
        try {
            fs$8.lstatSync(srcpath);
        } catch (err) {
            err.message = err.message.replace('lstat', 'ensureLink');
            throw err;
        }
        const dir = path$9.dirname(dstpath);
        const dirExists = fs$8.existsSync(dir);
        if (dirExists) return fs$8.linkSync(srcpath, dstpath);
        mkdir$1.mkdirsSync(dir);
        return fs$8.linkSync(srcpath, dstpath);
    }
    var link$1 = {
        createLink: u$4(createLink),
        createLinkSync,
    };
    const path$8 = require$$3$1;
    const fs$7 = gracefulFs;
    const pathExists$3 = pathExists_1.pathExists;
    function symlinkPaths$1(srcpath, dstpath, callback) {
        if (path$8.isAbsolute(srcpath)) {
            return fs$7.lstat(srcpath, (err) => {
                if (err) {
                    err.message = err.message.replace('lstat', 'ensureSymlink');
                    return callback(err);
                }
                return callback(null, {
                    toCwd: srcpath,
                    toDst: srcpath,
                });
            });
        } else {
            const dstdir = path$8.dirname(dstpath);
            const relativeToDst = path$8.join(dstdir, srcpath);
            return pathExists$3(relativeToDst, (err, exists) => {
                if (err) return callback(err);
                if (exists) {
                    return callback(null, {
                        toCwd: relativeToDst,
                        toDst: srcpath,
                    });
                } else {
                    return fs$7.lstat(srcpath, (err2) => {
                        if (err2) {
                            err2.message = err2.message.replace('lstat', 'ensureSymlink');
                            return callback(err2);
                        }
                        return callback(null, {
                            toCwd: srcpath,
                            toDst: path$8.relative(dstdir, srcpath),
                        });
                    });
                }
            });
        }
    }
    function symlinkPathsSync$1(srcpath, dstpath) {
        let exists;
        if (path$8.isAbsolute(srcpath)) {
            exists = fs$7.existsSync(srcpath);
            if (!exists) throw new Error('absolute srcpath does not exist');
            return {
                toCwd: srcpath,
                toDst: srcpath,
            };
        } else {
            const dstdir = path$8.dirname(dstpath);
            const relativeToDst = path$8.join(dstdir, srcpath);
            exists = fs$7.existsSync(relativeToDst);
            if (exists) {
                return {
                    toCwd: relativeToDst,
                    toDst: srcpath,
                };
            } else {
                exists = fs$7.existsSync(srcpath);
                if (!exists) throw new Error('relative srcpath does not exist');
                return {
                    toCwd: srcpath,
                    toDst: path$8.relative(dstdir, srcpath),
                };
            }
        }
    }
    var symlinkPaths_1 = {
        symlinkPaths: symlinkPaths$1,
        symlinkPathsSync: symlinkPathsSync$1,
    };
    const fs$6 = gracefulFs;
    function symlinkType$1(srcpath, type, callback) {
        callback = typeof type === 'function' ? type : callback;
        type = typeof type === 'function' ? false : type;
        if (type) return callback(null, type);
        fs$6.lstat(srcpath, (err, stats) => {
            if (err) return callback(null, 'file');
            type = stats && stats.isDirectory() ? 'dir' : 'file';
            callback(null, type);
        });
    }
    function symlinkTypeSync$1(srcpath, type) {
        let stats;
        if (type) return type;
        try {
            stats = fs$6.lstatSync(srcpath);
        } catch (e) {
            return 'file';
        }
        return stats && stats.isDirectory() ? 'dir' : 'file';
    }
    var symlinkType_1 = {
        symlinkType: symlinkType$1,
        symlinkTypeSync: symlinkTypeSync$1,
    };
    const u$3 = universalify$1.fromCallback;
    const path$7 = require$$3$1;
    const fs$5 = gracefulFs;
    const _mkdirs = mkdirs$2;
    const mkdirs = _mkdirs.mkdirs;
    const mkdirsSync = _mkdirs.mkdirsSync;
    const _symlinkPaths = symlinkPaths_1;
    const symlinkPaths = _symlinkPaths.symlinkPaths;
    const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    const _symlinkType = symlinkType_1;
    const symlinkType = _symlinkType.symlinkType;
    const symlinkTypeSync = _symlinkType.symlinkTypeSync;
    const pathExists$2 = pathExists_1.pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
        callback = typeof type === 'function' ? type : callback;
        type = typeof type === 'function' ? false : type;
        pathExists$2(dstpath, (err, destinationExists) => {
            if (err) return callback(err);
            if (destinationExists) return callback(null);
            symlinkPaths(srcpath, dstpath, (err2, relative) => {
                if (err2) return callback(err2);
                srcpath = relative.toDst;
                symlinkType(relative.toCwd, type, (err3, type2) => {
                    if (err3) return callback(err3);
                    const dir = path$7.dirname(dstpath);
                    pathExists$2(dir, (err4, dirExists) => {
                        if (err4) return callback(err4);
                        if (dirExists) return fs$5.symlink(srcpath, dstpath, type2, callback);
                        mkdirs(dir, (err5) => {
                            if (err5) return callback(err5);
                            fs$5.symlink(srcpath, dstpath, type2, callback);
                        });
                    });
                });
            });
        });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
        const destinationExists = fs$5.existsSync(dstpath);
        if (destinationExists) return void 0;
        const relative = symlinkPathsSync(srcpath, dstpath);
        srcpath = relative.toDst;
        type = symlinkTypeSync(relative.toCwd, type);
        const dir = path$7.dirname(dstpath);
        const exists = fs$5.existsSync(dir);
        if (exists) return fs$5.symlinkSync(srcpath, dstpath, type);
        mkdirsSync(dir);
        return fs$5.symlinkSync(srcpath, dstpath, type);
    }
    var symlink$1 = {
        createSymlink: u$3(createSymlink),
        createSymlinkSync,
    };
    const file = file$1;
    const link = link$1;
    const symlink = symlink$1;
    var ensure = {
        createFile: file.createFile,
        createFileSync: file.createFileSync,
        ensureFile: file.createFile,
        ensureFileSync: file.createFileSync,
        createLink: link.createLink,
        createLinkSync: link.createLinkSync,
        ensureLink: link.createLink,
        ensureLinkSync: link.createLinkSync,
        createSymlink: symlink.createSymlink,
        createSymlinkSync: symlink.createSymlinkSync,
        ensureSymlink: symlink.createSymlink,
        ensureSymlinkSync: symlink.createSymlinkSync,
    };
    function stringify$3(obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
        const EOF = finalEOL ? EOL : '';
        const str = JSON.stringify(obj, replacer, spaces);
        return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom$1(content) {
        if (Buffer.isBuffer(content)) content = content.toString('utf8');
        return content.replace(/^\uFEFF/, '');
    }
    var utils = { stringify: stringify$3, stripBom: stripBom$1 };
    let _fs;
    try {
        _fs = gracefulFs;
    } catch (_) {
        _fs = require$$2$2;
    }
    const universalify = universalify$1;
    const { stringify: stringify$2, stripBom } = utils;
    function _readFile(_0) {
        return __async(this, arguments, function* (file, options = {}) {
            if (typeof options === 'string') {
                options = { encoding: options };
            }
            const fs = options.fs || _fs;
            const shouldThrow = 'throws' in options ? options.throws : true;
            let data = yield universalify.fromCallback(fs.readFile)(file, options);
            data = stripBom(data);
            let obj;
            try {
                obj = JSON.parse(data, options ? options.reviver : null);
            } catch (err) {
                if (shouldThrow) {
                    err.message = `${file}: ${err.message}`;
                    throw err;
                } else {
                    return null;
                }
            }
            return obj;
        });
    }
    const readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
        if (typeof options === 'string') {
            options = { encoding: options };
        }
        const fs = options.fs || _fs;
        const shouldThrow = 'throws' in options ? options.throws : true;
        try {
            let content = fs.readFileSync(file, options);
            content = stripBom(content);
            return JSON.parse(content, options.reviver);
        } catch (err) {
            if (shouldThrow) {
                err.message = `${file}: ${err.message}`;
                throw err;
            } else {
                return null;
            }
        }
    }
    function _writeFile(_0, _1) {
        return __async(this, arguments, function* (file, obj, options = {}) {
            const fs = options.fs || _fs;
            const str = stringify$2(obj, options);
            yield universalify.fromCallback(fs.writeFile)(file, str, options);
        });
    }
    const writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
        const fs = options.fs || _fs;
        const str = stringify$2(obj, options);
        return fs.writeFileSync(file, str, options);
    }
    const jsonfile$1 = {
        readFile,
        readFileSync,
        writeFile,
        writeFileSync,
    };
    var jsonfile_1 = jsonfile$1;
    const jsonFile$1 = jsonfile_1;
    var jsonfile = {
        readJson: jsonFile$1.readFile,
        readJsonSync: jsonFile$1.readFileSync,
        writeJson: jsonFile$1.writeFile,
        writeJsonSync: jsonFile$1.writeFileSync,
    };
    const u$2 = universalify$1.fromCallback;
    const fs$4 = gracefulFs;
    const path$6 = require$$3$1;
    const mkdir = mkdirs$2;
    const pathExists$1 = pathExists_1.pathExists;
    function outputFile$1(file, data, encoding, callback) {
        if (typeof encoding === 'function') {
            callback = encoding;
            encoding = 'utf8';
        }
        const dir = path$6.dirname(file);
        pathExists$1(dir, (err, itDoes) => {
            if (err) return callback(err);
            if (itDoes) return fs$4.writeFile(file, data, encoding, callback);
            mkdir.mkdirs(dir, (err2) => {
                if (err2) return callback(err2);
                fs$4.writeFile(file, data, encoding, callback);
            });
        });
    }
    function outputFileSync$1(file, ...args) {
        const dir = path$6.dirname(file);
        if (fs$4.existsSync(dir)) {
            return fs$4.writeFileSync(file, ...args);
        }
        mkdir.mkdirsSync(dir);
        fs$4.writeFileSync(file, ...args);
    }
    var output = {
        outputFile: u$2(outputFile$1),
        outputFileSync: outputFileSync$1,
    };
    const { stringify: stringify$1 } = utils;
    const { outputFile } = output;
    function outputJson(_0, _1) {
        return __async(this, arguments, function* (file, data, options = {}) {
            const str = stringify$1(data, options);
            yield outputFile(file, str, options);
        });
    }
    var outputJson_1 = outputJson;
    const { stringify } = utils;
    const { outputFileSync } = output;
    function outputJsonSync(file, data, options) {
        const str = stringify(data, options);
        outputFileSync(file, str, options);
    }
    var outputJsonSync_1 = outputJsonSync;
    const u$1 = universalify$1.fromPromise;
    const jsonFile = jsonfile;
    jsonFile.outputJson = u$1(outputJson_1);
    jsonFile.outputJsonSync = outputJsonSync_1;
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    var json = jsonFile;
    const fs$3 = gracefulFs;
    const path$5 = require$$3$1;
    const copySync = copySync$1.copySync;
    const removeSync$1 = remove$2.removeSync;
    const mkdirpSync = mkdirs$2.mkdirpSync;
    const stat$1 = stat_1;
    function moveSync$1(src, dest, opts) {
        opts = opts || {};
        const overwrite = opts.overwrite || opts.clobber || false;
        const { srcStat } = stat$1.checkPathsSync(src, dest, 'move');
        stat$1.checkParentPathsSync(src, srcStat, dest, 'move');
        mkdirpSync(path$5.dirname(dest));
        return doRename$1(src, dest, overwrite);
    }
    function doRename$1(src, dest, overwrite) {
        if (overwrite) {
            removeSync$1(dest);
            return rename$1(src, dest, overwrite);
        }
        if (fs$3.existsSync(dest)) throw new Error('dest already exists.');
        return rename$1(src, dest, overwrite);
    }
    function rename$1(src, dest, overwrite) {
        try {
            fs$3.renameSync(src, dest);
        } catch (err) {
            if (err.code !== 'EXDEV') throw err;
            return moveAcrossDevice$1(src, dest, overwrite);
        }
    }
    function moveAcrossDevice$1(src, dest, overwrite) {
        const opts = {
            overwrite,
            errorOnExist: true,
        };
        copySync(src, dest, opts);
        return removeSync$1(src);
    }
    var moveSync_1 = moveSync$1;
    var moveSync = {
        moveSync: moveSync_1,
    };
    const fs$2 = gracefulFs;
    const path$4 = require$$3$1;
    const copy = copy$1.copy;
    const remove = remove$2.remove;
    const mkdirp = mkdirs$2.mkdirp;
    const pathExists = pathExists_1.pathExists;
    const stat = stat_1;
    function move$1(src, dest, opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        const overwrite = opts.overwrite || opts.clobber || false;
        stat.checkPaths(src, dest, 'move', (err, stats) => {
            if (err) return cb(err);
            const { srcStat } = stats;
            stat.checkParentPaths(src, srcStat, dest, 'move', (err2) => {
                if (err2) return cb(err2);
                mkdirp(path$4.dirname(dest), (err3) => {
                    if (err3) return cb(err3);
                    return doRename(src, dest, overwrite, cb);
                });
            });
        });
    }
    function doRename(src, dest, overwrite, cb) {
        if (overwrite) {
            return remove(dest, (err) => {
                if (err) return cb(err);
                return rename(src, dest, overwrite, cb);
            });
        }
        pathExists(dest, (err, destExists) => {
            if (err) return cb(err);
            if (destExists) return cb(new Error('dest already exists.'));
            return rename(src, dest, overwrite, cb);
        });
    }
    function rename(src, dest, overwrite, cb) {
        fs$2.rename(src, dest, (err) => {
            if (!err) return cb();
            if (err.code !== 'EXDEV') return cb(err);
            return moveAcrossDevice(src, dest, overwrite, cb);
        });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
        const opts = {
            overwrite,
            errorOnExist: true,
        };
        copy(src, dest, opts, (err) => {
            if (err) return cb(err);
            return remove(src, cb);
        });
    }
    var move_1 = move$1;
    const u = universalify$1.fromCallback;
    var move = {
        move: u(move_1),
    };
    (function (module2) {
        module2.exports = __spreadValues(
            __spreadValues(
                __spreadValues(
                    __spreadValues(
                        __spreadValues(
                            __spreadValues(
                                __spreadValues(
                                    __spreadValues(
                                        __spreadValues(
                                            __spreadValues(
                                                __spreadValues(__spreadValues({}, fs$j), copySync$1),
                                                copy$1,
                                            ),
                                            empty,
                                        ),
                                        ensure,
                                    ),
                                    json,
                                ),
                                mkdirs$2,
                            ),
                            moveSync,
                        ),
                        move,
                    ),
                    output,
                ),
                pathExists_1,
            ),
            remove$2,
        );
        const fs = require$$2$2;
        if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
            Object.defineProperty(module2.exports, 'promises', {
                get() {
                    return fs.promises;
                },
            });
        }
    })(lib);
    var __fs = lib.exports;
    function __packageTmpDir() {
        const tmpDir = SSugarConfig.get('storage.package.tmpDir');
        if (tmpDir !== void 0) {
            __fs.ensureDirSync(tmpDir);
            return tmpDir;
        }
        __fs.ensureDirSync(__tmpDir);
        return __tmpDir;
    }
    const fn = function () {
        const path = SSugarConfig.get('storage.package.localDir');
        __fs.ensureDirSync(path);
        return path;
    };
    function __packageCacheDir(settings = {}) {
        settings = Object.assign({}, settings);
        const packageCacheDir = SSugarConfig.get('storage.package.cacheDir');
        if (packageCacheDir !== void 0) {
            __fs.ensureDirSync(packageCacheDir);
            return packageCacheDir;
        }
        return void 0;
    }
    function isFile(path, settings = {}) {
        settings = __deepMerge$2(
            {
                symlink: true,
            },
            settings,
        );
        let isMatching = __fs$1.existsSync(path);
        if (!isMatching) return false;
        if (settings.symlink && __fs$1.lstatSync(path).isSymbolicLink()) {
            const realPath = __fs$1.realpathSync(path);
            isMatching = isMatching && __fs$1.lstatSync(realPath).isFile();
        } else {
            isMatching = isMatching && __fs$1.lstatSync(path).isFile();
        }
        return isMatching;
    }
    var path$3 = require$$3$1,
        fs$1 = require$$2$2;
    function parse(data) {
        data = data.toString('utf-8');
        if (data.charCodeAt(0) === 65279) data = data.slice(1);
        try {
            return JSON.parse(data);
        } catch (e) {
            return false;
        }
    }
    var iteratorSymbol = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.iterator : null;
    function addSymbolIterator(result) {
        if (!iteratorSymbol) {
            return result;
        }
        result[iteratorSymbol] = function () {
            return this;
        };
        return result;
    }
    var findPackageJson = function find(root) {
        root = root || process.cwd();
        if (typeof root !== 'string') {
            if (typeof root === 'object' && typeof root.filename === 'string') {
                root = root.filename;
            } else {
                throw new Error('Must pass a filename string or a module object to finder');
            }
        }
        return addSymbolIterator({
            next: function next() {
                if (root.match(/^(\w:\\|\/)$/))
                    return addSymbolIterator({
                        value: void 0,
                        filename: void 0,
                        done: true,
                    });
                var file = path$3.join(root, 'package.json'),
                    data;
                root = path$3.resolve(root, '..');
                if (fs$1.existsSync(file) && (data = parse(fs$1.readFileSync(file)))) {
                    data.__path = file;
                    return addSymbolIterator({
                        value: data,
                        filename: file,
                        done: false,
                    });
                }
                return next();
            },
        });
    };
    function packageRoot(from = process.cwd(), highest = false) {
        if (isFile(from)) from = from.split('/').slice(0, -1).join('/');
        const f = findPackageJson(from);
        let file = f.next();
        if (!file || !file.filename) return false;
        if (!highest) {
            const filename = file.filename || false;
            if (!filename) return filename;
            return filename.split('/').slice(0, -1).join('/');
        }
        let finalFile;
        while (!file.done) {
            if (file.done) break;
            finalFile = file;
            file = f.next();
        }
        if (finalFile.filename) {
            return finalFile.filename.split('/').slice(0, -1).join('/');
        }
        return false;
    }
    function __packageRootDir(from, highest = false) {
        if (from) {
            return packageRoot(from, highest);
        }
        const packageRootDir = SSugarConfig.get('storage.package.rootDir');
        if (packageRootDir !== void 0) {
            __fs.ensureDirSync(packageRootDir);
            return packageRootDir;
        }
        return '/';
    }
    function __srcRootDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcRootDir = SSugarConfig.get('storage.src.rootDir');
        if (srcRootDir !== void 0) {
            __fs.ensureDirSync(srcRootDir);
            return srcRootDir;
        }
        return void 0;
    }
    function __distRootDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distRootDir = SSugarConfig.get('storage.dist.rootDir');
        if (distRootDir !== void 0) {
            __fs.ensureDirSync(distRootDir);
            return distRootDir;
        }
        return void 0;
    }
    function __srcJsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcJsDir = SSugarConfig.get('storage.src.jsDir');
        if (srcJsDir !== void 0) {
            __fs.ensureDirSync(srcJsDir);
            return srcJsDir;
        }
        return void 0;
    }
    function __srcCssDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcCssDir = SSugarConfig.get('storage.src.cssDir');
        if (srcCssDir !== void 0) {
            __fs.ensureDirSync(srcCssDir);
            return srcCssDir;
        }
        return void 0;
    }
    function __srcDocDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcDocDir = SSugarConfig.get('storage.src.docDir');
        if (srcDocDir !== void 0) {
            __fs.ensureDirSync(srcDocDir);
            return srcDocDir;
        }
        return void 0;
    }
    function __srcFontsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcFontsDir = SSugarConfig.get('storage.src.fontsDir');
        if (srcFontsDir !== void 0) {
            __fs.ensureDirSync(srcFontsDir);
            return srcFontsDir;
        }
        return void 0;
    }
    function __srcIconsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcIconsDir = SSugarConfig.get('storage.src.iconsDir');
        if (srcIconsDir !== void 0) {
            __fs.ensureDirSync(srcIconsDir);
            return srcIconsDir;
        }
        return void 0;
    }
    function __srcImgDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcImgDir = SSugarConfig.get('storage.src.imgDir');
        if (srcImgDir !== void 0) {
            __fs.ensureDirSync(srcImgDir);
            return srcImgDir;
        }
        return void 0;
    }
    function __srcNodeDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcNodeDir = SSugarConfig.get('storage.src.nodeDir');
        if (srcNodeDir !== void 0) {
            __fs.ensureDirSync(srcNodeDir);
            return srcNodeDir;
        }
        return void 0;
    }
    function __srcViewsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const srcViewsDir = SSugarConfig.get('storage.src.viewsDir');
        if (srcViewsDir !== void 0) {
            __fs.ensureDirSync(srcViewsDir);
            return srcViewsDir;
        }
        return void 0;
    }
    function __distJsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distJsDir = SSugarConfig.get('storage.dist.jsDir');
        if (distJsDir !== void 0) {
            __fs.ensureDirSync(distJsDir);
            return distJsDir;
        }
        return void 0;
    }
    function __distCssDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distCssDir = SSugarConfig.get('storage.dist.cssDir');
        if (distCssDir !== void 0) {
            __fs.ensureDirSync(distCssDir);
            return distCssDir;
        }
        return void 0;
    }
    function __distDocDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distDocDir = SSugarConfig.get('storage.dist.docDir');
        if (distDocDir !== void 0) {
            __fs.ensureDirSync(distDocDir);
            return distDocDir;
        }
        return void 0;
    }
    function __distFontsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distFontsDir = SSugarConfig.get('storage.dist.fontsDir');
        if (distFontsDir !== void 0) {
            __fs.ensureDirSync(distFontsDir);
            return distFontsDir;
        }
        return void 0;
    }
    function __distIconsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distIconsDir = SSugarConfig.get('storage.dist.iconsDir');
        if (distIconsDir !== void 0) {
            __fs.ensureDirSync(distIconsDir);
            return distIconsDir;
        }
        return void 0;
    }
    function __distImgDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distImgDir = SSugarConfig.get('storage.dist.imgDir');
        if (distImgDir !== void 0) {
            __fs.ensureDirSync(distImgDir);
            return distImgDir;
        }
        return void 0;
    }
    function __distNodeDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distNodeDir = SSugarConfig.get('storage.dist.nodeDir');
        if (distNodeDir !== void 0) {
            __fs.ensureDirSync(distNodeDir);
            return distNodeDir;
        }
        return void 0;
    }
    function __distViewsDir(settings = {}) {
        settings = Object.assign({}, settings);
        const distViewsDir = SSugarConfig.get('storage.dist.viewsDir');
        if (distViewsDir !== void 0) {
            __fs.ensureDirSync(distViewsDir);
            return distViewsDir;
        }
        return void 0;
    }
    function replacePathTokens(paths, settings) {
        const set = Object.assign(
            {
                packageTmpDir: true,
                packageLocalDir: true,
                packageCacheDir: true,
                packageRootDir: true,
                srcRootDir: true,
                distRootDir: true,
                srcJsDir: true,
                srcCssDir: true,
                srcDocDir: true,
                srcFontsDir: true,
                srcIconsDir: true,
                srcImgDir: true,
                srcNodeDir: true,
                srcViewsDir: true,
                distJsDir: true,
                distCssDir: true,
                distDocDir: true,
                distFontsDir: true,
                distIconsDir: true,
                distImgDir: true,
                distNodeDir: true,
                distViewsDir: true,
            },
            settings,
        );
        const isArray = Array.isArray(paths);
        if (!isArray) paths = [paths];
        const finalPaths = paths.map((path) => {
            if (set.packageTmpDir) path = path.replace('%packageTmpDir', __packageTmpDir());
            if (set.packageLocalDir) path = path.replace('%packageLocalDir', fn());
            if (set.packageCacheDir) path = path.replace('%packageCacheDir', __packageCacheDir());
            if (set.packageRootDir) path = path.replace('%packageRootDir', __packageRootDir());
            if (set.srcRootDir) path = path.replace('%srcRootDir', __srcRootDir());
            if (set.distRootDir) path = path.replace('%distRootDir', __distRootDir());
            if (set.srcJsDir) path = path.replace('%srcJsDir', __srcJsDir());
            if (set.srcCssDir) path = path.replace('%srcCssDir', __srcCssDir());
            if (set.srcDocDir) path = path.replace('%srcDocDir', __srcDocDir());
            if (set.srcFontsDir) path = path.replace('%srcFontsDir', __srcFontsDir());
            if (set.srcIconsDir) path = path.replace('%srcIconsDir', __srcIconsDir());
            if (set.srcImgDir) path = path.replace('%srcImgDir', __srcImgDir());
            if (set.srcNodeDir) path = path.replace('%srcNodeDir', __srcNodeDir());
            if (set.srcViewsDir) path = path.replace('%srcViewsDir', __srcViewsDir());
            if (set.distJsDir) path = path.replace('%distJsDir', __distJsDir());
            if (set.distCssDir) path = path.replace('%distCssDir', __distCssDir());
            if (set.distDocDir) path = path.replace('%distDocDir', __distDocDir());
            if (set.distFontsDir) path = path.replace('%distFontsDir', __distFontsDir());
            if (set.distIconsDir) path = path.replace('%distIconsDir', __distIconsDir());
            if (set.distImgDir) path = path.replace('%distImgDir', __distImgDir());
            if (set.distNodeDir) path = path.replace('%distNodeDir', __distNodeDir());
            if (set.distViewsDir) path = path.replace('%distViewsDir', __distViewsDir());
            path = path.replace(/\/\//gm, '/');
            return path;
        });
        if (isArray) return finalPaths;
        else return finalPaths[0];
    }
    function ensureDirSync(dir) {
        dir = replacePathTokens(dir);
        __fs.ensureDirSync(dir);
    }
    function removeSync(path) {
        path = replacePathTokens(path);
        return __fs.removeSync(path);
    }
    class SCacheAdapter extends SClass {
        constructor(settings = {}) {
            super(
                __deepMerge$2(
                    {
                        cacheAdapter: {},
                    },
                    settings,
                ),
            );
        }
        setCache(cache) {
            this.cache = cache;
        }
    }
    var __awaiter$1 = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    class SCacheFsAdapter extends SCacheAdapter {
        constructor(settings = {}) {
            super(
                __deepMerge$2(
                    {
                        fsCacheAdapter: {
                            rootDir: SSugarConfig.get('storage.cacheDir') || `${__packageTmpDir()}/SCache`,
                        },
                    },
                    settings,
                ),
            );
        }
        get fsCacheAdapterSettings() {
            return this._settings.fsCacheAdapter;
        }
        set(name2, value) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const fsName = `${this.cache.id}/${name2}.json`.replace(/\/\//gm, '/');
                ensureDirSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName.split('/').slice(0, -1).join('/')}`);
                __fs$1.writeFileSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`, value);
                return true;
            });
        }
        get(name2) {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (name2.slice(0, 1) === '/') name2 = name2.slice(1);
                const fsName = `${this.cache.id}/${name2}.json`;
                if (!__fs$1.existsSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`)) return null;
                return __fs$1.readFileSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`, 'utf8');
            });
        }
        delete(name2) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const fsName = `${this.cache.id}/${name2}.json`;
                return __fs$1.unlinkSync(`${this.fsCacheAdapterSettings.rootDir}/${fsName}`);
            });
        }
        clear() {
            return __awaiter$1(this, void 0, void 0, function* () {
                return removeSync(`${this.fsCacheAdapterSettings.rootDir}/${this.cache.id}`);
            });
        }
        keys() {
            return __awaiter$1(this, void 0, void 0, function* () {
                return [];
            });
        }
    }
    SCacheFsAdapter.id = 'fs';
    var SCacheFsAdapter$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: SCacheFsAdapter,
    });
    function Lazyness(require_) {
        if (!this || !(this instanceof Lazyness)) {
            return new Lazyness(require_);
        }
        this.require = require_;
    }
    var Lazyness_1 = Lazyness;
    Lazyness.property = (object, property, fn, enumerable) => {
        Object.defineProperty(object, property, {
            configurable: true,
            enumerable: !!enumerable,
            get: function () {
                var value = fn(object, property);
                Object.defineProperty(object, property, {
                    configurable: true,
                    enumerable: !!enumerable,
                    writable: false,
                    value,
                });
                return value;
            },
        });
        return object;
    };
    Lazyness.prototype.property = Lazyness.property;
    Lazyness.properties = (object, properties, enumerable) => {
        Object.keys(properties).forEach((property) => {
            Lazyness.property(object, property, properties[property], enumerable);
        });
        return object;
    };
    Lazyness.prototype.properties = Lazyness.properties;
    Lazyness.instanceProperty = (object, property, fn, enumerable) => {
        Object.defineProperty(object, property, {
            configurable: true,
            enumerable: !!enumerable,
            get: function () {
                var value = fn(this, property);
                Object.defineProperty(this, property, {
                    configurable: true,
                    enumerable: !!enumerable,
                    writable: false,
                    value,
                });
                return value;
            },
        });
        return object;
    };
    Lazyness.prototype.instanceProperty = Lazyness.instanceProperty;
    Lazyness.instanceProperties = (object, properties, enumerable) => {
        Object.keys(properties).forEach((property) => {
            Lazyness.property(object, property, properties[property], enumerable);
        });
        return object;
    };
    Lazyness.prototype.instanceProperties = Lazyness.instanceProperties;
    Lazyness.value = (fn) => {
        var firstTime = true,
            value;
        return function () {
            if (firstTime) {
                value = fn();
                firstTime = false;
            }
            return value;
        };
    };
    Lazyness.prototype.value = Lazyness.value;
    Lazyness.require = function (require_, moduleId) {
        var firstTime = true,
            module_;
        return new Proxy(() => {}, {
            construct: (target, args) => {
                if (firstTime) {
                    module_ = require_(moduleId);
                    firstTime = false;
                }
                return Reflect.construct(module_, args);
            },
            apply: (target, thisArg, args) => {
                if (firstTime) {
                    module_ = require_(moduleId);
                    firstTime = false;
                }
                return Reflect.apply(module_, thisArg, args);
            },
            get: (target, property) => {
                if (firstTime) {
                    module_ = require_(moduleId);
                    firstTime = false;
                }
                return Reflect.get(module_, property);
            },
        });
    };
    Lazyness.prototype.require = function (moduleId) {
        return Lazyness.require(this.require, moduleId);
    };
    Lazyness.requireProperty = function (require_, object, property, moduleId, enumerable) {
        Object.defineProperty(object, property, {
            configurable: true,
            enumerable: !!enumerable,
            get: function () {
                var module_ = require_(moduleId);
                Object.defineProperty(object, property, {
                    configurable: true,
                    enumerable: !!enumerable,
                    writable: false,
                    value: module_,
                });
                return module_;
            },
        });
        return object;
    };
    Lazyness.prototype.requireProperty = function (object, property, moduleId, enumerable) {
        return Lazyness.requireProperty(this.require, object, property, moduleId, enumerable);
    };
    Lazyness.requireProperties = function (require_, object, properties, enumerable) {
        Object.keys(properties).forEach((property) => {
            Lazyness.requireProperty(require_, object, property, properties[property], enumerable);
        });
        return object;
    };
    Lazyness.prototype.requireProperties = function (object, properties, enumerable) {
        return Lazyness.requireProperties(this.require, object, properties, enumerable);
    };
    var polyfill$1 = {};
    var polyfill_1 = polyfill$1;
    polyfill$1.repeat = function (count) {
        if (this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count !== count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count === Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length === 0 || count === 0) {
            return '';
        }
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) === 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count === 0) {
                break;
            }
            str += str;
        }
        return rpt;
    };
    var _escape = {};
    (function (exports) {
        exports.regExp = exports.regExpPattern = (str) => str.replace(/([.*+?^${}()|[\]/\\])/g, '\\$1');
        exports.regExpReplacement = (str) => str.replace(/\$/g, '$$$$');
        exports.format = (str) => str.replace(/%/g, '%%');
        exports.jsSingleQuote = (str) => exports.control(str).replace(/'/g, "\\'");
        exports.jsDoubleQuote = (str) => exports.control(str).replace(/"/g, '\\"');
        exports.shellArg = (str) => "'" + str.replace(/'/g, "'\\''") + "'";
        var escapeControlMap = {
            '\r': '\\r',
            '\n': '\\n',
            '	': '\\t',
            '\x7F': '\\x7f',
        };
        exports.control = (str, keepNewLineAndTab = false) =>
            str.replace(/[\x00-\x1f\x7f]/g, (match) => {
                if (keepNewLineAndTab && (match === '\n' || match === '	')) {
                    return match;
                }
                if (escapeControlMap[match] !== void 0) {
                    return escapeControlMap[match];
                }
                var hex = match.charCodeAt(0).toString(16);
                if (hex.length % 2) {
                    hex = '0' + hex;
                }
                return '\\x' + hex;
            });
        var escapeHtmlMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;',
        };
        exports.html = (str) => str.replace(/[&<>]/g, (match) => escapeHtmlMap[match]);
        exports.htmlAttr = (str) => str.replace(/[&<>"]/g, (match) => escapeHtmlMap[match]);
        exports.htmlSpecialChars = (str) => str.replace(/[&<>"']/g, (match) => escapeHtmlMap[match]);
        exports.unicodePercentEncode = (str) =>
            str.replace(/[\x00-\x1f\u0100-\uffff\x7f%]/g, (match) => {
                try {
                    return encodeURI(match);
                } catch (error) {
                    return '';
                }
            });
        exports.httpHeaderValue = (str) => exports.unicodePercentEncode(str);
    })(_escape);
    var ansi$1 = {
        reset: '[0m',
        bold: '[1m',
        dim: '[2m',
        italic: '[3m',
        underline: '[4m',
        inverse: '[7m',
        defaultColor: '[39m',
        black: '[30m',
        red: '[31m',
        green: '[32m',
        yellow: '[33m',
        blue: '[34m',
        magenta: '[35m',
        cyan: '[36m',
        white: '[37m',
        grey: '[90m',
        gray: '[90m',
        brightBlack: '[90m',
        brightRed: '[91m',
        brightGreen: '[92m',
        brightYellow: '[93m',
        brightBlue: '[94m',
        brightMagenta: '[95m',
        brightCyan: '[96m',
        brightWhite: '[97m',
        defaultBgColor: '[49m',
        bgBlack: '[40m',
        bgRed: '[41m',
        bgGreen: '[42m',
        bgYellow: '[43m',
        bgBlue: '[44m',
        bgMagenta: '[45m',
        bgCyan: '[46m',
        bgWhite: '[47m',
        bgGrey: '[100m',
        bgGray: '[100m',
        bgBrightBlack: '[100m',
        bgBrightRed: '[101m',
        bgBrightGreen: '[102m',
        bgBrightYellow: '[103m',
        bgBrightBlue: '[104m',
        bgBrightMagenta: '[105m',
        bgBrightCyan: '[106m',
        bgBrightWhite: '[107m',
    };
    const unicode$1 = {};
    var unicode_1 = unicode$1;
    unicode$1.encode = (array) => String.fromCodePoint(...array);
    unicode$1.decode = (str) => {
        var value,
            extra,
            counter = 0,
            output = [],
            length = str.length;
        while (counter < length) {
            value = str.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
                extra = str.charCodeAt(counter++);
                if ((extra & 64512) === 56320) {
                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                } else {
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    };
    unicode$1.firstCodePoint = (str) => {
        var extra,
            value = str.charCodeAt(0);
        if (value >= 55296 && value <= 56319 && str.length >= 2) {
            extra = str.charCodeAt(1);
            if ((extra & 64512) === 56320) {
                return ((value & 1023) << 10) + (extra & 1023) + 65536;
            }
        }
        return value;
    };
    unicode$1.firstChar = (str) => {
        var extra,
            value = str.charCodeAt(0);
        if (value >= 55296 && value <= 56319 && str.length >= 2) {
            extra = str.charCodeAt(1);
            if ((extra & 64512) === 56320) {
                return str.slice(0, 2);
            }
        }
        return str[0];
    };
    unicode$1.toArray = (str) => {
        var value,
            extra,
            counter = 0,
            output = [],
            length = str.length;
        while (counter < length) {
            value = str.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
                extra = str.charCodeAt(counter++);
                if ((extra & 64512) === 56320) {
                    output.push(str.slice(counter - 2, counter));
                } else {
                    output.push(str[counter - 2]);
                    counter--;
                }
            } else {
                output.push(str[counter - 1]);
            }
        }
        return output;
    };
    unicode$1.toCells = (Cell, str, tabWidth = 4, linePosition = 0, ...extraCellArgs) => {
        var value,
            extra,
            counter = 0,
            output = [],
            fillSize,
            length = str.length;
        while (counter < length) {
            value = str.charCodeAt(counter++);
            if (value === 10) {
                linePosition = 0;
            } else if (value === 9) {
                fillSize = tabWidth - (linePosition % tabWidth) - 1;
                output.push(new Cell('	', ...extraCellArgs));
                linePosition += 1 + fillSize;
                while (fillSize--) {
                    output.push(new Cell(null, ...extraCellArgs));
                }
            } else if (value >= 55296 && value <= 56319 && counter < length) {
                extra = str.charCodeAt(counter++);
                if ((extra & 64512) === 56320) {
                    value = ((value & 1023) << 10) + (extra & 1023) + 65536;
                    output.push(new Cell(str.slice(counter - 2, counter), ...extraCellArgs));
                    linePosition++;
                    if (unicode$1.codePointWidth(value) === 2) {
                        linePosition++;
                        output.push(new Cell(null, ...extraCellArgs));
                    }
                } else {
                    counter--;
                }
            } else {
                output.push(new Cell(str[counter - 1], ...extraCellArgs));
                linePosition++;
                if (unicode$1.codePointWidth(value) === 2) {
                    output.push(new Cell(null, ...extraCellArgs));
                    linePosition++;
                }
            }
        }
        return output;
    };
    unicode$1.fromCells = (cells) => {
        return cells.map((cell) => (cell.filler ? '' : cell.char)).join('');
    };
    unicode$1.length = (str) => {
        var value,
            extra,
            counter = 0,
            uLength = 0,
            length = str.length;
        while (counter < length) {
            value = str.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
                extra = str.charCodeAt(counter++);
                if ((extra & 64512) !== 56320) {
                    counter--;
                }
            }
            uLength++;
        }
        return uLength;
    };
    unicode$1.width = (str) => {
        var count = 0;
        unicode$1.decode(str).forEach((code) => (count += unicode$1.codePointWidth(code)));
        return count;
    };
    unicode$1.arrayWidth = (array, limit) => {
        var index,
            count = 0;
        if (limit === void 0) {
            limit = array.length;
        }
        for (index = 0; index < limit; index++) {
            count += unicode$1.isFullWidth(array[index]) ? 2 : 1;
        }
        return count;
    };
    var lastTruncateWidth$1 = 0;
    unicode$1.getLastTruncateWidth = () => lastTruncateWidth$1;
    unicode$1.widthLimit = unicode$1.truncateWidth = (str, limit) => {
        var value,
            extra,
            charWidth,
            counter = 0,
            lastCounter = 0,
            length = str.length;
        lastTruncateWidth$1 = 0;
        while (counter < length) {
            value = str.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
                extra = str.charCodeAt(counter++);
                if ((extra & 64512) === 56320) {
                    value = ((value & 1023) << 10) + (extra & 1023) + 65536;
                } else {
                    counter--;
                }
            }
            charWidth = unicode$1.codePointWidth(value);
            if (lastTruncateWidth$1 + charWidth > limit) {
                return str.slice(0, lastCounter);
            }
            lastTruncateWidth$1 += charWidth;
            lastCounter = counter;
        }
        return str;
    };
    unicode$1.surrogatePair = (char) => {
        var code = char.charCodeAt(0);
        if (code < 55296 || code >= 57344) {
            return 0;
        } else if (code < 56320) {
            return 1;
        }
        return -1;
    };
    unicode$1.isFullWidth = (char) => {
        if (char.length <= 1) {
            return unicode$1.isFullWidthCodePoint(char.codePointAt(0));
        }
        return unicode$1.isFullWidthCodePoint(unicode$1.firstCodePoint(char));
    };
    unicode$1.charWidth = (char) => {
        if (char.length <= 1) {
            return unicode$1.codePointWidth(char.codePointAt(0));
        }
        return unicode$1.codePointWidth(unicode$1.firstCodePoint(char));
    };
    unicode$1.codePointWidth = (code) => {
        if (
            code >= 4352 &&
            (code <= 4447 ||
                code === 9001 ||
                code === 9002 ||
                (11904 <= code && code <= 12871 && code !== 12351) ||
                (12880 <= code && code <= 19903) ||
                (19968 <= code && code <= 42182) ||
                (43360 <= code && code <= 43388) ||
                (44032 <= code && code <= 55203) ||
                (63744 <= code && code <= 64255) ||
                (65040 <= code && code <= 65049) ||
                (65072 <= code && code <= 65131) ||
                (65281 <= code && code <= 65376) ||
                (65504 <= code && code <= 65510) ||
                (110592 <= code && code <= 110593) ||
                (127488 <= code && code <= 127569) ||
                (131072 <= code && code <= 262141))
        ) {
            return 2;
        }
        return 1;
    };
    unicode$1.isFullWidthCodePoint = (code) => unicode$1.codePointWidth(code) === 2;
    unicode$1.toFullWidth = (str) => {
        return String.fromCodePoint(
            ...unicode$1.decode(str).map((code) => (code >= 33 && code <= 126 ? 65280 + code - 32 : code)),
        );
    };
    var format = {};
    var inspect$1 = {};
    const escape$1 = _escape;
    const ansi = ansi$1;
    const EMPTY = {};
    function inspect(options, variable) {
        if (arguments.length < 2) {
            variable = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        var runtime = { depth: 0, ancestors: [] };
        if (!options.style) {
            options.style = inspectStyle.none;
        } else if (typeof options.style === 'string') {
            options.style = inspectStyle[options.style];
        }
        if (options.depth === void 0) {
            options.depth = 3;
        }
        if (options.maxLength === void 0) {
            options.maxLength = 250;
        }
        if (options.outputMaxLength === void 0) {
            options.outputMaxLength = 5e3;
        }
        if (options.nofunc) {
            options.noFunc = true;
        }
        if (options.minimal) {
            options.noFunc = true;
            options.noDescriptor = true;
            options.noType = true;
            options.noArrayProperty = true;
            options.enumOnly = true;
            options.proto = false;
            options.funcDetails = false;
        }
        var str = inspect_(runtime, options, variable);
        if (str.length > options.outputMaxLength) {
            str = options.style.truncate(str, options.outputMaxLength);
        }
        return str;
    }
    function inspect_(runtime, options, variable) {
        var i,
            funcName,
            length,
            proto,
            propertyList,
            constructor,
            keyIsProperty,
            type,
            pre,
            indent,
            isArray,
            isFunc,
            specialObject,
            str = '',
            key = '',
            descriptorStr = '',
            descriptor,
            nextAncestors;
        type = typeof variable;
        indent = options.style.tab.repeat(runtime.depth);
        if (type === 'function' && options.noFunc) {
            return '';
        }
        if (runtime.key !== void 0) {
            if (runtime.descriptor) {
                descriptorStr = [];
                if (!runtime.descriptor.configurable) {
                    descriptorStr.push('-conf');
                }
                if (!runtime.descriptor.enumerable) {
                    descriptorStr.push('-enum');
                }
                if (!runtime.descriptor.writable) {
                    descriptorStr.push('-w');
                }
                if (descriptorStr.length) {
                    descriptorStr = descriptorStr.join(' ');
                } else {
                    descriptorStr = '';
                }
            }
            if (runtime.keyIsProperty) {
                if (keyNeedingQuotes(runtime.key)) {
                    key = '"' + options.style.key(runtime.key) + '": ';
                } else {
                    key = options.style.key(runtime.key) + ': ';
                }
            } else if (!options.noIndex) {
                key = options.style.index(runtime.key);
            }
            if (descriptorStr) {
                descriptorStr = ' ' + options.style.type(descriptorStr);
            }
        }
        pre = runtime.noPre ? '' : indent + key;
        if (variable === void 0) {
            str += pre + options.style.constant('undefined') + descriptorStr + options.style.newline;
        } else if (variable === EMPTY) {
            str += pre + options.style.constant('[empty]') + descriptorStr + options.style.newline;
        } else if (variable === null) {
            str += pre + options.style.constant('null') + descriptorStr + options.style.newline;
        } else if (variable === false) {
            str += pre + options.style.constant('false') + descriptorStr + options.style.newline;
        } else if (variable === true) {
            str += pre + options.style.constant('true') + descriptorStr + options.style.newline;
        } else if (type === 'number') {
            str +=
                pre +
                options.style.number(variable.toString()) +
                (options.noType ? '' : ' ' + options.style.type('number')) +
                descriptorStr +
                options.style.newline;
        } else if (type === 'string') {
            if (variable.length > options.maxLength) {
                str +=
                    pre +
                    '"' +
                    options.style.string(escape$1.control(variable.slice(0, options.maxLength - 1))) +
                    '\u2026"' +
                    (options.noType
                        ? ''
                        : ' ' +
                          options.style.type('string') +
                          options.style.length('(' + variable.length + ' - TRUNCATED)')) +
                    descriptorStr +
                    options.style.newline;
            } else {
                str +=
                    pre +
                    '"' +
                    options.style.string(escape$1.control(variable)) +
                    '"' +
                    (options.noType
                        ? ''
                        : ' ' + options.style.type('string') + options.style.length('(' + variable.length + ')')) +
                    descriptorStr +
                    options.style.newline;
            }
        } else if (Buffer.isBuffer(variable)) {
            str +=
                pre +
                options.style.inspect(variable.inspect()) +
                (options.noType
                    ? ''
                    : ' ' + options.style.type('Buffer') + options.style.length('(' + variable.length + ')')) +
                descriptorStr +
                options.style.newline;
        } else if (type === 'object' || type === 'function') {
            funcName = length = '';
            isFunc = false;
            if (type === 'function') {
                isFunc = true;
                funcName = ' ' + options.style.funcName(variable.name ? variable.name : '(anonymous)');
                length = options.style.length('(' + variable.length + ')');
            }
            isArray = false;
            if (Array.isArray(variable)) {
                isArray = true;
                length = options.style.length('(' + variable.length + ')');
            }
            if (!variable.constructor) {
                constructor = '(no constructor)';
            } else if (!variable.constructor.name) {
                constructor = '(anonymous)';
            } else {
                constructor = variable.constructor.name;
            }
            constructor = options.style.constructorName(constructor);
            proto = Object.getPrototypeOf(variable);
            str += pre;
            if (!options.noType) {
                if (runtime.forceType) {
                    str += options.style.type(runtime.forceType);
                } else {
                    str += constructor + funcName + length + ' ' + options.style.type(type) + descriptorStr;
                }
                if (!isFunc || options.funcDetails) {
                    str += ' ';
                }
            }
            if (isArray && options.noArrayProperty) {
                propertyList = [...Array(variable.length).keys()];
            } else {
                propertyList = Object.getOwnPropertyNames(variable);
            }
            if (options.sort) {
                propertyList.sort();
            }
            specialObject = specialObjectSubstitution(variable, runtime, options);
            if (options.protoBlackList && options.protoBlackList.has(proto)) {
                str += options.style.limit('[skip]') + options.style.newline;
            } else if (specialObject !== void 0) {
                if (typeof specialObject === 'string') {
                    str += '=> ' + specialObject + options.style.newline;
                } else {
                    str +=
                        '=> ' +
                        inspect_(
                            {
                                depth: runtime.depth,
                                ancestors: runtime.ancestors,
                                noPre: true,
                            },
                            options,
                            specialObject,
                        );
                }
            } else if (isFunc && !options.funcDetails) {
                str += options.style.newline;
            } else if (!propertyList.length && !options.proto) {
                str += (isArray ? '[]' : '{}') + options.style.newline;
            } else if (runtime.depth >= options.depth) {
                str += options.style.limit('[depth limit]') + options.style.newline;
            } else if (runtime.ancestors.indexOf(variable) !== -1) {
                str += options.style.limit('[circular]') + options.style.newline;
            } else {
                str += (isArray && options.noType && options.noArrayProperty ? '[' : '{') + options.style.newline;
                nextAncestors = runtime.ancestors.slice();
                nextAncestors.push(variable);
                for (i = 0; i < propertyList.length && str.length < options.outputMaxLength; i++) {
                    if (
                        !isArray &&
                        ((options.propertyBlackList && options.propertyBlackList.has(propertyList[i])) ||
                            (options.useInspectPropertyBlackList &&
                                variable.inspectPropertyBlackList instanceof Set &&
                                variable.inspectPropertyBlackList.has(propertyList[i])))
                    ) {
                        continue;
                    }
                    if (isArray && options.noArrayProperty && !(propertyList[i] in variable)) {
                        str += inspect_(
                            {
                                depth: runtime.depth + 1,
                                ancestors: nextAncestors,
                                key: propertyList[i],
                                keyIsProperty: false,
                            },
                            options,
                            EMPTY,
                        );
                    } else {
                        try {
                            descriptor = Object.getOwnPropertyDescriptor(variable, propertyList[i]);
                            if (!descriptor.enumerable && options.enumOnly) {
                                continue;
                            }
                            keyIsProperty = !isArray || !descriptor.enumerable || isNaN(propertyList[i]);
                            if (!options.noDescriptor && descriptor && (descriptor.get || descriptor.set)) {
                                str += inspect_(
                                    {
                                        depth: runtime.depth + 1,
                                        ancestors: nextAncestors,
                                        key: propertyList[i],
                                        keyIsProperty,
                                        descriptor,
                                        forceType: 'getter/setter',
                                    },
                                    options,
                                    { get: descriptor.get, set: descriptor.set },
                                );
                            } else {
                                str += inspect_(
                                    {
                                        depth: runtime.depth + 1,
                                        ancestors: nextAncestors,
                                        key: propertyList[i],
                                        keyIsProperty,
                                        descriptor: options.noDescriptor ? void 0 : descriptor,
                                    },
                                    options,
                                    variable[propertyList[i]],
                                );
                            }
                        } catch (error) {
                            str += inspect_(
                                {
                                    depth: runtime.depth + 1,
                                    ancestors: nextAncestors,
                                    key: propertyList[i],
                                    keyIsProperty,
                                    descriptor: options.noDescriptor ? void 0 : descriptor,
                                },
                                options,
                                error,
                            );
                        }
                    }
                    if (i < propertyList.length - 1) {
                        str += options.style.comma;
                    }
                }
                if (options.proto) {
                    str += inspect_(
                        {
                            depth: runtime.depth + 1,
                            ancestors: nextAncestors,
                            key: '__proto__',
                            keyIsProperty: true,
                        },
                        options,
                        proto,
                    );
                }
                str += indent + (isArray && options.noType && options.noArrayProperty ? ']' : '}');
                str += options.style.newline;
            }
        }
        if (runtime.depth === 0) {
            if (options.style.trim) {
                str = str.trim();
            }
            if (options.style === 'html') {
                str = escape$1.html(str);
            }
        }
        return str;
    }
    inspect$1.inspect = inspect;
    function keyNeedingQuotes(key) {
        if (!key.length) {
            return true;
        }
        return false;
    }
    var promiseStates = ['pending', 'fulfilled', 'rejected'];
    function specialObjectSubstitution(object, runtime, options) {
        if (typeof object.constructor !== 'function') {
            return;
        }
        if (object instanceof String) {
            return object.toString();
        }
        if (object instanceof RegExp) {
            return object.toString();
        }
        if (object instanceof Date) {
            return object.toString() + ' [' + object.getTime() + ']';
        }
        if (typeof Set === 'function' && object instanceof Set) {
            return Array.from(object);
        }
        if (typeof Map === 'function' && object instanceof Map) {
            return Array.from(object);
        }
        if (object instanceof Promise) {
            if (process && process.binding && process.binding('util') && process.binding('util').getPromiseDetails) {
                let details = process.binding('util').getPromiseDetails(object);
                let state = promiseStates[details[0]];
                let str = 'Promise <' + state + '>';
                if (state === 'fulfilled') {
                    str +=
                        ' ' +
                        inspect_(
                            {
                                depth: runtime.depth,
                                ancestors: runtime.ancestors,
                                noPre: true,
                            },
                            options,
                            details[1],
                        );
                } else if (state === 'rejected') {
                    if (details[1] instanceof Error) {
                        str +=
                            ' ' +
                            inspectError(
                                {
                                    style: options.style,
                                    noErrorStack: true,
                                },
                                details[1],
                            );
                    } else {
                        str +=
                            ' ' +
                            inspect_(
                                {
                                    depth: runtime.depth,
                                    ancestors: runtime.ancestors,
                                    noPre: true,
                                },
                                options,
                                details[1],
                            );
                    }
                }
                return str;
            }
        }
        if (object._bsontype) {
            return object.toString();
        }
        if (options.useInspect && typeof object.inspect === 'function') {
            return object.inspect();
        }
        return;
    }
    function inspectError(options, error) {
        var str = '',
            stack,
            type,
            code;
        if (arguments.length < 2) {
            error = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (!(error instanceof Error)) {
            return "inspectError(): it's not an error, using regular variable inspection: " + inspect(options, error);
        }
        if (!options.style) {
            options.style = inspectStyle.none;
        } else if (typeof options.style === 'string') {
            options.style = inspectStyle[options.style];
        }
        if (error.stack && !options.noErrorStack) {
            stack = inspectStack(options, error.stack);
        }
        type = error.type || error.constructor.name;
        code = error.code || error.name || error.errno || error.number;
        str += options.style.errorType(type) + (code ? ' [' + options.style.errorType(code) + ']' : '') + ': ';
        str += options.style.errorMessage(error.message) + '\n';
        if (stack) {
            str += options.style.errorStack(stack) + '\n';
        }
        if (error.from) {
            str +=
                options.style.newline +
                options.style.errorFromMessage('From error:') +
                options.style.newline +
                inspectError(options, error.from);
        }
        return str;
    }
    inspect$1.inspectError = inspectError;
    function inspectStack(options, stack) {
        if (arguments.length < 2) {
            stack = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (!options.style) {
            options.style = inspectStyle.none;
        } else if (typeof options.style === 'string') {
            options.style = inspectStyle[options.style];
        }
        if (!stack) {
            return;
        }
        if ((options.browser || process.browser) && stack.indexOf('@') !== -1) {
            stack = stack
                .replace(/[</]*(?=@)/g, '')
                .replace(
                    /^\s*([^@]*)\s*@\s*([^\n]*)(?::([0-9]+):([0-9]+))?$/gm,
                    (matches, method, file, line, column) => {
                        return (
                            options.style.errorStack('    at ') +
                            (method ? options.style.errorStackMethod(method) + ' ' : '') +
                            options.style.errorStack('(') +
                            (file ? options.style.errorStackFile(file) : options.style.errorStack('unknown')) +
                            (line ? options.style.errorStack(':') + options.style.errorStackLine(line) : '') +
                            (column ? options.style.errorStack(':') + options.style.errorStackColumn(column) : '') +
                            options.style.errorStack(')')
                        );
                    },
                );
        } else {
            stack = stack.replace(/^[^\n]*\n/, '');
            stack = stack.replace(
                /^\s*(at)\s+(?:(?:(async|new)\s+)?([^\s:()[\]\n]+(?:\([^)]+\))?)\s)?(?:\[as ([^\s:()[\]\n]+)\]\s)?(?:\(?([^:()[\]\n]+):([0-9]+):([0-9]+)\)?)?$/gm,
                (matches, at, keyword, method, as, file, line, column) => {
                    return (
                        options.style.errorStack('    at ') +
                        (keyword ? options.style.errorStackKeyword(keyword) + ' ' : '') +
                        (method ? options.style.errorStackMethod(method) + ' ' : '') +
                        (as
                            ? options.style.errorStack('[as ') +
                              options.style.errorStackMethodAs(as) +
                              options.style.errorStack('] ')
                            : '') +
                        options.style.errorStack('(') +
                        (file ? options.style.errorStackFile(file) : options.style.errorStack('unknown')) +
                        (line ? options.style.errorStack(':') + options.style.errorStackLine(line) : '') +
                        (column ? options.style.errorStack(':') + options.style.errorStackColumn(column) : '') +
                        options.style.errorStack(')')
                    );
                },
            );
        }
        return stack;
    }
    inspect$1.inspectStack = inspectStack;
    var inspectStyle = {};
    var inspectStyleNoop = (str) => str;
    inspectStyle.none = {
        trim: false,
        tab: '    ',
        newline: '\n',
        comma: '',
        limit: inspectStyleNoop,
        type: (str) => '<' + str + '>',
        constant: inspectStyleNoop,
        funcName: inspectStyleNoop,
        constructorName: (str) => '<' + str + '>',
        length: inspectStyleNoop,
        key: inspectStyleNoop,
        index: (str) => '[' + str + '] ',
        number: inspectStyleNoop,
        inspect: inspectStyleNoop,
        string: inspectStyleNoop,
        errorType: inspectStyleNoop,
        errorMessage: inspectStyleNoop,
        errorStack: inspectStyleNoop,
        errorStackKeyword: inspectStyleNoop,
        errorStackMethod: inspectStyleNoop,
        errorStackMethodAs: inspectStyleNoop,
        errorStackFile: inspectStyleNoop,
        errorStackLine: inspectStyleNoop,
        errorStackColumn: inspectStyleNoop,
        errorFromMessage: inspectStyleNoop,
        truncate: (str, maxLength) => str.slice(0, maxLength - 1) + '\u2026',
    };
    inspectStyle.inline = Object.assign({}, inspectStyle.none, {
        trim: true,
        tab: '',
        newline: ' ',
        comma: ', ',
        length: () => '',
        index: () => '',
    });
    inspectStyle.color = Object.assign({}, inspectStyle.none, {
        limit: (str) => ansi.bold + ansi.brightRed + str + ansi.reset,
        type: (str) => ansi.italic + ansi.brightBlack + str + ansi.reset,
        constant: (str) => ansi.cyan + str + ansi.reset,
        funcName: (str) => ansi.italic + ansi.magenta + str + ansi.reset,
        constructorName: (str) => ansi.magenta + str + ansi.reset,
        length: (str) => ansi.italic + ansi.brightBlack + str + ansi.reset,
        key: (str) => ansi.green + str + ansi.reset,
        index: (str) => ansi.blue + '[' + str + ']' + ansi.reset + ' ',
        number: (str) => ansi.cyan + str + ansi.reset,
        inspect: (str) => ansi.cyan + str + ansi.reset,
        string: (str) => ansi.blue + str + ansi.reset,
        errorType: (str) => ansi.red + ansi.bold + str + ansi.reset,
        errorMessage: (str) => ansi.red + ansi.italic + str + ansi.reset,
        errorStack: (str) => ansi.brightBlack + str + ansi.reset,
        errorStackKeyword: (str) => ansi.italic + ansi.bold + str + ansi.reset,
        errorStackMethod: (str) => ansi.brightYellow + str + ansi.reset,
        errorStackMethodAs: (str) => ansi.yellow + str + ansi.reset,
        errorStackFile: (str) => ansi.brightCyan + str + ansi.reset,
        errorStackLine: (str) => ansi.blue + str + ansi.reset,
        errorStackColumn: (str) => ansi.magenta + str + ansi.reset,
        errorFromMessage: (str) => ansi.yellow + ansi.underline + str + ansi.reset,
        truncate: (str, maxLength) => {
            var trail = ansi.gray + '\u2026' + ansi.reset;
            str = str.slice(0, maxLength - trail.length);
            var lastEscape = str.lastIndexOf('');
            if (lastEscape >= str.length - 6) {
                str = str.slice(0, lastEscape);
            }
            return str + trail;
        },
    });
    inspectStyle.html = Object.assign({}, inspectStyle.none, {
        tab: '&nbsp;&nbsp;&nbsp;&nbsp;',
        newline: '<br />',
        limit: (str) => '<span style="color:red">' + str + '</span>',
        type: (str) => '<i style="color:gray">' + str + '</i>',
        constant: (str) => '<span style="color:cyan">' + str + '</span>',
        funcName: (str) => '<i style="color:magenta">' + str + '</i>',
        constructorName: (str) => '<span style="color:magenta">' + str + '</span>',
        length: (str) => '<i style="color:gray">' + str + '</i>',
        key: (str) => '<span style="color:green">' + str + '</span>',
        index: (str) => '<span style="color:blue">[' + str + ']</span> ',
        number: (str) => '<span style="color:cyan">' + str + '</span>',
        inspect: (str) => '<span style="color:cyan">' + str + '</span>',
        string: (str) => '<span style="color:blue">' + str + '</span>',
        errorType: (str) => '<span style="color:red">' + str + '</span>',
        errorMessage: (str) => '<span style="color:red">' + str + '</span>',
        errorStack: (str) => '<span style="color:gray">' + str + '</span>',
        errorStackKeyword: (str) => '<i>' + str + '</i>',
        errorStackMethod: (str) => '<span style="color:yellow">' + str + '</span>',
        errorStackMethodAs: (str) => '<span style="color:yellow">' + str + '</span>',
        errorStackFile: (str) => '<span style="color:cyan">' + str + '</span>',
        errorStackLine: (str) => '<span style="color:blue">' + str + '</span>',
        errorStackColumn: (str) => '<span style="color:gray">' + str + '</span>',
        errorFromMessage: (str) => '<span style="color:yellow">' + str + '</span>',
    });
    var naturalSort = function (a, b) {
        var re = /(^([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)?$|^0x[\da-fA-F]+$|\d+)/g,
            sre = /^\s+|\s+$/g,
            snre = /\s+/g,
            dre =
                /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[/-]\d{1,4}[/-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
            hre = /^0x[0-9a-f]+$/i,
            ore = /^0/,
            i = function (s) {
                return ('' + s).toLowerCase().replace(sre, '');
            },
            x = i(a) || '',
            y = i(b) || '',
            xN = x.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),
            yN = y.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),
            xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && Date.parse(x)),
            yD = parseInt(y.match(hre), 16) || (xD && y.match(dre) && Date.parse(y)) || null,
            normChunk = function (s, l) {
                return ((!s.match(ore) || l === 1) && parseFloat(s)) || s.replace(snre, ' ').replace(sre, '') || 0;
            },
            oFxNcL,
            oFyNcL;
        if (yD) {
            if (xD < yD) {
                return -1;
            } else if (xD > yD) {
                return 1;
            }
        }
        for (var cLoc = 0, xNl = xN.length, yNl = yN.length, numS = Math.max(xNl, yNl); cLoc < numS; cLoc++) {
            oFxNcL = normChunk(xN[cLoc], xNl);
            oFyNcL = normChunk(yN[cLoc], yNl);
            if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
                return isNaN(oFxNcL) ? 1 : -1;
            } else if (typeof oFxNcL !== typeof oFyNcL) {
                oFxNcL += '';
                oFyNcL += '';
            }
            if (oFxNcL < oFyNcL) {
                return -1;
            }
            if (oFxNcL > oFyNcL) {
                return 1;
            }
        }
        return 0;
    };
    (function (exports) {
        const inspect = inspect$1.inspect;
        const inspectError = inspect$1.inspectError;
        const escape2 = _escape;
        const ansi = ansi$1;
        const unicode = unicode_1;
        const naturalSort$1 = naturalSort;
        exports.formatMethod = function (...args) {
            var str = args[0];
            if (typeof str !== 'string') {
                if (!str) {
                    str = '';
                } else if (typeof str.toString === 'function') {
                    str = str.toString();
                } else {
                    str = '';
                }
            }
            var arg,
                autoIndex = 1,
                length = args.length,
                hasMarkup = false,
                shift = null,
                markupStack = [];
            if (this.markupReset && this.startingMarkupReset) {
                str = (typeof this.markupReset === 'function' ? this.markupReset(markupStack) : this.markupReset) + str;
            }
            str = str.replace(
                /\^(.?)|(%%)|%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-Z])/g,
                (match, markup, doublePercent, relative, index, modeArg, mode) => {
                    var replacement,
                        i,
                        tmp,
                        fn,
                        fnArgString,
                        argMatches,
                        argList = [];
                    if (doublePercent) {
                        return '%';
                    }
                    if (markup) {
                        if (this.noMarkup) {
                            return '^' + markup;
                        }
                        if (markup === '^') {
                            return '^';
                        }
                        if (this.shiftMarkup && this.shiftMarkup[markup]) {
                            shift = this.shiftMarkup[markup];
                            return '';
                        }
                        if (shift) {
                            if (
                                !this.shiftedMarkup ||
                                !this.shiftedMarkup[shift] ||
                                !this.shiftedMarkup[shift][markup]
                            ) {
                                return '';
                            }
                            hasMarkup = true;
                            if (typeof this.shiftedMarkup[shift][markup] === 'function') {
                                replacement = this.shiftedMarkup[shift][markup](markupStack);
                            } else {
                                replacement = this.shiftedMarkup[shift][markup];
                                markupStack.push(replacement);
                            }
                            shift = null;
                        } else {
                            if (!this.markup || !this.markup[markup]) {
                                return '';
                            }
                            hasMarkup = true;
                            if (typeof this.markup[markup] === 'function') {
                                replacement = this.markup[markup](markupStack);
                            } else {
                                replacement = this.markup[markup];
                                markupStack.push(replacement);
                            }
                        }
                        return replacement;
                    }
                    if (index) {
                        index = parseInt(index, 10);
                        if (relative) {
                            if (relative === '+') {
                                index = autoIndex + index;
                            } else if (relative === '-') {
                                index = autoIndex - index;
                            }
                        }
                    } else {
                        index = autoIndex;
                    }
                    autoIndex++;
                    if (index >= length || index < 1) {
                        arg = void 0;
                    } else {
                        arg = args[index];
                    }
                    if (modes[mode]) {
                        replacement = modes[mode](arg, modeArg, this);
                        if (this.argumentSanitizer && !modes[mode].noSanitize) {
                            replacement = this.argumentSanitizer(replacement);
                        }
                        if (modeArg && !modes[mode].noCommonModeArg) {
                            replacement = commonModeArg(replacement, modeArg);
                        }
                        return replacement;
                    }
                    if (mode === 'F') {
                        autoIndex--;
                        if (modeArg === void 0) {
                            return '';
                        }
                        tmp = modeArg.split(':');
                        fn = tmp[0];
                        fnArgString = tmp[1];
                        if (!fn) {
                            return '';
                        }
                        if (fnArgString && (argMatches = fnArgString.match(/%([+-]?)([0-9]*)[a-zA-Z]/g))) {
                            for (i = 0; i < argMatches.length; i++) {
                                relative = argMatches[i][1];
                                index = argMatches[i][2];
                                if (index) {
                                    index = parseInt(index, 10);
                                    if (relative) {
                                        if (relative === '+') {
                                            index = autoIndex + index;
                                        } else if (relative === '-') {
                                            index = autoIndex - index;
                                        }
                                    }
                                } else {
                                    index = autoIndex;
                                }
                                autoIndex++;
                                if (index >= length || index < 1) {
                                    argList[i] = void 0;
                                } else {
                                    argList[i] = args[index];
                                }
                            }
                        }
                        if (!this || !this.fn || typeof this.fn[fn] !== 'function') {
                            return '';
                        }
                        return this.fn[fn].apply(this, argList);
                    }
                    return '';
                },
            );
            if (hasMarkup && this.markupReset && this.endingMarkupReset) {
                str += typeof this.markupReset === 'function' ? this.markupReset(markupStack) : this.markupReset;
            }
            if (this.extraArguments) {
                for (; autoIndex < length; autoIndex++) {
                    arg = args[autoIndex];
                    if (arg === null || arg === void 0) {
                        continue;
                    } else if (typeof arg === 'string') {
                        str += arg;
                    } else if (typeof arg === 'number') {
                        str += arg;
                    } else if (typeof arg.toString === 'function') {
                        str += arg.toString();
                    }
                }
            }
            return str;
        };
        const modes = {};
        modes.s = (arg) => {
            if (typeof arg === 'string') {
                return arg;
            }
            if (arg === null || arg === void 0 || arg === true || arg === false) {
                return '(' + arg + ')';
            }
            if (typeof arg === 'number') {
                return '' + arg;
            }
            if (typeof arg.toString === 'function') {
                return arg.toString();
            }
            return '(' + arg + ')';
        };
        modes.r = (arg) => modes.s(arg);
        modes.r.noSanitize = true;
        modes.S = (arg, modeArg, options) => {
            var interpret = (str) =>
                exports.markupMethod.call(options, options.argumentSanitizer ? options.argumentSanitizer(str) : str);
            if (typeof arg === 'string') {
                return interpret(arg);
            }
            if (arg === null || arg === void 0 || arg === true || arg === false) {
                return '(' + arg + ')';
            }
            if (typeof arg === 'number') {
                return '' + arg;
            }
            if (typeof arg.toString === 'function') {
                return interpret(arg.toString());
            }
            return interpret('(' + arg + ')');
        };
        modes.S.noSanitize = true;
        modes.S.noCommonModeArg = true;
        modes.N = (arg, isSubCall) => {
            if (typeof arg === 'string') {
                return arg;
            }
            if (arg === null || arg === void 0 || arg === true || arg === false || typeof arg === 'number') {
                return '' + arg;
            }
            if (Array.isArray(arg)) {
                arg = arg.map((e) => modes.N(e, true));
                if (isSubCall) {
                    return '[' + arg.join(',') + ']';
                }
                return arg.join(', ');
            }
            if (Buffer.isBuffer(arg)) {
                arg = [...arg].map((e) => {
                    e = e.toString(16);
                    if (e.length === 1) {
                        e = '0' + e;
                    }
                    return e;
                });
                return '<' + arg.join(' ') + '>';
            }
            var proto = Object.getPrototypeOf(arg);
            if (proto === null || proto === Object.prototype) {
                arg = Object.entries(arg)
                    .sort(naturalSort$1)
                    .map((e) => e[0] + ': ' + modes.N(e[1], true));
                if (isSubCall) {
                    return '{' + arg.join(', ') + '}';
                }
                return arg.join(', ');
            }
            if (typeof arg.inspect === 'function') {
                return arg.inspect();
            }
            if (typeof arg.toString === 'function') {
                return arg.toString();
            }
            return '(' + arg + ')';
        };
        modes.n = (arg) => modes.N(arg, true);
        modes.f = (arg, modeArg) => {
            var match,
                k,
                v,
                lv,
                n,
                step = 0,
                toFixed,
                toFixedIfDecimal,
                padding;
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                arg = 0;
            }
            if (modeArg) {
                MODE_ARG_FORMAT_REGEX.lastIndex = 0;
                while ((match = MODE_ARG_FORMAT_REGEX.exec(modeArg))) {
                    [, k, v] = match;
                    if (k === 'z') {
                        padding = +v;
                    } else if (!k) {
                        if (v[0] === '.') {
                            lv = v[v.length - 1];
                            if (lv === '!') {
                                n = parseInt(v.slice(1, -1), 10);
                                step = __pow(10, -n);
                                toFixed = n;
                            } else if (lv === '?') {
                                n = parseInt(v.slice(1, -1), 10);
                                step = __pow(10, -n);
                                toFixed = n;
                                toFixedIfDecimal = true;
                            } else {
                                n = parseInt(v.slice(1), 10);
                                step = __pow(10, -n);
                            }
                        } else if (v[v.length - 1] === '.') {
                            n = parseInt(v.slice(0, -1), 10);
                            step = __pow(10, n);
                        } else {
                            n = parseInt(v, 10);
                            step = __pow(10, Math.ceil(Math.log10(arg + Number.EPSILON) + Number.EPSILON) - n);
                        }
                    }
                }
            }
            if (step) {
                arg = round(arg, step);
            }
            if (toFixed !== void 0 && (!toFixedIfDecimal || arg !== Math.trunc(arg))) {
                arg = arg.toFixed(toFixed);
            } else {
                arg = '' + arg;
            }
            if (padding) {
                n = arg.indexOf('.');
                if (n === -1) {
                    n = arg.length;
                }
                if (arg[0] === '-') {
                    if (n - 1 < padding) {
                        arg = '-' + '0'.repeat(1 + padding - n) + arg.slice(1);
                    }
                } else if (n < padding) {
                    arg = '0'.repeat(padding - n) + arg;
                }
            }
            return arg;
        };
        modes.f.noSanitize = true;
        modes.e = (arg, modeArg) => {
            var match, k, v;
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                arg = 0;
            }
            if (modeArg) {
                MODE_ARG_FORMAT_REGEX.lastIndex = 0;
                if ((match = MODE_ARG_FORMAT_REGEX.exec(modeArg))) {
                    [, k, v] = match;
                    if (!k) {
                        return '' + arg.toExponential(parseInt(v, 10) - 1);
                    }
                }
            }
            return '' + arg.toExponential();
        };
        modes.e.noSanitize = true;
        modes.d = modes.i = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.floor(arg);
            }
            return '0';
        };
        modes.i.noSanitize = true;
        modes.u = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.max(Math.floor(arg), 0);
            }
            return '0';
        };
        modes.u.noSanitize = true;
        modes.U = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.max(Math.floor(arg), 1);
            }
            return '1';
        };
        modes.U.noSanitize = true;
        modes.k = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                return '0';
            }
            return metricPrefix(arg);
        };
        modes.k.noSanitize = true;
        modes.m = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                return '(NaN)';
            }
            var minus = '';
            if (arg < 0) {
                minus = '-';
                arg = -arg;
            }
            var degrees = epsilonFloor(arg),
                frac = arg - degrees;
            if (!frac) {
                return minus + degrees + '\xB0';
            }
            var minutes = epsilonFloor(frac * 60),
                seconds = epsilonFloor(frac * 3600 - minutes * 60);
            if (seconds) {
                return (
                    minus +
                    degrees +
                    '\xB0' +
                    ('' + minutes).padStart(2, '0') +
                    '\u2032' +
                    ('' + seconds).padStart(2, '0') +
                    '\u2033'
                );
            }
            return minus + degrees + '\xB0' + ('' + minutes).padStart(2, '0') + '\u2032';
        };
        modes.m.noSanitize = true;
        modes.t = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                return '(NaN)';
            }
            var s = Math.floor(arg / 1e3);
            if (s < 60) {
                return s + 's';
            }
            var min = Math.floor(s / 60);
            s = s % 60;
            if (min < 60) {
                return min + 'min' + ('' + s).padStart(2, '0') + 's';
            }
            var h = Math.floor(min / 60);
            min = min % 60;
            return h + 'h' + ('' + min).padStart(2, '0') + 'min' + ('' + s).padStart(2, '0') + 's';
        };
        modes.t.noSanitize = true;
        modes.h = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.max(Math.floor(arg), 0).toString(16);
            }
            return '0';
        };
        modes.h.noSanitize = true;
        modes.x = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg !== 'number') {
                return '00';
            }
            var value = '' + Math.max(Math.floor(arg), 0).toString(16);
            if (value.length % 2) {
                value = '0' + value;
            }
            return value;
        };
        modes.x.noSanitize = true;
        modes.o = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.max(Math.floor(arg), 0).toString(8);
            }
            return '0';
        };
        modes.o.noSanitize = true;
        modes.b = (arg) => {
            if (typeof arg === 'string') {
                arg = parseFloat(arg);
            }
            if (typeof arg === 'number') {
                return '' + Math.max(Math.floor(arg), 0).toString(2);
            }
            return '0';
        };
        modes.b.noSanitize = true;
        modes.X = (arg) => {
            if (typeof arg === 'string') {
                arg = Buffer.from(arg);
            } else if (!Buffer.isBuffer(arg)) {
                return '';
            }
            return arg.toString('hex');
        };
        modes.X.noSanitize = true;
        modes.z = (arg) => {
            if (typeof arg === 'string') {
                arg = Buffer.from(arg);
            } else if (!Buffer.isBuffer(arg)) {
                return '';
            }
            return arg.toString('base64');
        };
        modes.Z = (arg) => {
            if (typeof arg === 'string') {
                arg = Buffer.from(arg);
            } else if (!Buffer.isBuffer(arg)) {
                return '';
            }
            return arg
                .toString('base64')
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/[=]{1,2}$/g, '');
        };
        const I_OPTIONS = {};
        modes.I = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, I_OPTIONS);
        modes.I.noSanitize = true;
        const Y_OPTIONS = {
            noFunc: true,
            enumOnly: true,
            noDescriptor: true,
            useInspect: true,
            useInspectPropertyBlackList: true,
        };
        modes.Y = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, Y_OPTIONS);
        modes.Y.noSanitize = true;
        const O_OPTIONS = { minimal: true, noIndex: true };
        modes.O = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, O_OPTIONS);
        modes.O.noSanitize = true;
        const E_OPTIONS = {};
        modes.E = (arg, modeArg, options) => genericInspectMode(arg, modeArg, options, E_OPTIONS, true);
        modes.E.noSanitize = true;
        modes.J = (arg) => (arg === void 0 ? 'null' : JSON.stringify(arg));
        modes.D = () => '';
        modes.D.noSanitize = true;
        var defaultFormatter = {
            argumentSanitizer: (str) => escape2.control(str, true),
            extraArguments: true,
            color: false,
            noMarkup: false,
            endingMarkupReset: true,
            startingMarkupReset: false,
            markupReset: ansi.reset,
            shiftMarkup: {
                '#': 'background',
            },
            markup: {
                ':': ansi.reset,
                ' ': ansi.reset + ' ',
                '-': ansi.dim,
                '+': ansi.bold,
                _: ansi.underline,
                '/': ansi.italic,
                '!': ansi.inverse,
                b: ansi.blue,
                B: ansi.brightBlue,
                c: ansi.cyan,
                C: ansi.brightCyan,
                g: ansi.green,
                G: ansi.brightGreen,
                k: ansi.black,
                K: ansi.brightBlack,
                m: ansi.magenta,
                M: ansi.brightMagenta,
                r: ansi.red,
                R: ansi.brightRed,
                w: ansi.white,
                W: ansi.brightWhite,
                y: ansi.yellow,
                Y: ansi.brightYellow,
            },
            shiftedMarkup: {
                background: {
                    ':': ansi.reset,
                    ' ': ansi.reset + ' ',
                    b: ansi.bgBlue,
                    B: ansi.bgBrightBlue,
                    c: ansi.bgCyan,
                    C: ansi.bgBrightCyan,
                    g: ansi.bgGreen,
                    G: ansi.bgBrightGreen,
                    k: ansi.bgBlack,
                    K: ansi.bgBrightBlack,
                    m: ansi.bgMagenta,
                    M: ansi.bgBrightMagenta,
                    r: ansi.bgRed,
                    R: ansi.bgBrightRed,
                    w: ansi.bgWhite,
                    W: ansi.bgBrightWhite,
                    y: ansi.bgYellow,
                    Y: ansi.bgBrightYellow,
                },
            },
        };
        exports.createFormatter = (options) => exports.formatMethod.bind(Object.assign({}, defaultFormatter, options));
        exports.format = exports.formatMethod.bind(defaultFormatter);
        exports.format.default = defaultFormatter;
        exports.markupMethod = function (str) {
            if (typeof str !== 'string') {
                if (!str) {
                    str = '';
                } else if (typeof str.toString === 'function') {
                    str = str.toString();
                } else {
                    str = '';
                }
            }
            var hasMarkup = false,
                shift = null,
                markupStack = [];
            if (this.markupReset && this.startingMarkupReset) {
                str = (typeof this.markupReset === 'function' ? this.markupReset(markupStack) : this.markupReset) + str;
            }
            str = str.replace(/\^(.?)/g, (match, markup) => {
                var replacement;
                if (markup === '^') {
                    return '^';
                }
                if (this.shiftMarkup && this.shiftMarkup[markup]) {
                    shift = this.shiftMarkup[markup];
                    return '';
                }
                if (shift) {
                    if (!this.shiftedMarkup || !this.shiftedMarkup[shift] || !this.shiftedMarkup[shift][markup]) {
                        return '';
                    }
                    hasMarkup = true;
                    if (typeof this.shiftedMarkup[shift][markup] === 'function') {
                        replacement = this.shiftedMarkup[shift][markup](markupStack);
                    } else {
                        replacement = this.shiftedMarkup[shift][markup];
                        markupStack.push(replacement);
                    }
                    shift = null;
                } else {
                    if (!this.markup || !this.markup[markup]) {
                        return '';
                    }
                    hasMarkup = true;
                    if (typeof this.markup[markup] === 'function') {
                        replacement = this.markup[markup](markupStack);
                    } else {
                        replacement = this.markup[markup];
                        markupStack.push(replacement);
                    }
                }
                return replacement;
            });
            if (hasMarkup && this.markupReset && this.endingMarkupReset) {
                str += typeof this.markupReset === 'function' ? this.markupReset(markupStack) : this.markupReset;
            }
            return str;
        };
        exports.createMarkup = (options) => exports.markupMethod.bind(Object.assign({}, defaultFormatter, options));
        exports.markup = exports.markupMethod.bind(defaultFormatter);
        exports.format.count = function (str) {
            var match,
                index,
                relative,
                autoIndex = 1,
                maxIndex = 0;
            if (typeof str !== 'string') {
                return 0;
            }
            var regexp = /%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-EG-Z])/g;
            while ((match = regexp.exec(str)) !== null) {
                relative = match[1];
                index = match[2];
                if (index) {
                    index = parseInt(index, 10);
                    if (relative) {
                        if (relative === '+') {
                            index = autoIndex + index;
                        } else if (relative === '-') {
                            index = autoIndex - index;
                        }
                    }
                } else {
                    index = autoIndex;
                }
                autoIndex++;
                if (maxIndex < index) {
                    maxIndex = index;
                }
            }
            return maxIndex;
        };
        exports.format.hasFormatting = function (str) {
            if (str.search(/\^(.?)|(%%)|%([+-]?)([0-9]*)(?:\[([^\]]*)\])?([a-zA-Z])/) !== -1) {
                return true;
            }
            return false;
        };
        const COMMON_MODE_ARG_FORMAT_REGEX = /([a-zA-Z])(.[^a-zA-Z]*)/g;
        const MODE_ARG_FORMAT_REGEX = /([a-zA-Z]|^)(.[^a-zA-Z]*)/g;
        function commonModeArg(str, modeArg) {
            var match, k, v;
            COMMON_MODE_ARG_FORMAT_REGEX.lastIndex = 0;
            while ((match = COMMON_MODE_ARG_FORMAT_REGEX.exec(modeArg))) {
                [, k, v] = match;
                if (k === 'L') {
                    let width = unicode.width(str);
                    v = +v || 1;
                    if (width > v) {
                        str = unicode.truncateWidth(str, v - 1).trim() + '\u2026';
                        width = unicode.width(str);
                    }
                    if (width < v) {
                        str = ' '.repeat(v - width) + str;
                    }
                } else if (k === 'R') {
                    let width = unicode.width(str);
                    v = +v || 1;
                    if (width > v) {
                        str = unicode.truncateWidth(str, v - 1).trim() + '\u2026';
                        width = unicode.width(str);
                    }
                    if (width < v) {
                        str = str + ' '.repeat(v - width);
                    }
                }
            }
            return str;
        }
        function genericInspectMode(arg, modeArg, options, modeOptions, isInspectError = false) {
            var match,
                k,
                v,
                outputMaxLength,
                maxLength,
                depth = 3,
                style = options && options.color ? 'color' : 'none';
            if (modeArg) {
                MODE_ARG_FORMAT_REGEX.lastIndex = 0;
                while ((match = MODE_ARG_FORMAT_REGEX.exec(modeArg))) {
                    [, k, v] = match;
                    if (k === 'c') {
                        if (v === '+') {
                            style = 'color';
                        } else if (v === '-') {
                            style = 'none';
                        }
                    } else if (k === 'l') {
                        outputMaxLength = parseInt(v, 10) || void 0;
                    } else if (k === 's') {
                        maxLength = parseInt(v, 10) || void 0;
                    } else if (!k) {
                        depth = parseInt(v, 10) || 1;
                    }
                }
            }
            if (isInspectError) {
                return inspectError(
                    Object.assign(
                        {
                            depth,
                            style,
                            outputMaxLength,
                            maxLength,
                        },
                        modeOptions,
                    ),
                    arg,
                );
            }
            return inspect(
                Object.assign(
                    {
                        depth,
                        style,
                        outputMaxLength,
                        maxLength,
                    },
                    modeOptions,
                ),
                arg,
            );
        }
        const EPSILON = 1e-10;
        const INVERSE_EPSILON = Math.round(1 / EPSILON);
        function epsilonRound(v) {
            return Math.round(v * INVERSE_EPSILON) / INVERSE_EPSILON;
        }
        function epsilonFloor(v) {
            return Math.floor(v + EPSILON);
        }
        function round(v, step) {
            return epsilonRound(step * Math.round(v * (1 / step)));
        }
        const MUL_PREFIX = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
        const SUB_MUL_PREFIX = ['', 'm', '\xB5', 'n', 'p', 'f', 'a', 'z', 'y'];
        const IROUND_STEP = [100, 10, 1];
        function metricPrefix(n) {
            var log, logDiv3, logMod, base, prefix;
            if (!n || n === 1) {
                return '' + n;
            }
            if (n < 0) {
                return '-' + metricPrefix(-n);
            }
            if (n > 1) {
                log = Math.floor(Math.log10(n));
                logDiv3 = Math.floor(log / 3);
                logMod = log % 3;
                base = iround(n / Math.pow(1e3, logDiv3), IROUND_STEP[logMod]);
                prefix = MUL_PREFIX[logDiv3];
            } else {
                log = Math.floor(Math.log10(n));
                logDiv3 = Math.floor(log / 3);
                logMod = log % 3;
                if (logMod < 0) {
                    logMod += 3;
                }
                base = iround(n / Math.pow(1e3, logDiv3), IROUND_STEP[logMod]);
                prefix = SUB_MUL_PREFIX[-logDiv3];
            }
            return '' + base + prefix;
        }
        function iround(v, istep) {
            return Math.round((v + Number.EPSILON) * istep) / istep;
        }
    })(format);
    var misc$1 = {};
    misc$1.resize = function (str, length) {
        if (str.length === length) {
            return str;
        } else if (str.length > length) {
            return str.slice(0, length);
        }
        return str + ' '.repeat(length - str.length);
    };
    misc$1.occurrenceCount = function (str, subStr, overlap = false) {
        if (!str || !subStr) {
            return 0;
        }
        var count = 0,
            index = 0,
            inc = overlap ? 1 : subStr.length;
        while ((index = str.indexOf(subStr, index)) !== -1) {
            count++;
            index += inc;
        }
        return count;
    };
    var regexp = {};
    (function (exports) {
        var escape2 = _escape;
        exports.regexp = {};
        exports.regexp.array2alternatives = function array2alternatives(array) {
            var i,
                sorted = array.slice();
            sorted.sort((a, b) => {
                return b.length - a.length;
            });
            for (i = 0; i < sorted.length; i++) {
                sorted[i] = escape2.regExpPattern(sorted[i]);
            }
            return sorted.join('|');
        };
    })(regexp);
    var camel = {};
    var camel_1 = camel;
    camel.toCamelCase = function (str, preserveUpperCase = false) {
        if (!str || typeof str !== 'string') {
            return '';
        }
        return str.replace(
            /^[\s_-]*([^\s_-]+)|[\s_-]+([^\s_-]?)([^\s_-]*)/g,
            (match, firstWord, firstLetter, endOfWord) => {
                if (preserveUpperCase) {
                    if (firstWord) {
                        return firstWord;
                    }
                    if (!firstLetter) {
                        return '';
                    }
                    return firstLetter.toUpperCase() + endOfWord;
                }
                if (firstWord) {
                    return firstWord.toLowerCase();
                }
                if (!firstLetter) {
                    return '';
                }
                return firstLetter.toUpperCase() + endOfWord.toLowerCase();
            },
        );
    };
    camel.camelCaseToSeparated = function (str, separator = ' ') {
        if (!str || typeof str !== 'string') {
            return '';
        }
        return str.replace(/^([A-Z])|([A-Z])/g, (match, firstLetter, letter) => {
            if (firstLetter) {
                return firstLetter.toLowerCase();
            }
            return separator + letter.toLowerCase();
        });
    };
    camel.camelCaseToDash = camel.camelCaseToDashed = (str) => camel.camelCaseToSeparated(str, '-');
    const C = 'c';
    var require$$0$1 = {
        '\u07C0': '0',
        '\u0301': '',
        '\xA0': ' ',
        '\u24B6': 'A',
        '\uFF21': 'A',
        '\xC0': 'A',
        '\xC1': 'A',
        '\xC2': 'A',
        '\u1EA6': 'A',
        '\u1EA4': 'A',
        '\u1EAA': 'A',
        '\u1EA8': 'A',
        '\xC3': 'A',
        '\u0100': 'A',
        '\u0102': 'A',
        '\u1EB0': 'A',
        '\u1EAE': 'A',
        '\u1EB4': 'A',
        '\u1EB2': 'A',
        '\u0226': 'A',
        '\u01E0': 'A',
        '\xC4': 'A',
        '\u01DE': 'A',
        '\u1EA2': 'A',
        '\xC5': 'A',
        '\u01FA': 'A',
        '\u01CD': 'A',
        '\u0200': 'A',
        '\u0202': 'A',
        '\u1EA0': 'A',
        '\u1EAC': 'A',
        '\u1EB6': 'A',
        '\u1E00': 'A',
        '\u0104': 'A',
        '\u023A': 'A',
        '\u2C6F': 'A',
        '\uA732': 'AA',
        '\xC6': 'AE',
        '\u01FC': 'AE',
        '\u01E2': 'AE',
        '\uA734': 'AO',
        '\uA736': 'AU',
        '\uA738': 'AV',
        '\uA73A': 'AV',
        '\uA73C': 'AY',
        '\u24B7': 'B',
        '\uFF22': 'B',
        '\u1E02': 'B',
        '\u1E04': 'B',
        '\u1E06': 'B',
        '\u0243': 'B',
        '\u0181': 'B',
        '\uFF43': 'C',
        '\u24B8': 'C',
        '\uFF23': 'C',
        '\uA73E': 'C',
        '\u1E08': 'C',
        '\xC7': 'C',
        '\u24B9': 'D',
        '\uFF24': 'D',
        '\u1E0A': 'D',
        '\u010E': 'D',
        '\u1E0C': 'D',
        '\u1E10': 'D',
        '\u1E12': 'D',
        '\u1E0E': 'D',
        '\u0110': 'D',
        '\u018A': 'D',
        '\u0189': 'D',
        '\u1D05': 'D',
        '\uA779': 'D',
        '\xD0': 'Dh',
        '\u01F1': 'DZ',
        '\u01C4': 'DZ',
        '\u01F2': 'Dz',
        '\u01C5': 'Dz',
        '\u025B': 'E',
        '\u24BA': 'E',
        '\uFF25': 'E',
        '\xC8': 'E',
        '\xC9': 'E',
        '\xCA': 'E',
        '\u1EC0': 'E',
        '\u1EBE': 'E',
        '\u1EC4': 'E',
        '\u1EC2': 'E',
        '\u1EBC': 'E',
        '\u0112': 'E',
        '\u1E14': 'E',
        '\u1E16': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\xCB': 'E',
        '\u1EBA': 'E',
        '\u011A': 'E',
        '\u0204': 'E',
        '\u0206': 'E',
        '\u1EB8': 'E',
        '\u1EC6': 'E',
        '\u0228': 'E',
        '\u1E1C': 'E',
        '\u0118': 'E',
        '\u1E18': 'E',
        '\u1E1A': 'E',
        '\u0190': 'E',
        '\u018E': 'E',
        '\u1D07': 'E',
        '\uA77C': 'F',
        '\u24BB': 'F',
        '\uFF26': 'F',
        '\u1E1E': 'F',
        '\u0191': 'F',
        '\uA77B': 'F',
        '\u24BC': 'G',
        '\uFF27': 'G',
        '\u01F4': 'G',
        '\u011C': 'G',
        '\u1E20': 'G',
        '\u011E': 'G',
        '\u0120': 'G',
        '\u01E6': 'G',
        '\u0122': 'G',
        '\u01E4': 'G',
        '\u0193': 'G',
        '\uA7A0': 'G',
        '\uA77D': 'G',
        '\uA77E': 'G',
        '\u0262': 'G',
        '\u24BD': 'H',
        '\uFF28': 'H',
        '\u0124': 'H',
        '\u1E22': 'H',
        '\u1E26': 'H',
        '\u021E': 'H',
        '\u1E24': 'H',
        '\u1E28': 'H',
        '\u1E2A': 'H',
        '\u0126': 'H',
        '\u2C67': 'H',
        '\u2C75': 'H',
        '\uA78D': 'H',
        '\u24BE': 'I',
        '\uFF29': 'I',
        '\xCC': 'I',
        '\xCD': 'I',
        '\xCE': 'I',
        '\u0128': 'I',
        '\u012A': 'I',
        '\u012C': 'I',
        '\u0130': 'I',
        '\xCF': 'I',
        '\u1E2E': 'I',
        '\u1EC8': 'I',
        '\u01CF': 'I',
        '\u0208': 'I',
        '\u020A': 'I',
        '\u1ECA': 'I',
        '\u012E': 'I',
        '\u1E2C': 'I',
        '\u0197': 'I',
        '\u24BF': 'J',
        '\uFF2A': 'J',
        '\u0134': 'J',
        '\u0248': 'J',
        '\u0237': 'J',
        '\u24C0': 'K',
        '\uFF2B': 'K',
        '\u1E30': 'K',
        '\u01E8': 'K',
        '\u1E32': 'K',
        '\u0136': 'K',
        '\u1E34': 'K',
        '\u0198': 'K',
        '\u2C69': 'K',
        '\uA740': 'K',
        '\uA742': 'K',
        '\uA744': 'K',
        '\uA7A2': 'K',
        '\u24C1': 'L',
        '\uFF2C': 'L',
        '\u013F': 'L',
        '\u0139': 'L',
        '\u013D': 'L',
        '\u1E36': 'L',
        '\u1E38': 'L',
        '\u013B': 'L',
        '\u1E3C': 'L',
        '\u1E3A': 'L',
        '\u0141': 'L',
        '\u023D': 'L',
        '\u2C62': 'L',
        '\u2C60': 'L',
        '\uA748': 'L',
        '\uA746': 'L',
        '\uA780': 'L',
        '\u01C7': 'LJ',
        '\u01C8': 'Lj',
        '\u24C2': 'M',
        '\uFF2D': 'M',
        '\u1E3E': 'M',
        '\u1E40': 'M',
        '\u1E42': 'M',
        '\u2C6E': 'M',
        '\u019C': 'M',
        '\u03FB': 'M',
        '\uA7A4': 'N',
        '\u0220': 'N',
        '\u24C3': 'N',
        '\uFF2E': 'N',
        '\u01F8': 'N',
        '\u0143': 'N',
        '\xD1': 'N',
        '\u1E44': 'N',
        '\u0147': 'N',
        '\u1E46': 'N',
        '\u0145': 'N',
        '\u1E4A': 'N',
        '\u1E48': 'N',
        '\u019D': 'N',
        '\uA790': 'N',
        '\u1D0E': 'N',
        '\u01CA': 'NJ',
        '\u01CB': 'Nj',
        '\u24C4': 'O',
        '\uFF2F': 'O',
        '\xD2': 'O',
        '\xD3': 'O',
        '\xD4': 'O',
        '\u1ED2': 'O',
        '\u1ED0': 'O',
        '\u1ED6': 'O',
        '\u1ED4': 'O',
        '\xD5': 'O',
        '\u1E4C': 'O',
        '\u022C': 'O',
        '\u1E4E': 'O',
        '\u014C': 'O',
        '\u1E50': 'O',
        '\u1E52': 'O',
        '\u014E': 'O',
        '\u022E': 'O',
        '\u0230': 'O',
        '\xD6': 'O',
        '\u022A': 'O',
        '\u1ECE': 'O',
        '\u0150': 'O',
        '\u01D1': 'O',
        '\u020C': 'O',
        '\u020E': 'O',
        '\u01A0': 'O',
        '\u1EDC': 'O',
        '\u1EDA': 'O',
        '\u1EE0': 'O',
        '\u1EDE': 'O',
        '\u1EE2': 'O',
        '\u1ECC': 'O',
        '\u1ED8': 'O',
        '\u01EA': 'O',
        '\u01EC': 'O',
        '\xD8': 'O',
        '\u01FE': 'O',
        '\u0186': 'O',
        '\u019F': 'O',
        '\uA74A': 'O',
        '\uA74C': 'O',
        '\u0152': 'OE',
        '\u01A2': 'OI',
        '\uA74E': 'OO',
        '\u0222': 'OU',
        '\u24C5': 'P',
        '\uFF30': 'P',
        '\u1E54': 'P',
        '\u1E56': 'P',
        '\u01A4': 'P',
        '\u2C63': 'P',
        '\uA750': 'P',
        '\uA752': 'P',
        '\uA754': 'P',
        '\u24C6': 'Q',
        '\uFF31': 'Q',
        '\uA756': 'Q',
        '\uA758': 'Q',
        '\u024A': 'Q',
        '\u24C7': 'R',
        '\uFF32': 'R',
        '\u0154': 'R',
        '\u1E58': 'R',
        '\u0158': 'R',
        '\u0210': 'R',
        '\u0212': 'R',
        '\u1E5A': 'R',
        '\u1E5C': 'R',
        '\u0156': 'R',
        '\u1E5E': 'R',
        '\u024C': 'R',
        '\u2C64': 'R',
        '\uA75A': 'R',
        '\uA7A6': 'R',
        '\uA782': 'R',
        '\u24C8': 'S',
        '\uFF33': 'S',
        '\u1E9E': 'S',
        '\u015A': 'S',
        '\u1E64': 'S',
        '\u015C': 'S',
        '\u1E60': 'S',
        '\u0160': 'S',
        '\u1E66': 'S',
        '\u1E62': 'S',
        '\u1E68': 'S',
        '\u0218': 'S',
        '\u015E': 'S',
        '\u2C7E': 'S',
        '\uA7A8': 'S',
        '\uA784': 'S',
        '\u24C9': 'T',
        '\uFF34': 'T',
        '\u1E6A': 'T',
        '\u0164': 'T',
        '\u1E6C': 'T',
        '\u021A': 'T',
        '\u0162': 'T',
        '\u1E70': 'T',
        '\u1E6E': 'T',
        '\u0166': 'T',
        '\u01AC': 'T',
        '\u01AE': 'T',
        '\u023E': 'T',
        '\uA786': 'T',
        '\xDE': 'Th',
        '\uA728': 'TZ',
        '\u24CA': 'U',
        '\uFF35': 'U',
        '\xD9': 'U',
        '\xDA': 'U',
        '\xDB': 'U',
        '\u0168': 'U',
        '\u1E78': 'U',
        '\u016A': 'U',
        '\u1E7A': 'U',
        '\u016C': 'U',
        '\xDC': 'U',
        '\u01DB': 'U',
        '\u01D7': 'U',
        '\u01D5': 'U',
        '\u01D9': 'U',
        '\u1EE6': 'U',
        '\u016E': 'U',
        '\u0170': 'U',
        '\u01D3': 'U',
        '\u0214': 'U',
        '\u0216': 'U',
        '\u01AF': 'U',
        '\u1EEA': 'U',
        '\u1EE8': 'U',
        '\u1EEE': 'U',
        '\u1EEC': 'U',
        '\u1EF0': 'U',
        '\u1EE4': 'U',
        '\u1E72': 'U',
        '\u0172': 'U',
        '\u1E76': 'U',
        '\u1E74': 'U',
        '\u0244': 'U',
        '\u24CB': 'V',
        '\uFF36': 'V',
        '\u1E7C': 'V',
        '\u1E7E': 'V',
        '\u01B2': 'V',
        '\uA75E': 'V',
        '\u0245': 'V',
        '\uA760': 'VY',
        '\u24CC': 'W',
        '\uFF37': 'W',
        '\u1E80': 'W',
        '\u1E82': 'W',
        '\u0174': 'W',
        '\u1E86': 'W',
        '\u1E84': 'W',
        '\u1E88': 'W',
        '\u2C72': 'W',
        '\u24CD': 'X',
        '\uFF38': 'X',
        '\u1E8A': 'X',
        '\u1E8C': 'X',
        '\u24CE': 'Y',
        '\uFF39': 'Y',
        '\u1EF2': 'Y',
        '\xDD': 'Y',
        '\u0176': 'Y',
        '\u1EF8': 'Y',
        '\u0232': 'Y',
        '\u1E8E': 'Y',
        '\u0178': 'Y',
        '\u1EF6': 'Y',
        '\u1EF4': 'Y',
        '\u01B3': 'Y',
        '\u024E': 'Y',
        '\u1EFE': 'Y',
        '\u24CF': 'Z',
        '\uFF3A': 'Z',
        '\u0179': 'Z',
        '\u1E90': 'Z',
        '\u017B': 'Z',
        '\u017D': 'Z',
        '\u1E92': 'Z',
        '\u1E94': 'Z',
        '\u01B5': 'Z',
        '\u0224': 'Z',
        '\u2C7F': 'Z',
        '\u2C6B': 'Z',
        '\uA762': 'Z',
        '\u24D0': 'a',
        '\uFF41': 'a',
        '\u1E9A': 'a',
        '\xE0': 'a',
        '\xE1': 'a',
        '\xE2': 'a',
        '\u1EA7': 'a',
        '\u1EA5': 'a',
        '\u1EAB': 'a',
        '\u1EA9': 'a',
        '\xE3': 'a',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u1EB1': 'a',
        '\u1EAF': 'a',
        '\u1EB5': 'a',
        '\u1EB3': 'a',
        '\u0227': 'a',
        '\u01E1': 'a',
        '\xE4': 'a',
        '\u01DF': 'a',
        '\u1EA3': 'a',
        '\xE5': 'a',
        '\u01FB': 'a',
        '\u01CE': 'a',
        '\u0201': 'a',
        '\u0203': 'a',
        '\u1EA1': 'a',
        '\u1EAD': 'a',
        '\u1EB7': 'a',
        '\u1E01': 'a',
        '\u0105': 'a',
        '\u2C65': 'a',
        '\u0250': 'a',
        '\u0251': 'a',
        '\uA733': 'aa',
        '\xE6': 'ae',
        '\u01FD': 'ae',
        '\u01E3': 'ae',
        '\uA735': 'ao',
        '\uA737': 'au',
        '\uA739': 'av',
        '\uA73B': 'av',
        '\uA73D': 'ay',
        '\u24D1': 'b',
        '\uFF42': 'b',
        '\u1E03': 'b',
        '\u1E05': 'b',
        '\u1E07': 'b',
        '\u0180': 'b',
        '\u0183': 'b',
        '\u0253': 'b',
        '\u0182': 'b',
        '\u24D2': 'c',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010B': 'c',
        '\u010D': 'c',
        '\xE7': 'c',
        '\u1E09': 'c',
        '\u0188': 'c',
        '\u023C': 'c',
        '\uA73F': 'c',
        '\u2184': 'c',
        C,
        '\u0106': 'c',
        '\u0108': 'c',
        '\u010A': 'c',
        '\u010C': 'c',
        '\u0187': 'c',
        '\u023B': 'c',
        '\u24D3': 'd',
        '\uFF44': 'd',
        '\u1E0B': 'd',
        '\u010F': 'd',
        '\u1E0D': 'd',
        '\u1E11': 'd',
        '\u1E13': 'd',
        '\u1E0F': 'd',
        '\u0111': 'd',
        '\u018C': 'd',
        '\u0256': 'd',
        '\u0257': 'd',
        '\u018B': 'd',
        '\u13E7': 'd',
        '\u0501': 'd',
        '\uA7AA': 'd',
        '\xF0': 'dh',
        '\u01F3': 'dz',
        '\u01C6': 'dz',
        '\u24D4': 'e',
        '\uFF45': 'e',
        '\xE8': 'e',
        '\xE9': 'e',
        '\xEA': 'e',
        '\u1EC1': 'e',
        '\u1EBF': 'e',
        '\u1EC5': 'e',
        '\u1EC3': 'e',
        '\u1EBD': 'e',
        '\u0113': 'e',
        '\u1E15': 'e',
        '\u1E17': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\xEB': 'e',
        '\u1EBB': 'e',
        '\u011B': 'e',
        '\u0205': 'e',
        '\u0207': 'e',
        '\u1EB9': 'e',
        '\u1EC7': 'e',
        '\u0229': 'e',
        '\u1E1D': 'e',
        '\u0119': 'e',
        '\u1E19': 'e',
        '\u1E1B': 'e',
        '\u0247': 'e',
        '\u01DD': 'e',
        '\u24D5': 'f',
        '\uFF46': 'f',
        '\u1E1F': 'f',
        '\u0192': 'f',
        '\uFB00': 'ff',
        '\uFB01': 'fi',
        '\uFB02': 'fl',
        '\uFB03': 'ffi',
        '\uFB04': 'ffl',
        '\u24D6': 'g',
        '\uFF47': 'g',
        '\u01F5': 'g',
        '\u011D': 'g',
        '\u1E21': 'g',
        '\u011F': 'g',
        '\u0121': 'g',
        '\u01E7': 'g',
        '\u0123': 'g',
        '\u01E5': 'g',
        '\u0260': 'g',
        '\uA7A1': 'g',
        '\uA77F': 'g',
        '\u1D79': 'g',
        '\u24D7': 'h',
        '\uFF48': 'h',
        '\u0125': 'h',
        '\u1E23': 'h',
        '\u1E27': 'h',
        '\u021F': 'h',
        '\u1E25': 'h',
        '\u1E29': 'h',
        '\u1E2B': 'h',
        '\u1E96': 'h',
        '\u0127': 'h',
        '\u2C68': 'h',
        '\u2C76': 'h',
        '\u0265': 'h',
        '\u0195': 'hv',
        '\u24D8': 'i',
        '\uFF49': 'i',
        '\xEC': 'i',
        '\xED': 'i',
        '\xEE': 'i',
        '\u0129': 'i',
        '\u012B': 'i',
        '\u012D': 'i',
        '\xEF': 'i',
        '\u1E2F': 'i',
        '\u1EC9': 'i',
        '\u01D0': 'i',
        '\u0209': 'i',
        '\u020B': 'i',
        '\u1ECB': 'i',
        '\u012F': 'i',
        '\u1E2D': 'i',
        '\u0268': 'i',
        '\u0131': 'i',
        '\u24D9': 'j',
        '\uFF4A': 'j',
        '\u0135': 'j',
        '\u01F0': 'j',
        '\u0249': 'j',
        '\u24DA': 'k',
        '\uFF4B': 'k',
        '\u1E31': 'k',
        '\u01E9': 'k',
        '\u1E33': 'k',
        '\u0137': 'k',
        '\u1E35': 'k',
        '\u0199': 'k',
        '\u2C6A': 'k',
        '\uA741': 'k',
        '\uA743': 'k',
        '\uA745': 'k',
        '\uA7A3': 'k',
        '\u24DB': 'l',
        '\uFF4C': 'l',
        '\u0140': 'l',
        '\u013A': 'l',
        '\u013E': 'l',
        '\u1E37': 'l',
        '\u1E39': 'l',
        '\u013C': 'l',
        '\u1E3D': 'l',
        '\u1E3B': 'l',
        '\u017F': 'l',
        '\u0142': 'l',
        '\u019A': 'l',
        '\u026B': 'l',
        '\u2C61': 'l',
        '\uA749': 'l',
        '\uA781': 'l',
        '\uA747': 'l',
        '\u026D': 'l',
        '\u01C9': 'lj',
        '\u24DC': 'm',
        '\uFF4D': 'm',
        '\u1E3F': 'm',
        '\u1E41': 'm',
        '\u1E43': 'm',
        '\u0271': 'm',
        '\u026F': 'm',
        '\u24DD': 'n',
        '\uFF4E': 'n',
        '\u01F9': 'n',
        '\u0144': 'n',
        '\xF1': 'n',
        '\u1E45': 'n',
        '\u0148': 'n',
        '\u1E47': 'n',
        '\u0146': 'n',
        '\u1E4B': 'n',
        '\u1E49': 'n',
        '\u019E': 'n',
        '\u0272': 'n',
        '\u0149': 'n',
        '\uA791': 'n',
        '\uA7A5': 'n',
        '\u0509': 'n',
        '\u01CC': 'nj',
        '\u24DE': 'o',
        '\uFF4F': 'o',
        '\xF2': 'o',
        '\xF3': 'o',
        '\xF4': 'o',
        '\u1ED3': 'o',
        '\u1ED1': 'o',
        '\u1ED7': 'o',
        '\u1ED5': 'o',
        '\xF5': 'o',
        '\u1E4D': 'o',
        '\u022D': 'o',
        '\u1E4F': 'o',
        '\u014D': 'o',
        '\u1E51': 'o',
        '\u1E53': 'o',
        '\u014F': 'o',
        '\u022F': 'o',
        '\u0231': 'o',
        '\xF6': 'o',
        '\u022B': 'o',
        '\u1ECF': 'o',
        '\u0151': 'o',
        '\u01D2': 'o',
        '\u020D': 'o',
        '\u020F': 'o',
        '\u01A1': 'o',
        '\u1EDD': 'o',
        '\u1EDB': 'o',
        '\u1EE1': 'o',
        '\u1EDF': 'o',
        '\u1EE3': 'o',
        '\u1ECD': 'o',
        '\u1ED9': 'o',
        '\u01EB': 'o',
        '\u01ED': 'o',
        '\xF8': 'o',
        '\u01FF': 'o',
        '\uA74B': 'o',
        '\uA74D': 'o',
        '\u0275': 'o',
        '\u0254': 'o',
        '\u1D11': 'o',
        '\u0153': 'oe',
        '\u01A3': 'oi',
        '\uA74F': 'oo',
        '\u0223': 'ou',
        '\u24DF': 'p',
        '\uFF50': 'p',
        '\u1E55': 'p',
        '\u1E57': 'p',
        '\u01A5': 'p',
        '\u1D7D': 'p',
        '\uA751': 'p',
        '\uA753': 'p',
        '\uA755': 'p',
        '\u03C1': 'p',
        '\u24E0': 'q',
        '\uFF51': 'q',
        '\u024B': 'q',
        '\uA757': 'q',
        '\uA759': 'q',
        '\u24E1': 'r',
        '\uFF52': 'r',
        '\u0155': 'r',
        '\u1E59': 'r',
        '\u0159': 'r',
        '\u0211': 'r',
        '\u0213': 'r',
        '\u1E5B': 'r',
        '\u1E5D': 'r',
        '\u0157': 'r',
        '\u1E5F': 'r',
        '\u024D': 'r',
        '\u027D': 'r',
        '\uA75B': 'r',
        '\uA7A7': 'r',
        '\uA783': 'r',
        '\u24E2': 's',
        '\uFF53': 's',
        '\u015B': 's',
        '\u1E65': 's',
        '\u015D': 's',
        '\u1E61': 's',
        '\u0161': 's',
        '\u1E67': 's',
        '\u1E63': 's',
        '\u1E69': 's',
        '\u0219': 's',
        '\u015F': 's',
        '\u023F': 's',
        '\uA7A9': 's',
        '\uA785': 's',
        '\u1E9B': 's',
        '\u0282': 's',
        '\xDF': 'ss',
        '\u24E3': 't',
        '\uFF54': 't',
        '\u1E6B': 't',
        '\u1E97': 't',
        '\u0165': 't',
        '\u1E6D': 't',
        '\u021B': 't',
        '\u0163': 't',
        '\u1E71': 't',
        '\u1E6F': 't',
        '\u0167': 't',
        '\u01AD': 't',
        '\u0288': 't',
        '\u2C66': 't',
        '\uA787': 't',
        '\xFE': 'th',
        '\uA729': 'tz',
        '\u24E4': 'u',
        '\uFF55': 'u',
        '\xF9': 'u',
        '\xFA': 'u',
        '\xFB': 'u',
        '\u0169': 'u',
        '\u1E79': 'u',
        '\u016B': 'u',
        '\u1E7B': 'u',
        '\u016D': 'u',
        '\xFC': 'u',
        '\u01DC': 'u',
        '\u01D8': 'u',
        '\u01D6': 'u',
        '\u01DA': 'u',
        '\u1EE7': 'u',
        '\u016F': 'u',
        '\u0171': 'u',
        '\u01D4': 'u',
        '\u0215': 'u',
        '\u0217': 'u',
        '\u01B0': 'u',
        '\u1EEB': 'u',
        '\u1EE9': 'u',
        '\u1EEF': 'u',
        '\u1EED': 'u',
        '\u1EF1': 'u',
        '\u1EE5': 'u',
        '\u1E73': 'u',
        '\u0173': 'u',
        '\u1E77': 'u',
        '\u1E75': 'u',
        '\u0289': 'u',
        '\u24E5': 'v',
        '\uFF56': 'v',
        '\u1E7D': 'v',
        '\u1E7F': 'v',
        '\u028B': 'v',
        '\uA75F': 'v',
        '\u028C': 'v',
        '\uA761': 'vy',
        '\u24E6': 'w',
        '\uFF57': 'w',
        '\u1E81': 'w',
        '\u1E83': 'w',
        '\u0175': 'w',
        '\u1E87': 'w',
        '\u1E85': 'w',
        '\u1E98': 'w',
        '\u1E89': 'w',
        '\u2C73': 'w',
        '\u24E7': 'x',
        '\uFF58': 'x',
        '\u1E8B': 'x',
        '\u1E8D': 'x',
        '\u24E8': 'y',
        '\uFF59': 'y',
        '\u1EF3': 'y',
        '\xFD': 'y',
        '\u0177': 'y',
        '\u1EF9': 'y',
        '\u0233': 'y',
        '\u1E8F': 'y',
        '\xFF': 'y',
        '\u1EF7': 'y',
        '\u1E99': 'y',
        '\u1EF5': 'y',
        '\u01B4': 'y',
        '\u024F': 'y',
        '\u1EFF': 'y',
        '\u24E9': 'z',
        '\uFF5A': 'z',
        '\u017A': 'z',
        '\u1E91': 'z',
        '\u017C': 'z',
        '\u017E': 'z',
        '\u1E93': 'z',
        '\u1E95': 'z',
        '\u01B6': 'z',
        '\u0225': 'z',
        '\u0240': 'z',
        '\u2C6C': 'z',
        '\uA763': 'z',
    };
    var map = require$$0$1;
    var latinize = function (str) {
        return str.replace(/[^\u0000-\u007e]/g, (c) => {
            return map[c] || c;
        });
    };
    var toTitleCase = function toTitleCase(str, options) {
        if (!str || typeof str !== 'string') {
            return '';
        }
        options = options || {};
        return str.replace(/[^\s_-]+/g, (part) => {
            if (options.zealous) {
                if (options.preserveAllCaps && part === part.toUpperCase()) {
                    return part;
                }
                return part[0].toUpperCase() + part.slice(1).toLowerCase();
            }
            return part[0].toUpperCase() + part.slice(1);
        });
    };
    const unicode = unicode_1;
    const FRENCH_DOUBLE_GRAPH_TYPO = {
        '!': true,
        '?': true,
        ':': true,
        ';': true,
    };
    var wordwrap = function wordwrap(str, options) {
        var start = 0,
            end,
            skipEnd,
            lineWidth,
            currentLine,
            currentWidth,
            length,
            lastEnd,
            lastWidth,
            lastWasSpace,
            charWidthFn,
            explicitNewLine = true,
            strArray = unicode.toArray(str),
            trimNewLine = false,
            line,
            lines = [];
        if (typeof options !== 'object') {
            options = { width: options };
        }
        if (!options.width || typeof options.width !== 'number' || options.width <= 0) {
            options.width = 80;
        }
        lineWidth = options.offset ? options.width - options.offset : options.width;
        if (typeof options.glue !== 'string') {
            options.glue = '\n';
        }
        if (options.regroupFn) {
            strArray = options.regroupFn(strArray);
            charWidthFn = options.charWidthFn || unicode.width;
        } else {
            charWidthFn = options.charWidthFn || unicode.charWidth;
        }
        length = strArray.length;
        var getNextLine = () => {
            if (!explicitNewLine || trimNewLine) {
                while (strArray[start] === ' ') {
                    start++;
                }
                if (trimNewLine && strArray[start] === '\n') {
                    explicitNewLine = true;
                    start++;
                }
            }
            if (start >= length) {
                return null;
            }
            explicitNewLine = false;
            trimNewLine = false;
            lastWasSpace = false;
            end = lastEnd = start;
            currentWidth = lastWidth = 0;
            for (;;) {
                if (end >= length) {
                    return strArray.slice(start, end).join('');
                }
                if (strArray[end] === '\n') {
                    explicitNewLine = true;
                    currentLine = strArray.slice(start, end++).join('');
                    if (options.fill) {
                        currentLine += ' '.repeat(lineWidth - currentWidth);
                    }
                    return currentLine;
                }
                if (options.skipFn) {
                    skipEnd = options.skipFn(strArray, end);
                    if (skipEnd !== end) {
                        end = skipEnd;
                        continue;
                    }
                }
                if (strArray[end] === ' ' && !lastWasSpace && !FRENCH_DOUBLE_GRAPH_TYPO[strArray[end + 1]]) {
                    lastEnd = end;
                    lastWidth = currentWidth;
                } else {
                    lastWasSpace = false;
                }
                currentWidth += charWidthFn(strArray[end]);
                if (currentWidth > lineWidth) {
                    trimNewLine = true;
                    if (lastEnd !== start) {
                        end = lastEnd;
                    } else if (lineWidth < options.width) {
                        end = start;
                        return '';
                    }
                    currentLine = strArray.slice(start, end).join('');
                    if (options.fill) {
                        currentLine += ' '.repeat(lineWidth - lastWidth);
                    }
                    return currentLine;
                }
                end++;
            }
        };
        while (start < length && (line = getNextLine()) !== null) {
            lines.push(line);
            start = end;
            lineWidth = options.width;
        }
        if (explicitNewLine) {
            lines.push('');
        }
        if (!options.noTrim && !options.fill) {
            lines = lines.map((line_, index) => (index === lines.length - 1 ? line_ : line_.trimRight()));
        }
        if (!options.noJoin) {
            lines = lines.join(options.glue);
        }
        if (options.updateOffset) {
            options.offset = currentWidth;
        }
        return lines;
    };
    const fuzzy = {};
    var fuzzy_1 = fuzzy;
    fuzzy.score = (input, pattern) => {
        if (input === pattern) {
            return 1;
        }
        if (input.length === 0 || pattern.length === 0) {
            return 0;
        }
        return Math.max(0, 1 - fuzzy.levenshtein(input, pattern) / pattern.length);
    };
    const DEFAULT_SCORE_LIMIT = 0;
    const DEFAULT_TOKEN_DISPARITY_PENALTY = 0.88;
    const DEFAULT_DELTA_RATE = 0.9;
    fuzzy.bestMatch = (input, patterns, options = {}) => {
        var bestScore = options.scoreLimit || DEFAULT_SCORE_LIMIT,
            i,
            iMax,
            currentScore,
            currentPattern,
            bestIndex = -1,
            bestPattern = null;
        for (i = 0, iMax = patterns.length; i < iMax; i++) {
            currentPattern = patterns[i];
            currentScore = fuzzy.score(input, currentPattern);
            if (currentScore === 1) {
                return options.indexOf ? i : currentPattern;
            }
            if (currentScore > bestScore) {
                bestScore = currentScore;
                bestPattern = currentPattern;
                bestIndex = i;
            }
        }
        return options.indexOf ? bestIndex : bestPattern;
    };
    fuzzy.topMatch = (input, patterns, options = {}) => {
        var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT,
            deltaRate = options.deltaRate || DEFAULT_DELTA_RATE,
            i,
            iMax,
            patternScores;
        patternScores = patterns.map((pattern, index) => ({ pattern, index, score: fuzzy.score(input, pattern) }));
        patternScores.sort((a, b) => b.score - a.score);
        if (patternScores[0].score <= scoreLimit) {
            return [];
        }
        scoreLimit = Math.max(scoreLimit, patternScores[0].score * deltaRate);
        for (i = 1, iMax = patternScores.length; i < iMax; i++) {
            if (patternScores[i].score < scoreLimit) {
                patternScores.length = i;
                break;
            }
        }
        return options.indexOf ? patternScores.map((e) => e.index) : patternScores.map((e) => e.pattern);
    };
    const englishBlackList = new Set([
        'a',
        'an',
        'the',
        'this',
        'that',
        'those',
        'some',
        'of',
        'in',
        'on',
        'at',
        'my',
        'your',
        'her',
        'his',
        'its',
        'our',
        'their',
    ]);
    function tokenize(str, blackList = englishBlackList) {
        return str.split(/[ '"/|,:_-]+/g).filter((s) => s && !blackList.has(s));
    }
    fuzzy.bestTokenMatch = (input, patterns, options = {}) => {
        var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT,
            tokenDisparityPenalty = options.tokenDisparityPenalty || DEFAULT_TOKEN_DISPARITY_PENALTY,
            i,
            iMax,
            j,
            jMax,
            z,
            zMax,
            currentPattern,
            currentPatternTokens,
            currentPatternToken,
            currentPatternScore,
            bestPatternScore = scoreLimit,
            currentInputToken,
            currentScore,
            inputTokens = tokenize(input),
            bestScore,
            bestIndex = -1,
            bestPattern = null;
        if (!inputTokens.length || !patterns.length) {
            return options.indexOf ? bestIndex : bestPattern;
        }
        for (i = 0, iMax = patterns.length; i < iMax; i++) {
            currentPattern = patterns[i];
            currentPatternTokens = tokenize(currentPattern);
            currentPatternScore = 0;
            for (j = 0, jMax = inputTokens.length; j < jMax; j++) {
                currentInputToken = inputTokens[j];
                bestScore = 0;
                for (z = 0, zMax = currentPatternTokens.length; z < zMax; z++) {
                    currentPatternToken = currentPatternTokens[z];
                    currentScore = fuzzy.score(currentInputToken, currentPatternToken);
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        if (currentScore === 1) {
                            break;
                        }
                    }
                }
                currentPatternScore += bestScore;
            }
            currentPatternScore /= inputTokens.length;
            if (inputTokens.length !== currentPatternTokens.length) {
                currentPatternScore *= __pow(
                    tokenDisparityPenalty,
                    Math.abs(currentPatternTokens.length - inputTokens.length),
                );
            }
            if (currentPatternScore > bestPatternScore) {
                bestPatternScore = currentPatternScore;
                bestPattern = currentPattern;
                bestIndex = i;
            }
        }
        return options.indexOf ? bestIndex : bestPattern;
    };
    fuzzy.topTokenMatch = (input, patterns, options = {}) => {
        var scoreLimit = options.scoreLimit || DEFAULT_SCORE_LIMIT,
            tokenDisparityPenalty = options.tokenDisparityPenalty || DEFAULT_TOKEN_DISPARITY_PENALTY,
            deltaRate = options.deltaRate || DEFAULT_DELTA_RATE,
            i,
            iMax,
            j,
            jMax,
            z,
            zMax,
            currentPattern,
            currentPatternTokens,
            currentPatternToken,
            currentPatternScore,
            currentInputToken,
            currentScore,
            inputTokens = tokenize(input),
            bestScore,
            patternScores = [];
        if (!inputTokens.length || !patterns.length) {
            return [];
        }
        for (i = 0, iMax = patterns.length; i < iMax; i++) {
            currentPattern = patterns[i];
            currentPatternTokens = tokenize(currentPattern);
            currentPatternScore = 0;
            for (j = 0, jMax = inputTokens.length; j < jMax; j++) {
                currentInputToken = inputTokens[j];
                bestScore = 0;
                for (z = 0, zMax = currentPatternTokens.length; z < zMax; z++) {
                    currentPatternToken = currentPatternTokens[z];
                    currentScore = fuzzy.score(currentInputToken, currentPatternToken);
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        if (currentScore === 1) {
                            break;
                        }
                    }
                }
                currentPatternScore += bestScore;
            }
            currentPatternScore /= inputTokens.length;
            if (inputTokens.length !== currentPatternTokens.length) {
                currentPatternScore *= __pow(
                    tokenDisparityPenalty,
                    Math.abs(currentPatternTokens.length - inputTokens.length),
                );
            }
            patternScores.push({ pattern: currentPattern, index: i, score: currentPatternScore });
        }
        patternScores.sort((a, b) => b.score - a.score);
        if (patternScores[0].score <= scoreLimit) {
            return [];
        }
        scoreLimit = Math.max(scoreLimit, patternScores[0].score * deltaRate);
        for (i = 1, iMax = patternScores.length; i < iMax; i++) {
            if (patternScores[i].score < scoreLimit) {
                patternScores.length = i;
                break;
            }
        }
        return options.indexOf ? patternScores.map((e) => e.index) : patternScores.map((e) => e.pattern);
    };
    const _tracker = [];
    const _leftCharCodeCache = [];
    fuzzy.levenshtein = (left, right) => {
        if (left === right) {
            return 0;
        }
        if (left.length > right.length) {
            let swap = left;
            left = right;
            right = swap;
        }
        let leftLength = left.length;
        let rightLength = right.length;
        while (leftLength > 0 && left.charCodeAt(leftLength - 1) === right.charCodeAt(rightLength - 1)) {
            leftLength--;
            rightLength--;
        }
        let start = 0;
        while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
            start++;
        }
        leftLength -= start;
        rightLength -= start;
        if (leftLength === 0) {
            return rightLength;
        }
        let rightCharCode;
        let result;
        let temp;
        let temp2;
        let i = 0;
        let j = 0;
        while (i < leftLength) {
            _leftCharCodeCache[i] = left.charCodeAt(start + i);
            _tracker[i] = ++i;
        }
        while (j < rightLength) {
            rightCharCode = right.charCodeAt(start + j);
            temp = j++;
            result = j;
            for (i = 0; i < leftLength; i++) {
                temp2 = rightCharCode === _leftCharCodeCache[i] ? temp : temp + 1;
                temp = _tracker[i];
                result = _tracker[i] =
                    temp > result ? (temp2 > result ? result + 1 : temp2) : temp2 > temp ? temp + 1 : temp2;
            }
        }
        return result;
    };
    var stringKit = {};
    var string$4 = stringKit;
    var fn_;
    var polyfill = polyfill_1;
    for (fn_ in polyfill) {
        stringKit[fn_] = function (str, ...args) {
            return polyfill[fn_].call(str, ...args);
        };
    }
    Object.assign(stringKit, { escape: _escape }, { ansi: ansi$1 }, { unicode: unicode_1 });
    Object.assign(stringKit, format, misc$1, inspect$1, regexp, camel_1, {
        latinize,
        toTitleCase,
        wordwrap,
        naturalSort,
        fuzzy: fuzzy_1,
    });
    stringKit.installPolyfills = function installPolyfills() {
        var fn;
        for (fn in polyfill) {
            if (!String.prototype[fn]) {
                String.prototype[fn] = polyfill[fn];
            }
        }
    };
    const string$3 = string$4;
    const misc = {};
    var misc_1 = misc;
    const colorNameToIndexDict = {
        black: 0,
        red: 1,
        green: 2,
        yellow: 3,
        blue: 4,
        magenta: 5,
        violet: 5,
        cyan: 6,
        white: 7,
        grey: 8,
        gray: 8,
        brightblack: 8,
        brightred: 9,
        brightgreen: 10,
        brightyellow: 11,
        brightblue: 12,
        brightmagenta: 13,
        brightviolet: 13,
        brightcyan: 14,
        brightwhite: 15,
    };
    misc.colorNameToIndex = (color) => colorNameToIndexDict[color.toLowerCase()];
    const indexToColorNameArray = [
        'black',
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
        'gray',
        'brightRed',
        'brightGreen',
        'brightYellow',
        'brightBlue',
        'brightMagenta',
        'brightCyan',
        'brightWhite',
    ];
    misc.indexToColorName = (index) => indexToColorNameArray[index];
    misc.hexToRgba = (hex) => {
        if (hex[0] === '#') {
            hex = hex.slice(1);
        }
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        return {
            r: parseInt(hex.slice(0, 2), 16),
            g: parseInt(hex.slice(2, 4), 16),
            b: parseInt(hex.slice(4, 6), 16),
            a: hex.length > 6 ? parseInt(hex.slice(6, 8), 16) : 255,
        };
    };
    misc.color2index = misc.colorNameToIndex;
    misc.index2color = misc.indexToColorName;
    misc.hexToColor = misc.hexToRgba;
    misc.stripControlChars = (str, newline) => {
        if (newline) {
            return str.replace(/[\x00-\x09\x0b-\x1f\x7f]/g, '');
        }
        return str.replace(/[\x00-\x1f\x7f]/g, '');
    };
    const escapeSequenceRegex = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    const escapeSequenceParserRegex =
        /([\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])|([^\u001b\u009b]+)/g;
    misc.stripEscapeSequences = (str) => str.replace(escapeSequenceRegex, '');
    misc.ansiWidth = misc.stringWidth = (str) => {
        var matches,
            width = 0;
        escapeSequenceParserRegex.lastIndex = 0;
        while ((matches = escapeSequenceParserRegex.exec(str))) {
            if (matches[2]) {
                width += string$3.unicode.width(matches[2]);
            }
        }
        return width;
    };
    var lastTruncateWidth = 0;
    misc.getLastTruncateWidth = () => lastTruncateWidth;
    misc.truncateAnsiString = misc.truncateString = (str, maxWidth) => {
        var matches,
            width = 0;
        lastTruncateWidth = 0;
        escapeSequenceParserRegex.lastIndex = 0;
        while ((matches = escapeSequenceParserRegex.exec(str))) {
            if (matches[2]) {
                width += string$3.unicode.width(matches[2]);
                if (width >= maxWidth) {
                    if (width === maxWidth) {
                        return str.slice(0, matches.index + matches[2].length);
                    }
                    return (
                        str.slice(0, matches.index) +
                        string$3.unicode.truncateWidth(matches[2], maxWidth - lastTruncateWidth)
                    );
                }
                lastTruncateWidth = width;
            }
        }
        return str;
    };
    misc.markupWidth = (str) => {
        return string$3.unicode.width(
            str.replace(/\^\[[^\]]*]|\^(.)/g, (match, second) => {
                if (second === ' ' || second === '^') {
                    return second;
                }
                return '';
            }),
        );
    };
    misc.truncateMarkupString = (str, maxWidth) => {
        var index = 0,
            charWidth,
            strArray = string$3.unicode.toArray(str);
        lastTruncateWidth = 0;
        while (index < strArray.length) {
            if (strArray[index] === '^') {
                index++;
                if (strArray[index] === '[') {
                    while (index < strArray.length && strArray[index] !== ']') {
                        index++;
                    }
                    index++;
                    continue;
                }
                if (strArray[index] !== ' ' && strArray[index] !== '^') {
                    index++;
                    continue;
                }
            }
            charWidth = string$3.unicode.isFullWidth(strArray[index]) ? 2 : 1;
            if (lastTruncateWidth + charWidth > maxWidth) {
                strArray.length = index;
                return strArray.join('');
            }
            lastTruncateWidth += charWidth;
            index++;
        }
        return str;
    };
    misc.escapeSequenceSkipFn = (strArray, index) => {
        var code;
        if (strArray[index] !== '') {
            return index;
        }
        index++;
        if (strArray[index] !== '[') {
            return index;
        }
        index++;
        for (; index < strArray.length; index++) {
            code = strArray[index].charCodeAt(0);
            if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) {
                index++;
                break;
            }
        }
        return index;
    };
    misc.wordWrapAnsi = (str, width) =>
        string$3.wordwrap(str, {
            width,
            noJoin: true,
            fill: true,
            regroupFn: (strArray) => {
                var sequence = '',
                    csi = false,
                    newStrArray = [];
                strArray.forEach((char) => {
                    var charCode;
                    if (csi) {
                        sequence += char;
                        charCode = char.charCodeAt(0);
                        if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122)) {
                            newStrArray.push(sequence);
                            sequence = '';
                            csi = false;
                        }
                    } else if (sequence) {
                        sequence += char;
                        if (char === '[') {
                            csi = true;
                        } else {
                            newStrArray.push(sequence);
                            sequence = '';
                        }
                    } else if (char === '') {
                        sequence = char;
                    } else {
                        newStrArray.push(char);
                    }
                });
                return newStrArray;
            },
            charWidthFn: (char) => {
                if (char[0] === '') {
                    return 0;
                }
                return string$3.unicode.charWidth(char);
            },
        });
    misc.wordwrapMarkup = misc.wordWrapMarkup = (str, width) =>
        string$3.wordwrap(str, {
            width,
            noJoin: true,
            fill: true,
            regroupFn: (strArray) => {
                var markup = '',
                    complexMarkup = false,
                    newStrArray = [];
                strArray.forEach((char) => {
                    if (complexMarkup) {
                        markup += char;
                        if (char === ']') {
                            newStrArray.push(markup);
                            markup = '';
                            complexMarkup = false;
                        }
                    } else if (markup) {
                        markup += char;
                        if (char === '[') {
                            complexMarkup = true;
                        } else {
                            newStrArray.push(markup);
                            markup = '';
                        }
                    } else if (char === '^') {
                        markup = char;
                    } else {
                        newStrArray.push(char);
                    }
                });
                return newStrArray;
            },
            charWidthFn: (char) => {
                if (char[0] === '^' && char[1]) {
                    if (char[1] === '^' || char[1] === ' ') {
                        return 1;
                    }
                    return 0;
                }
                return string$3.unicode.charWidth(char);
            },
        });
    misc.preserveMarkupFormat = string$3.createFormatter({
        argumentSanitizer: (str) => str.replace(/[\x00-\x1f\x7f^]/g, (char) => (char === '^' ? '^^' : '')),
        noMarkup: true,
    });
    misc.markupOptions = {
        complexMarkupAliases: {
            c: 'color',
            fg: 'color',
            bg: 'bgColor',
        },
        shiftMarkup: {
            '#': 'background',
        },
        markup: {
            ':': { reset: true },
            ' ': { reset: true, raw: ' ' },
            ';': { reset: true, special: true },
            '-': { dim: true },
            '+': { bold: true },
            _: { underline: true },
            '/': { italic: true },
            '!': { inverse: true },
            k: { color: 0 },
            r: { color: 1 },
            g: { color: 2 },
            y: { color: 3 },
            b: { color: 4 },
            m: { color: 5 },
            c: { color: 6 },
            w: { color: 7 },
            K: { color: 8 },
            R: { color: 9 },
            G: { color: 10 },
            Y: { color: 11 },
            B: { color: 12 },
            M: { color: 13 },
            C: { color: 14 },
            W: { color: 15 },
        },
        shiftedMarkup: {
            background: {
                ':': { reset: true, defaultColor: true, bgDefaultColor: true },
                ' ': {
                    reset: true,
                    defaultColor: true,
                    bgDefaultColor: true,
                    raw: ' ',
                },
                ';': {
                    reset: true,
                    special: true,
                    defaultColor: true,
                    bgDefaultColor: true,
                },
                k: { bgColor: 0 },
                r: { bgColor: 1 },
                g: { bgColor: 2 },
                y: { bgColor: 3 },
                b: { bgColor: 4 },
                m: { bgColor: 5 },
                c: { bgColor: 6 },
                w: { bgColor: 7 },
                K: { bgColor: 8 },
                R: { bgColor: 9 },
                G: { bgColor: 10 },
                Y: { bgColor: 11 },
                B: { bgColor: 12 },
                M: { bgColor: 13 },
                C: { bgColor: 14 },
                W: { bgColor: 15 },
            },
        },
    };
    const parseMarkupRegexp = /\^\[([^\]]*)]|\^(.)|([^^]+)/g;
    misc.parseMarkup = (str, options) => {
        var complex,
            markup,
            raw,
            match,
            base = options.markup,
            output = [];
        parseMarkupRegexp.lastIndex = 0;
        while ((match = parseMarkupRegexp.exec(str))) {
            [, complex, markup, raw] = match;
            if (complex) {
                var custom = {};
                complex.split(',').forEach((part) => {
                    var [k, v] = part.split(':');
                    if (options.complexMarkupAliases[k]) {
                        k = options.complexMarkupAliases[k];
                    }
                    custom[k] = v || true;
                });
                output.push({ markup: custom });
            } else if (raw) {
                output.push(raw);
            } else if (markup === '^') {
                output.push('^');
            } else if (options.shiftMarkup[markup]) {
                base = options.shiftedMarkup[options.shiftMarkup[markup]];
                continue;
            } else if (base[markup]) {
                output.push({ markup: base[markup] });
            }
            base = options.markup;
        }
        return output;
    };
    const ANSI_CODES = {
        0: { reset: true },
        1: { bold: true },
        2: { dim: true },
        22: { bold: false, dim: false },
        3: { italic: true },
        23: { italic: false },
        4: { underline: true },
        24: { underline: false },
        5: { blink: true },
        25: { blink: false },
        7: { inverse: true },
        27: { inverse: false },
        8: { hidden: true },
        28: { hidden: false },
        9: { strike: true },
        29: { strike: false },
        30: { color: 0 },
        31: { color: 1 },
        32: { color: 2 },
        33: { color: 3 },
        34: { color: 4 },
        35: { color: 5 },
        36: { color: 6 },
        37: { color: 7 },
        '39:': { defaultColor: true },
        90: { color: 8 },
        91: { color: 9 },
        92: { color: 10 },
        93: { color: 11 },
        94: { color: 12 },
        95: { color: 13 },
        96: { color: 14 },
        97: { color: 15 },
        40: { bgColor: 0 },
        41: { bgColor: 1 },
        42: { bgColor: 2 },
        43: { bgColor: 3 },
        44: { bgColor: 4 },
        45: { bgColor: 5 },
        46: { bgColor: 6 },
        47: { bgColor: 7 },
        '49:': { bgDefaultColor: true },
        100: { bgColor: 8 },
        101: { bgColor: 9 },
        102: { bgColor: 10 },
        103: { bgColor: 11 },
        104: { bgColor: 12 },
        105: { bgColor: 13 },
        106: { bgColor: 14 },
        107: { bgColor: 15 },
    };
    const parseAnsiRegexp = /\x1b\[([0-9;]+)m|(.[^\x1b]*)/g;
    misc.parseAnsi = (str) => {
        var match,
            ansiCodes,
            raw,
            output = [];
        parseAnsiRegexp.lastIndex = 0;
        while ((match = parseAnsiRegexp.exec(str))) {
            [, ansiCodes, raw] = match;
            if (raw) {
                output.push(raw);
            } else {
                ansiCodes.split(/;/g).forEach((ansiCode) => {
                    if (ANSI_CODES[ansiCode]) {
                        output.push({ markup: ANSI_CODES[ansiCode] });
                    }
                });
            }
        }
        return output;
    };
    var detectTerminal = {};
    (function (global2, undefined$1) {
        if (global2.setImmediate) {
            return;
        }
        var nextHandle = 1;
        var tasksByHandle = {};
        var currentlyRunningATask = false;
        var doc = global2.document;
        var registerImmediate;
        function setImmediate2(callback) {
            if (typeof callback !== 'function') {
                callback = new Function('' + callback);
            }
            var args = new Array(arguments.length - 1);
            for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i + 1];
            }
            var task = { callback, args };
            tasksByHandle[nextHandle] = task;
            registerImmediate(nextHandle);
            return nextHandle++;
        }
        function clearImmediate(handle) {
            delete tasksByHandle[handle];
        }
        function run(task) {
            var callback = task.callback;
            var args = task.args;
            switch (args.length) {
                case 0:
                    callback();
                    break;
                case 1:
                    callback(args[0]);
                    break;
                case 2:
                    callback(args[0], args[1]);
                    break;
                case 3:
                    callback(args[0], args[1], args[2]);
                    break;
                default:
                    callback.apply(undefined$1, args);
                    break;
            }
        }
        function runIfPresent(handle) {
            if (currentlyRunningATask) {
                setTimeout(runIfPresent, 0, handle);
            } else {
                var task = tasksByHandle[handle];
                if (task) {
                    currentlyRunningATask = true;
                    try {
                        run(task);
                    } finally {
                        clearImmediate(handle);
                        currentlyRunningATask = false;
                    }
                }
            }
        }
        function installNextTickImplementation() {
            registerImmediate = function (handle) {
                process.nextTick(function () {
                    runIfPresent(handle);
                });
            };
        }
        function canUsePostMessage() {
            if (global2.postMessage && !global2.importScripts) {
                var postMessageIsAsynchronous = true;
                var oldOnMessage = global2.onmessage;
                global2.onmessage = function () {
                    postMessageIsAsynchronous = false;
                };
                global2.postMessage('', '*');
                global2.onmessage = oldOnMessage;
                return postMessageIsAsynchronous;
            }
        }
        function installPostMessageImplementation() {
            var messagePrefix = 'setImmediate$' + Math.random() + '$';
            var onGlobalMessage = function (event2) {
                if (
                    event2.source === global2 &&
                    typeof event2.data === 'string' &&
                    event2.data.indexOf(messagePrefix) === 0
                ) {
                    runIfPresent(+event2.data.slice(messagePrefix.length));
                }
            };
            if (global2.addEventListener) {
                global2.addEventListener('message', onGlobalMessage, false);
            } else {
                global2.attachEvent('onmessage', onGlobalMessage);
            }
            registerImmediate = function (handle) {
                global2.postMessage(messagePrefix + handle, '*');
            };
        }
        function installMessageChannelImplementation() {
            var channel = new MessageChannel();
            channel.port1.onmessage = function (event2) {
                var handle = event2.data;
                runIfPresent(handle);
            };
            registerImmediate = function (handle) {
                channel.port2.postMessage(handle);
            };
        }
        function installReadyStateChangeImplementation() {
            var html = doc.documentElement;
            registerImmediate = function (handle) {
                var script = doc.createElement('script');
                script.onreadystatechange = function () {
                    runIfPresent(handle);
                    script.onreadystatechange = null;
                    html.removeChild(script);
                    script = null;
                };
                html.appendChild(script);
            };
        }
        function installSetTimeoutImplementation() {
            registerImmediate = function (handle) {
                setTimeout(runIfPresent, 0, handle);
            };
        }
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
        if ({}.toString.call(global2.process) === '[object process]') {
            installNextTickImplementation();
        } else if (canUsePostMessage()) {
            installPostMessageImplementation();
        } else if (global2.MessageChannel) {
            installMessageChannelImplementation();
        } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
            installReadyStateChangeImplementation();
        } else {
            installSetTimeoutImplementation();
        }
        attachTo.setImmediate = setImmediate2;
        attachTo.clearImmediate = clearImmediate;
    })(
        typeof self === 'undefined'
            ? typeof commonjsGlobal$1 === 'undefined'
                ? commonjsGlobal$1
                : commonjsGlobal$1
            : self,
    );
    const NativePromise = commonjsGlobal$1.Promise;
    var nextTick$1;
    if (!process.browser) {
        nextTick$1 = process.nextTick;
    } else {
        nextTick$1 = setImmediate;
    }
    function Promise$j(fn) {
        this.fn = fn;
        this._then = Promise$j._dormantThen;
        this.value = null;
        this.thenHandlers = null;
        this.handledRejection = null;
        if (this.fn) {
            this._exec();
        }
    }
    var core = Promise$j;
    Promise$j.Native = NativePromise;
    Promise$j.warnUnhandledRejection = true;
    Promise$j.prototype._exec = function () {
        this._then = Promise$j._pendingThen;
        try {
            this.fn(
                (result_) => {
                    this.resolve(result_);
                },
                (error_) => {
                    this.reject(error_);
                },
            );
        } catch (error) {
            this.reject(error);
        }
    };
    Promise$j.prototype.resolve = Promise$j.prototype.fulfill = function (value) {
        if (this._then.settled) {
            return this;
        }
        if (Promise$j.isThenable(value)) {
            this._execThenPromise(value);
            return this;
        }
        return this._resolveValue(value);
    };
    Promise$j.prototype._resolveValue = function (value) {
        this._then = Promise$j._fulfilledThen;
        this.value = value;
        if (this.thenHandlers && this.thenHandlers.length) {
            this._execFulfillHandlers();
        }
        return this;
    };
    Promise$j.prototype._execThenPromise = function (thenPromise) {
        try {
            thenPromise.then(
                (result_) => {
                    this.resolve(result_);
                },
                (error_) => {
                    this.reject(error_);
                },
            );
        } catch (error) {
            this.reject(error);
        }
    };
    Promise$j.prototype.reject = function (error) {
        if (this._then.settled) {
            return this;
        }
        this._then = Promise$j._rejectedThen;
        this.value = error;
        if (this.thenHandlers && this.thenHandlers.length) {
            this._execRejectionHandlers();
        } else if (Promise$j.warnUnhandledRejection && !this.handledRejection) {
            this._unhandledRejection();
        }
        return this;
    };
    Promise$j.prototype._execFulfillHandlers = function () {
        var i,
            length = this.thenHandlers.length;
        for (i = 0; i < length; i += 3) {
            if (this.thenHandlers[i + 1]) {
                this._execOneFulfillHandler(this.thenHandlers[i], this.thenHandlers[i + 1]);
            } else {
                this.thenHandlers[i].resolve(this.value);
            }
        }
    };
    Promise$j.prototype._execOneFulfillHandler = function (promise, onFulfill) {
        try {
            promise.resolve(onFulfill(this.value));
        } catch (error_) {
            promise.reject(error_);
        }
    };
    Promise$j.prototype._execRejectionHandlers = function () {
        var i,
            length = this.thenHandlers.length;
        for (i = 0; i < length; i += 3) {
            if (this.thenHandlers[i + 2]) {
                this._execOneRejectHandler(this.thenHandlers[i], this.thenHandlers[i + 2]);
            } else {
                this.thenHandlers[i].reject(this.value);
            }
        }
    };
    Promise$j.prototype._execOneRejectHandler = function (promise, onReject) {
        try {
            promise.resolve(onReject(this.value));
        } catch (error_) {
            promise.reject(error_);
        }
    };
    Promise$j.prototype.resolveTimeout = Promise$j.prototype.fulfillTimeout = function (time, result) {
        setTimeout(() => this.resolve(result), time);
    };
    Promise$j.prototype.rejectTimeout = function (time, error) {
        setTimeout(() => this.reject(error), time);
    };
    Promise$j._dormantThen = function (onFulfill, onReject) {
        if (this.fn) {
            this._exec();
            return this._then(onFulfill, onReject);
        }
        var promise = new Promise$j();
        if (!this.thenHandlers) {
            this.thenHandlers = [promise, onFulfill, onReject];
        } else {
            this.thenHandlers[this.thenHandlers.length] = promise;
            this.thenHandlers[this.thenHandlers.length] = onFulfill;
            this.thenHandlers[this.thenHandlers.length] = onReject;
        }
        return promise;
    };
    Promise$j._dormantThen.settled = false;
    Promise$j._pendingThen = function (onFulfill, onReject) {
        var promise = new Promise$j();
        if (!this.thenHandlers) {
            this.thenHandlers = [promise, onFulfill, onReject];
        } else {
            this.thenHandlers[this.thenHandlers.length] = promise;
            this.thenHandlers[this.thenHandlers.length] = onFulfill;
            this.thenHandlers[this.thenHandlers.length] = onReject;
        }
        return promise;
    };
    Promise$j._pendingThen.settled = false;
    Promise$j._fulfilledThen = function (onFulfill) {
        if (!onFulfill) {
            return this;
        }
        var promise = new Promise$j();
        nextTick$1(() => {
            try {
                promise.resolve(onFulfill(this.value));
            } catch (error) {
                promise.reject(error);
            }
        });
        return promise;
    };
    Promise$j._fulfilledThen.settled = true;
    Promise$j._rejectedThen = function (onFulfill, onReject) {
        if (!onReject) {
            return this;
        }
        this.handledRejection = true;
        var promise = new Promise$j();
        nextTick$1(() => {
            try {
                promise.resolve(onReject(this.value));
            } catch (error) {
                promise.reject(error);
            }
        });
        return promise;
    };
    Promise$j._rejectedThen.settled = true;
    Promise$j.prototype.then = function (onFulfill, onReject) {
        return this._then(onFulfill, onReject);
    };
    Promise$j.prototype.catch = function (onReject = () => void 0) {
        return this._then(void 0, onReject);
    };
    Promise$j.prototype.finally = function (onSettled) {
        return this._then(onSettled, onSettled);
    };
    Promise$j.prototype.tap = Promise$j.prototype.tapThen = function (onFulfill) {
        this._then(onFulfill, void 0);
        return this;
    };
    Promise$j.prototype.tapCatch = function (onReject) {
        this._then(void 0, onReject);
        return this;
    };
    Promise$j.prototype.tapFinally = function (onSettled) {
        this._then(onSettled, onSettled);
        return this;
    };
    Promise$j.prototype.fatal = function () {
        this._then(void 0, (error) => {
            nextTick$1(() => {
                throw error;
            });
        });
    };
    Promise$j.prototype.done = function (onFulfill, onReject) {
        this._then(onFulfill, onReject).fatal();
        return this;
    };
    Promise$j.prototype.callback = function (cb) {
        this._then(
            (value) => {
                cb(void 0, value);
            },
            (error) => {
                cb(error);
            },
        ).fatal();
        return this;
    };
    Promise$j.prototype.callbackAll = function (cb) {
        this._then(
            (values) => {
                if (Array.isArray(values)) {
                    cb(void 0, ...values);
                } else {
                    cb(void 0, values);
                }
            },
            (error) => {
                cb(error);
            },
        ).fatal();
        return this;
    };
    Promise$j.callback = function (fn) {
        return new Promise$j((resolve, reject) => {
            fn((error, arg) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(arg);
                }
            });
        });
    };
    Promise$j.callbackAll = function (fn) {
        return new Promise$j((resolve, reject) => {
            fn((error, ...args) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(args);
                }
            });
        });
    };
    Promise$j.prototype.toPromise = Promise$j.prototype.propagate = function (promise) {
        this._then(
            (value) => {
                promise.resolve(value);
            },
            (error) => {
                promise.reject(error);
            },
        );
        return this;
    };
    Promise$j.propagate = function (foreignPromise, promise) {
        foreignPromise.then(
            (value) => {
                promise.resolve(value);
            },
            (error) => {
                promise.reject(error);
            },
        );
        return foreignPromise;
    };
    Promise$j.finally = function (foreignPromise, onSettled) {
        return foreignPromise.then(onSettled, onSettled);
    };
    Promise$j.resolve = Promise$j.fulfill = function (value) {
        if (Promise$j.isThenable(value)) {
            return Promise$j.fromThenable(value);
        }
        return Promise$j._resolveValue(value);
    };
    Promise$j._resolveValue = function (value) {
        var promise = new Promise$j();
        promise._then = Promise$j._fulfilledThen;
        promise.value = value;
        return promise;
    };
    Promise$j.reject = function (error) {
        var promise = new Promise$j();
        promise._then = Promise$j._rejectedThen;
        promise.value = error;
        return promise;
    };
    Promise$j.resolveTimeout = Promise$j.fulfillTimeout = function (timeout, value) {
        return new Promise$j((resolve) => setTimeout(() => resolve(value), timeout));
    };
    Promise$j.rejectTimeout = function (timeout, error) {
        return new Promise$j((resolve, reject) => setTimeout(() => reject(error), timeout));
    };
    Promise$j.resolveNextTick = Promise$j.fulfillNextTick = function (value) {
        return new Promise$j((resolve) => nextTick$1(() => resolve(value)));
    };
    Promise$j.rejectNextTick = function (error) {
        return new Promise$j((resolve, reject) => nextTick$1(() => reject(error)));
    };
    Promise$j.dormant = function (fn) {
        var promise = new Promise$j();
        promise.fn = fn;
        return promise;
    };
    Promise$j.try = function (fn) {
        try {
            return Promise$j.resolve(fn());
        } catch (error) {
            return Promise$j.reject(error);
        }
    };
    Promise$j.isThenable = function (value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    };
    Promise$j.fromThenable = function (thenable) {
        if (thenable instanceof Promise$j) {
            return thenable;
        }
        return new Promise$j((resolve, reject) => {
            thenable.then(
                (value) => {
                    resolve(value);
                },
                (error) => {
                    reject(error);
                },
            );
        });
    };
    Promise$j._bareThen = function (value, onFulfill, onReject) {
        if (value && typeof value === 'object') {
            if (value instanceof Promise$j) {
                if (value._then === Promise$j._fulfilledThen) {
                    onFulfill(value.value);
                } else if (value._then === Promise$j._rejectedThen) {
                    onReject(value.value);
                } else {
                    value._then(onFulfill, onReject);
                }
            } else if (typeof value.then === 'function') {
                value.then(onFulfill, onReject);
            } else {
                onFulfill(value);
            }
        } else {
            onFulfill(value);
        }
    };
    Promise$j._handleAll = function (iterable) {
        var value;
        for (value of iterable) {
            if (Promise$j.isThenable(value)) {
                value.handledRejection = true;
            }
        }
    };
    Promise$j.prototype._unhandledRejection = function () {
        this.handledRejection = false;
        const nextTick_ = (cb) => setTimeout(cb, 0);
        if (this.value instanceof Error) {
            nextTick_(() => {
                if (this.handledRejection === false) {
                    this.value.message = 'Unhandled promise rejection: ' + this.value.message;
                    console.error(this.value);
                }
            });
        } else {
            let error_ = new Error('Unhandled promise rejection');
            nextTick_(() => {
                if (this.handledRejection === false) {
                    console.error(error_);
                    console.error('Rejection reason:', this.value);
                }
            });
        }
    };
    Promise$j.prototype.isSettled = function () {
        return this._then.settled;
    };
    Promise$j.prototype.getStatus = function () {
        switch (this._then) {
            case Promise$j._dormantThen:
                return 'dormant';
            case Promise$j._pendingThen:
                return 'pending';
            case Promise$j._fulfilledThen:
                return 'fulfilled';
            case Promise$j._rejectedThen:
                return 'rejected';
        }
    };
    Promise$j.prototype.inspect = function () {
        switch (this._then) {
            case Promise$j._dormantThen:
                return 'Promise { <DORMANT> }';
            case Promise$j._pendingThen:
                return 'Promise { <PENDING> }';
            case Promise$j._fulfilledThen:
                return 'Promise { <FULFILLED> ' + this.value + ' }';
            case Promise$j._rejectedThen:
                return 'Promise { <REJECTED> ' + this.value + ' }';
        }
    };
    Promise$j.resolved = Promise$j.dummy = Promise$j.resolve();
    if (process.browser) {
        Promise$j.prototype.resolveAtAnimationFrame = function (value) {
            window.requestAnimationFrame(() => this.resolve(value));
        };
        Promise$j.prototype.rejectAtAnimationFrame = function (error) {
            window.requestAnimationFrame(() => this.reject(error));
        };
        Promise$j.resolveAtAnimationFrame = function (value) {
            return new Promise$j((resolve) => window.requestAnimationFrame(() => resolve(value)));
        };
        Promise$j.rejectAtAnimationFrame = function (error) {
            return new Promise$j((resolve, reject) => window.requestAnimationFrame(() => reject(error)));
        };
    }
    const Promise$i = seventh_1;
    const HOLE = {};
    function noop$1() {}
    Promise$i.all = (iterable) => {
        var index = -1,
            settled = false,
            count = 0,
            length = Infinity,
            value,
            values = [],
            allPromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            index++;
            (() => {
                const promiseIndex = index;
                Promise$i.resolve(value).then(
                    (value_) => {
                        if (settled) {
                            return;
                        }
                        values[promiseIndex] = value_;
                        count++;
                        if (count >= length) {
                            settled = true;
                            allPromise._resolveValue(values);
                        }
                    },
                    (error) => {
                        if (settled) {
                            return;
                        }
                        settled = true;
                        allPromise.reject(error);
                    },
                );
            })();
        }
        length = index + 1;
        if (!length) {
            allPromise._resolveValue(values);
        }
        return allPromise;
    };
    Promise$i._allArray = (iterable) => {
        var length = iterable.length;
        if (!length) {
            Promise$i._resolveValue([]);
        }
        var index,
            runtime = {
                settled: false,
                count: 0,
                length,
                values: [],
                allPromise: new Promise$i(),
            };
        for (index = 0; !runtime.settled && index < length; index++) {
            Promise$i._allArrayOne(iterable[index], index, runtime);
        }
        return runtime.allPromise;
    };
    Promise$i._allArrayOne = (value, index, runtime) => {
        Promise$i._bareThen(
            value,
            (value_) => {
                if (runtime.settled) {
                    return;
                }
                runtime.values[index] = value_;
                runtime.count++;
                if (runtime.count >= runtime.length) {
                    runtime.settled = true;
                    runtime.allPromise._resolveValue(runtime.values);
                }
            },
            (error) => {
                if (runtime.settled) {
                    return;
                }
                runtime.settled = true;
                runtime.allPromise.reject(error);
            },
        );
    };
    Promise$i.every = Promise$i.map = (iterable, iterator) => {
        var index = -1,
            settled = false,
            count = 0,
            length = Infinity,
            value,
            values = [],
            allPromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            index++;
            (() => {
                const promiseIndex = index;
                Promise$i.resolve(value)
                    .then((value_) => {
                        if (settled) {
                            return;
                        }
                        return iterator(value_, promiseIndex);
                    })
                    .then(
                        (value_) => {
                            if (settled) {
                                return;
                            }
                            values[promiseIndex] = value_;
                            count++;
                            if (count >= length) {
                                settled = true;
                                allPromise._resolveValue(values);
                            }
                        },
                        (error) => {
                            if (settled) {
                                return;
                            }
                            settled = true;
                            allPromise.reject(error);
                        },
                    );
            })();
        }
        length = index + 1;
        if (!length) {
            allPromise._resolveValue(values);
        }
        return allPromise;
    };
    Promise$i.any = (iterable) => {
        var index = -1,
            settled = false,
            count = 0,
            length = Infinity,
            value,
            errors = [],
            anyPromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            index++;
            (() => {
                const promiseIndex = index;
                Promise$i.resolve(value).then(
                    (value_) => {
                        if (settled) {
                            return;
                        }
                        settled = true;
                        anyPromise._resolveValue(value_);
                    },
                    (error) => {
                        if (settled) {
                            return;
                        }
                        errors[promiseIndex] = error;
                        count++;
                        if (count >= length) {
                            settled = true;
                            anyPromise.reject(errors);
                        }
                    },
                );
            })();
        }
        length = index + 1;
        if (!length) {
            anyPromise.reject(new RangeError('Promise.any(): empty array'));
        }
        return anyPromise;
    };
    Promise$i.some = (iterable, iterator) => {
        var index = -1,
            settled = false,
            count = 0,
            length = Infinity,
            value,
            errors = [],
            anyPromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            index++;
            (() => {
                const promiseIndex = index;
                Promise$i.resolve(value)
                    .then((value_) => {
                        if (settled) {
                            return;
                        }
                        return iterator(value_, promiseIndex);
                    })
                    .then(
                        (value_) => {
                            if (settled) {
                                return;
                            }
                            settled = true;
                            anyPromise._resolveValue(value_);
                        },
                        (error) => {
                            if (settled) {
                                return;
                            }
                            errors[promiseIndex] = error;
                            count++;
                            if (count >= length) {
                                settled = true;
                                anyPromise.reject(errors);
                            }
                        },
                    );
            })();
        }
        length = index + 1;
        if (!length) {
            anyPromise.reject(new RangeError('Promise.any(): empty array'));
        }
        return anyPromise;
    };
    Promise$i.filter = (iterable, iterator) => {
        var index = -1,
            settled = false,
            count = 0,
            length = Infinity,
            value,
            values = [],
            filterPromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            index++;
            (() => {
                const promiseIndex = index;
                Promise$i.resolve(value)
                    .then((value_) => {
                        if (settled) {
                            return;
                        }
                        values[promiseIndex] = value_;
                        return iterator(value_, promiseIndex);
                    })
                    .then(
                        (iteratorValue) => {
                            if (settled) {
                                return;
                            }
                            count++;
                            if (!iteratorValue) {
                                values[promiseIndex] = HOLE;
                            }
                            if (count >= length) {
                                settled = true;
                                values = values.filter((e) => e !== HOLE);
                                filterPromise._resolveValue(values);
                            }
                        },
                        (error) => {
                            if (settled) {
                                return;
                            }
                            settled = true;
                            filterPromise.reject(error);
                        },
                    );
            })();
        }
        length = index + 1;
        if (!length) {
            filterPromise._resolveValue(values);
        } else if (count >= length) {
            settled = true;
            values = values.filter((e) => e !== HOLE);
            filterPromise._resolveValue(values);
        }
        return filterPromise;
    };
    Promise$i.foreach = Promise$i.forEach = function (iterable, iterator, accumulator) {
        var index = -1,
            isReduce = arguments.length >= 3,
            it = iterable[Symbol.iterator](),
            forEachPromise = new Promise$i(),
            lastPromise = Promise$i.resolve(accumulator);
        if (Promise$i.warnUnhandledRejection) {
            Promise$i._handleAll(iterable);
        }
        var nextElement = () => {
            lastPromise.then(
                (accumulator_) => {
                    let { value, done } = it.next();
                    index++;
                    if (done) {
                        forEachPromise.resolve(accumulator_);
                    } else {
                        lastPromise = Promise$i.resolve(value).then(
                            isReduce
                                ? (value_) => iterator(accumulator_, value_, index)
                                : (value_) => iterator(value_, index),
                        );
                        nextElement();
                    }
                },
                (error) => {
                    forEachPromise.reject(error);
                    for (;;) {
                        let { value, done } = it.next();
                        if (done) {
                            break;
                        }
                        if (Promise$i.isThenable(value)) {
                            value.then(noop$1, noop$1);
                        }
                    }
                },
            );
        };
        nextElement();
        return forEachPromise;
    };
    Promise$i.reduce = (iterable, iterator, accumulator) => {
        return Promise$i.forEach(iterable, iterator, accumulator);
    };
    Promise$i.mapObject = (inputObject, iterator) => {
        var settled = false,
            count = 0,
            i,
            key,
            keys = Object.keys(inputObject),
            length = keys.length,
            value,
            outputObject = {},
            mapPromise = new Promise$i();
        for (i = 0; !settled && i < length; i++) {
            key = keys[i];
            value = inputObject[key];
            (() => {
                const promiseKey = key;
                Promise$i.resolve(value)
                    .then((value_) => {
                        if (settled) {
                            return;
                        }
                        return iterator(value_, promiseKey);
                    })
                    .then(
                        (value_) => {
                            if (settled) {
                                return;
                            }
                            outputObject[promiseKey] = value_;
                            count++;
                            if (count >= length) {
                                settled = true;
                                mapPromise._resolveValue(outputObject);
                            }
                        },
                        (error) => {
                            if (settled) {
                                return;
                            }
                            settled = true;
                            mapPromise.reject(error);
                        },
                    );
            })();
        }
        if (!length) {
            mapPromise._resolveValue(outputObject);
        }
        return mapPromise;
    };
    Promise$i.concurrent = (limit, iterable, iterator) => {
        var index = -1,
            settled = false,
            running = 0,
            count = 0,
            length = Infinity,
            value,
            done = false,
            values = [],
            it = iterable[Symbol.iterator](),
            concurrentPromise = new Promise$i();
        if (Promise$i.warnUnhandledRejection) {
            Promise$i._handleAll(iterable);
        }
        limit = +limit || 1;
        const runBatch = () => {
            while (!done && running < limit) {
                ({ value, done } = it.next());
                if (done) {
                    length = index + 1;
                    if (count >= length) {
                        settled = true;
                        concurrentPromise._resolveValue(values);
                        return;
                    }
                    break;
                }
                if (settled) {
                    break;
                }
                index++;
                (() => {
                    const promiseIndex = index;
                    running++;
                    Promise$i.resolve(value)
                        .then((value_) => {
                            if (settled) {
                                return;
                            }
                            return iterator(value_, promiseIndex);
                        })
                        .then(
                            (value_) => {
                                if (settled) {
                                    return;
                                }
                                values[promiseIndex] = value_;
                                count++;
                                running--;
                                if (count >= length) {
                                    settled = true;
                                    concurrentPromise._resolveValue(values);
                                    return;
                                }
                                if (running < limit) {
                                    runBatch();
                                    return;
                                }
                            },
                            (error) => {
                                if (settled) {
                                    return;
                                }
                                settled = true;
                                concurrentPromise.reject(error);
                            },
                        );
                })();
            }
        };
        runBatch();
        if (index < 0) {
            concurrentPromise._resolveValue(values);
        }
        return concurrentPromise;
    };
    Promise$i.race = (iterable) => {
        var settled = false,
            value,
            racePromise = new Promise$i();
        for (value of iterable) {
            if (settled) {
                break;
            }
            Promise$i.resolve(value).then(
                (value_) => {
                    if (settled) {
                        return;
                    }
                    settled = true;
                    racePromise._resolveValue(value_);
                },
                (error) => {
                    if (settled) {
                        return;
                    }
                    settled = true;
                    racePromise.reject(error);
                },
            );
        }
        return racePromise;
    };
    const Promise$h = seventh_1;
    Promise$h.timeLimit = (timeout, asyncFnOrPromise) => {
        return new Promise$h((resolve, reject) => {
            if (typeof asyncFnOrPromise === 'function') {
                asyncFnOrPromise = asyncFnOrPromise();
            }
            Promise$h.resolve(asyncFnOrPromise).then(resolve, reject);
            setTimeout(() => reject(new Error('Timeout')), timeout);
        });
    };
    Promise$h.retry = (options, asyncFn) => {
        var count = options.retries || 1,
            coolDown = options.coolDown || 0,
            raiseFactor = options.raiseFactor || 1,
            maxCoolDown = options.maxCoolDown || Infinity,
            timeout = options.timeout || 0,
            catchFn = options.catch || null;
        const oneTry = () => {
            return (timeout ? Promise$h.timeLimit(timeout, asyncFn) : asyncFn()).catch((error) => {
                if (!count--) {
                    throw error;
                }
                var currentCoolDown = coolDown;
                coolDown = Math.min(coolDown * raiseFactor, maxCoolDown);
                if (catchFn) {
                    return Promise$h.resolve(catchFn(error)).then(() =>
                        Promise$h.resolveTimeout(currentCoolDown).then(oneTry),
                    );
                }
                return Promise$h.resolveTimeout(currentCoolDown).then(oneTry);
            });
        };
        return oneTry();
    };
    Promise$h.onceEvent = (emitter, eventName) => {
        return new Promise$h((resolve) => emitter.once(eventName, resolve));
    };
    Promise$h.onceEventAll = (emitter, eventName) => {
        return new Promise$h((resolve) => emitter.once(eventName, (...args) => resolve(args)));
    };
    Promise$h.onceEventOrError = (emitter, eventName, excludeEvents, _internalAllArgs = false) => {
        return new Promise$h((resolve, reject) => {
            var altRejects;
            var resolve_ = (...args) => {
                emitter.removeListener('error', reject_);
                if (altRejects) {
                    for (let event2 in altRejects) {
                        emitter.removeListener(event2, altRejects[event2]);
                    }
                }
                resolve(_internalAllArgs ? args : args[0]);
            };
            var reject_ = (arg) => {
                emitter.removeListener(eventName, resolve_);
                if (altRejects) {
                    for (let event2 in altRejects) {
                        emitter.removeListener(event2, altRejects[event2]);
                    }
                }
                reject(arg);
            };
            emitter.once(eventName, resolve_);
            emitter.once('error', reject_);
            if (excludeEvents) {
                if (!Array.isArray(excludeEvents)) {
                    excludeEvents = [excludeEvents];
                }
                altRejects = {};
                excludeEvents.forEach((event2) => {
                    var altReject = (...args) => {
                        emitter.removeListener('error', reject_);
                        emitter.removeListener(eventName, resolve_);
                        var error = new Error('Received an excluded event: ' + event2);
                        error.event = event2;
                        error.eventArgs = args;
                        reject(error);
                    };
                    emitter.once(event2, altReject);
                    altRejects[event2] = altReject;
                });
            }
        });
    };
    Promise$h.onceEventAllOrError = (emitter, eventName, excludeEvents) => {
        return Promise$h.onceEventOrError(emitter, eventName, excludeEvents, true);
    };
    const Promise$g = seventh_1;
    Promise$g.promisifyAll = (nodeAsyncFn, thisBinding) => {
        if (thisBinding) {
            return (...args) => {
                return new Promise$g((resolve, reject) => {
                    nodeAsyncFn.call(thisBinding, ...args, (error, ...cbArgs) => {
                        if (error) {
                            if (cbArgs.length && error instanceof Error) {
                                error.args = cbArgs;
                            }
                            reject(error);
                        } else {
                            resolve(cbArgs);
                        }
                    });
                });
            };
        }
        return function (...args) {
            return new Promise$g((resolve, reject) => {
                nodeAsyncFn.call(this, ...args, (error, ...cbArgs) => {
                    if (error) {
                        if (cbArgs.length && error instanceof Error) {
                            error.args = cbArgs;
                        }
                        reject(error);
                    } else {
                        resolve(cbArgs);
                    }
                });
            });
        };
    };
    Promise$g.promisify = (nodeAsyncFn, thisBinding) => {
        if (thisBinding) {
            return (...args) => {
                return new Promise$g((resolve, reject) => {
                    nodeAsyncFn.call(thisBinding, ...args, (error, cbArg) => {
                        if (error) {
                            if (cbArg !== void 0 && error instanceof Error) {
                                error.arg = cbArg;
                            }
                            reject(error);
                        } else {
                            resolve(cbArg);
                        }
                    });
                });
            };
        }
        return function (...args) {
            return new Promise$g((resolve, reject) => {
                nodeAsyncFn.call(this, ...args, (error, cbArg) => {
                    if (error) {
                        if (cbArg !== void 0 && error instanceof Error) {
                            error.arg = cbArg;
                        }
                        reject(error);
                    } else {
                        resolve(cbArg);
                    }
                });
            });
        };
    };
    Promise$g.returnValueInterceptor = (interceptor, asyncFn, thisBinding) => {
        return function (...args) {
            var returnVal = asyncFn.call(thisBinding || this, ...args);
            interceptor(returnVal);
            return returnVal;
        };
    };
    Promise$g.once = (asyncFn, thisBinding) => {
        var triggered = false;
        var result;
        return function (...args) {
            if (!triggered) {
                triggered = true;
                result = asyncFn.call(thisBinding || this, ...args);
            }
            return result;
        };
    };
    Promise$g.serialize = (asyncFn, thisBinding) => {
        var lastPromise = new Promise$g.resolve();
        return function (...args) {
            var promise = new Promise$g();
            lastPromise.finally(() => {
                Promise$g.propagate(asyncFn.call(thisBinding || this, ...args), promise);
            });
            lastPromise = promise;
            return promise;
        };
    };
    Promise$g.debounce = (asyncFn, thisBinding) => {
        var inProgress = null;
        const outWrapper = () => {
            inProgress = null;
        };
        return function (...args) {
            if (inProgress) {
                return inProgress;
            }
            inProgress = asyncFn.call(thisBinding || this, ...args);
            Promise$g.finally(inProgress, outWrapper);
            return inProgress;
        };
    };
    Promise$g.debounceDelay = (delay, asyncFn, thisBinding) => {
        var inProgress = null;
        const outWrapper = () => {
            setTimeout(() => (inProgress = null), delay);
        };
        return function (...args) {
            if (inProgress) {
                return inProgress;
            }
            inProgress = asyncFn.call(thisBinding || this, ...args);
            Promise$g.finally(inProgress, outWrapper);
            return inProgress;
        };
    };
    Promise$g.debounceUpdate = (asyncFn, thisBinding) => {
        var inProgress = null;
        var nextUpdateWith = null;
        var nextUpdatePromise = null;
        const outWrapper = () => {
            var args, sharedPromise;
            inProgress = null;
            if (nextUpdateWith) {
                args = nextUpdateWith;
                nextUpdateWith = null;
                sharedPromise = nextUpdatePromise;
                nextUpdatePromise = null;
                inProgress = asyncFn.call(...args);
                Promise$g.propagate(inProgress, sharedPromise);
                Promise$g.finally(inProgress, outWrapper);
                return inProgress;
            }
        };
        return function (...args) {
            var localThis = thisBinding || this;
            if (inProgress) {
                if (!nextUpdatePromise) {
                    nextUpdatePromise = new Promise$g();
                }
                nextUpdateWith = [localThis, ...args];
                return nextUpdatePromise;
            }
            inProgress = asyncFn.call(localThis, ...args);
            Promise$g.finally(inProgress, outWrapper);
            return inProgress;
        };
    };
    Promise$g.NO_DELAY = {};
    Promise$g.BATCH_NO_DELAY = {};
    Promise$g.debounceSync = (getParams, fullSyncParams) => {
        var perResourceData = new Map();
        const getResourceData = (resourceId) => {
            var resourceData = perResourceData.get(resourceId);
            if (!resourceData) {
                resourceData = {
                    inProgress: null,
                    inProgressIsFull: null,
                    last: null,
                    lastTime: null,
                    lastFullSync: null,
                    lastFullSyncTime: null,
                    nextFullSyncPromise: null,
                    nextFullSyncWith: null,
                    noDelayBatches: new Set(),
                };
                perResourceData.set(resourceId, resourceData);
            }
            return resourceData;
        };
        const outWrapper = (resourceData, level) => {
            var delta,
                args,
                sharedPromise,
                now = new Date();
            resourceData.inProgress = null;
            if (level >= 2) {
                resourceData.lastFullSyncTime = resourceData.lastTime = now;
            } else if (level >= 1) {
                resourceData.lastTime = now;
            }
            if (resourceData.nextFullSyncWith) {
                if (
                    fullSyncParams.delay &&
                    resourceData.lastFullSyncTime &&
                    (delta = now - resourceData.lastFullSyncTime - fullSyncParams.delay) < 0
                ) {
                    resourceData.inProgress = Promise$g.resolveTimeout(-delta + 1);
                    resourceData.inProgress.finally(() => outWrapper(resourceData, 0));
                    return resourceData.nextFullSyncPromise;
                }
                args = resourceData.nextFullSyncWith;
                resourceData.nextFullSyncWith = null;
                sharedPromise = resourceData.nextFullSyncPromise;
                resourceData.nextFullSyncPromise = null;
                resourceData.lastFullSync =
                    resourceData.last =
                    resourceData.inProgress =
                        fullSyncParams.fn.call(...args);
                Promise$g.propagate(resourceData.inProgress, sharedPromise);
                Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 2));
                return resourceData.inProgress;
            }
        };
        const getInWrapper = function (resourceId, ...args) {
            var noDelay = false,
                localThis = getParams.thisBinding || this,
                resourceData = getResourceData(resourceId);
            if (args[0] === Promise$g.NO_DELAY) {
                noDelay = true;
                args.shift();
            } else if (args[0] === Promise$g.BATCH_NO_DELAY) {
                args.shift();
                let batchId = args.shift();
                if (!resourceData.noDelayBatches.has(batchId)) {
                    resourceData.noDelayBatches.add(batchId);
                    noDelay = true;
                }
            }
            if (resourceData.inProgress) {
                return resourceData.inProgress;
            }
            if (
                !noDelay &&
                getParams.delay &&
                resourceData.lastTime &&
                new Date() - resourceData.lastTime < getParams.delay
            ) {
                if (typeof getParams.onDebounce === 'function') {
                    getParams.onDebounce(resourceId, ...args);
                }
                return resourceData.last;
            }
            resourceData.last = resourceData.inProgress = getParams.fn.call(localThis, resourceId, ...args);
            resourceData.inProgressIsFull = false;
            Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 1));
            return resourceData.inProgress;
        };
        const fullSyncInWrapper = function (resourceId, ...args) {
            var delta,
                noDelay = false,
                localThis = fullSyncParams.thisBinding || this,
                resourceData = getResourceData(resourceId);
            if (args[0] === Promise$g.NO_DELAY) {
                noDelay = true;
                args.shift();
            } else if (args[0] === Promise$g.BATCH_NO_DELAY) {
                args.shift();
                let batchId = args.shift();
                if (!resourceData.noDelayBatches.has(batchId)) {
                    resourceData.noDelayBatches.add(batchId);
                    noDelay = true;
                }
            }
            if (
                !resourceData.inProgress &&
                !noDelay &&
                fullSyncParams.delay &&
                resourceData.lastFullSyncTime &&
                (delta = new Date() - resourceData.lastFullSyncTime - fullSyncParams.delay) < 0
            ) {
                resourceData.inProgress = Promise$g.resolveTimeout(-delta + 1);
                Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 0));
            }
            if (resourceData.inProgress) {
                if (!resourceData.nextFullSyncPromise) {
                    resourceData.nextFullSyncPromise = new Promise$g();
                }
                resourceData.nextFullSyncWith = [localThis, resourceId, ...args];
                return resourceData.nextFullSyncPromise;
            }
            resourceData.lastFullSync =
                resourceData.last =
                resourceData.inProgress =
                    fullSyncParams.fn.call(localThis, resourceId, ...args);
            Promise$g.finally(resourceData.inProgress, () => outWrapper(resourceData, 2));
            return resourceData.inProgress;
        };
        return [getInWrapper, fullSyncInWrapper];
    };
    Promise$g.timeout = (timeout, asyncFn, thisBinding) => {
        return function (...args) {
            var promise = asyncFn.call(thisBinding || this, ...args);
            setTimeout(() => promise.reject(new Error('Timeout')), timeout);
            return promise;
        };
    };
    Promise$g.variableTimeout = (asyncFn, thisBinding) => {
        return function (timeout, ...args) {
            var promise = asyncFn.call(thisBinding || this, ...args);
            setTimeout(() => promise.reject(new Error('Timeout')), timeout);
            return promise;
        };
    };
    const Promise$f = seventh_1;
    function Queue(jobRunner, concurrency = 4) {
        this.jobRunner = jobRunner;
        this.jobs = new Map();
        this.pendingJobs = new Map();
        this.runningJobs = new Map();
        this.errorJobs = new Map();
        this.jobsDone = new Map();
        this.concurrency = +concurrency || 1;
        this.isQueueRunning = true;
        this.isLoopRunning = false;
        this.canLoopAgain = false;
        this.ready = Promise$f.resolved;
        this.startTime = null;
        this.endTime = null;
        this.drained = Promise$f.resolved;
        this.idle = Promise$f.resolved;
    }
    Promise$f.Queue = Queue;
    function Job(id, dependencies = null, data = void 0) {
        this.id = id;
        this.dependencies = dependencies === null ? null : [...dependencies];
        this.data = data === void 0 ? id : data;
        this.error = null;
        this.startTime = null;
        this.endTime = null;
    }
    Queue.Job = Job;
    Queue.prototype.setConcurrency = function (concurrency) {
        this.concurrency = +concurrency || 1;
    };
    Queue.prototype.stop = Queue.prototype.pause = function () {
        this.isQueueRunning = false;
    };
    Queue.prototype.has = function (id) {
        return this.jobs.has(id);
    };
    Queue.prototype.add = Queue.prototype.addJob = function (id, data, dependencies = null) {
        if (this.jobs.has(id)) {
            return false;
        }
        var job = new Job(id, dependencies, data);
        this.jobs.set(id, job);
        this.pendingJobs.set(id, job);
        this.canLoopAgain = true;
        if (this.isQueueRunning && !this.isLoopRunning) {
            this.run();
        }
        if (this.drained.isSettled()) {
            this.drained = new Promise$f();
        }
        return job;
    };
    Queue.prototype.addBatch = Queue.prototype.addJobBatch = function (ids) {
        var id, job;
        for (id of ids) {
            if (this.jobs.has(id)) {
                return false;
            }
            job = new Job(id);
            this.jobs.set(id, job);
            this.pendingJobs.set(id, job);
        }
        this.canLoopAgain = true;
        if (this.isQueueRunning && !this.isLoopRunning) {
            this.run();
        }
        if (this.drained.isSettled()) {
            this.drained = new Promise$f();
        }
    };
    Queue.prototype.run = Queue.prototype.resume = function () {
        return __async(this, null, function* () {
            var job;
            this.isQueueRunning = true;
            if (this.isLoopRunning) {
                return;
            }
            this.isLoopRunning = true;
            if (!this.startTime) {
                this.startTime = Date.now();
            }
            do {
                this.canLoopAgain = false;
                for (job of this.pendingJobs.values()) {
                    if (job.dependencies && job.dependencies.some((dependencyId) => !this.jobsDone.has(dependencyId))) {
                        continue;
                    }
                    if (this.idle.isSettled()) {
                        this.idle = new Promise$f();
                    }
                    this.canLoopAgain = true;
                    yield this.ready;
                    if (!this.isQueueRunning) {
                        this.finishRun();
                        return;
                    }
                    this.runJob(job);
                }
            } while (this.canLoopAgain);
            this.finishRun();
        });
    };
    Queue.prototype.finishRun = function () {
        this.isLoopRunning = false;
        if (!this.pendingJobs.size) {
            this.drained.resolve();
        }
        if (!this.runningJobs.size) {
            this.endTime = Date.now();
            this.idle.resolve();
        }
    };
    Queue.prototype.runJob = function (job) {
        return __async(this, null, function* () {
            this.pendingJobs.delete(job.id);
            this.runningJobs.set(job.id, job);
            if (this.runningJobs.size >= this.concurrency) {
                this.ready = new Promise$f();
            }
            try {
                job.startTime = Date.now();
                yield this.jobRunner(job.data);
                job.endTime = Date.now();
                this.jobsDone.set(job.id, job);
                this.canLoopAgain = true;
            } catch (error) {
                job.endTime = Date.now();
                job.error = error;
                this.errorJobs.set(job.id, job);
            }
            this.runningJobs.delete(job.id);
            if (this.runningJobs.size < this.concurrency) {
                this.ready.resolve();
            }
            if (!this.isLoopRunning) {
                if (this.isQueueRunning && this.pendingJobs.size) {
                    this.run();
                } else {
                    this.finishRun();
                }
            }
        });
    };
    Queue.prototype.getJobTimes = function () {
        var job,
            stats = {};
        for (job of this.jobsDone.values()) {
            stats[job.id] = job.endTime - job.startTime;
        }
        return stats;
    };
    Queue.prototype.getStats = function () {
        var job,
            sum = 0,
            stats = {
                pending: this.pendingJobs.size,
                running: this.runningJobs.size,
                failed: this.errorJobs.size,
                done: this.jobsDone.size,
                averageJobTime: null,
                queueTime: null,
            };
        if (this.jobsDone.size) {
            for (job of this.jobsDone.values()) {
                sum += job.endTime - job.startTime;
            }
            stats.averageJobTime = sum / this.jobsDone.size;
        }
        if (this.endTime) {
            stats.queueTime = this.endTime - this.startTime;
        }
        return stats;
    };
    const Promise$e = seventh_1;
    Promise$e.promisifyNodeApi = (api, suffix, multiSuffix, filter, anything) => {
        var keys;
        suffix = suffix || 'Async';
        multiSuffix = multiSuffix || 'AsyncAll';
        filter = filter || ((key) => key[0] !== '_' && !key.endsWith('Sync'));
        if (anything) {
            keys = [];
            for (let key in api) {
                if (typeof api[key] === 'function') {
                    keys.push(key);
                }
            }
        } else {
            keys = Object.keys(api);
        }
        keys.filter((key) => {
            if (typeof api[key] !== 'function') {
                return false;
            }
            for (let trash in api[key].prototype) {
                return false;
            }
            return filter(key, api);
        }).forEach((key) => {
            const targetKey = key + suffix;
            const multiTargetKey = key + multiSuffix;
            if (!api[targetKey]) {
                api[targetKey] = Promise$e.promisify(api[key], api);
            }
            if (!api[multiTargetKey]) {
                api[multiTargetKey] = Promise$e.promisifyAll(api[key], api);
            }
        });
    };
    Promise$e.promisifyAnyNodeApi = (api, suffix, multiSuffix, filter) => {
        Promise$e.promisifyNodeApi(api, suffix, multiSuffix, filter, true);
    };
    const Promise$d = seventh_1;
    Promise$d.parasite = () => {
        var compatibleProtoFn = ['tap', 'tapCatch', 'finally', 'fatal', 'done', 'callback', 'callbackAll'];
        compatibleProtoFn.forEach((fn) => (Promise$d.Native.prototype[fn] = Promise$d.prototype[fn]));
        Promise$d.Native.prototype._then = Promise$d.Native.prototype.then;
    };
    const Promise$c = seventh_1;
    var exitInProgress = false;
    Promise$c.asyncExit = function (exitCode, timeout) {
        if (exitInProgress) {
            return;
        }
        exitInProgress = true;
        var listeners = process.listeners('asyncExit');
        if (!listeners.length) {
            process.exit(exitCode);
            return;
        }
        if (timeout === void 0) {
            timeout = 1e3;
        }
        const callListener = (listener) => {
            if (listener.length < 3) {
                listener(exitCode, timeout);
                return Promise$c.dummy;
            }
            return new Promise$c((resolve) => {
                listener(exitCode, timeout, () => {
                    resolve();
                });
            });
        };
        Promise$c.map(listeners, callListener).finally(() => process.exit(exitCode));
        setTimeout(() => process.exit(exitCode), timeout);
    };
    Promise$c.resolveSafeTimeout = function (timeout, value) {
        return new Promise$c((resolve) => {
            setTimeout(() => {
                setTimeout(() => {
                    setTimeout(() => {
                        setTimeout(() => resolve(value), 0);
                    }, timeout / 2);
                }, timeout / 2);
            }, 0);
        });
    };
    const seventh = core;
    var seventh_1 = seventh;
    var __viteBrowserExternal_child_process = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "child_process" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_child_process$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_child_process,
    });
    var require$$2 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_child_process$1);
    var __viteBrowserExternal_os = new Proxy(
        {},
        {
            get() {
                throw new Error(
                    'Module "os" has been externalized for browser compatibility and cannot be accessed in client code.',
                );
            },
        },
    );
    var __viteBrowserExternal_os$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: __viteBrowserExternal_os,
    });
    var require$$3 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal_os$1);
    const Promise$b = seventh_1;
    const exec = require$$2.exec;
    const path$2 = require$$3$1;
    const os = require$$3;
    const termkit$4 = termkit_1;
    detectTerminal.guessTerminal = function (unpipe) {
        var envVar;
        var isSSH = !!{}.SSH_CONNECTION;
        var isTTY = !!process.stdout.isTTY;
        if (!isTTY && !unpipe) {
            return {
                isTTY,
                isSSH,
                appId: 'none',
                safe: true,
                generic: 'none',
            };
        }
        var platform = os.platform();
        var appId = {}.TERM;
        if (platform === 'darwin') {
            appId = path$2.parse(appId).name;
        }
        var safe = appId !== {}.TERM || {}.TERM;
        var generic = appId;
        switch (appId) {
            case 'xterm':
            case 'xterm-256color':
                if (safe) {
                    break;
                }
                if (platform === 'darwin') {
                    appId = 'osx-256color';
                    break;
                }
                for (envVar in process.env) {
                    if (envVar.match(/KONSOLE/)) {
                        appId = 'konsole';
                        safe = true;
                        break;
                    }
                }
                break;
            case 'linux':
            case 'aterm':
            case 'kuake':
            case 'tilda':
            case 'terminology':
            case 'wterm':
            case 'mrxvt':
                break;
            case 'gnome':
            case 'gnome-256color':
            case 'gnome-terminal':
            case 'gnome-terminal-256color':
            case 'terminator':
            case 'guake':
                appId = 'gnome';
                break;
            case 'konsole':
                appId = 'konsole';
                break;
            case 'rxvt':
            case 'rxvt-xpm':
            case 'rxvt-unicode-256color':
            case 'urxvt256c':
            case 'urxvt256c-ml':
            case 'rxvt-unicode':
            case 'urxvt':
            case 'urxvt-ml':
                {
                    appId = 'rxvt';
                }
                break;
            case 'xfce':
            case 'xfce-terminal':
            case 'xfce4-terminal':
                appId = 'xfce';
                break;
            case 'eterm':
            case 'Eterm':
                appId = 'eterm';
                break;
            case 'atomic-terminal':
                appId = 'atomic-terminal';
                break;
            case 'xterm-kitty':
            case 'kitty':
                appId = 'kitty';
                break;
            case 'iTerm':
            case 'iterm':
            case 'iTerm2':
            case 'iterm2':
            case 'Terminal':
            case 'terminal':
            case 'Apple_Terminal':
                appId = 'osx-256color';
                break;
            default:
                if (!appId) {
                    generic = 'unknown';
                } else {
                    generic = appId = generic.toLowerCase();
                }
                break;
        }
        return {
            isTTY,
            isSSH,
            appId,
            safe,
            generic: safe ? appId : generic,
        };
    };
    function getParentProcess(pid) {
        var parentPid, appName;
        return new Promise$b((resolve, reject) => {
            exec('ps -h -o ppid -p ' + pid, (error, stdout) => {
                if (error) {
                    reject(error);
                    return;
                }
                parentPid = parseInt(stdout.match(/[0-9]+/gm)[0], 10);
                if (!parentPid) {
                    reject(new Error("Couldn't get parent PID"));
                    return;
                }
                exec('ps -h -o comm -p ' + parentPid, (error_, stdout_) => {
                    if (error_) {
                        reject(error_);
                        return;
                    }
                    appName = stdout_.trim();
                    resolve({ pid: parentPid, appName });
                });
            });
        });
    }
    detectTerminal.getParentTerminalInfo = function (callback) {
        return __async(this, null, function* () {
            var loopAgain,
                appName,
                appNames = [],
                appId,
                pid = process.pid;
            var platform = os.platform();
            var t256color = {}.COLORTERM;
            var tTrueColor = {}.COLORTERM;
            try {
                loopAgain = true;
                while (loopAgain) {
                    ({ appName, pid } = yield getParentProcess(pid));
                    if (platform === 'darwin') {
                        appName = path$2.parse(appName).name;
                    }
                    appNames.push(appName);
                    loopAgain = false;
                    switch (appName) {
                        case 'linux':
                        case 'xterm':
                        case 'konsole':
                        case 'gnome-terminal':
                        case 'aterm':
                        case 'guake':
                        case 'kuake':
                        case 'tilda':
                        case 'terminology':
                        case 'wterm':
                        case 'mrxvt':
                            appId = t256color || tTrueColor ? appName + '-256color' : appName;
                            break;
                        case 'atomic-terminal':
                            appId = appName;
                            break;
                        case 'login':
                            appName = 'linux';
                            appId = appName;
                            break;
                        case 'terminator':
                            appId = t256color || tTrueColor ? 'gnome-256color' : 'gnome';
                            break;
                        case 'rxvt':
                        case 'urxvt256c':
                        case 'urxvt256c-ml':
                            appId = 'rxvt-256color';
                            break;
                        case 'urxvt':
                        case 'urxvt-ml':
                            appId = 'rxvt';
                            break;
                        case 'xfce4-terminal':
                            appId = 'xfce';
                            break;
                        case 'gnome-terminal-':
                            appName = 'gnome-terminal';
                            appId = t256color || tTrueColor ? 'gnome-256color' : 'gnome';
                            break;
                        case 'Eterm':
                        case 'eterm':
                            appName = 'Eterm';
                            appId = t256color || tTrueColor ? 'eterm-256color' : 'eterm';
                            break;
                        case 'kitty':
                            appName = appId = 'kitty';
                            break;
                        case 'iTerm':
                        case 'iTerm2':
                        case 'Terminal':
                            appId = 'osx-256color';
                            break;
                        default:
                            if (appName.match(/gnome-terminal/)) {
                                appName = 'gnome-terminal';
                                appId = t256color || tTrueColor ? 'gnome-256color' : 'gnome';
                                break;
                            }
                            if (!pid || pid === 1) {
                                throw new Error('Terminal not found, app names: ' + appNames.join(', '));
                            }
                            loopAgain = true;
                    }
                }
            } catch (error_) {
                if (callback) {
                    callback(error_);
                    return;
                }
                throw error_;
            }
            var result = {
                appId,
                appName,
                pid,
                safe: true,
            };
            if (callback) {
                callback(void 0, result);
                return;
            }
            return result;
        });
    };
    detectTerminal.getDetectedTerminal = function (callback) {
        return __async(this, null, function* () {
            var terminal,
                info,
                guessed = termkit$4.guessTerminal();
            if (guessed.safe || guessed.isSSH) {
                terminal = termkit$4.createTerminal({
                    stdin: process.stdin,
                    stdout: process.stdout,
                    stderr: process.stderr,
                    generic: 'unknown',
                    appId: guessed.safe ? guessed.appId : void 0,
                    isTTY: guessed.isTTY,
                    isSSH: guessed.isSSH,
                    processSigwinch: true,
                    preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch,
                });
                if (callback) {
                    callback(void 0, terminal);
                }
                return terminal;
            }
            try {
                info = yield termkit$4.getParentTerminalInfo();
                terminal = termkit$4.createTerminal({
                    stdin: process.stdin,
                    stdout: process.stdout,
                    stderr: process.stderr,
                    generic: ({}.TERM && {}.TERM.toLowerCase()) || 'unknown',
                    appId: info.appId,
                    appName: info.appName,
                    isTTY: guessed.isTTY,
                    isSSH: guessed.isSSH,
                    pid: info.pid,
                    processSigwinch: true,
                    preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch,
                });
            } catch (error) {
                terminal = termkit$4.createTerminal({
                    stdin: process.stdin,
                    stdout: process.stdout,
                    stderr: process.stderr,
                    generic: 'unknown',
                    appId: guessed.safe ? guessed.appId : void 0,
                    isTTY: guessed.isTTY,
                    isSSH: guessed.isSSH,
                    processSigwinch: true,
                    preferProcessSigwinch: !!termkit$4.globalConfig.preferProcessSigwinch,
                });
            }
            if (callback) {
                callback(void 0, terminal);
            }
            return terminal;
        });
    };
    function extend(options, target, ...sources) {
        var i,
            source,
            newTarget = false,
            length = sources.length;
        if (!length) {
            return target;
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        var runtime = { depth: 0, prefix: '' };
        if (options.deep) {
            if (Array.isArray(options.deep)) {
                options.deep = new Set(options.deep);
            } else if (!(options.deep instanceof Set)) {
                options.deep = true;
            }
        }
        if (options.immutables) {
            if (Array.isArray(options.immutables)) {
                options.immutables = new Set(options.immutables);
            } else if (!(options.immutables instanceof Set)) {
                delete options.immutables;
            }
        }
        if (!options.maxDepth && options.deep && !options.circular) {
            options.maxDepth = 100;
        }
        if (options.deepFunc) {
            options.deep = true;
        }
        if (options.flat) {
            options.deep = true;
            options.proto = false;
            options.inherit = false;
            options.unflat = false;
            if (typeof options.flat !== 'string') {
                options.flat = '.';
            }
        }
        if (options.unflat) {
            options.deep = false;
            options.proto = false;
            options.inherit = false;
            options.flat = false;
            if (typeof options.unflat !== 'string') {
                options.unflat = '.';
            }
        }
        if (options.inherit) {
            options.own = true;
            options.proto = false;
        } else if (options.proto) {
            options.own = true;
        }
        if (!target || (typeof target !== 'object' && typeof target !== 'function')) {
            newTarget = true;
        }
        if (!options.skipRoot && (options.inherit || options.proto)) {
            for (i = length - 1; i >= 0; i--) {
                source = sources[i];
                if (source && (typeof source === 'object' || typeof source === 'function')) {
                    if (options.inherit) {
                        if (newTarget) {
                            target = Object.create(source);
                        } else {
                            Object.setPrototypeOf(target, source);
                        }
                    } else if (options.proto) {
                        if (newTarget) {
                            target = Object.create(Object.getPrototypeOf(source));
                        } else {
                            Object.setPrototypeOf(target, Object.getPrototypeOf(source));
                        }
                    }
                    break;
                }
            }
        } else if (newTarget) {
            target = {};
        }
        runtime.references = { sources: [], targets: [] };
        for (i = 0; i < length; i++) {
            source = sources[i];
            if (!source || (typeof source !== 'object' && typeof source !== 'function')) {
                continue;
            }
            extendOne(runtime, options, target, source);
        }
        return target;
    }
    var extend_1 = extend;
    function extendOne(runtime, options, target, source) {
        var j,
            jmax,
            sourceKeys,
            sourceKey,
            sourceValue,
            sourceValueProto,
            value,
            sourceDescriptor,
            targetKey,
            targetPointer,
            path,
            indexOfSource = -1;
        if (options.maxDepth && runtime.depth > options.maxDepth) {
            throw new Error('[tree] extend(): max depth reached(' + options.maxDepth + ')');
        }
        if (options.circular) {
            runtime.references.sources.push(source);
            runtime.references.targets.push(target);
        }
        if (options.own) {
            if (options.nonEnum) {
                sourceKeys = Object.getOwnPropertyNames(source);
            } else {
                sourceKeys = Object.keys(source);
            }
        } else {
            sourceKeys = source;
        }
        for (sourceKey in sourceKeys) {
            if (options.own) {
                sourceKey = sourceKeys[sourceKey];
            }
            if (sourceKey === '__proto__') {
                continue;
            }
            if (options.descriptor) {
                sourceDescriptor = Object.getOwnPropertyDescriptor(source, sourceKey);
                sourceValue = sourceDescriptor.value;
            } else {
                sourceValue = source[sourceKey];
            }
            targetPointer = target;
            targetKey = runtime.prefix + sourceKey;
            if (options.nofunc && typeof sourceValue === 'function') {
                continue;
            }
            if (options.unflat && runtime.depth === 0) {
                path = sourceKey.split(options.unflat);
                jmax = path.length - 1;
                if (jmax) {
                    for (j = 0; j < jmax; j++) {
                        if (
                            !targetPointer[path[j]] ||
                            (typeof targetPointer[path[j]] !== 'object' && typeof targetPointer[path[j]] !== 'function')
                        ) {
                            targetPointer[path[j]] = {};
                        }
                        targetPointer = targetPointer[path[j]];
                    }
                    targetKey = runtime.prefix + path[jmax];
                }
            }
            if (
                options.deep &&
                sourceValue &&
                (typeof sourceValue === 'object' || (options.deepFunc && typeof sourceValue === 'function')) &&
                (!options.descriptor || !sourceDescriptor.get) &&
                ((sourceValueProto = Object.getPrototypeOf(sourceValue)) || true) &&
                (!(options.deep instanceof Set) || options.deep.has(sourceValueProto)) &&
                (!options.immutables || !options.immutables.has(sourceValueProto))
            ) {
                if (options.circular) {
                    indexOfSource = runtime.references.sources.indexOf(sourceValue);
                }
                if (options.flat) {
                    if (indexOfSource >= 0) {
                        continue;
                    }
                    extendOne(
                        {
                            depth: runtime.depth + 1,
                            prefix: runtime.prefix + sourceKey + options.flat,
                            references: runtime.references,
                        },
                        options,
                        targetPointer,
                        sourceValue,
                    );
                } else {
                    if (indexOfSource >= 0) {
                        if (options.descriptor) {
                            Object.defineProperty(targetPointer, targetKey, {
                                value: runtime.references.targets[indexOfSource],
                                enumerable: sourceDescriptor.enumerable,
                                writable: sourceDescriptor.writable,
                                configurable: sourceDescriptor.configurable,
                            });
                        } else {
                            targetPointer[targetKey] = runtime.references.targets[indexOfSource];
                        }
                        continue;
                    }
                    if (
                        !targetPointer[targetKey] ||
                        !Object.prototype.hasOwnProperty.call(targetPointer, targetKey) ||
                        (typeof targetPointer[targetKey] !== 'object' && typeof targetPointer[targetKey] !== 'function')
                    ) {
                        if (Array.isArray(sourceValue)) {
                            value = [];
                        } else if (options.proto) {
                            value = Object.create(sourceValueProto);
                        } else if (options.inherit) {
                            value = Object.create(sourceValue);
                        } else {
                            value = {};
                        }
                        if (options.descriptor) {
                            Object.defineProperty(targetPointer, targetKey, {
                                value,
                                enumerable: sourceDescriptor.enumerable,
                                writable: sourceDescriptor.writable,
                                configurable: sourceDescriptor.configurable,
                            });
                        } else {
                            targetPointer[targetKey] = value;
                        }
                    } else if (options.proto && Object.getPrototypeOf(targetPointer[targetKey]) !== sourceValueProto) {
                        Object.setPrototypeOf(targetPointer[targetKey], sourceValueProto);
                    } else if (options.inherit && Object.getPrototypeOf(targetPointer[targetKey]) !== sourceValue) {
                        Object.setPrototypeOf(targetPointer[targetKey], sourceValue);
                    }
                    if (options.circular) {
                        runtime.references.sources.push(sourceValue);
                        runtime.references.targets.push(targetPointer[targetKey]);
                    }
                    extendOne(
                        { depth: runtime.depth + 1, prefix: '', references: runtime.references },
                        options,
                        targetPointer[targetKey],
                        sourceValue,
                    );
                }
            } else if (options.preserve && targetPointer[targetKey] !== void 0) {
                continue;
            } else if (!options.inherit) {
                if (options.descriptor) {
                    Object.defineProperty(targetPointer, targetKey, sourceDescriptor);
                } else {
                    targetPointer[targetKey] = sourceValue;
                }
            }
            if (options.move) {
                delete source[sourceKey];
            }
        }
    }
    function clone(originalObject, circular) {
        var originalProto = Object.getPrototypeOf(originalObject);
        if (clone.opaque.has(originalProto)) {
            return clone.opaque.get(originalProto)(originalObject);
        }
        var propertyIndex,
            descriptor,
            keys,
            current,
            nextSource,
            proto,
            copies = [
                {
                    source: originalObject,
                    target: Array.isArray(originalObject) ? [] : Object.create(originalProto),
                },
            ],
            cloneObject = copies[0].target,
            refMap = new Map();
        refMap.set(originalObject, cloneObject);
        while ((current = copies.shift())) {
            keys = Object.getOwnPropertyNames(current.source);
            for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
                descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
                if (!descriptor.value || typeof descriptor.value !== 'object') {
                    Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                    continue;
                }
                nextSource = descriptor.value;
                if (circular) {
                    if (refMap.has(nextSource)) {
                        descriptor.value = refMap.get(nextSource);
                        Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                        continue;
                    }
                }
                proto = Object.getPrototypeOf(descriptor.value);
                if (clone.opaque.has(proto)) {
                    descriptor.value = clone.opaque.get(proto)(descriptor.value);
                    Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                    continue;
                }
                descriptor.value = Array.isArray(nextSource) ? [] : Object.create(proto);
                if (circular) {
                    refMap.set(nextSource, descriptor.value);
                }
                Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                copies.push({ source: nextSource, target: descriptor.value });
            }
        }
        return cloneObject;
    }
    var clone_1 = clone;
    clone.opaque = new Map();
    clone.opaque.set(Date.prototype, (src) => new Date(src));
    var treePath = {};
    var path$1 = treePath;
    treePath.op = function op(type, object, path, value) {
        var i,
            parts,
            last,
            pointer,
            key,
            isArray = false,
            pathArrayMode = false,
            isGenericSet,
            canBeEmpty = true;
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return;
        }
        if (typeof path === 'string') {
            if (path) {
                parts = path.match(/([.#[\]]|[^.#[\]]+)/g);
            } else {
                parts = [''];
            }
            if (parts[0] === '.') {
                parts.unshift('');
            }
            if (parts[parts.length - 1] === '.') {
                parts.push('');
            }
        } else if (Array.isArray(path)) {
            parts = path;
            pathArrayMode = true;
        } else {
            throw new TypeError('[tree.path] .' + type + '(): the path argument should be a string or an array');
        }
        switch (type) {
            case 'get':
            case 'delete':
                isGenericSet = false;
                break;
            case 'set':
            case 'define':
            case 'inc':
            case 'dec':
            case 'append':
            case 'prepend':
            case 'concat':
            case 'insert':
            case 'autoPush':
                isGenericSet = true;
                break;
            default:
                throw new TypeError("[tree.path] .op(): wrong type of operation '" + type + "'");
        }
        pointer = object;
        last = parts.length - 1;
        for (i = 0; i <= last; i++) {
            if (pathArrayMode) {
                if (key === void 0) {
                    key = parts[i];
                    continue;
                }
                if (!pointer[key] || (typeof pointer[key] !== 'object' && typeof pointer[key] !== 'function')) {
                    if (!isGenericSet) {
                        return void 0;
                    }
                    pointer[key] = {};
                }
                pointer = pointer[key];
                key = parts[i];
                continue;
            } else if (parts[i] === '.') {
                isArray = false;
                if (key === void 0) {
                    if (!canBeEmpty) {
                        canBeEmpty = true;
                        continue;
                    }
                    key = '';
                }
                if (!pointer[key] || (typeof pointer[key] !== 'object' && typeof pointer[key] !== 'function')) {
                    if (!isGenericSet) {
                        return void 0;
                    }
                    pointer[key] = {};
                }
                pointer = pointer[key];
                canBeEmpty = true;
                continue;
            } else if (parts[i] === '#' || parts[i] === '[') {
                isArray = true;
                canBeEmpty = false;
                if (key === void 0) {
                    if (!Array.isArray(pointer)) {
                        return void 0;
                    }
                    continue;
                }
                if (!pointer[key] || !Array.isArray(pointer[key])) {
                    if (!isGenericSet) {
                        return void 0;
                    }
                    pointer[key] = [];
                }
                pointer = pointer[key];
                continue;
            } else if (parts[i] === ']') {
                canBeEmpty = false;
                continue;
            }
            canBeEmpty = false;
            if (!isArray) {
                key = parts[i];
                continue;
            }
            switch (parts[i]) {
                case 'length':
                    key = parts[i];
                    break;
                case 'first':
                    key = 0;
                    break;
                case 'last':
                    key = pointer.length - 1;
                    if (key < 0) {
                        key = 0;
                    }
                    break;
                case 'next':
                    if (!isGenericSet) {
                        return void 0;
                    }
                    key = pointer.length;
                    break;
                case 'insert':
                    if (!isGenericSet) {
                        return void 0;
                    }
                    pointer.unshift(void 0);
                    key = 0;
                    break;
                default:
                    key = parseInt(parts[i], 10);
            }
        }
        switch (type) {
            case 'get':
                return pointer[key];
            case 'delete':
                if (isArray && typeof key === 'number') {
                    pointer.splice(key, 1);
                } else {
                    delete pointer[key];
                }
                return;
            case 'set':
                pointer[key] = value;
                return pointer[key];
            case 'define':
                if (!(key in pointer)) {
                    pointer[key] = value;
                }
                return pointer[key];
            case 'inc':
                if (typeof pointer[key] === 'number') {
                    pointer[key]++;
                } else if (!pointer[key] || typeof pointer[key] !== 'object') {
                    pointer[key] = 1;
                }
                return pointer[key];
            case 'dec':
                if (typeof pointer[key] === 'number') {
                    pointer[key]--;
                } else if (!pointer[key] || typeof pointer[key] !== 'object') {
                    pointer[key] = -1;
                }
                return pointer[key];
            case 'append':
                if (!pointer[key]) {
                    pointer[key] = [value];
                } else if (Array.isArray(pointer[key])) {
                    pointer[key].push(value);
                }
                return pointer[key];
            case 'prepend':
                if (!pointer[key]) {
                    pointer[key] = [value];
                } else if (Array.isArray(pointer[key])) {
                    pointer[key].unshift(value);
                }
                return pointer[key];
            case 'concat':
                if (!pointer[key]) {
                    pointer[key] = value;
                } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
                    pointer[key] = pointer[key].concat(value);
                }
                return pointer[key];
            case 'insert':
                if (!pointer[key]) {
                    pointer[key] = value;
                } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
                    pointer[key] = value.concat(pointer[key]);
                }
                return pointer[key];
            case 'autoPush':
                if (pointer[key] === void 0) {
                    pointer[key] = value;
                } else if (Array.isArray(pointer[key])) {
                    pointer[key].push(value);
                } else {
                    pointer[key] = [pointer[key], value];
                }
                return pointer[key];
        }
    };
    treePath.get = treePath.op.bind(void 0, 'get');
    treePath.delete = treePath.op.bind(void 0, 'delete');
    treePath.set = treePath.op.bind(void 0, 'set');
    treePath.define = treePath.op.bind(void 0, 'define');
    treePath.inc = treePath.op.bind(void 0, 'inc');
    treePath.dec = treePath.op.bind(void 0, 'dec');
    treePath.append = treePath.op.bind(void 0, 'append');
    treePath.prepend = treePath.op.bind(void 0, 'prepend');
    treePath.concat = treePath.op.bind(void 0, 'concat');
    treePath.insert = treePath.op.bind(void 0, 'insert');
    treePath.autoPush = treePath.op.bind(void 0, 'autoPush');
    treePath.prototype = {
        get: function (path) {
            return treePath.get(this, path);
        },
        delete: function (path) {
            return treePath.delete(this, path);
        },
        set: function (path, value) {
            return treePath.set(this, path, value);
        },
        define: function (path, value) {
            return treePath.define(this, path, value);
        },
        inc: function (path, value) {
            return treePath.inc(this, path, value);
        },
        dec: function (path, value) {
            return treePath.dec(this, path, value);
        },
        append: function (path, value) {
            return treePath.append(this, path, value);
        },
        prepend: function (path, value) {
            return treePath.prepend(this, path, value);
        },
        concat: function (path, value) {
            return treePath.concat(this, path, value);
        },
        insert: function (path, value) {
            return treePath.insert(this, path, value);
        },
        autoPush: function (path, value) {
            return treePath.autoPush(this, path, value);
        },
    };
    treePath.upgrade = function upgrade(object) {
        Object.defineProperties(object, {
            get: { value: treePath.op.bind(void 0, 'get', object) },
            delete: { value: treePath.op.bind(void 0, 'delete', object) },
            set: { value: treePath.op.bind(void 0, 'set', object) },
            define: { value: treePath.op.bind(void 0, 'define', object) },
            inc: { value: treePath.op.bind(void 0, 'inc', object) },
            dec: { value: treePath.op.bind(void 0, 'dec', object) },
            append: { value: treePath.op.bind(void 0, 'append', object) },
            prepend: { value: treePath.op.bind(void 0, 'prepend', object) },
            concat: { value: treePath.op.bind(void 0, 'concat', object) },
            insert: { value: treePath.op.bind(void 0, 'insert', object) },
            autoPush: { value: treePath.op.bind(void 0, 'autoPush', object) },
        });
    };
    const dotPath = {};
    var dotPath_1 = dotPath;
    const EMPTY_PATH = [];
    function toPathArray(path) {
        if (Array.isArray(path)) {
            return path;
        } else if (!path) {
            return EMPTY_PATH;
        } else if (typeof path === 'string') {
            return path.split('.');
        }
        throw new TypeError('[tree.dotPath]: the path argument should be a string or an array');
    }
    function walk(object, pathArray) {
        var i,
            iMax,
            pointer = object;
        for (i = 0, iMax = pathArray.length; i < iMax; i++) {
            if (!pointer || (typeof pointer !== 'object' && typeof pointer !== 'function')) {
                return void 0;
            }
            pointer = pointer[pathArray[i]];
        }
        return pointer;
    }
    function walkBeforeLast(object, pathArray) {
        var i,
            iMax,
            pointer = object;
        for (i = 0, iMax = pathArray.length - 1; i < iMax; i++) {
            if (!pointer || (typeof pointer !== 'object' && typeof pointer !== 'function')) {
                return void 0;
            }
            pointer = pointer[pathArray[i]];
        }
        return pointer;
    }
    function pave(object, pathArray) {
        var i,
            iMax,
            key,
            pointer = object;
        for (i = 0, iMax = pathArray.length - 1; i < iMax; i++) {
            key = pathArray[i];
            if (!pointer[key] || (typeof pointer[key] !== 'object' && typeof pointer[key] !== 'function')) {
                pointer[key] = {};
            }
            pointer = pointer[key];
        }
        return pointer;
    }
    dotPath.get = function (object, path) {
        return walk(object, toPathArray(path));
    };
    dotPath.set = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        pointer[pathArray[pathArray.length - 1]] = value;
        return value;
    };
    dotPath.define = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (!(key in pointer)) {
            pointer[key] = value;
        }
        return value;
    };
    dotPath.inc = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (typeof pointer[key] === 'number') {
            pointer[key]++;
        } else if (!pointer[key] || typeof pointer[key] !== 'object') {
            pointer[key] = 1;
        }
        return value;
    };
    dotPath.dec = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (typeof pointer[key] === 'number') {
            pointer[key]--;
        } else if (!pointer[key] || typeof pointer[key] !== 'object') {
            pointer[key] = -1;
        }
        return value;
    };
    dotPath.concat = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (!pointer[key]) {
            pointer[key] = value;
        } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
            pointer[key] = pointer[key].concat(value);
        }
        return value;
    };
    dotPath.insert = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (!pointer[key]) {
            pointer[key] = value;
        } else if (Array.isArray(pointer[key]) && Array.isArray(value)) {
            pointer[key] = value.concat(pointer[key]);
        }
        return value;
    };
    dotPath.delete = function (object, path) {
        var pathArray = toPathArray(path);
        var pointer = walkBeforeLast(object, pathArray);
        if (!pointer || (typeof pointer !== 'object' && typeof pointer !== 'function')) {
            return false;
        }
        return delete pointer[pathArray[pathArray.length - 1]];
    };
    dotPath.autoPush = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (pointer[key] === void 0) {
            pointer[key] = value;
        } else if (Array.isArray(pointer[key])) {
            pointer[key].push(value);
        } else {
            pointer[key] = [pointer[key], value];
        }
        return pointer[key];
    };
    dotPath.append = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (!pointer[key]) {
            pointer[key] = [value];
        } else if (Array.isArray(pointer[key])) {
            pointer[key].push(value);
        }
        return pointer[key];
    };
    dotPath.prepend = function (object, path, value) {
        if (!object || (typeof object !== 'object' && typeof object !== 'function')) {
            return void 0;
        }
        var pathArray = toPathArray(path);
        var pointer = pave(object, pathArray);
        var key = pathArray[pathArray.length - 1];
        if (!pointer[key]) {
            pointer[key] = [value];
        } else if (Array.isArray(pointer[key])) {
            pointer[key].unshift(value);
        }
        return pointer[key];
    };
    var lazy$1 = {};
    lazy$1.defineLazyProperty = function defineLazyProperty(object, name2, func) {
        Object.defineProperty(object, name2, {
            configurable: true,
            enumerable: true,
            get: function () {
                var value = func();
                Object.defineProperty(object, name2, {
                    configurable: true,
                    enumerable: true,
                    writable: false,
                    value,
                });
                return value;
            },
        });
    };
    var diff$1 = {};
    function diff(left, right, options) {
        var i, key, keyPath, leftKeys, rightKeys, leftTypeof, rightTypeof, depth, diffObject, length, arrayMode;
        leftTypeof = typeof left;
        rightTypeof = typeof right;
        if (
            !left ||
            (leftTypeof !== 'object' && leftTypeof !== 'function') ||
            !right ||
            (rightTypeof !== 'object' && rightTypeof !== 'function')
        ) {
            throw new Error('[tree] diff() needs objects as argument #0 and #1');
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        depth = options.depth || 0;
        if (!depth) {
            options.diffObject = {};
            if (!options.path) {
                options.path = '';
            }
            if (!options.pathSeparator) {
                options.pathSeparator = '.';
            }
        }
        diffObject = options.diffObject;
        if (Array.isArray(left)) {
            arrayMode = true;
            length = left.length;
        } else {
            arrayMode = false;
            leftKeys = Object.keys(left);
            length = leftKeys.length;
        }
        for (i = 0; i < length; i++) {
            key = arrayMode ? i : leftKeys[i];
            keyPath = options.path + options.pathSeparator + key;
            if (!Object.prototype.hasOwnProperty.call(right, key)) {
                diffObject[keyPath] = { path: keyPath, message: 'does not exist in right-hand side' };
                continue;
            }
            leftTypeof = typeof left[key];
            rightTypeof = typeof right[key];
            if (leftTypeof !== rightTypeof) {
                diffObject[keyPath] = {
                    path: keyPath,
                    message: 'different typeof: ' + leftTypeof + ' - ' + rightTypeof,
                };
                continue;
            }
            if (leftTypeof === 'object' || leftTypeof === 'function') {
                if (!left[key]) {
                    if (right[key]) {
                        diffObject[keyPath] = { path: keyPath, message: 'different type: null - Object' };
                    }
                    continue;
                }
                if (!right[key]) {
                    diffObject[keyPath] = { path: keyPath, message: 'different type: Object - null' };
                    continue;
                }
                if (Array.isArray(left[key]) && !Array.isArray(right[key])) {
                    diffObject[keyPath] = { path: keyPath, message: 'different type: Array - Object' };
                    continue;
                }
                if (!Array.isArray(left[key]) && Array.isArray(right[key])) {
                    diffObject[keyPath] = { path: keyPath, message: 'different type: Object - Array' };
                    continue;
                }
                diff(left[key], right[key], {
                    path: keyPath,
                    pathSeparator: options.pathSeparator,
                    depth: depth + 1,
                    diffObject,
                });
                continue;
            }
            if (left[key] !== right[key]) {
                diffObject[keyPath] = { path: keyPath, message: 'different value: ' + left[key] + ' - ' + right[key] };
                continue;
            }
        }
        if (Array.isArray(right)) {
            arrayMode = true;
            length = right.length;
        } else {
            arrayMode = false;
            rightKeys = Object.keys(right);
            length = rightKeys.length;
        }
        for (i = 0; i < length; i++) {
            key = arrayMode ? i : rightKeys[i];
            keyPath = options.path + options.pathSeparator + key;
            if (!Object.prototype.hasOwnProperty.call(left, key)) {
                diffObject[keyPath] = { path: keyPath, message: 'does not exist in left-hand side' };
                continue;
            }
        }
        return Object.keys(diffObject).length ? diffObject : null;
    }
    diff$1.diff = diff;
    var tree$2 = tree_1;
    var util = require$$1;
    var masklib = {};
    var mask = masklib;
    masklib.Mask = function Mask() {
        throw new Error('Cannot create a tree.Mask() directly');
    };
    var maskDefaultOptions = {
        clone: false,
        path: '<object>',
        pathSeparator: '.',
    };
    masklib.createMask = function createMask(maskArgument, options) {
        if (maskArgument === null || typeof maskArgument !== 'object') {
            throw new TypeError('[tree] .createMask() : Argument #1 should be an object');
        }
        if (options !== null && typeof options === 'object') {
            options = tree$2.extend(null, {}, maskDefaultOptions, options);
        } else {
            options = maskDefaultOptions;
        }
        var mask = Object.create(masklib.Mask.prototype, {
            __options__: { value: options, writable: true },
        });
        tree$2.extend(null, mask, maskArgument);
        return mask;
    };
    masklib.Mask.prototype.applyTo = function applyTo(input, context, contextOverideDefault) {
        if (input === null || typeof input !== 'object') {
            throw new TypeError('[tree] .applyTo() : Argument #1 should be an object');
        }
        if (contextOverideDefault) {
            context = tree$2.extend(
                null,
                {
                    mask: this,
                    options: this.__options__,
                    path: this.__options__.path,
                },
                context,
            );
        } else if (context === void 0) {
            context = {
                mask: this,
                options: this.__options__,
                path: this.__options__.path,
            };
        }
        var result,
            nextPath,
            output,
            i,
            key,
            maskValue,
            maskKeyList = Object.keys(context.mask),
            j,
            inputKey,
            inputValue,
            inputKeyList;
        if (Array.isArray(input)) {
            output = [];
        } else {
            output = {};
        }
        for (i = 0; i < maskKeyList.length; i++) {
            key = maskKeyList[i];
            maskValue = context.mask[key];
            if (key === '*') {
                inputKeyList = Object.keys(input);
                for (j = 0; j < inputKeyList.length; j++) {
                    inputKey = inputKeyList[j];
                    inputValue = input[inputKey];
                    nextPath = context.path + context.options.pathSeparator + inputKey;
                    if (maskValue !== null && typeof maskValue === 'object') {
                        if (inputValue !== null && typeof inputValue === 'object') {
                            if (inputValue instanceof masklib.Mask) {
                                output[inputKey] = inputValue.applyTo(inputValue, { path: nextPath }, true);
                            } else {
                                output[inputKey] = this.applyTo(
                                    inputValue,
                                    tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                                );
                            }
                        } else if (typeof context.options.leaf === 'function') {
                            output[inputKey] = this.applyTo(
                                {},
                                tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                            );
                        }
                    } else if (maskValue !== null && typeof context.options.leaf === 'function') {
                        result = context.options.leaf(input, inputKey, maskValue, nextPath);
                        if (!(result instanceof Error)) {
                            output[inputKey] = result;
                        }
                    } else if (context.options.clone && inputValue !== null && typeof inputValue === 'object') {
                        output[inputKey] = tree$2.extend({ deep: true }, {}, inputValue);
                    } else {
                        output[inputKey] = inputValue;
                    }
                }
                continue;
            }
            nextPath = context.path + context.options.pathSeparator + key;
            if (maskValue !== null && typeof maskValue === 'object') {
                if (
                    Object.prototype.hasOwnProperty.call(input, key) &&
                    input[key] !== null &&
                    typeof input[key] === 'object'
                ) {
                    if (input.key instanceof masklib.Mask) {
                        output[key] = input.key.applyTo(input[key], { path: nextPath }, true);
                    } else {
                        output[key] = this.applyTo(
                            input[key],
                            tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                        );
                    }
                } else if (context.options.leaf) {
                    output[key] = this.applyTo(
                        {},
                        tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                    );
                }
            } else if (Object.prototype.hasOwnProperty.call(input, key)) {
                if (maskValue !== void 0 && typeof context.options.leaf === 'function') {
                    result = context.options.leaf(input, key, maskValue, nextPath);
                    if (!(result instanceof Error)) {
                        output[key] = result;
                    }
                } else if (context.options.clone && input[key] !== null && typeof input[key] === 'object') {
                    output[key] = tree$2.extend({ deep: true }, {}, input[key]);
                } else {
                    output[key] = input[key];
                }
            } else if (maskValue !== void 0 && typeof context.options.leaf === 'function') {
                result = context.options.leaf(input, key, maskValue, nextPath);
                if (!(result instanceof Error)) {
                    output[key] = result;
                }
            }
        }
        return output;
    };
    masklib.InverseMask = function InverseMask() {
        throw new Error('Cannot create a tree.InverseMask() directly');
    };
    util.inherits(masklib.InverseMask, masklib.Mask);
    masklib.createInverseMask = function createInverseMask(maskArgument, options) {
        if (maskArgument === null || typeof maskArgument !== 'object') {
            throw new TypeError('[tree] .createInverseMask() : Argument #1 should be an object');
        }
        if (options !== null && typeof options === 'object') {
            options = tree$2.extend(null, {}, maskDefaultOptions, options);
        } else {
            options = maskDefaultOptions;
        }
        var mask = Object.create(masklib.InverseMask.prototype, {
            __options__: { value: options, writable: true },
        });
        tree$2.extend(null, mask, maskArgument);
        return mask;
    };
    masklib.InverseMask.prototype.applyTo = function applyTo(input, context, contextOverideDefault) {
        if (input === null || typeof input !== 'object') {
            throw new TypeError('[tree] .applyTo() : Argument #1 should be an object');
        }
        if (contextOverideDefault) {
            context = tree$2.extend(
                null,
                {
                    mask: this,
                    options: this.__options__,
                    path: this.__options__.path,
                },
                context,
            );
        } else if (context === void 0) {
            context = {
                mask: this,
                options: this.__options__,
                path: this.__options__.path,
            };
        }
        var nextPath,
            output,
            i,
            key,
            maskValue,
            maskKeyList = Object.keys(context.mask),
            j,
            inputKey,
            inputValue,
            inputKeyList;
        if (Array.isArray(input)) {
            output = tree$2.extend({ deep: true }, [], input);
        } else {
            output = tree$2.extend({ deep: true }, {}, input);
        }
        for (i = 0; i < maskKeyList.length; i++) {
            key = maskKeyList[i];
            maskValue = context.mask[key];
            if (key === '*') {
                inputKeyList = Object.keys(input);
                for (j = 0; j < inputKeyList.length; j++) {
                    inputKey = inputKeyList[j];
                    inputValue = input[inputKey];
                    nextPath = context.path + context.options.pathSeparator + inputKey;
                    if (maskValue !== null && typeof maskValue === 'object') {
                        if (inputValue !== null && typeof inputValue === 'object') {
                            if (inputValue instanceof masklib.Mask) {
                                output[inputKey] = inputValue.applyTo(inputValue, { path: nextPath }, true);
                            } else {
                                output[inputKey] = this.applyTo(
                                    inputValue,
                                    tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                                );
                            }
                        }
                    } else {
                        delete output[inputKey];
                    }
                }
                continue;
            }
            nextPath = context.path + context.options.pathSeparator + key;
            if (maskValue !== null && typeof maskValue === 'object') {
                if (
                    Object.prototype.hasOwnProperty.call(input, key) &&
                    input[key] !== null &&
                    typeof input[key] === 'object'
                ) {
                    if (input.key instanceof masklib.Mask) {
                        output[key] = input.key.applyTo(input[key], { path: nextPath }, true);
                    } else {
                        output[key] = this.applyTo(
                            input[key],
                            tree$2.extend(null, {}, context, { mask: maskValue, path: nextPath }),
                        );
                    }
                }
            } else if (Object.prototype.hasOwnProperty.call(input, key)) {
                delete output[key];
            }
        }
        return output;
    };
    var tree$1 = {};
    var tree_1 = tree$1;
    Object.assign(
        tree$1,
        {
            extend: extend_1,
            clone: clone_1,
            path: path$1,
            dotPath: dotPath_1,
        },
        lazy$1,
        diff$1,
        mask,
    );
    const name$1 = 'nextgen-events';
    const version = '1.3.4';
    const description = 'The next generation of events handling for javascript! New: abstract away the network!';
    const main = 'lib/NextGenEvents.js';
    const engines = {
        node: '>=6.0.0',
    };
    const directories = {
        test: 'test',
    };
    const dependencies = {};
    const devDependencies = {
        browserify: '^16.2.2',
        'uglify-js-es6': '^2.8.9',
        ws: '^5.1.1',
    };
    const scripts = {
        test: 'tea-time -R dot',
    };
    const repository = {
        type: 'git',
        url: 'https://github.com/cronvel/nextgen-events.git',
    };
    const keywords = [
        'events',
        'async',
        'emit',
        'listener',
        'context',
        'series',
        'serialize',
        'namespace',
        'proxy',
        'network',
    ];
    const author = 'C\xE9dric Ronvel';
    const license = 'MIT';
    const bugs = {
        url: 'https://github.com/cronvel/nextgen-events/issues',
    };
    const config = {
        'tea-time': {
            coverDir: ['lib'],
        },
    };
    const copyright = {
        title: 'Next-Gen Events',
        years: [2015, 2019],
        owner: 'C\xE9dric Ronvel',
    };
    var require$$0 = {
        name: name$1,
        version,
        description,
        main,
        engines,
        directories,
        dependencies,
        devDependencies,
        scripts,
        repository,
        keywords,
        author,
        license,
        bugs,
        config,
        copyright,
    };
    function Proxy$1() {
        this.localServices = {};
        this.remoteServices = {};
        this.nextAckId = 1;
    }
    var _Proxy = Proxy$1;
    var NextGenEvents$5 = NextGenEvents_1;
    var MESSAGE_TYPE = 'NextGenEvents/message';
    function noop() {}
    Proxy$1.create = (...args) => new Proxy$1(...args);
    Proxy$1.prototype.addLocalService = function (id, emitter, options) {
        this.localServices[id] = LocalService.create(this, id, emitter, options);
        return this.localServices[id];
    };
    Proxy$1.prototype.addRemoteService = function (id) {
        this.remoteServices[id] = RemoteService.create(this, id);
        return this.remoteServices[id];
    };
    Proxy$1.prototype.destroy = function () {
        Object.keys(this.localServices).forEach((id) => {
            this.localServices[id].destroy();
            delete this.localServices[id];
        });
        Object.keys(this.remoteServices).forEach((id) => {
            this.remoteServices[id].destroy();
            delete this.remoteServices[id];
        });
        this.receive = this.send = noop;
    };
    Proxy$1.prototype.push = function (message) {
        if (
            message.__type !== MESSAGE_TYPE ||
            !message.service ||
            typeof message.service !== 'string' ||
            !message.event ||
            typeof message.event !== 'string' ||
            !message.method
        ) {
            return;
        }
        switch (message.method) {
            case 'event':
                return (
                    this.remoteServices[message.service] && this.remoteServices[message.service].receiveEvent(message)
                );
            case 'ackEmit':
                return (
                    this.remoteServices[message.service] && this.remoteServices[message.service].receiveAckEmit(message)
                );
            case 'emit':
                return this.localServices[message.service] && this.localServices[message.service].receiveEmit(message);
            case 'listen':
                return (
                    this.localServices[message.service] && this.localServices[message.service].receiveListen(message)
                );
            case 'ignore':
                return (
                    this.localServices[message.service] && this.localServices[message.service].receiveIgnore(message)
                );
            case 'ackEvent':
                return (
                    this.localServices[message.service] && this.localServices[message.service].receiveAckEvent(message)
                );
            default:
                return;
        }
    };
    Proxy$1.prototype.receive = function (raw) {
        this.push(raw);
    };
    Proxy$1.prototype.send = function () {
        throw new Error('The send() method of the Proxy MUST be extended/overwritten');
    };
    function LocalService(proxy, id, emitter, options) {
        return LocalService.create(proxy, id, emitter, options);
    }
    Proxy$1.LocalService = LocalService;
    LocalService.create = function (proxy, id, emitter, options) {
        var self2 = Object.create(LocalService.prototype, {
            proxy: { value: proxy, enumerable: true },
            id: { value: id, enumerable: true },
            emitter: { value: emitter, writable: true, enumerable: true },
            internalEvents: { value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true },
            events: { value: {}, enumerable: true },
            canListen: { value: !!options.listen, writable: true, enumerable: true },
            canEmit: { value: !!options.emit, writable: true, enumerable: true },
            canAck: { value: !!options.ack, writable: true, enumerable: true },
            canRpc: { value: !!options.rpc, writable: true, enumerable: true },
            destroyed: { value: false, writable: true, enumerable: true },
        });
        return self2;
    };
    LocalService.prototype.destroy = function () {
        Object.keys(this.events).forEach((eventName) => {
            this.emitter.off(eventName, this.events[eventName]);
            delete this.events[eventName];
        });
        this.emitter = null;
        this.destroyed = true;
    };
    LocalService.prototype.receiveEmit = function (message) {
        if (this.destroyed || !this.canEmit || (message.ack && !this.canAck)) {
            return;
        }
        var event2 = {
            emitter: this.emitter,
            name: message.event,
            args: message.args || [],
        };
        if (message.ack) {
            event2.callback = (interruption) => {
                this.proxy.send({
                    __type: MESSAGE_TYPE,
                    service: this.id,
                    method: 'ackEmit',
                    ack: message.ack,
                    event: message.event,
                    interruption,
                });
            };
        }
        NextGenEvents$5.emitEvent(event2);
    };
    LocalService.prototype.receiveListen = function (message) {
        if (this.destroyed || !this.canListen || (message.ack && !this.canAck)) {
            return;
        }
        if (message.ack) {
            if (this.events[message.event]) {
                if (this.events[message.event].ack) {
                    return;
                }
                this.emitter.off(message.event, this.events[message.event]);
            }
            this.events[message.event] = LocalService.forwardWithAck.bind(this);
            this.events[message.event].ack = true;
            this.emitter.on(message.event, this.events[message.event], { eventObject: true, async: true });
        } else {
            if (this.events[message.event]) {
                if (!this.events[message.event].ack) {
                    return;
                }
                this.emitter.off(message.event, this.events[message.event]);
            }
            this.events[message.event] = LocalService.forward.bind(this);
            this.events[message.event].ack = false;
            this.emitter.on(message.event, this.events[message.event], { eventObject: true });
        }
    };
    LocalService.prototype.receiveIgnore = function (message) {
        if (this.destroyed || !this.canListen) {
            return;
        }
        if (!this.events[message.event]) {
            return;
        }
        this.emitter.off(message.event, this.events[message.event]);
        this.events[message.event] = null;
    };
    LocalService.prototype.receiveAckEvent = function (message) {
        if (
            this.destroyed ||
            !this.canListen ||
            !this.canAck ||
            !message.ack ||
            !this.events[message.event] ||
            !this.events[message.event].ack
        ) {
            return;
        }
        this.internalEvents.emit('ack', message);
    };
    LocalService.forward = function (event2) {
        if (this.destroyed) {
            return;
        }
        this.proxy.send({
            __type: MESSAGE_TYPE,
            service: this.id,
            method: 'event',
            event: event2.name,
            args: event2.args,
        });
    };
    LocalService.forward.ack = false;
    LocalService.forwardWithAck = function (event2, callback) {
        if (this.destroyed) {
            return;
        }
        if (!event2.callback) {
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'event',
                event: event2.name,
                args: event2.args,
            });
            callback();
            return;
        }
        var triggered = false;
        var ackId = this.proxy.nextAckId++;
        var onAck = (message) => {
            if (triggered || message.ack !== ackId) {
                return;
            }
            triggered = true;
            this.internalEvents.off('ack', onAck);
            callback();
        };
        this.internalEvents.on('ack', onAck);
        this.proxy.send({
            __type: MESSAGE_TYPE,
            service: this.id,
            method: 'event',
            event: event2.name,
            ack: ackId,
            args: event2.args,
        });
    };
    LocalService.forwardWithAck.ack = true;
    function RemoteService(proxy, id) {
        return RemoteService.create(proxy, id);
    }
    Proxy$1.RemoteService = RemoteService;
    var EVENT_NO_ACK = 1;
    var EVENT_ACK = 2;
    RemoteService.create = function (proxy, id) {
        var self2 = Object.create(RemoteService.prototype, {
            proxy: { value: proxy, enumerable: true },
            id: { value: id, enumerable: true },
            emitter: { value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true },
            internalEvents: { value: Object.create(NextGenEvents$5.prototype), writable: true, enumerable: true },
            events: { value: {}, enumerable: true },
            destroyed: { value: false, writable: true, enumerable: true },
        });
        return self2;
    };
    RemoteService.prototype.destroy = function () {
        this.emitter.removeAllListeners();
        this.emitter = null;
        Object.keys(this.events).forEach((eventName) => {
            delete this.events[eventName];
        });
        this.destroyed = true;
    };
    RemoteService.prototype.emit = function (eventName, ...args) {
        if (this.destroyed) {
            return;
        }
        var callback, ackId, triggered;
        if (typeof eventName === 'number') {
            throw new TypeError('Cannot emit with a nice value on a remote service');
        }
        if (typeof args[args.length - 1] !== 'function') {
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'emit',
                event: eventName,
                args,
            });
            return;
        }
        callback = args.pop();
        ackId = this.proxy.nextAckId++;
        triggered = false;
        var onAck = (message) => {
            if (triggered || message.ack !== ackId) {
                return;
            }
            triggered = true;
            this.internalEvents.off('ack', onAck);
            callback(message.interruption);
        };
        this.internalEvents.on('ack', onAck);
        this.proxy.send({
            __type: MESSAGE_TYPE,
            service: this.id,
            method: 'emit',
            ack: ackId,
            event: eventName,
            args,
        });
    };
    RemoteService.prototype.addListener = function (eventName, fn, options) {
        if (this.destroyed) {
            return;
        }
        if (typeof fn !== 'function') {
            options = fn;
            fn = void 0;
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        options.fn = fn || options.fn;
        this.emitter.addListener(eventName, options);
        if (!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) {
            return;
        }
        if (options.async && this.events[eventName] !== EVENT_ACK) {
            this.events[eventName] = EVENT_ACK;
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'listen',
                ack: true,
                event: eventName,
            });
        } else if (!options.async && !this.events[eventName]) {
            this.events[eventName] = EVENT_NO_ACK;
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'listen',
                event: eventName,
            });
        }
    };
    RemoteService.prototype.on = RemoteService.prototype.addListener;
    RemoteService.prototype.once = NextGenEvents$5.prototype.once;
    RemoteService.prototype.removeListener = function (eventName, id) {
        if (this.destroyed) {
            return;
        }
        this.emitter.removeListener(eventName, id);
        if (
            (!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) &&
            this.events[eventName]
        ) {
            this.events[eventName] = 0;
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'ignore',
                event: eventName,
            });
        }
    };
    RemoteService.prototype.off = RemoteService.prototype.removeListener;
    RemoteService.prototype.receiveEvent = function (message) {
        if (this.destroyed || !this.events[message.event]) {
            return;
        }
        var event2 = {
            emitter: this.emitter,
            name: message.event,
            args: message.args || [],
        };
        if (message.ack) {
            event2.callback = () => {
                this.proxy.send({
                    __type: MESSAGE_TYPE,
                    service: this.id,
                    method: 'ackEvent',
                    ack: message.ack,
                    event: message.event,
                });
            };
        }
        NextGenEvents$5.emitEvent(event2);
        var eventName = event2.name;
        if (!this.emitter.__ngev.listeners[eventName] || !this.emitter.__ngev.listeners[eventName].length) {
            this.events[eventName] = 0;
            this.proxy.send({
                __type: MESSAGE_TYPE,
                service: this.id,
                method: 'ignore',
                event: eventName,
            });
        }
    };
    RemoteService.prototype.receiveAckEmit = function (message) {
        if (this.destroyed || !message.ack || this.events[message.event] !== EVENT_ACK) {
            return;
        }
        this.internalEvents.emit('ack', message);
    };
    const nextTick = process.browser ? window.setImmediate : process.nextTick;
    if (!commonjsGlobal$1.__NEXTGEN_EVENTS__) {
        commonjsGlobal$1.__NEXTGEN_EVENTS__ = {
            recursions: 0,
        };
    }
    var globalData = commonjsGlobal$1.__NEXTGEN_EVENTS__;
    function NextGenEvents$4() {}
    var NextGenEvents_1 = NextGenEvents$4;
    NextGenEvents$4.prototype.__prototypeUID__ = 'nextgen-events/NextGenEvents';
    NextGenEvents$4.prototype.__prototypeVersion__ = require$$0.version;
    NextGenEvents$4.SYNC = -Infinity;
    NextGenEvents$4.DESYNC = -1;
    NextGenEvents$4.defaultMaxListeners = Infinity;
    NextGenEvents$4.init = function () {
        Object.defineProperty(this, '__ngev', {
            configurable: true,
            value: new NextGenEvents$4.Internal(),
        });
    };
    NextGenEvents$4.Internal = function (from) {
        this.nice = NextGenEvents$4.SYNC;
        this.interruptible = false;
        this.contexts = {};
        this.desync = setImmediate;
        this.depth = 0;
        this.states = {};
        this.stateGroups = {};
        this.listeners = {
            error: [],
            interrupt: [],
            newListener: [],
            removeListener: [],
        };
        this.hasListenerPriority = false;
        this.maxListeners = NextGenEvents$4.defaultMaxListeners;
        if (from) {
            this.nice = from.nice;
            this.interruptible = from.interruptible;
            Object.assign(this.states, from.states),
                Object.assign(this.stateGroups, from.stateGroups),
                Object.keys(from.listeners).forEach((eventName) => {
                    this.listeners[eventName] = from.listeners[eventName].slice();
                });
            Object.keys(from.contexts).forEach((contextName) => {
                var context = from.contexts[contextName];
                this.contexts[contextName] = {
                    nice: context.nice,
                    ready: true,
                    status: context.status,
                    serial: context.serial,
                    scopes: {},
                };
            });
        }
    };
    NextGenEvents$4.initFrom = function (from) {
        if (!from.__ngev) {
            NextGenEvents$4.init.call(from);
        }
        Object.defineProperty(this, '__ngev', {
            configurable: true,
            value: new NextGenEvents$4.Internal(from.__ngev),
        });
    };
    NextGenEvents$4.mergeListeners = function (foreigners) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        var oldListeners = this.__ngev.listeners;
        this.__ngev.listeners = {};
        Object.keys(oldListeners).forEach((eventName) => {
            this.__ngev.listeners[eventName] = [];
        });
        foreigners.forEach((foreigner) => {
            if (!foreigner.__ngev) {
                NextGenEvents$4.init.call(foreigner);
            }
            Object.keys(foreigner.__ngev.listeners).forEach((eventName) => {
                if (!this.__ngev.listeners[eventName]) {
                    this.__ngev.listeners[eventName] = [];
                }
            });
        });
        Object.keys(this.__ngev.listeners).forEach((eventName) => {
            var i,
                iMax,
                blacklist = [];
            if (oldListeners[eventName]) {
                oldListeners[eventName].forEach((listener) => {
                    for (i = 0, iMax = foreigners.length; i < iMax; i++) {
                        if (
                            !foreigners[i].__ngev.listeners[eventName] ||
                            foreigners[i].__ngev.listeners[eventName].indexOf(listener) === -1
                        ) {
                            blacklist.push(listener);
                            break;
                        }
                    }
                });
            }
            foreigners.forEach((foreigner) => {
                foreigner.__ngev.listeners[eventName].forEach((listener) => {
                    if (
                        this.__ngev.listeners[eventName].indexOf(listener) === -1 &&
                        blacklist.indexOf(listener) === -1
                    ) {
                        this.__ngev.listeners[eventName].push(listener);
                    }
                });
            });
        });
    };
    NextGenEvents$4.filterOutCallback = function (what, currentElement) {
        return what !== currentElement;
    };
    NextGenEvents$4.prototype.addListener = function (eventName, fn, options) {
        var listener, newListenerListeners;
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!this.__ngev.listeners[eventName]) {
            this.__ngev.listeners[eventName] = [];
        }
        if (!eventName || typeof eventName !== 'string') {
            throw new TypeError('.addListener(): argument #0 should be a non-empty string');
        }
        if (typeof fn === 'function') {
            listener = {};
            if (!options || typeof options !== 'object') {
                options = {};
            }
        } else if (options === true && fn && typeof fn === 'object') {
            options = listener = fn;
            fn = void 0;
        } else {
            options = fn;
            if (!options || typeof options !== 'object') {
                throw new TypeError(
                    ".addListener(): a function or an object with a 'fn' property which value is a function should be provided",
                );
            }
            fn = void 0;
            listener = {};
        }
        listener.fn = fn || options.fn;
        listener.id = options.id !== void 0 ? options.id : listener.fn;
        listener.once = !!options.once;
        listener.async = !!options.async;
        listener.eventObject = !!options.eventObject;
        listener.nice = options.nice !== void 0 ? Math.floor(options.nice) : NextGenEvents$4.SYNC;
        listener.priority = +options.priority || 0;
        listener.context =
            options.context && (typeof options.context === 'string' || typeof options.context === 'object')
                ? options.context
                : null;
        if (typeof listener.fn !== 'function') {
            throw new TypeError(
                ".addListener(): a function or an object with a 'fn' property which value is a function should be provided",
            );
        }
        if (typeof listener.context === 'string') {
            listener.context = this.__ngev.contexts[listener.context] || this.addListenerContext(listener.context);
        }
        listener.event = eventName;
        if (this.__ngev.listeners.newListener.length) {
            newListenerListeners = this.__ngev.listeners.newListener.slice();
            this.__ngev.listeners[eventName].push(listener);
            NextGenEvents$4.emitEvent({
                emitter: this,
                name: 'newListener',
                args: [[listener]],
                listeners: newListenerListeners,
            });
            if (this.__ngev.states[eventName]) {
                NextGenEvents$4.emitToOneListener(this.__ngev.states[eventName], listener);
            }
            return this;
        }
        this.__ngev.listeners[eventName].push(listener);
        if (this.__ngev.hasListenerPriority) {
            this.__ngev.listeners[eventName].sort((a, b) => b.priority - a.priority);
        }
        if (this.__ngev.listeners[eventName].length === this.__ngev.maxListeners + 1) {
            process.emitWarning(
                'Possible NextGenEvents memory leak detected. ' +
                    this.__ngev.listeners[eventName].length +
                    ' ' +
                    eventName +
                    ' listeners added. Use emitter.setMaxListeners() to increase limit',
                { type: 'MaxListenersExceededWarning' },
            );
        }
        if (this.__ngev.states[eventName]) {
            NextGenEvents$4.emitToOneListener(this.__ngev.states[eventName], listener);
        }
        return this;
    };
    NextGenEvents$4.prototype.on = NextGenEvents$4.prototype.addListener;
    NextGenEvents$4.prototype.once = function (eventName, fn, options) {
        if (fn && typeof fn === 'object') {
            fn.once = true;
        } else if (options && typeof options === 'object') {
            options.once = true;
        } else {
            options = { once: true };
        }
        return this.addListener(eventName, fn, options);
    };
    NextGenEvents$4.prototype.waitFor = function (eventName) {
        return new Promise((resolve) => {
            this.addListener(eventName, (firstArg) => resolve(firstArg), { once: true });
        });
    };
    NextGenEvents$4.prototype.waitForAll = function (eventName) {
        return new Promise((resolve) => {
            this.addListener(eventName, (...args) => resolve(args), { once: true });
        });
    };
    NextGenEvents$4.prototype.removeListener = function (eventName, id) {
        if (!eventName || typeof eventName !== 'string') {
            throw new TypeError('.removeListener(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        var listeners = this.__ngev.listeners[eventName];
        if (!listeners || !listeners.length) {
            return this;
        }
        var i,
            removedListeners,
            removeCount = 0,
            length = listeners.length,
            hasRemoveListener = this.__ngev.listeners.removeListener.length;
        if (hasRemoveListener) {
            removedListeners = [];
        }
        for (i = 0; i < length; i++) {
            if (listeners[i].id === id) {
                removeCount++;
                if (hasRemoveListener) {
                    removedListeners.push(listeners[i]);
                }
            } else if (removeCount) {
                listeners[i - removeCount] = listeners[i];
            }
        }
        if (removeCount) {
            listeners.length -= removeCount;
        }
        if (hasRemoveListener && removedListeners.length) {
            this.emit('removeListener', removedListeners);
        }
        return this;
    };
    NextGenEvents$4.prototype.off = NextGenEvents$4.prototype.removeListener;
    NextGenEvents$4.prototype.removeAllListeners = function (eventName) {
        var removedListeners;
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (eventName) {
            if (!eventName || typeof eventName !== 'string') {
                throw new TypeError('.removeAllListeners(): argument #0 should be undefined or a non-empty string');
            }
            if (!this.__ngev.listeners[eventName]) {
                this.__ngev.listeners[eventName] = [];
            }
            removedListeners = this.__ngev.listeners[eventName];
            this.__ngev.listeners[eventName] = [];
            if (removedListeners.length && this.__ngev.listeners.removeListener.length) {
                this.emit('removeListener', removedListeners);
            }
        } else {
            this.__ngev.listeners = {
                error: [],
                interrupt: [],
                newListener: [],
                removeListener: [],
            };
        }
        return this;
    };
    NextGenEvents$4.listenerWrapper = function (listener, event2, contextScope, serial, nice) {
        var returnValue,
            listenerCallback,
            eventMaster = event2.master || event2,
            interruptible = !!event2.master || event2.emitter.__ngev.interruptible;
        if (eventMaster.interrupt) {
            return;
        }
        if (listener.async) {
            if (contextScope) {
                contextScope.ready = !serial;
            }
            if (nice < 0) {
                if (globalData.recursions >= -nice) {
                    event2.emitter.__ngev.desync(
                        NextGenEvents$4.listenerWrapper.bind(
                            void 0,
                            listener,
                            event2,
                            contextScope,
                            serial,
                            NextGenEvents$4.SYNC,
                        ),
                    );
                    return;
                }
            } else {
                setTimeout(
                    NextGenEvents$4.listenerWrapper.bind(
                        void 0,
                        listener,
                        event2,
                        contextScope,
                        serial,
                        NextGenEvents$4.SYNC,
                    ),
                    nice,
                );
                return;
            }
            listenerCallback = (arg) => {
                eventMaster.listenersDone++;
                if (arg && interruptible && !eventMaster.interrupt && event2.name !== 'interrupt') {
                    eventMaster.interrupt = arg;
                    if (eventMaster.callback) {
                        NextGenEvents$4.emitCallback(event2);
                    }
                    event2.emitter.emit('interrupt', eventMaster.interrupt);
                } else if (eventMaster.listenersDone >= eventMaster.listeners.length && eventMaster.callback) {
                    NextGenEvents$4.emitCallback(event2);
                }
                if (serial) {
                    NextGenEvents$4.processScopeQueue(contextScope, true, true);
                }
            };
            if (listener.eventObject) {
                listener.fn(event2, listenerCallback);
            } else {
                returnValue = listener.fn(...event2.args, listenerCallback);
            }
        } else {
            if (nice < 0) {
                if (globalData.recursions >= -nice) {
                    event2.emitter.__ngev.desync(
                        NextGenEvents$4.listenerWrapper.bind(
                            void 0,
                            listener,
                            event2,
                            contextScope,
                            serial,
                            NextGenEvents$4.SYNC,
                        ),
                    );
                    return;
                }
            } else {
                setTimeout(
                    NextGenEvents$4.listenerWrapper.bind(
                        void 0,
                        listener,
                        event2,
                        contextScope,
                        serial,
                        NextGenEvents$4.SYNC,
                    ),
                    nice,
                );
                return;
            }
            if (listener.eventObject) {
                listener.fn(event2);
            } else {
                returnValue = listener.fn(...event2.args);
            }
            eventMaster.listenersDone++;
        }
        if (returnValue && interruptible && !eventMaster.interrupt && event2.name !== 'interrupt') {
            eventMaster.interrupt = returnValue;
            if (eventMaster.callback) {
                NextGenEvents$4.emitCallback(event2);
            }
            event2.emitter.emit('interrupt', eventMaster.interrupt);
        } else if (eventMaster.listenersDone >= eventMaster.listeners.length && eventMaster.callback) {
            NextGenEvents$4.emitCallback(event2);
        }
    };
    var nextEventId = 0;
    NextGenEvents$4.prototype.emit = function (...args) {
        var event2 = NextGenEvents$4.createEvent(this, ...args);
        return NextGenEvents$4.emitEvent(event2);
    };
    NextGenEvents$4.prototype.emitIfListener = function (...args) {
        var eventName = typeof args[0] === 'number' ? args[1] : args[0];
        if (!this.__ngev || !this.__ngev.listeners[eventName] || !this.__ngev.listeners[eventName].length) {
            return null;
        }
        var event2 = NextGenEvents$4.createEvent(this, ...args);
        return NextGenEvents$4.emitEvent(event2);
    };
    NextGenEvents$4.prototype.waitForEmit = function (...args) {
        return new Promise((resolve) => {
            this.emit(...args, (interrupt) => resolve(interrupt));
        });
    };
    NextGenEvents$4.createEvent = function (emitter, ...args) {
        var event2 = {
            emitter,
            interrupt: null,
            master: null,
            sync: true,
        };
        if (typeof args[0] === 'number') {
            event2.nice = Math.floor(args[0]);
            event2.name = args[1];
            if (!event2.name || typeof event2.name !== 'string') {
                throw new TypeError('.emit(): when argument #0 is a number, argument #1 should be a non-empty string');
            }
            if (typeof args[args.length - 1] === 'function') {
                event2.callback = args[args.length - 1];
                event2.args = args.slice(2, -1);
            } else {
                event2.args = args.slice(2);
            }
        } else {
            event2.name = args[0];
            if (!event2.name || typeof event2.name !== 'string') {
                throw new TypeError('.emit(): argument #0 should be an number or a non-empty string');
            }
            if (typeof args[args.length - 1] === 'function') {
                event2.callback = args[args.length - 1];
                event2.args = args.slice(1, -1);
            } else {
                event2.args = args.slice(1);
            }
        }
        return event2;
    };
    NextGenEvents$4.emitEvent = function (event2) {
        var self2 = event2.emitter,
            i,
            iMax,
            count = 0,
            state,
            removedListeners;
        if (!self2.__ngev) {
            NextGenEvents$4.init.call(self2);
        }
        state = self2.__ngev.states[event2.name];
        if (state !== void 0) {
            if (
                state &&
                event2.args.length === state.args.length &&
                event2.args.every((arg, index) => arg === state.args[index])
            ) {
                return;
            }
            self2.__ngev.stateGroups[event2.name].forEach((eventName) => {
                self2.__ngev.states[eventName] = null;
            });
            self2.__ngev.states[event2.name] = event2;
        }
        if (!self2.__ngev.listeners[event2.name]) {
            self2.__ngev.listeners[event2.name] = [];
        }
        event2.id = nextEventId++;
        event2.listenersDone = 0;
        if (event2.nice === void 0 || event2.nice === null) {
            event2.nice = self2.__ngev.nice;
        }
        if (!event2.listeners) {
            event2.listeners = self2.__ngev.listeners[event2.name].slice();
        }
        globalData.recursions++;
        event2.depth = self2.__ngev.depth++;
        removedListeners = [];
        try {
            for (i = 0, iMax = event2.listeners.length; i < iMax; i++) {
                count++;
                NextGenEvents$4.emitToOneListener(event2, event2.listeners[i], removedListeners);
            }
        } catch (error) {
            globalData.recursions--;
            self2.__ngev.depth--;
            throw error;
        }
        globalData.recursions--;
        if (!event2.callback) {
            self2.__ngev.depth--;
        }
        if (removedListeners.length && self2.__ngev.listeners.removeListener.length) {
            self2.emit('removeListener', removedListeners);
        }
        if (!count) {
            if (event2.name === 'error') {
                if (event2.args[0]) {
                    throw event2.args[0];
                } else {
                    throw Error("Uncaught, unspecified 'error' event.");
                }
            }
            if (event2.callback) {
                NextGenEvents$4.emitCallback(event2);
            }
        }
        event2.sync = false;
        return event2;
    };
    NextGenEvents$4.emitIntricatedEvents = function (array, callback) {
        var i,
            iMax,
            count = 0,
            removedListeners;
        if (!Array.isArray(array)) {
            throw new TypeError('.emitCorrelatedEvents() argument should be an array');
        }
        var listenerEventRows = [],
            context = {
                nice: NextGenEvents$4.DESYNC,
                ready: true,
                status: NextGenEvents$4.CONTEXT_ENABLED,
                serial: true,
                scopes: {},
            },
            master = {
                sync: false,
                nice: NextGenEvents$4.DESYNC,
                context,
                interrupt: null,
                listeners: listenerEventRows,
                listenersDone: 0,
                depth: 0,
                callback,
            };
        array.forEach((eventParams) => {
            var event2 = NextGenEvents$4.createEvent(...eventParams);
            event2.master = master;
            if (!event2.emitter.__ngev) {
                NextGenEvents$4.init.call(event2.emitter);
            }
            if (!event2.emitter.__ngev.listeners[event2.name]) {
                event2.emitter.__ngev.listeners[event2.name] = [];
            }
            event2.listeners = event2.emitter.__ngev.listeners[event2.name].slice();
            event2.id = nextEventId++;
            event2.listeners.forEach((listener) => listenerEventRows.push({ event: event2, listener }));
        });
        listenerEventRows.sort((a, b) => b.listener.priority - a.listener.priority);
        globalData.recursions++;
        removedListeners = [];
        try {
            for (i = 0, iMax = listenerEventRows.length; i < iMax; i++) {
                count++;
                NextGenEvents$4.emitToOneListener(
                    listenerEventRows[i].event,
                    listenerEventRows[i].listener,
                    removedListeners,
                );
            }
        } catch (error) {
            globalData.recursions--;
            throw error;
        }
        globalData.recursions--;
        if (!count && master.callback) {
            NextGenEvents$4.emitCallback(event);
        }
        master.sync = false;
    };
    NextGenEvents$4.emitToOneListener = function (event2, listener, removedListeners) {
        var self2 = event2.emitter,
            eventMaster = event2.master || event2,
            context = event2.master ? event2.master.context : listener.context,
            contextScope,
            serial,
            currentNice,
            emitRemoveListener = false;
        if (context) {
            if (context.status === NextGenEvents$4.CONTEXT_DISABLED) {
                return;
            }
            currentNice = Math.max(eventMaster.nice, listener.nice, context.nice);
            serial = context.serial;
            contextScope = NextGenEvents$4.getContextScope(context, eventMaster.depth);
        } else {
            currentNice = Math.max(eventMaster.nice, listener.nice);
        }
        if (listener.once) {
            self2.__ngev.listeners[event2.name] = self2.__ngev.listeners[event2.name].filter(
                NextGenEvents$4.filterOutCallback.bind(void 0, listener),
            );
            if (removedListeners) {
                removedListeners.push(listener);
            } else {
                emitRemoveListener = true;
            }
        }
        if (context && (context.status === NextGenEvents$4.CONTEXT_QUEUED || !contextScope.ready)) {
            contextScope.queue.push({ event: event2, listener, nice: currentNice });
        } else {
            NextGenEvents$4.listenerWrapper(listener, event2, contextScope, serial, currentNice);
        }
        if (emitRemoveListener && self2.__ngev.listeners.removeListener.length) {
            self2.emit('removeListener', [listener]);
        }
    };
    NextGenEvents$4.emitCallback = function (event2) {
        var callback;
        if (event2.master) {
            callback = event2.master.callback;
            delete event2.master.callback;
            if (event2.master.sync) {
                nextTick(() => callback(event2.master.interrupt, event2));
            } else {
                callback(event2.master.interrupt, event2);
            }
            return;
        }
        callback = event2.callback;
        delete event2.callback;
        if (event2.sync && event2.emitter.__ngev.nice !== NextGenEvents$4.SYNC) {
            event2.emitter.__ngev.desync(() => {
                event2.emitter.__ngev.depth--;
                callback(event2.interrupt, event2);
            });
        } else {
            event2.emitter.__ngev.depth--;
            callback(event2.interrupt, event2);
        }
    };
    NextGenEvents$4.prototype.listeners = function (eventName) {
        if (!eventName || typeof eventName !== 'string') {
            throw new TypeError('.listeners(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!this.__ngev.listeners[eventName]) {
            this.__ngev.listeners[eventName] = [];
        }
        return this.__ngev.listeners[eventName].slice();
    };
    NextGenEvents$4.listenerCount = function (emitter, eventName) {
        if (!emitter || !(emitter instanceof NextGenEvents$4)) {
            throw new TypeError('.listenerCount(): argument #0 should be an instance of NextGenEvents');
        }
        return emitter.listenerCount(eventName);
    };
    NextGenEvents$4.prototype.listenerCount = function (eventName) {
        if (!eventName || typeof eventName !== 'string') {
            throw new TypeError('.listenerCount(): argument #1 should be a non-empty string');
        }
        if (!this.__ngev || !this.__ngev.listeners[eventName]) {
            return 0;
        }
        return this.__ngev.listeners[eventName].length;
    };
    NextGenEvents$4.prototype.setNice = function (nice) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        this.__ngev.nice = Math.floor(+nice || 0);
    };
    NextGenEvents$4.prototype.desyncUseNextTick = function (useNextTick) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        this.__ngev.desync = useNextTick ? nextTick : setImmediate;
    };
    NextGenEvents$4.prototype.setInterruptible = function (isInterruptible) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        this.__ngev.interruptible = !!isInterruptible;
    };
    NextGenEvents$4.prototype.setListenerPriority = function (hasListenerPriority) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        this.__ngev.hasListenerPriority = !!hasListenerPriority;
    };
    NextGenEvents$4.share = function (source, target) {
        if (!(source instanceof NextGenEvents$4) || !(target instanceof NextGenEvents$4)) {
            throw new TypeError('NextGenEvents.share() arguments should be instances of NextGenEvents');
        }
        if (!source.__ngev) {
            NextGenEvents$4.init.call(source);
        }
        Object.defineProperty(target, '__ngev', {
            configurable: true,
            value: source.__ngev,
        });
    };
    NextGenEvents$4.reset = function (emitter) {
        Object.defineProperty(emitter, '__ngev', {
            configurable: true,
            value: null,
        });
    };
    NextGenEvents$4.prototype.getMaxListeners = function () {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        return this.__ngev.maxListeners;
    };
    NextGenEvents$4.prototype.setMaxListeners = function (n) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        this.__ngev.maxListeners =
            typeof n === 'number' && !Number.isNaN(n) ? Math.floor(n) : NextGenEvents$4.defaultMaxListeners;
        return this;
    };
    NextGenEvents$4.noop = () => void 0;
    NextGenEvents$4.prototype.defineStates = function (...states) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        states.forEach((state) => {
            this.__ngev.states[state] = null;
            this.__ngev.stateGroups[state] = states;
        });
    };
    NextGenEvents$4.prototype.hasState = function (state) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        return !!this.__ngev.states[state];
    };
    NextGenEvents$4.prototype.getAllStates = function () {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        return Object.keys(this.__ngev.states).filter((e) => this.__ngev.states[e]);
    };
    NextGenEvents$4.groupAddListener = function (emitters, eventName, fn, options) {
        if (typeof fn !== 'function') {
            options = fn;
            fn = void 0;
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        fn = fn || options.fn;
        delete options.fn;
        options.id = options.id || fn;
        emitters.forEach((emitter) => {
            emitter.addListener(eventName, fn.bind(void 0, emitter), options);
        });
    };
    NextGenEvents$4.groupOn = NextGenEvents$4.groupAddListener;
    NextGenEvents$4.groupOnce = function (emitters, eventName, fn, options) {
        if (fn && typeof fn === 'object') {
            fn.once = true;
        } else if (options && typeof options === 'object') {
            options.once = true;
        } else {
            options = { once: true };
        }
        return this.groupAddListener(emitters, eventName, fn, options);
    };
    NextGenEvents$4.groupWaitFor = function (emitters, eventName) {
        return Promise.all(emitters.map((emitter) => emitter.waitFor(eventName)));
    };
    NextGenEvents$4.groupWaitForAll = function (emitters, eventName) {
        return Promise.all(emitters.map((emitter) => emitter.waitForAll(eventName)));
    };
    NextGenEvents$4.groupOnceFirst = function (emitters, eventName, fn, options) {
        var fnWrapper,
            triggered = false;
        if (typeof fn !== 'function') {
            options = fn;
            fn = void 0;
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        fn = fn || options.fn;
        delete options.fn;
        options.id = options.id || fn;
        fnWrapper = (...args) => {
            if (triggered) {
                return;
            }
            triggered = true;
            NextGenEvents$4.groupRemoveListener(emitters, eventName, options.id);
            fn(...args);
        };
        emitters.forEach((emitter) => {
            emitter.once(eventName, fnWrapper.bind(void 0, emitter), options);
        });
    };
    NextGenEvents$4.groupWaitForFirst = function (emitters, eventName) {
        return new Promise((resolve) => {
            NextGenEvents$4.groupOnceFirst(emitters, eventName, (firstArg) => resolve(firstArg));
        });
    };
    NextGenEvents$4.groupWaitForFirstAll = function (emitters, eventName) {
        return new Promise((resolve) => {
            NextGenEvents$4.groupOnceFirst(emitters, eventName, (...args) => resolve(args));
        });
    };
    NextGenEvents$4.groupOnceLast = function (emitters, eventName, fn, options) {
        var fnWrapper,
            triggered = false,
            count = emitters.length;
        if (typeof fn !== 'function') {
            options = fn;
            fn = void 0;
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        fn = fn || options.fn;
        delete options.fn;
        options.id = options.id || fn;
        fnWrapper = (...args) => {
            if (triggered) {
                return;
            }
            if (--count) {
                return;
            }
            triggered = true;
            fn(...args);
        };
        emitters.forEach((emitter) => {
            emitter.once(eventName, fnWrapper.bind(void 0, emitter), options);
        });
    };
    NextGenEvents$4.groupWaitForLast = function (emitters, eventName) {
        return new Promise((resolve) => {
            NextGenEvents$4.groupOnceLast(emitters, eventName, (firstArg) => resolve(firstArg));
        });
    };
    NextGenEvents$4.groupWaitForLastAll = function (emitters, eventName) {
        return new Promise((resolve) => {
            NextGenEvents$4.groupOnceLast(emitters, eventName, (...args) => resolve(args));
        });
    };
    NextGenEvents$4.groupRemoveListener = function (emitters, eventName, id) {
        emitters.forEach((emitter) => {
            emitter.removeListener(eventName, id);
        });
    };
    NextGenEvents$4.groupOff = NextGenEvents$4.groupRemoveListener;
    NextGenEvents$4.groupRemoveAllListeners = function (emitters, eventName) {
        emitters.forEach((emitter) => {
            emitter.removeAllListeners(eventName);
        });
    };
    NextGenEvents$4.groupEmit = function (emitters, ...args) {
        var eventName,
            nice,
            argStart = 1,
            argEnd,
            count = emitters.length,
            callback,
            callbackWrapper,
            callbackTriggered = false;
        if (typeof args[args.length - 1] === 'function') {
            argEnd = -1;
            callback = args[args.length - 1];
            callbackWrapper = (interruption) => {
                if (callbackTriggered) {
                    return;
                }
                if (interruption) {
                    callbackTriggered = true;
                    callback(interruption);
                } else if (!--count) {
                    callbackTriggered = true;
                    callback();
                }
            };
        }
        if (typeof args[0] === 'number') {
            argStart = 2;
            nice = typeof args[0];
        }
        eventName = args[argStart - 1];
        args = args.slice(argStart, argEnd);
        emitters.forEach((emitter) => {
            NextGenEvents$4.emitEvent({
                emitter,
                name: eventName,
                args,
                nice,
                callback: callbackWrapper,
            });
        });
    };
    NextGenEvents$4.groupWaitForEmit = function (emitters, ...args) {
        return new Promise((resolve) => {
            NextGenEvents$4.groupEmit(emitters, ...args, (interrupt) => resolve(interrupt));
        });
    };
    NextGenEvents$4.groupDefineStates = function (emitters, ...args) {
        emitters.forEach((emitter) => {
            emitter.defineStates(...args);
        });
    };
    NextGenEvents$4.groupGlobalOnce = NextGenEvents$4.groupOnceFirst;
    NextGenEvents$4.groupGlobalOnceAll = NextGenEvents$4.groupOnceLast;
    NextGenEvents$4.CONTEXT_ENABLED = 0;
    NextGenEvents$4.CONTEXT_DISABLED = 1;
    NextGenEvents$4.CONTEXT_QUEUED = 2;
    NextGenEvents$4.prototype.addListenerContext = function (contextName, options) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.addListenerContext(): argument #0 should be a non-empty string');
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        var context = this.__ngev.contexts[contextName];
        if (!context) {
            context = this.__ngev.contexts[contextName] = {
                nice: NextGenEvents$4.SYNC,
                ready: true,
                status: NextGenEvents$4.CONTEXT_ENABLED,
                serial: false,
                scopes: {},
            };
        }
        if (options.nice !== void 0) {
            context.nice = Math.floor(options.nice);
        }
        if (options.status !== void 0) {
            context.status = options.status;
        }
        if (options.serial !== void 0) {
            context.serial = !!options.serial;
        }
        return context;
    };
    NextGenEvents$4.prototype.getListenerContext = function (contextName) {
        return this.__ngev.contexts[contextName];
    };
    NextGenEvents$4.getContextScope = function (context, scopeName) {
        var scope = context.scopes[scopeName];
        if (!scope) {
            scope = context.scopes[scopeName] = {
                ready: true,
                queue: [],
            };
        }
        return scope;
    };
    NextGenEvents$4.prototype.disableListenerContext = function (contextName) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.disableListenerContext(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev.contexts[contextName]) {
            this.addListenerContext(contextName);
        }
        this.__ngev.contexts[contextName].status = NextGenEvents$4.CONTEXT_DISABLED;
        return this;
    };
    NextGenEvents$4.prototype.enableListenerContext = function (contextName) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.enableListenerContext(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev.contexts[contextName]) {
            this.addListenerContext(contextName);
        }
        var context = this.__ngev.contexts[contextName];
        context.status = NextGenEvents$4.CONTEXT_ENABLED;
        Object.values(context.scopes).forEach((contextScope) => {
            if (contextScope.queue.length > 0) {
                NextGenEvents$4.processScopeQueue(contextScope, context.serial);
            }
        });
        return this;
    };
    NextGenEvents$4.prototype.queueListenerContext = function (contextName) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.queueListenerContext(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev.contexts[contextName]) {
            this.addListenerContext(contextName);
        }
        this.__ngev.contexts[contextName].status = NextGenEvents$4.CONTEXT_QUEUED;
        return this;
    };
    NextGenEvents$4.prototype.serializeListenerContext = function (contextName, value) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.serializeListenerContext(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev.contexts[contextName]) {
            this.addListenerContext(contextName);
        }
        this.__ngev.contexts[contextName].serial = value === void 0 ? true : !!value;
        return this;
    };
    NextGenEvents$4.prototype.setListenerContextNice = function (contextName, nice) {
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.setListenerContextNice(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev.contexts[contextName]) {
            this.addListenerContext(contextName);
        }
        this.__ngev.contexts[contextName].nice = Math.floor(nice);
        return this;
    };
    NextGenEvents$4.prototype.destroyListenerContext = function (contextName) {
        var i,
            length,
            context,
            eventName,
            newListeners,
            removedListeners = [];
        if (!contextName || typeof contextName !== 'string') {
            throw new TypeError('.disableListenerContext(): argument #0 should be a non-empty string');
        }
        if (!this.__ngev) {
            NextGenEvents$4.init.call(this);
        }
        context = this.__ngev.contexts[contextName];
        if (!context) {
            return;
        }
        for (eventName in this.__ngev.listeners) {
            newListeners = null;
            length = this.__ngev.listeners[eventName].length;
            for (i = 0; i < length; i++) {
                if (this.__ngev.listeners[eventName][i].context === context) {
                    newListeners = [];
                    removedListeners.push(this.__ngev.listeners[eventName][i]);
                } else if (newListeners) {
                    newListeners.push(this.__ngev.listeners[eventName][i]);
                }
            }
            if (newListeners) {
                this.__ngev.listeners[eventName] = newListeners;
            }
        }
        delete this.__ngev.contexts[contextName];
        if (removedListeners.length && this.__ngev.listeners.removeListener.length) {
            this.emit('removeListener', removedListeners);
        }
        return this;
    };
    NextGenEvents$4.processScopeQueue = function (contextScope, serial, isCompletionCallback) {
        var job, event2, eventMaster;
        if (isCompletionCallback) {
            contextScope.ready = true;
        }
        globalData.recursions++;
        while (contextScope.ready && contextScope.queue.length) {
            job = contextScope.queue.shift();
            event2 = job.event;
            eventMaster = event2.master || event2;
            event2.emitter;
            if (eventMaster.interrupt) {
                continue;
            }
            NextGenEvents$4.listenerWrapper(job.listener, event2, contextScope, serial, job.nice);
        }
        globalData.recursions--;
    };
    NextGenEvents$4.on = NextGenEvents$4.prototype.on;
    NextGenEvents$4.once = NextGenEvents$4.prototype.once;
    NextGenEvents$4.off = NextGenEvents$4.prototype.off;
    if (commonjsGlobal$1.AsyncTryCatch) {
        NextGenEvents$4.prototype.asyncTryCatchId = commonjsGlobal$1.AsyncTryCatch.NextGenEvents.length;
        commonjsGlobal$1.AsyncTryCatch.NextGenEvents.push(NextGenEvents$4);
        if (commonjsGlobal$1.AsyncTryCatch.substituted) {
            commonjsGlobal$1.AsyncTryCatch.substitute();
        }
    }
    NextGenEvents$4.Proxy = _Proxy;
    var Promise$a = seventh_1;
    var yesOrNo = function yesOrNo(options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = void 0;
        }
        if (!options || typeof options !== 'object') {
            options = {
                yes: ['y', 'Y'],
                no: ['n', 'N'],
                echoYes: 'yes',
                echoNo: 'no',
            };
        }
        if (typeof options.yes === 'string') {
            options.yes = [options.yes];
        }
        if (!Array.isArray(options.yes)) {
            options.yes = ['y', 'Y'];
        }
        if (typeof options.no === 'string') {
            options.no = [options.no];
        }
        if (!Array.isArray(options.no)) {
            options.no = ['n', 'N'];
        }
        if (!this.grabbing) {
            this.grabInput();
        }
        var onKey = (key) => {
            if (options.yes.indexOf(key) !== -1) {
                if (options.echoYes) {
                    this(options.echoYes);
                }
                this.removeListener('key', onKey);
                if (callback) {
                    callback(void 0, true);
                } else {
                    controller.promise.resolve(true);
                }
            } else if (options.no.indexOf(key) !== -1) {
                if (options.echoNo) {
                    this(options.echoNo);
                }
                this.removeListener('key', onKey);
                if (callback) {
                    callback(void 0, false);
                } else {
                    controller.promise.resolve(false);
                }
            }
        };
        this.on('key', onKey);
        var controller = {};
        controller.abort = () => {
            this.removeListener('key', onKey);
        };
        controller.promise = new Promise$a();
        return controller;
    };
    var autoComplete$2 = function autoComplete(array, startString, returnAlternatives, prefix, postfix) {
        var i,
            j,
            exitLoop,
            candidate = [],
            completed = startString,
            hasCompleted = false;
        if (!prefix) {
            prefix = '';
        }
        if (!postfix) {
            postfix = '';
        }
        for (i = 0; i < array.length; i++) {
            if (array[i].slice(0, startString.length) === startString) {
                candidate.push(array[i]);
            }
        }
        if (!candidate.length) {
            return prefix + completed + postfix;
        }
        if (candidate.length === 1) {
            return prefix + candidate[0] + postfix;
        }
        j = startString.length;
        exitLoop = false;
        for (j = startString.length; j < candidate[0].length; j++) {
            for (i = 1; i < candidate.length; i++) {
                if (candidate[i][j] !== candidate[0][j]) {
                    exitLoop = true;
                    break;
                }
            }
            if (exitLoop) {
                break;
            }
            completed += candidate[0][j];
            hasCompleted = true;
        }
        if (returnAlternatives && !hasCompleted) {
            candidate.prefix = prefix;
            candidate.postfix = postfix;
            return candidate;
        }
        return prefix + completed + postfix;
    };
    const NextGenEvents$3 = NextGenEvents_1;
    const Promise$9 = seventh_1;
    const string$2 = string$4;
    const autoComplete$1 = autoComplete$2;
    const defaultKeyBindings$3 = {
        ENTER: 'submit',
        KP_ENTER: 'submit',
        ESCAPE: 'cancel',
        BACKSPACE: 'backDelete',
        DELETE: 'delete',
        LEFT: 'backward',
        RIGHT: 'forward',
        UP: 'historyPrevious',
        DOWN: 'historyNext',
        HOME: 'startOfInput',
        END: 'endOfInput',
        TAB: 'autoComplete',
        CTRL_R: 'autoCompleteUsingHistory',
        CTRL_LEFT: 'previousWord',
        CTRL_RIGHT: 'nextWord',
        ALT_D: 'deleteNextWord',
        CTRL_W: 'deletePreviousWord',
        CTRL_U: 'deleteAllBefore',
        CTRL_K: 'deleteAllAfter',
    };
    const defaultTokenRegExp = /\S+/g;
    var inputField = function inputField(options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (options.echo === void 0) {
            options.echo = true;
        }
        if (typeof options.maxLength !== 'number') {
            options.maxLength = Infinity;
        }
        if (typeof options.minLength !== 'number') {
            options.minLength = 0;
        }
        if (options.echoChar && typeof options.echoChar !== 'string') {
            options.echoChar = '\u2022';
        }
        if (options.autoCompleteMenu) {
            if (typeof options.autoCompleteMenu !== 'object') {
                options.autoCompleteMenu = {};
            }
            options.autoCompleteMenu.exitOnUnexpectedKey = true;
            delete options.autoCompleteMenu.y;
        }
        var keyBindings = options.keyBindings || defaultKeyBindings$3;
        if (
            options.tokenRegExp &&
            (!(options.tokenRegExp instanceof RegExp) || !options.tokenRegExp.flags.includes('g'))
        ) {
            throw new Error(".inputField(): if set, the 'tokenRegExp' option should be a RegExp with the 'g' flag");
        }
        if (!this.grabbing) {
            this.grabInput();
        }
        var controller,
            finished = false,
            paused = false,
            alreadyCleanedUp = false,
            offset = options.cursorPosition !== void 0 ? options.cursorPosition : -1,
            echo = !!options.echo,
            start = {},
            end = {},
            cursor = {},
            endHint = {},
            inputs = [],
            inputIndex,
            alwaysRedraw = options.tokenHook || options.autoCompleteHint,
            hint = [],
            meta = false;
        var dynamic = {
            style: options.style || this,
            hintStyle: options.hintStyle || this.brightBlack,
            tokenRegExp: options.tokenRegExp || defaultTokenRegExp,
            autoComplete: options.autoComplete,
            autoCompleteMenu: options.autoCompleteMenu,
            autoCompleteHint: !!options.autoCompleteHint,
        };
        if (Array.isArray(options.history)) {
            inputs = options.history.map((str) => string$2.unicode.toArray(str).slice(0, options.maxLength));
        }
        if (options.default && typeof options.default === 'string') {
            inputs.push(string$2.unicode.toArray(options.default).slice(0, options.maxLength));
        } else {
            inputs.push([]);
        }
        var init = () => {
            inputIndex = inputs.length - 1;
            offset = boundOffset(offset);
            if (options.y !== void 0) {
                options.x = options.x || 1;
                this.moveTo.eraseLineAfter(options.x, options.y);
                finishInit(options.x, options.y);
            } else {
                this.getCursorLocation((error, x, y) => {
                    if (error) {
                        this.row.eraseLineAfter(this.height)('\n> ');
                        x = 3;
                        y = this.height;
                    }
                    finishInit(x, y);
                });
            }
        };
        var finishInit = (x, y) => {
            start.x = end.x = cursor.x = x;
            start.y = end.y = cursor.y = y;
            if (inputs[inputIndex].length) {
                computeAllCoordinate();
                redraw();
            }
            this.on('key', onKey);
            controller.emit('ready');
        };
        var cleanup = (error, input) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            finished = true;
            this.removeListener('key', onKey);
            if (error === 'abort') {
                return;
            }
            this.styleReset();
            if (error) {
                if (callback) {
                    callback(error);
                } else {
                    controller.promise.reject(error);
                }
                return;
            }
            var value;
            if (typeof input === 'string') {
                value = input;
            } else if (input) {
                value = input.join('');
            }
            if (callback) {
                callback(void 0, value);
            } else {
                controller.promise.resolve(value);
            }
        };
        var computeAllCoordinate = () => {
            var scroll,
                inputWidth = string$2.unicode.arrayWidth(inputs[inputIndex]),
                hintWidth = string$2.unicode.arrayWidth(hint);
            end = offsetCoordinate(inputWidth);
            endHint = offsetCoordinate(inputWidth + hintWidth);
            if (endHint.y > this.height) {
                scroll = endHint.y - this.height;
                dynamic.style.noFormat('\n'.repeat(scroll));
                start.y -= scroll;
                end.y -= scroll;
                endHint.y -= scroll;
            }
            cursorCoordinate();
        };
        var cursorCoordinate = () => {
            cursor = offsetCoordinate(string$2.unicode.arrayWidth(inputs[inputIndex], offset));
        };
        var offsetCoordinate = (offset_) => {
            return {
                x: 1 + ((start.x + offset_ - 1) % this.width),
                y: start.y + Math.floor((start.x + offset_ - 1) / this.width),
            };
        };
        var boundOffset = (offset_) => {
            if (typeof offset_ !== 'number' || isNaN(offset_)) {
                return inputs[inputIndex].length;
            }
            if (offset_ < 0) {
                offset_ = inputs[inputIndex].length + 1 + offset_;
            }
            if (offset_ < 0) {
                offset_ = 0;
            } else if (offset_ >= inputs[inputIndex].length) {
                offset_ = inputs[inputIndex].length;
            }
            return offset_;
        };
        var redraw = (extraLines, forceClear) => {
            var i, hintCleared;
            extraLines = extraLines || 0;
            if (!dynamic.autoCompleteHint && forceClear) {
                this.moveTo(end.x, end.y);
                dynamic.style.noFormat.eraseLineAfter('');
            }
            this.moveTo(start.x, start.y);
            if (options.tokenHook) {
                writeTokens(inputs[inputIndex].join(''));
            } else if (options.echoChar) {
                dynamic.style.noFormat(options.echoChar.repeat(inputs[inputIndex].length));
            } else {
                dynamic.style.noFormat(inputs[inputIndex].join(''));
            }
            hintCleared = clearHint();
            if (extraLines > 0) {
                for (i = 1; i <= extraLines; i++) {
                    this.moveTo(1, end.y + i);
                    dynamic.style.noFormat.eraseLineAfter('');
                }
            }
            if (!hintCleared && (cursor.y < end.y || end.x === this.width)) {
                this.moveTo(end.x, end.y);
                dynamic.style.noFormat.eraseLineAfter('');
            }
            this.moveTo(cursor.x, cursor.y);
        };
        var redrawCursor = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', redrawCursor);
                return;
            }
            this.moveTo(cursor.x, cursor.y);
        };
        var pause = () => {
            if (paused) {
                return;
            }
            paused = true;
        };
        var resume = () => {
            if (!paused) {
                return;
            }
            paused = false;
            if (controller.hasState('ready')) {
                redraw();
            }
        };
        var clearHint = () => {
            if (!dynamic.autoCompleteHint) {
                return false;
            }
            var y = end.y;
            this.moveTo(end.x, end.y);
            dynamic.style.noFormat.eraseLineAfter('');
            while (y < endHint.y) {
                y++;
                this.moveTo(1, y);
                dynamic.style.noFormat.eraseLineAfter('');
            }
            this.moveTo(cursor.x, cursor.y);
            return true;
        };
        var autoCompleteMenu = (menu) => {
            paused = true;
            this.singleLineMenu(menu, dynamic.autoCompleteMenu, (error, response) => {
                paused = false;
                if (error) {
                    return;
                }
                if (response.selectedText) {
                    if (menu.prefix) {
                        response.selectedText = menu.prefix + response.selectedText;
                    }
                    if (menu.postfix) {
                        response.selectedText += menu.postfix;
                    }
                    response.selectedText = string$2.unicode.toArray(response.selectedText).slice(0, options.maxLength);
                    inputs[inputIndex] = response.selectedText.concat(
                        inputs[inputIndex].slice(offset, options.maxLength + offset - response.selectedText.length),
                    );
                    offset = response.selectedText.length;
                }
                if (echo) {
                    this.column.eraseLineAfter(1);
                    if (end.y >= this.height && start.y > 1) {
                        start.y--;
                    }
                    computeAllCoordinate();
                    redraw();
                    this.moveTo(cursor.x, cursor.y);
                }
                if (response.unexpectedKey && response.unexpectedKey !== 'TAB') {
                    onKey(response.unexpectedKey, void 0, response.unexpectedKeyData);
                }
            }).on('highlight', (eventData) => controller.emit('highlight', eventData));
        };
        var writeTokens = (text) => {
            var match,
                lastIndex,
                lastEndIndex = 0,
                tokens = [],
                tokenStyle,
                isEndOfInput;
            dynamic.style = options.style || this;
            dynamic.hintStyle = options.hintStyle || this.brightBlack;
            dynamic.tokenRegExp = options.tokenRegExp || defaultTokenRegExp;
            dynamic.autoComplete = options.autoComplete;
            dynamic.autoCompleteMenu = options.autoCompleteMenu;
            dynamic.autoCompleteHint = !!options.autoCompleteHint;
            dynamic.tokenRegExp.lastIndex = 0;
            if (options.tokenResetHook) {
                options.tokenResetHook(this, dynamic);
            }
            while ((match = dynamic.tokenRegExp.exec(text)) !== null) {
                lastIndex = dynamic.tokenRegExp.lastIndex;
                if (match.index > lastEndIndex) {
                    dynamic.style.noFormat(text.slice(lastEndIndex, match.index));
                }
                isEndOfInput = match.index + match[0].length === text.length;
                tokenStyle = options.tokenHook(match[0], isEndOfInput, tokens, this, dynamic);
                if (typeof tokenStyle === 'function') {
                    tokenStyle.noFormat(match[0]);
                } else if (typeof tokenStyle === 'string') {
                    this.noFormat(tokenStyle);
                } else {
                    dynamic.style.noFormat(match[0]);
                }
                tokens.push(match[0]);
                lastEndIndex = match.index + match[0].length;
                dynamic.tokenRegExp.lastIndex = lastIndex;
            }
            if (lastEndIndex < text.length) {
                dynamic.style.noFormat(text.slice(lastEndIndex));
            }
        };
        var autoCompleteHint = () => {
            if (!dynamic.autoComplete || !dynamic.autoCompleteHint || offset < inputs[inputIndex].length) {
                return;
            }
            var autoCompleted,
                inputText = inputs[inputIndex].join('');
            var finishCompletion = () => {
                if (Array.isArray(autoCompleted)) {
                    return;
                }
                hint = string$2.unicode
                    .toArray(autoCompleted.slice(inputText.length))
                    .slice(0, options.maxLength - inputs[inputIndex].length);
                computeAllCoordinate();
                this.moveTo(end.x, end.y);
                dynamic.hintStyle.noFormat(hint.join(''));
                this.moveTo(cursor.x, cursor.y);
            };
            if (Array.isArray(dynamic.autoComplete)) {
                autoCompleted = autoComplete$1(dynamic.autoComplete, inputText, dynamic.autoCompleteMenu);
            } else if (typeof dynamic.autoComplete === 'function') {
                if (dynamic.autoComplete.length === 2) {
                    dynamic.autoComplete(inputText, (error, autoCompleted_) => {
                        if (error) {
                            cleanup(error);
                            return;
                        }
                        autoCompleted = autoCompleted_;
                        finishCompletion();
                    });
                    return;
                }
                autoCompleted = dynamic.autoComplete(inputText);
                if (Promise$9.isThenable(autoCompleted)) {
                    autoCompleted.then(
                        (autoCompleted_) => {
                            autoCompleted = autoCompleted_;
                            finishCompletion();
                        },
                        (error) => {
                            cleanup(error);
                        },
                    );
                    return;
                }
            }
            finishCompletion();
        };
        var onKey = (key, trash, data) => {
            if (finished || paused) {
                return;
            }
            var leftPart,
                autoCompleteUsed,
                autoCompleted,
                extraLines,
                charToDelete,
                cutOffset,
                altKey,
                lastOffset = offset;
            if (meta) {
                meta = false;
                altKey = 'ALT_' + key.toUpperCase();
                if (data) {
                    data.isCharacter = false;
                }
                if (keyBindings[altKey]) {
                    key = altKey;
                }
            }
            if (data && data.isCharacter) {
                if (inputs[inputIndex].length >= options.maxLength) {
                    return;
                }
                inputs[inputIndex].splice(offset, 0, key);
                offset++;
                if (echo) {
                    if (offset === inputs[inputIndex].length && !alwaysRedraw) {
                        dynamic.style.noFormat(options.echoChar || key);
                        computeAllCoordinate();
                    } else {
                        computeAllCoordinate();
                        redraw();
                        if (dynamic.autoCompleteHint) {
                            autoCompleteHint();
                        }
                    }
                }
            } else {
                switch (keyBindings[key]) {
                    case 'submit':
                        if (inputs[inputIndex].length < options.minLength) {
                            break;
                        }
                        clearHint();
                        cleanup(void 0, inputs[inputIndex]);
                        break;
                    case 'cancel':
                        if (options.cancelable) {
                            cleanup();
                        }
                        break;
                    case 'meta':
                        meta = true;
                        break;
                    case 'backDelete':
                        if (inputs[inputIndex].length && offset > 0) {
                            charToDelete = inputs[inputIndex][offset - 1];
                            inputs[inputIndex].splice(offset - 1, 1);
                            offset--;
                            if (echo) {
                                if (cursor.y < end.y || cursor.x === 1 || alwaysRedraw) {
                                    computeAllCoordinate();
                                    redraw(void 0, true);
                                    if (dynamic.autoCompleteHint) {
                                        autoCompleteHint();
                                    }
                                } else {
                                    computeAllCoordinate();
                                    if (string$2.unicode.isFullWidth(charToDelete)) {
                                        this.left(2);
                                        this.delete(2);
                                    } else {
                                        this.left(1);
                                        this.delete(1);
                                    }
                                }
                            }
                        }
                        break;
                    case 'delete':
                        if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
                            charToDelete = inputs[inputIndex][offset];
                            inputs[inputIndex].splice(offset, 1);
                            if (echo) {
                                if (cursor.y < end.y || alwaysRedraw) {
                                    computeAllCoordinate();
                                    redraw(void 0, true);
                                    if (dynamic.autoCompleteHint) {
                                        autoCompleteHint();
                                    }
                                } else {
                                    computeAllCoordinate();
                                    this.delete(string$2.unicode.isFullWidth(charToDelete) ? 2 : 1);
                                }
                            }
                        }
                        break;
                    case 'deleteAllBefore':
                        if (inputs[inputIndex].length && offset > 0) {
                            inputs[inputIndex].splice(0, offset);
                            offset = 0;
                            if (echo) {
                                computeAllCoordinate();
                                redraw(void 0, true);
                            }
                        }
                        break;
                    case 'deleteAllAfter':
                        if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
                            inputs[inputIndex].splice(offset, inputs[inputIndex].length - offset);
                            if (echo) {
                                computeAllCoordinate();
                                redraw(void 0, true);
                                if (dynamic.autoCompleteHint) {
                                    autoCompleteHint();
                                }
                            }
                        }
                        break;
                    case 'backward':
                        if (inputs[inputIndex].length && offset > 0) {
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                clearHint();
                            }
                            offset--;
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                            }
                        }
                        break;
                    case 'forward':
                        if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
                            offset++;
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                            }
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                autoCompleteHint();
                            }
                        }
                        break;
                    case 'deletePreviousWord':
                        if (inputs[inputIndex].length && offset > 0) {
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                clearHint();
                            }
                            cutOffset = offset--;
                            while (offset > 0 && inputs[inputIndex][offset] === ' ') {
                                offset--;
                            }
                            while (offset > 0 && inputs[inputIndex][offset - 1] !== ' ') {
                                offset--;
                            }
                            inputs[inputIndex].splice(offset, cutOffset - offset);
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                                redraw(void 0, true);
                            }
                        }
                        break;
                    case 'deleteNextWord':
                        if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
                            cutOffset = offset;
                            while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === ' ') {
                                offset++;
                            }
                            while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] !== ' ') {
                                offset++;
                            }
                            while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === ' ') {
                                offset++;
                            }
                            inputs[inputIndex].splice(cutOffset, offset - cutOffset);
                            offset = Math.min(inputs[inputIndex].length, cutOffset);
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                                redraw(void 0, true);
                            }
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                autoCompleteHint();
                            }
                        }
                        break;
                    case 'previousWord':
                        if (inputs[inputIndex].length && offset > 0) {
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                clearHint();
                            }
                            offset--;
                            while (offset > 0 && inputs[inputIndex][offset] === ' ') {
                                offset--;
                            }
                            while (offset > 0 && inputs[inputIndex][offset - 1] !== ' ') {
                                offset--;
                            }
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                            }
                        }
                        break;
                    case 'nextWord':
                        if (inputs[inputIndex].length && offset < inputs[inputIndex].length) {
                            while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] === ' ') {
                                offset++;
                            }
                            while (offset < inputs[inputIndex].length && inputs[inputIndex][offset] !== ' ') {
                                offset++;
                            }
                            if (echo) {
                                computeAllCoordinate();
                                this.moveTo(cursor.x, cursor.y);
                            }
                            if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                                autoCompleteHint();
                            }
                        }
                        break;
                    case 'startOfInput':
                        if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                            clearHint();
                        }
                        offset = 0;
                        if (echo) {
                            computeAllCoordinate();
                            this.moveTo(cursor.x, cursor.y);
                        }
                        break;
                    case 'endOfInput':
                        offset = inputs[inputIndex].length;
                        if (echo) {
                            computeAllCoordinate();
                            this.moveTo(cursor.x, cursor.y);
                        }
                        if (dynamic.autoCompleteHint && lastOffset !== inputs[inputIndex].length) {
                            autoCompleteHint();
                        }
                        break;
                    case 'historyNext':
                        if (inputIndex < inputs.length - 1) {
                            inputIndex++;
                            offset = inputs[inputIndex].length;
                            if (echo) {
                                extraLines = end.y - start.y;
                                computeAllCoordinate();
                                extraLines -= end.y - start.y;
                                redraw(extraLines, true);
                                this.moveTo(cursor.x, cursor.y);
                            }
                        }
                        break;
                    case 'historyPrevious':
                        if (inputIndex > 0) {
                            inputIndex--;
                            offset = inputs[inputIndex].length;
                            if (echo) {
                                extraLines = end.y - start.y;
                                computeAllCoordinate();
                                extraLines -= end.y - start.y;
                                redraw(extraLines, true);
                                this.moveTo(cursor.x, cursor.y);
                            }
                        }
                        break;
                    case 'autoCompleteUsingHistory':
                    case 'autoComplete':
                        autoCompleteUsed =
                            keyBindings[key] === 'autoCompleteUsingHistory' ? options.history : dynamic.autoComplete;
                        if (!autoCompleteUsed) {
                            break;
                        }
                        leftPart = inputs[inputIndex].slice(0, offset);
                        var finishCompletion = () => {
                            if (Array.isArray(autoCompleted)) {
                                if (dynamic.autoCompleteMenu) {
                                    autoCompleteMenu(autoCompleted);
                                }
                                return;
                            }
                            leftPart = string$2.unicode.toArray(autoCompleted).slice(0, options.maxLength);
                            inputs[inputIndex] = leftPart.concat(
                                inputs[inputIndex].slice(offset, options.maxLength + offset - leftPart.length),
                            );
                            offset = leftPart.length;
                            if (echo) {
                                computeAllCoordinate();
                                redraw();
                            }
                        };
                        if (Array.isArray(autoCompleteUsed)) {
                            autoCompleted = autoComplete$1(
                                autoCompleteUsed,
                                leftPart.join(''),
                                dynamic.autoCompleteMenu,
                            );
                        } else if (typeof autoCompleteUsed === 'function') {
                            if (autoCompleteUsed.length === 2) {
                                autoCompleteUsed(leftPart.join(''), (error, autoCompleted_) => {
                                    if (error) {
                                        cleanup(error);
                                        return;
                                    }
                                    autoCompleted = autoCompleted_;
                                    finishCompletion();
                                });
                                return;
                            }
                            autoCompleted = autoCompleteUsed(leftPart.join(''));
                            if (Promise$9.isThenable(autoCompleted)) {
                                autoCompleted.then(
                                    (autoCompleted_) => {
                                        autoCompleted = autoCompleted_;
                                        finishCompletion();
                                    },
                                    (error) => {
                                        cleanup(error);
                                    },
                                );
                                return;
                            }
                        }
                        finishCompletion();
                        break;
                }
            }
        };
        controller = Object.create(NextGenEvents$3.prototype);
        controller.defineStates('ready');
        Object.defineProperty(controller, 'ready', {
            get: function () {
                return this.hasState('ready');
            },
        });
        controller.widgetType = 'inputField';
        controller.abort = () => {
            if (finished) {
                return;
            }
            cleanup('abort');
        };
        controller.stop = () => {
            if (finished) {
                return;
            }
            cleanup(void 0, inputs[inputIndex]);
        };
        controller.pause = pause;
        controller.resume = resume;
        controller.focus = (value) => {
            if (value) {
                resume();
            } else {
                pause();
            }
        };
        controller.getInput = () => inputs[inputIndex].join('');
        controller.value = controller.getInput;
        controller.getPosition = () => ({ x: start.x, y: start.y });
        controller.hide = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.hide);
                return;
            }
            var i, j;
            for (i = start.x, j = start.y; j <= end.y; i = 1, j++) {
                this.moveTo.eraseLineAfter(i, j);
            }
            echo = false;
        };
        controller.show = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.show);
                return;
            }
            echo = true;
            redraw();
        };
        controller.redraw = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.redraw);
                return;
            }
            redraw(void 0, true);
        };
        controller.redrawCursor = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.redrawCursor);
                return;
            }
            redrawCursor();
        };
        controller.getCursorPosition = () => offset;
        controller.setCursorPosition = (newOffset) => {
            newOffset = boundOffset(newOffset);
            if (newOffset !== offset) {
                if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                    clearHint();
                }
                offset = newOffset;
                if (echo) {
                    computeAllCoordinate();
                    this.moveTo(cursor.x, cursor.y);
                }
                if (dynamic.autoCompleteHint && offset === inputs[inputIndex].length) {
                    autoCompleteHint();
                }
            }
        };
        controller.rebase = (x, y) => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.rebase);
                return;
            }
            var rebaseTo = (x_, y_) => {
                start.x = x_;
                start.y = y_;
                if (options.echo) {
                    echo = true;
                    computeAllCoordinate();
                    redraw();
                }
                controller.emit('rebased');
            };
            if (x !== void 0 && y !== void 0) {
                rebaseTo(x, y);
                return;
            }
            echo = false;
            this.getCursorLocation((error, x_, y_) => {
                if (error) {
                    return;
                }
                rebaseTo(x_, y_);
            });
        };
        controller.promise = new Promise$9();
        init();
        return controller;
    };
    var Promise$8 = seventh_1;
    var autoComplete = autoComplete$2;
    var fs = require$$2$2;
    var path = require$$3$1;
    var fileInput = function fileInput(options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        var baseDir;
        var promise = new Promise$8();
        if (options.baseDir) {
            baseDir = path.resolve(options.baseDir);
            if (!path.isAbsolute(baseDir)) {
                fs.realpath(options.baseDir, (error, resolvedPath) => {
                    if (error) {
                        if (callback) {
                            callback(error);
                        } else {
                            promise.reject(error);
                        }
                        return;
                    }
                    options.baseDir = resolvedPath;
                    this.fileInput(options).then(
                        (input) => {
                            if (callback) {
                                callback(input);
                            } else {
                                promise.resolve(input);
                            }
                        },
                        (error_) => {
                            if (callback) {
                                callback(error_);
                            } else {
                                promise.reject(error_);
                            }
                        },
                    );
                });
                return promise;
            }
        } else {
            baseDir = process.cwd();
        }
        if (baseDir[baseDir.length - 1] !== '/') {
            baseDir += '/';
        }
        var autoCompleter = function autoCompleter2(inputString) {
            return __async(this, null, function* () {
                var inputDir, inputFile, currentDir, files, completion;
                if (inputString[inputString.length - 1] === '/') {
                    inputDir = inputString;
                    inputFile = '';
                } else {
                    inputDir = path.dirname(inputString);
                    inputDir = inputDir === '.' ? '' : inputDir + '/';
                    inputFile = path.basename(inputString);
                }
                if (path.isAbsolute(inputString)) {
                    currentDir = inputDir;
                } else {
                    currentDir = baseDir + inputDir;
                }
                try {
                    files = yield readdir(currentDir);
                } catch (error) {
                    return inputString;
                }
                if (!Array.isArray(files) || !files.length) {
                    return inputString;
                }
                completion = autoComplete(files, inputFile, true);
                if (Array.isArray(completion)) {
                    completion.prefix = inputDir;
                } else {
                    completion = path.normalize(inputDir + completion);
                }
                return completion;
            });
        };
        options = Object.assign({}, options, { autoComplete: autoCompleter, autoCompleteMenu: true, minLength: 1 });
        this.inputField(options).promise.then(
            (input) => {
                if (!input && typeof input !== 'string') {
                    input = void 0;
                } else {
                    input = path.resolve(path.isAbsolute(input) ? input : baseDir + input);
                }
                if (callback) {
                    callback(void 0, input);
                } else {
                    promise.resolve(input);
                }
            },
            (error) => {
                if (callback) {
                    callback(error);
                } else {
                    promise.reject(error);
                }
            },
        );
        return promise;
    };
    function readdir(dir) {
        var promise = new Promise$8();
        if (dir[dir.length - 1] !== '/') {
            dir += '/';
        }
        fs.readdir(dir, (error, files) => {
            if (error) {
                promise.reject(error);
                return;
            }
            Promise$8.map(files, (file) => {
                return new Promise$8((resolve, reject) => {
                    fs.lstat(dir + file, (error_, stats) => {
                        if (error_) {
                            reject(error_);
                            return;
                        }
                        if (stats.isDirectory()) {
                            file += '/';
                        }
                        resolve(file);
                    });
                });
            }).toPromise(promise);
        });
        return promise;
    }
    const termkit$3 = termkit_1;
    const stringWidth$1 = termkit$3.stringWidth;
    const NextGenEvents$2 = NextGenEvents_1;
    const Promise$7 = seventh_1;
    const defaultKeyBindings$2 = {
        ENTER: 'submit',
        KP_ENTER: 'submit',
        LEFT: 'previous',
        RIGHT: 'next',
        UP: 'previousPage',
        DOWN: 'nextPage',
        TAB: 'cycleNext',
        SHIFT_TAB: 'cyclePrevious',
        HOME: 'first',
        END: 'last',
        ESCAPE: 'escape',
    };
    var singleLineMenu = function singleLineMenu(menuItems_, options, callback) {
        if (arguments.length < 1) {
            throw new Error('[terminal] singleLineMenu() needs at least an array of menuItems');
        }
        if (!Array.isArray(menuItems_) || !menuItems_.length) {
            throw new TypeError('[terminal] singleLineMenu(): argument #0 should be a non-empty array');
        }
        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (options.separator === void 0) {
            options.separator = '  ';
        }
        if (options.nextPageHint === void 0) {
            options.nextPageHint = ' \xBB ';
        }
        if (options.previousPageHint === void 0) {
            options.previousPageHint = ' \xAB ';
        }
        if (!options.style) {
            options.style = this;
        }
        if (!options.selectedStyle) {
            options.selectedStyle = this.dim.blue.bgGreen;
        }
        if (!options.y) {
            this('\n');
        } else {
            this.moveTo(1, options.y);
        }
        var keyBindings = options.keyBindings || defaultKeyBindings$2;
        if (!this.grabbing) {
            this.grabInput();
        }
        var menuItems = menuItems_.map((e) => (typeof e === 'string' ? e : '' + e));
        var selectedIndexInPage = (options.selectedIndex = options.selectedIndex || 0);
        var start = {},
            selectedPage = 0,
            finished = false,
            menuPages = [],
            alreadyCleanedUp = false;
        var nextPageHintWidth = stringWidth$1(options.nextPageHint),
            previousPageHintWidth = stringWidth$1(options.previousPageHint),
            separatorWidth = stringWidth$1(options.separator);
        var computePages = () => {
            var i,
                itemWidth,
                displayText,
                p = 0,
                endX = 1,
                nextEndX,
                firstItem = true,
                lastItem,
                lineWidth,
                offset,
                xMax = this.width - nextPageHintWidth;
            menuPages = [[]];
            for (i = 0; i < menuItems.length; i++) {
                if (p >= menuPages.length) {
                    menuPages.push([]);
                }
                itemWidth = stringWidth$1(menuItems[i]);
                nextEndX = endX + itemWidth + separatorWidth;
                if (nextEndX > xMax) {
                    if (firstItem) {
                        itemWidth = xMax - endX;
                        displayText = termkit$3.truncateString(menuItems[i], itemWidth - 1) + '\u2026';
                        if (i === options.selectedIndex) {
                            selectedPage = p;
                            selectedIndexInPage = menuPages[p].length;
                        }
                        menuPages[p].push({
                            index: i,
                            text: menuItems[i],
                            displayText,
                            displayTextWidth: itemWidth,
                            x: endX,
                        });
                    } else {
                        i--;
                    }
                    p++;
                    endX = 1 + previousPageHintWidth;
                    firstItem = true;
                    continue;
                }
                if (i === options.selectedIndex) {
                    selectedPage = p;
                    selectedIndexInPage = menuPages[p].length;
                }
                menuPages[p].push({
                    index: i,
                    text: menuItems[i],
                    displayText: menuItems[i],
                    displayTextWidth: itemWidth,
                    x: endX,
                });
                endX = nextEndX;
                firstItem = false;
            }
            for (p = 0; p < menuPages.length; p++) {
                lastItem = menuPages[p][menuPages[p].length - 1];
                lineWidth = lastItem.x + lastItem.displayTextWidth - 1;
                if (p < menuPages.length - 1) {
                    lineWidth += nextPageHintWidth;
                }
                menuPages[p].x = 1;
                if (lineWidth < this.width) {
                    if (options.align === 'right') {
                        offset = this.width - lineWidth;
                    } else if (options.align === 'center') {
                        offset = Math.floor((this.width - lineWidth) / 2);
                    } else {
                        offset = 0;
                    }
                    menuPages[p].x += offset;
                    if (offset) {
                        menuPages[p].forEach((item) => (item.x += offset));
                    }
                }
            }
        };
        var cleanup = (error, data) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            finished = true;
            this.removeListener('key', onKey);
            this.removeListener('mouse', onMouse);
            if (error) {
                if (callback) {
                    callback(error);
                } else {
                    controller.promise.reject(error);
                }
                return;
            }
            var page = menuPages[selectedPage];
            var value =
                data !== void 0
                    ? data
                    : {
                          selectedIndex: page[selectedIndexInPage].index,
                          selectedText: page[selectedIndexInPage].text,
                          x: page[selectedIndexInPage].x,
                          y: start.y,
                      };
            if (callback) {
                callback(void 0, value);
            } else {
                controller.promise.resolve(value);
            }
        };
        var redraw = () => {
            var i,
                cursorX,
                page = menuPages[selectedPage],
                endX = page.x;
            this.moveTo.eraseLineAfter(1, start.y);
            if (options.fillIn && endX > 1) {
                options.style.noFormat(' '.repeat(endX - 1));
            } else {
                this.column(endX);
            }
            if (selectedPage) {
                options.style.forceStyleOnReset.noFormat(options.previousPageHint);
                endX += previousPageHintWidth;
            }
            for (i = 0; i < page.length; i++) {
                if (i) {
                    options.style.forceStyleOnReset.noFormat(options.separator);
                    endX += separatorWidth;
                }
                if (i === selectedIndexInPage) {
                    options.selectedStyle.forceStyleOnReset.noFormat(page[i].displayText);
                    cursorX = endX;
                } else {
                    options.style.forceStyleOnReset.noFormat(page[i].displayText);
                }
                endX += page[i].displayTextWidth;
            }
            if (selectedPage < menuPages.length - 1) {
                options.style.forceStyleOnReset.noFormat(options.nextPageHint);
                endX += nextPageHintWidth;
            }
            if (options.fillIn && endX < this.width) {
                options.style.noFormat(' '.repeat(this.width - endX));
            }
            this.column(cursorX);
        };
        var emitHighlight = () => {
            var item = menuPages[selectedPage][selectedIndexInPage];
            controller.emit('highlight', {
                highlightedIndex: item.index,
                highlightedText: item.text,
                x: item.x,
                y: start.y,
            });
        };
        var onKey = (key, trash, data) => {
            if (finished) {
                return;
            }
            var changed = false,
                page = menuPages[selectedPage];
            switch (keyBindings[key]) {
                case 'submit':
                    cleanup();
                    break;
                case 'previous':
                    if (selectedIndexInPage > 0) {
                        selectedIndexInPage--;
                        changed = true;
                    } else if (selectedPage > 0) {
                        selectedPage--;
                        selectedIndexInPage = menuPages[selectedPage].length - 1;
                        changed = true;
                    }
                    break;
                case 'next':
                    if (selectedIndexInPage < page.length - 1) {
                        selectedIndexInPage++;
                        changed = true;
                    } else if (selectedPage < menuPages.length - 1) {
                        selectedPage++;
                        selectedIndexInPage = 0;
                        changed = true;
                    }
                    break;
                case 'cycleNext':
                    if (selectedPage === menuPages.length - 1 && selectedIndexInPage === page.length - 1) {
                        selectedPage = 0;
                        selectedIndexInPage = 0;
                        changed = true;
                    } else if (selectedIndexInPage < page.length - 1) {
                        selectedIndexInPage++;
                        changed = true;
                    } else if (selectedPage < menuPages.length - 1) {
                        selectedPage++;
                        selectedIndexInPage = 0;
                        changed = true;
                    }
                    break;
                case 'cyclePrevious':
                    if (selectedPage === 0 && selectedIndexInPage === 0) {
                        selectedPage = menuPages.length - 1;
                        selectedIndexInPage = menuPages[selectedPage].length - 1;
                        changed = true;
                    } else if (selectedIndexInPage > 0) {
                        selectedIndexInPage--;
                        changed = true;
                    } else if (selectedPage > 0) {
                        selectedPage--;
                        selectedIndexInPage = menuPages[selectedPage].length - 1;
                        changed = true;
                    }
                    break;
                case 'first':
                    if (selectedPage !== 0 || selectedIndexInPage !== 0) {
                        selectedPage = 0;
                        selectedIndexInPage = 0;
                        changed = true;
                    }
                    break;
                case 'last':
                    if (
                        selectedPage !== menuPages.length - 1 ||
                        selectedIndexInPage !== menuPages[selectedPage].length - 1
                    ) {
                        selectedPage = menuPages.length - 1;
                        selectedIndexInPage = menuPages[selectedPage].length - 1;
                        changed = true;
                    }
                    break;
                case 'previousPage':
                    if (selectedPage > 0) {
                        selectedPage--;
                        selectedIndexInPage = 0;
                        changed = true;
                    }
                    break;
                case 'nextPage':
                    if (selectedPage < menuPages.length - 1) {
                        selectedPage++;
                        selectedIndexInPage = 0;
                        changed = true;
                    }
                    break;
                case 'escape':
                    if (options.cancelable) {
                        cleanup(void 0, { canceled: true });
                    }
                    if (options.exitOnUnexpectedKey) {
                        cleanup(void 0, { unexpectedKey: key, unexpectedKeyData: data });
                    }
                    break;
                default:
                    if (options.exitOnUnexpectedKey) {
                        cleanup(void 0, { unexpectedKey: key, unexpectedKeyData: data });
                    }
                    break;
            }
            if (changed) {
                redraw();
                emitHighlight();
            }
        };
        var onMouse = (name2, data) => {
            if (finished) {
                return;
            }
            if (data.y !== start.y) {
                return;
            }
            var i,
                item,
                nextButtonX,
                inBounds = false,
                page = menuPages[selectedPage];
            if (name2 === 'MOUSE_LEFT_BUTTON_PRESSED') {
                if (selectedPage > 0 && data.x >= 1 && data.x < 1 + previousPageHintWidth) {
                    selectedPage--;
                    selectedIndexInPage = 0;
                    redraw();
                    emitHighlight();
                    return;
                }
                nextButtonX = page[page.length - 1].x + page[page.length - 1].displayTextWidth;
                if (
                    selectedPage < menuPages.length - 1 &&
                    data.x >= nextButtonX &&
                    data.x < nextButtonX + nextPageHintWidth
                ) {
                    selectedPage++;
                    selectedIndexInPage = 0;
                    redraw();
                    emitHighlight();
                    return;
                }
            }
            for (i = 0; i < page.length; i++) {
                item = page[i];
                if (data.x >= item.x && data.x < item.x + item.displayTextWidth) {
                    inBounds = true;
                    if (selectedIndexInPage !== i) {
                        selectedIndexInPage = i;
                        redraw();
                        emitHighlight();
                    }
                    break;
                }
            }
            if (inBounds && name2 === 'MOUSE_LEFT_BUTTON_PRESSED') {
                cleanup();
            }
        };
        var controller = Object.create(NextGenEvents$2.prototype);
        controller.promise = new Promise$7();
        this.getCursorLocation((error, x, y) => {
            if (error) {
                this.row.eraseLineAfter(this.height)('\n');
                x = 1;
                y = this.height;
            }
            start.x = x;
            start.y = y;
            computePages();
            redraw();
            emitHighlight();
            this.on('key', onKey);
            if (this.mouseGrabbing) {
                this.on('mouse', onMouse);
            }
        });
        return controller;
    };
    const termkit$2 = termkit_1;
    const stringWidth = termkit$2.stringWidth;
    const string$1 = string$4;
    const NextGenEvents$1 = NextGenEvents_1;
    const Promise$6 = seventh_1;
    const defaultKeyBindings$1 = {
        ENTER: 'submit',
        KP_ENTER: 'submit',
        UP: 'previous',
        DOWN: 'next',
        TAB: 'cycleNext',
        SHIFT_TAB: 'cyclePrevious',
        HOME: 'first',
        END: 'last',
        BACKSPACE: 'cancel',
        DELETE: 'cancel',
        ESCAPE: 'escape',
    };
    var singleColumnMenu = function singleColumnMenu(menuItemsArg, options, callback) {
        if (arguments.length < 1) {
            throw new Error('[terminal] singleColumnMenu() needs at least an array of menuItems');
        }
        if (!Array.isArray(menuItemsArg) || !menuItemsArg.length) {
            throw new TypeError('[terminal] singleColumnMenu(): argument #0 should be a non-empty array');
        }
        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (!options.style) {
            options.style = this;
        }
        if (!options.selectedStyle) {
            options.selectedStyle = this.inverse;
        }
        if (!options.submittedStyle) {
            options.submittedStyle = this.bgGray.bold;
        }
        if (!options.disabledStyle) {
            options.disabledStyle = this.dim;
        }
        if (!options.disabledSelectedStyle) {
            options.disabledSelectedStyle = this.bgGray.dim;
        }
        if (!options.disabledSubmittedStyle) {
            options.disabledSubmittedStyle = this.bgGray;
        }
        if (options.leftPadding === void 0) {
            options.leftPadding = ' ';
        }
        if (options.selectedLeftPadding === void 0) {
            options.selectedLeftPadding = options.leftPadding;
        }
        if (options.submittedLeftPadding === void 0) {
            options.submittedLeftPadding = options.leftPadding;
        }
        if (typeof options.extraLines !== 'number' || options.extraLines < 0) {
            options.extraLines = 1;
        }
        if (!options.itemMaxWidth) {
            options.itemMaxWidth = this.width - 1;
        }
        if (!options.unsubmittableIndexes) {
            options.unsubmittableIndexes = [];
        }
        var selectedIndex = options.selectedIndex || 0;
        var submittedIndex = options.submitted ? options.selectedIndex : null;
        var paused = !!options.paused;
        var keyBindings = options.keyBindings || defaultKeyBindings$1;
        if (!this.grabbing) {
            this.grabInput();
        }
        var start = {},
            end = {},
            textWidth,
            outerWidth,
            paddingLength,
            menuItems,
            offsetY = 0,
            lineCount = 0,
            scrollLines = 0,
            controller,
            finished = false,
            alreadyCleanedUp = false;
        var init = () => {
            computeItems(menuItemsArg);
            if (options.y !== void 0) {
                this.moveTo(1, options.y);
                finishInit(1, options.y);
            } else {
                this('\n');
                this.getCursorLocation((error, x, y) => {
                    if (error) {
                        this.row.eraseLineAfter(this.height)('\n');
                        x = 1;
                        y = this.height;
                    }
                    finishInit(x, y);
                });
            }
        };
        var computeItems = (menuItems_) => {
            textWidth = 0;
            paddingLength = Math.max(stringWidth(options.leftPadding), stringWidth(options.selectedLeftPadding));
            menuItems_ = menuItems_.map((element) => {
                if (typeof element !== 'string') {
                    element = '' + element;
                }
                textWidth = Math.max(textWidth, stringWidth(element));
                return element;
            });
            if (!options.oneLineItem && textWidth > options.itemMaxWidth - paddingLength) {
                outerWidth = Math.min(textWidth + paddingLength, this.width);
                menuItems = menuItems_.map((element, index) => {
                    var item,
                        lines,
                        lineLength = options.itemMaxWidth - paddingLength;
                    lines = string$1.wordwrap(element, {
                        width: lineLength,
                        noJoin: true,
                        fill: true,
                        skipFn: termkit$2.escapeSequenceSkipFn,
                    });
                    item = {
                        offsetY,
                        index,
                        text: element,
                        displayText: lines,
                    };
                    offsetY += lines.length;
                    return item;
                });
                lineCount = offsetY;
            } else {
                textWidth = Math.min(textWidth, options.itemMaxWidth - paddingLength);
                outerWidth = Math.min(textWidth + paddingLength, this.width);
                menuItems = menuItems_.map((element, index) => {
                    var elementWidth = stringWidth(element);
                    return {
                        offsetY: index,
                        index,
                        text: element,
                        displayText: [
                            elementWidth > textWidth
                                ? element.slice(0, textWidth - 1) + '\u2026'
                                : element + ' '.repeat(textWidth - elementWidth),
                        ],
                    };
                });
                lineCount = menuItems.length;
            }
        };
        var finishInit = (x, y) => {
            if (finished) {
                return;
            }
            prepareArea(x, y);
            redraw();
            this.on('key', onKey);
            if (this.mouseGrabbing) {
                this.on('mouse', onMouse);
            }
            controller.emit('ready');
            emitHighlight();
        };
        var emitHighlight = () => {
            var item = menuItems[selectedIndex];
            controller.emit('highlight', {
                highlightedIndex: item.index,
                highlightedText: item.text,
                submitted: submittedIndex !== null,
                x: 1,
                y: start.y + item.offsetY,
            });
        };
        var prepareArea = (x, y) => {
            start.x = x;
            start.y = y;
            end.x = 1;
            end.y = y + lineCount;
            scrollLines = start.y + lineCount - (options.scrollRegionBottom || this.height) - 1 + options.extraLines;
            if (scrollLines > 0) {
                this('\n'.repeat(scrollLines));
                start.y -= scrollLines;
                end.y -= scrollLines;
            }
        };
        var cleanup = (error, data, eraseMenu) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            finished = true;
            this.removeListener('key', onKey);
            this.removeListener('mouse', onMouse);
            if (error === 'abort') {
                return;
            }
            if (controller.hasState('ready')) {
                if (eraseMenu) {
                    erase();
                } else {
                    this.moveTo(1, end.y);
                }
            }
            if (error) {
                if (callback) {
                    callback(error);
                } else {
                    controller.promise.reject(error);
                }
                return;
            }
            var value =
                data !== void 0
                    ? data
                    : {
                          selectedIndex,
                          selectedText: menuItems[selectedIndex].text,
                          submitted: submittedIndex !== null,
                          x: 1,
                          y: start.y + menuItems[selectedIndex].offsetY,
                      };
            if (callback) {
                callback(void 0, value);
            } else {
                controller.promise.resolve(value);
            }
        };
        var erase = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', erase);
                return;
            }
            var i, j;
            for (i = start.x, j = start.y; j <= end.y; i = 1, j++) {
                this.moveTo.eraseLineAfter(i, j);
            }
            this.moveTo(1, start.y);
        };
        var redraw = () => {
            for (var i = 0; i < menuItems.length; i++) {
                redrawItem(i);
            }
            redrawCursor();
        };
        var redrawItem = (index) => {
            var item = menuItems[index];
            item.displayText.forEach((text, line) => {
                this.moveTo(1, start.y + item.offsetY + line);
                if (paused || options.unsubmittableIndexes[index]) {
                    if (index === submittedIndex) {
                        if (line) {
                            options.disabledSubmittedStyle.forceStyleOnReset.noFormat(options.leftPadding);
                        } else {
                            options.disabledSubmittedStyle.forceStyleOnReset.noFormat(options.submittedLeftPadding);
                        }
                        options.disabledSubmittedStyle.forceStyleOnReset.noFormat(text);
                    } else if (index === selectedIndex) {
                        if (line) {
                            options.disabledSelectedStyle.forceStyleOnReset.noFormat(options.leftPadding);
                        } else {
                            options.disabledSelectedStyle.forceStyleOnReset.noFormat(options.selectedLeftPadding);
                        }
                        options.disabledSelectedStyle.forceStyleOnReset.noFormat(text);
                    } else {
                        options.disabledStyle.forceStyleOnReset.noFormat(options.leftPadding);
                        options.disabledStyle.forceStyleOnReset.noFormat(text);
                    }
                } else if (index === submittedIndex) {
                    if (line) {
                        options.submittedStyle.forceStyleOnReset.noFormat(options.leftPadding);
                    } else {
                        options.submittedStyle.forceStyleOnReset.noFormat(options.submittedLeftPadding);
                    }
                    options.submittedStyle.forceStyleOnReset.noFormat(text);
                } else if (index === selectedIndex) {
                    if (line) {
                        options.selectedStyle.forceStyleOnReset.noFormat(options.leftPadding);
                    } else {
                        options.selectedStyle.forceStyleOnReset.noFormat(options.selectedLeftPadding);
                    }
                    options.selectedStyle.forceStyleOnReset.noFormat(text);
                } else {
                    options.style.forceStyleOnReset.noFormat(options.leftPadding);
                    options.style.forceStyleOnReset.noFormat(text);
                }
            });
        };
        var redrawCursor = () => {
            this.moveTo(1, start.y + menuItems[selectedIndex].offsetY);
        };
        var select = (index) => {
            var oldSelectedIndex = selectedIndex;
            if (selectedIndex !== index && index >= 0 && index < menuItems.length) {
                selectedIndex = index;
                if (controller.hasState('ready')) {
                    redrawItem(oldSelectedIndex);
                    redrawItem(selectedIndex);
                    redrawCursor();
                    emitHighlight();
                }
            }
        };
        var submit = () => {
            if (submittedIndex !== null || options.unsubmittableIndexes[selectedIndex]) {
                return;
            }
            submittedIndex = selectedIndex;
            if (controller.hasState('ready')) {
                redrawItem(submittedIndex);
                redrawCursor();
            }
            controller.emit('submit', {
                selectedIndex: submittedIndex,
                selectedText: menuItems[submittedIndex].text,
                submitted: true,
                x: 1,
                y: start.y + menuItems[submittedIndex].offsetY,
            });
            if (!options.continueOnSubmit) {
                cleanup();
            }
        };
        var cancel = () => {
            var oldSelectedIndex = submittedIndex;
            if (submittedIndex === null) {
                return;
            }
            submittedIndex = null;
            redrawItem(oldSelectedIndex);
            redrawCursor();
            controller.emit('cancel');
        };
        var pause = () => {
            if (paused) {
                return;
            }
            paused = true;
            if (controller.hasState('ready')) {
                redraw();
            }
        };
        var resume = () => {
            if (!paused) {
                return;
            }
            paused = false;
            if (controller.hasState('ready')) {
                redraw();
            }
        };
        var onKey = (key, trash, data) => {
            if (finished || paused) {
                return;
            }
            var oldSelectedIndex = selectedIndex;
            switch (keyBindings[key]) {
                case 'submit':
                    submit();
                    break;
                case 'previous':
                    if (submittedIndex !== null) {
                        return;
                    }
                    if (selectedIndex > 0) {
                        selectedIndex--;
                        redrawItem(selectedIndex);
                        redrawItem(selectedIndex + 1);
                        redrawCursor();
                        emitHighlight();
                    }
                    break;
                case 'next':
                    if (submittedIndex !== null) {
                        return;
                    }
                    if (selectedIndex < menuItems.length - 1) {
                        selectedIndex++;
                        redrawItem(selectedIndex - 1);
                        redrawItem(selectedIndex);
                        redrawCursor();
                        emitHighlight();
                    }
                    break;
                case 'cyclePrevious':
                    if (submittedIndex !== null) {
                        return;
                    }
                    selectedIndex--;
                    if (selectedIndex < 0) {
                        selectedIndex = menuItems.length - 1;
                    }
                    redrawItem(oldSelectedIndex);
                    redrawItem(selectedIndex);
                    redrawCursor();
                    emitHighlight();
                    break;
                case 'cycleNext':
                    if (submittedIndex !== null) {
                        return;
                    }
                    selectedIndex++;
                    if (selectedIndex >= menuItems.length) {
                        selectedIndex = 0;
                    }
                    redrawItem(oldSelectedIndex);
                    redrawItem(selectedIndex);
                    redrawCursor();
                    emitHighlight();
                    break;
                case 'first':
                    if (submittedIndex !== null) {
                        return;
                    }
                    if (selectedIndex !== 0) {
                        selectedIndex = 0;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                        emitHighlight();
                    }
                    break;
                case 'last':
                    if (submittedIndex !== null) {
                        return;
                    }
                    if (selectedIndex !== menuItems.length - 1) {
                        selectedIndex = menuItems.length - 1;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                        emitHighlight();
                    }
                    break;
                case 'cancel':
                    cancel();
                    break;
                case 'escape':
                    if (options.cancelable) {
                        cleanup(void 0, { canceled: true });
                    }
                    if (options.exitOnUnexpectedKey) {
                        cleanup(void 0, { unexpectedKey: key, unexpectedKeyData: data });
                    }
                    break;
                default:
                    if (options.exitOnUnexpectedKey) {
                        cleanup(void 0, { unexpectedKey: key, unexpectedKeyData: data });
                    }
                    break;
            }
        };
        var onMouse = (name2, data) => {
            if (finished || paused || submittedIndex !== null) {
                return;
            }
            if (data.y < start.y || data.y >= end.y) {
                return;
            }
            var i,
                yMin,
                yMax,
                inBounds = false;
            for (i = 0; i < menuItems.length; i++) {
                yMin = start.y + menuItems[i].offsetY;
                yMax = start.y + menuItems[i].offsetY + menuItems[i].displayText.length - 1;
                if (data.y >= yMin && data.y <= yMax && data.x < 1 + outerWidth) {
                    inBounds = true;
                    select(i);
                    break;
                }
            }
            if (inBounds && name2 === 'MOUSE_LEFT_BUTTON_PRESSED') {
                submit();
            }
        };
        controller = Object.create(NextGenEvents$1.prototype);
        controller.defineStates('ready');
        controller.abort = () => {
            if (finished) {
                return;
            }
            cleanup('abort');
        };
        controller.stop = (eraseMenu) => {
            if (finished) {
                return;
            }
            cleanup(void 0, void 0, eraseMenu);
        };
        controller.select = select;
        controller.submit = submit;
        controller.cancel = cancel;
        controller.erase = erase;
        controller.pause = pause;
        controller.resume = resume;
        controller.focus = (value) => {
            if (value) {
                resume();
            } else {
                pause();
            }
        };
        controller.getState = () => ({
            selectedIndex,
            selectedText: menuItems[selectedIndex].text,
            submitted: submittedIndex !== null,
            start,
            end,
            x: 1,
            y: start.y + menuItems[selectedIndex].offsetY,
        });
        controller.getPosition = () => ({ x: start.x, y: start.y });
        controller.hide = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.hide);
                return;
            }
            erase();
        };
        controller.show = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.show);
                return;
            }
            redraw();
        };
        controller.redraw = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.redraw);
                return;
            }
            redraw();
        };
        controller.redrawCursor = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.redrawCursor);
                return;
            }
            redrawCursor();
        };
        controller.rebase = () => {
            if (!controller.hasState('ready')) {
                controller.once('ready', controller.rebase);
                return;
            }
            var wasPaused = paused;
            paused = true;
            this.getCursorLocation((error, x, y) => {
                if (error) {
                    return;
                }
                paused = wasPaused;
                prepareArea(x, y);
                redraw();
                controller.emit('rebased');
            });
        };
        controller.promise = new Promise$6();
        init();
        return controller;
    };
    var Promise$5 = seventh_1;
    var defaultKeyBindings = {
        ENTER: 'submit',
        KP_ENTER: 'submit',
        UP: 'previous',
        DOWN: 'next',
        LEFT: 'previousColumn',
        RIGHT: 'nextColumn',
        TAB: 'cycleNext',
        SHIFT_TAB: 'cyclePrevious',
        HOME: 'first',
        END: 'last',
    };
    var gridMenu = function gridMenu(menuItems_, options, callback) {
        if (arguments.length < 1) {
            throw new Error('[terminal] gridMenu() needs at least an array of menuItems argument');
        }
        if (!Array.isArray(menuItems_) || !menuItems_.length) {
            throw new TypeError('[terminal] gridMenu(): argument #0 should be a non-empty array');
        }
        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (!options || typeof options !== 'object') {
            options = {};
        }
        if (!options.style) {
            options.style = this;
        }
        if (!options.selectedStyle) {
            options.selectedStyle = this.inverse;
        }
        if (options.leftPadding === void 0) {
            options.leftPadding = ' ';
        }
        if (options.selectedLeftPadding === void 0) {
            options.selectedLeftPadding = ' ';
        }
        if (options.rightPadding === void 0) {
            options.rightPadding = ' ';
        }
        if (options.selectedRightPadding === void 0) {
            options.selectedRightPadding = ' ';
        }
        if (!options.x) {
            options.x = 1;
        }
        if (!options.y) {
            this('\n');
        } else {
            this.moveTo(options.x, options.y);
        }
        if (!options.width) {
            options.width = this.width - options.x + 1;
        }
        if (!options.itemMaxWidth) {
            options.itemMaxWidth = Math.floor((options.width - 1) / 3);
        }
        var keyBindings = options.keyBindings || defaultKeyBindings;
        if (!this.grabbing) {
            this.grabInput();
        }
        var start = {},
            selectedIndex = 0,
            finished = false,
            alreadyCleanedUp = false,
            itemInnerWidth = 0,
            itemOuterWidth = 0,
            menuItems,
            columns,
            rows,
            padLength;
        padLength =
            Math.max(options.leftPadding.length, options.selectedLeftPadding.length) +
            Math.max(options.rightPadding.length, options.selectedRightPadding.length);
        menuItems_ = menuItems_.map((element) => {
            if (typeof element !== 'string') {
                element = '' + element;
            }
            itemInnerWidth = Math.max(itemInnerWidth, element.length);
            return element;
        });
        itemInnerWidth = Math.min(itemInnerWidth, options.itemMaxWidth - padLength);
        itemOuterWidth = itemInnerWidth + padLength;
        columns = Math.floor(options.width / itemOuterWidth);
        rows = Math.ceil(menuItems_.length / columns);
        menuItems = menuItems_.map((element, index) => ({
            offsetY: index % rows,
            offsetX: options.x - 1 + Math.floor(index / rows) * itemOuterWidth,
            index,
            text: element,
            displayText:
                element.length > itemInnerWidth
                    ? element.slice(0, itemInnerWidth - 1) + '\u2026'
                    : element + ' '.repeat(itemInnerWidth - element.length),
        }));
        var cleanup = (error, data) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            finished = true;
            this.removeListener('key', onKey);
            this.removeListener('mouse', onMouse);
            this.moveTo(1, start.y + rows);
            if (error) {
                if (callback) {
                    callback(error);
                } else {
                    controller.promise.reject(error);
                }
                return;
            }
            var value =
                data !== void 0
                    ? data
                    : {
                          selectedIndex,
                          selectedText: menuItems[selectedIndex].text,
                          x: 1 + menuItems[selectedIndex].offsetX,
                          y: start.y + menuItems[selectedIndex].offsetY,
                      };
            if (callback) {
                callback(void 0, value);
            } else {
                controller.promise.resolve(value);
            }
        };
        var redraw = () => {
            for (var i = 0; i < menuItems.length; i++) {
                redrawItem(i);
            }
            redrawCursor();
        };
        var redrawItem = (index) => {
            var item = menuItems[index];
            this.moveTo(1 + item.offsetX, start.y + item.offsetY);
            if (index === selectedIndex) {
                options.selectedStyle.noFormat(options.selectedLeftPadding);
                options.selectedStyle.noFormat(item.displayText);
                options.selectedStyle.noFormat(options.selectedRightPadding);
            } else {
                options.style.noFormat(options.leftPadding);
                options.style.noFormat(item.displayText);
                options.style.noFormat(options.rightPadding);
            }
        };
        var redrawCursor = () => {
            this.moveTo(1 + menuItems[selectedIndex].offsetX, start.y + menuItems[selectedIndex].offsetY);
        };
        var onKey = (key, trash, data) => {
            if (finished) {
                return;
            }
            var oldSelectedIndex = selectedIndex;
            switch (keyBindings[key]) {
                case 'submit':
                    cleanup();
                    break;
                case 'previous':
                    if (selectedIndex > 0) {
                        selectedIndex--;
                        redrawItem(selectedIndex);
                        redrawItem(selectedIndex + 1);
                        redrawCursor();
                    }
                    break;
                case 'next':
                    if (selectedIndex < menuItems.length - 1) {
                        selectedIndex++;
                        redrawItem(selectedIndex - 1);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                case 'previousColumn':
                    if (selectedIndex >= rows) {
                        selectedIndex -= rows;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                case 'nextColumn':
                    if (selectedIndex < menuItems.length - rows) {
                        selectedIndex += rows;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                case 'cyclePrevious':
                    selectedIndex--;
                    if (selectedIndex < 0) {
                        selectedIndex = menuItems.length - 1;
                    }
                    redrawItem(oldSelectedIndex);
                    redrawItem(selectedIndex);
                    redrawCursor();
                    break;
                case 'cycleNext':
                    selectedIndex++;
                    if (selectedIndex >= menuItems.length) {
                        selectedIndex = 0;
                    }
                    redrawItem(oldSelectedIndex);
                    redrawItem(selectedIndex);
                    redrawCursor();
                    break;
                case 'first':
                    if (selectedIndex !== 0) {
                        selectedIndex = 0;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                case 'last':
                    if (selectedIndex !== menuItems.length - 1) {
                        selectedIndex = menuItems.length - 1;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                default:
                    if (options.exitOnUnexpectedKey) {
                        cleanup(void 0, { unexpectedKey: key, unexpectedKeyData: data });
                    }
                    break;
            }
        };
        var onMouse = (name2, data) => {
            if (finished) {
                return;
            }
            if (data.y < start.y || data.y >= start.y + rows) {
                return;
            }
            var i,
                inBounds = false,
                oldSelectedIndex = selectedIndex;
            for (i = 0; i < menuItems.length; i++) {
                if (
                    data.y === start.y + menuItems[i].offsetY &&
                    data.x >= 1 + menuItems[i].offsetX &&
                    data.x < 1 + menuItems[i].offsetX + itemOuterWidth
                ) {
                    inBounds = true;
                    if (selectedIndex !== i) {
                        selectedIndex = i;
                        redrawItem(oldSelectedIndex);
                        redrawItem(selectedIndex);
                        redrawCursor();
                    }
                    break;
                }
            }
            if (inBounds && name2 === 'MOUSE_LEFT_BUTTON_PRESSED') {
                cleanup();
            }
        };
        this.getCursorLocation((error, x, y) => {
            if (error) {
                this.row.eraseLineAfter(this.height)('\n');
                x = 1;
                y = this.height;
            }
            start.x = x;
            start.y = y;
            var extra = start.y + rows - this.height;
            if (extra > 0) {
                this('\n'.repeat(extra));
                start.y -= extra;
            }
            redraw();
            this.on('key', onKey);
            if (this.mouseGrabbing) {
                this.on('mouse', onMouse);
            }
        });
        var controller = {};
        controller.promise = new Promise$5();
        return controller;
    };
    var progressBar = function progressBar_(options) {
        if (!options || typeof options !== 'object') {
            options = {};
        }
        var controller = {},
            progress,
            ready = false,
            pause = false,
            maxItems,
            itemsDone = 0,
            itemsStarted = [],
            itemFiller,
            title,
            titleFiller,
            width,
            y,
            startX,
            endX,
            oldWidth,
            wheel,
            wheelCounter = 0,
            itemRollCounter = 0,
            progressUpdateCount = 0,
            lastUpdateTime,
            lastRedrawTime,
            startingTime,
            redrawTimer,
            etaStartingTime,
            etaFiller;
        etaStartingTime = startingTime = new Date().getTime();
        wheel = ['|', '/', '-', '\\'];
        options.syncMode = !!options.syncMode;
        width = options.width || this.width - 1;
        if (!options.barBracketStyle) {
            if (options.barStyle) {
                options.barBracketStyle = options.barStyle;
            } else {
                options.barBracketStyle = this.blue;
            }
        }
        if (!options.barStyle) {
            options.barStyle = this.cyan;
        }
        if (!options.percentStyle) {
            options.percentStyle = this.yellow;
        }
        if (!options.etaStyle) {
            options.etaStyle = this.bold;
        }
        if (!options.itemStyle) {
            options.itemStyle = this.dim;
        }
        if (!options.titleStyle) {
            options.titleStyle = this.bold;
        }
        if (!options.barChar) {
            options.barChar = '=';
        } else {
            options.barChar = options.barChar[0];
        }
        if (!options.barHeadChar) {
            options.barHeadChar = '>';
        } else {
            options.barHeadChar = options.barHeadChar[0];
        }
        if (typeof options.maxRefreshTime !== 'number') {
            options.maxRefreshTime = 500;
        }
        if (typeof options.minRefreshTime !== 'number') {
            options.minRefreshTime = 100;
        }
        if (typeof options.items === 'number') {
            maxItems = options.items;
        }
        if (maxItems && typeof options.itemSize !== 'number') {
            options.itemSize = Math.round(width / 3);
        }
        itemFiller = ' '.repeat(options.itemSize);
        if (options.title && typeof options.title === 'string') {
            title = options.title;
            if (typeof options.titleSize !== 'number') {
                options.titleSize = Math.round(Math.min(options.title.length + 1, width / 3));
            }
        }
        titleFiller = ' '.repeat(options.titleSize);
        etaFiller = '           ';
        var etaString = (updated) => {
            var eta = '',
                elapsedEtaTime,
                remainingTime,
                averageUpdateDelay,
                averageUpdateProgress,
                lastUpdateElapsedTime,
                fakeProgress;
            if (progress >= 1) {
                eta = ' done';
            } else if (progress > 0) {
                new Date().getTime() - startingTime;
                elapsedEtaTime = new Date().getTime() - etaStartingTime;
                if (!updated && progressUpdateCount > 1) {
                    lastUpdateElapsedTime = new Date().getTime() - lastUpdateTime;
                    averageUpdateDelay = elapsedEtaTime / progressUpdateCount;
                    averageUpdateProgress = progress / progressUpdateCount;
                    if (lastUpdateElapsedTime < averageUpdateDelay) {
                        fakeProgress = progress + (averageUpdateProgress * lastUpdateElapsedTime) / averageUpdateDelay;
                    } else {
                        fakeProgress = progress + averageUpdateProgress;
                    }
                    if (fakeProgress > 0.99) {
                        fakeProgress = 0.99;
                    }
                } else {
                    fakeProgress = progress;
                }
                remainingTime = (elapsedEtaTime * ((1 - fakeProgress) / fakeProgress)) / 1e3;
                eta = ' in ';
                if (remainingTime < 10) {
                    eta += Math.round(remainingTime * 10) / 10 + 's';
                } else if (remainingTime < 120) {
                    eta += Math.round(remainingTime) + 's';
                } else if (remainingTime < 7200) {
                    eta += Math.round(remainingTime / 60) + 'min';
                } else if (remainingTime < 172800) {
                    eta += Math.round(remainingTime / 3600) + 'hours';
                } else if (remainingTime < 31536e3) {
                    eta += Math.round(remainingTime / 86400) + 'days';
                } else {
                    eta = 'few years';
                }
            } else {
                etaStartingTime = new Date().getTime();
            }
            eta = (eta + etaFiller).slice(0, etaFiller.length);
            return eta;
        };
        var redraw = (updated) => {
            var time,
                itemIndex,
                itemName = itemFiller,
                titleName = titleFiller,
                innerBarSize,
                progressSize,
                voidSize,
                progressBar = '',
                voidBar = '',
                percent = '',
                eta = '';
            if (!ready || pause) {
                return;
            }
            time = new Date().getTime();
            if ((!progress || progress < 1) && lastRedrawTime && time < lastRedrawTime + options.minRefreshTime) {
                if (!options.syncMode) {
                    if (redrawTimer) {
                        clearTimeout(redrawTimer);
                    }
                    redrawTimer = setTimeout(
                        redraw.bind(this, updated),
                        lastRedrawTime + options.minRefreshTime - time,
                    );
                }
                return;
            }
            this.saveCursor();
            if (y === null) {
                this.column(startX);
            } else {
                this.moveTo(startX, y);
            }
            innerBarSize = width - 2;
            if (options.percent) {
                innerBarSize -= 4;
                percent = ('   ' + Math.round((progress || 0) * 100) + '%').slice(-4);
            }
            if (options.eta) {
                eta = etaString(updated);
                innerBarSize -= eta.length;
            }
            innerBarSize -= options.itemSize || 0;
            if (maxItems) {
                if (!itemsStarted.length) {
                    itemName = '';
                } else if (itemsStarted.length === 1) {
                    itemName = ' ' + itemsStarted[0];
                } else {
                    itemIndex = itemRollCounter++ % itemsStarted.length;
                    itemName = ' [' + (itemIndex + 1) + '/' + itemsStarted.length + '] ' + itemsStarted[itemIndex];
                }
                if (itemName.length > itemFiller.length) {
                    itemName = itemName.slice(0, itemFiller.length - 1) + '\u2026';
                } else if (itemName.length < itemFiller.length) {
                    itemName = (itemName + itemFiller).slice(0, itemFiller.length);
                }
            }
            innerBarSize -= options.titleSize || 0;
            if (title) {
                titleName = title;
                if (titleName.length >= titleFiller.length) {
                    titleName = titleName.slice(0, titleFiller.length - 2) + '\u2026 ';
                } else {
                    titleName = (titleName + titleFiller).slice(0, titleFiller.length);
                }
            }
            progressSize = progress === void 0 ? 1 : Math.round(innerBarSize * Math.max(Math.min(progress, 1), 0));
            voidSize = innerBarSize - progressSize;
            if (progressSize) {
                if (progress === void 0) {
                    progressBar = wheel[++wheelCounter % wheel.length];
                } else {
                    progressBar += options.barChar.repeat(progressSize - 1);
                    progressBar += options.barHeadChar;
                }
            }
            voidBar += ' '.repeat(voidSize);
            options.titleStyle(titleName);
            if (percent) {
                options.percentStyle(percent);
            }
            if (progress === void 0) {
                this(' ');
            } else {
                options.barBracketStyle('[');
            }
            options.barStyle(progressBar);
            this(voidBar);
            if (progress === void 0) {
                this(' ');
            } else {
                options.barBracketStyle(']');
            }
            options.etaStyle(eta);
            options.itemStyle(itemName);
            this.restoreCursor();
            if (!options.syncMode) {
                if (redrawTimer) {
                    clearTimeout(redrawTimer);
                }
                if (!progress || progress < 1) {
                    redrawTimer = setTimeout(redraw, options.maxRefreshTime);
                }
            }
            lastRedrawTime = time;
        };
        if (options.syncMode || options.inline || options.y) {
            oldWidth = width;
            if (options.y) {
                startX = +options.x || 1;
                y = +options.y || 1;
            } else {
                startX = 1;
                y = null;
            }
            endX = Math.min(startX + width, this.width);
            width = endX - startX;
            if (width !== oldWidth) {
                if (options.titleSize) {
                    options.titleSize = Math.floor((options.titleSize * width) / oldWidth);
                }
                if (options.itemSize) {
                    options.itemSize = Math.floor((options.itemSize * width) / oldWidth);
                }
            }
            ready = true;
            redraw();
        } else {
            this.getCursorLocation((error, x_, y_) => {
                if (error) {
                    this.row.eraseLineAfter(this.height)('\n');
                    x_ = 1;
                    y_ = this.height;
                }
                var oldWidth_ = width;
                startX = x_;
                endX = Math.min(x_ + width, this.width);
                y = y_;
                width = endX - startX;
                if (width !== oldWidth_) {
                    if (options.titleSize) {
                        options.titleSize = Math.floor((options.titleSize * width) / oldWidth_);
                    }
                    if (options.itemSize) {
                        options.itemSize = Math.floor((options.itemSize * width) / oldWidth_);
                    }
                }
                ready = true;
                redraw();
            });
        }
        controller.startItem = (name2) => {
            itemsStarted.push(name2);
            if (itemsStarted.length === 1) {
                if (progress >= 1) {
                    redraw();
                    return;
                }
                if (options.syncMode) {
                    redraw();
                } else {
                    if (redrawTimer) {
                        clearTimeout(redrawTimer);
                    }
                    redrawTimer = setTimeout(redraw, 0);
                }
            }
        };
        controller.itemDone = (name2) => {
            var index;
            itemsDone++;
            if (maxItems) {
                progress = itemsDone / maxItems;
            } else {
                progress = void 0;
            }
            lastUpdateTime = new Date().getTime();
            progressUpdateCount++;
            index = itemsStarted.indexOf(name2);
            if (index >= 0) {
                itemsStarted.splice(index, 1);
            }
            if (progress >= 1) {
                redraw(true);
                return;
            }
            if (options.syncMode) {
                redraw();
            } else {
                if (redrawTimer) {
                    clearTimeout(redrawTimer);
                }
                redrawTimer = setTimeout(redraw.bind(this, true), 0);
            }
        };
        controller.update = (toUpdate) => {
            if (!toUpdate) {
                toUpdate = {};
            } else if (typeof toUpdate === 'number') {
                toUpdate = { progress: toUpdate };
            }
            if ('progress' in toUpdate) {
                if (typeof toUpdate.progress !== 'number') {
                    progress = void 0;
                } else {
                    progress = toUpdate.progress;
                    if (progress > 1) {
                        progress = 1;
                    } else if (progress < 0) {
                        progress = 0;
                    }
                    if (progress > 0) {
                        progressUpdateCount++;
                    }
                    lastUpdateTime = new Date().getTime();
                }
            }
            if (typeof toUpdate.items === 'number') {
                maxItems = toUpdate.items;
                if (maxItems) {
                    progress = itemsDone / maxItems;
                }
                if (typeof options.itemSize !== 'number') {
                    options.itemSize = Math.round(width / 3);
                    itemFiller = ' '.repeat(options.itemSize);
                }
            }
            if (typeof toUpdate.title === 'string') {
                title = toUpdate.title;
                if (typeof options.titleSize !== 'number') {
                    options.titleSize = Math.round(width / 3);
                    titleFiller = ' '.repeat(options.titleSize);
                }
            }
            if (progress >= 1) {
                redraw(true);
                return;
            }
            if (options.syncMode) {
                redraw();
            } else {
                if (redrawTimer) {
                    clearTimeout(redrawTimer);
                }
                redrawTimer = setTimeout(redraw.bind(this, true), 0);
            }
        };
        controller.pause = controller.stop = () => {
            pause = true;
        };
        controller.resume = () => {
            if (pause) {
                pause = false;
                redraw();
            }
        };
        controller.reset = () => {
            etaStartingTime = startingTime = new Date().getTime();
            itemsDone = 0;
            progress = void 0;
            itemsStarted.length = 0;
            wheelCounter = itemRollCounter = progressUpdateCount = 0;
            redraw();
        };
        return controller;
    };
    const BIT_DOTS =
        '\u2800\u2801\u2802\u2803\u2804\u2805\u2806\u2807\u2840\u2841\u2842\u2843\u2844\u2845\u2846\u2847\u2808\u2809\u280A\u280B\u280C\u280D\u280E\u280F\u2848\u2849\u284A\u284B\u284C\u284D\u284E\u284F\u2810\u2811\u2812\u2813\u2814\u2815\u2816\u2817\u2850\u2851\u2852\u2853\u2854\u2855\u2856\u2857\u2818\u2819\u281A\u281B\u281C\u281D\u281E\u281F\u2858\u2859\u285A\u285B\u285C\u285D\u285E\u285F\u2820\u2821\u2822\u2823\u2824\u2825\u2826\u2827\u2860\u2861\u2862\u2863\u2864\u2865\u2866\u2867\u2828\u2829\u282A\u282B\u282C\u282D\u282E\u282F\u2868\u2869\u286A\u286B\u286C\u286D\u286E\u286F\u2830\u2831\u2832\u2833\u2834\u2835\u2836\u2837\u2870\u2871\u2872\u2873\u2874\u2875\u2876\u2877\u2838\u2839\u283A\u283B\u283C\u283D\u283E\u283F\u2878\u2879\u287A\u287B\u287C\u287D\u287E\u287F\u2880\u2881\u2882\u2883\u2884\u2885\u2886\u2887\u28C0\u28C1\u28C2\u28C3\u28C4\u28C5\u28C6\u28C7\u2888\u2889\u288A\u288B\u288C\u288D\u288E\u288F\u28C8\u28C9\u28CA\u28CB\u28CC\u28CD\u28CE\u28CF\u2890\u2891\u2892\u2893\u2894\u2895\u2896\u2897\u28D0\u28D1\u28D2\u28D3\u28D4\u28D5\u28D6\u28D7\u2898\u2899\u289A\u289B\u289C\u289D\u289E\u289F\u28D8\u28D9\u28DA\u28DB\u28DC\u28DD\u28DE\u28DF\u28A0\u28A1\u28A2\u28A3\u28A4\u28A5\u28A6\u28A7\u28E0\u28E1\u28E2\u28E3\u28E4\u28E5\u28E6\u28E7\u28A8\u28A9\u28AA\u28AB\u28AC\u28AD\u28AE\u28AF\u28E8\u28E9\u28EA\u28EB\u28EC\u28ED\u28EE\u28EF\u28B0\u28B1\u28B2\u28B3\u28B4\u28B5\u28B6\u28B7\u28F0\u28F1\u28F2\u28F3\u28F4\u28F5\u28F6\u28F7\u28B8\u28B9\u28BA\u28BB\u28BC\u28BD\u28BE\u28BF\u28F8\u28F9\u28FA\u28FB\u28FC\u28FD\u28FE\u28FF'.split(
            '',
        );
    const GROWING_BLOCK = [' ', '\u2581', '\u2582', '\u2583', '\u2584', '\u2585', '\u2586', '\u2587', '\u2588'];
    const ENLARGING_BLOCK = [' ', '\u258F', '\u258E', '\u258D', '\u258C', '\u258B', '\u258A', '\u2589', '\u2588'];
    var spChars$1 = {
        password: '\u25CF',
        forwardSingleQuote: '\xB4',
        overscore: '\xAF',
        multiply: '\xD7',
        divide: '\xF7',
        up: '\u2191',
        down: '\u2193',
        left: '\u2190',
        right: '\u2192',
        leftAndRight: '\u2194',
        upAndDown: '\u2195',
        upLeft: '\u2196',
        upRight: '\u2197',
        downRight: '\u2198',
        downLeft: '\u2199',
        upLeftAndDownRight: '\u2921',
        upRightAndDownLeft: '\u2922',
        northWest: '\u2196',
        northEast: '\u2197',
        southEast: '\u2198',
        southWest: '\u2199',
        northWestAndSouthEast: '\u2921',
        northEastAndSouthWest: '\u2922',
        fullBlock: '\u2588',
        upperHalfBlock: '\u2580',
        lowerHalfBlock: '\u2584',
        growingBlock: GROWING_BLOCK,
        enlargingBlock: ENLARGING_BLOCK,
        bitDots: BIT_DOTS,
        bar: {
            classic: {
                border: ['[', ']'],
                body: ['=', ' '],
            },
            classicWithArrow: {
                border: ['[', ']'],
                body: ['=', '>', ' '],
            },
            classicWithHalf: {
                border: ['[', ']'],
                body: ['=', ' ', '-', '=', ' '],
            },
            solid: {
                border: ['^!\u2589', '\u258F'],
                body: ['\u2588', ...ENLARGING_BLOCK, ' '],
            },
        },
        box: {
            plain: {
                vertical: '\u2588',
                horizontal: '\u2588',
                topLeft: '\u2588',
                topRight: '\u2588',
                bottomLeft: '\u2588',
                bottomRight: '\u2588',
                topTee: '\u2588',
                bottomTee: '\u2588',
                leftTee: '\u2588',
                rightTee: '\u2588',
                cross: '\u2588',
            },
            empty: {
                vertical: ' ',
                horizontal: ' ',
                topLeft: ' ',
                topRight: ' ',
                bottomLeft: ' ',
                bottomRight: ' ',
                topTee: ' ',
                bottomTee: ' ',
                leftTee: ' ',
                rightTee: ' ',
                cross: ' ',
            },
            ascii: {
                vertical: '|',
                horizontal: '-',
                topLeft: '|',
                topRight: '|',
                bottomLeft: '|',
                bottomRight: '|',
                topTee: '-',
                bottomTee: '-',
                leftTee: '|',
                rightTee: '|',
                cross: '+',
            },
            light: {
                vertical: '\u2502',
                horizontal: '\u2500',
                topLeft: '\u250C',
                topRight: '\u2510',
                bottomLeft: '\u2514',
                bottomRight: '\u2518',
                topTee: '\u252C',
                bottomTee: '\u2534',
                leftTee: '\u251C',
                rightTee: '\u2524',
                cross: '\u253C',
            },
            lightRounded: {
                vertical: '\u2502',
                horizontal: '\u2500',
                topLeft: '\u256D',
                topRight: '\u256E',
                bottomLeft: '\u2570',
                bottomRight: '\u256F',
                topTee: '\u252C',
                bottomTee: '\u2534',
                leftTee: '\u251C',
                rightTee: '\u2524',
                cross: '\u253C',
            },
            heavy: {
                vertical: '\u2503',
                horizontal: '\u2501',
                topLeft: '\u250F',
                topRight: '\u2513',
                bottomLeft: '\u2517',
                bottomRight: '\u251B',
                topTee: '\u2533',
                bottomTee: '\u253B',
                leftTee: '\u2523',
                rightTee: '\u252B',
                cross: '\u254B',
            },
            double: {
                vertical: '\u2551',
                horizontal: '\u2550',
                topLeft: '\u2554',
                topRight: '\u2557',
                bottomLeft: '\u255A',
                bottomRight: '\u255D',
                topTee: '\u2566',
                bottomTee: '\u2569',
                leftTee: '\u2560',
                rightTee: '\u2563',
                cross: '\u256C',
            },
            dotted: {
                vertical: '\u250A',
                horizontal: '\u2504',
                topLeft: '\u250C',
                topRight: '\u2510',
                bottomLeft: '\u2514',
                bottomRight: '\u2518',
                topTee: '\u252C',
                bottomTee: '\u2534',
                leftTee: '\u251C',
                rightTee: '\u2524',
                cross: '\u253C',
            },
        },
        animation: {
            asciiSpinner: ['\u2502', '/', '-', '\\'],
            lineSpinner: ['\u2502', '/', '\u2500', '\\'],
            dotSpinner: [
                BIT_DOTS[7],
                BIT_DOTS[19],
                BIT_DOTS[49],
                BIT_DOTS[112],
                BIT_DOTS[224],
                BIT_DOTS[200],
                BIT_DOTS[140],
                BIT_DOTS[14],
            ],
            bitDots: BIT_DOTS,
            impulse: [
                '\u2219\u2219\u2219',
                '\u25CF\u2219\u2219',
                '\u2219\u25CF\u2219',
                '\u2219\u2219\u25CF',
                '\u2219\u25CF\u2219',
                '\u25CF\u2219\u2219',
                '\u2219\u2219\u2219',
                '\u2219\u2219\u2219',
            ],
            unboxing: [
                ' ',
                '\u2581',
                '\u2582',
                '\u2583',
                '\u2584',
                '\u2585',
                '\u2586',
                '\u2587',
                '\u2588',
                '\u2589',
                '\u258A',
                '\u258B',
                '\u258C',
                '\u258D',
                '\u258E',
                '\u258F',
            ],
            'unboxing-color': [
                '^r^#^b ',
                '^r^#^b\u2581',
                '^r^#^b\u2582',
                '^r^#^b\u2583',
                '^r^#^b\u2584',
                '^r^#^b\u2585',
                '^r^#^b\u2586',
                '^r^#^b\u2587',
                '^r^#^m\u2588',
                '^r^#^m\u2589',
                '^r^#^m\u258A',
                '^r^#^m\u258B',
                '^r^#^m\u258C',
                '^r^#^m\u258D',
                '^r^#^m\u258E',
                '^r^#^m\u258F',
                '^m^#^y\u2588',
                '^m^#^y\u2587',
                '^m^#^y\u2586',
                '^m^#^y\u2585',
                '^m^#^y\u2584',
                '^m^#^y\u2583',
                '^m^#^y\u2582',
                '^m^#^y\u2581',
                '^b^#^y ',
                '^b^#^y\u258F',
                '^b^#^y\u258E',
                '^b^#^y\u258D',
                '^b^#^y\u258C',
                '^b^#^y\u258B',
                '^b^#^y\u258A',
                '^b^#^y\u2589',
            ],
        },
        blackSquare: '\u25A0',
        whiteSquare: '\u25A1',
        blackCircle: '\u25CF',
        whiteCircle: '\u25CB',
        blackUpTriangle: '\u25B2',
        whiteUpTriangle: '\u25B3',
        blackDownTriangle: '\u25BC',
        whiteDownTriangle: '\u25BD',
        blackLeftTriangle: '\u25C0',
        whiteLeftTriangle: '\u25C1',
        blackRightTriangle: '\u25B6',
        whiteRightTriangle: '\u25B7',
        blackDiamond: '\u25C6',
        whiteDiamond: '\u25C7',
        blackStar: '\u2605',
        whiteStar: '\u2606',
        spadeSuit: '\u2660',
        heartSuit: '\u2665',
        diamondSuit: '\u2666',
        clubSuit: '\u2663',
        powerline: {
            branch: '\uE0A0',
            line: '\uE0A1',
            readOnly: '\uE0A2',
            rightTriangleSeparator: '\uE0B0',
            rightArrowSeparator: '\uE0B1',
            leftTriangleSeparator: '\uE0B2',
            leftArrowSeparator: '\uE0B3',
        },
    };
    const spChars = spChars$1;
    var bar = function (value, options) {
        var str = '',
            barString = '';
        options = options || {};
        if (isNaN(value) || value < 0) {
            value = 0;
        } else if (value > 1) {
            value = 1;
        }
        var innerSize = options.innerSize || 10;
        var fullBlocks = Math.floor(value * innerSize);
        var partialBlock = Math.round((value * innerSize - fullBlocks) * 8);
        var barStyle = options.barStyle || this.blue;
        barString += '\u2588'.repeat(fullBlocks);
        if (fullBlocks < innerSize) {
            barString += spChars.enlargingBlock[partialBlock];
            barString += ' '.repeat(innerSize - fullBlocks - 1);
        }
        if (options.str) {
            str += this.str.inverse('\u2589');
            str += barStyle.str(barString);
            str += this.str('\u258F');
            return str;
        }
        this.inverse('\u2589');
        barStyle(barString);
        this('\u258F');
        return this;
    };
    var Promise$4 = seventh_1;
    var slowTyping = function slowTyping(str, options, callback) {
        if (typeof str !== 'string') {
            throw new TypeError('[terminal] slowTyping(): argument #0 should be a string');
        }
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (!options || typeof options !== 'object') {
            options = {};
        }
        if (!options.style) {
            options.style = this.green;
        }
        if (!options.delay) {
            options.delay = 150;
        }
        if (!options.flashStyle) {
            options.flashStyle = this.bold.brightGreen;
        }
        if (!options.flashDelay) {
            options.flashDelay = 100;
        }
        var index,
            unflashTimer,
            promise = new Promise$4();
        var printChar = () => {
            if (unflashTimer) {
                clearTimeout(unflashTimer);
                unflashTimer = null;
                unflash();
            }
            if (index === void 0) {
                index = 0;
            } else if (index >= str.length) {
                if (callback) {
                    callback();
                } else {
                    promise.resolve();
                }
                return;
            } else {
                if (options.flashStyle && str[index].match(/\S/)) {
                    options.flashStyle(str[index]);
                    unflashTimer = setTimeout(unflash, options.flashDelay);
                } else {
                    options.style(str[index]);
                }
                index++;
            }
            setTimeout(printChar, (0.2 + Math.random() * 1.8) * options.delay);
        };
        var unflash = () => {
            this.left(1);
            options.style(str[index - 1]);
            unflashTimer = null;
        };
        printChar();
        return promise;
    };
    var extClipboard = {};
    const Promise$3 = seventh_1;
    Promise$3.promisifyNodeApi(require$$2);
    const Promise$2 = seventh_1;
    require$$2.execAsync;
    const execFileAsync = require$$2.execFileAsync;
    const spawn = require$$2.spawn;
    const XCLIP_SELECTION_ARG = {
        c: 'clipboard',
        p: 'primary',
        s: 'secondary',
    };
    if (process.platform === 'linux') {
        extClipboard.getClipboard = (source) =>
            __async(this, null, function* () {
                var arg = XCLIP_SELECTION_ARG[source[0]] || 'clipboard';
                return yield execFileAsync('xclip', ['-o', '-selection', arg]);
            });
        extClipboard.setClipboard = (str, source) =>
            __async(this, null, function* () {
                var promise = new Promise$2();
                var arg = XCLIP_SELECTION_ARG[source[0]] || 'clipboard';
                var xclip = spawn('xclip', ['-i', '-selection', arg]);
                xclip.on('error', (error) => {
                    promise.reject(error);
                });
                xclip.on('exit', (code) => {
                    if (code !== 0) {
                        promise.reject(code);
                    } else {
                        promise.resolve();
                    }
                });
                xclip.stdin.end(str);
                return promise;
            });
    } else {
        extClipboard.getClipboard = () => Promise$2.reject(new Error('No clipboard manipulation program found'));
        extClipboard.setClipboard = () => Promise$2.reject(new Error('No clipboard manipulation program found'));
    }
    var require$$15 = [
        {
            r: 0,
            g: 0,
            b: 0,
            names: ['black'],
        },
        {
            r: 180,
            g: 0,
            b: 0,
            names: ['red'],
        },
        {
            r: 0,
            g: 180,
            b: 0,
            names: ['green'],
        },
        {
            r: 180,
            g: 180,
            b: 0,
            names: ['yellow'],
        },
        {
            r: 0,
            g: 0,
            b: 180,
            names: ['blue'],
        },
        {
            r: 180,
            g: 0,
            b: 180,
            names: ['magenta'],
        },
        {
            r: 0,
            g: 180,
            b: 180,
            names: ['cyan'],
        },
        {
            r: 220,
            g: 220,
            b: 220,
            names: ['white'],
        },
        {
            r: 55,
            g: 55,
            b: 55,
            names: ['brightBlack', 'gray', 'grey'],
        },
        {
            r: 250,
            g: 0,
            b: 0,
            names: ['brightRed'],
        },
        {
            r: 0,
            g: 250,
            b: 0,
            names: ['brightGreen'],
        },
        {
            r: 250,
            g: 250,
            b: 0,
            names: ['brightYellow'],
        },
        {
            r: 0,
            g: 0,
            b: 250,
            names: ['brightBlue'],
        },
        {
            r: 250,
            g: 0,
            b: 250,
            names: ['brightMagenta'],
        },
        {
            r: 0,
            g: 250,
            b: 250,
            names: ['brightCyan'],
        },
        {
            r: 250,
            g: 250,
            b: 250,
            names: ['brightWhite'],
        },
    ];
    const tree = tree_1;
    const string = string$4;
    const NextGenEvents = NextGenEvents_1;
    const Promise$1 = seventh_1;
    const termkit$1 = termkit_1;
    function Terminal(...args) {
        return Terminal.create(...args);
    }
    Terminal.prototype = Object.create(NextGenEvents.prototype);
    Terminal.prototype.constructor = Terminal;
    var Terminal_1 = Terminal;
    Terminal.create = function (createOptions) {
        if (!createOptions || typeof createOptions !== 'object') {
            createOptions = {};
        }
        if (!createOptions.stdin) {
            createOptions.stdin = process.stdin;
        }
        if (!createOptions.stdout) {
            createOptions.stdout = process.stdout;
        }
        if (!createOptions.stderr) {
            createOptions.stderr = process.stderr;
        }
        if (typeof createOptions.generic !== 'string') {
            createOptions.generic = 'xterm';
        }
        var k;
        var termconfig;
        var chainable = Object.create(notChainable);
        var options = {
            on: '',
            off: '',
            params: 0,
            out: createOptions.stdout,
        };
        var term = applyEscape.bind(void 0, options);
        Object.setPrototypeOf(term, chainable);
        term.apply = Function.prototype.apply;
        term.call = Function.prototype.call;
        options.root = term;
        term.root = term;
        term.options = options;
        term.stdin = createOptions.stdin;
        term.stdout = createOptions.stdout;
        term.stderr = createOptions.stderr;
        term.generic = createOptions.generic;
        term.appId = createOptions.appId;
        term.appName = createOptions.appName;
        term.isTTY = createOptions.isTTY === void 0 ? true : !!createOptions.isTTY;
        term.isSSH = !!createOptions.isSSH;
        term.pid = createOptions.pid;
        term.grabbing = false;
        term.mouseGrabbing = false;
        term.focusGrabbing = false;
        term.timeout = term.isSSH ? 500 : 200;
        term.shutdown = false;
        term.raw = term.stdout.write.bind(term.stdout);
        term.onStdin = onStdin.bind(term);
        term.prependStdinChunk = null;
        term.lock = {};
        term.wrapOptions = {
            x: 1,
            width: null,
            continue: false,
            offset: 0,
        };
        term.width = void 0;
        term.height = void 0;
        onResize.call(term);
        if (createOptions.preferProcessSigwinch) {
            process.on('SIGWINCH', onResize.bind(term));
        } else if (term.stdout.isTTY) {
            term.stdout.on('resize', onResize.bind(term));
        } else if (createOptions.processSigwinch) {
            process.on('SIGWINCH', onResize.bind(term));
        }
        term.state = {
            fullscreen: false,
            button: {
                left: null,
                middle: null,
                right: null,
                other: null,
            },
        };
        if (term.appId) {
            try {
                term.termconfigFile = term.appId + '.js';
                termconfig = require('./termconfig/' + term.termconfigFile);
            } catch (error) {}
        }
        if (!termconfig) {
            try {
                term.termconfigFile = term.generic + '.generic.js';
                termconfig = require('./termconfig/' + term.termconfigFile);
            } catch (error) {
                try {
                    term.termconfigFile = term.generic + '.js';
                    termconfig = require('./termconfig/' + term.termconfigFile);
                } catch (error_) {
                    term.termconfigFile = 'xterm.generic.js';
                    termconfig = require('./termconfig/' + term.termconfigFile);
                }
            }
        }
        term.esc = tree.extend({ deep: true }, {}, termconfig.esc);
        term.support = tree.extend({ deep: true }, {}, termconfig.support);
        tree.extend(null, term.esc, pseudoEsc, {
            gray: term.esc.brightBlack,
            grey: term.esc.brightBlack,
            bgGray: term.esc.bgBrightBlack,
            bgGrey: term.esc.bgBrightBlack,
        });
        term.handler = tree.extend(null, {}, termconfig.handler);
        term.keymap = tree.extend({ deep: true }, {}, termconfig.keymap);
        term.colorRegister = tree.extend({ deep: true }, [], defaultColorRegister, termconfig.colorRegister);
        term.escHandler = { root: term };
        term.escOffHandler = { root: term };
        term.rKeymap = [];
        term.rKeymapMaxSize = -1;
        term.rKeymapStarter = [];
        term.rKeymapStarterMaxSize = -1;
        Object.keys(term.keymap).forEach((key) => {
            var i,
                j,
                keymapObject,
                code,
                codeList = term.keymap[key];
            if (!Array.isArray(codeList)) {
                codeList = [codeList];
                term.keymap[key] = codeList;
            }
            for (j = 0; j < codeList.length; j++) {
                code = codeList[j];
                if (typeof code === 'object') {
                    keymapObject = code;
                    keymapObject.name = key;
                    code = keymapObject.code;
                } else {
                    keymapObject = {
                        code,
                        name: key,
                        matches: [key],
                    };
                    term.keymap[key][j] = { code };
                }
                if (keymapObject.handler && typeof keymapObject.handler !== 'function') {
                    term.keymap[key][j].handler = term.handler[keymapObject.handler];
                }
                if (code) {
                    if (code.length > term.rKeymapMaxSize) {
                        for (i = term.rKeymapMaxSize + 1; i <= code.length; i++) {
                            term.rKeymap[i] = {};
                        }
                        term.rKeymapMaxSize = code.length;
                    }
                    if (term.rKeymap[code.length][code]) {
                        term.rKeymap[code.length][code].matches.push(key);
                    } else {
                        term.rKeymap[code.length][code] = keymapObject;
                        term.rKeymap[code.length][code].matches = [key];
                    }
                } else {
                    if (!keymapObject.starter || !keymapObject.ender || !keymapObject.handler) {
                        continue;
                    }
                    if (keymapObject.starter.length > term.rKeymapStarterMaxSize) {
                        for (i = term.rKeymapStarterMaxSize + 1; i <= keymapObject.starter.length; i++) {
                            term.rKeymapStarter[i] = {};
                        }
                        term.rKeymapStarterMaxSize = keymapObject.starter.length;
                    }
                    if (term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter]) {
                        term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter].push(key);
                    } else {
                        term.rKeymapStarter[keymapObject.starter.length][keymapObject.starter] = [keymapObject];
                    }
                }
            }
        });
        Object.keys(term.esc).forEach((key) => {
            if (!term.esc[key] || typeof term.esc[key] !== 'object') {
                console.error(
                    "Bad escape sequence entry '" + key + "' using termconfig: '" + term.termconfigFile + "'.",
                );
                return;
            }
            if (typeof term.esc[key].on === 'function') {
                term.esc[key].on = term.esc[key].on.call(term);
            }
            if (typeof term.esc[key].off === 'function') {
                term.esc[key].off = term.esc[key].off.call(term);
            }
            if (term.esc[key].handler) {
                if (typeof term.esc[key].handler === 'function') {
                    term.escHandler[key] = term.esc[key].handler.bind(term);
                } else {
                    term.escHandler[key] = term.handler[term.esc[key].handler];
                }
            }
            if (term.esc[key].offHandler) {
                if (typeof term.esc[key].offHandler === 'function') {
                    term.escOffHandler[key] = term.esc[key].offHandler.bind(term);
                } else {
                    term.escOffHandler[key] = term.handler[term.esc[key].offHandler];
                }
            }
            Object.defineProperty(chainable, key, {
                configurable: true,
                get: function () {
                    var fn, chainOptions;
                    chainOptions = Object.assign({}, this.options);
                    chainOptions.on += this.root.esc[key].on || '';
                    chainOptions.off = (this.root.esc[key].off || '') + chainOptions.off;
                    chainOptions.params += string.format.count(this.root.esc[key].on);
                    if (
                        !chainOptions.onHasFormatting &&
                        (chainOptions.params ||
                            (typeof this.root.esc[key].on === 'string' &&
                                string.format.hasFormatting(this.root.esc[key].on)))
                    ) {
                        chainOptions.onHasFormatting = true;
                    }
                    if (
                        !chainOptions.offHasFormatting &&
                        typeof this.root.esc[key].off === 'string' &&
                        string.format.hasFormatting(this.root.esc[key].off)
                    ) {
                        chainOptions.offHasFormatting = true;
                    }
                    if (this.root.esc[key].err) {
                        chainOptions.err = true;
                        chainOptions.out = this.root.stderr;
                    }
                    if (this.root.esc[key].str) {
                        chainOptions.str = true;
                    }
                    if (this.root.esc[key].bind) {
                        chainOptions.bind = true;
                    }
                    if (this.root.esc[key].forceStyleOnReset) {
                        chainOptions.forceStyleOnReset = true;
                    }
                    if (this.root.esc[key].noFormat) {
                        chainOptions.noFormat = true;
                    }
                    if (this.root.esc[key].markupOnly) {
                        chainOptions.markupOnly = true;
                    }
                    if (this.root.esc[key].wrap) {
                        chainOptions.wrap = true;
                    }
                    fn = applyEscape.bind(void 0, chainOptions);
                    Object.setPrototypeOf(fn, chainable);
                    fn.apply = Function.prototype.apply;
                    fn.root = this.root || this;
                    fn.options = chainOptions;
                    Object.defineProperty(this, key, { value: fn, configurable: true });
                    return fn;
                },
            });
        });
        term.resetString = '';
        term.setResetString = function (str) {
            term.resetString = string.markupMethod.call(term.formatConfig.rawMarkupConfig, str);
        };
        var resetFn = (extra) => term.str.styleReset() + term.resetString + extra;
        term.formatConfig = {
            fn: {},
            endingMarkupReset: true,
            markupReset: resetFn.bind(void 0, ''),
            shiftMarkup: {
                '#': 'background',
            },
            markup: {
                ':': resetFn.bind(void 0, ''),
                ' ': resetFn.bind(void 0, ' '),
                '-': term.str.dim(),
                '+': term.str.bold(),
                _: term.str.underline(),
                '/': term.str.italic(),
                '!': term.str.inverse(),
                b: term.str.blue(),
                B: term.str.brightBlue(),
                c: term.str.cyan(),
                C: term.str.brightCyan(),
                g: term.str.green(),
                G: term.str.brightGreen(),
                k: term.str.black(),
                K: term.str.brightBlack(),
                m: term.str.magenta(),
                M: term.str.brightMagenta(),
                r: term.str.red(),
                R: term.str.brightRed(),
                w: term.str.white(),
                W: term.str.brightWhite(),
                y: term.str.yellow(),
                Y: term.str.brightYellow(),
            },
            shiftedMarkup: {
                background: {
                    ':': resetFn.bind(void 0, ''),
                    ' ': resetFn.bind(void 0, ' '),
                    b: term.str.bgBlue(),
                    B: term.str.bgBrightBlue(),
                    c: term.str.bgCyan(),
                    C: term.str.bgBrightCyan(),
                    g: term.str.bgGreen(),
                    G: term.str.bgBrightGreen(),
                    k: term.str.bgBlack(),
                    K: term.str.bgBrightBlack(),
                    m: term.str.bgMagenta(),
                    M: term.str.bgBrightMagenta(),
                    r: term.str.bgRed(),
                    R: term.str.bgBrightRed(),
                    w: term.str.bgWhite(),
                    W: term.str.bgBrightWhite(),
                    y: term.str.bgYellow(),
                    Y: term.str.bgBrightYellow(),
                },
            },
        };
        term.formatConfig.rawMarkupConfig = Object.create(term.formatConfig);
        term.formatConfig.rawMarkupConfig.startingMarkupReset = false;
        term.formatConfig.rawMarkupConfig.endingMarkupReset = false;
        for (k in term.escHandler) {
            term.formatConfig.fn[k] = term.escHandler[k];
        }
        for (k in term.escOffHandler) {
            term.formatConfig.fn[k + '_off'] = term.escOffHandler[k];
        }
        term.format = string.createFormatter(term.formatConfig);
        term.markup = string.createMarkup(term.formatConfig);
        term.options = options;
        createOptimized(term);
        process.on('exit', () => {
            if (term.shutdown) {
                return;
            }
            term.shutdown = true;
            term.styleReset();
            term.grabInput(false);
        });
        process.on('asyncExit', (code, timeout, done) => {
            term.asyncCleanup().then(done);
        });
        process.once('beforeExit', () => {
            term.asyncCleanup();
        });
        term.palette = new termkit$1.Palette({ system: true, term });
        return term;
    };
    function createOptimized(term) {
        var i;
        term.optimized = {};
        term.optimized.styleReset = term.str.styleReset();
        term.optimized.bold = term.str.bold();
        term.optimized.dim = term.str.dim();
        term.optimized.italic = term.str.italic();
        term.optimized.underline = term.str.underline();
        term.optimized.blink = term.str.blink();
        term.optimized.inverse = term.str.inverse();
        term.optimized.hidden = term.str.hidden();
        term.optimized.strike = term.str.strike();
        term.optimized.noBold = term.str.bold(false);
        term.optimized.noDim = term.str.dim(false);
        term.optimized.noItalic = term.str.italic(false);
        term.optimized.noUnderline = term.str.underline(false);
        term.optimized.noBlink = term.str.blink(false);
        term.optimized.noInverse = term.str.inverse(false);
        term.optimized.noHidden = term.str.hidden(false);
        term.optimized.noStrike = term.str.strike(false);
        term.optimized.color256 = [];
        term.optimized.bgColor256 = [];
        for (i = 0; i <= 255; i++) {
            term.optimized.color256[i] = term.str.color256(i);
            term.optimized.bgColor256[i] = term.str.bgColor256(i);
        }
        term.optimized.defaultColor = term.str.defaultColor();
        term.optimized.bgDefaultColor = term.str.bgDefaultColor();
        term.optimized.moveTo = term.esc.moveTo.optimized || term.str.moveTo;
        term.optimized.right = term.str.right(1);
        term.optimized.color24bits = term.esc.color24bits.optimized || term.str.color24bits;
        term.optimized.bgColor24bits = term.esc.bgColor24bits.optimized || term.str.bgColor24bits;
    }
    function applyEscape(options, ...args) {
        var fn, newOptions, wrapOptions;
        if (options.bounded) {
            args = options.bounded.concat(args);
        }
        if (options.bind) {
            newOptions = Object.assign({}, options, { bind: false, bounded: args });
            fn = applyEscape.bind(this, newOptions);
            Object.setPrototypeOf(fn, Object.getPrototypeOf(options.root));
            fn.apply = Function.prototype.apply;
            fn.root = options.root;
            fn.options = newOptions;
            return fn;
        }
        var onFormat = [options.on],
            output,
            on,
            off;
        var action = args[options.params];
        if (options.params) {
            onFormat = onFormat.concat(args.slice(0, options.params));
        }
        if (action === void 0 || action === true) {
            on = options.onHasFormatting ? options.root.format(...onFormat) : options.on;
            if (options.str) {
                return on;
            }
            options.out.write(on);
            return options.root;
        }
        if (action === null || action === false) {
            off = options.offHasFormatting ? options.root.format(options.off) : options.off;
            if (options.str) {
                return off;
            }
            options.out.write(off);
            return options.root;
        }
        if (typeof action !== 'string') {
            if (typeof action.toString === 'function') {
                action = action.toString();
            } else {
                action = '';
            }
        }
        on = options.onHasFormatting ? options.root.format(...onFormat) : options.on;
        if (options.markupOnly) {
            action = options.root.markup(...args.slice(options.params));
        } else if (!options.noFormat) {
            action = options.root.format(...args.slice(options.params));
        }
        if (options.wrap) {
            if (options.root.wrapOptions.x && options.root.wrapOptions.x > 1) {
                wrapOptions = {
                    width: options.root.wrapOptions.width || options.root.width - options.root.wrapOptions.x + 1,
                    glue: '\n' + options.root.str.column(options.root.wrapOptions.x),
                    offset: options.root.wrapOptions.offset,
                    updateOffset: true,
                    skipFn: termkit$1.escapeSequenceSkipFn,
                };
                action = string.wordwrap(action, wrapOptions);
                if (!options.root.wrapOptions.continue) {
                    action = options.root.str.column(options.root.wrapOptions.x) + action;
                }
                options.root.wrapOptions.continue = true;
                options.root.wrapOptions.offset = wrapOptions.offset;
            } else {
                wrapOptions = {
                    width: options.root.wrapOptions.width || options.root.width,
                    glue: '\n',
                    offset: options.root.wrapOptions.offset,
                    updateOffset: true,
                    skipFn: termkit$1.escapeSequenceSkipFn,
                };
                action = string.wordwrap(action, wrapOptions);
                options.root.wrapOptions.continue = true;
                options.root.wrapOptions.offset = wrapOptions.offset;
            }
        } else {
            options.root.wrapOptions.continue = false;
            options.root.wrapOptions.offset = 0;
        }
        off = options.offHasFormatting ? options.root.format(options.off) : options.off;
        if (options.forceStyleOnReset) {
            action = action.replace(
                new RegExp(string.escape.regExp(options.root.optimized.styleReset), 'g'),
                options.root.optimized.styleReset + on,
            );
        }
        if (options.root.resetString) {
            output = options.root.resetString + on + action + off + options.root.resetString;
        } else {
            output = on + action + off;
        }
        if (options.crlf) {
            output = output.replace(/\n/g, '\r\n');
        }
        if (options.str) {
            return output;
        }
        options.out.write(output);
        return options.root;
    }
    var pseudoEsc = {
        error: { err: true },
        str: { str: true },
        attr: { attr: true },
        bindArgs: { bind: true },
        forceStyleOnReset: { forceStyleOnReset: true },
        noFormat: { noFormat: true },
        markupOnly: { markupOnly: true },
        wrap: { wrap: true },
        move: {
            on: '%[move:%a%a]F',
            handler: function move(x, y) {
                var sequence = '';
                if (x) {
                    if (x > 0) {
                        sequence += this.root.format(this.root.esc.right.on, x);
                    } else {
                        sequence += this.root.format(this.root.esc.left.on, -x);
                    }
                }
                if (y) {
                    if (y > 0) {
                        sequence += this.root.format(this.root.esc.down.on, y);
                    } else {
                        sequence += this.root.format(this.root.esc.up.on, -y);
                    }
                }
                return sequence;
            },
        },
        color: {
            on: '%[color:%a]F',
            off: function () {
                return this.root.esc.defaultColor.on;
            },
            handler: function color(c) {
                if (typeof c === 'string') {
                    c = termkit$1.colorNameToIndex(c);
                }
                if (typeof c !== 'number') {
                    return '';
                }
                c = Math.floor(c);
                if (c < 0 || c > 15) {
                    return '';
                }
                if (c <= 7) {
                    return this.root.format(this.root.esc.darkColor.on, c);
                }
                return this.root.format(this.root.esc.brightColor.on, c - 8);
            },
        },
        bgColor: {
            on: '%[bgColor:%a]F',
            off: function () {
                return this.root.esc.bgDefaultColor.on;
            },
            handler: function bgColor(c) {
                if (typeof c === 'string') {
                    c = termkit$1.colorNameToIndex(c);
                }
                if (typeof c !== 'number') {
                    return '';
                }
                c = Math.floor(c);
                if (c < 0 || c > 15) {
                    return '';
                }
                if (c <= 7) {
                    return this.root.format(this.root.esc.bgDarkColor.on, c);
                }
                return this.root.format(this.root.esc.bgBrightColor.on, c - 8);
            },
        },
        colorRgb: {
            on: '%[colorRgb:%a%a%a]F',
            off: function () {
                return this.root.esc.defaultColor.on;
            },
            handler: colorRgbHandler,
        },
        bgColorRgb: {
            on: '%[bgColorRgb:%a%a%a]F',
            off: function () {
                return this.root.esc.bgDefaultColor.on;
            },
            handler: bgColorRgbHandler,
        },
        colorRgbHex: {
            on: '%[colorRgbHex:%a]F',
            off: function () {
                return this.root.esc.defaultColor.on;
            },
            handler: colorRgbHandler,
        },
        bgColorRgbHex: {
            on: '%[bgColorRgbHex:%a]F',
            off: function () {
                return this.root.esc.bgDefaultColor.on;
            },
            handler: bgColorRgbHandler,
        },
        colorGrayscale: {
            on: '%[colorGrayscale:%a]F',
            off: function () {
                return this.root.esc.defaultColor.on;
            },
            handler: function colorGrayscale(g) {
                var c;
                if (typeof g !== 'number') {
                    return '';
                }
                if (g < 0 || g > 255) {
                    return '';
                }
                if (!this.root.esc.color24bits.na && !this.root.esc.color24bits.fb) {
                    return this.root.format(this.root.esc.color24bits.on, g, g, g);
                }
                if (!this.root.esc.color256.na && !this.root.esc.color256.fb) {
                    g = Math.round((g * 25) / 255);
                    if (g < 0 || g > 25) {
                        return '';
                    }
                    if (g === 0) {
                        c = 16;
                    } else if (g === 25) {
                        c = 231;
                    } else {
                        c = g + 231;
                    }
                    return this.root.format(this.root.esc.color256.on, c);
                }
                c = this.root.registerForRgb(g, g, g, 0, 15);
                return this.root.format(this.root.esc.color.on, c);
            },
        },
        bgColorGrayscale: {
            on: '%[bgColorGrayscale:%a]F',
            off: function () {
                return this.root.esc.bgDefaultColor.on;
            },
            handler: function bgColorGrayscale(g) {
                var c;
                if (typeof g !== 'number') {
                    return '';
                }
                if (g < 0 || g > 255) {
                    return '';
                }
                if (!this.root.esc.bgColor24bits.na && !this.root.esc.bgColor24bits.fb) {
                    return this.root.format(this.root.esc.bgColor24bits.on, g, g, g);
                }
                if (!this.root.esc.bgColor256.na && !this.root.esc.bgColor256.fb) {
                    g = Math.round((g * 25) / 255);
                    if (g < 0 || g > 25) {
                        return '';
                    }
                    if (g === 0) {
                        c = 16;
                    } else if (g === 25) {
                        c = 231;
                    } else {
                        c = g + 231;
                    }
                    return this.root.format(this.root.esc.bgColor256.on, c);
                }
                c = this.root.registerForRgb(g, g, g, 0, 15);
                return this.root.format(this.root.esc.bgColor.on, c);
            },
        },
    };
    function colorRgbHandler(r, g, b) {
        var c, rgb;
        if (typeof r === 'string') {
            rgb = termkit$1.hexToRgba(r);
            r = rgb.r;
            g = rgb.g;
            b = rgb.b;
        }
        if (
            typeof r !== 'number' ||
            isNaN(r) ||
            typeof g !== 'number' ||
            isNaN(g) ||
            typeof b !== 'number' ||
            isNaN(b) ||
            r < 0 ||
            r > 255 ||
            g < 0 ||
            g > 255 ||
            b < 0 ||
            b > 255
        ) {
            return '';
        }
        if (!this.root.esc.color24bits.na && !this.root.esc.color24bits.fb) {
            return this.root.format(this.root.esc.color24bits.on, r, g, b);
        }
        if (!this.root.esc.color256.na && !this.root.esc.color256.fb) {
            r = Math.round((r * 5) / 255);
            g = Math.round((g * 5) / 255);
            b = Math.round((b * 5) / 255);
            c = 16 + r * 36 + g * 6 + b;
            return this.root.format(this.root.esc.color256.on, c);
        }
        c = this.root.registerForRgb(r, g, b, 0, 15);
        return this.root.format(this.root.esc.color.on, c);
    }
    function bgColorRgbHandler(r, g, b) {
        var c, rgb;
        if (typeof r === 'string') {
            rgb = termkit$1.hexToRgba(r);
            r = rgb.r;
            g = rgb.g;
            b = rgb.b;
        }
        if (
            typeof r !== 'number' ||
            isNaN(r) ||
            typeof g !== 'number' ||
            isNaN(g) ||
            typeof b !== 'number' ||
            isNaN(b) ||
            r < 0 ||
            r > 255 ||
            g < 0 ||
            g > 255 ||
            b < 0 ||
            b > 255
        ) {
            return '';
        }
        if (!this.root.esc.bgColor24bits.na && !this.root.esc.bgColor24bits.fb) {
            return this.root.format(this.root.esc.bgColor24bits.on, r, g, b);
        }
        if (!this.root.esc.bgColor256.na && !this.root.esc.bgColor256.fb) {
            r = Math.round((r * 5) / 255);
            g = Math.round((g * 5) / 255);
            b = Math.round((b * 5) / 255);
            c = 16 + r * 36 + g * 6 + b;
            return this.root.format(this.root.esc.bgColor256.on, c);
        }
        c = this.root.registerForRgb(r, g, b, 0, 15);
        return this.root.format(this.root.esc.bgColor.on, c);
    }
    function onResize() {
        if (this.stdout.columns && this.stdout.rows) {
            this.width = this.stdout.columns;
            this.height = this.stdout.rows;
        }
        this.emit('resize', this.width, this.height);
    }
    var notChainable = Object.create(Terminal.prototype);
    notChainable.yesOrNo = yesOrNo;
    notChainable.inputField = inputField;
    notChainable.fileInput = fileInput;
    notChainable.singleRowMenu = notChainable.singleLineMenu = singleLineMenu;
    notChainable.singleColumnMenu = singleColumnMenu;
    notChainable.gridMenu = gridMenu;
    notChainable.progressBar = progressBar;
    notChainable.bar = bar;
    notChainable.slowTyping = slowTyping;
    notChainable.createDocument = function (options) {
        if (!options || typeof options !== 'object') {
            options = {};
        }
        options.outputDst = this;
        options.eventSource = this;
        return new termkit$1.Document(options);
    };
    notChainable.createInlineElement = function (Type, options) {
        return termkit$1.Element.createInline(this, Type, options);
    };
    notChainable.table = function (table, options = {}) {
        return termkit$1.Element.createInline(
            this,
            termkit$1.TextTable,
            Object.assign({}, options, {
                cellContents: table,
                fit: options.fit !== void 0 ? !!options.fit : true,
            }),
        );
    };
    notChainable.spinner = function (options = {}) {
        if (typeof options === 'string') {
            options = { animation: options };
        }
        return termkit$1.Element.createInline(this, termkit$1.AnimatedText, options);
    };
    notChainable.wrapColumn = function (...args) {
        this.wrapOptions.continue = false;
        this.wrapOptions.offset = 0;
        if (!args.length) {
            return;
        }
        if (args[0] && typeof args[0] === 'object') {
            Object.assign(this.wrapOptions, args[0]);
            return this.wrap;
        }
        if (args.length === 1) {
            this.wrapOptions.x = 1;
            this.wrapOptions.width = args[0];
            return this.wrap;
        }
        this.wrapOptions.x = args[0];
        this.wrapOptions.width = args[1];
        return this.wrap;
    };
    notChainable.fullscreen = function (options) {
        if (options === false) {
            if (!this.state.fullscreen) {
                return this;
            }
            this.state.fullscreen = false;
            this.moveTo(1, this.height, '\n');
            this.alternateScreenBuffer(false);
            return this;
        }
        if (!options) {
            options = {};
        }
        this.state.fullscreen = true;
        if (!options.noAlternate) {
            this.alternateScreenBuffer(true);
        }
        this.clear();
    };
    function onStdin(chunk) {
        var i,
            j,
            buffer,
            startBuffer,
            char,
            codepoint,
            keymapCode,
            keymapStartCode,
            keymap,
            keymapList,
            regexp,
            matches,
            bytes,
            found,
            handlerResult,
            accumulate = false,
            index = 0,
            length = chunk.length;
        if (this.shutdown) {
            return;
        }
        if (this.prependStdinChunk) {
            chunk = Buffer.concat([this.prependStdinChunk, chunk]);
        }
        while (index < length) {
            found = false;
            bytes = 1;
            if (chunk[index] <= 31 || chunk[index] === 127) {
                for (i = Math.min(length, Math.max(this.rKeymapMaxSize, this.rKeymapStarterMaxSize)); i > 0; i--) {
                    buffer = chunk.slice(index);
                    keymapCode = buffer.toString();
                    startBuffer = chunk.slice(index, index + i);
                    keymapStartCode = startBuffer.toString();
                    if (this.rKeymap[i] && this.rKeymap[i][keymapStartCode]) {
                        keymap = this.rKeymap[i][keymapStartCode];
                        found = true;
                        if (keymap.handler) {
                            handlerResult = keymap.handler.call(this, keymap.name, chunk.slice(index + i));
                            bytes = i + handlerResult.eaten;
                            if (!handlerResult.disable) {
                                this.emit(keymap.event, handlerResult.name, handlerResult.data);
                            }
                        } else if (keymap.event) {
                            bytes = i;
                            this.emit(keymap.event, keymap.name, keymap.data, { code: startBuffer });
                        } else {
                            bytes = i;
                            this.emit('key', keymap.name, keymap.matches, { isCharacter: false, code: startBuffer });
                        }
                        break;
                    } else if (this.rKeymapStarter[i] && this.rKeymapStarter[i][keymapStartCode]) {
                        keymapList = this.rKeymapStarter[i][keymapStartCode];
                        for (j = 0; j < keymapList.length; j++) {
                            keymap = keymapList[j];
                            if (keymap.altEnder) {
                                regexp =
                                    '^' +
                                    string.escape.regExp(keymap.starter) +
                                    '([ -~]*?)(' +
                                    string.escape.regExp(keymap.ender) +
                                    '|' +
                                    string.escape.regExp(keymap.altEnder) +
                                    ')';
                            } else {
                                regexp =
                                    '^' +
                                    string.escape.regExp(keymap.starter) +
                                    '([ -~]*?)' +
                                    string.escape.regExp(keymap.ender);
                            }
                            matches = keymapCode.match(new RegExp(regexp), 'g');
                            if (matches) {
                                found = true;
                                handlerResult = keymap.handler.call(this, keymap.name, matches[1]);
                                bytes = matches[0].length;
                                this.emit(keymap.event, handlerResult.name, handlerResult.data);
                                break;
                            } else if (keymap.accumulate) {
                                found = true;
                                accumulate = true;
                                break;
                            }
                        }
                        if (found) {
                            break;
                        }
                    }
                }
                if (!found) {
                    this.emit('unknown', chunk);
                    break;
                }
            } else if (chunk[index] >= 128) {
                if (chunk[index] < 192) {
                    continue;
                } else if (chunk[index] < 224) {
                    bytes = 2;
                } else if (chunk[index] < 240) {
                    bytes = 3;
                } else if (chunk[index] < 248) {
                    bytes = 4;
                } else if (chunk[index] < 252) {
                    bytes = 5;
                } else {
                    bytes = 6;
                }
                buffer = chunk.slice(index, index + bytes);
                char = buffer.toString('utf8');
                if (bytes > 2) {
                    codepoint = string.unicode.firstCodePoint(char);
                } else {
                    codepoint = char.charCodeAt(0);
                }
                this.emit('key', char, [char], { isCharacter: true, codepoint, code: buffer });
            } else {
                char = String.fromCharCode(chunk[index]);
                this.emit('key', char, [char], { isCharacter: true, codepoint: chunk[index], code: chunk[index] });
            }
            index += bytes;
        }
        if (accumulate) {
            this.prependStdinChunk = chunk;
        } else {
            this.prependStdinChunk = null;
        }
    }
    notChainable.grabInput = function (options, safe) {
        this.mouseButton(false);
        this.mouseDrag(false);
        this.mouseMotion(false);
        this.focusEvent(false);
        this.stdin.removeListener('data', this.onStdin);
        this.grabbing = false;
        this.mouseGrabbing = false;
        this.focusGrabbing = false;
        var disable = () => {
            this.stdin.pause();
            try {
                this.stdin.setRawMode(false);
            } catch (error) {}
        };
        if (options === false) {
            if (safe) {
                return Promise$1.resolveSafeTimeout(this.timeout / 2).then(disable);
            }
            disable();
            return Promise$1.resolved;
        }
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        this.grabbing = true;
        if (!options) {
            options = {};
        }
        try {
            this.stdin.setRawMode(true);
        } catch (error) {}
        this.stdin.on('data', this.onStdin);
        this.stdin.resume();
        if (options.mouse) {
            this.mouseGrabbing = true;
            switch (options.mouse) {
                case 'button':
                    this.mouseButton.mouseSGR();
                    break;
                case 'drag':
                    this.mouseDrag.mouseSGR();
                    break;
                case 'motion':
                    this.mouseMotion.mouseSGR();
                    break;
            }
        }
        if (options.focus) {
            this.focusEvent();
            this.focusGrabbing = true;
        }
        return Promise$1.resolved;
    };
    notChainable.processExit = function (code) {
        this('\n');
        this.asyncCleanup().then(() => process.exit(code));
    };
    notChainable.asyncCleanup = function () {
        return __async(this, null, function* () {
            if (this.shutdown) {
                return;
            }
            this.shutdown = true;
            this.styleReset();
            var wasGrabbing = this.grabbing;
            yield this.waitStreamDone(this.stdout);
            if (!this.isTTY || !wasGrabbing) {
                return;
            }
            yield Promise$1.resolveSafeTimeout(this.timeout / 4);
            return this.grabInput(false, true);
        });
    };
    notChainable.waitStreamDone = function (stream) {
        if (!stream._writableState.needDrain) {
            return Promise$1.resolved;
        }
        return Promise$1.onceEvent(stream, 'drain');
    };
    notChainable.object2attr = function (object) {
        var attr = this.esc.styleReset.on;
        if (!object || typeof object !== 'object') {
            object = {};
        }
        if (typeof object.color === 'string') {
            object.color = termkit$1.colorNameToIndex(object.color);
        }
        if (typeof object.color !== 'number' || object.color < 0 || object.color > 255) {
            object.color = 7;
        } else {
            object.color = Math.floor(object.color);
        }
        attr += this.str.color(object.color);
        if (typeof object.bgColor === 'string') {
            object.bgColor = termkit$1.colorNameToIndex(object.bgColor);
        }
        if (typeof object.bgColor !== 'number' || object.bgColor < 0 || object.bgColor > 255) {
            object.bgColor = 0;
        } else {
            object.bgColor = Math.floor(object.bgColor);
        }
        attr += this.str.bgColor(object.bgColor);
        if (object.bold) {
            attr += this.esc.bold.on;
        }
        if (object.dim) {
            attr += this.esc.dim.on;
        }
        if (object.italic) {
            attr += this.esc.italic.on;
        }
        if (object.underline) {
            attr += this.esc.underline.on;
        }
        if (object.blink) {
            attr += this.esc.blink.on;
        }
        if (object.inverse) {
            attr += this.esc.inverse.on;
        }
        if (object.hidden) {
            attr += this.esc.hidden.on;
        }
        if (object.strike) {
            attr += this.esc.strike.on;
        }
        return attr;
    };
    notChainable.eraseArea = function (xMin, yMin, width = 1, height = 1) {
        xMin = Math.min(xMin, this.width);
        yMin = Math.min(yMin, this.height);
        var y,
            xMax = Math.min(xMin + width, this.width + 1),
            yMax = Math.min(yMin + height, this.height + 1),
            str = ' '.repeat(xMax - xMin);
        for (y = yMin; y < yMax; y++) {
            this.moveTo(xMin, y, str);
        }
    };
    notChainable.getCursorLocation = function (callback) {
        var wasGrabbing = this.grabbing,
            alreadyCleanedUp = false,
            error;
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        if (this.esc.requestCursorLocation.na) {
            error = new Error('Terminal is not capable');
            if (callback) {
                callback(error);
                return Promise$1.resolved;
            }
            return Promise$1.reject(error);
        }
        var promise = new Promise$1();
        if (this.lock.getCursorLocation) {
            this.once('unlock_getCursorLocation', () => {
                this.getCursorLocation().then(
                    (data) => {
                        if (callback) {
                            callback(void 0, data.x, data.y);
                        } else {
                            promise.resolve(data);
                        }
                    },
                    (error_) => {
                        if (callback) {
                            callback(error_);
                        } else {
                            promise.reject(error_);
                        }
                    },
                );
            });
            return promise;
        }
        this.lock.getCursorLocation = true;
        var cleanup = (error_, x, y) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            this.removeListener('terminal', onTerminal);
            if (!wasGrabbing) {
                this.grabInput(false);
            }
            if (error_) {
                if (this.shutdown) {
                    error_.code = 'shutdown';
                }
                if (callback) {
                    callback(error_);
                } else {
                    promise.reject(error_);
                }
                return;
            }
            if (callback) {
                callback(void 0, x, y);
            } else {
                promise.resolve({ x, y });
            }
        };
        var onTerminal = (name2, data) => {
            if (name2 !== 'CURSOR_LOCATION') {
                return;
            }
            this.lock.getCursorLocation = false;
            this.emit('unlock_getCursorLocation');
            cleanup(void 0, data.x, data.y);
        };
        if (!wasGrabbing) {
            this.grabInput();
        }
        this.on('terminal', onTerminal);
        this.requestCursorLocation();
        Promise$1.resolveSafeTimeout(this.timeout).then(() => {
            if (alreadyCleanedUp) {
                return;
            }
            var error_ = new Error('.getCursorLocation() timed out');
            error_.code = 'timeout';
            cleanup(error_);
        });
        return promise;
    };
    notChainable.getColor = function (register, callback) {
        var wasGrabbing = this.grabbing,
            alreadyCleanedUp = false,
            error;
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        if (this.esc.requestColor.na) {
            error = new Error('Terminal is not capable');
            if (callback) {
                callback(error);
                return Promise$1.resolved;
            }
            return Promise$1.reject(error);
        }
        var promise = new Promise$1();
        var cleanup = (error_, data) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            this.removeListener('terminal', onTerminal);
            if (!wasGrabbing) {
                this.grabInput(false);
            }
            if (error_) {
                if (this.shutdown) {
                    error_.code = 'shutdown';
                }
                if (callback) {
                    callback(error_);
                } else {
                    promise.reject(error_);
                }
                return;
            }
            if (callback) {
                callback(void 0, data);
            } else {
                promise.resolve(data);
            }
        };
        var onTerminal = (name2, data) => {
            if (name2 !== 'COLOR_REGISTER') {
                return;
            }
            if (data.register !== register) {
                return;
            }
            if (register < 16) {
                this.colorRegister[register] = { r: data.r, g: data.g, b: data.b };
            }
            cleanup(void 0, data);
        };
        if (!wasGrabbing) {
            this.grabInput();
        }
        this.requestColor(register);
        this.on('terminal', onTerminal);
        Promise$1.resolveSafeTimeout(this.timeout).then(() => {
            if (alreadyCleanedUp) {
                return;
            }
            var error_ = new Error('.getColor() timed out');
            error_.code = 'timeout';
            cleanup(error_);
        });
        return promise;
    };
    notChainable.getPalette = function (callback) {
        var defaultPalette,
            wasGrabbing = this.grabbing;
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        if (!wasGrabbing) {
            this.grabInput();
        }
        if (this.esc.requestColor.na) {
            defaultPalette = this.colorRegister.slice(0, 16);
            if (callback) {
                callback(void 0, defaultPalette);
                return Promise$1.resolved;
            }
            return Promise$1.resolve(defaultPalette);
        }
        return Promise$1.concurrent(4, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], (register) =>
            this.getColor(register),
        ).then(
            (palette) => {
                if (!wasGrabbing) {
                    this.grabInput(false);
                }
                if (callback) {
                    callback(void 0, palette);
                } else {
                    return palette;
                }
            },
            (error) => {
                if (!wasGrabbing) {
                    this.grabInput(false);
                }
                if (callback) {
                    callback(error);
                } else {
                    throw error;
                }
            },
        );
    };
    notChainable.setColor = function (register, r, g, b, names) {
        if (r && typeof r === 'object') {
            b = r.b;
            g = r.g;
            r = r.r;
            names = g;
        }
        if (typeof register !== 'number' || register < 0 || register > 15) {
            throw new Error('Bad register value');
        }
        if (!Array.isArray(names)) {
            names = [];
        }
        if (
            typeof r !== 'number' ||
            r < 0 ||
            r > 255 ||
            typeof g !== 'number' ||
            g < 0 ||
            g > 255 ||
            typeof b !== 'number' ||
            b < 0 ||
            b > 255
        ) {
            throw new Error('Bad RGB value');
        }
        if (this.setColorLL.na) {
            return;
        }
        this.colorRegister[register] = {
            r,
            g,
            b,
            names,
        };
        this.setColorLL(register, r, g, b);
    };
    notChainable.setPalette = function (palette) {
        var i;
        if (typeof palette === 'string') {
            try {
                palette = require('./colorScheme/' + palette + '.json');
            } catch (error) {
                throw new Error('[terminal] .setPalette(): color scheme not found: ' + palette);
            }
        }
        if (!Array.isArray(palette)) {
            throw new Error(
                '[terminal] .setPalette(): argument #0 should be an Array of RGB Object or a built-in color scheme',
            );
        }
        if (this.setColorLL.na) {
            return;
        }
        for (i = 0; i <= 15; i++) {
            if (!palette[i] || typeof palette[i] !== 'object') {
                continue;
            }
            this.setColor(i, palette[i]);
        }
    };
    notChainable.getClipboard = function (source = 'c') {
        var wasGrabbing = this.grabbing,
            alreadyCleanedUp = false,
            extClipboard$1;
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        if (this.esc.requestClipboard.na) {
            extClipboard$1 = extClipboard;
            return extClipboard$1.getClipboard(source).catch(() => '');
        }
        var promise = new Promise$1();
        var cleanup = (error_, data) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            this.removeListener('terminal', onTerminal);
            if (!wasGrabbing) {
                this.grabInput(false);
            }
            if (error_) {
                if (this.shutdown) {
                    error_.code = 'shutdown';
                }
                promise.reject(error_);
                return;
            }
            promise.resolve(data);
        };
        var onTerminal = (name2, data) => {
            if (name2 !== 'CLIPBOARD') {
                return;
            }
            cleanup(void 0, data.content);
        };
        if (!wasGrabbing) {
            this.grabInput();
        }
        this.requestClipboard(source[0]);
        this.on('terminal', onTerminal);
        Promise$1.resolveSafeTimeout(this.timeout).then(() => {
            if (alreadyCleanedUp) {
                return;
            }
            var error_ = new Error('.getClipboard() timed out');
            error_.code = 'timeout';
            cleanup(error_);
        });
        return promise;
    };
    notChainable.setClipboard = function (str, source = 'c') {
        return __async(this, null, function* () {
            var extClipboard$1;
            if (this.esc.setClipboardLL.na) {
                extClipboard$1 = extClipboard;
                return extClipboard$1.setClipboard(str, source).catch(() => void 0);
            }
            var base64 = Buffer.from(str).toString('base64');
            this.setClipboardLL(source[0], base64);
            return Promise$1.resolved;
        });
    };
    notChainable.getTerminfo = function (key) {
        var wasGrabbing = this.grabbing,
            alreadyCleanedUp = false;
        if (this.shutdown) {
            return Promise$1.resolved;
        }
        if (this.esc.xtgettcapLL.na) {
            return Promise$1.reject(new Error('Terminal is not capable'));
        }
        var promise = new Promise$1();
        if (this.lock.getTerminfo) {
            this.once('unlock_getTerminfo', () => this.getTerminfo(key).propagate(promise));
            return promise;
        }
        this.lock.getTerminfo = true;
        var cleanup = (error, data) => {
            if (alreadyCleanedUp) {
                return;
            }
            alreadyCleanedUp = true;
            this.removeListener('terminal', onTerminal);
            if (!wasGrabbing) {
                this.grabInput(false);
            }
            if (error) {
                if (this.shutdown) {
                    error.code = 'shutdown';
                }
                promise.reject(error);
                return;
            }
            if (!data.valid || data.key !== key) {
                promise.resolve();
                return;
            }
            promise.resolve(data.value);
        };
        var onTerminal = (name2, data) => {
            if (name2 !== 'TERMINFO') {
                return;
            }
            this.lock.getTerminfo = false;
            this.emit('unlock_getTerminfo');
            cleanup(void 0, data);
        };
        if (!wasGrabbing) {
            this.grabInput();
        }
        this.on('terminal', onTerminal);
        this.xtgettcapLL(Buffer.from(key).toString('hex'));
        Promise$1.resolveSafeTimeout(this.timeout).then(() => {
            if (alreadyCleanedUp) {
                return;
            }
            var error = new Error('.getTerminfo() timed out');
            error.code = 'timeout';
            cleanup(error);
        });
        return promise;
    };
    var defaultColorRegister = require$$15;
    (function buildDefaultColorRegister() {
        var register, offset, factor, l;
        for (register = 16; register < 232; register++) {
            offset = register - 16;
            factor = 255 / 5;
            defaultColorRegister[register] = {
                r: Math.round((Math.floor(offset / 36) % 6) * factor),
                g: Math.round((Math.floor(offset / 6) % 6) * factor),
                b: Math.round((offset % 6) * factor),
                names: [],
            };
        }
        for (register = 232; register <= 255; register++) {
            offset = register - 231;
            factor = 255 / 25;
            l = Math.round(offset * factor);
            defaultColorRegister[register] = {
                r: l,
                g: l,
                b: l,
                names: [],
            };
        }
    })();
    notChainable.rgbForRegister = function (register) {
        if (register < 0 || register > 255) {
            throw new Error('Bad register value');
        }
        return {
            r: this.colorRegister[register].r,
            g: this.colorRegister[register].g,
            b: this.colorRegister[register].b,
        };
    };
    notChainable.registerForRgb = function (r, g, b, minRegister, maxRegister) {
        if (r && typeof r === 'object') {
            maxRegister = b;
            minRegister = g;
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (
            typeof r !== 'number' ||
            r < 0 ||
            r > 255 ||
            typeof g !== 'number' ||
            g < 0 ||
            g > 255 ||
            typeof b !== 'number' ||
            b < 0 ||
            b > 255
        ) {
            throw new Error('Bad RGB value');
        }
        if (typeof maxRegister !== 'number' || maxRegister < 0 || maxRegister > 255) {
            maxRegister = 15;
        }
        if (typeof minRegister !== 'number' || minRegister < 0 || minRegister > 255) {
            minRegister = 0;
        }
        if (minRegister > maxRegister) {
            var tmp;
            tmp = maxRegister;
            maxRegister = minRegister;
            minRegister = tmp;
        }
        return this._registerForRgb(r, g, b, minRegister, maxRegister);
    };
    notChainable._registerForRgb = function (r, g, b, minRegister, maxRegister) {
        var register,
            delta,
            minDelta = Infinity,
            rgb = [r, g, b];
        for (register = minRegister; register <= maxRegister; register++) {
            delta = termkit$1.chroma.distance(rgb, this.colorRegister[register], 'hcl');
            if (delta < minDelta) {
                minDelta = delta;
                minRegister = register;
            }
        }
        return minRegister;
    };
    notChainable.colorNameForRgb = function (r, g, b) {
        return termkit$1.indexToColorName(this.registerForRgb(r, g, b, 0, 15));
    };
    notChainable.colorNameForHex = function (hex) {
        var rgba = termkit$1.hexToRgba(hex);
        return this.colorNameForRgb(rgba.r, rgba.g, rgba.b);
    };
    notChainable.registerForRgbCache = function (cache, r, g, b, minRegister, maxRegister) {
        var key = r + '-' + g + '-' + b;
        if (cache[key]) {
            return cache[key];
        }
        return (cache[key] = this._registerForRgb(r, g, b, minRegister, maxRegister));
    };
    notChainable.drawCursor = function () {};
    notChainable.put = function (options, str, ...args) {
        var i, x, y, dx, dy, attr, wrap, characters, len, moveToNeeded, inline;
        if (!options) {
            options = {};
        }
        wrap = options.wrap === void 0 ? true : options.wrap;
        x = options.x || 0;
        y = options.y || 0;
        if (typeof x !== 'number' || x < 1) {
            x = 1;
        } else if (x > this.width) {
            x = this.width;
        } else {
            x = Math.floor(x);
        }
        if (typeof y !== 'number' || y < 1) {
            y = 1;
        } else if (y > this.height) {
            y = this.height;
        } else {
            y = Math.floor(y);
        }
        dx = 1;
        dy = 0;
        switch (options.direction) {
            case 'left':
                dx = -1;
                break;
            case 'up':
                dx = 0;
                dy = -1;
                break;
            case 'down':
                dx = 0;
                dy = 1;
                break;
            case null:
            case 'none':
                dx = 0;
                dy = 0;
                break;
        }
        if (typeof options.dx === 'number') {
            dx = options.dx;
        }
        if (typeof options.dy === 'number') {
            dy = options.dy;
        }
        inline = dx === 1 && dy === 0;
        attr = options.attr || this.esc.styleReset.on;
        if (attr && typeof attr === 'object') {
            attr = this.object2attr(attr);
        }
        if (typeof attr !== 'string') {
            attr = this.esc.styleReset.on;
        }
        if (typeof str !== 'string') {
            if (str.toString) {
                str = str.toString();
            } else {
                return;
            }
        }
        if (args.length) {
            str = string.format(str, ...args);
        }
        str = termkit$1.stripControlChars(str);
        characters = string.unicode.toArray(str);
        len = characters.length;
        moveToNeeded = true;
        this.stdout.write(attr);
        for (i = 0; i < len; i++) {
            if (moveToNeeded) {
                this.moveTo(x, y);
            }
            this(characters[i]);
            x += dx;
            y += dy;
            moveToNeeded = !inline;
            if (x < 0) {
                if (!wrap) {
                    break;
                }
                x = this.width - 1;
                y--;
                moveToNeeded = true;
            } else if (x >= this.width) {
                if (!wrap) {
                    break;
                }
                x = 0;
                y++;
                moveToNeeded = true;
            }
            if (y < 0) {
                break;
            } else if (y >= this.height) {
                break;
            }
        }
    };
    notChainable.drawNdarrayImage = function (pixels) {
        var x,
            xMax = Math.min(pixels.shape[0], this.width),
            y,
            yMax = Math.ceil(pixels.shape[1] / 2),
            hasAlpha = pixels.shape[2] === 4,
            maxRegister = this.support['256colors'] ? 255 : 15,
            fgColor,
            bgColor,
            fgAlpha,
            bgAlpha,
            cache = {};
        for (y = 0; y < yMax; y++) {
            for (x = 0; x < xMax; x++) {
                if (this.support.trueColor) {
                    fgAlpha = hasAlpha ? pixels.get(x, y * 2, 3) / 255 : 1;
                    if (y * 2 + 1 < pixels.shape[1]) {
                        bgAlpha = hasAlpha ? pixels.get(x, y * 2 + 1, 3) / 255 : 1;
                        this.noFormat(
                            this.optimized.color24bits(
                                Math.round(fgAlpha * pixels.get(x, y * 2, 0)),
                                Math.round(fgAlpha * pixels.get(x, y * 2, 1)),
                                Math.round(fgAlpha * pixels.get(x, y * 2, 2)),
                            ) +
                                this.optimized.bgColor24bits(
                                    Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 0)),
                                    Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 1)),
                                    Math.round(bgAlpha * pixels.get(x, y * 2 + 1, 2)),
                                ) +
                                '\u2580',
                        );
                    } else {
                        this.noFormat(
                            this.optimized.color24bits(
                                Math.round(fgAlpha * pixels.get(x, y * 2, 0)),
                                Math.round(fgAlpha * pixels.get(x, y * 2, 1)),
                                Math.round(fgAlpha * pixels.get(x, y * 2, 2)),
                            ) +
                                this.optimized.bgColor24bits(0, 0, 0) +
                                '\u2580',
                        );
                    }
                } else {
                    fgColor =
                        hasAlpha && pixels.get(x, y * 2, 3) < 127
                            ? 0
                            : this.registerForRgbCache(
                                  cache,
                                  pixels.get(x, y * 2, 0),
                                  pixels.get(x, y * 2, 1),
                                  pixels.get(x, y * 2, 2),
                                  0,
                                  maxRegister,
                              );
                    if (y * 2 + 1 < pixels.shape[1]) {
                        bgColor =
                            hasAlpha && pixels.get(x, y * 2 + 1, 3) < 127
                                ? 0
                                : this.registerForRgbCache(
                                      cache,
                                      pixels.get(x, y * 2 + 1, 0),
                                      pixels.get(x, y * 2 + 1, 1),
                                      pixels.get(x, y * 2 + 1, 2),
                                      0,
                                      maxRegister,
                                  );
                        this.noFormat(this.optimized.color256[fgColor] + this.optimized.bgColor256[bgColor] + '\u2580');
                    } else {
                        this.noFormat(this.optimized.color256[fgColor] + this.optimized.bgColor256[0] + '\u2580');
                    }
                }
            }
            this.styleReset()('\n');
        }
    };
    notChainable.drawImage = function (filepath, options, callback) {
        return termkit$1.image.load.call(this, notChainable.drawNdarrayImage.bind(this), filepath, options, callback);
    };
    var windows = function (termkit) {
        termkit.globalConfig.preferProcessSigwinch = true;
    };
    const termkit = {};
    var termkit_1 = termkit;
    const lazy = Lazyness_1(require);
    termkit.globalConfig = {};
    lazy.requireProperty(termkit, 'tty', './tty.js');
    Object.assign(termkit, misc_1);
    Object.assign(termkit, detectTerminal);
    termkit.Terminal = Terminal_1;
    termkit.createTerminal = termkit.Terminal.create;
    if (process.platform === 'win32') {
        windows(termkit);
    }
    lazy.requireProperties(termkit, {
        image: './image.js',
        Palette: './Palette.js',
        Rect: './Rect.js',
        ScreenBuffer: './ScreenBuffer.js',
        ScreenBufferHD: './ScreenBufferHD.js',
        TextBuffer: './TextBuffer.js',
        Vte: './vte/Vte.js',
        autoComplete: './autoComplete.js',
        spChars: './spChars.js',
        Element: './document/Element.js',
        Document: './document/Document.js',
        Container: './document/Container.js',
        Text: './document/Text.js',
        AnimatedText: './document/AnimatedText.js',
        Button: './document/Button.js',
        ToggleButton: './document/ToggleButton.js',
        TextBox: './document/TextBox.js',
        EditableTextBox: './document/EditableTextBox.js',
        Slider: './document/Slider.js',
        Bar: './document/Bar.js',
        LabeledInput: './document/LabeledInput.js',
        InlineInput: './document/InlineInput.js',
        Form: './document/Form.js',
        RowMenu: './document/RowMenu.js',
        ColumnMenu: './document/ColumnMenu.js',
        ColumnMenuMulti: './document/ColumnMenuMulti.js',
        SelectList: './document/SelectList.js',
        SelectListMulti: './document/SelectListMulti.js',
        DropDownMenu: './document/DropDownMenu.js',
        TextTable: './document/TextTable.js',
        Layout: './document/Layout.js',
        Window: './document/Window.js',
        chroma: 'chroma-js',
    });
    lazy.properties(
        termkit,
        {
            terminal: () => {
                var guessed = termkit.guessTerminal();
                return termkit.createTerminal({
                    stdin: process.stdin,
                    stdout: process.stdout,
                    stderr: process.stderr,
                    generic: guessed.generic || 'unknown',
                    appId: guessed.safe ? guessed.appId : void 0,
                    isTTY: guessed.isTTY,
                    isSSH: guessed.isSSH,
                    processSigwinch: true,
                    preferProcessSigwinch: !!termkit.globalConfig.preferProcessSigwinch,
                });
            },
            realTerminal: () => {
                var guessed = termkit.guessTerminal(true);
                var input = termkit.tty.getInput();
                var output = termkit.tty.getOutput();
                return termkit.createTerminal({
                    stdin: input,
                    stdout: output,
                    stderr: process.stderr,
                    generic: guessed.generic || 'unknown',
                    appId: guessed.safe ? guessed.appId : void 0,
                    isTTY: true,
                    isSSH: guessed.isSSH,
                    processSigwinch: true,
                    preferProcessSigwinch: !!termkit.globalConfig.preferProcessSigwinch,
                });
            },
        },
        true,
    );
    var __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    const __onProcessExitCallbacks = [];
    function onProcessExit(callback) {
        if (!__onProcessExitCallbacks.length) {
            let exitHandler = function (state) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (isExiting) return;
                    isExiting = true;
                    for (let i = 0; i < __onProcessExitCallbacks.length; i++) {
                        const cbFn = __onProcessExitCallbacks[i];
                        yield cbFn(state);
                    }
                    setTimeout(() => {
                        termkit_1.terminal.processExit('SIGTERM');
                    }, 100);
                });
            };
            let isExiting = false;
            process.on('close', (code) => (code === 0 ? exitHandler('success') : exitHandler('error')));
            process.on('exit', (code) => (code === 0 ? exitHandler('success') : exitHandler('error')));
            process.on('custom_exit', (state) => {
                exitHandler(state);
            });
            process.on('SIGINT', () => exitHandler('killed'));
            process.on('SIGUSR1', () => exitHandler('killed'));
            process.on('SIGUSR2', () => exitHandler('killed'));
            process.on('uncaughtException', () => exitHandler('error'));
        }
        if (__onProcessExitCallbacks.indexOf(callback) !== -1) return;
        __onProcessExitCallbacks.push(callback);
    }
    var onProcessExit$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: 'Module',
        default: onProcessExit,
    });
})();

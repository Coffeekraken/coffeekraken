<doc-nav>

    <div class="s-grid:12222">
        <nav class="__nav">
        
            <form name="doc">

                <fieldset class="__nav-search s-mb:30 s-pr:20 s-pt:20">
                    <input type="text" class="s-input s-width:100" name="search" placeholder="Search doc" value="{state.saved.search}" onkeyup="{_search}" />
                </fieldset>

                <fieldset class="__nav-platform s-mb:30">
                    <legend class="s-typo:h6 s-mb:10">
                        Platform
                    </legend>
                    <dl class="s-list s-bg:even">
                        <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface" each="{ (platform, idx) in availablePlatforms }">
                            <label class="s-flex-item:grow" for="platform-{ platform }">
                                { platform }
                            </label>
                            <label class="s-switch:accent" for="platform-{ platform }">
                                <input name="platform-{ platform }" type="checkbox" id="platform-{ platform }" onchange="{() => _togglePlatform(platform)}" checked="{ state.saved.platforms.indexOf(platform) !== -1 }">
                                <div class="s-switch-handler"></div>
                            </label>
                        </dt>
                    </dl>
                </fieldset>

                <fieldset class="__nav-type s-mb:30">
                    <legend class="s-typo:h6 s-mb:10">
                        Type
                    </legend>
                    <dl class="s-list s-bg:even">
                        <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface" each="{ (type, idx) in availableTypes }">
                            <label class="s-flex-item:grow" for="type-{ type }">
                                { type }
                            </label>
                            <label class="s-switch:accent" for="type-{ type }">
                                <input name="type-{ type }" type="checkbox" id="type-{ type }" onchange="{() => _toggleType(type)}" checked="{ state.saved.types.indexOf(type) !== -1 }">
                                <div class="s-switch-handler"></div>
                            </label>
                        </dt>
                    </dl>
                </fieldset>

                <fieldset class="__nav-status s-mb:30">
                    <legend class="s-typo:h6 s-mb:10">
                        Status
                    </legend>
                    <dl class="s-list s-bg:even">
                        <dt class="s-flex s-font:40 s-p:10 s-bg:ui-surface" each="{ (status, idx) in availableStatuses }">
                            <label class="s-flex-item:grow" for="status-{ status }">
                                { status }
                            </label>
                            <label class="s-switch:accent" for="status-{ status }">
                                <input name="status-{ status }" type="checkbox" id="status-{ status }" onchange="{() => _toggleStatus(status)}" checked="{ state.saved.statuses.indexOf(status) !== -1 }">
                                <div class="s-switch-handler"></div>
                            </label>
                        </dt>
                    </dl>
                </fieldset>

            </form>
            

        </nav>
        <section class="__list">
            <div class="__list-item" if="{ idx <= state.maxItemsToDisplay }" each="{ (item, idx) in Object.values(state.filteredItems) }">
                <div class="s-p:50">
                    <div class="">
                        <div class="s-flex">
                            <div class="s-flex-item:grow">
                                <div>
                                    <i class="s-platform:{platform.name} s-font:80 s-mb:30 s-mr:10" each="{ platform in item.platform}"></i>
                                </div>
                                <h4 class="s-font:title s-font:60 s-color:accent s-mb:10 s-flex-item:grow">
                                    <a href="/doc/api/{_striptags(item.namespace)}.{_striptags(item.name)}">
                                        { item.name }
                                    </a>
                                </h4>
                            </div>
                            <div>
                                <div class="s-font:40">
                                    <span class="s-font:30">Since <span class="s-color:complementary">{ item.since }</span></span>
                                    &nbsp;
                                    <span class="s-badge:pill:{ item.status }">{ item.status }</span>
                                </div>
                            </div>
                        </div>
                        <h5 class="s-color:complementary s-font:40 s-mb:30">{ item.namespace }</h5>
                        <p class="s-typo:p s-mb:30">{ item.description }</p>
                    </div>
                    <div if="{ item.example && item.example.length }" class="__code">
                        <s-code-example default-style style="max-width:100%;" class="s-depth:50 s-flex-item:grow:shrink">
                            <textarea lang="{ item.example[0].language }">
                                { item.example[0].code }                    
                            </textarea>
                        </s-code-example>
                    </div>
                </div>
            </div>
        </section>
    </div>


    <style type="postcss">

    </style>

    <script>

        import __SInterface from '@coffeekraken/s-interface';
        import __SComponentUtils from '@coffeekraken/s-component-utils';
        import __SRequest from '@coffeekraken/s-request';
        import __sameItems from '@coffeekraken/sugar/shared/array/sameItems';
        import __striptags from '@coffeekraken/sugar/shared/html/striptags';
        import __onScrollEnd from '@coffeekraken/sugar/js/dom/detect/onScrollEnd';
        import __miniSearch from 'minisearch';
        import __queryStringToObject from '@coffeekraken/sugar/shared/url/queryStringToObject';

        class SDocNavComponentInterface extends __SInterface {
            static definition = {
            }
        }

        export default {
            maxItems: 10,
            state: {
                maxItemsToDisplay: 10,
                filteredItems: {},
                docmap: {},
                saved: {
                    search: undefined,
                    platforms: [],
                    types: [],
                    statuses: []
                }
            },
            _striptags: __striptags,
            // shouldUpdate() {
            //     return this._shouldUpdate;
            // },
            // onBeforeUpdate() {

            // },
            // _shouldUpdate: false,
            async onBeforeMount() {
                // setTimeout(() => {
                //     this._shouldUpdate = true;
                // }, 200);
                this.component = new __SComponentUtils(this.root, this.props, {
                    interface: SDocNavComponentInterface
                });
                const request = new __SRequest({
                    url: '/api/docmap',
                    method: 'GET'
                });

                const docmapJson = (await request.send()).data;
                this.update({
                    docmap: docmapJson
                });

                // restore state
                this._restoreState();

                // query string
                const queryStringObj = __queryStringToObject(document.location.search);
                if (queryStringObj.search) {
                    this.state.saved.search = queryStringObj.search;
                }

                // filter items
                this._filterItems();

                // scroll end
                __onScrollEnd(document.body, () => {
                    this.update({
                        maxItemsToDisplay: this.state.maxItemsToDisplay + this.maxItems
                    });
                });

            },
            get availablePlatforms() {
                if (!this.state.docmap.map) return [];
                const availablePlatforms = [];
                Object.keys(this.state.docmap.map).forEach(namespace => {
                    const docmapObj = this.state.docmap.map[namespace];
                    if (!docmapObj.platform) return;
                    docmapObj.platform.forEach(platform => {
                        if (availablePlatforms.indexOf(platform.name) === -1) availablePlatforms.push(platform.name);
                    });
                });
                return availablePlatforms;
            },
            get availableTypes() {
                if (!this.state.docmap.map) return [];
                const availableTypes = [];
                Object.keys(this.state.docmap.map).forEach(namespace => {
                    const docmapObj = this.state.docmap.map[namespace];
                    if (!docmapObj.type) return;
                    if (availableTypes.indexOf(docmapObj.type) === -1) availableTypes.push(docmapObj.type);
                });
                return availableTypes;
            },
            get availableStatuses() {
                if (!this.state.docmap.map) return [];
                const availableStatus = [];
                Object.keys(this.state.docmap.map).forEach(namespace => {
                    const docmapObj = this.state.docmap.map[namespace];
                    if (!docmapObj.status) return;
                    if (availableStatus.indexOf(docmapObj.status) === -1) availableStatus.push(docmapObj.status);
                });
                return availableStatus;
            },
            
            _filterItems() {

                let items = Object.values(this.state.docmap.map).map(i => {
                    i.id = i.name;
                    return i;
                });

                if (this.state.saved.search) {
                    let miniSearch = new __miniSearch({
                        fields: ['name', 'namespace', 'description', 'since', 'type', 'status'],
                        storeFields: Object.keys(items[0])
                    });
                    miniSearch.addAll(items);
                    items = miniSearch.search(this.state.saved.search);
                }


                items = items.filter(docmapObj => {

                    if (this.state.saved.platforms.length) {
                        if (!docmapObj.platform) return false;
                        const samePlatforms = __sameItems(docmapObj.platform.map(l => l.name), this.state.saved.platforms);
                        if (!samePlatforms.length) return false;
                    }

                    if (this.state.saved.types.length) {
                        if (this.state.saved.types.indexOf(docmapObj.type) === -1) return false;
                    }

                    if (this.state.saved.statuses.length) {
                        if (this.state.saved.statuses.indexOf(docmapObj.status) === -1) return false;
                    }

                    return true;

                });

                this.update({
                    maxItemsToDisplay: this.maxItems,
                    filteredItems: items
                });

            },
            _searchTimeout: 0,
            _search(e) {

                clearTimeout(this._searchTimeout);
                this._searchTimeout = setTimeout(() => {

                    this.update({
                        saved: {
                            ...this.state.saved,
                            search: e.target.value
                        }
                    });

                    // filter items
                    this._filterItems();

                    // save state
                    this._saveState();

                }, 300);
            },
            _togglePlatform(platform) {
                const idx = this.state.saved.platforms.indexOf(platform);
                if (idx !== -1) {
                    this.state.saved.platforms.splice(idx, 1);
                    this.update({
                        saved: {
                            ...this.state.saved,
                            platforms: this.state.saved.platforms
                        }
                    });
                } else {
                    this.update({
                        saved: {
                            ...this.state.saved,
                            platforms: [...this.state.saved.platforms, platform]
                        }
                    });
                }

                // filter items
                this._filterItems();

                // save state
                this._saveState();
            },
            _toggleType(type) {
                const idx = this.state.saved.types.indexOf(type);
                if (idx !== -1) {
                    this.state.saved.types.splice(idx, 1);
                    this.update({
                        saved: {
                            ...this.state.saved,
                            types: this.state.saved.types
                        }
                    });
                } else {
                    this.update({
                        saved: {
                            ...this.state.saved,
                            types: [...this.state.saved.types, type]
                        }
                    });
                }

                // filter items
                this._filterItems();

                // save state
                this._saveState();
            },
            _toggleStatus(status) {
                const idx = this.state.saved.statuses.indexOf(status);
                if (idx !== -1) {
                    this.state.saved.statuses.splice(idx, 1);
                    this.update({
                        saved: {
                            ...this.state.saved,
                            statuses: this.state.saved.statuses,
                        }
                    });
                } else {
                    this.update({
                        saved: {
                            ...this.state.saved,
                            statuses: [...this.state.saved.statuses, status],
                        }
                    });
                }

                // filter items
                this._filterItems();

                // save state
                this._saveState();
            },
            _saveState() {
                window.localStorage.setItem('docState', JSON.stringify(this.state.saved));
            },
            _restoreState() {
                const savedState = JSON.parse(window.localStorage.getItem('docState') ?? '{}');
                this.update({
                    saved: savedState
                });
            }
        }
    </script>

</doc-nav>
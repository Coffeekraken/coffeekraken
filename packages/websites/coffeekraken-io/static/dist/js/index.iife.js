var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp2(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve2(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
!function(OrbitControls_js) {
  "use strict";
  function plainObject$7(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$7(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$7(a2[e4]) && plainObject$7(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  var __assign$6 = function() {
    return (__assign$6 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function lowerCase(e2) {
    return e2.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g], DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(e2, t2) {
    for (var r2 = (t2 = t2 === void 0 ? {} : t2).splitRegexp, n2 = t2.stripRegexp, i2 = n2 === void 0 ? DEFAULT_STRIP_REGEXP : n2, n2 = t2.transform, n2 = n2 === void 0 ? lowerCase : n2, t2 = t2.delimiter, t2 = t2 === void 0 ? " " : t2, a2 = replace(replace(e2, r2 === void 0 ? DEFAULT_SPLIT_REGEXP : r2, "$1\0$2"), i2, "\0"), o2 = 0, s2 = a2.length; a2.charAt(o2) === "\0"; )
      o2++;
    for (; a2.charAt(s2 - 1) === "\0"; )
      s2--;
    return a2.slice(o2, s2).split("\0").map(n2).join(t2);
  }
  function replace(e2, t2, r2) {
    return t2 instanceof RegExp ? e2.replace(t2, r2) : t2.reduce(function(e3, t3) {
      return e3.replace(t3, r2);
    }, e2);
  }
  function dotCase(e2, t2) {
    return noCase(e2, __assign$6({ delimiter: "." }, t2 = t2 === void 0 ? {} : t2));
  }
  function paramCase(e2, t2) {
    return dotCase(e2, __assign$6({ delimiter: "-" }, t2 = t2 === void 0 ? {} : t2));
  }
  function dashCase(e2) {
    return paramCase(e2);
  }
  function wait$2(t2 = 0) {
    return new Promise((e2) => {
      setTimeout(() => {
        e2();
      }, t2);
    });
  }
  function autoCast$1(string) {
    if (typeof string != "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'")
      return string.substr(1, string.length - 2);
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber) && presumedNumber.toString() === string)
      return presumedNumber;
    if (window[string])
      return string;
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e2) {
      return string;
    }
  }
  var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function getDefaultExportFromCjs(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  function commonjsRequire(e2) {
    throw new Error('Could not dynamically require "' + e2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var isClass = { exports: {} }, Ga, Ha;
  Ga = isClass, Ha = isClass.exports, function() {
    const t2 = Function.prototype.toString;
    function e2(e3) {
      if (typeof e3 != "function")
        return false;
      if (/^class[\s{]/.test(t2.call(e3)))
        return true;
      e3 = e3, e3 = t2.call(e3).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
      return /classCallCheck\(/.test(e3) || /TypeError\("Cannot call a class as a function"\)/.test(e3);
    }
    (Ha = Ga.exports ? Ga.exports = e2 : Ha).isClass = e2;
  }();
  var __isClass = isClass.exports;
  function cls(t2) {
    Array.isArray(t2) || (t2 = [t2]);
    for (let e2 = 0; e2 < t2.length; e2++)
      if (!__isClass(t2[e2]))
        return false;
    return true;
  }
  const fn$4 = function(e2, t2 = {}) {
    const r2 = {};
    cls(e2) || (e2 = e2.constructor), t2.includeBaseClass === true && (r2[e2.name] = e2);
    let n2 = e2;
    for (; n2; ) {
      var i2 = Object.getPrototypeOf(n2);
      if (!i2 || i2 === Object || !i2.name)
        break;
      r2[i2.name] = i2, n2 = i2;
    }
    return r2;
  };
  function unique(e2) {
    const r2 = e2.concat();
    for (let t2 = 0; t2 < r2.length; ++t2)
      for (let e3 = t2 + 1; e3 < r2.length; ++e3)
        r2[t2] === r2[e3] && r2.splice(e3--, 1);
    return r2;
  }
  var lodash_clone = { exports: {} };
  !function(e2, t2) {
    var n2 = "__lodash_hash_undefined__", c2 = 9007199254740991, p2 = "[object Arguments]", f2 = "[object Boolean]", m2 = "[object Date]", g2 = "[object Function]", v2 = "[object GeneratorFunction]", y = "[object Map]", _2 = "[object Number]", b2 = "[object Object]", r2 = "[object Promise]", x2 = "[object RegExp]", w2 = "[object Set]", S2 = "[object String]", M2 = "[object Symbol]", i2 = "[object WeakMap]", E2 = "[object ArrayBuffer]", T2 = "[object DataView]", k2 = "[object Float32Array]", A2 = "[object Float64Array]", C2 = "[object Int8Array]", $2 = "[object Int16Array]", R2 = "[object Int32Array]", L = "[object Uint8Array]", O = "[object Uint8ClampedArray]", P2 = "[object Uint16Array]", I2 = "[object Uint32Array]", D = /\w*$/, a2 = /^\[object .+?Constructor\]$/, u2 = /^(?:0|[1-9]\d*)$/, N2 = {};
    N2[p2] = N2["[object Array]"] = N2[E2] = N2[T2] = N2[f2] = N2[m2] = N2[k2] = N2[A2] = N2[C2] = N2[$2] = N2[R2] = N2[y] = N2[_2] = N2[b2] = N2[x2] = N2[w2] = N2[S2] = N2[M2] = N2[L] = N2[O] = N2[P2] = N2[I2] = true, N2["[object Error]"] = N2[g2] = N2[i2] = false;
    var o2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, s2 = typeof self == "object" && self && self.Object === Object && self, l2 = o2 || s2 || Function("return this")(), h2 = t2 && !t2.nodeType && t2, d2 = h2 && e2 && !e2.nodeType && e2, B = d2 && d2.exports === h2;
    function F(e3, t3) {
      return e3.set(t3[0], t3[1]), e3;
    }
    function j2(e3, t3) {
      return e3.add(t3), e3;
    }
    function U(e3, t3, r3, n3) {
      var i3 = -1, a3 = e3 ? e3.length : 0;
      for (n3 && a3 && (r3 = e3[++i3]); ++i3 < a3; )
        r3 = t3(r3, e3[i3], i3, e3);
      return r3;
    }
    function V2(e3) {
      var t3 = false;
      if (e3 != null && typeof e3.toString != "function")
        try {
          t3 = !!(e3 + "");
        } catch (e4) {
        }
      return t3;
    }
    function z(e3) {
      var r3 = -1, n3 = Array(e3.size);
      return e3.forEach(function(e4, t3) {
        n3[++r3] = [t3, e4];
      }), n3;
    }
    function H2(t3, r3) {
      return function(e3) {
        return t3(r3(e3));
      };
    }
    function G(e3) {
      var t3 = -1, r3 = Array(e3.size);
      return e3.forEach(function(e4) {
        r3[++t3] = e4;
      }), r3;
    }
    var o2 = Array.prototype, s2 = Function.prototype, W = Object.prototype, t2 = l2["__core-js_shared__"], q = (d2 = /[^.]+$/.exec(t2 && t2.keys && t2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + d2 : "", Y = s2.toString, X = W.hasOwnProperty, Z = W.toString, K = RegExp("^" + Y.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), h2 = B ? l2.Buffer : void 0, t2 = l2.Symbol, J = l2.Uint8Array, Q = H2(Object.getPrototypeOf, Object), ee = Object.create, te = W.propertyIsEnumerable, re = o2.splice, d2 = Object.getOwnPropertySymbols, s2 = h2 ? h2.isBuffer : void 0, ne = H2(Object.keys, Object), B = Me(l2, "DataView"), ie = Me(l2, "Map"), o2 = Me(l2, "Promise"), h2 = Me(l2, "Set"), l2 = Me(l2, "WeakMap"), ae = Me(Object, "create"), oe = Ae(B), se = Ae(ie), le = Ae(o2), ce = Ae(h2), ue = Ae(l2), t2 = t2 ? t2.prototype : void 0, he = t2 ? t2.valueOf : void 0;
    function de(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function pe(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function fe(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function me(e3) {
      this.__data__ = new pe(e3);
    }
    function ge(e3, t3) {
      var r3, n3, i3, a3, o3 = $e(e3) || function(e4) {
        return function(e5) {
          return !!e5 && typeof e5 == "object";
        }(e4) && Re(e4);
      }(r3 = e3) && X.call(r3, "callee") && (!te.call(r3, "callee") || Z.call(r3) == p2) ? function(e4, t4) {
        for (var r4 = -1, n4 = Array(e4); ++r4 < e4; )
          n4[r4] = t4(r4);
        return n4;
      }(e3.length, String) : [], s3 = o3.length, l3 = !!s3;
      for (n3 in e3)
        !t3 && !X.call(e3, n3) || l3 && (n3 == "length" || (i3 = n3, !!(a3 = (a3 = s3) == null ? c2 : a3) && (typeof i3 == "number" || u2.test(i3)) && -1 < i3 && i3 % 1 == 0 && i3 < a3)) || o3.push(n3);
      return o3;
    }
    function ve(e3, t3, r3) {
      var n3 = e3[t3];
      X.call(e3, t3) && Ce(n3, r3) && (r3 !== void 0 || t3 in e3) || (e3[t3] = r3);
    }
    function ye(e3, t3) {
      for (var r3 = e3.length; r3--; )
        if (Ce(e3[r3][0], t3))
          return r3;
      return -1;
    }
    function _e(r3, n3, i3, a3, e3, t3, o3) {
      var s3;
      if ((s3 = a3 ? t3 ? a3(r3, e3, t3, o3) : a3(r3) : s3) !== void 0)
        return s3;
      if (!Pe(r3))
        return r3;
      var l3, c3 = $e(r3);
      if (c3) {
        if (s3 = function(e4) {
          var t4 = e4.length, r4 = e4.constructor(t4);
          t4 && typeof e4[0] == "string" && X.call(e4, "index") && (r4.index = e4.index, r4.input = e4.input);
          return r4;
        }(r3), !n3)
          return function(e4, t4) {
            var r4 = -1, n4 = e4.length;
            t4 = t4 || Array(n4);
            for (; ++r4 < n4; )
              t4[r4] = e4[r4];
            return t4;
          }(r3, s3);
      } else {
        var u3 = Te(r3), h3 = u3 == g2 || u3 == v2;
        if (Le(r3))
          return function(e4, t4) {
            if (t4)
              return e4.slice();
            t4 = new e4.constructor(e4.length);
            return e4.copy(t4), t4;
          }(r3, n3);
        if (u3 == b2 || u3 == p2 || h3 && !t3) {
          if (V2(r3))
            return t3 ? r3 : {};
          if (s3 = typeof (l3 = h3 ? {} : r3).constructor != "function" || ke(l3) ? {} : function(e4) {
            return Pe(e4) ? ee(e4) : {};
          }(Q(l3)), !n3)
            return h3 = e3 = r3, l3 = (l3 = s3) && we(h3, Ie(h3), l3), we(e3, Ee(e3), l3);
        } else {
          if (!N2[u3])
            return t3 ? r3 : {};
          s3 = function(e4, t4, r4, n4) {
            var i4 = e4.constructor;
            switch (t4) {
              case E2:
                return xe(e4);
              case f2:
              case m2:
                return new i4(+e4);
              case T2:
                return function(e5, t5) {
                  t5 = t5 ? xe(e5.buffer) : e5.buffer;
                  return new e5.constructor(t5, e5.byteOffset, e5.byteLength);
                }(e4, n4);
              case k2:
              case A2:
              case C2:
              case $2:
              case R2:
              case L:
              case O:
              case P2:
              case I2:
                return function(e5, t5) {
                  t5 = t5 ? xe(e5.buffer) : e5.buffer;
                  return new e5.constructor(t5, e5.byteOffset, e5.length);
                }(e4, n4);
              case y:
                return function(e5, t5, r5) {
                  return U(t5 ? r5(z(e5), true) : z(e5), F, new e5.constructor());
                }(e4, n4, r4);
              case _2:
              case S2:
                return new i4(e4);
              case x2:
                return function(e5) {
                  var t5 = new e5.constructor(e5.source, D.exec(e5));
                  return t5.lastIndex = e5.lastIndex, t5;
                }(e4);
              case w2:
                return function(e5, t5, r5) {
                  return U(t5 ? r5(G(e5), true) : G(e5), j2, new e5.constructor());
                }(e4, n4, r4);
              case M2:
                return function(e5) {
                  return he ? Object(he.call(e5)) : {};
                }(e4);
            }
          }(r3, u3, _e, n3);
        }
      }
      var d3, u3 = (o3 = o3 || new me()).get(r3);
      return u3 || (o3.set(r3, s3), function(e4, t4) {
        for (var r4 = -1, n4 = e4 ? e4.length : 0; ++r4 < n4 && t4(e4[r4], r4, e4) !== false; )
          ;
      }((d3 = !c3 ? i3 ? function(e4, t4, r4) {
        t4 = t4(e4);
        return $e(e4) ? t4 : function(e5, t5) {
          for (var r5 = -1, n4 = t5.length, i4 = e5.length; ++r5 < n4; )
            e5[i4 + r5] = t5[r5];
          return e5;
        }(t4, r4(e4));
      }(r3, Ie, Ee) : Ie(r3) : d3) || r3, function(e4, t4) {
        d3 && (e4 = r3[t4 = e4]), ve(s3, t4, _e(e4, n3, i3, a3, t4, r3, o3));
      }), s3);
    }
    function be(e3) {
      var t3;
      return Pe(e3) && (t3 = e3, !(q && q in t3)) && (Oe(e3) || V2(e3) ? K : a2).test(Ae(e3));
    }
    function xe(e3) {
      var t3 = new e3.constructor(e3.byteLength);
      return new J(t3).set(new J(e3)), t3;
    }
    function we(e3, t3, r3, n3) {
      r3 = r3 || {};
      for (var i3 = -1, a3 = t3.length; ++i3 < a3; ) {
        var o3 = t3[i3], s3 = n3 ? n3(r3[o3], e3[o3], o3, r3, e3) : void 0;
        ve(r3, o3, s3 === void 0 ? e3[o3] : s3);
      }
      return r3;
    }
    function Se(e3, t3) {
      var r3, n3 = e3.__data__;
      return ((e3 = typeof (r3 = t3)) == "string" || e3 == "number" || e3 == "symbol" || e3 == "boolean" ? r3 !== "__proto__" : r3 === null) ? n3[typeof t3 == "string" ? "string" : "hash"] : n3.map;
    }
    function Me(e3, t3) {
      t3 = t3, t3 = (e3 = e3) == null ? void 0 : e3[t3];
      return be(t3) ? t3 : void 0;
    }
    de.prototype.clear = function() {
      this.__data__ = ae ? ae(null) : {};
    }, de.prototype.delete = function(e3) {
      return this.has(e3) && delete this.__data__[e3];
    }, de.prototype.get = function(e3) {
      var t3 = this.__data__;
      if (ae) {
        var r3 = t3[e3];
        return r3 === n2 ? void 0 : r3;
      }
      return X.call(t3, e3) ? t3[e3] : void 0;
    }, de.prototype.has = function(e3) {
      var t3 = this.__data__;
      return ae ? t3[e3] !== void 0 : X.call(t3, e3);
    }, de.prototype.set = function(e3, t3) {
      return this.__data__[e3] = ae && t3 === void 0 ? n2 : t3, this;
    }, pe.prototype.clear = function() {
      this.__data__ = [];
    }, pe.prototype.delete = function(e3) {
      var t3 = this.__data__;
      return !((e3 = ye(t3, e3)) < 0) && (e3 == t3.length - 1 ? t3.pop() : re.call(t3, e3, 1), true);
    }, pe.prototype.get = function(e3) {
      var t3 = this.__data__;
      return (e3 = ye(t3, e3)) < 0 ? void 0 : t3[e3][1];
    }, pe.prototype.has = function(e3) {
      return -1 < ye(this.__data__, e3);
    }, pe.prototype.set = function(e3, t3) {
      var r3 = this.__data__, n3 = ye(r3, e3);
      return n3 < 0 ? r3.push([e3, t3]) : r3[n3][1] = t3, this;
    }, fe.prototype.clear = function() {
      this.__data__ = { hash: new de(), map: new (ie || pe)(), string: new de() };
    }, fe.prototype.delete = function(e3) {
      return Se(this, e3).delete(e3);
    }, fe.prototype.get = function(e3) {
      return Se(this, e3).get(e3);
    }, fe.prototype.has = function(e3) {
      return Se(this, e3).has(e3);
    }, fe.prototype.set = function(e3, t3) {
      return Se(this, e3).set(e3, t3), this;
    }, me.prototype.clear = function() {
      this.__data__ = new pe();
    }, me.prototype.delete = function(e3) {
      return this.__data__.delete(e3);
    }, me.prototype.get = function(e3) {
      return this.__data__.get(e3);
    }, me.prototype.has = function(e3) {
      return this.__data__.has(e3);
    }, me.prototype.set = function(e3, t3) {
      var r3 = this.__data__;
      if (r3 instanceof pe) {
        var n3 = r3.__data__;
        if (!ie || n3.length < 199)
          return n3.push([e3, t3]), this;
        r3 = this.__data__ = new fe(n3);
      }
      return r3.set(e3, t3), this;
    };
    var Ee = d2 ? H2(d2, Object) : function() {
      return [];
    }, Te = function(e3) {
      return Z.call(e3);
    };
    function ke(e3) {
      var t3 = e3 && e3.constructor;
      return e3 === (typeof t3 == "function" && t3.prototype || W);
    }
    function Ae(e3) {
      if (e3 != null) {
        try {
          return Y.call(e3);
        } catch (e4) {
        }
        try {
          return e3 + "";
        } catch (e4) {
        }
      }
      return "";
    }
    function Ce(e3, t3) {
      return e3 === t3 || e3 != e3 && t3 != t3;
    }
    (B && Te(new B(new ArrayBuffer(1))) != T2 || ie && Te(new ie()) != y || o2 && Te(o2.resolve()) != r2 || h2 && Te(new h2()) != w2 || l2 && Te(new l2()) != i2) && (Te = function(e3) {
      var t3 = Z.call(e3), e3 = t3 == b2 ? e3.constructor : void 0, e3 = e3 ? Ae(e3) : void 0;
      if (e3)
        switch (e3) {
          case oe:
            return T2;
          case se:
            return y;
          case le:
            return r2;
          case ce:
            return w2;
          case ue:
            return i2;
        }
      return t3;
    });
    var $e = Array.isArray;
    function Re(e3) {
      return e3 != null && (typeof (t3 = e3.length) == "number" && -1 < t3 && t3 % 1 == 0 && t3 <= c2) && !Oe(e3);
      var t3;
    }
    var Le = s2 || function() {
      return false;
    };
    function Oe(e3) {
      e3 = Pe(e3) ? Z.call(e3) : "";
      return e3 == g2 || e3 == v2;
    }
    function Pe(e3) {
      var t3 = typeof e3;
      return e3 && (t3 == "object" || t3 == "function");
    }
    function Ie(e3) {
      return (Re(e3) ? ge : function(e4) {
        if (!ke(e4))
          return ne(e4);
        var t3, r3 = [];
        for (t3 in Object(e4))
          X.call(e4, t3) && t3 != "constructor" && r3.push(t3);
        return r3;
      })(e3);
    }
    e2.exports = function(e3) {
      return _e(e3, false, true);
    };
  }(lodash_clone, lodash_clone.exports);
  var __clone = lodash_clone.exports, lodash_clonedeep = { exports: {} };
  !function(e2, t2) {
    var n2 = "__lodash_hash_undefined__", c2 = 9007199254740991, p2 = "[object Arguments]", f2 = "[object Boolean]", m2 = "[object Date]", g2 = "[object Function]", v2 = "[object GeneratorFunction]", y = "[object Map]", _2 = "[object Number]", b2 = "[object Object]", r2 = "[object Promise]", x2 = "[object RegExp]", w2 = "[object Set]", S2 = "[object String]", M2 = "[object Symbol]", i2 = "[object WeakMap]", E2 = "[object ArrayBuffer]", T2 = "[object DataView]", k2 = "[object Float32Array]", A2 = "[object Float64Array]", C2 = "[object Int8Array]", $2 = "[object Int16Array]", R2 = "[object Int32Array]", L = "[object Uint8Array]", O = "[object Uint8ClampedArray]", P2 = "[object Uint16Array]", I2 = "[object Uint32Array]", D = /\w*$/, a2 = /^\[object .+?Constructor\]$/, u2 = /^(?:0|[1-9]\d*)$/, N2 = {};
    N2[p2] = N2["[object Array]"] = N2[E2] = N2[T2] = N2[f2] = N2[m2] = N2[k2] = N2[A2] = N2[C2] = N2[$2] = N2[R2] = N2[y] = N2[_2] = N2[b2] = N2[x2] = N2[w2] = N2[S2] = N2[M2] = N2[L] = N2[O] = N2[P2] = N2[I2] = true, N2["[object Error]"] = N2[g2] = N2[i2] = false;
    var o2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, s2 = typeof self == "object" && self && self.Object === Object && self, l2 = o2 || s2 || Function("return this")(), h2 = t2 && !t2.nodeType && t2, d2 = h2 && e2 && !e2.nodeType && e2, B = d2 && d2.exports === h2;
    function F(e3, t3) {
      return e3.set(t3[0], t3[1]), e3;
    }
    function j2(e3, t3) {
      return e3.add(t3), e3;
    }
    function U(e3, t3, r3, n3) {
      var i3 = -1, a3 = e3 ? e3.length : 0;
      for (n3 && a3 && (r3 = e3[++i3]); ++i3 < a3; )
        r3 = t3(r3, e3[i3], i3, e3);
      return r3;
    }
    function V2(e3) {
      var t3 = false;
      if (e3 != null && typeof e3.toString != "function")
        try {
          t3 = !!(e3 + "");
        } catch (e4) {
        }
      return t3;
    }
    function z(e3) {
      var r3 = -1, n3 = Array(e3.size);
      return e3.forEach(function(e4, t3) {
        n3[++r3] = [t3, e4];
      }), n3;
    }
    function H2(t3, r3) {
      return function(e3) {
        return t3(r3(e3));
      };
    }
    function G(e3) {
      var t3 = -1, r3 = Array(e3.size);
      return e3.forEach(function(e4) {
        r3[++t3] = e4;
      }), r3;
    }
    var o2 = Array.prototype, s2 = Function.prototype, W = Object.prototype, t2 = l2["__core-js_shared__"], q = (d2 = /[^.]+$/.exec(t2 && t2.keys && t2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + d2 : "", Y = s2.toString, X = W.hasOwnProperty, Z = W.toString, K = RegExp("^" + Y.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), h2 = B ? l2.Buffer : void 0, t2 = l2.Symbol, J = l2.Uint8Array, Q = H2(Object.getPrototypeOf, Object), ee = Object.create, te = W.propertyIsEnumerable, re = o2.splice, d2 = Object.getOwnPropertySymbols, s2 = h2 ? h2.isBuffer : void 0, ne = H2(Object.keys, Object), B = Me(l2, "DataView"), ie = Me(l2, "Map"), o2 = Me(l2, "Promise"), h2 = Me(l2, "Set"), l2 = Me(l2, "WeakMap"), ae = Me(Object, "create"), oe = Ae(B), se = Ae(ie), le = Ae(o2), ce = Ae(h2), ue = Ae(l2), t2 = t2 ? t2.prototype : void 0, he = t2 ? t2.valueOf : void 0;
    function de(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function pe(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function fe(e3) {
      var t3 = -1, r3 = e3 ? e3.length : 0;
      for (this.clear(); ++t3 < r3; ) {
        var n3 = e3[t3];
        this.set(n3[0], n3[1]);
      }
    }
    function me(e3) {
      this.__data__ = new pe(e3);
    }
    function ge(e3, t3) {
      var r3, n3, i3, a3, o3 = $e(e3) || function(e4) {
        return function(e5) {
          return !!e5 && typeof e5 == "object";
        }(e4) && Re(e4);
      }(r3 = e3) && X.call(r3, "callee") && (!te.call(r3, "callee") || Z.call(r3) == p2) ? function(e4, t4) {
        for (var r4 = -1, n4 = Array(e4); ++r4 < e4; )
          n4[r4] = t4(r4);
        return n4;
      }(e3.length, String) : [], s3 = o3.length, l3 = !!s3;
      for (n3 in e3)
        !t3 && !X.call(e3, n3) || l3 && (n3 == "length" || (i3 = n3, !!(a3 = (a3 = s3) == null ? c2 : a3) && (typeof i3 == "number" || u2.test(i3)) && -1 < i3 && i3 % 1 == 0 && i3 < a3)) || o3.push(n3);
      return o3;
    }
    function ve(e3, t3, r3) {
      var n3 = e3[t3];
      X.call(e3, t3) && Ce(n3, r3) && (r3 !== void 0 || t3 in e3) || (e3[t3] = r3);
    }
    function ye(e3, t3) {
      for (var r3 = e3.length; r3--; )
        if (Ce(e3[r3][0], t3))
          return r3;
      return -1;
    }
    function _e(r3, n3, i3, a3, e3, t3, o3) {
      var s3;
      if ((s3 = a3 ? t3 ? a3(r3, e3, t3, o3) : a3(r3) : s3) !== void 0)
        return s3;
      if (!Pe(r3))
        return r3;
      var l3, c3 = $e(r3);
      if (c3) {
        if (s3 = function(e4) {
          var t4 = e4.length, r4 = e4.constructor(t4);
          t4 && typeof e4[0] == "string" && X.call(e4, "index") && (r4.index = e4.index, r4.input = e4.input);
          return r4;
        }(r3), !n3)
          return function(e4, t4) {
            var r4 = -1, n4 = e4.length;
            t4 = t4 || Array(n4);
            for (; ++r4 < n4; )
              t4[r4] = e4[r4];
            return t4;
          }(r3, s3);
      } else {
        var u3 = Te(r3), h3 = u3 == g2 || u3 == v2;
        if (Le(r3))
          return function(e4, t4) {
            if (t4)
              return e4.slice();
            t4 = new e4.constructor(e4.length);
            return e4.copy(t4), t4;
          }(r3, n3);
        if (u3 == b2 || u3 == p2 || h3 && !t3) {
          if (V2(r3))
            return t3 ? r3 : {};
          if (s3 = typeof (l3 = h3 ? {} : r3).constructor != "function" || ke(l3) ? {} : function(e4) {
            return Pe(e4) ? ee(e4) : {};
          }(Q(l3)), !n3)
            return h3 = e3 = r3, l3 = (l3 = s3) && we(h3, Ie(h3), l3), we(e3, Ee(e3), l3);
        } else {
          if (!N2[u3])
            return t3 ? r3 : {};
          s3 = function(e4, t4, r4, n4) {
            var i4 = e4.constructor;
            switch (t4) {
              case E2:
                return xe(e4);
              case f2:
              case m2:
                return new i4(+e4);
              case T2:
                return function(e5, t5) {
                  t5 = t5 ? xe(e5.buffer) : e5.buffer;
                  return new e5.constructor(t5, e5.byteOffset, e5.byteLength);
                }(e4, n4);
              case k2:
              case A2:
              case C2:
              case $2:
              case R2:
              case L:
              case O:
              case P2:
              case I2:
                return function(e5, t5) {
                  t5 = t5 ? xe(e5.buffer) : e5.buffer;
                  return new e5.constructor(t5, e5.byteOffset, e5.length);
                }(e4, n4);
              case y:
                return function(e5, t5, r5) {
                  return U(t5 ? r5(z(e5), true) : z(e5), F, new e5.constructor());
                }(e4, n4, r4);
              case _2:
              case S2:
                return new i4(e4);
              case x2:
                return function(e5) {
                  var t5 = new e5.constructor(e5.source, D.exec(e5));
                  return t5.lastIndex = e5.lastIndex, t5;
                }(e4);
              case w2:
                return function(e5, t5, r5) {
                  return U(t5 ? r5(G(e5), true) : G(e5), j2, new e5.constructor());
                }(e4, n4, r4);
              case M2:
                return function(e5) {
                  return he ? Object(he.call(e5)) : {};
                }(e4);
            }
          }(r3, u3, _e, n3);
        }
      }
      var d3, u3 = (o3 = o3 || new me()).get(r3);
      return u3 || (o3.set(r3, s3), function(e4, t4) {
        for (var r4 = -1, n4 = e4 ? e4.length : 0; ++r4 < n4 && t4(e4[r4], r4, e4) !== false; )
          ;
      }((d3 = !c3 ? i3 ? function(e4, t4, r4) {
        t4 = t4(e4);
        return $e(e4) ? t4 : function(e5, t5) {
          for (var r5 = -1, n4 = t5.length, i4 = e5.length; ++r5 < n4; )
            e5[i4 + r5] = t5[r5];
          return e5;
        }(t4, r4(e4));
      }(r3, Ie, Ee) : Ie(r3) : d3) || r3, function(e4, t4) {
        d3 && (e4 = r3[t4 = e4]), ve(s3, t4, _e(e4, n3, i3, a3, t4, r3, o3));
      }), s3);
    }
    function be(e3) {
      var t3;
      return Pe(e3) && (t3 = e3, !(q && q in t3)) && (Oe(e3) || V2(e3) ? K : a2).test(Ae(e3));
    }
    function xe(e3) {
      var t3 = new e3.constructor(e3.byteLength);
      return new J(t3).set(new J(e3)), t3;
    }
    function we(e3, t3, r3, n3) {
      r3 = r3 || {};
      for (var i3 = -1, a3 = t3.length; ++i3 < a3; ) {
        var o3 = t3[i3], s3 = n3 ? n3(r3[o3], e3[o3], o3, r3, e3) : void 0;
        ve(r3, o3, s3 === void 0 ? e3[o3] : s3);
      }
      return r3;
    }
    function Se(e3, t3) {
      var r3, n3 = e3.__data__;
      return ((e3 = typeof (r3 = t3)) == "string" || e3 == "number" || e3 == "symbol" || e3 == "boolean" ? r3 !== "__proto__" : r3 === null) ? n3[typeof t3 == "string" ? "string" : "hash"] : n3.map;
    }
    function Me(e3, t3) {
      t3 = t3, t3 = (e3 = e3) == null ? void 0 : e3[t3];
      return be(t3) ? t3 : void 0;
    }
    de.prototype.clear = function() {
      this.__data__ = ae ? ae(null) : {};
    }, de.prototype.delete = function(e3) {
      return this.has(e3) && delete this.__data__[e3];
    }, de.prototype.get = function(e3) {
      var t3 = this.__data__;
      if (ae) {
        var r3 = t3[e3];
        return r3 === n2 ? void 0 : r3;
      }
      return X.call(t3, e3) ? t3[e3] : void 0;
    }, de.prototype.has = function(e3) {
      var t3 = this.__data__;
      return ae ? t3[e3] !== void 0 : X.call(t3, e3);
    }, de.prototype.set = function(e3, t3) {
      return this.__data__[e3] = ae && t3 === void 0 ? n2 : t3, this;
    }, pe.prototype.clear = function() {
      this.__data__ = [];
    }, pe.prototype.delete = function(e3) {
      var t3 = this.__data__;
      return !((e3 = ye(t3, e3)) < 0) && (e3 == t3.length - 1 ? t3.pop() : re.call(t3, e3, 1), true);
    }, pe.prototype.get = function(e3) {
      var t3 = this.__data__;
      return (e3 = ye(t3, e3)) < 0 ? void 0 : t3[e3][1];
    }, pe.prototype.has = function(e3) {
      return -1 < ye(this.__data__, e3);
    }, pe.prototype.set = function(e3, t3) {
      var r3 = this.__data__, n3 = ye(r3, e3);
      return n3 < 0 ? r3.push([e3, t3]) : r3[n3][1] = t3, this;
    }, fe.prototype.clear = function() {
      this.__data__ = { hash: new de(), map: new (ie || pe)(), string: new de() };
    }, fe.prototype.delete = function(e3) {
      return Se(this, e3).delete(e3);
    }, fe.prototype.get = function(e3) {
      return Se(this, e3).get(e3);
    }, fe.prototype.has = function(e3) {
      return Se(this, e3).has(e3);
    }, fe.prototype.set = function(e3, t3) {
      return Se(this, e3).set(e3, t3), this;
    }, me.prototype.clear = function() {
      this.__data__ = new pe();
    }, me.prototype.delete = function(e3) {
      return this.__data__.delete(e3);
    }, me.prototype.get = function(e3) {
      return this.__data__.get(e3);
    }, me.prototype.has = function(e3) {
      return this.__data__.has(e3);
    }, me.prototype.set = function(e3, t3) {
      var r3 = this.__data__;
      if (r3 instanceof pe) {
        var n3 = r3.__data__;
        if (!ie || n3.length < 199)
          return n3.push([e3, t3]), this;
        r3 = this.__data__ = new fe(n3);
      }
      return r3.set(e3, t3), this;
    };
    var Ee = d2 ? H2(d2, Object) : function() {
      return [];
    }, Te = function(e3) {
      return Z.call(e3);
    };
    function ke(e3) {
      var t3 = e3 && e3.constructor;
      return e3 === (typeof t3 == "function" && t3.prototype || W);
    }
    function Ae(e3) {
      if (e3 != null) {
        try {
          return Y.call(e3);
        } catch (e4) {
        }
        try {
          return e3 + "";
        } catch (e4) {
        }
      }
      return "";
    }
    function Ce(e3, t3) {
      return e3 === t3 || e3 != e3 && t3 != t3;
    }
    (B && Te(new B(new ArrayBuffer(1))) != T2 || ie && Te(new ie()) != y || o2 && Te(o2.resolve()) != r2 || h2 && Te(new h2()) != w2 || l2 && Te(new l2()) != i2) && (Te = function(e3) {
      var t3 = Z.call(e3), e3 = t3 == b2 ? e3.constructor : void 0, e3 = e3 ? Ae(e3) : void 0;
      if (e3)
        switch (e3) {
          case oe:
            return T2;
          case se:
            return y;
          case le:
            return r2;
          case ce:
            return w2;
          case ue:
            return i2;
        }
      return t3;
    });
    var $e = Array.isArray;
    function Re(e3) {
      return e3 != null && (typeof (t3 = e3.length) == "number" && -1 < t3 && t3 % 1 == 0 && t3 <= c2) && !Oe(e3);
      var t3;
    }
    var Le = s2 || function() {
      return false;
    };
    function Oe(e3) {
      e3 = Pe(e3) ? Z.call(e3) : "";
      return e3 == g2 || e3 == v2;
    }
    function Pe(e3) {
      var t3 = typeof e3;
      return e3 && (t3 == "object" || t3 == "function");
    }
    function Ie(e3) {
      return (Re(e3) ? ge : function(e4) {
        if (!ke(e4))
          return ne(e4);
        var t3, r3 = [];
        for (t3 in Object(e4))
          X.call(e4, t3) && t3 != "constructor" && r3.push(t3);
        return r3;
      })(e3);
    }
    e2.exports = function(e3) {
      return _e(e3, true, true);
    };
  }(lodash_clonedeep, lodash_clonedeep.exports);
  var __deepClone = lodash_clonedeep.exports;
  function clone$2(e2, t2 = {}) {
    return ((t2 = Object.assign({ deep: false }, t2)).deep ? __deepClone : __clone)(e2);
  }
  function deepAssign(t2, ...r2) {
    const a2 = { array: false, object: true, cloneChilds: true };
    var e2 = r2[r2.length - 1] || {};
    (e2.array && typeof e2.array == "boolean" || e2.object && typeof e2.object == "boolean") && (e2.array !== void 0 && (a2.array = e2.array), e2.object !== void 0 && (a2.object = e2.object), r2.pop());
    for (let e3 = 0; e3 < r2.length; e3++)
      !function e4(t3, r3) {
        for (const i2 of Object.keys(r3)) {
          var n2;
          a2.array === true && Array.isArray(t3[i2]) && Array.isArray(r3[i2]) ? (n2 = unique([...t3[i2], ...r3[i2]]), t3[i2] = n2) : a2.object === true && plainObject$7(t3[i2]) && plainObject$7(r3[i2]) ? t3[i2] = e4(t3[i2], r3[i2]) : plainObject$7(r3[i2]) && a2.cloneChilds ? t3[i2] = clone$2(r3[i2], { deep: true }) : t3[i2] = r3[i2];
        }
        return t3;
      }(t2, r2[e3] || {});
    return t2;
  }
  function unquote(t2, e2 = ['"', "'", "\u201D", "`"]) {
    return t2 = t2.trim(), e2.forEach((e3) => {
      t2.substr(0, 1) === e3 && t2.substr(-1) === e3 && (t2 = (t2 = t2.substr(1)).substr(0, t2.length - 1));
    }), t2;
  }
  function get$3(t2, r2, n2 = {}) {
    if (n2 = Object.assign({}, n2), t2[r2] !== void 0)
      return t2[r2];
    if (!r2 || r2 === "" || r2 === ".")
      return t2;
    let i2 = [(r2 = (r2 = r2.replace(/\[(\w+)\]/g, ".$1")).replace(/^\./, "")).replace(/\?/gm, "")];
    const a2 = r2.split(".");
    for (let e2 = a2.length - 1; 0 <= e2; e2--) {
      const l2 = a2[e2];
      if (l2.match(/\?$/)) {
        var o2 = a2.slice(0, e2);
        const c2 = a2.slice(e2 + 1);
        i2.push([...o2, ...c2].join(".")), i2.push([...o2, ...c2.filter((e3) => !e3.match(/\?$/))].join("."));
      }
    }
    i2 = unique(i2.map((e2) => e2.replace(/\?/gm, "")));
    for (let e2 = 0; e2 < i2.length; e2++) {
      const r3 = i2[e2];
      var s2 = __get(t2, r3, n2);
      if (s2 !== void 0)
        return s2;
    }
  }
  function __get(e2, t2, r2 = {}) {
    if (r2 = Object.assign({}, r2), e2[t2] !== void 0)
      return e2[t2];
    if (!t2 || t2 === "" || t2 === ".")
      return e2;
    const n2 = t2.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((e3) => unquote(e3));
    let i2 = e2;
    for (; n2.length; ) {
      var a2 = n2.shift().replace(/\?$/, "");
      if (typeof i2 != "object" || !(a2 in i2))
        return;
      i2 = i2[a2];
    }
    return i2;
  }
  var md5$1 = { exports: {} }, core$1 = { exports: {} }, g8;
  core$1.exports = function(c2) {
    var n2;
    if (typeof window != "undefined" && window.crypto && (n2 = window.crypto), typeof self != "undefined" && self.crypto && (n2 = self.crypto), !(n2 = !(n2 = !(n2 = typeof globalThis != "undefined" && globalThis.crypto ? globalThis.crypto : n2) && typeof window != "undefined" && window.msCrypto ? window.msCrypto : n2) && commonjsGlobal !== void 0 && commonjsGlobal.crypto ? commonjsGlobal.crypto : n2) && typeof commonjsRequire == "function")
      try {
        n2 = require("crypto");
      } catch (e3) {
      }
    var r2 = Object.create || function(e3) {
      return t2.prototype = e3, e3 = new t2(), t2.prototype = null, e3;
    };
    function t2() {
    }
    var e2 = {}, i2 = e2.lib = {}, a2 = i2.Base = { extend: function(e3) {
      var t3 = r2(this);
      return e3 && t3.mixIn(e3), t3.hasOwnProperty("init") && this.init !== t3.init || (t3.init = function() {
        t3.$super.init.apply(this, arguments);
      }), (t3.init.prototype = t3).$super = this, t3;
    }, create: function() {
      var e3 = this.extend();
      return e3.init.apply(e3, arguments), e3;
    }, init: function() {
    }, mixIn: function(e3) {
      for (var t3 in e3)
        e3.hasOwnProperty(t3) && (this[t3] = e3[t3]);
      e3.hasOwnProperty("toString") && (this.toString = e3.toString);
    }, clone: function() {
      return this.init.prototype.extend(this);
    } }, u2 = i2.WordArray = a2.extend({ init: function(e3, t3) {
      e3 = this.words = e3 || [], this.sigBytes = t3 != null ? t3 : 4 * e3.length;
    }, toString: function(e3) {
      return (e3 || s2).stringify(this);
    }, concat: function(e3) {
      var t3 = this.words, r3 = e3.words, n3 = this.sigBytes, i3 = e3.sigBytes;
      if (this.clamp(), n3 % 4)
        for (var a3 = 0; a3 < i3; a3++) {
          var o3 = r3[a3 >>> 2] >>> 24 - a3 % 4 * 8 & 255;
          t3[n3 + a3 >>> 2] |= o3 << 24 - (n3 + a3) % 4 * 8;
        }
      else
        for (var s3 = 0; s3 < i3; s3 += 4)
          t3[n3 + s3 >>> 2] = r3[s3 >>> 2];
      return this.sigBytes += i3, this;
    }, clamp: function() {
      var e3 = this.words, t3 = this.sigBytes;
      e3[t3 >>> 2] &= 4294967295 << 32 - t3 % 4 * 8, e3.length = c2.ceil(t3 / 4);
    }, clone: function() {
      var e3 = a2.clone.call(this);
      return e3.words = this.words.slice(0), e3;
    }, random: function(e3) {
      for (var t3 = [], r3 = 0; r3 < e3; r3 += 4)
        t3.push(function() {
          if (n2) {
            if (typeof n2.getRandomValues == "function")
              try {
                return n2.getRandomValues(new Uint32Array(1))[0];
              } catch (e4) {
              }
            if (typeof n2.randomBytes == "function")
              try {
                return n2.randomBytes(4).readInt32LE();
              } catch (e4) {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }());
      return new u2.init(t3, e3);
    } }), o2 = e2.enc = {}, s2 = o2.Hex = { stringify: function(e3) {
      for (var t3 = e3.words, r3 = e3.sigBytes, n3 = [], i3 = 0; i3 < r3; i3++) {
        var a3 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
        n3.push((a3 >>> 4).toString(16)), n3.push((15 & a3).toString(16));
      }
      return n3.join("");
    }, parse: function(e3) {
      for (var t3 = e3.length, r3 = [], n3 = 0; n3 < t3; n3 += 2)
        r3[n3 >>> 3] |= parseInt(e3.substr(n3, 2), 16) << 24 - n3 % 8 * 4;
      return new u2.init(r3, t3 / 2);
    } }, l2 = o2.Latin1 = { stringify: function(e3) {
      for (var t3 = e3.words, r3 = e3.sigBytes, n3 = [], i3 = 0; i3 < r3; i3++) {
        var a3 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
        n3.push(String.fromCharCode(a3));
      }
      return n3.join("");
    }, parse: function(e3) {
      for (var t3 = e3.length, r3 = [], n3 = 0; n3 < t3; n3++)
        r3[n3 >>> 2] |= (255 & e3.charCodeAt(n3)) << 24 - n3 % 4 * 8;
      return new u2.init(r3, t3);
    } }, h2 = o2.Utf8 = { stringify: function(e3) {
      try {
        return decodeURIComponent(escape(l2.stringify(e3)));
      } catch (e4) {
        throw new Error("Malformed UTF-8 data");
      }
    }, parse: function(e3) {
      return l2.parse(unescape(encodeURIComponent(e3)));
    } }, d2 = i2.BufferedBlockAlgorithm = a2.extend({ reset: function() {
      this._data = new u2.init(), this._nDataBytes = 0;
    }, _append: function(e3) {
      typeof e3 == "string" && (e3 = h2.parse(e3)), this._data.concat(e3), this._nDataBytes += e3.sigBytes;
    }, _process: function(e3) {
      var t3, r3 = this._data, n3 = r3.words, i3 = r3.sigBytes, a3 = this.blockSize, o3 = i3 / (4 * a3), s3 = (o3 = e3 ? c2.ceil(o3) : c2.max((0 | o3) - this._minBufferSize, 0)) * a3, i3 = c2.min(4 * s3, i3);
      if (s3) {
        for (var l3 = 0; l3 < s3; l3 += a3)
          this._doProcessBlock(n3, l3);
        t3 = n3.splice(0, s3), r3.sigBytes -= i3;
      }
      return new u2.init(t3, i3);
    }, clone: function() {
      var e3 = a2.clone.call(this);
      return e3._data = this._data.clone(), e3;
    }, _minBufferSize: 0 });
    i2.Hasher = d2.extend({ cfg: a2.extend(), init: function(e3) {
      this.cfg = this.cfg.extend(e3), this.reset();
    }, reset: function() {
      d2.reset.call(this), this._doReset();
    }, update: function(e3) {
      return this._append(e3), this._process(), this;
    }, finalize: function(e3) {
      return e3 && this._append(e3), this._doFinalize();
    }, blockSize: 16, _createHelper: function(r3) {
      return function(e3, t3) {
        return new r3.init(t3).finalize(e3);
      };
    }, _createHmacHelper: function(r3) {
      return function(e3, t3) {
        return new p2.HMAC.init(r3, t3).finalize(e3);
      };
    } });
    var p2 = e2.algo = {};
    return e2;
  }(Math), md5$1.exports = (g8 = core$1.exports, function(l2) {
    var e2 = g8, t2 = e2.lib, r2 = t2.WordArray, n2 = t2.Hasher, t2 = e2.algo, T2 = [];
    !function() {
      for (var e3 = 0; e3 < 64; e3++)
        T2[e3] = 4294967296 * l2.abs(l2.sin(e3 + 1)) | 0;
    }();
    t2 = t2.MD5 = n2.extend({ _doReset: function() {
      this._hash = new r2.init([1732584193, 4023233417, 2562383102, 271733878]);
    }, _doProcessBlock: function(e3, t3) {
      for (var r3 = 0; r3 < 16; r3++) {
        var n3 = t3 + r3, i2 = e3[n3];
        e3[n3] = 16711935 & (i2 << 8 | i2 >>> 24) | 4278255360 & (i2 << 24 | i2 >>> 8);
      }
      var a2 = this._hash.words, o2 = e3[t3 + 0], s2 = e3[t3 + 1], l3 = e3[t3 + 2], c2 = e3[t3 + 3], u2 = e3[t3 + 4], h2 = e3[t3 + 5], d2 = e3[t3 + 6], p2 = e3[t3 + 7], f2 = e3[t3 + 8], m2 = e3[t3 + 9], g2 = e3[t3 + 10], v2 = e3[t3 + 11], y = e3[t3 + 12], _2 = e3[t3 + 13], b2 = e3[t3 + 14], x2 = e3[t3 + 15], w2 = k2(w2 = a2[0], E2 = a2[1], M2 = a2[2], S2 = a2[3], o2, 7, T2[0]), S2 = k2(S2, w2, E2, M2, s2, 12, T2[1]), M2 = k2(M2, S2, w2, E2, l3, 17, T2[2]), E2 = k2(E2, M2, S2, w2, c2, 22, T2[3]);
      w2 = k2(w2, E2, M2, S2, u2, 7, T2[4]), S2 = k2(S2, w2, E2, M2, h2, 12, T2[5]), M2 = k2(M2, S2, w2, E2, d2, 17, T2[6]), E2 = k2(E2, M2, S2, w2, p2, 22, T2[7]), w2 = k2(w2, E2, M2, S2, f2, 7, T2[8]), S2 = k2(S2, w2, E2, M2, m2, 12, T2[9]), M2 = k2(M2, S2, w2, E2, g2, 17, T2[10]), E2 = k2(E2, M2, S2, w2, v2, 22, T2[11]), w2 = k2(w2, E2, M2, S2, y, 7, T2[12]), S2 = k2(S2, w2, E2, M2, _2, 12, T2[13]), M2 = k2(M2, S2, w2, E2, b2, 17, T2[14]), w2 = A2(w2, E2 = k2(E2, M2, S2, w2, x2, 22, T2[15]), M2, S2, s2, 5, T2[16]), S2 = A2(S2, w2, E2, M2, d2, 9, T2[17]), M2 = A2(M2, S2, w2, E2, v2, 14, T2[18]), E2 = A2(E2, M2, S2, w2, o2, 20, T2[19]), w2 = A2(w2, E2, M2, S2, h2, 5, T2[20]), S2 = A2(S2, w2, E2, M2, g2, 9, T2[21]), M2 = A2(M2, S2, w2, E2, x2, 14, T2[22]), E2 = A2(E2, M2, S2, w2, u2, 20, T2[23]), w2 = A2(w2, E2, M2, S2, m2, 5, T2[24]), S2 = A2(S2, w2, E2, M2, b2, 9, T2[25]), M2 = A2(M2, S2, w2, E2, c2, 14, T2[26]), E2 = A2(E2, M2, S2, w2, f2, 20, T2[27]), w2 = A2(w2, E2, M2, S2, _2, 5, T2[28]), S2 = A2(S2, w2, E2, M2, l3, 9, T2[29]), M2 = A2(M2, S2, w2, E2, p2, 14, T2[30]), w2 = C2(w2, E2 = A2(E2, M2, S2, w2, y, 20, T2[31]), M2, S2, h2, 4, T2[32]), S2 = C2(S2, w2, E2, M2, f2, 11, T2[33]), M2 = C2(M2, S2, w2, E2, v2, 16, T2[34]), E2 = C2(E2, M2, S2, w2, b2, 23, T2[35]), w2 = C2(w2, E2, M2, S2, s2, 4, T2[36]), S2 = C2(S2, w2, E2, M2, u2, 11, T2[37]), M2 = C2(M2, S2, w2, E2, p2, 16, T2[38]), E2 = C2(E2, M2, S2, w2, g2, 23, T2[39]), w2 = C2(w2, E2, M2, S2, _2, 4, T2[40]), S2 = C2(S2, w2, E2, M2, o2, 11, T2[41]), M2 = C2(M2, S2, w2, E2, c2, 16, T2[42]), E2 = C2(E2, M2, S2, w2, d2, 23, T2[43]), w2 = C2(w2, E2, M2, S2, m2, 4, T2[44]), S2 = C2(S2, w2, E2, M2, y, 11, T2[45]), M2 = C2(M2, S2, w2, E2, x2, 16, T2[46]), w2 = $2(w2, E2 = C2(E2, M2, S2, w2, l3, 23, T2[47]), M2, S2, o2, 6, T2[48]), S2 = $2(S2, w2, E2, M2, p2, 10, T2[49]), M2 = $2(M2, S2, w2, E2, b2, 15, T2[50]), E2 = $2(E2, M2, S2, w2, h2, 21, T2[51]), w2 = $2(w2, E2, M2, S2, y, 6, T2[52]), S2 = $2(S2, w2, E2, M2, c2, 10, T2[53]), M2 = $2(M2, S2, w2, E2, g2, 15, T2[54]), E2 = $2(E2, M2, S2, w2, s2, 21, T2[55]), w2 = $2(w2, E2, M2, S2, f2, 6, T2[56]), S2 = $2(S2, w2, E2, M2, x2, 10, T2[57]), M2 = $2(M2, S2, w2, E2, d2, 15, T2[58]), E2 = $2(E2, M2, S2, w2, _2, 21, T2[59]), w2 = $2(w2, E2, M2, S2, u2, 6, T2[60]), S2 = $2(S2, w2, E2, M2, v2, 10, T2[61]), M2 = $2(M2, S2, w2, E2, l3, 15, T2[62]), E2 = $2(E2, M2, S2, w2, m2, 21, T2[63]), a2[0] = a2[0] + w2 | 0, a2[1] = a2[1] + E2 | 0, a2[2] = a2[2] + M2 | 0, a2[3] = a2[3] + S2 | 0;
    }, _doFinalize: function() {
      var e3 = this._data, t3 = e3.words, r3 = 8 * this._nDataBytes, n3 = 8 * e3.sigBytes;
      t3[n3 >>> 5] |= 128 << 24 - n3 % 32;
      var i2 = l2.floor(r3 / 4294967296), r3 = r3;
      t3[15 + (64 + n3 >>> 9 << 4)] = 16711935 & (i2 << 8 | i2 >>> 24) | 4278255360 & (i2 << 24 | i2 >>> 8), t3[14 + (64 + n3 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), e3.sigBytes = 4 * (t3.length + 1), this._process();
      for (var t3 = this._hash, a2 = t3.words, o2 = 0; o2 < 4; o2++) {
        var s2 = a2[o2];
        a2[o2] = 16711935 & (s2 << 8 | s2 >>> 24) | 4278255360 & (s2 << 24 | s2 >>> 8);
      }
      return t3;
    }, clone: function() {
      var e3 = n2.clone.call(this);
      return e3._hash = this._hash.clone(), e3;
    } });
    function k2(e3, t3, r3, n3, i2, a2, o2) {
      o2 = e3 + (t3 & r3 | ~t3 & n3) + i2 + o2;
      return (o2 << a2 | o2 >>> 32 - a2) + t3;
    }
    function A2(e3, t3, r3, n3, i2, a2, o2) {
      o2 = e3 + (t3 & n3 | r3 & ~n3) + i2 + o2;
      return (o2 << a2 | o2 >>> 32 - a2) + t3;
    }
    function C2(e3, t3, r3, n3, i2, a2, o2) {
      o2 = e3 + (t3 ^ r3 ^ n3) + i2 + o2;
      return (o2 << a2 | o2 >>> 32 - a2) + t3;
    }
    function $2(e3, t3, r3, n3, i2, a2, o2) {
      o2 = e3 + (r3 ^ (t3 | ~n3)) + i2 + o2;
      return (o2 << a2 | o2 >>> 32 - a2) + t3;
    }
    e2.MD5 = n2._createHelper(t2), e2.HmacMD5 = n2._createHmacHelper(t2);
  }(Math), g8.MD5);
  var md5 = md5$1.exports, ansiStyles$1 = { exports: {} }, colorName = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
  const cssKeywords = colorName, reverseKeywords = {};
  for (const key of Object.keys(cssKeywords))
    reverseKeywords[cssKeywords[key]] = key;
  const convert$3 = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
  var conversions$2 = convert$3;
  for (const model of Object.keys(convert$3)) {
    if (!("channels" in convert$3[model]))
      throw new Error("missing channels property: " + model);
    if (!("labels" in convert$3[model]))
      throw new Error("missing channel labels property: " + model);
    if (convert$3[model].labels.length !== convert$3[model].channels)
      throw new Error("channel and label counts mismatch: " + model);
    const { channels, labels } = convert$3[model];
    delete convert$3[model].channels, delete convert$3[model].labels, Object.defineProperty(convert$3[model], "channels", { value: channels }), Object.defineProperty(convert$3[model], "labels", { value: labels });
  }
  function comparativeDistance(e2, t2) {
    return __pow(e2[0] - t2[0], 2) + __pow(e2[1] - t2[1], 2) + __pow(e2[2] - t2[2], 2);
  }
  convert$3.rgb.hsl = function(e2) {
    var t2 = e2[0] / 255, r2 = e2[1] / 255, n2 = e2[2] / 255, i2 = Math.min(t2, r2, n2), a2 = Math.max(t2, r2, n2), e2 = a2 - i2;
    let o2, s2;
    a2 === i2 ? o2 = 0 : t2 === a2 ? o2 = (r2 - n2) / e2 : r2 === a2 ? o2 = 2 + (n2 - t2) / e2 : n2 === a2 && (o2 = 4 + (t2 - r2) / e2), o2 = Math.min(60 * o2, 360), o2 < 0 && (o2 += 360);
    r2 = (i2 + a2) / 2;
    return s2 = a2 === i2 ? 0 : r2 <= 0.5 ? e2 / (a2 + i2) : e2 / (2 - a2 - i2), [o2, 100 * s2, 100 * r2];
  }, convert$3.rgb.hsv = function(e2) {
    var t2;
    let r2, n2;
    var i2 = e2[0] / 255, a2 = e2[1] / 255, o2 = e2[2] / 255;
    const s2 = Math.max(i2, a2, o2), l2 = s2 - Math.min(i2, a2, o2);
    var c2 = function(e3) {
      return (s2 - e3) / 6 / l2 + 0.5;
    };
    return l2 == 0 ? (r2 = 0, n2 = 0) : (n2 = l2 / s2, t2 = c2(i2), e2 = c2(a2), c2 = c2(o2), i2 === s2 ? r2 = c2 - e2 : a2 === s2 ? r2 = 1 / 3 + t2 - c2 : o2 === s2 && (r2 = 2 / 3 + e2 - t2), r2 < 0 ? r2 += 1 : 1 < r2 && --r2), [360 * r2, 100 * n2, 100 * s2];
  }, convert$3.rgb.hwb = function(e2) {
    var t2 = e2[0], r2 = e2[1], n2 = e2[2];
    return [convert$3.rgb.hsl(e2)[0], 100 * (1 / 255 * Math.min(t2, Math.min(r2, n2))), 100 * (n2 = 1 - 1 / 255 * Math.max(t2, Math.max(r2, n2)))];
  }, convert$3.rgb.cmyk = function(e2) {
    var t2 = e2[0] / 255, r2 = e2[1] / 255, n2 = e2[2] / 255, e2 = Math.min(1 - t2, 1 - r2, 1 - n2);
    return [100 * ((1 - t2 - e2) / (1 - e2) || 0), 100 * ((1 - r2 - e2) / (1 - e2) || 0), 100 * ((1 - n2 - e2) / (1 - e2) || 0), 100 * e2];
  }, convert$3.rgb.keyword = function(e2) {
    var t2 = reverseKeywords[e2];
    if (t2)
      return t2;
    let r2 = 1 / 0, n2;
    for (const a2 of Object.keys(cssKeywords)) {
      var i2 = comparativeDistance(e2, cssKeywords[a2]);
      i2 < r2 && (r2 = i2, n2 = a2);
    }
    return n2;
  }, convert$3.keyword.rgb = function(e2) {
    return cssKeywords[e2];
  }, convert$3.rgb.xyz = function(e2) {
    let t2 = e2[0] / 255, r2 = e2[1] / 255, n2 = e2[2] / 255;
    return t2 = 0.04045 < t2 ? __pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92, r2 = 0.04045 < r2 ? __pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92, n2 = 0.04045 < n2 ? __pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92, [100 * (0.4124 * t2 + 0.3576 * r2 + 0.1805 * n2), 100 * (0.2126 * t2 + 0.7152 * r2 + 0.0722 * n2), 100 * (0.0193 * t2 + 0.1192 * r2 + 0.9505 * n2)];
  }, convert$3.rgb.lab = function(e2) {
    e2 = convert$3.rgb.xyz(e2);
    let t2 = e2[0], r2 = e2[1], n2 = e2[2];
    return t2 /= 95.047, r2 /= 100, n2 /= 108.883, t2 = 8856e-6 < t2 ? __pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, r2 = 8856e-6 < r2 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116, n2 = 8856e-6 < n2 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, [116 * r2 - 16, 500 * (t2 - r2), 200 * (r2 - n2)];
  }, convert$3.hsl.rgb = function(e2) {
    var t2 = e2[0] / 360, r2 = e2[1] / 100, e2 = e2[2] / 100;
    let n2, i2, a2;
    if (r2 == 0)
      return a2 = 255 * e2, [a2, a2, a2];
    n2 = e2 < 0.5 ? e2 * (1 + r2) : e2 + r2 - e2 * r2;
    var o2 = 2 * e2 - n2;
    const s2 = [0, 0, 0];
    for (let e3 = 0; e3 < 3; e3++)
      i2 = t2 + 1 / 3 * -(e3 - 1), i2 < 0 && i2++, 1 < i2 && i2--, a2 = 6 * i2 < 1 ? o2 + 6 * (n2 - o2) * i2 : 2 * i2 < 1 ? n2 : 3 * i2 < 2 ? o2 + (n2 - o2) * (2 / 3 - i2) * 6 : o2, s2[e3] = 255 * a2;
    return s2;
  }, convert$3.hsl.hsv = function(e2) {
    var t2 = e2[0], r2 = e2[1] / 100, n2 = e2[2] / 100, i2 = r2, e2 = Math.max(n2, 0.01);
    return r2 *= (n2 *= 2) <= 1 ? n2 : 2 - n2, i2 *= e2 <= 1 ? e2 : 2 - e2, [t2, 100 * (n2 == 0 ? 2 * i2 / (e2 + i2) : 2 * r2 / (n2 + r2)), 100 * ((n2 + r2) / 2)];
  }, convert$3.hsv.rgb = function(e2) {
    var t2 = e2[0] / 60, r2 = e2[1] / 100, n2 = e2[2] / 100, e2 = Math.floor(t2) % 6, t2 = t2 - Math.floor(t2), i2 = 255 * n2 * (1 - r2), a2 = 255 * n2 * (1 - r2 * t2), o2 = 255 * n2 * (1 - r2 * (1 - t2));
    switch (n2 *= 255, e2) {
      case 0:
        return [n2, o2, i2];
      case 1:
        return [a2, n2, i2];
      case 2:
        return [i2, n2, o2];
      case 3:
        return [i2, a2, n2];
      case 4:
        return [o2, i2, n2];
      case 5:
        return [n2, i2, a2];
    }
  }, convert$3.hsv.hsl = function(e2) {
    var t2 = e2[0], r2 = e2[1] / 100, n2 = e2[2] / 100, i2 = Math.max(n2, 0.01), e2 = (2 - r2) * n2, n2 = (2 - r2) * i2, i2 = r2 * i2;
    return [t2, 100 * ((i2 /= n2 <= 1 ? n2 : 2 - n2) || 0), 100 * (e2 /= 2)];
  }, convert$3.hwb.rgb = function(e2) {
    var t2 = e2[0] / 360;
    let r2 = e2[1] / 100, n2 = e2[2] / 100;
    e2 = r2 + n2;
    let i2;
    1 < e2 && (r2 /= e2, n2 /= e2);
    var e2 = Math.floor(6 * t2), a2 = 1 - n2;
    i2 = 6 * t2 - e2, (1 & e2) != 0 && (i2 = 1 - i2);
    var o2 = r2 + i2 * (a2 - r2);
    let s2, l2, c2;
    switch (e2) {
      default:
      case 6:
      case 0:
        s2 = a2, l2 = o2, c2 = r2;
        break;
      case 1:
        s2 = o2, l2 = a2, c2 = r2;
        break;
      case 2:
        s2 = r2, l2 = a2, c2 = o2;
        break;
      case 3:
        s2 = r2, l2 = o2, c2 = a2;
        break;
      case 4:
        s2 = o2, l2 = r2, c2 = a2;
        break;
      case 5:
        s2 = a2, l2 = r2, c2 = o2;
    }
    return [255 * s2, 255 * l2, 255 * c2];
  }, convert$3.cmyk.rgb = function(e2) {
    var t2 = e2[0] / 100, r2 = e2[1] / 100, n2 = e2[2] / 100, e2 = e2[3] / 100;
    return [255 * (1 - Math.min(1, t2 * (1 - e2) + e2)), 255 * (1 - Math.min(1, r2 * (1 - e2) + e2)), 255 * (1 - Math.min(1, n2 * (1 - e2) + e2))];
  }, convert$3.xyz.rgb = function(e2) {
    var t2 = e2[0] / 100, r2 = e2[1] / 100, e2 = e2[2] / 100;
    let n2, i2, a2;
    return n2 = 3.2406 * t2 + -1.5372 * r2 + -0.4986 * e2, i2 = -0.9689 * t2 + 1.8758 * r2 + 0.0415 * e2, a2 = 0.0557 * t2 + -0.204 * r2 + 1.057 * e2, n2 = 31308e-7 < n2 ? 1.055 * __pow(n2, 1 / 2.4) - 0.055 : 12.92 * n2, i2 = 31308e-7 < i2 ? 1.055 * __pow(i2, 1 / 2.4) - 0.055 : 12.92 * i2, a2 = 31308e-7 < a2 ? 1.055 * __pow(a2, 1 / 2.4) - 0.055 : 12.92 * a2, n2 = Math.min(Math.max(0, n2), 1), i2 = Math.min(Math.max(0, i2), 1), a2 = Math.min(Math.max(0, a2), 1), [255 * n2, 255 * i2, 255 * a2];
  }, convert$3.xyz.lab = function(e2) {
    let t2 = e2[0], r2 = e2[1], n2 = e2[2];
    return t2 /= 95.047, r2 /= 100, n2 /= 108.883, t2 = 8856e-6 < t2 ? __pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, r2 = 8856e-6 < r2 ? __pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116, n2 = 8856e-6 < n2 ? __pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, [116 * r2 - 16, 500 * (t2 - r2), 200 * (r2 - n2)];
  }, convert$3.lab.xyz = function(e2) {
    var t2 = e2[0], r2 = e2[1], e2 = e2[2];
    let n2, i2, a2;
    i2 = (t2 + 16) / 116, n2 = r2 / 500 + i2, a2 = i2 - e2 / 200;
    t2 = __pow(i2, 3), r2 = __pow(n2, 3), e2 = __pow(a2, 3);
    return i2 = 8856e-6 < t2 ? t2 : (i2 - 16 / 116) / 7.787, n2 = 8856e-6 < r2 ? r2 : (n2 - 16 / 116) / 7.787, a2 = 8856e-6 < e2 ? e2 : (a2 - 16 / 116) / 7.787, n2 *= 95.047, i2 *= 100, a2 *= 108.883, [n2, i2, a2];
  }, convert$3.lab.lch = function(e2) {
    var t2 = e2[0], r2 = e2[1], n2 = e2[2];
    let i2;
    e2 = Math.atan2(n2, r2);
    return i2 = 360 * e2 / 2 / Math.PI, i2 < 0 && (i2 += 360), [t2, Math.sqrt(r2 * r2 + n2 * n2), i2];
  }, convert$3.lch.lab = function(e2) {
    var t2 = e2[0], r2 = e2[1], e2 = e2[2] / 360 * 2 * Math.PI;
    return [t2, r2 * Math.cos(e2), r2 * Math.sin(e2)];
  }, convert$3.rgb.ansi16 = function(e2, t2 = null) {
    var [r2, n2, i2] = e2, t2 = t2 === null ? convert$3.rgb.hsv(e2)[2] : t2;
    if ((t2 = Math.round(t2 / 50)) === 0)
      return 30;
    let a2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(n2 / 255) << 1 | Math.round(r2 / 255));
    return t2 === 2 && (a2 += 60), a2;
  }, convert$3.hsv.ansi16 = function(e2) {
    return convert$3.rgb.ansi16(convert$3.hsv.rgb(e2), e2[2]);
  }, convert$3.rgb.ansi256 = function(e2) {
    var t2 = e2[0], r2 = e2[1], e2 = e2[2];
    return t2 === r2 && r2 === e2 ? t2 < 8 ? 16 : 248 < t2 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(r2 / 255 * 5) + Math.round(e2 / 255 * 5);
  }, convert$3.ansi16.rgb = function(e2) {
    let t2 = e2 % 10;
    if (t2 === 0 || t2 === 7)
      return 50 < e2 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
    e2 = 0.5 * (1 + ~~(50 < e2));
    return [(1 & t2) * e2 * 255, (t2 >> 1 & 1) * e2 * 255, (t2 >> 2 & 1) * e2 * 255];
  }, convert$3.ansi256.rgb = function(e2) {
    if (232 <= e2) {
      var t2 = 10 * (e2 - 232) + 8;
      return [t2, t2, t2];
    }
    return e2 -= 16, [Math.floor(e2 / 36) / 5 * 255, Math.floor((e2 = e2 % 36) / 6) / 5 * 255, e2 % 6 / 5 * 255];
  }, convert$3.rgb.hex = function(e2) {
    const t2 = ((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]));
    e2 = t2.toString(16).toUpperCase();
    return "000000".substring(e2.length) + e2;
  }, convert$3.hex.rgb = function(e2) {
    e2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e2)
      return [0, 0, 0];
    let t2 = e2[0];
    e2[0].length === 3 && (t2 = t2.split("").map((e3) => e3 + e3).join(""));
    e2 = parseInt(t2, 16);
    return [e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
  }, convert$3.rgb.hcg = function(e2) {
    var t2 = e2[0] / 255, r2 = e2[1] / 255, n2 = e2[2] / 255, i2 = Math.max(Math.max(t2, r2), n2), a2 = Math.min(Math.min(t2, r2), n2), e2 = i2 - a2;
    let o2, s2;
    return o2 = e2 < 1 ? a2 / (1 - e2) : 0, s2 = e2 <= 0 ? 0 : i2 === t2 ? (r2 - n2) / e2 % 6 : i2 === r2 ? 2 + (n2 - t2) / e2 : 4 + (t2 - r2) / e2, s2 /= 6, s2 %= 1, [360 * s2, 100 * e2, 100 * o2];
  }, convert$3.hsl.hcg = function(e2) {
    var t2 = e2[1] / 100, r2 = e2[2] / 100, t2 = r2 < 0.5 ? 2 * t2 * r2 : 2 * t2 * (1 - r2);
    let n2 = t2 < 1 ? (r2 - 0.5 * t2) / (1 - t2) : 0;
    return [e2[0], 100 * t2, 100 * n2];
  }, convert$3.hsv.hcg = function(e2) {
    var t2 = e2[1] / 100, r2 = e2[2] / 100, t2 = t2 * r2;
    let n2 = t2 < 1 ? (r2 - t2) / (1 - t2) : 0;
    return [e2[0], 100 * t2, 100 * n2];
  }, convert$3.hcg.rgb = function(e2) {
    var t2 = e2[0] / 360, r2 = e2[1] / 100, n2 = e2[2] / 100;
    if (r2 == 0)
      return [255 * n2, 255 * n2, 255 * n2];
    const i2 = [0, 0, 0];
    var e2 = t2 % 1 * 6, a2 = e2 % 1, o2 = 1 - a2;
    switch (Math.floor(e2)) {
      case 0:
        i2[0] = 1, i2[1] = a2, i2[2] = 0;
        break;
      case 1:
        i2[0] = o2, i2[1] = 1, i2[2] = 0;
        break;
      case 2:
        i2[0] = 0, i2[1] = 1, i2[2] = a2;
        break;
      case 3:
        i2[0] = 0, i2[1] = o2, i2[2] = 1;
        break;
      case 4:
        i2[0] = a2, i2[1] = 0, i2[2] = 1;
        break;
      default:
        i2[0] = 1, i2[1] = 0, i2[2] = o2;
    }
    return t2 = (1 - r2) * n2, [255 * (r2 * i2[0] + t2), 255 * (r2 * i2[1] + t2), 255 * (r2 * i2[2] + t2)];
  }, convert$3.hcg.hsv = function(e2) {
    var t2 = e2[1] / 100, r2 = t2 + e2[2] / 100 * (1 - t2);
    let n2 = 0 < r2 ? t2 / r2 : 0;
    return [e2[0], 100 * n2, 100 * r2];
  }, convert$3.hcg.hsl = function(e2) {
    var t2 = e2[1] / 100, r2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
    let n2 = 0;
    return 0 < r2 && r2 < 0.5 ? n2 = t2 / (2 * r2) : 0.5 <= r2 && r2 < 1 && (n2 = t2 / (2 * (1 - r2))), [e2[0], 100 * n2, 100 * r2];
  }, convert$3.hcg.hwb = function(e2) {
    var t2 = e2[1] / 100, r2 = t2 + e2[2] / 100 * (1 - t2);
    return [e2[0], 100 * (r2 - t2), 100 * (1 - r2)];
  }, convert$3.hwb.hcg = function(e2) {
    var t2 = e2[1] / 100, r2 = 1 - e2[2] / 100, t2 = r2 - t2;
    let n2 = t2 < 1 ? (r2 - t2) / (1 - t2) : 0;
    return [e2[0], 100 * t2, 100 * n2];
  }, convert$3.apple.rgb = function(e2) {
    return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
  }, convert$3.rgb.apple = function(e2) {
    return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
  }, convert$3.gray.rgb = function(e2) {
    return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
  }, convert$3.gray.hsl = function(e2) {
    return [0, 0, e2[0]];
  }, convert$3.gray.hsv = convert$3.gray.hsl, convert$3.gray.hwb = function(e2) {
    return [0, 100, e2[0]];
  }, convert$3.gray.cmyk = function(e2) {
    return [0, 0, 0, e2[0]];
  }, convert$3.gray.lab = function(e2) {
    return [e2[0], 0, 0];
  }, convert$3.gray.hex = function(e2) {
    e2 = 255 & Math.round(e2[0] / 100 * 255);
    const t2 = (e2 << 16) + (e2 << 8) + e2;
    e2 = t2.toString(16).toUpperCase();
    return "000000".substring(e2.length) + e2;
  }, convert$3.rgb.gray = function(e2) {
    return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const r2 = {};
    var n2 = Object.keys(conversions$1);
    for (let e2 = n2.length, t2 = 0; t2 < e2; t2++)
      r2[n2[t2]] = { distance: -1, parent: null };
    return r2;
  }
  function deriveBFS(e2) {
    const r2 = buildGraph(), n2 = [e2];
    for (r2[e2].distance = 0; n2.length; ) {
      var i2 = n2.pop(), a2 = Object.keys(conversions$1[i2]);
      for (let e3 = a2.length, t2 = 0; t2 < e3; t2++) {
        var o2 = a2[t2];
        const s2 = r2[o2];
        s2.distance === -1 && (s2.distance = r2[i2].distance + 1, s2.parent = i2, n2.unshift(o2));
      }
    }
    return r2;
  }
  function link(t2, r2) {
    return function(e2) {
      return r2(t2(e2));
    };
  }
  function wrapConversion(e2, t2) {
    const r2 = [t2[e2].parent, e2];
    let n2 = conversions$1[t2[e2].parent][e2], i2 = t2[e2].parent;
    for (; t2[i2].parent; )
      r2.unshift(t2[i2].parent), n2 = link(conversions$1[t2[i2].parent][i2], n2), i2 = t2[i2].parent;
    return n2.conversion = r2, n2;
  }
  var route$1 = function(e2) {
    var r2 = deriveBFS(e2);
    const n2 = {};
    var i2 = Object.keys(r2);
    for (let e3 = i2.length, t2 = 0; t2 < e3; t2++) {
      var a2 = i2[t2];
      r2[a2].parent !== null && (n2[a2] = wrapConversion(a2, r2));
    }
    return n2;
  };
  const conversions = conversions$2, route = route$1, convert$2 = {}, models = Object.keys(conversions);
  function wrapRaw(r2) {
    function e2(...e3) {
      var t2 = e3[0];
      return t2 == null ? t2 : (1 < t2.length && (e3 = t2), r2(e3));
    }
    return "conversion" in r2 && (e2.conversion = r2.conversion), e2;
  }
  function wrapRounded(n2) {
    function e2(...e3) {
      var t2 = e3[0];
      if (t2 == null)
        return t2;
      1 < t2.length && (e3 = t2);
      const r2 = n2(e3);
      if (typeof r2 == "object")
        for (let e4 = r2.length, t3 = 0; t3 < e4; t3++)
          r2[t3] = Math.round(r2[t3]);
      return r2;
    }
    return "conversion" in n2 && (e2.conversion = n2.conversion), e2;
  }
  models.forEach((r2) => {
    convert$2[r2] = {}, Object.defineProperty(convert$2[r2], "channels", { value: conversions[r2].channels }), Object.defineProperty(convert$2[r2], "labels", { value: conversions[r2].labels });
    const n2 = route(r2), e2 = Object.keys(n2);
    e2.forEach((e3) => {
      var t2 = n2[e3];
      convert$2[r2][e3] = wrapRounded(t2), convert$2[r2][e3].raw = wrapRaw(t2);
    });
  });
  var colorConvert = convert$2;
  !function() {
    const o2 = (t2, r2) => (...e2) => {
      return `[${t2(...e2) + r2}m`;
    }, s2 = (t2, r2) => (...e2) => {
      e2 = t2(...e2);
      return `[${38 + r2};5;${e2}m`;
    }, l2 = (t2, r2) => (...e2) => {
      e2 = t2(...e2);
      return `[${38 + r2};2;${e2[0]};${e2[1]};${e2[2]}m`;
    }, c2 = (e2) => e2, u2 = (e2, t2, r2) => [e2, t2, r2], h2 = (t2, r2, n2) => {
      Object.defineProperty(t2, r2, { get: () => {
        var e2 = n2();
        return Object.defineProperty(t2, r2, { value: e2, enumerable: true, configurable: true }), e2;
      }, enumerable: true, configurable: true });
    };
    let d2;
    const p2 = (e2, t2, r2, n2) => {
      d2 === void 0 && (d2 = colorConvert);
      var i2, a2, o3 = n2 ? 10 : 0;
      const s3 = {};
      for ([i2, a2] of Object.entries(d2)) {
        var l3 = i2 === "ansi16" ? "ansi" : i2;
        i2 === t2 ? s3[l3] = e2(r2, o3) : typeof a2 == "object" && (s3[l3] = e2(a2[t2], o3));
      }
      return s3;
    };
    Object.defineProperty(ansiStyles$1, "exports", { enumerable: true, get: function() {
      const e2 = new Map(), t2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
      t2.color.gray = t2.color.blackBright, t2.bgColor.bgGray = t2.bgColor.bgBlackBright, t2.color.grey = t2.color.blackBright, t2.bgColor.bgGrey = t2.bgColor.bgBlackBright;
      for (var [r2, n2] of Object.entries(t2)) {
        for (var [i2, a2] of Object.entries(n2))
          t2[i2] = { open: `[${a2[0]}m`, close: `[${a2[1]}m` }, n2[i2] = t2[i2], e2.set(a2[0], a2[1]);
        Object.defineProperty(t2, r2, { value: n2, enumerable: false });
      }
      return Object.defineProperty(t2, "codes", { value: e2, enumerable: false }), t2.color.close = "[39m", t2.bgColor.close = "[49m", h2(t2.color, "ansi", () => p2(o2, "ansi16", c2, false)), h2(t2.color, "ansi256", () => p2(s2, "ansi256", c2, false)), h2(t2.color, "ansi16m", () => p2(l2, "rgb", u2, false)), h2(t2.bgColor, "ansi", () => p2(o2, "ansi16", c2, true)), h2(t2.bgColor, "ansi256", () => p2(s2, "ansi256", c2, true)), h2(t2.bgColor, "ansi16m", () => p2(l2, "rgb", u2, true)), t2;
    } });
  }();
  var browser$1 = { stdout: false, stderr: false };
  const stringReplaceAll$1 = (e2, t2, r2) => {
    let n2 = e2.indexOf(t2);
    if (n2 === -1)
      return e2;
    var i2 = t2.length;
    let a2 = 0, o2 = "";
    for (; o2 += e2.substr(a2, n2 - a2) + t2 + r2, a2 = n2 + i2, n2 = e2.indexOf(t2, a2), n2 !== -1; )
      ;
    return o2 += e2.substr(a2), o2;
  }, stringEncaseCRLFWithFirstIndex$1 = (e2, t2, r2, n2) => {
    let i2 = 0, a2 = "";
    do {
      var o2 = e2[n2 - 1] === "\r";
      a2 += e2.substr(i2, (o2 ? n2 - 1 : n2) - i2) + t2 + (o2 ? "\r\n" : "\n") + r2, i2 = n2 + 1, n2 = e2.indexOf("\n", i2);
    } while (n2 !== -1);
    return a2 += e2.substr(i2), a2;
  };
  var util = { stringReplaceAll: stringReplaceAll$1, stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1 };
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
  function unescape$1(e2) {
    var t2 = e2[0] === "u", r2 = e2[1] === "{";
    return t2 && !r2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t2 && r2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : ESCAPES.get(e2) || e2;
  }
  function parseArguments(e2, t2) {
    const r2 = [];
    let n2;
    for (const a2 of t2.trim().split(/\s*,\s*/g)) {
      var i2 = Number(a2);
      if (Number.isNaN(i2)) {
        if (!(n2 = a2.match(STRING_REGEX)))
          throw new Error(`Invalid Chalk template style argument: ${a2} (in style '${e2}')`);
        r2.push(n2[2].replace(ESCAPE_REGEX, (e3, t3, r3) => t3 ? unescape$1(t3) : r3));
      } else
        r2.push(i2);
    }
    return r2;
  }
  function parseStyle(e2) {
    STYLE_REGEX.lastIndex = 0;
    const t2 = [];
    for (var r2; (r2 = STYLE_REGEX.exec(e2)) !== null; ) {
      const n2 = r2[1];
      r2[2] ? (r2 = parseArguments(n2, r2[2]), t2.push([n2].concat(r2))) : t2.push([n2]);
    }
    return t2;
  }
  function buildStyle(e2, t2) {
    const r2 = {};
    for (const i2 of t2)
      for (const a2 of i2.styles)
        r2[a2[0]] = i2.inverse ? null : a2.slice(1);
    let n2 = e2;
    for (const [o2, t3] of Object.entries(r2))
      if (Array.isArray(t3)) {
        if (!(o2 in n2))
          throw new Error("Unknown Chalk style: " + o2);
        n2 = 0 < t3.length ? n2[o2](...t3) : n2[o2];
      }
    return n2;
  }
  var templates = (o2, e2) => {
    const s2 = [], l2 = [];
    let c2 = [];
    if (e2.replace(TEMPLATE_REGEX, (e3, t2, r2, n2, i2, a2) => {
      if (t2)
        c2.push(unescape$1(t2));
      else if (n2) {
        t2 = c2.join("");
        c2 = [], l2.push(s2.length === 0 ? t2 : buildStyle(o2, s2)(t2)), s2.push({ inverse: r2, styles: parseStyle(n2) });
      } else if (i2) {
        if (s2.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        l2.push(buildStyle(o2, s2)(c2.join(""))), c2 = [], s2.pop();
      } else
        c2.push(a2);
    }), l2.push(c2.join("")), 0 < s2.length) {
      e2 = `Chalk template literal is missing ${s2.length} closing bracket${s2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(e2);
    }
    return l2.join("");
  };
  const ansiStyles = ansiStyles$1.exports, { stdout: stdoutColor, stderr: stderrColor } = browser$1, { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = util, { isArray: isArray$8 } = Array, levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"], styles = Object.create(null), applyOptions = (e2, t2 = {}) => {
    if (t2.level && !(Number.isInteger(t2.level) && 0 <= t2.level && t2.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    var r2 = stdoutColor ? stdoutColor.level : 0;
    e2.level = t2.level === void 0 ? r2 : t2.level;
  };
  class ChalkClass {
    constructor(e2) {
      return chalkFactory(e2);
    }
  }
  const chalkFactory = (e2) => {
    const t2 = {};
    return applyOptions(t2, e2), t2.template = (...e3) => chalkTag(t2.template, ...e3), Object.setPrototypeOf(t2, Chalk.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t2.template.Instance = ChalkClass, t2.template;
  };
  function Chalk(e2) {
    return chalkFactory(e2);
  }
  for (const [styleName, style] of Object.entries(ansiStyles))
    styles[styleName] = { get() {
      var e2 = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      return Object.defineProperty(this, styleName, { value: e2 }), e2;
    } };
  styles.visible = { get() {
    var e2 = createBuilder(this, this._styler, true);
    return Object.defineProperty(this, "visible", { value: e2 }), e2;
  } };
  const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels)
    styles[model] = { get() {
      const t2 = this["level"];
      return function(...e2) {
        e2 = createStyler(ansiStyles.color[levelMapping[t2]][model](...e2), ansiStyles.color.close, this._styler);
        return createBuilder(this, e2, this._isEmpty);
      };
    } };
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = { get() {
      const t2 = this["level"];
      return function(...e2) {
        e2 = createStyler(ansiStyles.bgColor[levelMapping[t2]][model](...e2), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, e2, this._isEmpty);
      };
    } };
  }
  const proto$3 = Object.defineProperties(() => {
  }, __spreadProps(__spreadValues({}, styles), { level: { enumerable: true, get() {
    return this._generator.level;
  }, set(e2) {
    this._generator.level = e2;
  } } })), createStyler = (e2, t2, r2) => {
    let n2, i2;
    return i2 = r2 === void 0 ? (n2 = e2, t2) : (n2 = r2.openAll + e2, t2 + r2.closeAll), { open: e2, close: t2, openAll: n2, closeAll: i2, parent: r2 };
  }, createBuilder = (e2, t2, r2) => {
    const n2 = (...e3) => isArray$8(e3[0]) && isArray$8(e3[0].raw) ? applyStyle(n2, chalkTag(n2, ...e3)) : applyStyle(n2, e3.length === 1 ? "" + e3[0] : e3.join(" "));
    return Object.setPrototypeOf(n2, proto$3), n2._generator = e2, n2._styler = t2, n2._isEmpty = r2, n2;
  }, applyStyle = (e2, t2) => {
    if (e2.level <= 0 || !t2)
      return e2._isEmpty ? "" : t2;
    let r2 = e2._styler;
    if (r2 === void 0)
      return t2;
    var { openAll: n2, closeAll: i2 } = r2;
    if (t2.indexOf("") !== -1)
      for (; r2 !== void 0; )
        t2 = stringReplaceAll(t2, r2.close, r2.open), r2 = r2.parent;
    e2 = t2.indexOf("\n");
    return n2 + (t2 = e2 !== -1 ? stringEncaseCRLFWithFirstIndex(t2, i2, n2, e2) : t2) + i2;
  };
  let template;
  const chalkTag = (e2, ...t2) => {
    var [r2] = t2;
    if (!isArray$8(r2) || !isArray$8(r2.raw))
      return t2.join(" ");
    var n2 = t2.slice(1);
    const i2 = [r2.raw[0]];
    for (let e3 = 1; e3 < r2.length; e3++)
      i2.push(String(n2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(r2.raw[e3]));
    return template === void 0 && (template = templates), template(e2, i2.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  const chalk = Chalk();
  chalk.supportsColor = stdoutColor, chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 }), chalk.stderr.supportsColor = stderrColor;
  var source$1 = chalk, decycle_1;
  function classInstance(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name !== "Object") && (Object.prototype.toString.call(e2) !== "[object Object]" && e2.constructor !== Object)));
  }
  function deepMap(r2, n2, i2 = {}, a2 = []) {
    i2 = __deepMerge$7({ classInstances: false, array: true, privateProps: false, cloneFirst: true }, i2);
    const o2 = Array.isArray(r2);
    let s2 = o2 ? [] : i2.cloneFirst ? Object.assign({}, r2) : r2;
    return Object.keys(r2).forEach((e2) => {
      if (i2.privateProps || !e2.match(/^_/))
        if (plainObject$7(r2[e2]) || classInstance(r2[e2]) && i2.classInstances || Array.isArray(r2[e2]) && i2.array) {
          const t2 = deepMap(r2[e2], n2, i2, [...a2, e2]);
          o2 ? s2.push(t2) : e2 === "..." && plainObject$7(t2) ? s2 = Object.assign(Object.assign({}, s2), t2) : s2[e2] = t2;
        } else {
          const t2 = n2({ object: r2, prop: e2, value: r2[e2], path: [...a2, e2].join(".") });
          t2 !== -1 ? o2 ? s2.push(t2) : e2 === "..." && plainObject$7(t2) ? s2 = Object.assign(Object.assign({}, s2), t2) : s2[e2] = t2 : delete r2[e2];
        }
    }), s2;
  }
  function isMap(e2) {
    return e2 instanceof Map;
  }
  function isArray$7(e2) {
    return e2 && typeof e2 == "object" && e2.constructor === Array;
  }
  function isBoolean(e2) {
    return typeof e2 == "boolean";
  }
  function isFunction$2(e2) {
    return e2 && {}.toString.call(e2) === "[object Function]";
  }
  function isJson(e2) {
    try {
      var t2 = JSON.parse(e2);
      return Object.keys(t2).length ? 1 : void 0;
    } catch (e3) {
      return;
    }
    return 1;
  }
  function isObject$3(e2) {
    return e2 && typeof e2 == "object" && e2.constructor === Object;
  }
  function mapToObject(e2) {
    const t2 = {};
    for (var [r2, n2] of e2)
      t2[r2] = n2;
    return t2;
  }
  const isArray$6 = (e2) => Array.isArray(e2), isObject$2 = (e2) => Object.prototype.toString.call(e2).slice(8, -1) === "Object", validate$1 = (e2) => {
    if (e2 === void 0)
      throw new Error("This method requires one parameter");
    if (!isArray$6(e2) && !isObject$2(e2))
      throw new TypeError("This method only accepts arrays and objects");
  }, findRef = (t2, r2) => Object.keys(r2).find((e2) => r2[e2] === t2), decycle = (e2) => {
    validate$1(e2);
    let t2 = {};
    const i2 = (r2, n2 = "$") => {
      var e3 = findRef(r2, t2);
      return e3 ? { $ref: e3 } : isArray$6(r2) || isObject$2(r2) ? (t2[n2] = r2, isArray$6(r2) ? r2.map((e4, t3) => i2(e4, n2 + `[${t3}]`)) : Object.keys(r2).reduce((e4, t3) => (e4[t3] = i2(r2[t3], n2 + "." + t3), e4), {})) : r2;
    };
    return i2(e2);
  };
  function fn$3(r2, n2 = {}) {
    if (n2 = __deepMerge$7({ beautify: true, highlight: true, verbose: true, theme: { number: source$1.yellow, default: source$1.white, keyword: source$1.blue, regexp: source$1.red, string: source$1.whiteBright, class: source$1.yellow, function: source$1.yellow, comment: source$1.gray, variable: source$1.red, attr: source$1.green } }, n2), typeof r2 == "string")
      return r2;
    if (r2 === null)
      return null;
    if (r2 !== void 0) {
      if (r2 instanceof Error) {
        var e2 = r2.toString();
        const i2 = r2.stack, a2 = r2.message;
        return n2.verbose ? [`<red>${r2.constructor.name || "Error"}</red>`, "", a2, "", i2].join("\n") : e2;
      }
      if (isObject$3(r2 = isMap(r2) ? mapToObject(r2) : r2) || isArray$7(r2) || isJson(r2)) {
        try {
          r2 = decycle_1(r2);
        } catch (e4) {
        }
        r2 = deepMap(r2, ({ value: e4 }) => e4 instanceof Map ? mapToObject(e4) : e4);
        let e3 = JSON.stringify(r2, null, n2.beautify ? 4 : 0);
        return e3 = e3.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"'), n2.highlight, e3;
      }
      if (isBoolean(r2))
        return r2 ? "true" : "false";
      if (isFunction$2(r2))
        return "" + r2;
      let t2 = "";
      try {
        r2 = decycle_1(r2), t2 = JSON.stringify(r2, null, n2.beautify ? 4 : 0);
      } catch (e3) {
        try {
          t2 = r2.toString();
        } catch (e4) {
          t2 = r2;
        }
      }
      return t2;
    }
  }
  var decycle_1 = decycle, __parse = (t2) => {
    if (typeof t2 != "string")
      return t2;
    t2 = t2.split("\u2800").join("").trim();
    try {
      return Function(`
      "use strict";
      return (${t2});
    `)();
    } catch (e2) {
      return t2;
    }
  };
  const __encryptedMessages = {};
  var __md5 = { encrypt: function(e2) {
    typeof e2 != "string" && (e2 = fn$3(e2));
    var t2 = md5(e2).toString();
    return __encryptedMessages[t2] = e2, t2;
  }, decrypt: function(e2) {
    if (__encryptedMessages[e2]) {
      var t2 = __encryptedMessages[e2];
      return delete __encryptedMessages[e2], __parse(t2);
    }
    console.warn(`The message "${e2}" cannot be decrypted...`);
  } };
  function availableColors(e2) {
    e2 = Object.assign({ excludeBasics: false }, e2 != null ? e2 : {});
    const t2 = ["yellow", "cyan", "green", "magenta", "blue", "red", "grey", "gray"];
    let r2 = t2;
    return e2.excludeBasics && (r2 = t2.filter((e3) => e3 !== "white" && e3 !== "black" && e3 !== "grey" && e3 !== "gray")), r2;
  }
  function pickRandom(e2) {
    return e2[Math.round(Math.random() * (e2.length - 1))];
  }
  const _colorUsedByScope = {}, _colorsStack = {};
  function getColorFor(e2, t2) {
    var r2 = availableColors(t2 = __deepMerge$7({ scope: "default", excludeBasics: true }, t2 != null ? t2 : {})), n2 = __md5.encrypt(t2.scope), i2 = __md5.encrypt(e2);
    if (_colorsStack[n2 + "." + i2])
      return _colorsStack[n2 + "." + i2];
    if (_colorUsedByScope[n2] || (_colorUsedByScope[n2] = []), _colorUsedByScope[n2].length >= r2.length) {
      e2 = pickRandom(r2);
      return _colorsStack[n2 + "." + i2] = e2;
    }
    for (let e3 = 0; e3 < r2.length; e3++)
      if (_colorUsedByScope[n2].indexOf(r2[e3]) === -1)
        return _colorUsedByScope[n2].push(r2[e3]), _colorsStack[n2 + "." + i2] = r2[e3], r2[e3];
  }
  var __set = (t2, r2, n2, e2 = {}) => {
    if (e2 = Object.assign({}, e2), r2 && r2 !== "" && r2 !== ".") {
      const a2 = unquote(r2 = r2.replace(/\[(\w+)\]/g, ".[$1]")).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((e4) => unquote(e4));
      let e3 = t2;
      for (; a2.length - 1; ) {
        var i2 = a2.shift();
        i2 in e3 || (a2[0].match(/^\[[0-9]+\]$/) ? e3[i2] = [] : e3[i2] = {}), e3 = e3[i2];
      }
      return a2[0].match(/^\[[0-9]+\]$/) ? (Array.isArray(e3) || (e3 = []), e3.push(n2)) : e3[a2[0]] = n2, get$3(t2, r2);
    }
    t2 = n2;
  };
  function toJson(e2) {
    const r2 = {};
    return deepMap(e2, ({ value: e3, path: t2 }) => (__set(r2, t2, e3), e3), { privateProps: false, classInstances: true }), r2;
  }
  class SClass {
    constructor(e2 = {}) {
      this._settings = {}, this._interfacesStack = {}, generateInterfacesStack(this), setSettings(this, e2), applyInterfaces(this), this.metas = getMetas(this), Object.defineProperty(this, "metas", { enumerable: true, value: getMetas(this) });
    }
    get formattedName() {
      var e2;
      let t2 = `<yellow>${((e2 = this.metas) === null || e2 === void 0 ? void 0 : e2.name) || ""}</yellow>`;
      return (e2 = this.metas) !== null && e2 !== void 0 && e2.id && (t2 += ` <cyan>${(e2 = this.metas) === null || e2 === void 0 ? void 0 : e2.id}</cyan>`), t2;
    }
    static extends(e2) {
      class t2 extends e2 {
        constructor(e3, ...t3) {
          super(...t3), this._settings = {}, this._interfacesStack = {}, generateInterfacesStack(this), setSettings(this, e3), applyInterfaces(this), this.metas = getMetas(this), Object.defineProperty(this, "metas", { enumerable: true, value: getMetas(this) });
        }
        get formattedName() {
          let e3 = `<yellow>${this.name || ""}</yellow>`;
          return this.id && (e3 += ` <cyan>${this.id}</cyan>`), e3;
        }
        expose(e3, t3) {
          return expose(this, e3, t3);
        }
        applyInterface(e3, t3) {
          return applyInterface(this, e3, t3);
        }
        getInterface(e3) {
          return getInterface(this, e3);
        }
        toPlainObject() {
          return toPlainObject(this);
        }
      }
      return t2;
    }
    expose(e2, t2) {
      return expose(this, e2, t2);
    }
    applyInterface(e2, t2) {
      return applyInterface(this, e2, t2);
    }
    getInterface(e2) {
      return getInterface(this, e2);
    }
    toPlainObject() {
      return toPlainObject(this);
    }
  }
  function getMetas(e2) {
    var t2;
    let r2 = `<yellow>${((t2 = e2._settings.metas) === null || t2 === void 0 ? void 0 : t2.name) || ""}</yellow>`;
    return (t2 = e2._settings.metas) !== null && t2 !== void 0 && t2.id && (r2 += ` <cyan>${e2._settings.metas.id}</cyan>`), { id: (t2 = (t2 = e2._settings.metas) === null || t2 === void 0 ? void 0 : t2.id) !== null && t2 !== void 0 ? t2 : e2.constructor.name, name: (t2 = (t2 = e2._settings.metas) === null || t2 === void 0 ? void 0 : t2.name) !== null && t2 !== void 0 ? t2 : e2.constructor.name, formattedName: r2, color: (e2 = (e2 = e2._settings.metas) === null || e2 === void 0 ? void 0 : e2.color) !== null && e2 !== void 0 ? e2 : "yellow" };
  }
  function generateInterfacesStack(r2) {
    const n2 = fn$4(r2, { includeBaseClass: true });
    Object.keys(n2).forEach((e2) => {
      var t2 = n2[e2];
      t2.interfaces && (r2._interfacesStack[e2] = t2.interfaces);
    });
  }
  function expose(t2, r2, e2) {
    (e2 = __deepMerge$7({ as: void 0, props: [] }, e2)).as && typeof e2.as == "string" && (t2[e2.as] = r2), e2.props && e2.props.forEach((e3) => {
      r2[e3].bind && typeof r2[e3].bind == "function" ? t2[e3] = r2[e3].bind(r2) : t2[e3] = r2[e3];
    });
  }
  function getInterfaceObj(t2, r2) {
    let n2 = get$3(t2._interfacesStack, r2);
    if (!n2) {
      var i2 = Object.keys(t2._interfacesStack);
      for (let e2 = 0; e2 < i2.length; e2++) {
        var a2 = t2._interfacesStack[i2[e2]];
        if (a2[r2] !== void 0) {
          n2 = plainObject$7(a2[r2]) ? a2[r2] : { apply: true, on: r2 === "settings" ? "_settings" : r2 === "this" ? t2 : void 0, class: a2[r2] };
          break;
        }
      }
    }
    return r2 === "settings" && n2.on === void 0 && (t2.settings !== void 0 ? n2.on = "settings" : t2._settings !== void 0 && (n2.on = "_settings")), n2;
  }
  function toPlainObject(e2) {
    return toJson(e2);
  }
  function getInterface(e2, t2) {
    t2 = getInterfaceObj(e2, t2);
    return plainObject$7(t2) ? t2.class : t2;
  }
  function applyInterfaces(n2) {
    var t2 = Object.keys(n2._interfacesStack);
    for (let e2 = t2.length - 1; 0 <= e2; e2--) {
      const i2 = n2._interfacesStack[t2[e2]], a2 = t2[e2];
      Object.keys(i2).forEach((e3) => {
        var t3 = i2[e3];
        let r2;
        r2 = plainObject$7(t3) ? Object.assign({}, Object.assign({ apply: true, on: e3 === "settings" ? "_settings" : e3 === "this" ? n2 : void 0 }, t3)) : Object.assign({}, { apply: true, on: e3 === "settings" ? "_settings" : e3 === "this" ? n2 : void 0, class: t3 }), r2.apply === true && r2.on && (typeof r2.on == "string" && get$3(n2, r2.on) !== void 0 || typeof r2.on == "object" ? applyInterface(n2, a2 + "." + e3, r2.on) : n2[e3] !== void 0 && applyInterface(n2, a2 + "." + e3));
      });
    }
  }
  function applyInterface(n2, i2, e2 = null) {
    const a2 = getInterfaceObj(n2, "" + i2);
    if (!a2)
      throw new Error(`You try to apply the interface named "<yellow>${i2}</yellow>" on the context "<cyan>${n2.name}</cyan>" but it does not exists...`);
    if (e2 !== void 0 && (a2.on = e2), !a2)
      throw `Sorry the the asked interface "<yellow>${i2}</yellow>" does not exists on the class "<cyan>${n2.constructor.name}</cyan>"`;
    if (i2.includes(".") && (i2 = i2.split(".").slice(1).join(".")), plainObject$7(a2)) {
      let e3;
      e3 = a2.on && typeof a2.on == "string" ? get$3(n2, a2.on) : a2.on && typeof a2.on == "object" ? a2.on : get$3(n2, i2);
      let t2 = n2.constructor.name;
      n2.id && (t2 += `(${n2.id})`), i2 && (t2 += "." + i2), a2.on && a2.on.constructor && (t2 += "." + a2.on.constructor.name), a2.on && a2.on.id && (t2 += `(${a2.on.id})`);
      let r2;
      return i2 === "this" ? (r2 = a2.class.apply(e3 || {}, { id: t2, throw: true }), deepAssign(n2, r2.value), n2) : (r2 = a2.class.apply(e3, { id: t2, throw: true }), a2.on && typeof a2.on == "object" ? deepAssign(a2.on, r2) : a2.on && typeof a2.on == "string" ? deepAssign(get$3(n2, a2.on), r2) : n2[i2] !== void 0 ? n2[i2] : r2);
    }
  }
  function setSettings(e2, t2 = {}) {
    e2._settings = t2, e2._settings.metas || (e2._settings.metas = {}), (t2 = e2._settings.metas) !== null && t2 !== void 0 && t2.id || (e2._settings.metas.id = e2.constructor.name), e2.constructor.name.match(/^SConfig/) ? e2._settings.metas.color || (e2._settings.metas.color = "yellow") : e2._settings.metas.color || (e2._settings.metas.color = getColorFor(e2.constructor.name, { scope: "class" }));
  }
  function isInteger(e2) {
    return typeof e2 == "number" && !isNaN(e2) && (0 | (e2 = parseFloat(e2))) === e2;
  }
  function upperFirst(e2) {
    return e2.charAt(0).toUpperCase() + e2.slice(1);
  }
  function typeOf(t2, r2 = {}) {
    r2 = __deepMerge$7({ of: false, customClass: true }, r2);
    let e2;
    e2 = Array.isArray(t2) ? "Array" : t2 instanceof Map ? "Map" : t2 === null ? "Null" : t2 === void 0 ? "Undefined" : typeof t2 == "string" ? "String" : isInteger(t2) ? "Integer" : typeof t2 == "number" ? "Number" : typeof t2 == "boolean" ? "Boolean" : t2 instanceof RegExp ? "RegExp" : r2.customClass === true && cls(t2) && t2.name !== void 0 ? upperFirst(t2.name) : r2.customClass === true && t2.constructor !== void 0 && t2.constructor.name !== void 0 ? upperFirst(t2.constructor.name) : r2.customClass === false && cls(t2) ? "Class" : typeof t2 == "function" ? "Function" : typeof t2 == "object" ? "Object" : "Unknown";
    if (r2.of === true && !["Null", "Undefined", "String", "Integer", "Number", "Boolean", "Unknown"].includes(e2)) {
      const n2 = Array.isArray(t2) ? [...t2.keys()] : Object.keys(t2), i2 = [];
      n2.forEach((e3) => {
        e3 = typeOf(t2[e3], { of: false, customClass: r2.customClass });
        i2.includes(e3) || i2.push(e3);
      }), e2 += `<${i2.join("|")}>`;
    }
    return e2;
  }
  const fn$2 = function(t2, r2, n2 = {}) {
    n2 = Object.assign({ newStack: false }, n2);
    var e2 = typeOf(t2).toLowerCase();
    let i2;
    i2 = e2 === "object" ? Object.keys(t2) : e2 === "array" ? Array.from(Array(t2.length).keys()) : e2 === "number" || e2 === "integer" ? Array.from(Array(Math.round(t2)).keys()) : e2 === "string" || e2 === "set" ? Array.from(t2) : Array.from(t2.keys()), e2 !== "string" && e2 !== "number" && e2 !== "integer" && e2 !== "set" || (n2.newStack = true);
    let a2 = [];
    e2 === "object" ? a2 = {} : e2 === "map" ? a2 = new Map() : e2 === "set" && (a2 = new Set());
    for (let e3 = 0; e3 < i2.length; e3++) {
      var o2, s2 = i2[e3];
      if ((o2 = r2({ key: s2, prop: s2, value: ((e4, t3) => {
        switch (typeOf(e4).toLowerCase()) {
          case "array":
          case "object":
            return e4[t3];
          case "string":
            return t3;
          case "number":
          case "integer":
            return t3;
          case "map":
            return e4.get(t3);
          case "set":
            return t3;
        }
      })(t2, s2), i: e3, idx: e3 })) === -1)
        break;
      ((e4, t3, r3) => {
        switch (typeOf(e4).toLowerCase()) {
          case "array":
            n2.newStack === true ? e4.push(r3) : e4[t3] = r3;
            break;
          case "object":
            e4[t3] = r3;
            break;
          case "number":
          case "integer":
          case "string":
            e4.push(r3);
            break;
          case "map":
            e4.set(t3, r3);
            break;
          case "set":
            e4.add(r3);
        }
      })(n2.newStack ? a2 : t2, s2, o2);
    }
    return e2 === "string" ? a2.join("") : n2.newStack ? a2 : t2;
  };
  source$1.level = 3;
  const tagsMap = { black: (e2, t2) => source$1.black(t2), red: (e2, t2) => source$1.red(t2), green: (e2, t2) => source$1.green(t2), yellow: (e2, t2) => source$1.yellow(t2), blue: (e2, t2) => source$1.blue(t2), magenta: (e2, t2) => source$1.magenta(t2), cyan: (e2, t2) => source$1.cyan(t2), white: (e2, t2) => source$1.white(t2), grey: (e2, t2) => source$1.grey(t2), bgBlack: (e2, t2) => source$1.bgBlack(t2), bgRed: (e2, t2) => source$1.bgRed(t2), bgGreen: (e2, t2) => source$1.bgGreen(t2), bgYellow: (e2, t2) => source$1.bgYellow(t2), bgBlue: (e2, t2) => source$1.bgBlue(t2), bgMagenta: (e2, t2) => source$1.bgMagenta(t2), bgCyan: (e2, t2) => source$1.bgCyan(t2), bgWhite: (e2, t2) => source$1.bgWhite(t2), bold: (e2, t2) => source$1.bold(t2), dim: (e2, t2) => source$1.dim(t2), italic: (e2, t2) => source$1.italic(t2), underline: (e2, t2) => source$1.underline(t2), strike: (e2, t2) => source$1.strike(t2), h1: (e2, t2) => source$1.underline(source$1.bold(t2)) + "\n\n", h2: (e2, t2) => source$1.bold(t2) + "\n", date: (e2, t2) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2), time: (e2, t2) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2), day: (e2, t2) => new Date().getDate().toString().padStart("0", 2), days: (e2, t2) => new Date().getDate().toString().padStart("0", 2), month: (e2, t2) => new Date().getMonth().toString().padStart("0", 2), months: (e2, t2) => new Date().getMonth().toString().padStart("0", 2), year: (e2, t2) => new Date().getFullYear().toString().padStart("0", 2), years: (e2, t2) => new Date().getFullYear().toString().padStart("0", 2), hour: (e2, t2) => new Date().getHours().toString().padStart("0", 2), hours: (e2, t2) => new Date().getHours().toString().padStart("0", 2), minute: (e2, t2) => new Date().getMinutes().toString().padStart("0", 2), minutes: (e2, t2) => new Date().getMinutes().toString().padStart("0", 2), second: (e2, t2) => new Date().getSeconds().toString().padStart("0", 2), seconds: (e2, t2) => new Date().getSeconds().toString().padStart("0", 2), br: (e2, t2) => "\n" };
  function replaceTags(e2, c2) {
    let u2 = (e2 = fn$3(e2 = e2 || "")).replace(/\r\n/g, "|rn|");
    return u2 = u2.replace(/\n/g, "|n|"), u2 = u2.replace(/\r/g, "|r|"), Object.keys(c2).forEach((t2) => {
      var e3 = new RegExp(`<s*${t2}[^>]*>((.*?))<\\s*/\\s*${t2}>`, "g"), r2 = u2.match(e3), e3 = new RegExp(`\\s?<${t2}\\s?/>\\s?`, "g"), n2 = u2.match(e3);
      if (r2)
        for (let e4 = 0; e4 < r2.length; e4++) {
          const s2 = r2[e4];
          var i2, a2 = s2.match(`<\\s*${t2}[^>]*>((.*?))<\\s*/\\s*${t2}>`);
          a2 && (i2 = a2[0], a2 = a2[1], u2 = u2.replace(i2, c2[t2](t2, a2)));
        }
      if (n2)
        for (let e4 = 0; e4 < n2.length; e4++) {
          const l2 = n2[e4];
          var o2 = l2.match(`\\s?<${t2}\\s?/>\\s?`);
          o2 && (o2 = o2[0], u2 = u2.replace(o2, c2[t2](t2, "")));
        }
    }), u2 = u2.replace(/\|rn\|/g, "\r\n"), u2 = u2.replace(/\|n\|/g, "\n"), u2 = u2.replace(/\|r\|/g, "\r"), u2;
  }
  function parseHtml(e2) {
    let t2 = false;
    return Array.isArray(e2) ? t2 = true : e2 = [e2], e2 = e2.map((e3) => replaceTags(e3, tagsMap)), t2 ? e2 : e2[0];
  }
  function parseSingleTypeString(e2) {
    let t2 = "", r2 = e2;
    const n2 = e2.match(/<(.+)>$/gm);
    n2 && n2.length && (t2 = n2[0].replace("<", "").replace(">", "")), t2 !== "" && (r2 = r2.replace(`<${t2}>`, ""));
    let i2 = t2 !== "" ? [t2.toLowerCase()] : void 0;
    return t2 !== void 0 && t2.includes("|") && (i2 = t2.split("|").map((e3) => e3.trim().toLowerCase())), { type: r2, of: i2 };
  }
  const fn$1 = function(t2) {
    t2 = (t2 = (t2 = t2.toLowerCase().trim()).split("|").map((e2) => e2 = e2.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>")).join("|")).split("|").map((e2) => e2 = e2.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, "object<$1>")).join("|");
    let r2 = [], n2 = false, i2 = "";
    for (let e2 = 0; e2 < t2.length; e2++) {
      var a2 = t2[e2];
      a2 === "<" ? (n2 = true, i2 += a2) : a2 === ">" ? (n2 = false, i2 += a2) : a2 === "|" && n2 === false ? (r2.push(i2), i2 = "") : i2 += a2;
    }
    r2.push(i2);
    const o2 = [];
    return r2.forEach((e2) => {
      o2.push(parseSingleTypeString(e2));
    }), { raw: t2, types: o2 };
  };
  var __isNode$1 = () => typeof process != "undefined" && process.release && process.release.name === "node";
  class STypeResult {
    constructor(e2) {
      this._data = e2;
    }
    get typeString() {
      return this._data.typeString;
    }
    get value() {
      return this._data.value;
    }
    get received() {
      return this._data.received;
    }
    get expected() {
      return this._data.expected;
    }
    get issues() {
      return this._data.issues;
    }
    get settings() {
      return this._data.settings;
    }
    hasIssues() {
      return !!this._data;
    }
    toString() {
      return __isNode$1() ? this.toConsole() : 'The method "toHtml" has not being integrated for now...';
    }
    toConsole() {
      const e2 = [`<underline><magenta>${this._data.settings.name}</magenta></underline>`, "", "<underline>Received value</underline>", "", "" + fn$3(this._data.value, { beautify: true }), ""], n2 = [];
      Object.keys(this._data.issues).forEach((e3) => {
        const t3 = this._data.issues[e3], r2 = [];
        t3.expected.type && r2.push(`- Expected "<yellow>${t3.expected.type}</yellow>"`), t3.received.type && r2.push(`- Received "<red>${t3.received.type}</red>"`), t3.message && r2.push(["<underline>Details:</underline>", t3.message].join("\n")), n2.push(r2.join("\n"));
      });
      const t2 = ["", "<underline>Settings</underline>", "", "" + fn$3(this._data.settings, { beautify: true })];
      return parseHtml(`
${e2.join("\n")}
${n2.join("\n")}
${this.settings.verbose ? t2.join("\n") : ""}
    `).trim();
    }
  }
  class SType {
    constructor(e2, t2 = {}) {
      if (e2 = (this.typeString = e2).toLowerCase().trim(), this.constructor._instanciatedTypes[e2] !== void 0)
        return this.constructor._instanciatedTypes[e2];
      this.types = fn$1(e2).types, this._settings = __deepMerge$7({ id: this.constructor.name, name: this.constructor.name, customTypes: true, interfaces: true }, t2), this.constructor._instanciatedTypes[e2] = this;
    }
    static registerType(e2) {
      if (e2.id === void 0 || typeof e2.id != "string")
        throw new Error("Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...");
      this._registeredTypes[e2.id] = e2;
    }
    is(e2, t2 = {}) {
      const r2 = this.check(e2, t2);
      return r2 === true || (!(r2 instanceof STypeResult) || !r2.hasIssues());
    }
    check(r2, n2 = {}) {
      n2 = __deepMerge$7(this._settings, n2);
      const i2 = {};
      for (let e2 = 0; e2 < this.types.length; e2++) {
        var a2 = this.types[e2], t2 = a2.type;
        const u3 = this._isType(r2, t2, n2);
        if (u3 === true) {
          if (a2.of === void 0)
            return true;
          var o2 = typeOf(r2);
          if (o2 !== "Array" && o2 !== "Object" && o2 !== "Map")
            throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${o2}</cyan>" that does not support "child" value(s)...`);
          var s2 = o2 === "Object" ? Object.keys(r2) : Array.from(r2.keys());
          if (!s2.length)
            return true;
          for (let t3 = 0; t3 < s2.length; t3++)
            for (let e3 = 0; e3 < a2.of.length; e3++) {
              var l2 = a2.of[e3], c2 = s2[t3], c2 = o2 === "Map" ? r2.get(c2) : r2[c2];
              if (this._isType(c2, l2, n2) === true)
                return true;
              i2[a2.type] = { expected: { type: a2.type }, received: { type: typeOf(c2), value: c2 } };
            }
        } else {
          const h2 = { expected: { type: a2.type }, received: { type: typeOf(r2), value: r2 } };
          u3 !== void 0 && u3 !== null && u3 !== false && u3.toString && typeof u3.toString == "function" && (h2.message = u3.toString()), i2[a2.type] = h2;
        }
      }
      const u2 = new STypeResult({ typeString: this.typeString, value: r2, expected: { type: this.typeString }, received: { type: typeOf(r2) }, issues: i2, settings: n2 });
      return u2;
    }
    _isType(e2, t2, r2 = {}) {
      if (r2 = __deepMerge$7(this._settings, r2), this.constructor._registeredTypes[t2.toLowerCase()] !== void 0)
        return this.constructor._registeredTypes[t2.toLowerCase()].is(e2);
      if (r2.interfaces === true) {
        const n2 = SInterface.getAvailableTypes();
        if (n2[t2] !== void 0)
          return n2[t2].apply(e2, {});
      }
      if (r2.customTypes === true) {
        r2 = typeOf(e2).toLowerCase();
        const i2 = Object.keys(fn$4(e2)).map((e3) => e3.toLowerCase());
        if (t2 === r2 || i2.indexOf(t2) !== -1)
          return true;
      }
      throw new Error(`Sorry but you try to validate a value with the type "<yellow>${t2}</yellow>" but this type is not registered...`);
    }
    cast(t2, r2, n2) {
      const i2 = { value: t2, issues: {}, settings: n2 = __deepMerge$7(this._settings, n2), toString() {
        const e2 = Object.entries(this.issues);
        return e2.map((e3) => e3[1]).join("\n");
      } };
      if (this.is(t2))
        return t2;
      for (let e2 = 0; e2 < this.types.length; e2++) {
        const s2 = this.types[e2], l2 = s2.type, c2 = this.constructor._registeredTypes[l2.toLowerCase()];
        if (c2 !== void 0 && c2.cast !== void 0) {
          let e3;
          if (e3 = c2.cast(t2, r2), e3 instanceof Error)
            i2.issues[l2] = e3.toString();
          else {
            if (s2.of !== void 0 && this.canHaveChilds(e3) === false) {
              var a2 = `Sorry but the passed type "<yellow>${l2}</yellow>" has some child(s) dependencies "<green>${s2.of.join("|")}</green>" but this type can not have child(s)`;
              throw new Error(parseHtml(a2));
            }
            if (s2.of !== void 0) {
              const u2 = new SType(s2.of.join("|"));
              e3 = fn$2(e3, ({ value: e4 }) => u2.cast(e4, r2, n2));
            }
            if (e3 === null && c2.id === "null")
              return null;
            if (e3 === void 0 && c2.id === "undefined")
              return;
            if (e3 !== null && e3 !== void 0)
              return e3;
            i2.issues[l2] = "Something goes wrong but no details are available... Sorry";
          }
        }
      }
      const o2 = [`Sorry but the value of type "<cyan>${typeOf(t2)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`];
      throw Object.keys(i2.issues).forEach((e2) => {
        o2.push(`- <red>${e2}</red>: ` + i2.issues[e2]);
      }), new Error(parseHtml(o2.join("\n")));
    }
    canHaveChilds(e2) {
      e2 = typeOf(e2);
      return e2 === "Array" || e2 === "Object" || e2 === "Map";
    }
    get name() {
      return this._settings.name;
    }
    get id() {
      return this._settings.id;
    }
  }
  function isString$2(e2) {
    return typeof e2 == "string" || e2 instanceof String;
  }
  SType._instanciatedTypes = {}, SType._registeredTypes = {};
  const descriptor$g = { name: "String", id: "string", is: (e2) => isString$2(e2), cast: (e2) => fn$3(e2, { beautify: true }) }, descriptor$f = { name: "Map", id: "map", is: (e2) => isMap(e2), cast: (e2) => {
    if (isMap(e2))
      return e2;
    const t2 = new Map();
    return t2.set("value", e2), t2;
  } }, descriptor$e = { name: "Object", id: "object", is: (e2) => isObject$3(e2), cast: (e2) => isObject$3(e2) ? e2 : { value: e2 } }, descriptor$d = { name: "Array", id: "array", is: (e2) => Array.isArray(e2), cast: (e2, t2 = {}) => e2 ? (t2.splitChars && Array.isArray(t2.splitChars) && (e2 = e2.split(new RegExp(`(${t2.splitChars.join("|")})`, "gm")).filter((e3) => e3.trim() !== "" && t2.splitChars.indexOf(e3) === -1)), Array.isArray(e2) ? e2 : [e2]) : [] }, descriptor$c = { name: "Integer", id: "integer", is: (e2) => Number.isInteger(e2), cast: (e2) => {
    if (typeof e2 != "string" && typeof e2 != "number")
      return new Error("Sorry but only strings and numbers can be casted to integers... Passed value: " + e2);
    var t2 = parseInt(e2);
    return isNaN(t2) ? new Error(`Sorry but the conversion of "<yellow>${e2}</yellow>" to a <green>Integer</green> does not work...`) : t2;
  } }, descriptor$b = { name: "Number", id: "number", is: (e2) => typeof e2 == "number", cast: (e2) => {
    if (typeof e2 != "string")
      return new Error("Sorry but only strings can be casted to numbers...");
    var t2 = parseFloat(e2);
    return isNaN(t2) ? new Error(`Sorry but the conversion of "<yellow>${e2}</yellow>" to a <green>Number</green> does not work...`) : t2;
  } }, descriptor$a = { name: "Boolean", id: "boolean", is: (e2) => typeof e2 == "boolean", cast: (e2, t2 = {}) => !(e2 === false || !t2 || !t2.nullishAsTrue || e2) || (typeof e2 == "boolean" ? e2 : e2 != null && (typeof e2 == "number" ? 0 < e2 : typeof e2 == "string" || Array.isArray(e2) ? 0 < e2.length : typeof e2 == "object" ? 0 < Object.keys(e2).length : new Error(["Sorry but for now only these types can be casted to boolean:", "- <yellow>null</yellow>: Will be casted as <red>false</red>", "- <yellow>undefined</yellow>: Will be casted as <red>false</red>", "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise", "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise", "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise", "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"].join("\n")))) }, descriptor$9 = { name: "Undefined", id: "undefined", is: (e2) => e2 === void 0, cast: (e2) => {
  } }, descriptor$8 = { name: "Null", id: "null", is: (e2) => e2 === null, cast: (e2) => null }, descriptor$7 = { name: "Symbol", id: "symbol", is: (e2) => typeof e2 == "symbol", cast: (e2) => typeof e2 == "symbol" ? e2 : Symbol(e2) }, descriptor$6 = { name: "Bigint", id: "bigint", is: (e2) => typeof e2 == "bigint", cast: (t2) => {
    if (typeof t2 == "bigint")
      return t2;
    if (typeof t2 != "string" && typeof t2 != "number")
      return new Error("Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>");
    let r2;
    try {
      r2 = BigInt(t2);
    } catch (e2) {
      r2 = new Error(`It seem's that the passed value "<yellow>${t2}</yellow>" can not be casted to a <green>BigInt</green>`);
    }
    return r2;
  } }, descriptor$5 = { name: "Date", id: "date", is: (e2) => e2 instanceof Date, cast: (s2) => {
    if (typeof s2 == "string")
      return new Date(s2);
    if (typeof s2 == "number")
      return new Date(Math.round(s2));
    if (plainObject$7(s2)) {
      const l2 = new Date();
      let e2 = l2.getFullYear(), t2 = 0, r2 = 1, n2 = 0, i2 = 0, a2 = 0, o2 = 0;
      return s2.year && typeof s2.year == "number" && (e2 = s2.year), s2.month && typeof s2.month == "number" && (t2 = s2.month), s2.day && typeof s2.day == "number" && (r2 = s2.day), s2.hours && typeof s2.hours == "number" && (n2 = s2.hours), s2.minutes && typeof s2.minutes == "number" && (i2 = s2.minutes), s2.seconds && typeof s2.seconds == "number" && (a2 = s2.seconds), s2.milliseconds && typeof s2.milliseconds == "number" && (o2 = s2.milliseconds), new Date(e2, t2, r2, n2, i2, a2, o2);
    }
    return new Error("Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date");
  } }, descriptor$4 = { name: "Function", id: "function", is: (e2) => typeof e2 == "function", cast: (e2) => new Error("Sorry but nothing is castable to a Function") }, descriptor$3 = { name: "WeakMap", id: "weakmap", is: (e2) => e2 instanceof WeakMap, cast: (e2) => new Error("Sorry but nothing can be casted to a WeakMap for now") }, descriptor$2 = { name: "WeakSet", id: "weakset", is: (e2) => e2 instanceof WeakSet, cast: (e2) => new Error("Sorry but nothing can be casted to a WeakSet for now") }, descriptor$1 = { name: "Set", id: "set", is: (e2) => e2 instanceof Set, cast: (e2) => {
    if (e2 instanceof Set)
      return e2;
    const t2 = new Set();
    return t2.add(e2), t2;
  } }, descriptor = { name: "Class", id: "class", is: (e2) => cls(e2), cast: (e2) => new Error("Sorry but nothing is castable to a Class") };
  function ofType(e2, t2, r2 = {}) {
    r2 = Object.assign({ verbose: false }, r2);
    const n2 = new SType(t2, r2);
    return n2.is(e2);
  }
  SType.registerType(descriptor$g), SType.registerType(descriptor$f), SType.registerType(descriptor$e), SType.registerType(descriptor$d), SType.registerType(descriptor$c), SType.registerType(descriptor$b), SType.registerType(descriptor$a), SType.registerType(descriptor$9), SType.registerType(descriptor$8), SType.registerType(descriptor$7), SType.registerType(descriptor$6), SType.registerType(descriptor$5), SType.registerType(descriptor$4), SType.registerType(descriptor$3), SType.registerType(descriptor$2), SType.registerType(descriptor$1), SType.registerType(descriptor);
  class SDescriptorResult extends SClass {
    constructor(e2, t2, r2) {
      super({}), this._issues = {}, this._descriptor = e2, this._descriptorSettings = r2;
      try {
        this._originalValue = clone$2(t2, { deep: true });
      } catch (e3) {
        this._originalValue = t2;
      }
      this.value = t2;
    }
    hasIssues() {
      return 1 <= Object.keys(this._issues).length;
    }
    add(e2) {
      e2.__ruleObj.id && (this._issues[e2.__ruleObj.id] = e2);
    }
    toString() {
      return __isNode$1(), this.toConsole();
    }
    toConsole() {
      const e2 = [`<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`, "", "" + fn$3(this.value, { beautify: true }), ""], n2 = [];
      Object.keys(this._issues).forEach((e3) => {
        const t3 = this._issues[e3];
        let r2 = "";
        t3.__error && t3.__error instanceof Error ? r2 = t3.__error.message : t3.__ruleObj.message !== void 0 && typeof t3.__ruleObj.message == "function" ? r2 = t3.__ruleObj.message(t3) : t3.__ruleObj.message !== void 0 && typeof t3.__ruleObj.message == "string" && (r2 = t3.__ruleObj.message), n2.push(`-${typeof t3.__propName == "string" ? ` [<magenta>${t3.__propName}</magenta>]` : ""} <red>${e3}</red>: ` + r2);
      });
      const t2 = ["", "<underline>Settings</underline>", "", "" + fn$3(this._descriptorSettings, { beautify: true })];
      return parseHtml(`
${e2.join("\n")}
${n2.join("\n")}
${t2.join("\n")}
    `).trim();
    }
  }
  var isExtglob$1 = function(e2) {
    if (typeof e2 != "string" || e2 === "")
      return false;
    for (var t2; t2 = /(\\).|([@?!+*]\(.*\))/g.exec(e2); ) {
      if (t2[2])
        return true;
      e2 = e2.slice(t2.index + t2[0].length);
    }
    return false;
  }, isExtglob = isExtglob$1, chars = { "{": "}", "(": ")", "[": "]" }, strictCheck = function(e2) {
    if (e2[0] === "!")
      return true;
    for (var t2 = 0, r2 = -2, n2 = -2, i2 = -2, a2 = -2, o2 = -2; t2 < e2.length; ) {
      if (e2[t2] === "*")
        return true;
      if (e2[t2 + 1] === "?" && /[\].+)]/.test(e2[t2]))
        return true;
      if (n2 !== -1 && e2[t2] === "[" && e2[t2 + 1] !== "]" && t2 < (n2 = n2 < t2 ? e2.indexOf("]", t2) : n2)) {
        if (o2 === -1 || n2 < o2)
          return true;
        if ((o2 = e2.indexOf("\\", t2)) === -1 || n2 < o2)
          return true;
      }
      if (i2 !== -1 && e2[t2] === "{" && e2[t2 + 1] !== "}" && t2 < (i2 = e2.indexOf("}", t2)) && ((o2 = e2.indexOf("\\", t2)) === -1 || i2 < o2))
        return true;
      if (a2 !== -1 && e2[t2] === "(" && e2[t2 + 1] === "?" && /[:!=]/.test(e2[t2 + 2]) && e2[t2 + 3] !== ")" && t2 < (a2 = e2.indexOf(")", t2)) && ((o2 = e2.indexOf("\\", t2)) === -1 || a2 < o2))
        return true;
      if (r2 !== -1 && e2[t2] === "(" && e2[t2 + 1] !== "|" && (r2 = r2 < t2 ? e2.indexOf("|", t2) : r2) !== -1 && e2[r2 + 1] !== ")" && r2 < (a2 = e2.indexOf(")", r2)) && ((o2 = e2.indexOf("\\", r2)) === -1 || a2 < o2))
        return true;
      if (e2[t2] === "\\") {
        var s2 = e2[t2 + 1];
        t2 += 2;
        s2 = chars[s2];
        if (!s2 || (s2 = e2.indexOf(s2, t2)) !== -1 && (t2 = s2 + 1), e2[t2] === "!")
          return true;
      } else
        t2++;
    }
    return false;
  }, relaxedCheck = function(e2) {
    if (e2[0] === "!")
      return true;
    for (var t2 = 0; t2 < e2.length; ) {
      if (/[*?{}()[\]]/.test(e2[t2]))
        return true;
      if (e2[t2] === "\\") {
        var r2 = e2[t2 + 1];
        t2 += 2;
        r2 = chars[r2];
        if (!r2 || (r2 = e2.indexOf(r2, t2)) !== -1 && (t2 = r2 + 1), e2[t2] === "!")
          return true;
      } else
        t2++;
    }
    return false;
  }, isGlob = function(e2, t2) {
    if (typeof e2 != "string" || e2 === "")
      return false;
    if (isExtglob(e2))
      return true;
    var r2 = strictCheck;
    return (r2 = t2 && t2.strict === false ? relaxedCheck : r2)(e2);
  }, __isGlob = (e2) => isGlob(e2);
  class SDescriptor extends SClass {
    constructor(e2) {
      super(__deepMerge$7({ descriptor: { rules: {}, type: "Object", arrayAsValue: false, throwOnMissingRule: false, defaults: true } }, e2 != null ? e2 : {}));
    }
    static registerRule(e2) {
      if (e2.id === void 0 || typeof e2.id != "string")
        throw new Error("Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...");
      this._registeredRules[e2.id] = e2;
    }
    get descriptorSettings() {
      return this._settings.descriptor;
    }
    apply(t2, e2) {
      const n2 = __deepMerge$7(this.descriptorSettings, e2 || {});
      t2 == null && (t2 = {});
      const i2 = {}, a2 = {};
      this._descriptorResult = new SDescriptorResult(this, a2, Object.assign({}, n2));
      const o2 = n2.rules;
      if (!ofType(t2, n2.type))
        throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${typeOf(t2)}</cyan>" but only "<green>${n2.type}</green>"...`);
      if (Array.isArray(t2) && !n2.arrayAsValue)
        throw new Error("Sorry but the support for arrays like values has not been integrated for not...");
      if (typeof t2 != "object" || t2 == null)
        throw console.warn(t2), new Error("You can apply an <yellow>SDescriptor</yellow> only on an Object like value...");
      if (Object.keys(o2).forEach((e3) => {
        __isGlob(e3) && t2 || (i2[e3] = get$3(t2, e3));
      }), Object.keys(i2).forEach((e3) => {
        const t3 = o2[e3];
        i2[e3] === void 0 && n2.defaults && t3.default !== void 0 && (i2[e3] = t3.default), t3.interface !== void 0 && (r2 = i2[e3], i2[e3] = t3.interface.apply(r2 || {}, {}));
        var r2 = this._validate(i2[e3], e3, t3, n2);
        r2 != null && __set(a2, e3, r2);
      }), this._descriptorResult.hasIssues())
        throw new Error(this._descriptorResult.toString());
      return this._descriptorResult;
    }
    _validate(e2, a2, o2, s2) {
      if (o2 === void 0)
        return e2;
      if ((o2.required === void 0 || o2.required === false) && e2 == null)
        return e2;
      let t2 = Object.keys(o2).filter((e3) => e3 !== "default");
      t2 = t2.sort((e3, t3) => {
        const r2 = this.constructor._registeredRules[e3], n2 = this.constructor._registeredRules[t3];
        return r2 ? n2 ? (r2.priority === void 0 && (r2.priority = 9999999999), n2.priority === void 0 && (n2.priority = 9999999999), r2.priotity - n2.priority) : 1 : -1;
      }).reverse();
      let l2 = e2;
      return t2.forEach((e3) => {
        var t3 = o2[e3];
        if (this.constructor._registeredRules[e3] === void 0) {
          if (s2.throwOnMissingRule)
            throw new Error(`Sorry but you try to validate a value using the "<yellow>${e3}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ` + Object.keys(this.constructor._registeredRules).join("\n- "));
        } else {
          const r2 = this.constructor._registeredRules[e3], n2 = r2.processParams !== void 0 ? r2.processParams(t3) : t3, i2 = r2.settings !== void 0 ? r2.settings : {};
          if (i2.mapOnArray && Array.isArray(l2)) {
            let t4 = [];
            l2.forEach((e4) => {
              e4 = this._processRule(e4, r2, a2, n2, i2, s2);
              Array.isArray(e4) ? t4 = [...t4, ...e4] : t4.push(e4);
            }), l2 = t4;
          } else {
            t3 = this._processRule(l2, r2, a2, n2, i2, s2);
            l2 = t3;
          }
        }
      }), l2;
    }
    _processRule(e2, t2, r2, n2, i2, a2) {
      a2 = t2.apply(e2, n2, i2, Object.assign(Object.assign({}, a2), { propName: r2, name: a2.name + "." + r2 }));
      if (n2 && n2.type && n2.type.toLowerCase() === "boolean" && a2 === true)
        return true;
      if (!(a2 instanceof Error))
        return a2;
      if (this._descriptorResult)
        throw this._descriptorResult.add({ __error: a2, __ruleObj: t2, __propName: r2 }), new Error(this._descriptorResult.toString());
    }
  }
  SDescriptor._registeredRules = {}, SDescriptor.rules = {}, SDescriptor.type = "Object";
  const ruleObj$3 = { priority: 1, name: "Required", id: "required", settings: { when: [void 0, null] }, message: "This value is required", processParams: (e2) => ({ value: e2 }), apply: (e2, t2, r2, n2) => t2.value === true && r2.when.indexOf(e2) !== -1 ? new Error("This property is <yellow>required</yellow>") : e2 }, ruleObj$2 = { prority: 10, name: "Type", id: "type", settings: {}, processParams: (e2) => {
    var t2;
    if ((e2 == null || !e2.type) && typeof e2 != "string")
      throw new Error('<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...');
    return Object.assign(Object.assign({}, typeof e2 != "string" ? e2 : {}), { type: (t2 = e2.type) !== null && t2 !== void 0 ? t2 : e2, cast: (e2 = e2.cast) === null || e2 === void 0 || e2 });
  }, apply: (e2, t2, r2, n2) => {
    const i2 = new SType(t2.type, { metas: { id: n2.id } });
    return t2.cast && !i2.is(e2) && (e2 = i2.cast(e2, t2)), i2.is(e2) ? e2 : new Error(`The value must be of type "<yellow>${t2.type}</yellow>" but you've passed a value of type "<cyan>${typeof e2}</cyan>"`);
  } }, ruleObj$1 = { name: "Min", id: "min", settings: {}, accept: "Number", message: (e2) => `This value has to be minimum "<yellow>${e2.min}</yellow>". Received "<red>${e2.received}</red>"`, processParams: (e2) => ({ value: e2 }), apply: (e2, t2, r2, n2) => e2 < t2.value ? new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${e2}</yellow>" must be greater or equal at <cyan>${t2.value}</cyan>`) : e2 }, ruleObj = { name: "Max", id: "max", settings: {}, accept: "Number", message: (e2) => `This value has to be maximum "<yellow>${e2.max}</yellow>". Received "<red>${e2.received}</red>"`, processParams: (e2) => ({ value: e2 }), apply: (e2, t2, r2, n2) => e2 > t2.value ? new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${e2}</yellow>" must be lower or equal at <cyan>${t2.value}</cyan>`) : e2 };
  function parseArgs(i2, e2 = {}) {
    e2 = __deepMerge$7({ throw: true, defaultObj: {}, cast: true, valueQuote: void 0 }, e2), i2 = (i2 = i2.trim()).replace(/(["'`])--/gm, "$1--\xA7 --");
    let a2 = e2.valueQuote;
    if (!a2) {
      for (let e3 = 0; e3 < i2.length; e3++) {
        var t2 = i2[e3];
        if (t2 === '"' || t2 === "`" || t2 === "'") {
          a2 = t2;
          break;
        }
      }
      a2 = a2 || '"';
    }
    let o2 = [], s2 = false;
    if (i2.match(/^\(/) && i2.match(/\)$/)) {
      s2 = true, i2 = i2.slice(1, -1);
      let t3 = "", r2 = 0, n3 = 0;
      for (let e3 = 0; e3 < i2.length; e3++) {
        var l2 = i2[e3], c2 = i2[e3 - 1] || i2[0];
        l2 !== a2 || c2 === "\\" || n3 ? l2 === a2 && c2 !== "\\" && n3 && n3-- : n3++, n3 || l2 !== "(" ? n3 || l2 !== ")" || r2-- : r2++, l2 !== "," || n3 || r2 ? t3 += l2 : (o2.push(t3.trim()), t3 = "");
      }
      r2 && (t3 += ")".repeat(r2)), o2.push(t3.trim());
    } else {
      let t3 = "", r2 = false;
      for (let e3 = 0; e3 < i2.length; e3++) {
        var n2 = i2[e3], u2 = i2[e3 - 1] || i2[0];
        n2 !== a2 || u2 === "\\" || r2 ? n2 === a2 && u2 !== "\\" && r2 && (r2 = false) : r2 = true, n2 !== " " || r2 ? t3 += n2 : (o2.push(t3.trim()), t3 = "");
      }
      o2.push(t3.trim());
    }
    o2 = o2.map((e3) => unquote(e3));
    const h2 = {};
    let d2 = void 0, p2;
    return o2 = o2.forEach((t3, r2) => {
      if (s2 || t3.includes(" ") || t3.slice(0, 2) !== "--" && t3.slice(0, 1) !== "-") {
        let e3;
        if (t3 && typeof t3 == "string" && (e3 = t3.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, ""), e3.match(/^\$[a-zA-Z0-9-_]+\s?:.*/))) {
          const n3 = t3.split(":");
          d2 = n3[0].trim().replace(/^\$/, ""), e3 = n3.slice(1).join(":").trim();
        }
        p2 = __parse(e3), typeof p2 == "string" && (p2 = p2.replace("--\xA7 ", "")), d2 !== void 0 ? (h2[d2] !== void 0 && h2[d2] !== true ? (Array.isArray(h2[d2]) || (h2[d2] = [h2[d2]]), h2[d2].push(p2)) : h2[d2] = p2, p2 = void 0, d2 = void 0) : h2[r2] = p2;
      } else
        p2 === void 0 && d2 !== -1 && d2 && h2[d2] === void 0 && (h2[d2] = true), d2 = t3.replace(/^[-]{1,2}/, ""), h2[d2] === void 0 && (h2[d2] = true);
    }), Object.keys(h2).forEach((e3) => {
      h2[e3] === void 0 && delete h2[e3];
    }), h2;
  }
  function getAvailableInterfaceTypes() {
    return global !== void 0 ? global._registeredInterfacesTypes || {} : window !== void 0 && window._registeredInterfacesTypes || {};
  }
  SDescriptor.registerRule(ruleObj$3), SDescriptor.registerRule(ruleObj$2), SDescriptor.registerRule(ruleObj$1), SDescriptor.registerRule(ruleObj), __isNode$1() ? global._registeredInterfacesTypes = {} : window._registeredInterfacesTypes = {};
  class SInterface extends SClass {
    constructor(e2) {
      super(__deepMerge$7({ interface: { stripUnkown: false } }, e2 != null ? e2 : {})), this._definition = {}, this._definition = this.constructor.definition;
    }
    static get definition() {
      return this._cachedDefinition || (this._cachedDefinition = this._definition, this._cachedDefinition);
    }
    static set definition(e2) {
      this._cachedDefinition = e2;
    }
    get interfaceSettings() {
      return this._settings.interface;
    }
    static registerRenderer(e2) {
      if (!e2.id)
        throw new Error(`Sorry but the interface renderer "<yellow>${e2.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
      this._registeredRenderers[e2.id] = e2;
    }
    static override(e2) {
      class t2 extends this {
      }
      return t2.overridedName = this.name + " (overrided)", t2.definition = __deepMerge$7(this.definition, e2), t2;
    }
    static getAvailableTypes() {
      return getAvailableInterfaceTypes();
    }
    static makeAvailableAsType(e2 = null) {
      const t2 = (e2 || this.name).toLowerCase();
      global !== void 0 ? (global._registeredInterfacesTypes[t2] = this, global._registeredInterfacesTypes[t2.replace("interface", "")] = this) : window !== void 0 && (window._registeredInterfacesTypes[t2] = this, window._registeredInterfacesTypes[t2.replace("interface", "")] = this);
    }
    static toObject() {
      var e2;
      return { name: this.name, description: (e2 = this.description) !== null && e2 !== void 0 ? e2 : "", definition: Object.assign({}, this.definition) };
    }
    static defaults() {
      const r2 = {};
      return Object.keys(this.definition).forEach((e2) => {
        var t2 = this.definition[e2];
        t2.default !== void 0 && (r2[e2] = t2.default);
      }), r2;
    }
    static apply(e2, t2) {
      const r2 = new this({ interface: t2 != null ? t2 : {} });
      return r2.apply(e2);
    }
    static render(e2 = "terminal", t2) {
      t2 = __deepMerge$7({ renderer: "terminal", exclude: ["help"] }, t2);
      if (!this._registeredRenderers[e2])
        throw new Error(`Sorry but the requested renderer "<yellow>${e2}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
      const r2 = new this._registeredRenderers[e2](this, t2);
      return r2.render();
    }
    apply(n2, e2) {
      var t2 = __deepMerge$7(this.interfaceSettings, e2 != null ? e2 : {});
      let i2 = n2;
      typeof n2 == "string" && (i2 = parseArgs(n2), Object.keys(i2).forEach((t3) => {
        for (let e3 = 0; e3 < Object.keys(this._definition).length; e3++) {
          var r3 = Object.keys(this._definition)[e3], r3 = this._definition[r3];
          if (r3.explicit) {
            if (r3.alias && ` ${n2} `.match(new RegExp(`\\s-${r3.alias}\\s`)))
              return;
            if (` ${n2} `.match(new RegExp(`\\s--${t3}\\s`)))
              return;
            delete i2[t3];
          }
        }
      }), Object.keys(i2).forEach((t3) => {
        for (let e3 = 0; e3 < Object.keys(this._definition).length; e3++) {
          var r3 = Object.keys(this._definition)[e3], n3 = this._definition[r3];
          n3.alias && n3.alias === t3 && i2[r3] === void 0 && (i2[r3] = i2[t3], delete i2[t3]);
        }
      }), Object.keys(i2).forEach((e3, t3) => {
        var r3;
        e3 === "" + t3 && ((r3 = Object.keys(this._definition))[t3] && (i2[r3[t3]] = i2[e3]), delete i2[e3]);
      }));
      const r2 = new SDescriptor({ descriptor: Object.assign({ type: "Object", rules: this._definition }, (e2 = t2.descriptor) !== null && e2 !== void 0 ? e2 : {}) });
      t2.baseObj && (i2 = __deepMerge$7(t2.baseObj, i2));
      const a2 = r2.apply(i2);
      if (a2.hasIssues())
        throw new Error(a2.toString());
      let o2 = a2.value;
      return t2.stripUnkown || (o2 = __deepMerge$7(i2, o2)), o2;
    }
  }
  SInterface.description = "", SInterface._registeredRenderers = {};
  var __awaiter$j = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  }, getRandomValues;
  function adoptStyleInShadowRoot(t2, r2 = document) {
    return __awaiter$j(this, void 0, void 0, function* () {
      var e2 = r2.querySelectorAll('link[rel="stylesheet"]');
      return e2 && t2 && Array.from(e2).forEach((e3) => __awaiter$j(this, void 0, void 0, function* () {
        t2 != null && t2.appendChild(e3.cloneNode());
      })), true;
    });
  }
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues && !(getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto)))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return getRandomValues(rnds8);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(e2) {
    return typeof e2 == "string" && REGEX.test(e2);
  }
  for (var byteToHex = [], i$3 = 0; i$3 < 256; ++i$3)
    byteToHex.push((i$3 + 256).toString(16).substr(1));
  function stringify(e2) {
    var t2 = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0, t2 = (byteToHex[e2[t2 + 0]] + byteToHex[e2[t2 + 1]] + byteToHex[e2[t2 + 2]] + byteToHex[e2[t2 + 3]] + "-" + byteToHex[e2[t2 + 4]] + byteToHex[e2[t2 + 5]] + "-" + byteToHex[e2[t2 + 6]] + byteToHex[e2[t2 + 7]] + "-" + byteToHex[e2[t2 + 8]] + byteToHex[e2[t2 + 9]] + "-" + byteToHex[e2[t2 + 10]] + byteToHex[e2[t2 + 11]] + byteToHex[e2[t2 + 12]] + byteToHex[e2[t2 + 13]] + byteToHex[e2[t2 + 14]] + byteToHex[e2[t2 + 15]]).toLowerCase();
    if (!validate(t2))
      throw TypeError("Stringified UUID is invalid");
    return t2;
  }
  function v4(e2, t2, r2) {
    var n2 = (e2 = e2 || {}).random || (e2.rng || rng)();
    if (n2[6] = 15 & n2[6] | 64, n2[8] = 63 & n2[8] | 128, t2) {
      r2 = r2 || 0;
      for (var i2 = 0; i2 < 16; ++i2)
        t2[r2 + i2] = n2[i2];
      return t2;
    }
    return stringify(n2);
  }
  function uniqid() {
    return v4();
  }
  function injectStyle(e2, t2 = "injected-style-" + uniqid(), r2 = document.head) {
    const n2 = document.createElement("style");
    return n2.type = "text/css", n2.setAttribute("id", "injected-style-" + t2.toLowerCase()), n2.innerHTML = e2, r2.appendChild(n2), n2;
  }
  function camelize$1(e2) {
    let t2 = "";
    return t2 = e2.replace(/(?:^|[_-\s])(\w)/g, function(e3, t3) {
      return t3 ? t3.toUpperCase() : "";
    }), t2 = t2.substr(0, 1).toLowerCase() + t2.slice(1), t2.trim();
  }
  function camelCase(e2) {
    return camelize$1(e2);
  }
  function getMethods(n2) {
    let e2 = [], t2 = n2;
    do {
      const r2 = Object.getOwnPropertyNames(t2);
      r2.indexOf("__defineGetter__") === -1 && (e2 = e2.concat(r2));
    } while (t2 = Object.getPrototypeOf(t2));
    return e2.sort().filter(function(e3, t3, r2) {
      if (e3 != r2[t3 + 1] && typeof n2[e3] == "function")
        return true;
    });
  }
  var concatMap$1 = function(e2, t2) {
    for (var r2 = [], n2 = 0; n2 < e2.length; n2++) {
      var i2 = t2(e2[n2], n2);
      isArray$5(i2) ? r2.push.apply(r2, i2) : r2.push(i2);
    }
    return r2;
  }, isArray$5 = Array.isArray || function(e2) {
    return Object.prototype.toString.call(e2) === "[object Array]";
  }, balancedMatch = balanced$1;
  function balanced$1(e2, t2, r2) {
    var n2 = range(e2 = e2 instanceof RegExp ? maybeMatch(e2, r2) : e2, t2 = t2 instanceof RegExp ? maybeMatch(t2, r2) : t2, r2);
    return n2 && { start: n2[0], end: n2[1], pre: r2.slice(0, n2[0]), body: r2.slice(n2[0] + e2.length, n2[1]), post: r2.slice(n2[1] + t2.length) };
  }
  function maybeMatch(e2, t2) {
    e2 = t2.match(e2);
    return e2 ? e2[0] : null;
  }
  function range(e2, t2, r2) {
    var n2, i2, a2, o2, s2, l2 = r2.indexOf(e2), c2 = r2.indexOf(t2, l2 + 1), u2 = l2;
    if (0 <= l2 && 0 < c2) {
      if (e2 === t2)
        return [l2, c2];
      for (n2 = [], a2 = r2.length; 0 <= u2 && !s2; )
        u2 == l2 ? (n2.push(u2), l2 = r2.indexOf(e2, u2 + 1)) : n2.length == 1 ? s2 = [n2.pop(), c2] : ((i2 = n2.pop()) < a2 && (a2 = i2, o2 = c2), c2 = r2.indexOf(t2, u2 + 1)), u2 = l2 < c2 && 0 <= l2 ? l2 : c2;
      n2.length && (s2 = [a2, o2]);
    }
    return s2;
  }
  balanced$1.range = range;
  var concatMap = concatMap$1, balanced = balancedMatch, braceExpansion = expandTop, escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(e2) {
    return parseInt(e2, 10) == e2 ? parseInt(e2, 10) : e2.charCodeAt(0);
  }
  function escapeBraces(e2) {
    return e2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(e2) {
    return e2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(e2) {
    if (!e2)
      return [""];
    var t2 = [], r2 = balanced("{", "}", e2);
    if (!r2)
      return e2.split(",");
    var n2 = r2.pre, e2 = r2.body, r2 = r2.post, n2 = n2.split(",");
    n2[n2.length - 1] += "{" + e2 + "}";
    e2 = parseCommaParts(r2);
    return r2.length && (n2[n2.length - 1] += e2.shift(), n2.push.apply(n2, e2)), t2.push.apply(t2, n2), t2;
  }
  function expandTop(e2) {
    return e2 ? expand$1(escapeBraces(e2 = e2.substr(0, 2) === "{}" ? "\\{\\}" + e2.substr(2) : e2), true).map(unescapeBraces) : [];
  }
  function embrace(e2) {
    return "{" + e2 + "}";
  }
  function isPadded(e2) {
    return /^-?0\d/.test(e2);
  }
  function lte(e2, t2) {
    return e2 <= t2;
  }
  function gte(e2, t2) {
    return t2 <= e2;
  }
  function expand$1(e2, t2) {
    var r2 = [], n2 = balanced("{", "}", e2);
    if (!n2 || /\$$/.test(n2.pre))
      return [e2];
    var i2 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n2.body), a2 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n2.body), o2 = i2 || a2, i2 = 0 <= n2.body.indexOf(",");
    if (!o2 && !i2)
      return n2.post.match(/,.*\}/) ? expand$1(e2 = n2.pre + "{" + n2.body + escClose + n2.post) : [e2];
    if (o2)
      s2 = n2.body.split(/\.\./);
    else if ((s2 = parseCommaParts(n2.body)).length === 1) {
      var s2 = expand$1(s2[0], false).map(embrace);
      if (s2.length === 1)
        return (c2 = n2.post.length ? expand$1(n2.post, false) : [""]).map(function(e3) {
          return n2.pre + s2[0] + e3;
        });
    }
    var l2 = n2.pre, c2 = n2.post.length ? expand$1(n2.post, false) : [""];
    if (o2) {
      var e2 = numeric(s2[0]), u2 = numeric(s2[1]), h2 = Math.max(s2[0].length, s2[1].length), d2 = s2.length == 3 ? Math.abs(numeric(s2[2])) : 1, p2 = lte;
      u2 < e2 && (d2 *= -1, p2 = gte);
      for (var f2, m2, g2 = s2.some(isPadded), v2 = [], y = e2; p2(y, u2); y += d2)
        a2 ? (m2 = String.fromCharCode(y)) === "\\" && (m2 = "") : (m2 = String(y), !g2 || 0 < (f2 = h2 - m2.length) && (f2 = new Array(1 + f2).join("0"), m2 = y < 0 ? "-" + f2 + m2.slice(1) : f2 + m2)), v2.push(m2);
    } else
      v2 = concatMap(s2, function(e3) {
        return expand$1(e3, false);
      });
    for (var _2 = 0; _2 < v2.length; _2++)
      for (var b2 = 0; b2 < c2.length; b2++) {
        var x2 = l2 + v2[_2] + c2[b2];
        t2 && !o2 && !x2 || r2.push(x2);
      }
    return r2;
  }
  var minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = { sep: "/" };
  try {
    path = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, expand = braceExpansion, plTypes = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(e2) {
    return e2.split("").reduce(function(e3, t2) {
      return e3[t2] = true, e3;
    }, {});
  }
  var slashSplit = /\/+/;
  function filter$3(n2, i2) {
    return i2 = i2 || {}, function(e2, t2, r2) {
      return minimatch(e2, n2, i2);
    };
  }
  function ext(t2, r2) {
    t2 = t2 || {}, r2 = r2 || {};
    var n2 = {};
    return Object.keys(r2).forEach(function(e2) {
      n2[e2] = r2[e2];
    }), Object.keys(t2).forEach(function(e2) {
      n2[e2] = t2[e2];
    }), n2;
  }
  function minimatch(e2, t2, r2) {
    if (typeof t2 != "string")
      throw new TypeError("glob pattern string required");
    return !(!(r2 = r2 || {}).nocomment && t2.charAt(0) === "#") && (t2.trim() === "" ? e2 === "" : new Minimatch(t2, r2).match(e2));
  }
  function Minimatch(e2, t2) {
    if (!(this instanceof Minimatch))
      return new Minimatch(e2, t2);
    if (typeof e2 != "string")
      throw new TypeError("glob pattern string required");
    t2 = t2 || {}, e2 = e2.trim(), path.sep !== "/" && (e2 = e2.split(path.sep).join("/")), this.options = t2, this.set = [], this.pattern = e2, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.make();
  }
  function make() {
    var e2, t2;
    this._made || (t2 = this.pattern, (e2 = this.options).nocomment || t2.charAt(0) !== "#" ? t2 ? (this.parseNegate(), t2 = this.globSet = this.braceExpand(), e2.debug && (this.debug = console.error), this.debug(this.pattern, t2), t2 = this.globParts = t2.map(function(e3) {
      return e3.split(slashSplit);
    }), this.debug(this.pattern, t2), t2 = t2.map(function(e3, t3, r2) {
      return e3.map(this.parse, this);
    }, this), this.debug(this.pattern, t2), t2 = t2.filter(function(e3) {
      return e3.indexOf(false) === -1;
    }), this.debug(this.pattern, t2), this.set = t2) : this.empty = true : this.comment = true);
  }
  function parseNegate() {
    var e2 = this.pattern, t2 = false, r2 = 0;
    if (!this.options.nonegate) {
      for (var n2 = 0, i2 = e2.length; n2 < i2 && e2.charAt(n2) === "!"; n2++)
        t2 = !t2, r2++;
      r2 && (this.pattern = e2.substr(r2)), this.negate = t2;
    }
  }
  function braceExpand(e2, t2) {
    if (t2 = t2 || (this instanceof Minimatch ? this.options : {}), (e2 = e2 === void 0 ? this.pattern : e2) === void 0)
      throw new TypeError("undefined pattern");
    return t2.nobrace || !e2.match(/\{.*\}/) ? [e2] : expand(e2);
  }
  minimatch.filter = filter$3, minimatch.defaults = function(n2) {
    if (!n2 || !Object.keys(n2).length)
      return minimatch;
    function e2(e3, t2, r2) {
      return i2.minimatch(e3, t2, ext(n2, r2));
    }
    var i2 = minimatch;
    return e2.Minimatch = function(e3, t2) {
      return new i2.Minimatch(e3, ext(n2, t2));
    }, e2;
  }, Minimatch.defaults = function(e2) {
    return e2 && Object.keys(e2).length ? minimatch.defaults(e2).Minimatch : Minimatch;
  }, Minimatch.prototype.debug = function() {
  }, Minimatch.prototype.make = make, Minimatch.prototype.parseNegate = parseNegate, minimatch.braceExpand = function(e2, t2) {
    return braceExpand(e2, t2);
  }, Minimatch.prototype.braceExpand = braceExpand, Minimatch.prototype.parse = parse$1;
  var SUBPARSE = {};
  function parse$1(e2, t2) {
    if (65536 < e2.length)
      throw new TypeError("pattern is too long");
    var r2 = this.options;
    if (!r2.noglobstar && e2 === "**")
      return GLOBSTAR;
    if (e2 === "")
      return "";
    var n2, i2 = "", a2 = !!r2.nocase, o2 = false, s2 = [], l2 = [], c2 = false, u2 = -1, h2 = -1, d2 = e2.charAt(0) === "." ? "" : r2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", p2 = this;
    function f2() {
      if (n2) {
        switch (n2) {
          case "*":
            i2 += star, a2 = true;
            break;
          case "?":
            i2 += qmark, a2 = true;
            break;
          default:
            i2 += "\\" + n2;
        }
        p2.debug("clearStateChar %j %j", n2, i2), n2 = false;
      }
    }
    for (var m2, g2 = 0, v2 = e2.length; g2 < v2 && (m2 = e2.charAt(g2)); g2++)
      if (this.debug("%s	%s %s %j", e2, g2, i2, m2), o2 && reSpecials[m2])
        i2 += "\\" + m2, o2 = false;
      else
        switch (m2) {
          case "/":
            return false;
          case "\\":
            f2(), o2 = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", e2, g2, i2, m2), c2) {
              this.debug("  in class"), i2 += m2 = m2 === "!" && g2 === h2 + 1 ? "^" : m2;
              continue;
            }
            p2.debug("call clearStateChar %j", n2), f2(), n2 = m2, r2.noext && f2();
            continue;
          case "(":
            if (c2) {
              i2 += "(";
              continue;
            }
            if (!n2) {
              i2 += "\\(";
              continue;
            }
            s2.push({ type: n2, start: g2 - 1, reStart: i2.length, open: plTypes[n2].open, close: plTypes[n2].close }), i2 += n2 === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", n2, i2), n2 = false;
            continue;
          case ")":
            if (c2 || !s2.length) {
              i2 += "\\)";
              continue;
            }
            f2();
            var a2 = true, y = s2.pop();
            i2 += y.close, y.type === "!" && l2.push(y), y.reEnd = i2.length;
            continue;
          case "|":
            if (c2 || !s2.length || o2) {
              i2 += "\\|", o2 = false;
              continue;
            }
            f2(), i2 += "|";
            continue;
          case "[":
            if (f2(), c2) {
              i2 += "\\" + m2;
              continue;
            }
            c2 = true, h2 = g2, u2 = i2.length, i2 += m2;
            continue;
          case "]":
            if (g2 === h2 + 1 || !c2) {
              i2 += "\\" + m2, o2 = false;
              continue;
            }
            if (c2) {
              var _2 = e2.substring(h2 + 1, g2);
              try {
                RegExp("[" + _2 + "]");
              } catch (e3) {
                var b2 = this.parse(_2, SUBPARSE), i2 = i2.substr(0, u2) + "\\[" + b2[0] + "\\]";
                a2 = a2 || b2[1], c2 = false;
                continue;
              }
            }
            c2 = !(a2 = true), i2 += m2;
            continue;
          default:
            f2(), o2 ? o2 = false : !reSpecials[m2] || m2 === "^" && c2 || (i2 += "\\"), i2 += m2;
        }
    for (c2 && (_2 = e2.substr(h2 + 1), b2 = this.parse(_2, SUBPARSE), i2 = i2.substr(0, u2) + "\\[" + b2[0], a2 = a2 || b2[1]), y = s2.pop(); y; y = s2.pop()) {
      var x2 = i2.slice(y.reStart + y.open.length);
      this.debug("setting tail", i2, y), x2 = x2.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(e3, t3, r3) {
        return t3 + t3 + (r3 = r3 || "\\") + "|";
      }), this.debug("tail=%j\n   %s", x2, x2, y, i2);
      var w2 = y.type === "*" ? star : y.type === "?" ? qmark : "\\" + y.type;
      a2 = true, i2 = i2.slice(0, y.reStart) + w2 + "\\(" + x2;
    }
    f2(), o2 && (i2 += "\\\\");
    var S2 = false;
    switch (i2.charAt(0)) {
      case ".":
      case "[":
      case "(":
        S2 = true;
    }
    for (var M2 = l2.length - 1; -1 < M2; M2--) {
      var E2 = l2[M2], T2 = i2.slice(0, E2.reStart), k2 = i2.slice(E2.reStart, E2.reEnd - 8), A2 = i2.slice(E2.reEnd - 8, E2.reEnd), C2 = i2.slice(E2.reEnd);
      A2 += C2;
      for (var $2 = T2.split("(").length - 1, R2 = C2, g2 = 0; g2 < $2; g2++)
        R2 = R2.replace(/\)[+*?]?/, "");
      E2 = "";
      i2 = T2 + k2 + (C2 = R2) + (E2 = C2 === "" && t2 !== SUBPARSE ? "$" : E2) + A2;
    }
    if (i2 !== "" && a2 && (i2 = "(?=.)" + i2), S2 && (i2 = d2 + i2), t2 === SUBPARSE)
      return [i2, a2];
    if (!a2)
      return globUnescape(e2);
    d2 = r2.nocase ? "i" : "";
    try {
      var L = new RegExp("^" + i2 + "$", d2);
    } catch (e3) {
      return new RegExp("$.");
    }
    return L._glob = e2, L._src = i2, L;
  }
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var e2 = this.set;
    if (!e2.length)
      return this.regexp = false, this.regexp;
    var t2 = this.options, r2 = t2.noglobstar ? star : t2.dot ? twoStarDot : twoStarNoDot, t2 = t2.nocase ? "i" : "", e2 = "^(?:" + (e2 = e2.map(function(e3) {
      return e3.map(function(e4) {
        return e4 === GLOBSTAR ? r2 : typeof e4 == "string" ? regExpEscape(e4) : e4._src;
      }).join("\\/");
    }).join("|")) + ")$";
    this.negate && (e2 = "^(?!" + e2 + ").*$");
    try {
      this.regexp = new RegExp(e2, t2);
    } catch (e3) {
      this.regexp = false;
    }
    return this.regexp;
  }
  function match(e2, t2) {
    if (this.debug("match", e2, this.pattern), this.comment)
      return false;
    if (this.empty)
      return e2 === "";
    if (e2 === "/" && t2)
      return true;
    var r2 = this.options;
    e2 = (e2 = path.sep !== "/" ? e2.split(path.sep).join("/") : e2).split(slashSplit), this.debug(this.pattern, "split", e2);
    var n2, i2, a2 = this.set;
    for (this.debug(this.pattern, "set", a2), i2 = e2.length - 1; 0 <= i2 && !(n2 = e2[i2]); i2--)
      ;
    for (i2 = 0; i2 < a2.length; i2++) {
      var o2 = a2[i2], s2 = e2;
      if (r2.matchBase && o2.length === 1 && (s2 = [n2]), this.matchOne(s2, o2, t2))
        return !!r2.flipNegate || !this.negate;
    }
    return !r2.flipNegate && this.negate;
  }
  function globUnescape(e2) {
    return e2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(e2) {
    return e2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  minimatch.makeRe = function(e2, t2) {
    return new Minimatch(e2, t2 || {}).makeRe();
  }, Minimatch.prototype.makeRe = makeRe, minimatch.match = function(e2, t2, r2) {
    var n2 = new Minimatch(t2, r2 = r2 || {});
    return e2 = e2.filter(function(e3) {
      return n2.match(e3);
    }), n2.options.nonull && !e2.length && e2.push(t2), e2;
  }, Minimatch.prototype.match = match, Minimatch.prototype.matchOne = function(e2, t2, r2) {
    var n2 = this.options;
    this.debug("matchOne", { this: this, file: e2, pattern: t2 }), this.debug("matchOne", e2.length, t2.length);
    for (var i2 = 0, a2 = 0, o2 = e2.length, s2 = t2.length; i2 < o2 && a2 < s2; i2++, a2++) {
      this.debug("matchOne loop");
      var l2, c2 = t2[a2], u2 = e2[i2];
      if (this.debug(t2, c2, u2), c2 === false)
        return false;
      if (c2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [t2, c2, u2]);
        var h2 = i2, d2 = a2 + 1;
        if (d2 === s2) {
          for (this.debug("** at the end"); i2 < o2; i2++)
            if (e2[i2] === "." || e2[i2] === ".." || !n2.dot && e2[i2].charAt(0) === ".")
              return false;
          return true;
        }
        for (; h2 < o2; ) {
          var p2 = e2[h2];
          if (this.debug("\nglobstar while", e2, h2, t2, d2, p2), this.matchOne(e2.slice(h2), t2.slice(d2), r2))
            return this.debug("globstar found match!", h2, o2, p2), true;
          if (p2 === "." || p2 === ".." || !n2.dot && p2.charAt(0) === ".") {
            this.debug("dot detected!", e2, h2, t2, d2);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), h2++;
        }
        return r2 && (this.debug("\n>>> no match, partial?", e2, h2, t2, d2), h2 === o2) ? true : false;
      }
      if (typeof c2 == "string" ? (l2 = n2.nocase ? u2.toLowerCase() === c2.toLowerCase() : u2 === c2, this.debug("string match", c2, u2, l2)) : (l2 = u2.match(c2), this.debug("pattern match", c2, u2, l2)), !l2)
        return false;
    }
    if (i2 === o2 && a2 === s2)
      return true;
    if (i2 === o2)
      return r2;
    if (a2 === s2)
      return i2 === o2 - 1 && e2[i2] === "";
    throw new Error("wtf?");
  };
  var ansiRegex$1 = ({ onlyFirst: e2 = false } = {}) => {
    var t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(t2, e2 ? void 0 : "g");
  };
  const ansiRegex = ansiRegex$1;
  var stripAnsi$1 = (e2) => typeof e2 == "string" ? e2.replace(ansiRegex(), "") : e2;
  function stripAnsi(e2) {
    return stripAnsi$1(e2);
  }
  function isTestEnv() {
    var e2;
    return ((e2 = process === null || process === void 0 ? void 0 : process.env) === null || e2 === void 0 ? void 0 : e2.NODE_ENV) === "test";
  }
  function isChildProcess() {
    return !isTestEnv() && (process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0);
  }
  class SLog {
    constructor(e2) {
      var t2;
      if (!(e2 != null && e2.value || e2._logObj))
        throw new Error(`<red>[${this.constructor.name}]</red> Sorry but you cannot instanciate a new SLog without a "<yellow>value</yellow>" property...`);
      this._logObj = __deepMerge$7({ type: SLog.LOG, timestamp: Date.now(), decorators: true, time: false }, this.constructor._defaultLogObj, (t2 = e2._logObj) !== null && t2 !== void 0 ? t2 : e2);
    }
    static filter(e2, t2 = "default") {
      this._appliedFilters[t2] = e2;
    }
    static clearFilters() {
      this._appliedFilters = {};
    }
    static removeFilter(e2) {
      delete this._appliedFilters[e2];
    }
    static setDefaultLogObj(e2) {
      this._defaultLogObj = e2;
    }
    get value() {
      return this._logObj.value;
    }
    set value(e2) {
      this._logObj.value = e2;
    }
    get type() {
      return this._logObj.type;
    }
    get active() {
      var t2 = Object.keys(this.constructor._appliedFilters);
      for (let e2 = 0; e2 < t2.length; e2++) {
        var r2 = this.constructor._appliedFilters[t2[e2]];
        for (let e3 = 0; e3 < Object.keys(r2).length; e3++) {
          var n2 = Object.keys(r2)[e3];
          const i2 = r2[n2];
          if (this[n2] !== void 0) {
            if (Array.isArray(i2)) {
              if (i2.indexOf(this[n2]) === -1)
                return false;
            } else if (i2 !== this[n2])
              return false;
          }
        }
      }
      return true;
    }
    get decorators() {
      return this._logObj.decorators;
    }
    set decorators(e2) {
      this._logObj.decorators = e2;
    }
    get time() {
      return this._logObj.time;
    }
    get timestamp() {
      return this._logObj.timestamp;
    }
    get clear() {
      return this._logObj.clear;
    }
    get margin() {
      var e2;
      return (e2 = this._logObj.margin) !== null && e2 !== void 0 ? e2 : { top: 0, bottom: 0 };
    }
    get temp() {
      return this._logObj.temp;
    }
    get as() {
      return this._logObj.as;
    }
  }
  SLog.TYPE_LOG = "log", SLog.TYPE_INFO = "info", SLog.TYPE_WARN = "warn", SLog.TYPE_ERROR = "error", SLog.TYPE_VERBOSE = "verbose", SLog.TYPE_VERBOSER = "verboser", SLog.TYPE_DECORATOR = "decorator", SLog.TYPE_SUMMARY = "summary", SLog.TYPE_CHILD_PROCESS = "child_process", SLog.TYPES = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_VERBOSER, SLog.TYPE_SUMMARY, SLog.TYPE_DECORATOR, SLog.TYPE_CHILD_PROCESS], SLog.PRESET_SILENT = [], SLog.PRESET_DEFAULT = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_SUMMARY, SLog.TYPE_DECORATOR], SLog.PRESET_WARN = [SLog.TYPE_WARN, SLog.TYPE_ERROR], SLog.PRESET_ERROR = [SLog.TYPE_ERROR], SLog.PRESET_VERBOSE = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_DECORATOR, SLog.TYPE_SUMMARY], SLog.PRESET_VERBOSER = [SLog.TYPE_LOG, SLog.TYPE_INFO, SLog.TYPE_WARN, SLog.TYPE_ERROR, SLog.TYPE_VERBOSE, SLog.TYPE_VERBOSER, SLog.TYPE_DECORATOR, SLog.TYPE_SUMMARY], SLog.PRESETS = ["silent", "default", "warn", "error", "verbose", "verboser"], SLog._appliedFilters = {}, SLog._defaultLogObj = {};
  var __awaiter$i = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SEventEmitter extends SClass {
    constructor(e2 = {}) {
      super(__deepMerge$7({ eventEmitter: { emitter: void 0, asyncStart: false, defaultCallTime: {}, bufferTimeout: 1e3, bufferedEvents: [], forceObject: ["log"], defaults: {}, castByEvent: { log: SLog }, bind: void 0 } }, e2 || {})), this._asyncStarted = false, this._buffer = [], this._eventsStacks = {}, this._onStackById = {};
    }
    static get global() {
      return this._globalInstance || (this._globalInstance = new SEventEmitter({ metas: { id: "sugarEventSPromise" } })), this._globalInstance;
    }
    static pipe(e2, s2, t2) {
      const l2 = Object.assign({ events: "*", prefixEvent: false, prefixValue: void 0, stripAnsi: false, trim: true, keepLineBreak: true, overrideEmitter: "bind", processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0 }, t2 != null ? t2 : {});
      if (!e2 || !e2.on || typeof e2.on != "function")
        return e2;
      e2.on(l2.events || "*", (a2, o2) => __awaiter$i(this, void 0, void 0, function* () {
        var e3, t3, r2, n2;
        if (o2 && (o2.id = (t3 = (e3 = o2.id) !== null && e3 !== void 0 ? e3 : (t3 = o2.emitter.metas) === null || t3 === void 0 ? void 0 : t3.id) !== null && t3 !== void 0 ? t3 : uniqid(), o2.color = (r2 = (t3 = o2.color) !== null && t3 !== void 0 ? t3 : (r2 = o2.emitter.metas) === null || r2 === void 0 ? void 0 : r2.color) !== null && r2 !== void 0 ? r2 : getColorFor(o2.id), (!l2.exclude || l2.exclude.indexOf(o2.event) === -1) && (!l2.filter || l2.filter(a2, o2)) && (l2.stripAnsi && (a2 && a2.value && typeof a2.value == "string" ? a2.value = stripAnsi(a2.value) : typeof a2 == "string" && (a2 = stripAnsi(a2))), l2.trim && (a2 && a2.value && typeof a2.value == "string" ? a2.value = a2.value.trim() : typeof a2 == "string" && (a2 = a2.trim())), l2.keepLineBreak === false && (a2 && a2.value && typeof a2.value == "string" ? a2.value = a2.value.replace(/\r?\n|\r/g, "") : typeof a2 == "string" && (a2 = a2.replace(/\r?\n|\r/g, ""))), l2.processor && (n2 = l2.processor(a2, o2), Array.isArray(n2) && n2.length === 2 ? (a2 = n2[0], o2 = n2[1]) : typeof n2 == "object" && n2.value !== void 0 && n2.metas !== void 0 ? (a2 = n2.value, o2 = n2.metas) : a2 = n2), l2.prefixValue && (a2 && a2.value && typeof a2.value == "string" ? a2.value = "" + l2.prefixValue + a2.value : typeof a2 == "string" && (a2 = "" + l2.prefixValue + a2)), o2 && o2.event))) {
          let e4 = o2.event;
          o2.emitter || (o2.emitter = this), l2.prefixEvent && (e4 = typeof l2.prefixEvent == "string" ? l2.prefixEvent + "." + o2.event : "" + o2.name, o2.event = e4);
          const i2 = Object.assign(Object.assign({}, o2), { level: ((n2 = o2 == null ? void 0 : o2.level) !== null && n2 !== void 0 ? n2 : 0) + 1 });
          s2 instanceof SEventEmitter && (l2.overrideEmitter === "bind" && s2.eventEmitterSettings.bind ? i2.emitter = s2.eventEmitterSettings.bind : l2.overrideEmitter === true && (i2.emitter = s2)), s2 === process && isChildProcess() && process.send ? (a2.value && a2.value instanceof Error && (a2.value = fn$3(a2.value)), process.send({ value: a2, metas: i2 })) : s2.emit(o2.event, a2, i2);
        }
      }));
    }
    get eventEmitterSettings() {
      return this._settings.eventEmitter;
    }
    pipe(e2, t2) {
      return SEventEmitter.pipe(e2, this, t2), e2;
    }
    pipeErrors(e2, t2) {
      return SEventEmitter.pipe(e2, this, Object.assign(Object.assign({}, t2), { events: "error" })), e2;
    }
    pipeFrom(e2, t2) {
      return this.pipe(e2, t2);
    }
    pipeTo(e2, t2) {
      return SEventEmitter.pipe(this, e2, t2), this;
    }
    start() {
      this.eventEmitterSettings.asyncStart && (this._asyncStarted = true, this._processBuffer());
    }
    _createMetas(e2, t2 = {}) {
      return __deepMerge$7({ event: e2, name: e2, emitter: (e2 = (e2 = this.eventEmitterSettings.bind) !== null && e2 !== void 0 ? e2 : t2 == null ? void 0 : t2.emitter) !== null && e2 !== void 0 ? e2 : this, originalEmitter: (e2 = t2 == null ? void 0 : t2.originalEmitter) !== null && e2 !== void 0 ? e2 : this, time: Date.now(), level: 0 }, t2 != null ? t2 : {});
    }
    emit(a2, o2, s2) {
      return new Promise((n2, i2) => __awaiter$i(this, void 0, void 0, function* () {
        let e2 = this._createMetas(a2, s2);
        var t2 = !e2.level;
        plainObject$7(o2) && Object.keys(this.eventEmitterSettings.defaults).forEach((e3) => {
          var t3;
          const r3 = e3.split(",").map((e4) => e4.trim());
          r3.indexOf(a2) === -1 && r3.indexOf("*") === -1 || (o2 = __deepMerge$7(o2, (t3 = this.eventEmitterSettings.defaults) === null || t3 === void 0 ? void 0 : t3[e3]));
        });
        const r2 = this.eventEmitterSettings.castByEvent[a2];
        !r2 || !cls(r2) || o2 instanceof r2 || o2._sEventEmitterPreprocessed || (o2 = new r2(o2)), a2 === "ask" && t2 && (e2.askId = uniqid()), this._asyncStarted || !this.eventEmitterSettings.asyncStart ? this._emit({ event: a2, value: o2, metas: e2, resolve: n2, reject: i2 }) : this._buffer.push({ event: a2, value: o2, metas: e2, resolve: n2, reject: i2 });
      }));
    }
    _emit(r2) {
      return __awaiter$i(this, void 0, void 0, function* () {
        var e2;
        r2.event === "ask" ? (this.constructor.global.on(`answer.${r2.metas.askId}:1`, (e3, t2) => {
          r2.resolve(e3);
        }), this._emitEvents(r2.event, r2.value, r2.metas)) : (e2 = yield this._emitEvents(r2.event, r2.value, Object.assign({}, r2.metas)), r2.resolve(e2));
      });
    }
    _registerNewEventsStacks(e2) {
      (e2 = typeof e2 == "string" ? e2.split(",").map((e3) => e3.trim()) : e2).forEach((e3) => {
        this._eventsStacks[e3] || (this._eventsStacks[e3] = { buffer: [], callStack: [] });
      });
    }
    _registerCallbackInEventStack(e2, t2, r2 = {}) {
      (r2 = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, r2)).id && (this._onStackById[r2.id] || (this._onStackById[r2.id] = []), this._onStackById[r2.id].push({ event: e2, callback: t2, settings: r2 })), this._eventsStacks[e2] || this._registerNewEventsStacks(e2);
      const n2 = this._eventsStacks[e2];
      let i2 = r2.callNumber;
      return i2 === void 0 && this.eventEmitterSettings.defaultCallTime[e2] !== void 0 ? i2 = this.eventEmitterSettings.defaultCallTime[e2] : i2 === void 0 && (i2 = -1), typeof t2 == "function" && n2.callStack.push({ callback: t2, callNumber: i2, filter: r2.filter, processor: r2.processor, called: 0 }), this._processBuffer(), this;
    }
    _processBuffer() {
      0 < this._buffer.length && setTimeout(() => {
        this._buffer = this._buffer.filter((e2) => (this._emit(e2), false));
      }, this.eventEmitterSettings.bufferTimeout);
    }
    _emitEventStack(a2, o2, s2) {
      return __awaiter$i(this, void 0, void 0, function* () {
        let t2 = o2;
        if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
          return t2;
        this._eventsStacks[a2] || this._registerNewEventsStacks(a2);
        let r2 = [];
        var n2, e2 = this._eventsStacks[a2];
        e2 && e2.callStack && (r2 = [...r2, ...e2.callStack]), Object.keys(this._eventsStacks).forEach((e3) => e3 === a2 ? t2 : void (minimatch_1(a2, e3) && this._eventsStacks[e3] !== void 0 && (r2 = [...r2, ...this._eventsStacks[e3].callStack]))), r2.map((e3) => e3.called++), r2 = r2.filter((e3) => e3.callNumber === -1 || e3.called <= e3.callNumber);
        for (let e3 = 0; e3 < r2.length; e3++) {
          const i2 = r2[e3];
          if (!i2.callback)
            return t2;
          i2.filter && !i2.filter(t2, s2) || (i2.processor && (n2 = i2.processor(t2, s2), Array.isArray(n2) && n2.length === 2 ? (t2 = n2[0], s2 = n2[1]) : typeof n2 == "object" && n2.value !== void 0 && n2.metas !== void 0 ? (t2 = n2.value, s2 = n2.metas) : t2 = n2), (n2 = yield i2.callback(t2, s2, s2 != null && s2.askId ? (e4) => {
            this.constructor.global.emit("answer." + s2.askId, e4, s2);
          } : void 0)) !== void 0 && (t2 = n2));
        }
        return t2;
      });
    }
    _emitEvents(n2, i2, a2) {
      return new Promise((e2, t2) => __awaiter$i(this, void 0, void 0, function* () {
        if (!n2)
          return this;
        typeof n2 == "string" && (n2 = n2.split(",").map((e3) => e3.trim()));
        let t3 = i2;
        for (let e3 = 0; e3 < n2.length; e3++) {
          var r2 = yield this._emitEventStack(n2[e3], t3, a2);
          r2 !== void 0 && (t3 = r2);
        }
        e2(t3);
      }));
    }
    on(e2, n2, t2) {
      const i2 = __deepMerge$7({ filter: void 0, processor: void 0, id: void 0 }, t2);
      return (e2 = typeof e2 == "string" ? e2.split(",").map((e3) => e3.trim()) : e2).forEach((e3) => {
        var t3 = e3.split(":");
        let r2 = -1;
        t3.length === 2 && (e3 = t3[0], r2 = parseInt(t3[1])), this._registerCallbackInEventStack(e3, n2, { callNumber: r2, filter: i2.filter, processor: i2.processor, id: i2.id });
      }), this;
    }
    off(e2, t2) {
      if (!t2)
        return this._eventsStacks[e2] ? delete this._eventsStacks[e2] : this._onStackById[e2] && (this._onStackById[e2].forEach((e3) => {
          this.off(e3.event, e3.callback);
        }), delete this._onStackById[e2]), this;
      const r2 = this._eventsStacks[e2];
      return r2 && (r2.callStack = r2.callStack.filter((e3) => e3.callback !== t2), this._eventsStacks[e2] = r2), this;
    }
    destroy() {
      this._eventsStacks = {};
    }
  }
  SEventEmitter.usableAsMixin = true;
  const fn = function(t2, e2 = {}) {
    let n2 = (e2 = Object.assign({ during: -1 }, e2)).during || -1;
    try {
      const i2 = Proxy.revocable(t2, { get(e3, t3, r2) {
        return t3 === "then" ? e3 : (0 < n2 ? n2-- : n2 === 0 && i2.revoke(), Reflect.get(...arguments));
      } });
      return i2.proxy.restorePromiseBehavior = () => (i2.revoke(), t2), i2.proxy;
    } catch (e3) {
      return t2;
    }
  };
  var __awaiter$h = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SPromise extends SClass.extends(Promise) {
    constructor(e2 = {}, t2) {
      let r2, i2 = {};
      if (super(__deepMerge$7({ promise: { treatCancelAs: "resolve", destroyTimeout: 1, preventRejectOnThrow: true, emitErrorEventOnThrow: true, resolveAtResolveEvent: false, rejectAtRejectEvent: false, proxies: { resolve: [], reject: [] } } }, typeof e2 == "object" ? e2 : {}, t2 != null ? t2 : {}), (r3, n2) => {
        i2.resolve = r3, new Promise((e3, t3) => {
          i2.reject = (...e4) => {
            t3(...e4), (this.promiseSettings.preventRejectOnThrow ? r3 : n2)(...e4);
          };
        }).catch((e3) => {
          this.emit("catch", e3);
        });
      }), this._promiseState = "pending", this._eventEmitter = new SEventEmitter(__deepMerge$7({ metas: Object.assign({}, this.metas), eventEmitter: {} }, this._settings)), this.expose(this._eventEmitter, { as: "eventEmitter", props: ["on", "off", "emit", "pipe", "pipeErrors", "pipeFrom", "pipeTo", "eventEmitterSettings"] }), this._resolvers = i2, this._settings.promise.destroyTimeout !== -1 && this.on("finally", (e3, t3) => {
        setTimeout(() => {
          this.destroy();
        }, this._settings.promise.destroyTimeout);
      }), r2 = typeof e2 == "function" ? e2 : null, r2) {
        const n2 = {};
        getMethods(this).forEach((e3) => {
          e3.slice(0, 1) !== "_" && (n2[e3] = this[e3].bind(this));
        }), __awaiter$h(this, void 0, void 0, function* () {
          yield wait$2(0);
          try {
            yield r2(n2);
          } catch (e3) {
            this.promiseSettings.emitErrorEventOnThrow && this.emit("log", { type: SLog.TYPE_ERROR, value: e3 }), this.reject(e3);
          }
        });
      }
      this.promiseSettings.resolveAtResolveEvent && this.on("resolve", (e3, t3) => {
        this.resolve(e3);
      }), this.promiseSettings.rejectAtRejectEvent && this.on("reject", (e3, t3) => {
        this.reject(e3);
      });
    }
    static queue(l2, c2, u2) {
      return new SPromise(({ resolve: o2, reject: s2 }) => __awaiter$h(this, void 0, void 0, function* () {
        const a2 = {};
        !function i2() {
          return __awaiter$h(this, void 0, void 0, function* () {
            var e2 = Object.keys(l2)[0];
            let t2 = l2[e2];
            typeof t2 == "function" && (t2 = t2());
            try {
              delete l2[e2], c2 && (yield c2(e2, t2));
              var r2, n2 = yield t2;
              a2[e2] = n2, !u2 || (r2 = yield u2(e2, result)) !== void 0 && (result[e2] = r2), Object.keys(l2).length ? i2() : o2(a2);
            } catch (e3) {
              s2(t2);
            }
          });
        }();
      }));
    }
    static treatAsValue(e2, t2 = {}) {
      return fn(e2, t2);
    }
    get promiseSettings() {
      return this._settings.promise;
    }
    static get [Symbol.species]() {
      return Promise;
    }
    get [Symbol.toStringTag]() {
      return "SPromise";
    }
    get promiseState() {
      return this._promiseState;
    }
    treatAsValue(e2 = {}) {
      return fn(this, e2);
    }
    registerProxy(e2, t2) {
      const r2 = e2.split(",").map((e3) => e3.trim());
      r2.forEach((e3) => {
        this._settings.promise.proxies[e3].push(t2);
      });
    }
    is(e2) {
      const t2 = e2.split(",").map((e3) => e3.trim());
      return t2.indexOf(this._promiseState) !== -1;
    }
    isPending() {
      return this._promiseState === "pending";
    }
    isResolved() {
      return this._promiseState === "resolved";
    }
    isRejected() {
      return this._promiseState === "rejected";
    }
    isCanceled() {
      return this._promiseState === "canceled";
    }
    isDestroyed() {
      return this._promiseState === "destroyed";
    }
    resolve(e2, t2 = "resolve,finally") {
      return this._resolve(e2, t2);
    }
    _resolve(n2, i2 = "resolve,finally") {
      return __awaiter$h(this, void 0, void 0, function* () {
        if (this._promiseState !== "destroyed") {
          this._promiseState = "resolved";
          var t2 = i2.split(",").map((e2) => e2.trim());
          for (let e2 = 0; e2 < t2.length; e2++) {
            var r2 = t2[e2];
            n2 = yield this.eventEmitter.emit(r2, n2);
          }
          for (const e2 of this._settings.promise.proxies.resolve || [])
            n2 = yield e2(n2);
          return this._resolvers.resolve(n2), n2;
        }
      });
    }
    reject(e2, t2 = "catch,reject,finally") {
      return this._reject(e2, t2);
    }
    _reject(n2, i2 = "catch,reject,finally") {
      return __awaiter$h(this, void 0, void 0, function* () {
        if (this._promiseState !== "destroyed") {
          this._promiseState = "rejected";
          var t2 = i2.split(",").map((e2) => e2.trim());
          for (let e2 = 0; e2 < t2.length; e2++) {
            var r2 = t2[e2];
            n2 = yield this.eventEmitter.emit(r2, n2);
          }
          for (const e2 of this._settings.promise.proxies.reject || [])
            n2 = yield e2(n2);
          return this._resolvers.reject(n2), n2;
        }
      });
    }
    cancel(e2, t2 = "cancel,finally") {
      return this._cancel(e2, t2);
    }
    _cancel(n2, i2 = "cancel,finally") {
      if (this._promiseState !== "destroyed")
        return new Promise((e2, t2) => __awaiter$h(this, void 0, void 0, function* () {
          this._promiseState = "canceled";
          var t3 = i2.split(",").map((e3) => e3.trim());
          for (let e3 = 0; e3 < t3.length; e3++) {
            var r2 = t3[e3];
            n2 = yield this.eventEmitter.emit(r2, n2);
          }
          this._settings.promise.treatCancelAs === "reject" ? this._resolvers.reject(n2) : this._resolvers.resolve(n2), e2(n2);
        }));
    }
    catch(...e2) {
      return super.catch(...e2), this.on("catch", ...e2);
    }
    finally(...e2) {
      return this.on("finally", ...e2);
    }
    destroy() {
      this._eventEmitter.destroy(), this._promiseState = "destroyed";
    }
  }
  function inViewportStatusChange(n2, e2) {
    let i2 = "out", t2, a2 = false;
    return e2 = Object.assign({ offset: "10px" }, e2 != null ? e2 : {}), new SPromise(({ emit: r2 }) => {
      t2 = new IntersectionObserver((e3, t3) => {
        e3.length && (e3 = e3[0], a2 = 0 < e3.intersectionRatio, a2 || i2 !== "in" ? a2 && i2 === "out" && (i2 = "in", r2("enter", n2)) : (i2 = "out", r2("leave", n2)));
      }, { root: null, rootMargin: e2.offset, threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] }), t2.observe(n2);
    }, { id: "inViewportStatisChange" }).on("cancel", () => {
      var e3;
      (e3 = t2.disconnect) !== null && e3 !== void 0 && e3.call(t2);
    });
  }
  function convert$1(e2, t2 = "ms") {
    let r2 = e2;
    if (typeof e2 == "string") {
      const i2 = parseFloat(e2);
      var n2 = i2.toString().length, n2 = e2.slice(n2);
      n2 === "ms" || n2 === "millisecond" || n2 === "milliseconds" ? r2 = i2 : n2 === "s" || n2 === "second" || n2 === "seconds" ? r2 = 1e3 * i2 : n2 === "m" || n2 === "minute" || n2 === "minutes" ? r2 = 60 * i2 * 1e3 : n2 === "h" || n2 === "hour" || n2 === "hours" ? r2 = 60 * i2 * 60 * 1e3 : n2 === "d" || n2 === "day" || n2 === "days" ? r2 = 24 * i2 * 60 * 60 * 1e3 : n2 === "w" || n2 === "week" || n2 === "weeks" ? r2 = 7 * i2 * 24 * 60 * 60 * 1e3 : n2 === "month" || n2 === "months" ? r2 = 31 * i2 * 24 * 60 * 60 * 1e3 : n2 !== "y" && n2 !== "year" && n2 !== "years" || (r2 = 365 * i2 * 24 * 60 * 60 * 1e3);
    }
    switch (t2) {
      case "ms":
      case "millisecond":
      case "milliseconds":
        return r2;
      case "s":
      case "second":
      case "seconds":
        return r2 / 1e3;
      case "m":
      case "minute":
      case "minutes":
        return r2 / 1e3 / 60;
      case "h":
      case "hour":
      case "hours":
        return r2 / 1e3 / 60 / 60;
      case "d":
      case "day":
      case "days":
        return r2 / 1e3 / 60 / 60 / 24;
      case "w":
      case "week":
      case "weeks":
        return r2 / 1e3 / 60 / 60 / 24 / 7;
      case "month":
      case "months":
        return r2 / 1e3 / 60 / 60 / 24 / 31;
      case "y":
      case "year":
      case "years":
        return r2 / 1e3 / 60 / 60 / 24 / 365;
      default:
        throw new Error(`You try to convert "${e2}" to "${t2}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
    }
  }
  function formatDuration(e2) {
    if (e2 === 1 / 0)
      return "...";
    if (e2 < 1e3)
      return e2 + "ms";
    if (e2 < 6e4) {
      var t2 = (e2 / 1e3).toFixed(0), r2 = (e2 - 1e3 * t2).toFixed(0);
      return t2 + "s" + (0 < r2 ? r2 + "ms" : "");
    }
    if (e2 < 36e5) {
      const i3 = Math.floor(e2 / 1e3 / 60);
      var n2 = ((e2 - 1e3 * i3 * 60) / 1e3).toFixed(0);
      return i3 + "m" + (0 < n2 ? n2 + "s" : "");
    }
    n2 = Math.floor(e2 / 1e3 / 60 / 60);
    const i2 = ((e2 - 1e3 * n2 * 60 * 60) / 1e3 / 60).toFixed(0);
    return n2 + "h" + (0 < i2 ? i2 + "m" : "");
  }
  convert$1.MILLISECOND = "ms", convert$1.SECOND = "s", convert$1.MINUTE = "m", convert$1.HOUR = "h", convert$1.DAY = "d", convert$1.WEEK = "w", convert$1.MONTH = "month", convert$1.YEAR = "y";
  class SDuration {
    constructor(e2 = {}) {
      this._settings = {}, this.startTime = null, this.endTime = null, this.duration = null, this._settings = __deepMerge$7({ format: "s", suffix: true }, e2), this.start();
    }
    toObject(e2 = {}) {
      e2 = __deepMerge$7(this._settings, e2), this.endTime && this.startTime || this.end();
      var t2 = this.endTime - this.startTime, e2 = convert$1(this.duration = t2, e2.format), t2 = formatDuration(t2);
      return { startTime: this.startTime || -1, endTime: this.endTime || -1, duration: this.duration || -1, convertedDuration: e2, formatedDuration: t2 };
    }
    start(e2 = null) {
      return this.startTime = e2 || Date.now(), this;
    }
    end(e2 = {}) {
      return e2 = __deepMerge$7(this._settings, e2), this.endTime = Date.now(), this.toObject(e2);
    }
  }
  function whenInViewport(n2, i2 = {}) {
    return i2 = Object.assign({ offset: "10px" }, i2), new Promise((r2) => {
      var e2 = { root: null, rootMargin: i2.offset, threshold: 1 };
      const t2 = new IntersectionObserver(function(e3, t3) {
        e3.forEach((e4) => {
          0 < e4.intersectionRatio && ((e4 = t3.disconnect) !== null && e4 !== void 0 && e4.call(t3), r2(n2));
        });
      }, e2);
      t2.observe(n2);
    });
  }
  var __awaiter$g = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  function whenNearViewport(i2, e2 = {}) {
    e2 = Object.assign({ offset: `${window.innerHeight}px ${window.innerWidth}px` }, e2);
    let a2, o2;
    return new Promise((n2) => __awaiter$g(this, void 0, void 0, function* () {
      const t2 = { root: null, rootMargin: e2.offset, threshold: 1 };
      function r2(e3, t3) {
        e3.forEach((e4) => {
          0 < e4.intersectionRatio && ((e4 = t3.disconnect) !== null && e4 !== void 0 && e4.call(t3), n2(i2));
        });
      }
      a2 = new IntersectionObserver(r2, t2), a2.observe(i2), window.addEventListener("resize", (e3) => {
        clearTimeout(o2), o2 = setTimeout(() => {
          var e4;
          (e4 = a2.disconnect) !== null && e4 !== void 0 && e4.call(a2), t2.rootMargin = `${window.innerHeight}px ${window.innerWidth}px`, a2 = new IntersectionObserver(r2, t2), a2.observe(i2);
        }, 500);
      });
    }));
  }
  var __awaiter$f = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  }, s$2, t, l, o;
  class SConductor extends SClass {
    constructor(e2) {
      super(__deepMerge$7({ conductor: { idleInterval: 500, logTimeout: 2e3, log: false } }, e2 != null ? e2 : {})), this._tasksStack = {}, this._runningTasksStack = {}, this._logTimeout = null, this._idleInterval = null, this._startTime = Date.now(), this._idleInterval = setInterval(() => {
        this._checkIdle();
      }, this.conductorSettings.idleInterval);
    }
    static get defaultInstance() {
      return this._defaultInstance || (this._defaultInstance = new SConductor({ conductor: this._defaultInstanceSettings }), this._defaultInstance);
    }
    static when(e2, t2, r2 = null) {
      return this.defaultInstance.when(e2, t2, r2);
    }
    static setup(e2) {
      if (this._defaultInstance)
        throw new Error('Sorry but you need to call the "SConductor.setup" method before all other static methods like "when"');
      this._defaultInstanceSettings = e2;
    }
    get conductorSettings() {
      return this._settings.conductor;
    }
    _checkIdle() {
      if (!Object.keys(this._runningTasksStack).length) {
        let e2;
        for (var [t2, r2] of Object.entries(this._tasksStack))
          if (r2.times.includes("idle")) {
            e2 = r2;
            break;
          }
        e2 ? this._executeTask(e2) : !this._logTimeout && this.conductorSettings.log && (this._logTimeout = setTimeout(() => {
          console.log(`[SConductor] The conductor "${this.metas.id}" has been executed tasks during ` + formatDuration(Date.now() - this._startTime - this.conductorSettings.logTimeout));
        }, this.conductorSettings.logTimeout));
      }
    }
    _executeTask(t2) {
      return __awaiter$f(this, void 0, void 0, function* () {
        this._runningTasksStack[t2.id] = t2, clearTimeout(this._logTimeout), t2.watchers.forEach((e3) => {
          var t3;
          (t3 = e3.cancel) !== null && t3 !== void 0 && t3.call(e3);
        });
        const e2 = new SDuration();
        return yield t2.task(), t2 = Object.assign(Object.assign({ resolved: true }, t2), e2.end()), delete this._tasksStack[t2.id], delete this._runningTasksStack[t2.id], t2.resolve(t2), clearInterval(this._idleInterval), setTimeout(() => {
          this._checkIdle(), this._idleInterval = setInterval(() => {
            this._checkIdle();
          }, this.conductorSettings.idleTimeout);
        }, 100), t2;
      });
    }
    when(r2, n2, i2) {
      return new SPromise(({ resolve: e2 }) => __awaiter$f(this, void 0, void 0, function* () {
        Array.isArray(n2) || (n2 = n2.split(",").map((e3) => e3.trim()));
        const t2 = { id: uniqid(), registerTime: Date.now(), times: n2, $elm: r2, task: i2, watchers: [], resolve: e2 };
        if (this._tasksStack[t2.id] = t2, n2.forEach((e3) => {
          switch (e3) {
            case "inViewport":
              t2.watchers.push(whenInViewport(r2));
              break;
            case "nearViewport":
              t2.watchers.push(whenNearViewport(r2));
              break;
            case "idle":
              t2.watchers.push(new SPromise(() => {
              }));
          }
        }), !n2.length || n2.includes("direct") || n2.includes("directly"))
          return this._executeTask(t2);
        yield Promise.race(t2.watchers), this._executeTask(t2);
      }));
    }
  }
  SConductor._defaultInstanceSettings = {};
  class SComponentDefaultInterface extends SInterface {
    static get _definition() {
      return { id: { type: "String", physical: true }, mounted: { type: "Boolean", default: false, physical: true }, mountWhen: { type: "String", values: ["directly", "inViewport"], default: "directly" }, adoptStyle: { type: "Boolean", default: true, physical: true }, bare: { type: "Boolean", default: false, physical: true } };
    }
  }
  class SComponent extends SClass {
    constructor(e2, t2, r2 = {}) {
      super(__deepMerge$7({ componentUtils: {} }, r2)), this.state = "pending", this._isInViewport = false, this.node = e2, this._props = t2, this.inViewportStatusChange.on("enter", () => {
        this.node.tagName.toLowerCase() === "ck-blob" && console.log("IN"), this._isInViewport = true;
      }).on("leave", () => {
        this._isInViewport = false;
      });
      let n2 = ((t2 = class extends SInterface {
      }).definition = {}, t2);
      n2.definition = Object.assign(Object.assign({}, Object.assign({}, SComponentDefaultInterface.definition)), (t2 = (t2 = this.componentUtilsSettings.interface) === null || t2 === void 0 ? void 0 : t2.definition) !== null && t2 !== void 0 ? t2 : {}), this.InterfaceToApply = n2;
      t2 = this.componentUtilsSettings.style;
      this.injectStyle(t2 != null ? t2 : "");
    }
    get name() {
      var e2;
      return (e2 = this.componentUtilsSettings.name) !== null && e2 !== void 0 ? e2 : this.node.tagName.toLowerCase();
    }
    static setDefaultProps(e2, t2) {
      (e2 = Array.isArray(e2) ? e2 : [e2]).forEach((e3) => {
        this._defaultProps[e3] = Object.assign(Object.assign({}, (e3 = this._defaultProps[e3]) !== null && e3 !== void 0 ? e3 : {}), t2);
      });
    }
    static getDefaultProps(e2) {
      return (e2 = this._defaultProps[e2]) !== null && e2 !== void 0 ? e2 : {};
    }
    get componentUtilsSettings() {
      return this._settings.componentUtils;
    }
    get inViewportStatusChange() {
      return this._inViewportStatusChangePromise || (this._inViewportStatusChangePromise = inViewportStatusChange(this.node), this._inViewportStatusChangePromise);
    }
    waitAndExecute(e2) {
      return SConductor.when(this.node, this.props.mountWhen, e2);
    }
    adoptStyleInShadowRoot(e2, t2) {
      return adoptStyleInShadowRoot(e2, t2);
    }
    get props() {
      if (this._finalProps)
        return this._finalProps;
      const n2 = this._props;
      let i2 = {};
      n2.constructor.name === "NamedNodeMap" ? Object.keys(n2).forEach((e2) => {
        var t2;
        let r2;
        ((t2 = n2[e2]) === null || t2 === void 0 ? void 0 : t2.nodeValue) !== void 0 && (r2 = n2[e2].nodeValue === "" || n2[e2].nodeValue), r2 && (i2[camelCase((t2 = (t2 = n2[e2]) === null || t2 === void 0 ? void 0 : t2.name) !== null && t2 !== void 0 ? t2 : e2)] = autoCast$1(r2));
      }) : (j, i2 = n2), this._finalProps = __deepMerge$7(this.defaultProps, this.InterfaceToApply.apply(i2, { descriptor: { defaults: false } }));
      const a2 = this;
      return this._finalProps = new Proxy(this._finalProps, { get(e2, t2, r2) {
        return e2[t2];
      }, set(e2, t2, r2) {
        var n3 = a2.InterfaceToApply.definition[t2];
        return n3 != null && n3.physical && (r2 === false || r2 == null ? a2.node.removeAttribute(dashCase(t2)) : a2.node.setAttribute(dashCase(t2), String(r2))), e2[t2] = r2, true;
      } }), Object.keys(this._finalProps).forEach((e2) => {
        this._finalProps[e2] = this._finalProps[e2];
      }), this._finalProps;
    }
    get defaultProps() {
      var e2;
      return this._defaultProps ? Object.assign({}, this._defaultProps) : (this._defaultProps = Object.assign({}, __deepMerge$7(this.InterfaceToApply.defaults(), (e2 = this.componentUtilsSettings.defaultProps) !== null && e2 !== void 0 ? e2 : {}, (e2 = this.constructor._defaultProps["*"]) !== null && e2 !== void 0 ? e2 : {}, (e2 = this.constructor._defaultProps[this.name]) !== null && e2 !== void 0 ? e2 : {})), this._defaultProps);
    }
    static getFinalInterface(e2) {
      class t2 extends SInterface {
      }
      return t2.definition = SComponentDefaultInterface.definition, e2 && (t2.definition = Object.assign(Object.assign({}, SComponentDefaultInterface.definition), e2.definition)), t2;
    }
    injectStyle(e2, t2 = this.tagName) {
      this.constructor._injectedStyles.indexOf(t2) === -1 && (this.constructor._injectedStyles.push(t2), injectStyle(e2, t2));
    }
    exposeApi(n2, i2 = this.node) {
      setTimeout(() => {
        let r2 = this.node;
        Object.keys(n2).forEach((e2) => {
          var t2 = n2[e2].bind(i2);
          r2[e2] = t2;
        });
      });
    }
    className(e2 = "", t2 = "") {
      let r2 = e2.split(" ").map((e3) => "" + this.node.tagName.toLowerCase() + (e3 && !e3.match(/^__/) ? "-" : "") + e3).join(" ");
      return t2 && !this.props.bare && (r2 += " " + t2), r2;
    }
    isMounted() {
      var e2;
      return (e2 = this.node) === null || e2 === void 0 ? void 0 : e2.hasAttribute("mounted");
    }
    isInViewport() {
      return this._isInViewport;
    }
  }
  SComponent._defaultProps = {}, SComponent._injectedStyles = [];
  const t$1 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, e$3 = Symbol(), n$3 = new Map();
  class s$3 {
    constructor(e2, t2) {
      if (this._$cssResult$ = true, t2 !== e$3)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = e2;
    }
    get styleSheet() {
      let e2 = n$3.get(this.cssText);
      return t$1 && e2 === void 0 && (n$3.set(this.cssText, e2 = new CSSStyleSheet()), e2.replaceSync(this.cssText)), e2;
    }
    toString() {
      return this.cssText;
    }
  }
  const o$3 = (e2) => new s$3(typeof e2 == "string" ? e2 : e2 + "", e$3), r$2 = (n2, ...e2) => {
    e2 = n2.length === 1 ? n2[0] : e2.reduce((e3, t2, r2) => e3 + (() => {
      if (t2._$cssResult$ === true)
        return t2.cssText;
      if (typeof t2 == "number")
        return t2;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t2 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })() + n2[r2 + 1], n2[0]);
    return new s$3(e2, e$3);
  }, i$2 = (n2, e2) => {
    t$1 ? n2.adoptedStyleSheets = e2.map((e3) => e3 instanceof CSSStyleSheet ? e3 : e3.styleSheet) : e2.forEach((e3) => {
      const t2 = document.createElement("style"), r2 = window.litNonce;
      r2 !== void 0 && t2.setAttribute("nonce", r2), t2.textContent = e3.cssText, n2.appendChild(t2);
    });
  }, S$1 = t$1 ? (e2) => e2 : (r2) => r2 instanceof CSSStyleSheet ? (() => {
    let e2 = "";
    for (const t2 of r2.cssRules)
      e2 += t2.cssText;
    return o$3(e2);
  })() : r2, e$2 = window.reactiveElementPolyfillSupport, r$1 = { toAttribute(e2, t2) {
    switch (t2) {
      case Boolean:
        e2 = e2 ? "" : null;
        break;
      case Object:
      case Array:
        e2 = e2 == null ? e2 : JSON.stringify(e2);
    }
    return e2;
  }, fromAttribute(e2, t2) {
    let r2 = e2;
    switch (t2) {
      case Boolean:
        r2 = e2 !== null;
        break;
      case Number:
        r2 = e2 === null ? null : Number(e2);
        break;
      case Object:
      case Array:
        try {
          r2 = JSON.parse(e2);
        } catch (e3) {
          r2 = null;
        }
    }
    return r2;
  } }, h$1 = (e2, t2) => t2 !== e2 && (t2 == t2 || e2 == e2), o$2 = { attribute: true, type: String, converter: r$1, reflect: false, hasChanged: h$1 };
  class n$2 extends HTMLElement {
    constructor() {
      super(), this._$Et = new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
    }
    static addInitializer(e2) {
      var t2;
      (t2 = this.l) !== null && t2 !== void 0 || (this.l = []), this.l.push(e2);
    }
    static get observedAttributes() {
      this.finalize();
      const r2 = [];
      return this.elementProperties.forEach((e2, t2) => {
        e2 = this._$Eh(t2, e2);
        e2 !== void 0 && (this._$Eu.set(e2, t2), r2.push(e2));
      }), r2;
    }
    static createProperty(e2, t2 = o$2) {
      var r2;
      t2.state && (t2.attribute = false), this.finalize(), this.elementProperties.set(e2, t2), t2.noAccessor || this.prototype.hasOwnProperty(e2) || (r2 = typeof e2 == "symbol" ? Symbol() : "__" + e2, (t2 = this.getPropertyDescriptor(e2, r2, t2)) !== void 0 && Object.defineProperty(this.prototype, e2, t2));
    }
    static getPropertyDescriptor(r2, n2, i2) {
      return { get() {
        return this[n2];
      }, set(e2) {
        var t2 = this[r2];
        this[n2] = e2, this.requestUpdate(r2, t2, i2);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(e2) {
      return this.elementProperties.get(e2) || o$2;
    }
    static finalize() {
      if (this.hasOwnProperty("finalized"))
        return false;
      this.finalized = true;
      const e2 = Object.getPrototypeOf(this);
      if (e2.finalize(), this.elementProperties = new Map(e2.elementProperties), this._$Eu = new Map(), this.hasOwnProperty("properties")) {
        const e3 = this.properties, t2 = [...Object.getOwnPropertyNames(e3), ...Object.getOwnPropertySymbols(e3)];
        for (const r2 of t2)
          this.createProperty(r2, e3[r2]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(e2) {
      const t2 = [];
      if (Array.isArray(e2)) {
        var r2 = new Set(e2.flat(1 / 0).reverse());
        for (const e3 of r2)
          t2.unshift(S$1(e3));
      } else
        e2 !== void 0 && t2.push(S$1(e2));
      return t2;
    }
    static _$Eh(e2, t2) {
      t2 = t2.attribute;
      return t2 === false ? void 0 : typeof t2 == "string" ? t2 : typeof e2 == "string" ? e2.toLowerCase() : void 0;
    }
    o() {
      var e2;
      this._$Ev = new Promise((e3) => this.enableUpdating = e3), this._$AL = new Map(), this._$Ep(), this.requestUpdate(), (e2 = this.constructor.l) === null || e2 === void 0 || e2.forEach((e3) => e3(this));
    }
    addController(e2) {
      var t2;
      ((t2 = this._$Em) !== null && t2 !== void 0 ? t2 : this._$Em = []).push(e2), this.renderRoot !== void 0 && this.isConnected && ((t2 = e2.hostConnected) === null || t2 === void 0 || t2.call(e2));
    }
    removeController(e2) {
      var t2;
      (t2 = this._$Em) === null || t2 === void 0 || t2.splice(this._$Em.indexOf(e2) >>> 0, 1);
    }
    _$Ep() {
      this.constructor.elementProperties.forEach((e2, t2) => {
        this.hasOwnProperty(t2) && (this._$Et.set(t2, this[t2]), delete this[t2]);
      });
    }
    createRenderRoot() {
      var e2 = (e2 = this.shadowRoot) !== null && e2 !== void 0 ? e2 : this.attachShadow(this.constructor.shadowRootOptions);
      return i$2(e2, this.constructor.elementStyles), e2;
    }
    connectedCallback() {
      var e2;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (e2 = this._$Em) === null || e2 === void 0 || e2.forEach((e3) => {
        var t2;
        return (t2 = e3.hostConnected) === null || t2 === void 0 ? void 0 : t2.call(e3);
      });
    }
    enableUpdating(e2) {
    }
    disconnectedCallback() {
      var e2;
      (e2 = this._$Em) === null || e2 === void 0 || e2.forEach((e3) => {
        var t2;
        return (t2 = e3.hostDisconnected) === null || t2 === void 0 ? void 0 : t2.call(e3);
      });
    }
    attributeChangedCallback(e2, t2, r2) {
      this._$AK(e2, r2);
    }
    _$Eg(e2, t2, r2 = o$2) {
      var n2, i2 = this.constructor._$Eh(e2, r2);
      i2 !== void 0 && r2.reflect === true && (r2 = ((n2 = (n2 = r2.converter) === null || n2 === void 0 ? void 0 : n2.toAttribute) !== null && n2 !== void 0 ? n2 : r$1.toAttribute)(t2, r2.type), this._$Ei = e2, r2 == null ? this.removeAttribute(i2) : this.setAttribute(i2, r2), this._$Ei = null);
    }
    _$AK(e2, t2) {
      const r2 = this.constructor, n2 = r2._$Eu.get(e2);
      if (n2 !== void 0 && this._$Ei !== n2) {
        const i2 = r2.getPropertyOptions(n2), a2 = i2.converter, o2 = (e2 = (e2 = a2 === null || a2 === void 0 ? void 0 : a2.fromAttribute) !== null && e2 !== void 0 ? e2 : typeof a2 == "function" ? a2 : null) !== null && e2 !== void 0 ? e2 : r$1.fromAttribute;
        this._$Ei = n2, this[n2] = o2(t2, i2.type), this._$Ei = null;
      }
    }
    requestUpdate(e2, t2, r2) {
      let n2 = true;
      e2 !== void 0 && (((r2 = r2 || this.constructor.getPropertyOptions(e2)).hasChanged || h$1)(this[e2], t2) ? (this._$AL.has(e2) || this._$AL.set(e2, t2), r2.reflect === true && this._$Ei !== e2 && (this._$ES === void 0 && (this._$ES = new Map()), this._$ES.set(e2, r2))) : n2 = false), !this.isUpdatePending && n2 && (this._$Ev = this._$EC());
    }
    _$EC() {
      return __async(this, null, function* () {
        this.isUpdatePending = true;
        try {
          yield this._$Ev;
        } catch (e3) {
          Promise.reject(e3);
        }
        var e2 = this.scheduleUpdate();
        return e2 != null && (yield e2), !this.isUpdatePending;
      });
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t2;
      if (this.isUpdatePending) {
        this.hasUpdated, this._$Et && (this._$Et.forEach((e3, t3) => this[t3] = e3), this._$Et = void 0);
        let e2 = false;
        var r2 = this._$AL;
        try {
          e2 = this.shouldUpdate(r2), e2 ? (this.willUpdate(r2), (t2 = this._$Em) === null || t2 === void 0 || t2.forEach((e3) => {
            var t3;
            return (t3 = e3.hostUpdate) === null || t3 === void 0 ? void 0 : t3.call(e3);
          }), this.update(r2)) : this._$EU();
        } catch (t3) {
          throw e2 = false, this._$EU(), t3;
        }
        e2 && this._$AE(r2);
      }
    }
    willUpdate(e2) {
    }
    _$AE(e2) {
      var t2;
      (t2 = this._$Em) === null || t2 === void 0 || t2.forEach((e3) => {
        var t3;
        return (t3 = e3.hostUpdated) === null || t3 === void 0 ? void 0 : t3.call(e3);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(e2)), this.updated(e2);
    }
    _$EU() {
      this._$AL = new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$Ev;
    }
    shouldUpdate(e2) {
      return true;
    }
    update(e2) {
      this._$ES !== void 0 && (this._$ES.forEach((e3, t2) => this._$Eg(t2, this[t2], e3)), this._$ES = void 0), this._$EU();
    }
    updated(e2) {
    }
    firstUpdated(e2) {
    }
  }
  n$2.finalized = true, n$2.elementProperties = new Map(), n$2.elementStyles = [], n$2.shadowRootOptions = { mode: "open" }, e$2 == null || e$2({ ReactiveElement: n$2 }), ((s$2 = globalThis.reactiveElementVersions) !== null && s$2 !== void 0 ? s$2 : globalThis.reactiveElementVersions = []).push("1.0.1");
  const i$1 = globalThis.trustedTypes, s$1 = i$1 ? i$1.createPolicy("lit-html", { createHTML: (e2) => e2 }) : void 0, e$1 = `lit$${(Math.random() + "").slice(9)}$`, o$1 = "?" + e$1, n$1 = `<${o$1}>`, l$1 = document, h = (e2 = "") => l$1.createComment(e2), r = (e2) => e2 === null || typeof e2 != "object" && typeof e2 != "function", d$3 = Array.isArray, u = (e2) => {
    return d$3(e2) || typeof (e2 === null || e2 === void 0 ? void 0 : e2[Symbol.iterator]) == "function";
  }, c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, a$2 = />/g, f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, _ = /'/g, m = /"/g, g = /^(?:script|style|textarea)$/i, $ = (r2) => (e2, ...t2) => ({ _$litType$: r2, strings: e2, values: t2 }), p = $(1), b = Symbol.for("lit-noChange"), T = Symbol.for("lit-nothing"), x = new WeakMap(), w = (e2, t2, r2) => {
    var n2;
    const i2 = (n2 = r2 == null ? void 0 : r2.renderBefore) !== null && n2 !== void 0 ? n2 : t2;
    let a2 = i2._$litPart$;
    if (a2 === void 0) {
      const e3 = (n2 = r2 == null ? void 0 : r2.renderBefore) !== null && n2 !== void 0 ? n2 : null;
      i2._$litPart$ = a2 = new N(t2.insertBefore(h(), e3), e3, void 0, r2 != null ? r2 : {});
    }
    return a2._$AI(e2), a2;
  }, A = l$1.createTreeWalker(l$1, 129, null, false), C = (a2, e2) => {
    const t2 = a2.length - 1, o2 = [];
    let s2, l2 = e2 === 2 ? "<svg>" : "", u2 = c;
    for (let i2 = 0; i2 < t2; i2++) {
      const d2 = a2[i2];
      let e3, t3, r2 = -1, n2 = 0;
      for (; n2 < d2.length && (u2.lastIndex = n2, t3 = u2.exec(d2), t3 !== null); )
        n2 = u2.lastIndex, u2 === c ? t3[1] === "!--" ? u2 = v : t3[1] !== void 0 ? u2 = a$2 : t3[2] !== void 0 ? (g.test(t3[2]) && (s2 = RegExp("</" + t3[2], "g")), u2 = f) : t3[3] !== void 0 && (u2 = f) : u2 === f ? t3[0] === ">" ? (u2 = s2 != null ? s2 : c, r2 = -1) : t3[1] === void 0 ? r2 = -2 : (r2 = u2.lastIndex - t3[2].length, e3 = t3[1], u2 = t3[3] === void 0 ? f : t3[3] === '"' ? m : _) : u2 === m || u2 === _ ? u2 = f : u2 === v || u2 === a$2 ? u2 = c : (u2 = f, s2 = void 0);
      var h2 = u2 === f && a2[i2 + 1].startsWith("/>") ? " " : "";
      l2 += u2 === c ? d2 + n$1 : 0 <= r2 ? (o2.push(e3), d2.slice(0, r2) + "$lit$" + d2.slice(r2) + e$1 + h2) : d2 + e$1 + (r2 === -2 ? (o2.push(void 0), i2) : h2);
    }
    e2 = l2 + (a2[t2] || "<?>") + (e2 === 2 ? "</svg>" : "");
    return [s$1 !== void 0 ? s$1.createHTML(e2) : e2, o2];
  };
  class P {
    constructor({ strings: t2, _$litType$: r2 }, e2) {
      let n2;
      this.parts = [];
      let i2 = 0, a2 = 0;
      const o2 = t2.length - 1, s2 = this.parts, [l2, c2] = C(t2, r2);
      if (this.el = P.createElement(l2, e2), A.currentNode = this.el.content, r2 === 2) {
        const t3 = this.el.content, u2 = t3.firstChild;
        u2.remove(), t3.append(...u2.childNodes);
      }
      for (; (n2 = A.nextNode()) !== null && s2.length < o2; ) {
        if (n2.nodeType === 1) {
          if (n2.hasAttributes()) {
            const t3 = [];
            for (const d2 of n2.getAttributeNames())
              if (d2.endsWith("$lit$") || d2.startsWith(e$1)) {
                const r3 = c2[a2++];
                if (t3.push(d2), r3 !== void 0) {
                  const t4 = n2.getAttribute(r3.toLowerCase() + "$lit$").split(e$1), p2 = /([.?@])?(.*)/.exec(r3);
                  s2.push({ type: 1, index: i2, name: p2[2], strings: t4, ctor: p2[1] === "." ? M : p2[1] === "?" ? k$2 : p2[1] === "@" ? H : S });
                } else
                  s2.push({ type: 6, index: i2 });
              }
            for (const f2 of t3)
              n2.removeAttribute(f2);
          }
          if (g.test(n2.tagName)) {
            const t3 = n2.textContent.split(e$1), r3 = t3.length - 1;
            if (0 < r3) {
              n2.textContent = i$1 ? i$1.emptyScript : "";
              for (let e3 = 0; e3 < r3; e3++)
                n2.append(t3[e3], h()), A.nextNode(), s2.push({ type: 2, index: ++i2 });
              n2.append(t3[r3], h());
            }
          }
        } else if (n2.nodeType === 8)
          if (n2.data === o$1)
            s2.push({ type: 2, index: i2 });
          else {
            let e3 = -1;
            for (; (e3 = n2.data.indexOf(e$1, e3 + 1)) !== -1; )
              s2.push({ type: 7, index: i2 }), e3 += e$1.length - 1;
          }
        i2++;
      }
    }
    static createElement(e2, t2) {
      const r2 = l$1.createElement("template");
      return r2.innerHTML = e2, r2;
    }
  }
  function V(e2, t2, n2 = e2, i2) {
    var a2;
    if (t2 === b)
      return t2;
    let o2 = i2 !== void 0 ? (a2 = n2._$Cl) === null || a2 === void 0 ? void 0 : a2[i2] : n2._$Cu;
    const s2 = r(t2) ? void 0 : t2._$litDirective$;
    return (o2 == null ? void 0 : o2.constructor) !== s2 && ((a2 = o2 == null ? void 0 : o2._$AO) === null || a2 === void 0 || a2.call(o2, false), s2 === void 0 ? o2 = void 0 : (o2 = new s2(e2), o2._$AT(e2, n2, i2)), i2 !== void 0 ? ((a2 = n2._$Cl) !== null && a2 !== void 0 ? a2 : n2._$Cl = [])[i2] = o2 : n2._$Cu = o2), t2 = o2 !== void 0 ? V(e2, o2._$AS(e2, t2.values), o2, i2) : t2;
  }
  class E {
    constructor(e2, t2) {
      this.v = [], this._$AN = void 0, this._$AD = e2, this._$AM = t2;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    p(t2) {
      var e2, { el: { content: r2 }, parts: n2 } = this._$AD, r2 = ((e2 = t2 == null ? void 0 : t2.creationScope) !== null && e2 !== void 0 ? e2 : l$1).importNode(r2, true);
      A.currentNode = r2;
      let i2 = A.nextNode(), a2 = 0, o2 = 0, s2 = n2[0];
      for (; s2 !== void 0; ) {
        if (a2 === s2.index) {
          let e3;
          s2.type === 2 ? e3 = new N(i2, i2.nextSibling, this, t2) : s2.type === 1 ? e3 = new s2.ctor(i2, s2.name, s2.strings, this, t2) : s2.type === 6 && (e3 = new I(i2, this, t2)), this.v.push(e3), s2 = n2[++o2];
        }
        a2 !== (s2 == null ? void 0 : s2.index) && (i2 = A.nextNode(), a2++);
      }
      return r2;
    }
    m(e2) {
      let t2 = 0;
      for (const r2 of this.v)
        r2 !== void 0 && (r2.strings !== void 0 ? (r2._$AI(e2, r2, t2), t2 += r2.strings.length - 2) : r2._$AI(e2[t2])), t2++;
    }
  }
  class N {
    constructor(e2, t2, r2, n2) {
      this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = e2, this._$AB = t2, this._$AM = r2, this.options = n2, this._$Cg = (n2 = n2 == null ? void 0 : n2.isConnected) === null || n2 === void 0 || n2;
    }
    get _$AU() {
      var e2;
      return (e2 = (e2 = this._$AM) === null || e2 === void 0 ? void 0 : e2._$AU) !== null && e2 !== void 0 ? e2 : this._$Cg;
    }
    get parentNode() {
      let e2 = this._$AA.parentNode;
      var t2 = this._$AM;
      return t2 !== void 0 && e2.nodeType === 11 && (e2 = t2.parentNode), e2;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(e2, t2 = this) {
      e2 = V(this, e2, t2), r(e2) ? e2 === T || e2 == null || e2 === "" ? (this._$AH !== T && this._$AR(), this._$AH = T) : e2 !== this._$AH && e2 !== b && this.$(e2) : e2._$litType$ !== void 0 ? this.T(e2) : e2.nodeType !== void 0 ? this.S(e2) : u(e2) ? this.M(e2) : this.$(e2);
    }
    A(e2, t2 = this._$AB) {
      return this._$AA.parentNode.insertBefore(e2, t2);
    }
    S(e2) {
      this._$AH !== e2 && (this._$AR(), this._$AH = this.A(e2));
    }
    $(e2) {
      this._$AH !== T && r(this._$AH) ? this._$AA.nextSibling.data = e2 : this.S(l$1.createTextNode(e2)), this._$AH = e2;
    }
    T(e2) {
      const { values: t2, _$litType$: r2 } = e2, n2 = typeof r2 == "number" ? this._$AC(e2) : (r2.el === void 0 && (r2.el = P.createElement(r2.h, this.options)), r2);
      if (((e2 = this._$AH) === null || e2 === void 0 ? void 0 : e2._$AD) === n2)
        this._$AH.m(t2);
      else {
        const i2 = new E(n2, this), e3 = i2.p(this.options);
        i2.m(t2), this.S(e3), this._$AH = i2;
      }
    }
    _$AC(e2) {
      let t2 = x.get(e2.strings);
      return t2 === void 0 && x.set(e2.strings, t2 = new P(e2)), t2;
    }
    M(e2) {
      d$3(this._$AH) || (this._$AH = [], this._$AR());
      const t2 = this._$AH;
      let r2, n2 = 0;
      for (const i2 of e2)
        n2 === t2.length ? t2.push(r2 = new N(this.A(h()), this.A(h()), this, this.options)) : r2 = t2[n2], r2._$AI(i2), n2++;
      n2 < t2.length && (this._$AR(r2 && r2._$AB.nextSibling, n2), t2.length = n2);
    }
    _$AR(e2 = this._$AA.nextSibling, t2) {
      var r2;
      for ((r2 = this._$AP) === null || r2 === void 0 || r2.call(this, false, true, t2); e2 && e2 !== this._$AB; ) {
        const t3 = e2.nextSibling;
        e2.remove(), e2 = t3;
      }
    }
    setConnected(e2) {
      var t2;
      this._$AM === void 0 && (this._$Cg = e2, (t2 = this._$AP) === null || t2 === void 0 || t2.call(this, e2));
    }
  }
  class S {
    constructor(e2, t2, r2, n2, i2) {
      this.type = 1, this._$AH = T, this._$AN = void 0, this.element = e2, this.name = t2, this._$AM = n2, this.options = i2, 2 < r2.length || r2[0] !== "" || r2[1] !== "" ? (this._$AH = Array(r2.length - 1).fill(new String()), this.strings = r2) : this._$AH = T;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(n2, i2 = this, a2, o2) {
      var s2 = this.strings;
      let l2 = false;
      if (s2 === void 0)
        n2 = V(this, n2, i2, 0), l2 = !r(n2) || n2 !== this._$AH && n2 !== b, l2 && (this._$AH = n2);
      else {
        const o3 = n2;
        let e2, t2;
        for (n2 = s2[0], e2 = 0; e2 < s2.length - 1; e2++)
          t2 = V(this, o3[a2 + e2], i2, e2), t2 === b && (t2 = this._$AH[e2]), l2 = l2 || (!r(t2) || t2 !== this._$AH[e2]), t2 === T ? n2 = T : n2 !== T && (n2 += (t2 != null ? t2 : "") + s2[e2 + 1]), this._$AH[e2] = t2;
      }
      l2 && !o2 && this.k(n2);
    }
    k(e2) {
      e2 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e2 != null ? e2 : "");
    }
  }
  class M extends S {
    constructor() {
      super(...arguments), this.type = 3;
    }
    k(e2) {
      this.element[this.name] = e2 === T ? void 0 : e2;
    }
  }
  class k$2 extends S {
    constructor() {
      super(...arguments), this.type = 4;
    }
    k(e2) {
      e2 && e2 !== T ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name);
    }
  }
  class H extends S {
    constructor(e2, t2, r2, n2, i2) {
      super(e2, t2, r2, n2, i2), this.type = 5;
    }
    _$AI(e2, t2 = this) {
      var r2, n2;
      (e2 = (n2 = V(this, e2, t2, 0)) !== null && n2 !== void 0 ? n2 : T) !== b && (r2 = this._$AH, t2 = e2 === T && r2 !== T || e2.capture !== r2.capture || e2.once !== r2.once || e2.passive !== r2.passive, n2 = e2 !== T && (r2 === T || t2), t2 && this.element.removeEventListener(this.name, this, r2), n2 && this.element.addEventListener(this.name, this, e2), this._$AH = e2);
    }
    handleEvent(e2) {
      var t2;
      typeof this._$AH == "function" ? this._$AH.call((t2 = (t2 = this.options) === null || t2 === void 0 ? void 0 : t2.host) !== null && t2 !== void 0 ? t2 : this.element, e2) : this._$AH.handleEvent(e2);
    }
  }
  class I {
    constructor(e2, t2, r2) {
      this.element = e2, this.type = 6, this._$AN = void 0, this._$AM = t2, this.options = r2;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e2) {
      V(this, e2);
    }
  }
  const R = window.litHtmlPolyfillSupport;
  R == null || R(P, N), ((t = globalThis.litHtmlVersions) !== null && t !== void 0 ? t : globalThis.litHtmlVersions = []).push("2.0.1");
  class s extends n$2 {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
    }
    createRenderRoot() {
      var e2, t2, r2 = super.createRenderRoot();
      return (e2 = (t2 = this.renderOptions).renderBefore) !== null && e2 !== void 0 || (t2.renderBefore = r2.firstChild), r2;
    }
    update(e2) {
      var t2 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e2), this._$Dt = w(t2, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var e2;
      super.connectedCallback(), (e2 = this._$Dt) === null || e2 === void 0 || e2.setConnected(true);
    }
    disconnectedCallback() {
      var e2;
      super.disconnectedCallback(), (e2 = this._$Dt) === null || e2 === void 0 || e2.setConnected(false);
    }
    render() {
      return b;
    }
  }
  s.finalized = true, s._$litElement$ = true, (l = globalThis.litElementHydrateSupport) === null || l === void 0 || l.call(globalThis, { LitElement: s });
  const n = globalThis.litElementPolyfillSupport;
  n == null || n({ LitElement: s }), ((o = globalThis.litElementVersions) !== null && o !== void 0 ? o : globalThis.litElementVersions = []).push("3.0.1");
  var __awaiter$e = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SLitComponent extends s {
    constructor(e2 = {}) {
      var t2;
      super(), this._settings = {}, this._shouldUpdate = false, this._settings = __deepMerge$7({ componentUtils: {}, litComponent: { shadowDom: true, get rootNode() {
        var e3;
        return (e3 = this.shadowRoot) === null || e3 === void 0 ? void 0 : e3.querySelector("*:first-child");
      } } }, e2), this.componentUtils = new SComponent(this, this.attributes, { componentUtils: Object.assign(Object.assign({}, (e2 = this._settings.componentUtils) !== null && e2 !== void 0 ? e2 : {}), { style: (t2 = (e2 = (e2 = this.constructor.styles) === null || e2 === void 0 ? void 0 : e2.cssText) !== null && e2 !== void 0 ? e2 : (t2 = this._settings.componentUtils) === null || t2 === void 0 ? void 0 : t2.style) !== null && t2 !== void 0 ? t2 : "" }) }), this.props = this.componentUtils.props, this.litComponentSettings.shadowDom === false && (this.createRenderRoot = () => this), Object.keys(this.componentUtils.props).forEach((e3) => {
        this[e3] = this.componentUtils.props[e3];
      });
      const r2 = (t2 = this.firstUpdated) === null || t2 === void 0 ? void 0 : t2.bind(this);
      this.firstUpdated = () => __awaiter$e(this, void 0, void 0, function* () {
        r2 && (yield r2()), this.mounted = true;
      });
      const n2 = (t2 = this.shouldUpdate) === null || t2 === void 0 ? void 0 : t2.bind(this);
      this.shouldUpdate = () => {
        if (n2 && !n2())
          return false;
        return this._shouldUpdate;
      }, __awaiter$e(this, void 0, void 0, function* () {
        yield this.componentUtils.waitAndExecute(this.mount.bind(this));
      });
    }
    static setDefaultProps(e2, t2) {
      SComponent.setDefaultProps(e2, t2);
    }
    get litComponentSettings() {
      return this._settings.litComponent;
    }
    static properties(e2, t2) {
      const i2 = {}, a2 = SComponent.getFinalInterface(t2);
      return Object.keys(a2.definition).forEach((e3) => {
        var t3, r2, n2 = a2.definition[e3];
        i2[e3] = Object.assign({}, (t3 = n2.lit) !== null && t3 !== void 0 ? t3 : {}), !n2.physical && ((t3 = (r2 = n2.type) === null || r2 === void 0 ? void 0 : r2.toLowerCase) === null || t3 === void 0 ? void 0 : t3.call(r2)) !== "boolean" && ((r2 = (n2 = (r2 = n2.type) === null || r2 === void 0 ? void 0 : r2.type) === null || n2 === void 0 ? void 0 : n2.toLowerCase) === null || r2 === void 0 ? void 0 : r2.call(n2)) !== "boolean" || (i2[e3].reflect = true, i2[e3].attribute = dashCase(e3), i2[e3].converter = { toAttribute(e4) {
          return e4 === false || e4 === null ? null : String(e4);
        } });
      }), Object.assign(Object.assign({}, i2), e2 != null ? e2 : {});
    }
    mount() {
      var e2;
      return __awaiter$e(this, void 0, void 0, function* () {
        return this._shouldUpdate = true, this.requestUpdate(), yield this.updateComplete, this.componentUtils.injectStyle((e2 = (e2 = this.constructor.styles) === null || e2 === void 0 ? void 0 : e2.cssText) !== null && e2 !== void 0 ? e2 : "", this.tagName), yield wait$2(), this.componentUtils.props.adoptStyle && this.shadowRoot && (yield this.componentUtils.adoptStyleInShadowRoot(this.shadowRoot)), true;
      });
    }
  }
  const i = (t2, r2) => r2.kind !== "method" || !r2.descriptor || "value" in r2.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: r2.key, initializer() {
    typeof r2.initializer == "function" && (this[r2.key] = r2.initializer.call(this));
  }, finisher(e2) {
    e2.createProperty(r2.key, t2);
  } } : __spreadProps(__spreadValues({}, r2), { finisher(e2) {
    e2.createProperty(r2.key, t2);
  } });
  function e(r2) {
    return (e2, t2) => t2 !== void 0 ? void e2.constructor.createProperty(t2, r2) : i(r2, e2);
  }
  var axios$2 = { exports: {} }, bind$2 = function(r2, n2) {
    return function() {
      for (var e2 = new Array(arguments.length), t2 = 0; t2 < e2.length; t2++)
        e2[t2] = arguments[t2];
      return r2.apply(n2, e2);
    };
  }, bind$1 = bind$2, toString$3 = Object.prototype.toString;
  function isArray$4(e2) {
    return toString$3.call(e2) === "[object Array]";
  }
  function isUndefined$1(e2) {
    return e2 === void 0;
  }
  function isBuffer(e2) {
    return e2 !== null && !isUndefined$1(e2) && e2.constructor !== null && !isUndefined$1(e2.constructor) && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
  }
  function isArrayBuffer(e2) {
    return toString$3.call(e2) === "[object ArrayBuffer]";
  }
  function isFormData(e2) {
    return typeof FormData != "undefined" && e2 instanceof FormData;
  }
  function isArrayBufferView(e2) {
    e2 = typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && e2.buffer instanceof ArrayBuffer;
    return e2;
  }
  function isString$1(e2) {
    return typeof e2 == "string";
  }
  function isNumber$1(e2) {
    return typeof e2 == "number";
  }
  function isObject$1(e2) {
    return e2 !== null && typeof e2 == "object";
  }
  function isPlainObject(e2) {
    if (toString$3.call(e2) !== "[object Object]")
      return false;
    e2 = Object.getPrototypeOf(e2);
    return e2 === null || e2 === Object.prototype;
  }
  function isDate$1(e2) {
    return toString$3.call(e2) === "[object Date]";
  }
  function isFile(e2) {
    return toString$3.call(e2) === "[object File]";
  }
  function isBlob(e2) {
    return toString$3.call(e2) === "[object Blob]";
  }
  function isFunction$1(e2) {
    return toString$3.call(e2) === "[object Function]";
  }
  function isStream(e2) {
    return isObject$1(e2) && isFunction$1(e2.pipe);
  }
  function isURLSearchParams(e2) {
    return typeof URLSearchParams != "undefined" && e2 instanceof URLSearchParams;
  }
  function trim(e2) {
    return e2.trim ? e2.trim() : e2.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    return (typeof navigator == "undefined" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && (typeof window != "undefined" && typeof document != "undefined");
  }
  function forEach(e2, t2) {
    if (e2 != null)
      if (isArray$4(e2 = typeof e2 != "object" ? [e2] : e2))
        for (var r2 = 0, n2 = e2.length; r2 < n2; r2++)
          t2.call(null, e2[r2], r2, e2);
      else
        for (var i2 in e2)
          Object.prototype.hasOwnProperty.call(e2, i2) && t2.call(null, e2[i2], i2, e2);
  }
  function merge() {
    var r2 = {};
    function e2(e3, t3) {
      isPlainObject(r2[t3]) && isPlainObject(e3) ? r2[t3] = merge(r2[t3], e3) : isPlainObject(e3) ? r2[t3] = merge({}, e3) : isArray$4(e3) ? r2[t3] = e3.slice() : r2[t3] = e3;
    }
    for (var t2 = 0, n2 = arguments.length; t2 < n2; t2++)
      forEach(arguments[t2], e2);
    return r2;
  }
  function extend$1(r2, e2, n2) {
    return forEach(e2, function(e3, t2) {
      r2[t2] = n2 && typeof e3 == "function" ? bind$1(e3, n2) : e3;
    }), r2;
  }
  function stripBOM(e2) {
    return e2 = e2.charCodeAt(0) === 65279 ? e2.slice(1) : e2;
  }
  var utils$d = { isArray: isArray$4, isArrayBuffer, isBuffer, isFormData, isArrayBufferView, isString: isString$1, isNumber: isNumber$1, isObject: isObject$1, isPlainObject, isUndefined: isUndefined$1, isDate: isDate$1, isFile, isBlob, isFunction: isFunction$1, isStream, isURLSearchParams, isStandardBrowserEnv, forEach, merge, extend: extend$1, trim, stripBOM }, utils$c = utils$d;
  function encode$1(e2) {
    return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function(e2, t2, r2) {
    if (!t2)
      return e2;
    var n2, r2 = r2 ? r2(t2) : utils$c.isURLSearchParams(t2) ? t2.toString() : (n2 = [], utils$c.forEach(t2, function(e3, t3) {
      e3 != null && (utils$c.isArray(e3) ? t3 += "[]" : e3 = [e3], utils$c.forEach(e3, function(e4) {
        utils$c.isDate(e4) ? e4 = e4.toISOString() : utils$c.isObject(e4) && (e4 = JSON.stringify(e4)), n2.push(encode$1(t3) + "=" + encode$1(e4));
      }));
    }), n2.join("&"));
    return r2 && ((t2 = e2.indexOf("#")) !== -1 && (e2 = e2.slice(0, t2)), e2 += (e2.indexOf("?") === -1 ? "?" : "&") + r2), e2;
  }, utils$b = utils$d;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function(e2, t2, r2) {
    return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!r2 && r2.synchronous, runWhen: r2 ? r2.runWhen : null }), this.handlers.length - 1;
  }, InterceptorManager$1.prototype.eject = function(e2) {
    this.handlers[e2] && (this.handlers[e2] = null);
  }, InterceptorManager$1.prototype.forEach = function(t2) {
    utils$b.forEach(this.handlers, function(e2) {
      e2 !== null && t2(e2);
    });
  };
  var InterceptorManager_1 = InterceptorManager$1, utils$a = utils$d, normalizeHeaderName$1 = function(r2, n2) {
    utils$a.forEach(r2, function(e2, t2) {
      t2 !== n2 && t2.toUpperCase() === n2.toUpperCase() && (r2[n2] = e2, delete r2[t2]);
    });
  }, enhanceError$2 = function(e2, t2, r2, n2, i2) {
    return e2.config = t2, r2 && (e2.code = r2), e2.request = n2, e2.response = i2, e2.isAxiosError = true, e2.toJSON = function() {
      return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code };
    }, e2;
  }, enhanceError$1 = enhanceError$2, createError$2 = function(e2, t2, r2, n2, i2) {
    e2 = new Error(e2);
    return enhanceError$1(e2, t2, r2, n2, i2);
  }, createError$1 = createError$2, settle$1 = function(e2, t2, r2) {
    var n2 = r2.config.validateStatus;
    r2.status && n2 && !n2(r2.status) ? t2(createError$1("Request failed with status code " + r2.status, r2.config, null, r2.request, r2)) : e2(r2);
  }, utils$9 = utils$d, cookies$1 = utils$9.isStandardBrowserEnv() ? { write: function(e2, t2, r2, n2, i2, a2) {
    var o2 = [];
    o2.push(e2 + "=" + encodeURIComponent(t2)), utils$9.isNumber(r2) && o2.push("expires=" + new Date(r2).toGMTString()), utils$9.isString(n2) && o2.push("path=" + n2), utils$9.isString(i2) && o2.push("domain=" + i2), a2 === true && o2.push("secure"), document.cookie = o2.join("; ");
  }, read: function(e2) {
    e2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
    return e2 ? decodeURIComponent(e2[3]) : null;
  }, remove: function(e2) {
    this.write(e2, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } }, isAbsoluteURL$1 = function(e2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e2);
  }, combineURLs$1 = function(e2, t2) {
    return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
  }, isAbsoluteURL = isAbsoluteURL$1, combineURLs = combineURLs$1, buildFullPath$1 = function(e2, t2) {
    return e2 && !isAbsoluteURL(t2) ? combineURLs(e2, t2) : t2;
  }, utils$8 = utils$d, ignoreDuplicateOf = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], parseHeaders$1 = function(e2) {
    var t2, r2, n2 = {};
    return e2 && utils$8.forEach(e2.split("\n"), function(e3) {
      r2 = e3.indexOf(":"), t2 = utils$8.trim(e3.substr(0, r2)).toLowerCase(), r2 = utils$8.trim(e3.substr(r2 + 1)), t2 && (n2[t2] && 0 <= ignoreDuplicateOf.indexOf(t2) || (n2[t2] = t2 === "set-cookie" ? (n2[t2] || []).concat([r2]) : n2[t2] ? n2[t2] + ", " + r2 : r2));
    }), n2;
  }, utils$7 = utils$d, isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? (wV = /(msie|trident)/i.test(navigator.userAgent), xV = document.createElement("a"), yV = zV(window.location.href), function(e2) {
    e2 = utils$7.isString(e2) ? zV(e2) : e2;
    return e2.protocol === yV.protocol && e2.host === yV.host;
  }) : function() {
    return true;
  }, yV, wV, xV;
  function zV(e2) {
    return wV && (xV.setAttribute("href", e2), e2 = xV.href), xV.setAttribute("href", e2), { href: xV.href, protocol: xV.protocol ? xV.protocol.replace(/:$/, "") : "", host: xV.host, search: xV.search ? xV.search.replace(/^\?/, "") : "", hash: xV.hash ? xV.hash.replace(/^#/, "") : "", hostname: xV.hostname, port: xV.port, pathname: xV.pathname.charAt(0) === "/" ? xV.pathname : "/" + xV.pathname };
  }
  var utils$6 = utils$d, settle = settle$1, cookies = cookies$1, buildURL$1 = buildURL$2, buildFullPath = buildFullPath$1, parseHeaders = parseHeaders$1, isURLSameOrigin = isURLSameOrigin$1, createError = createError$2, xhr = function(c2) {
    return new Promise(function(t2, r2) {
      var n2 = c2.data, i2 = c2.headers, a2 = c2.responseType;
      utils$6.isFormData(n2) && delete i2["Content-Type"];
      var e2, o2 = new XMLHttpRequest();
      c2.auth && (e2 = c2.auth.username || "", s2 = c2.auth.password ? unescape(encodeURIComponent(c2.auth.password)) : "", i2.Authorization = "Basic " + btoa(e2 + ":" + s2));
      var s2 = buildFullPath(c2.baseURL, c2.url);
      function l2() {
        var e3;
        o2 && (e3 = "getAllResponseHeaders" in o2 ? parseHeaders(o2.getAllResponseHeaders()) : null, e3 = { data: a2 && a2 !== "text" && a2 !== "json" ? o2.response : o2.responseText, status: o2.status, statusText: o2.statusText, headers: e3, config: c2, request: o2 }, settle(t2, r2, e3), o2 = null);
      }
      o2.open(c2.method.toUpperCase(), buildURL$1(s2, c2.params, c2.paramsSerializer), true), o2.timeout = c2.timeout, "onloadend" in o2 ? o2.onloadend = l2 : o2.onreadystatechange = function() {
        o2 && o2.readyState === 4 && (o2.status !== 0 || o2.responseURL && o2.responseURL.indexOf("file:") === 0) && setTimeout(l2);
      }, o2.onabort = function() {
        o2 && (r2(createError("Request aborted", c2, "ECONNABORTED", o2)), o2 = null);
      }, o2.onerror = function() {
        r2(createError("Network Error", c2, null, o2)), o2 = null;
      }, o2.ontimeout = function() {
        var e3 = "timeout of " + c2.timeout + "ms exceeded";
        c2.timeoutErrorMessage && (e3 = c2.timeoutErrorMessage), r2(createError(e3, c2, c2.transitional && c2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", o2)), o2 = null;
      }, !utils$6.isStandardBrowserEnv() || (s2 = (c2.withCredentials || isURLSameOrigin(s2)) && c2.xsrfCookieName ? cookies.read(c2.xsrfCookieName) : void 0) && (i2[c2.xsrfHeaderName] = s2), "setRequestHeader" in o2 && utils$6.forEach(i2, function(e3, t3) {
        n2 === void 0 && t3.toLowerCase() === "content-type" ? delete i2[t3] : o2.setRequestHeader(t3, e3);
      }), utils$6.isUndefined(c2.withCredentials) || (o2.withCredentials = !!c2.withCredentials), a2 && a2 !== "json" && (o2.responseType = c2.responseType), typeof c2.onDownloadProgress == "function" && o2.addEventListener("progress", c2.onDownloadProgress), typeof c2.onUploadProgress == "function" && o2.upload && o2.upload.addEventListener("progress", c2.onUploadProgress), c2.cancelToken && c2.cancelToken.promise.then(function(e3) {
        o2 && (o2.abort(), r2(e3), o2 = null);
      }), n2 = n2 || null, o2.send(n2);
    });
  }, utils$5 = utils$d, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$2, DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
  function setContentTypeIfUnset(e2, t2) {
    !utils$5.isUndefined(e2) && utils$5.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
  }
  function getDefaultAdapter() {
    var e2;
    return e2 = typeof XMLHttpRequest != "undefined" || typeof process != "undefined" && Object.prototype.toString.call(process) === "[object process]" ? xhr : e2;
  }
  function stringifySafely(e2, t2, r2) {
    if (utils$5.isString(e2))
      try {
        return (t2 || JSON.parse)(e2), utils$5.trim(e2);
      } catch (e3) {
        if (e3.name !== "SyntaxError")
          throw e3;
      }
    return (r2 || JSON.stringify)(e2);
  }
  var defaults$4 = { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: getDefaultAdapter(), transformRequest: [function(e2, t2) {
    return normalizeHeaderName(t2, "Accept"), normalizeHeaderName(t2, "Content-Type"), utils$5.isFormData(e2) || utils$5.isArrayBuffer(e2) || utils$5.isBuffer(e2) || utils$5.isStream(e2) || utils$5.isFile(e2) || utils$5.isBlob(e2) ? e2 : utils$5.isArrayBufferView(e2) ? e2.buffer : utils$5.isURLSearchParams(e2) ? (setContentTypeIfUnset(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString()) : utils$5.isObject(e2) || t2 && t2["Content-Type"] === "application/json" ? (setContentTypeIfUnset(t2, "application/json"), stringifySafely(e2)) : e2;
  }], transformResponse: [function(e2) {
    var t2 = this.transitional, r2 = t2 && t2.silentJSONParsing, t2 = t2 && t2.forcedJSONParsing, r2 = !r2 && this.responseType === "json";
    if (r2 || t2 && utils$5.isString(e2) && e2.length)
      try {
        return JSON.parse(e2);
      } catch (e3) {
        if (r2) {
          if (e3.name === "SyntaxError")
            throw enhanceError(e3, this, "E_JSON_PARSE");
          throw e3;
        }
      }
    return e2;
  }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, validateStatus: function(e2) {
    return 200 <= e2 && e2 < 300;
  }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
  utils$5.forEach(["delete", "get", "head"], function(e2) {
    defaults$4.headers[e2] = {};
  }), utils$5.forEach(["post", "put", "patch"], function(e2) {
    defaults$4.headers[e2] = utils$5.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$4, utils$4 = utils$d, defaults$3 = defaults_1, transformData$1 = function(t2, r2, e2) {
    var n2 = this || defaults$3;
    return utils$4.forEach(e2, function(e3) {
      t2 = e3.call(n2, t2, r2);
    }), t2;
  }, isCancel$1 = function(e2) {
    return !(!e2 || !e2.__CANCEL__);
  }, utils$3 = utils$d, transformData = transformData$1, isCancel = isCancel$1, defaults$2 = defaults_1;
  function throwIfCancellationRequested(e2) {
    e2.cancelToken && e2.cancelToken.throwIfRequested();
  }
  var dispatchRequest$1 = function(t2) {
    return throwIfCancellationRequested(t2), t2.headers = t2.headers || {}, t2.data = transformData.call(t2, t2.data, t2.headers, t2.transformRequest), t2.headers = utils$3.merge(t2.headers.common || {}, t2.headers[t2.method] || {}, t2.headers), utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(e2) {
      delete t2.headers[e2];
    }), (t2.adapter || defaults$2.adapter)(t2).then(function(e2) {
      return throwIfCancellationRequested(t2), e2.data = transformData.call(t2, e2.data, e2.headers, t2.transformResponse), e2;
    }, function(e2) {
      return isCancel(e2) || (throwIfCancellationRequested(t2), e2 && e2.response && (e2.response.data = transformData.call(t2, e2.response.data, e2.response.headers, t2.transformResponse))), Promise.reject(e2);
    });
  }, utils$2 = utils$d, mergeConfig$2 = function(t2, r2) {
    r2 = r2 || {};
    var n2 = {}, e2 = ["url", "method", "data"], i2 = ["headers", "auth", "proxy", "params"], a2 = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"], o2 = ["validateStatus"];
    function s2(e3, t3) {
      return utils$2.isPlainObject(e3) && utils$2.isPlainObject(t3) ? utils$2.merge(e3, t3) : utils$2.isPlainObject(t3) ? utils$2.merge({}, t3) : utils$2.isArray(t3) ? t3.slice() : t3;
    }
    function l2(e3) {
      utils$2.isUndefined(r2[e3]) ? utils$2.isUndefined(t2[e3]) || (n2[e3] = s2(void 0, t2[e3])) : n2[e3] = s2(t2[e3], r2[e3]);
    }
    utils$2.forEach(e2, function(e3) {
      utils$2.isUndefined(r2[e3]) || (n2[e3] = s2(void 0, r2[e3]));
    }), utils$2.forEach(i2, l2), utils$2.forEach(a2, function(e3) {
      utils$2.isUndefined(r2[e3]) ? utils$2.isUndefined(t2[e3]) || (n2[e3] = s2(void 0, t2[e3])) : n2[e3] = s2(void 0, r2[e3]);
    }), utils$2.forEach(o2, function(e3) {
      e3 in r2 ? n2[e3] = s2(t2[e3], r2[e3]) : e3 in t2 && (n2[e3] = s2(void 0, t2[e3]));
    });
    var c2 = e2.concat(i2).concat(a2).concat(o2), o2 = Object.keys(t2).concat(Object.keys(r2)).filter(function(e3) {
      return c2.indexOf(e3) === -1;
    });
    return utils$2.forEach(o2, l2), n2;
  };
  const name = "axios", version$1 = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = { test: "grunt test", start: "node ./sandbox/server.js", build: "NODE_ENV=production grunt build", preversion: "npm test", version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json", postversion: "git push && git push --tags", examples: "node ./examples/server.js", coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js", fix: "eslint --fix lib/**/*.js" }, repository = { type: "git", url: "https://github.com/axios/axios.git" }, keywords = ["xhr", "http", "ajax", "promise", "node"], author = "Matt Zabriskie", license = "MIT", bugs = { url: "https://github.com/axios/axios/issues" }, homepage = "https://axios-http.com", devDependencies = { coveralls: "^3.0.0", "es6-promise": "^4.2.4", grunt: "^1.3.0", "grunt-banner": "^0.6.0", "grunt-cli": "^1.2.0", "grunt-contrib-clean": "^1.1.0", "grunt-contrib-watch": "^1.0.0", "grunt-eslint": "^23.0.0", "grunt-karma": "^4.0.0", "grunt-mocha-test": "^0.13.3", "grunt-ts": "^6.0.0-beta.19", "grunt-webpack": "^4.0.2", "istanbul-instrumenter-loader": "^1.0.0", "jasmine-core": "^2.4.1", karma: "^6.3.2", "karma-chrome-launcher": "^3.1.0", "karma-firefox-launcher": "^2.1.0", "karma-jasmine": "^1.1.1", "karma-jasmine-ajax": "^0.1.13", "karma-safari-launcher": "^1.0.0", "karma-sauce-launcher": "^4.3.6", "karma-sinon": "^1.0.5", "karma-sourcemap-loader": "^0.3.8", "karma-webpack": "^4.0.2", "load-grunt-tasks": "^3.5.2", minimist: "^1.2.0", mocha: "^8.2.1", sinon: "^4.5.0", "terser-webpack-plugin": "^4.2.3", typescript: "^4.0.5", "url-search-params": "^0.10.0", webpack: "^4.44.2", "webpack-dev-server": "^3.11.0" }, browser = { "./lib/adapters/http.js": "./lib/adapters/xhr.js" }, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = { "follow-redirects": "^1.14.0" }, bundlesize = [{ path: "./dist/axios.min.js", threshold: "5kB" }];
  var require$$0$1 = { name, version: version$1, description, main, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, browser, jsdelivr, unpkg, typings, dependencies, bundlesize }, pkg = require$$0$1, validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(t2, r2) {
    validators$1[t2] = function(e2) {
      return typeof e2 === t2 || "a" + (r2 < 1 ? "n " : " ") + t2;
    };
  });
  var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
  function isOlderVersion(e2, t2) {
    for (var r2 = t2 ? t2.split(".") : currentVerArr, n2 = e2.split("."), i2 = 0; i2 < 3; i2++) {
      if (r2[i2] > n2[i2])
        return true;
      if (r2[i2] < n2[i2])
        return false;
    }
    return false;
  }
  function assertOptions(e2, t2, r2) {
    if (typeof e2 != "object")
      throw new TypeError("options must be an object");
    for (var n2 = Object.keys(e2), i2 = n2.length; 0 < i2--; ) {
      var a2 = n2[i2], o2 = t2[a2];
      if (o2) {
        var s2 = e2[a2], s2 = s2 === void 0 || o2(s2, a2, e2);
        if (s2 !== true)
          throw new TypeError("option " + a2 + " must be " + s2);
      } else if (r2 !== true)
        throw Error("Unknown option " + a2);
    }
  }
  validators$1.transitional = function(n2, i2, r2) {
    var a2 = i2 && isOlderVersion(i2);
    function o2(e2, t2) {
      return "[Axios v" + pkg.version + "] Transitional option '" + e2 + "'" + t2 + (r2 ? ". " + r2 : "");
    }
    return function(e2, t2, r3) {
      if (n2 === false)
        throw new Error(o2(t2, " has been removed in " + i2));
      return a2 && !deprecatedWarnings[t2] && (deprecatedWarnings[t2] = true, console.warn(o2(t2, " has been deprecated since v" + i2 + " and will be removed in the near future"))), !n2 || n2(e2, t2, r3);
    };
  };
  var validator$1 = { isOlderVersion, assertOptions, validators: validators$1 }, utils$1 = utils$d, buildURL = buildURL$2, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
  function Axios$1(e2) {
    this.defaults = e2, this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };
  }
  Axios$1.prototype.request = function(t2) {
    typeof t2 == "string" ? (t2 = arguments[1] || {}).url = arguments[0] : t2 = t2 || {}, (t2 = mergeConfig$1(this.defaults, t2)).method ? t2.method = t2.method.toLowerCase() : this.defaults.method ? t2.method = this.defaults.method.toLowerCase() : t2.method = "get";
    var e2 = t2.transitional;
    e2 !== void 0 && validator.assertOptions(e2, { silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"), forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"), clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0") }, false);
    var r2 = [], n2 = true;
    this.interceptors.request.forEach(function(e3) {
      typeof e3.runWhen == "function" && e3.runWhen(t2) === false || (n2 = n2 && e3.synchronous, r2.unshift(e3.fulfilled, e3.rejected));
    });
    var i2, a2 = [];
    if (this.interceptors.response.forEach(function(e3) {
      a2.push(e3.fulfilled, e3.rejected);
    }), !n2) {
      var o2 = [dispatchRequest, void 0];
      for (Array.prototype.unshift.apply(o2, r2), o2 = o2.concat(a2), i2 = Promise.resolve(t2); o2.length; )
        i2 = i2.then(o2.shift(), o2.shift());
      return i2;
    }
    for (var s2 = t2; r2.length; ) {
      var l2 = r2.shift(), c2 = r2.shift();
      try {
        s2 = l2(s2);
      } catch (e3) {
        c2(e3);
        break;
      }
    }
    try {
      i2 = dispatchRequest(s2);
    } catch (e3) {
      return Promise.reject(e3);
    }
    for (; a2.length; )
      i2 = i2.then(a2.shift(), a2.shift());
    return i2;
  }, Axios$1.prototype.getUri = function(e2) {
    return e2 = mergeConfig$1(this.defaults, e2), buildURL(e2.url, e2.params, e2.paramsSerializer).replace(/^\?/, "");
  }, utils$1.forEach(["delete", "get", "head", "options"], function(r2) {
    Axios$1.prototype[r2] = function(e2, t2) {
      return this.request(mergeConfig$1(t2 || {}, { method: r2, url: e2, data: (t2 || {}).data }));
    };
  }), utils$1.forEach(["post", "put", "patch"], function(n2) {
    Axios$1.prototype[n2] = function(e2, t2, r2) {
      return this.request(mergeConfig$1(r2 || {}, { method: n2, url: e2, data: t2 }));
    };
  });
  var Axios_1 = Axios$1;
  function Cancel$1(e2) {
    this.message = e2;
  }
  Cancel$1.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1, Cancel = Cancel_1;
  function CancelToken(e2) {
    if (typeof e2 != "function")
      throw new TypeError("executor must be a function.");
    var t2;
    this.promise = new Promise(function(e3) {
      t2 = e3;
    });
    var r2 = this;
    e2(function(e3) {
      r2.reason || (r2.reason = new Cancel(e3), t2(r2.reason));
    });
  }
  CancelToken.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, CancelToken.source = function() {
    var t2;
    return { token: new CancelToken(function(e2) {
      t2 = e2;
    }), cancel: t2 };
  };
  var CancelToken_1 = CancelToken, spread = function(t2) {
    return function(e2) {
      return t2.apply(null, e2);
    };
  }, isAxiosError = function(e2) {
    return typeof e2 == "object" && e2.isAxiosError === true;
  }, utils = utils$d, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults$1 = defaults_1;
  function createInstance(e2) {
    var t2 = new Axios(e2), e2 = bind(Axios.prototype.request, t2);
    return utils.extend(e2, Axios.prototype, t2), utils.extend(e2, t2), e2;
  }
  var axios$1 = createInstance(defaults$1);
  axios$1.Axios = Axios, axios$1.create = function(e2) {
    return createInstance(mergeConfig(axios$1.defaults, e2));
  }, axios$1.Cancel = Cancel_1, axios$1.CancelToken = CancelToken_1, axios$1.isCancel = isCancel$1, axios$1.all = function(e2) {
    return Promise.all(e2);
  }, axios$1.spread = spread, axios$1.isAxiosError = isAxiosError, axios$2.exports = axios$1, axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  function strToHtml(e2) {
    if (document === void 0 || document.createElement === void 0)
      return e2;
    {
      const t2 = document.createElement("div");
      return t2.innerHTML = e2, t2.children.length === 1 ? t2.children[0] : t2;
    }
  }
  function toStringFn(e2, t2 = true) {
    if (document === void 0 || document.createElement === void 0)
      return e2;
    {
      const r2 = document.createElement("div");
      return r2.appendChild(e2.cloneNode(t2)), r2.innerHTML;
    }
  }
  class SRequestConfig {
    constructor(e2) {
      this.url = null, this.baseURL = null, this.method = "GET", this.headers = {}, this.params = {}, this.data = {}, this.timeout = 0, this.sendInterval = 1e3, this.sendCount = 1, this.everyResponse = null, this.responseType = "json", e2.timeout && typeof e2.timeout == "string" && (e2.timeout = convert$1(e2.timeout, "ms")), e2.sendInterval && typeof e2.sendInterval == "string" && (e2.sendInterval = convert$1(e2.sendInterval, "ms")), Object.assign(this, e2);
    }
  }
  class SRequest extends SClass {
    constructor(e2, t2) {
      super(__deepMerge$7({ request: {} }, t2 != null ? t2 : {})), this._defaultRequestSettings = {}, this._currentRequestSettings = {}, this._requestsCount = 0, e2 instanceof SRequestConfig ? this._defaultRequestSettings = e2 : this._defaultRequestSettings = new SRequestConfig(e2);
    }
    get requestSettings() {
      return this._settings.request;
    }
    _onSuccess(e2) {
      let t2 = e2.data;
      var r2 = e2.headers["content-type"] || "text/plain", n2 = this._currentRequestSettings.url.indexOf("#") !== -1 && this._currentRequestSettings.url.split("#")[1];
      if (r2 === "text/html" && n2 !== false && document !== void 0 && document.querySelector !== void 0) {
        const i2 = strToHtml(e2.data);
        i2.id === n2 ? t2 = toStringFn(i2) : (n2 = i2.querySelector("#" + n2)) && (t2 = toStringFn(n2));
      } else
        r2 === "application/json" && (t2 = JSON.parse(e2.data));
      e2.data = t2, delete e2.config, delete e2.request, this._responsesArray.push(e2), this._currentRequestSettings.everyResponse && this._currentRequestSettings.everyResponse(Object.assign({}, e2), this._requestsCount);
      e2 = this._responsesArray.slice(-1)[0];
      this._requestsCount >= this._currentRequestSettings.sendCount ? this._resolve({ status: e2.status, statusText: e2.statusText, data: e2.data, count: this._responsesArray.length, response: e2, responses: this._responsesArray }) : this._send();
    }
    _onError(e2) {
      this._reject(e2);
    }
    _send(e2 = {}) {
      this._requestsCount++, (e2 = __deepMerge$7(this._defaultRequestSettings, e2)).beforeSend && (e2 = e2.beforeSend(e2, this._requestsCount)), this._currentRequestSettings = Object.assign(e2), axios(e2).then(this._onSuccess.bind(this)).catch(this._onError.bind(this));
    }
    retry() {
      return this.send();
    }
    send(r2 = {}) {
      return new Promise((e2, t2) => {
        this._requestsCount = 0, this._responsesArray = [], this._resolve = e2, this._reject = t2, this._send(r2);
      });
    }
  }
  function filter$2(t2, r2) {
    const n2 = {};
    return Object.keys(t2).forEach((e2) => {
      r2(e2, t2[e2]) && (n2[e2] = t2[e2]);
    }), n2;
  }
  var __defProp$1 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __decorateClass$1 = (e2, t2, r2, n2) => {
    for (var i2, a2 = 1 < n2 ? void 0 : n2 ? __getOwnPropDesc$1(t2, r2) : t2, o2 = e2.length - 1; 0 <= o2; o2--)
      (i2 = e2[o2]) && (a2 = (n2 ? i2(t2, r2, a2) : i2(a2)) || a2);
    return n2 && a2 && __defProp$1(t2, r2, a2), a2;
  };
  class ApiNav extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false }, componentUtils: {} }), this._openedNamespaces = [], this._menuStack = {}, this._menuStates = {}, this._loaded = false;
    }
    firstUpdated() {
      return __async(this, null, function* () {
        var _a2, _b2;
        const e2 = new SRequest({ url: "/docmap.json", method: "get" });
        this._menuStates = JSON.parse((_a2 = window.localStorage.getItem("apiNavStates")) != null ? _a2 : "{}");
        var t2 = JSON.parse((_b2 = window.localStorage.getItem("apiNav")) != null ? _b2 : "{}");
        Object.keys(t2).length && (this._menuStack = t2, this._loaded = true);
        const r2 = yield e2.send(), n2 = [];
        r2.data.map = filter$2(r2.data.map, (e3, t3) => {
          return n2.indexOf(t3.type) === -1 && n2.push(t3.type), ["function", "class", "cssmixin", "cssfunction", "object", "customelement", "feature"].indexOf(t3.type.toLowerCase()) !== -1;
        }), this._menuStack = {}, Object.keys(r2.data.map).forEach((e3) => {
          __set(this._menuStack, e3, r2.data.map[e3]);
        }), window.localStorage.setItem("apiNav", JSON.stringify(this._menuStack)), this._loaded = true, this.requestUpdate();
      });
    }
    _isAcive(e2) {
      var _a2;
      return (_a2 = this._menuStates[e2]) == null ? void 0 : _a2.opened;
    }
    _toggle(e2) {
      this._menuStates[e2] ? this._menuStates[e2].opened = !this._menuStates[e2].opened : this._menuStates[e2] = { opened: true }, window.localStorage.setItem("apiNavStates", JSON.stringify(this._menuStates)), this.requestUpdate();
    }
    _renderList(i2, a2 = "") {
      var e2 = Object.keys(i2).map((e3) => {
        var _a2;
        var t2 = i2[e3];
        const r2 = (a2 ? a2 + "." : "") + e3;
        if (t2.name && t2.namespace) {
          var n2 = t2.platform[0].name;
          return p`
                    <li>
                        <i
                            class="s-icon:file-${n2} s-tc:extension-${n2}"
                        ></i>
                        <a href="/api/${r2}">${t2.name}</a>
                    </li>
                `;
        }
        return p`
                    <li class="${this._isAcive(r2) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
          this._toggle(r2);
        }}
                        >
                            ${e3}
                        </span>
                        ${((_a2 = this._menuStates[r2]) == null ? void 0 : _a2.opened) ? p`
                                  ${this._renderList(get$3(this._menuStack, r2), r2)}
                              ` : ""}
                    </li>
                `;
      });
      return p`
            <ul class="${a2 ? "" : "s-fs-tree"}">
                ${e2}
            </ul>
        `;
    }
    render() {
      return this._loaded ? p`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        ` : p`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
    }
  }
  __decorateClass$1([e()], ApiNav.prototype, "_loaded", 2), customElements.get("api-nav") || customElements.define("api-nav", ApiNav);
  var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __decorateClass = (e2, t2, r2, n2) => {
    for (var i2, a2 = 1 < n2 ? void 0 : n2 ? __getOwnPropDesc(t2, r2) : t2, o2 = e2.length - 1; 0 <= o2; o2--)
      (i2 = e2[o2]) && (a2 = (n2 ? i2(t2, r2, a2) : i2(a2)) || a2);
    return n2 && a2 && __defProp(t2, r2, a2), a2;
  };
  class ConfigExplorerNav extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false }, componentUtils: {} }), this._openedNamespaces = [], this._menuStack = {}, this._menuStates = {}, this._loaded = false;
    }
    firstUpdated() {
      return __async(this, null, function* () {
        var _a2, _b2;
        const e2 = new SRequest({ url: "/api/docmap", method: "get" });
        this._menuStates = JSON.parse((_a2 = window.localStorage.getItem("ConfigExplorerNavStates")) != null ? _a2 : "{}");
        var t2 = JSON.parse((_b2 = window.localStorage.getItem("ConfigExplorerNav")) != null ? _b2 : "{}");
        Object.keys(t2).length && (this._menuStack = t2, this._loaded = true);
        const r2 = yield e2.send();
        r2.data.map = filter$2(r2.data.map, (e3, t3) => (e3.includes("imagesBuilder") && console.log("S", e3), e3.match(/[a-zA-Z0-9]+\.config\.[a-zA-Z0-9]+/) ? (e3.replace(/.*\.config\./, ""), true) : false));
      });
    }
    _isAcive(e2) {
      var _a2;
      return (_a2 = this._menuStates[e2]) == null ? void 0 : _a2.opened;
    }
    _toggle(e2) {
      this._menuStates[e2] ? this._menuStates[e2].opened = !this._menuStates[e2].opened : this._menuStates[e2] = { opened: true }, window.localStorage.setItem("ConfigExplorerNavStates", JSON.stringify(this._menuStates)), this.requestUpdate();
    }
    _renderList(i2, a2 = "") {
      var e2 = Object.keys(i2).map((e3) => {
        var _a2;
        var t2 = i2[e3];
        const r2 = (a2 ? a2 + "." : "") + e3;
        if (t2.name && t2.namespace) {
          var n2 = t2.platform[0].name;
          return p`
                    <li>
                        <i
                            class="s-icon:file-${n2} s-tc:extension-${n2}"
                        ></i>
                        <a href="/api/${r2}">${t2.name}</a>
                    </li>
                `;
        }
        return p`
                    <li class="${this._isAcive(r2) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
          this._toggle(r2);
        }}
                        >
                            ${e3}
                        </span>
                        ${((_a2 = this._menuStates[r2]) == null ? void 0 : _a2.opened) ? p`
                                  ${this._renderList(get$3(this._menuStack, r2), r2)}
                              ` : ""}
                    </li>
                `;
      });
      return p`
            <ul class="${a2 ? "" : "s-fs-tree"}">
                ${e2}
            </ul>
        `;
    }
    render() {
      return this._loaded ? p`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        ` : p`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
    }
  }
  function matches(e2, t2) {
    if (e2.nodeName != "#comment" && e2.nodeName != "#text") {
      var r2 = Element.prototype;
      const n2 = r2.matches || r2.webkitMatchesSelector || r2.mozMatchesSelector || r2.msMatchesSelector || function(e3) {
        return [].indexOf.call(document.querySelectorAll(e3), this) !== -1;
      };
      return n2.call(e2, t2);
    }
  }
  __decorateClass([e()], ConfigExplorerNav.prototype, "_loaded", 2), customElements.get("config-explorer-nav") || customElements.define("config-explorer-nav", ConfigExplorerNav);
  let _observer;
  const _selectors = {};
  function querySelectorLive(t2, e2 = null, r2 = {}) {
    var n2 = t2 + " - " + uniqid();
    return r2 = Object.assign({}, { rootNode: document, once: true }, r2), _selectors[t2] ? _selectors[t2].push({ id: n2, selector: t2, cb: e2, lastMutationId: null, settings: r2 }) : _selectors[t2] = [{ id: n2, selector: t2, cb: e2, lastMutationId: null, settings: r2 }], new SPromise(({ emit: i2 }) => {
      function a2(t3, e3, r3) {
        const n3 = _selectors[e3];
        n3 && n3.forEach((e4) => {
          if (!e4.lastMutationId || e4.lastMutationId !== r3) {
            if (e4.settings.once) {
              if (t3._querySelectorLive || (t3._querySelectorLive = {}), t3._querySelectorLive[e4.id])
                return;
              t3._querySelectorLive[e4.id] = true;
            }
            i2("node", t3), e4.cb && e4.cb(t3, () => {
              delete _selectors[e4.selector];
            });
          }
        });
      }
      _observer || (_observer = new MutationObserver((e3) => {
        const n3 = "mutation-" + uniqid();
        e3.forEach((t3) => {
          if (t3.addedNodes && t3.addedNodes.length)
            [].forEach.call(t3.addedNodes, (r3) => {
              const e4 = Object.keys(_selectors);
              e4.forEach((e5) => {
                matches(r3, e5) && a2(r3, e5, n3);
              }), r3.querySelectorAll && e4.forEach((t4) => {
                var e5 = r3.querySelectorAll(t4);
                [].forEach.call(e5, (e6) => {
                  a2(e6, t4, n3);
                });
              });
            });
          else if (t3.attributeName) {
            const e4 = Object.keys(_selectors);
            e4.forEach((e5) => {
              matches(t3.target, e5) && a2(t3.target, e5, n3);
            });
          }
        });
      }), _observer.observe(r2.rootNode, { childList: true, subtree: true, attributes: true, attributeFilter: ["class", "id"] })), [].forEach.call(r2.rootNode.querySelectorAll(t2), (e3) => {
        a2(e3, t2, "init");
      });
    });
  }
  var __awaiter$d = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SFeature extends SClass {
    constructor(e2, t2, r2 = {}) {
      super(__deepMerge$7({ componentUtils: {}, feature: {} }, r2)), this.componentUtils = new SComponent(t2, t2.attributes, { componentUtils: Object.assign(Object.assign({}, (r2 = this._settings.componentUtils) !== null && r2 !== void 0 ? r2 : {}), { name: e2 }) }), this.props = this.componentUtils.props, this.name = e2, this.node = t2, __awaiter$d(this, void 0, void 0, function* () {
        var e3;
        this.componentUtils.waitAndExecute((e3 = this.mount) === null || e3 === void 0 ? void 0 : e3.bind(this));
      });
    }
    static setDefaultProps(e2, t2) {
      SComponent.setDefaultProps(e2, t2);
    }
    static defineFeature(t2, r2, e2 = {}) {
      this.setDefaultProps(t2, e2), querySelectorLive(`[${t2}]`, (e3) => {
        new r2(t2, e3, SComponent.getDefaultProps(t2));
      });
    }
    get featureSettings() {
      return this._settings.feature;
    }
  }
  class SActivateFeatureInterface extends SInterface {
    static get _definition() {
      return { href: { description: "Specify the target element(s) to activate/unactivate", type: "String", default: "" }, group: { description: "Specify a group id for your element. This is used for things like tabs, etc...", type: "String" }, toggle: { description: "Specify if you want to be able to click on the same element to activate/unactivate it.", type: { type: "Boolean", nullishAsTrue: true }, default: false }, history: { description: "Specify if you want to store and react to history hash changes", type: { type: "Boolean", nullishAsTrue: true }, default: false }, active: { description: "Specify the initial state of your element", type: { type: "Boolean", nullishAsTrue: true }, default: false, physical: true }, activeClass: { description: 'Specify the class applied on target(s) when active. Default is "active"', type: "String", default: "active" }, activeAttribute: { description: "Specify the attribute name applied on target(s) when active.", type: "String", default: "active" }, saveState: { description: "Specify if you want to save state in localStorage to restore it on page reload, etc...", type: "Boolean", default: false }, activateTimeout: { description: "Specify a timeout before actiavting the target(s)", type: "Number", default: 0 }, unactivateTimeout: { description: "Specify a timeout before unactivate the target(s)", type: "Number", default: 0 }, trigger: { description: 'Specify what trigger an activate/unactivate action. Can be "click", "mouseover", "mouseout" and/or "anchor"', type: { type: "Array<String>", splitChars: [","] }, values: ["click", "mouseover", "mouseenter", "mouseout", "mouseleave", "anchor"], default: ["click"] } };
    }
  }
  var __awaiter$c = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SActivateFeature extends SFeature {
    constructor(e2, t2, r2) {
      super(e2, t2, __deepMerge$7({ componentUtils: { interface: SActivateFeatureInterface }, feature: {} }, r2 != null ? r2 : {})), this.componentUtils.exposeApi({ activate: this.activate, unactivate: this.unactivate, isActive: this.isActive }, this);
    }
    mount() {
      this._restoreState(), this.props.href && (this._hrefSelector = this.props.href);
      let e2;
      this._hrefSelector && (e2 = Array.from(document.querySelectorAll(this._hrefSelector))), e2 !== null && e2 !== void 0 && e2.length && (this._$targets = e2), this.props.group && (this._$groupElements = Array.from(document.querySelectorAll(`[${this.name}][group="${this.props.group}"]`))), this.props.trigger.forEach((e3) => {
        switch (e3) {
          case "click":
            this.node.addEventListener("click", (e4) => {
              this.isActive() && this.props.toggle ? this.unactivate() : this.activate();
            });
            break;
          case "mousenter":
          case "mouseover":
            this.node.addEventListener("mouseover", (e4) => {
              this.activate();
            });
            break;
          case "mouseout":
          case "mouseleave":
            this.node.addEventListener("mouseleave", (e4) => {
              this.unactivate();
            });
            break;
          case "anchor":
            document.location.hash === this._hrefSelector && this.activate(), window.addEventListener("hashchange", (e4) => {
              document.location.hash === this._hrefSelector && this.activate();
            });
        }
      });
    }
    get saveStateId() {
      return this.props.group ? "group-" + this.props.group : this.props.id;
    }
    isActive() {
      return this.node.hasAttribute("active");
    }
    _restoreState() {
      var e2;
      if (this.props.saveState) {
        if (!this.props.id)
          throw new Error('<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component');
        this.props.group ? ((e2 = JSON.parse((e2 = localStorage.getItem("s-activate-group-state-" + this.props.group)) !== null && e2 !== void 0 ? e2 : "{}")).activeId === this.props.id || !e2.activeId && this.props.active) && this.activate(true) : localStorage.getItem("s-activate-state-" + this.saveStateId) === this.props.id && this.activate(true);
      }
    }
    _saveState() {
      if (this.props.saveState) {
        if (!this.props.id)
          throw new Error('<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component');
        this.props.group ? localStorage.setItem("s-activate-group-state-" + this.props.group, JSON.stringify({ activeId: this.props.id })) : localStorage.setItem("s-activate-state-" + this.saveStateId, this.props.id);
      }
    }
    activate(e2 = false) {
      return __awaiter$c(this, void 0, void 0, function* () {
        clearTimeout(this._unactivateTimeout), !e2 && this.isActive() || setTimeout(() => {
          this._saveState(), this.props.history && this._hrefSelector && (document.location.hash = this._hrefSelector), this._$groupElements && this._$groupElements.forEach((e3) => {
            var t2;
            if (e3 !== this.node)
              try {
                (t2 = e3.unactivate) !== null && t2 !== void 0 && t2.call(e3);
              } catch (e4) {
              }
          }), this.props.active = true, this._$targets && this._$targets.forEach((e3) => {
            this.props.activeClass && e3.classList.add(this.props.activeClass), this.props.activeAttribute && e3.setAttribute(this.props.activeAttribute, "true");
          });
        }, this.props.activateTimeout);
      });
    }
    unactivate() {
      return __awaiter$c(this, void 0, void 0, function* () {
        this.isActive() && (this._unactivateTimeout = setTimeout(() => {
          if (this.props.saveState) {
            if (!this.props.id)
              throw new Error('<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component');
            localStorage.removeItem("s-activate-state-" + this.props.id);
          }
          this.node.removeAttribute("active"), this._$targets && this._$targets.forEach((e2) => {
            this.props.activeClass && e2.classList.remove(this.props.activeClass), this.props.activeAttribute && e2.removeAttribute(this.props.activeAttribute);
          });
        }, this.props.unactivateTimeout));
      });
    }
  }
  function define$f(e2 = {}, t2 = "s-activate") {
    SFeature.defineFeature(t2, SActivateFeature, e2);
  }
  var clipboardCopy_1 = clipboardCopy;
  function makeError() {
    return new DOMException("The request is not allowed", "NotAllowedError");
  }
  function copyClipboardApi(e2) {
    return __async(this, null, function* () {
      if (!navigator.clipboard)
        throw makeError();
      return navigator.clipboard.writeText(e2);
    });
  }
  function copyExecCommand(e2) {
    return __async(this, null, function* () {
      const t2 = document.createElement("span");
      t2.textContent = e2, t2.style.whiteSpace = "pre", t2.style.webkitUserSelect = "auto", t2.style.userSelect = "all", document.body.appendChild(t2);
      const r2 = window.getSelection(), n2 = window.document.createRange();
      r2.removeAllRanges(), n2.selectNode(t2), r2.addRange(n2);
      let i2 = false;
      try {
        i2 = window.document.execCommand("copy");
      } finally {
        r2.removeAllRanges(), window.document.body.removeChild(t2);
      }
      if (!i2)
        throw makeError();
    });
  }
  function clipboardCopy(e2) {
    return __async(this, null, function* () {
      try {
        yield copyClipboardApi(e2);
      } catch (t2) {
        try {
          yield copyExecCommand(e2);
        } catch (e3) {
          throw e3 || t2 || makeError();
        }
      }
    });
  }
  const standardProperty$2 = (t2, r2) => r2.kind !== "method" || !r2.descriptor || "value" in r2.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: r2.key, initializer() {
    typeof r2.initializer == "function" && (this[r2.key] = r2.initializer.call(this));
  }, finisher(e2) {
    e2.createProperty(r2.key, t2);
  } } : __spreadProps(__spreadValues({}, r2), { finisher(e2) {
    e2.createProperty(r2.key, t2);
  } }), legacyProperty$2 = (e2, t2, r2) => {
    t2.constructor.createProperty(r2, e2);
  };
  function property$2(r2) {
    return (e2, t2) => t2 !== void 0 ? legacyProperty$2(r2, e2, t2) : standardProperty$2(r2, e2);
  }
  class SHighlightJsComponentInterface$1 extends SInterface {
    static get _definition() {
      return { successTimeout: { description: 'Specify the duration for displaying the "success" icon', type: "Number", default: 1500 }, errorTimeout: { description: 'Specify the duration for displaying the "error" icon', type: "Number", default: 3e3 } };
    }
  }
  function copy(e2) {
    return clipboardCopy_1(e2);
  }
  function plainObject$6(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$6(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$6(a2[e4]) && plainObject$6(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  var __css$7 = ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0)) * 1%),calc((var(--s-theme-color-success-l, 0)) * 1%),var(--s-theme-color-success-a, 1));\n    }\n\n    .s-clipboard-copy[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    }\n\n    .s-clipboard-copy[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n", __decorate$4 = globalThis && globalThis.__decorate || function(e2, t2, r2, n2) {
    var i2, a2 = arguments.length, o2 = a2 < 3 ? t2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var s2 = e2.length - 1; 0 <= s2; s2--)
        (i2 = e2[s2]) && (o2 = (a2 < 3 ? i2(o2) : 3 < a2 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return 3 < a2 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class SClipboardCopy extends SLitComponent {
    constructor() {
      super(__deepMerge$6({ componentUtils: { interface: SHighlightJsComponentInterface$1 } })), this._state = "pending";
    }
    static get styles() {
      return r$2`
            ${o$3(__css$7)}
        `;
    }
    copy(e2) {
      this._state = "copy", copy(e2).then(() => {
        this._state = "success", setTimeout(() => {
          this._state = "pending";
        }, this.props.successTimeout);
      }).catch((e3) => {
        this._state = "error", setTimeout(() => {
          this._state = "pending";
        }, this.props.errorTimeout);
      });
    }
    render() {
      return p`
            <div
                class="${this.componentUtils.className("")}"
                state="${this._state}"
            >
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path
                            d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z"
                            fill="currentColor"
                        />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path
                            d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z"
                            fill="currentColor"
                        />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon
                        points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"
                    ></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
    }
  }
  function define$e(e2 = {}, t2 = "s-clipboard-copy") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SClipboardCopy);
  }
  function plainObject$5(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$5(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$5(a2[e4]) && plainObject$5(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  function wait$1(t2 = 0) {
    return new Promise((e2) => {
      setTimeout(() => {
        e2();
      }, t2);
    });
  }
  __decorate$4([property$2()], SClipboardCopy.prototype, "_state", void 0);
  var deepFreezeEs6 = { exports: {} };
  function deepFreeze(t2) {
    return t2 instanceof Map ? t2.clear = t2.delete = t2.set = function() {
      throw new Error("map is read-only");
    } : t2 instanceof Set && (t2.add = t2.clear = t2.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(t2), Object.getOwnPropertyNames(t2).forEach(function(e2) {
      e2 = t2[e2];
      typeof e2 != "object" || Object.isFrozen(e2) || deepFreeze(e2);
    }), t2;
  }
  deepFreezeEs6.exports = deepFreeze, deepFreezeEs6.exports.default = deepFreeze;
  var deepFreeze$1 = deepFreezeEs6.exports;
  class Response$1 {
    constructor(e2) {
      e2.data === void 0 && (e2.data = {}), this.data = e2.data, this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(e2) {
    return e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit$1(e2, ...t2) {
    const r2 = Object.create(null);
    for (const n2 in e2)
      r2[n2] = e2[n2];
    return t2.forEach(function(e3) {
      for (const t3 in e3)
        r2[t3] = e3[t3];
    }), r2;
  }
  const SPAN_CLOSE = "</span>", emitsWrappingTags = (e2) => !!e2.kind, expandScopeName = (e2, { prefix: t2 }) => {
    if (e2.includes(".")) {
      const r2 = e2.split(".");
      return ["" + t2 + r2.shift(), ...r2.map((e3, t3) => "" + e3 + "_".repeat(t3 + 1))].join(" ");
    }
    return "" + t2 + e2;
  };
  class HTMLRenderer {
    constructor(e2, t2) {
      this.buffer = "", this.classPrefix = t2.classPrefix, e2.walk(this);
    }
    addText(e2) {
      this.buffer += escapeHTML(e2);
    }
    openNode(t2) {
      if (emitsWrappingTags(t2)) {
        let e2 = t2.kind;
        e2 = t2.sublanguage ? "language-" + e2 : expandScopeName(e2, { prefix: this.classPrefix }), this.span(e2);
      }
    }
    closeNode(e2) {
      emitsWrappingTags(e2) && (this.buffer += SPAN_CLOSE);
    }
    value() {
      return this.buffer;
    }
    span(e2) {
      this.buffer += `<span class="${e2}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = { children: [] }, this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(e2) {
      this.top.children.push(e2);
    }
    openNode(e2) {
      e2 = { kind: e2, children: [] };
      this.add(e2), this.stack.push(e2);
    }
    closeNode() {
      if (1 < this.stack.length)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); )
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(e2) {
      return this.constructor._walk(e2, this.rootNode);
    }
    static _walk(t2, e2) {
      return typeof e2 == "string" ? t2.addText(e2) : e2.children && (t2.openNode(e2), e2.children.forEach((e3) => this._walk(t2, e3)), t2.closeNode(e2)), t2;
    }
    static _collapse(e2) {
      typeof e2 != "string" && e2.children && (e2.children.every((e3) => typeof e3 == "string") ? e2.children = [e2.children.join("")] : e2.children.forEach((e3) => {
        TokenTree._collapse(e3);
      }));
    }
  }
  class TokenTreeEmitter extends TokenTree {
    constructor(e2) {
      super(), this.options = e2;
    }
    addKeyword(e2, t2) {
      e2 !== "" && (this.openNode(t2), this.addText(e2), this.closeNode());
    }
    addText(e2) {
      e2 !== "" && this.add(e2);
    }
    addSublanguage(e2, t2) {
      const r2 = e2.root;
      r2.kind = t2, r2.sublanguage = true, this.add(r2);
    }
    toHTML() {
      const e2 = new HTMLRenderer(this, this.options);
      return e2.value();
    }
    finalize() {
      return true;
    }
  }
  function source(e2) {
    return e2 ? typeof e2 == "string" ? e2 : e2.source : null;
  }
  function lookahead(e2) {
    return concat("(?=", e2, ")");
  }
  function anyNumberOfTimes(e2) {
    return concat("(?:", e2, ")*");
  }
  function optional(e2) {
    return concat("(?:", e2, ")?");
  }
  function concat(...e2) {
    return e2.map((e3) => source(e3)).join("");
  }
  function stripOptionsFromArgs(e2) {
    var t2 = e2[e2.length - 1];
    return typeof t2 == "object" && t2.constructor === Object ? (e2.splice(e2.length - 1, 1), t2) : {};
  }
  function either(...e2) {
    return "(" + (stripOptionsFromArgs(e2).capture ? "" : "?:") + e2.map((e3) => source(e3)).join("|") + ")";
  }
  function countMatchGroups(e2) {
    return new RegExp(e2.toString() + "|").exec("").length - 1;
  }
  function startsWith(e2, t2) {
    t2 = e2 && e2.exec(t2);
    return t2 && t2.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function _rewriteBackreferences(e2, { joinWith: t2 }) {
    let a2 = 0;
    return e2.map((e3) => {
      a2 += 1;
      var t3 = a2;
      let r2 = source(e3), n2 = "";
      for (; 0 < r2.length; ) {
        var i2 = BACKREF_RE.exec(r2);
        if (!i2) {
          n2 += r2;
          break;
        }
        n2 += r2.substring(0, i2.index), r2 = r2.substring(i2.index + i2[0].length), i2[0][0] === "\\" && i2[1] ? n2 += "\\" + String(Number(i2[1]) + t3) : (n2 += i2[0], i2[0] === "(" && a2++);
      }
      return n2;
    }).map((e3) => `(${e3})`).join(t2);
  }
  const MATCH_NOTHING_RE = /\b\B/, IDENT_RE$1 = "[a-zA-Z]\\w*", UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*", NUMBER_RE = "\\b\\d+(\\.\\d+)?", C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", BINARY_NUMBER_RE = "\\b(0b[01]+)", RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", SHEBANG = (e2 = {}) => {
    var t2 = /^#![ ]*\//;
    return e2.binary && (e2.begin = concat(t2, /.*\b/, e2.binary, /\b.*/)), inherit$1({ scope: "meta", begin: t2, end: /$/, relevance: 0, "on:begin": (e3, t3) => {
      e3.index !== 0 && t3.ignoreMatch();
    } }, e2);
  }, BACKSLASH_ESCAPE = { begin: "\\\\[\\s\\S]", relevance: 0 }, APOS_STRING_MODE = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [BACKSLASH_ESCAPE] }, QUOTE_STRING_MODE = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [BACKSLASH_ESCAPE] }, PHRASAL_WORDS_MODE = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, COMMENT = function(e2, t2, r2 = {}) {
    const n2 = inherit$1({ scope: "comment", begin: e2, end: t2, contains: [] }, r2);
    n2.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: true, relevance: 0 });
    r2 = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
    return n2.contains.push({ begin: concat(/[ ]+/, "(", r2, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), n2;
  }, C_LINE_COMMENT_MODE = COMMENT("//", "$"), C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/"), HASH_COMMENT_MODE = COMMENT("#", "$"), NUMBER_MODE = { scope: "number", begin: NUMBER_RE, relevance: 0 }, C_NUMBER_MODE = { scope: "number", begin: C_NUMBER_RE, relevance: 0 }, BINARY_NUMBER_MODE = { scope: "number", begin: BINARY_NUMBER_RE, relevance: 0 }, REGEXP_MODE = { begin: /(?=\/[^/\n]*\/)/, contains: [{ scope: "regexp", begin: /\//, end: /\/[gimuy]*/, illegal: /\n/, contains: [BACKSLASH_ESCAPE, { begin: /\[/, end: /\]/, relevance: 0, contains: [BACKSLASH_ESCAPE] }] }] }, TITLE_MODE = { scope: "title", begin: IDENT_RE$1, relevance: 0 }, UNDERSCORE_TITLE_MODE = { scope: "title", begin: UNDERSCORE_IDENT_RE, relevance: 0 }, METHOD_GUARD = { begin: "\\.\\s*" + UNDERSCORE_IDENT_RE, relevance: 0 }, END_SAME_AS_BEGIN = function(e2) {
    return Object.assign(e2, { "on:begin": (e3, t2) => {
      t2.data._beginMatch = e3[1];
    }, "on:end": (e3, t2) => {
      t2.data._beginMatch !== e3[1] && t2.ignoreMatch();
    } });
  };
  var MODES$1 = Object.freeze({ __proto__: null, MATCH_NOTHING_RE, IDENT_RE: IDENT_RE$1, UNDERSCORE_IDENT_RE, NUMBER_RE, C_NUMBER_RE, BINARY_NUMBER_RE, RE_STARTERS_RE, SHEBANG, BACKSLASH_ESCAPE, APOS_STRING_MODE, QUOTE_STRING_MODE, PHRASAL_WORDS_MODE, COMMENT, C_LINE_COMMENT_MODE, C_BLOCK_COMMENT_MODE, HASH_COMMENT_MODE, NUMBER_MODE, C_NUMBER_MODE, BINARY_NUMBER_MODE, REGEXP_MODE, TITLE_MODE, UNDERSCORE_TITLE_MODE, METHOD_GUARD, END_SAME_AS_BEGIN });
  function skipIfHasPrecedingDot(e2, t2) {
    e2.input[e2.index - 1] === "." && t2.ignoreMatch();
  }
  function scopeClassName(e2, t2) {
    e2.className !== void 0 && (e2.scope = e2.className, delete e2.className);
  }
  function beginKeywords(e2, t2) {
    t2 && e2.beginKeywords && (e2.begin = "\\b(" + e2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e2.__beforeBegin = skipIfHasPrecedingDot, e2.keywords = e2.keywords || e2.beginKeywords, delete e2.beginKeywords, e2.relevance === void 0 && (e2.relevance = 0));
  }
  function compileIllegal(e2, t2) {
    Array.isArray(e2.illegal) && (e2.illegal = either(...e2.illegal));
  }
  function compileMatch(e2, t2) {
    if (e2.match) {
      if (e2.begin || e2.end)
        throw new Error("begin & end are not supported with match");
      e2.begin = e2.match, delete e2.match;
    }
  }
  function compileRelevance(e2, t2) {
    e2.relevance === void 0 && (e2.relevance = 1);
  }
  const beforeMatchExt = (t2, e2) => {
    if (t2.beforeMatch) {
      if (t2.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const r2 = Object.assign({}, t2);
      Object.keys(t2).forEach((e3) => {
        delete t2[e3];
      }), t2.keywords = r2.keywords, t2.begin = concat(r2.beforeMatch, lookahead(r2.begin)), t2.starts = { relevance: 0, contains: [Object.assign(r2, { endsParent: true })] }, t2.relevance = 0, delete r2.beforeMatch;
    }
  }, COMMON_KEYWORDS = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], DEFAULT_KEYWORD_SCOPE = "keyword";
  function compileKeywords(t2, r2, e2 = DEFAULT_KEYWORD_SCOPE) {
    const n2 = Object.create(null);
    return typeof t2 == "string" ? i2(e2, t2.split(" ")) : Array.isArray(t2) ? i2(e2, t2) : Object.keys(t2).forEach(function(e3) {
      Object.assign(n2, compileKeywords(t2[e3], r2, e3));
    }), n2;
    function i2(t3, e3) {
      (e3 = r2 ? e3.map((e4) => e4.toLowerCase()) : e3).forEach(function(e4) {
        e4 = e4.split("|");
        n2[e4[0]] = [t3, scoreForKeyword(e4[0], e4[1])];
      });
    }
  }
  function scoreForKeyword(e2, t2) {
    return t2 ? Number(t2) : commonKeyword(e2) ? 0 : 1;
  }
  function commonKeyword(e2) {
    return COMMON_KEYWORDS.includes(e2.toLowerCase());
  }
  const seenDeprecations = {}, error = (e2) => {
    console.error(e2);
  }, warn$1 = (e2, ...t2) => {
    console.log("WARN: " + e2, ...t2);
  }, deprecated = (e2, t2) => {
    seenDeprecations[e2 + "/" + t2] || (console.log(`Deprecated as of ${e2}. ` + t2), seenDeprecations[e2 + "/" + t2] = true);
  }, MultiClassError = new Error();
  function remapScopeNames(e2, t2, { key: r2 }) {
    let n2 = 0;
    var i2 = e2[r2];
    const a2 = {}, o2 = {};
    for (let e3 = 1; e3 <= t2.length; e3++)
      o2[e3 + n2] = i2[e3], a2[e3 + n2] = true, n2 += countMatchGroups(t2[e3 - 1]);
    e2[r2] = o2, e2[r2]._emit = a2, e2[r2]._multi = true;
  }
  function beginMultiClass(e2) {
    if (Array.isArray(e2.begin)) {
      if (e2.skip || e2.excludeBegin || e2.returnBegin)
        throw error("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), MultiClassError;
      if (typeof e2.beginScope != "object" || e2.beginScope === null)
        throw error("beginScope must be object"), MultiClassError;
      remapScopeNames(e2, e2.begin, { key: "beginScope" }), e2.begin = _rewriteBackreferences(e2.begin, { joinWith: "" });
    }
  }
  function endMultiClass(e2) {
    if (Array.isArray(e2.end)) {
      if (e2.skip || e2.excludeEnd || e2.returnEnd)
        throw error("skip, excludeEnd, returnEnd not compatible with endScope: {}"), MultiClassError;
      if (typeof e2.endScope != "object" || e2.endScope === null)
        throw error("endScope must be object"), MultiClassError;
      remapScopeNames(e2, e2.end, { key: "endScope" }), e2.end = _rewriteBackreferences(e2.end, { joinWith: "" });
    }
  }
  function scopeSugar(e2) {
    e2.scope && typeof e2.scope == "object" && e2.scope !== null && (e2.beginScope = e2.scope, delete e2.scope);
  }
  function MultiClass(e2) {
    scopeSugar(e2), typeof e2.beginScope == "string" && (e2.beginScope = { _wrap: e2.beginScope }), typeof e2.endScope == "string" && (e2.endScope = { _wrap: e2.endScope }), beginMultiClass(e2), endMultiClass(e2);
  }
  function compileLanguage(a2) {
    function o2(e2, t3) {
      return new RegExp(source(e2), "m" + (a2.case_insensitive ? "i" : "") + (a2.unicodeRegex ? "u" : "") + (t3 ? "g" : ""));
    }
    class t2 {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      addRule(e2, t3) {
        t3.position = this.position++, this.matchIndexes[this.matchAt] = t3, this.regexes.push([t3, e2]), this.matchAt += countMatchGroups(e2) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        var e2 = this.regexes.map((e3) => e3[1]);
        this.matcherRe = o2(_rewriteBackreferences(e2, { joinWith: "|" }), true), this.lastIndex = 0;
      }
      exec(e2) {
        this.matcherRe.lastIndex = this.lastIndex;
        const t3 = this.matcherRe.exec(e2);
        if (!t3)
          return null;
        var r2 = t3.findIndex((e3, t4) => 0 < t4 && e3 !== void 0), e2 = this.matchIndexes[r2];
        return t3.splice(0, r2), Object.assign(t3, e2);
      }
    }
    class s2 {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      getMatcher(e2) {
        if (this.multiRegexes[e2])
          return this.multiRegexes[e2];
        const r2 = new t2();
        return this.rules.slice(e2).forEach(([e3, t3]) => r2.addRule(e3, t3)), r2.compile(), this.multiRegexes[e2] = r2, r2;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(e2, t3) {
        this.rules.push([e2, t3]), t3.type === "begin" && this.count++;
      }
      exec(e2) {
        const t3 = this.getMatcher(this.regexIndex);
        t3.lastIndex = this.lastIndex;
        let r2 = t3.exec(e2);
        if (this.resumingScanAtSamePosition() && (!r2 || r2.index !== this.lastIndex)) {
          const n2 = this.getMatcher(0);
          n2.lastIndex = this.lastIndex + 1, r2 = n2.exec(e2);
        }
        return r2 && (this.regexIndex += r2.position + 1, this.regexIndex === this.count && this.considerAll()), r2;
      }
    }
    if (a2.compilerExtensions || (a2.compilerExtensions = []), a2.contains && a2.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return a2.classNameAliases = inherit$1(a2.classNameAliases || {}), function t3(r2, n2) {
      const i2 = r2;
      if (r2.isCompiled)
        return i2;
      [scopeClassName, compileMatch, MultiClass, beforeMatchExt].forEach((e3) => e3(r2, n2)), a2.compilerExtensions.forEach((e3) => e3(r2, n2)), r2.__beforeBegin = null, [beginKeywords, compileIllegal, compileRelevance].forEach((e3) => e3(r2, n2)), r2.isCompiled = true;
      let e2 = null;
      return typeof r2.keywords == "object" && r2.keywords.$pattern && (r2.keywords = Object.assign({}, r2.keywords), e2 = r2.keywords.$pattern, delete r2.keywords.$pattern), e2 = e2 || /\w+/, r2.keywords && (r2.keywords = compileKeywords(r2.keywords, a2.case_insensitive)), i2.keywordPatternRe = o2(e2, true), n2 && (r2.begin || (r2.begin = /\B|\b/), i2.beginRe = o2(i2.begin), r2.end || r2.endsWithParent || (r2.end = /\B|\b/), r2.end && (i2.endRe = o2(i2.end)), i2.terminatorEnd = source(i2.end) || "", r2.endsWithParent && n2.terminatorEnd && (i2.terminatorEnd += (r2.end ? "|" : "") + n2.terminatorEnd)), r2.illegal && (i2.illegalRe = o2(r2.illegal)), r2.contains || (r2.contains = []), r2.contains = [].concat(...r2.contains.map(function(e3) {
        return expandOrCloneMode(e3 === "self" ? r2 : e3);
      })), r2.contains.forEach(function(e3) {
        t3(e3, i2);
      }), r2.starts && t3(r2.starts, n2), i2.matcher = function(e3) {
        const t4 = new s2();
        return e3.contains.forEach((e4) => t4.addRule(e4.begin, { rule: e4, type: "begin" })), e3.terminatorEnd && t4.addRule(e3.terminatorEnd, { type: "end" }), e3.illegal && t4.addRule(e3.illegal, { type: "illegal" }), t4;
      }(i2), i2;
    }(a2);
  }
  function dependencyOnParent(e2) {
    return !!e2 && (e2.endsWithParent || dependencyOnParent(e2.starts));
  }
  function expandOrCloneMode(t2) {
    return t2.variants && !t2.cachedVariants && (t2.cachedVariants = t2.variants.map(function(e2) {
      return inherit$1(t2, { variants: null }, e2);
    })), t2.cachedVariants || (dependencyOnParent(t2) ? inherit$1(t2, { starts: t2.starts ? inherit$1(t2.starts) : null }) : Object.isFrozen(t2) ? inherit$1(t2) : t2);
  }
  var version = "11.3.1";
  class HTMLInjectionError extends Error {
    constructor(e2, t2) {
      super(e2), this.name = "HTMLInjectionError", this.html = t2;
    }
  }
  const escape$1 = escapeHTML, inherit = inherit$1, NO_MATCH = Symbol("nomatch"), MAX_KEYWORD_HITS = 7, HLJS = function(n2) {
    const T2 = Object.create(null), o2 = Object.create(null), i2 = [];
    let k2 = true;
    const A2 = "Could not find the language '{}', did you forget to load/include a language module?", a2 = { disableAutodetect: true, name: "Plain text", contains: [] };
    let C2 = { ignoreUnescapedHTML: false, throwUnescapedHTML: false, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: TokenTreeEmitter };
    function s2(e3) {
      return C2.noHighlightRe.test(e3);
    }
    function l2(e3, t3, r3) {
      let n3 = "", i3 = "";
      typeof t3 == "object" ? (n3 = e3, r3 = t3.ignoreIllegals, i3 = t3.language) : (deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated."), deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), i3 = e3, n3 = t3), r3 === void 0 && (r3 = true);
      t3 = { code: n3, language: i3 };
      h2("before:highlight", t3);
      const a3 = t3.result || $2(t3.language, t3.code, r3);
      return a3.code = t3.code, h2("after:highlight", a3), a3;
    }
    function $2(a3, o3, s3, e3) {
      const l3 = Object.create(null);
      function c3() {
        if (g2.keywords) {
          let e4 = 0;
          g2.keywordPatternRe.lastIndex = 0;
          let t4 = g2.keywordPatternRe.exec(_2), r4 = "";
          for (; t4; ) {
            r4 += _2.substring(e4, t4.index);
            var n4 = m2.case_insensitive ? t4[0].toLowerCase() : t4[0], i4 = g2.keywords[n4];
            if (i4) {
              const [a4, o4] = i4;
              y.addText(r4), r4 = "", l3[n4] = (l3[n4] || 0) + 1, l3[n4] <= MAX_KEYWORD_HITS && (b2 += o4), a4.startsWith("_") ? r4 += t4[0] : (n4 = m2.classNameAliases[a4] || a4, y.addKeyword(t4[0], n4));
            } else
              r4 += t4[0];
            e4 = g2.keywordPatternRe.lastIndex, t4 = g2.keywordPatternRe.exec(_2);
          }
          r4 += _2.substr(e4), y.addText(r4);
        } else
          y.addText(_2);
      }
      function u3() {
        (g2.subLanguage != null ? function() {
          if (_2 !== "") {
            let e4 = null;
            if (typeof g2.subLanguage == "string") {
              if (!T2[g2.subLanguage])
                return y.addText(_2);
              e4 = $2(g2.subLanguage, _2, true, v2[g2.subLanguage]), v2[g2.subLanguage] = e4._top;
            } else
              e4 = R2(_2, g2.subLanguage.length ? g2.subLanguage : null);
            0 < g2.relevance && (b2 += e4.relevance), y.addSublanguage(e4._emitter, e4.language);
          }
        } : c3)(), _2 = "";
      }
      function i3(e4, t4) {
        let r4 = 1;
        for (; t4[r4] !== void 0; ) {
          var n4, i4;
          e4._emit[r4] ? (n4 = m2.classNameAliases[e4[r4]] || e4[r4], i4 = t4[r4], n4 ? y.addKeyword(i4, n4) : (_2 = i4, c3(), _2 = ""), r4++) : r4++;
        }
      }
      function h3(e4, t4) {
        return e4.scope && typeof e4.scope == "string" && y.openNode(m2.classNameAliases[e4.scope] || e4.scope), e4.beginScope && (e4.beginScope._wrap ? (y.addKeyword(_2, m2.classNameAliases[e4.beginScope._wrap] || e4.beginScope._wrap), _2 = "") : e4.beginScope._multi && (i3(e4.beginScope, t4), _2 = "")), g2 = Object.create(e4, { parent: { value: g2 } }), g2;
      }
      function d2(e4) {
        var t4, r4 = e4[0], n4 = e4.rule, i4 = new Response$1(n4);
        for (const a4 of [n4.__beforeBegin, n4["on:begin"]])
          if (a4 && (a4(e4, i4), i4.isMatchIgnored))
            return t4 = r4, g2.matcher.regexIndex === 0 ? (_2 += t4[0], 1) : (S2 = true, 0);
        return n4.skip ? _2 += r4 : (n4.excludeBegin && (_2 += r4), u3(), n4.returnBegin || n4.excludeBegin || (_2 = r4)), h3(n4, e4), n4.returnBegin ? 0 : r4.length;
      }
      function p2(e4) {
        var t4 = e4[0], r4 = o3.substr(e4.index), n4 = function e5(t5, r5, n5) {
          let i4 = startsWith(t5.endRe, n5);
          var a4;
          if (i4 && (t5["on:end"] && (a4 = new Response$1(t5), t5["on:end"](r5, a4), a4.isMatchIgnored && (i4 = false)), i4)) {
            for (; t5.endsParent && t5.parent; )
              t5 = t5.parent;
            return t5;
          }
          if (t5.endsWithParent)
            return e5(t5.parent, r5, n5);
        }(g2, e4, r4);
        if (!n4)
          return NO_MATCH;
        r4 = g2;
        for (g2.endScope && g2.endScope._wrap ? (u3(), y.addKeyword(t4, g2.endScope._wrap)) : g2.endScope && g2.endScope._multi ? (u3(), i3(g2.endScope, e4)) : r4.skip ? _2 += t4 : (r4.returnEnd || r4.excludeEnd || (_2 += t4), u3(), r4.excludeEnd && (_2 = t4)); g2.scope && y.closeNode(), g2.skip || g2.subLanguage || (b2 += g2.relevance), g2 = g2.parent, g2 !== n4.parent; )
          ;
        return n4.starts && h3(n4.starts, e4), r4.returnEnd ? 0 : t4.length;
      }
      let f2 = {};
      function t3(e4, t4) {
        var r4 = t4 && t4[0];
        if (_2 += e4, r4 == null)
          return u3(), 0;
        if (f2.type === "begin" && t4.type === "end" && f2.index === t4.index && r4 === "") {
          if (_2 += o3.slice(t4.index, t4.index + 1), k2)
            return 1;
          {
            const n4 = new Error(`0 width match regex (${a3})`);
            throw n4.languageName = a3, n4.badRule = f2.rule, n4;
          }
        }
        if ((f2 = t4).type === "begin")
          return d2(t4);
        if (t4.type === "illegal" && !s3) {
          const i4 = new Error('Illegal lexeme "' + r4 + '" for mode "' + (g2.scope || "<unnamed>") + '"');
          throw i4.mode = g2, i4;
        }
        if (t4.type === "end") {
          e4 = p2(t4);
          if (e4 !== NO_MATCH)
            return e4;
        }
        if (t4.type === "illegal" && r4 === "")
          return 1;
        if (1e5 < w2 && w2 > 3 * t4.index)
          throw new Error("potential infinite loop, way more iterations than matches");
        return _2 += r4, r4.length;
      }
      const m2 = L(a3);
      if (!m2)
        throw error(A2.replace("{}", a3)), new Error('Unknown language: "' + a3 + '"');
      var r3 = compileLanguage(m2);
      let n3 = "", g2 = e3 || r3;
      const v2 = {}, y = new C2.__emitter(C2);
      !function() {
        const t4 = [];
        for (let e4 = g2; e4 !== m2; e4 = e4.parent)
          e4.scope && t4.unshift(e4.scope);
        t4.forEach((e4) => y.openNode(e4));
      }();
      let _2 = "", b2 = 0, x2 = 0, w2 = 0, S2 = false;
      try {
        for (g2.matcher.considerAll(); ; ) {
          w2++, S2 ? S2 = false : g2.matcher.considerAll(), g2.matcher.lastIndex = x2;
          var M2 = g2.matcher.exec(o3);
          if (!M2)
            break;
          var E2 = t3(o3.substring(x2, M2.index), M2);
          x2 = M2.index + E2;
        }
        return t3(o3.substr(x2)), y.closeAllNodes(), y.finalize(), n3 = y.toHTML(), { language: a3, value: n3, relevance: b2, illegal: false, _emitter: y, _top: g2 };
      } catch (e4) {
        if (e4.message && e4.message.includes("Illegal"))
          return { language: a3, value: escape$1(o3), illegal: true, relevance: 0, _illegalBy: { message: e4.message, index: x2, context: o3.slice(x2 - 100, x2 + 100), mode: e4.mode, resultSoFar: n3 }, _emitter: y };
        if (k2)
          return { language: a3, value: escape$1(o3), illegal: false, relevance: 0, errorRaised: e4, _emitter: y, _top: g2 };
        throw e4;
      }
    }
    function R2(t3, e3) {
      e3 = e3 || C2.languages || Object.keys(T2);
      var r3 = function(e4) {
        const t4 = { value: escape$1(e4), illegal: false, relevance: 0, _top: a2, _emitter: new C2.__emitter(C2) };
        return t4._emitter.addText(e4), t4;
      }(t3);
      const n3 = e3.filter(L).filter(u2).map((e4) => $2(e4, t3, false));
      n3.unshift(r3);
      var [e3, r3] = n3.sort((e4, t4) => {
        if (e4.relevance !== t4.relevance)
          return t4.relevance - e4.relevance;
        if (e4.language && t4.language) {
          if (L(e4.language).supersetOf === t4.language)
            return 1;
          if (L(t4.language).supersetOf === e4.language)
            return -1;
        }
        return 0;
      });
      const i3 = e3;
      return i3.secondBest = r3, i3;
    }
    function t2(e3) {
      var t3 = function(e4) {
        let t4 = e4.className + " ";
        t4 += e4.parentNode ? e4.parentNode.className : "";
        var r4 = C2.languageDetectRe.exec(t4);
        if (r4) {
          var n4 = L(r4[1]);
          return n4 || (warn$1(A2.replace("{}", r4[1])), warn$1("Falling back to no-highlight mode for this block.", e4)), n4 ? r4[1] : "no-highlight";
        }
        return t4.split(/\s+/).find((e5) => s2(e5) || L(e5));
      }(e3);
      if (!s2(t3)) {
        if (h2("before:highlightElement", { el: e3, language: t3 }), 0 < e3.children.length) {
          if (C2.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/issues/2886"), console.warn(e3)), C2.throwUnescapedHTML)
            throw new HTMLInjectionError("One of your code blocks includes unescaped HTML.", e3.innerHTML);
        }
        var r3, n3, i3 = e3.textContent, a3 = t3 ? l2(i3, { language: t3, ignoreIllegals: true }) : R2(i3);
        e3.innerHTML = a3.value, r3 = e3, n3 = t3, t3 = a3.language, t3 = n3 && o2[n3] || t3, r3.classList.add("hljs"), r3.classList.add("language-" + t3), e3.result = { language: a3.language, re: a3.relevance, relevance: a3.relevance }, a3.secondBest && (e3.secondBest = { language: a3.secondBest.language, relevance: a3.secondBest.relevance }), h2("after:highlightElement", { el: e3, result: a3, text: i3 });
      }
    }
    let r2 = false;
    function e2() {
      if (document.readyState !== "loading") {
        const e3 = document.querySelectorAll(C2.cssSelector);
        e3.forEach(t2);
      } else
        r2 = true;
    }
    function L(e3) {
      return e3 = (e3 || "").toLowerCase(), T2[e3] || T2[o2[e3]];
    }
    function c2(e3, { languageName: t3 }) {
      (e3 = typeof e3 == "string" ? [e3] : e3).forEach((e4) => {
        o2[e4.toLowerCase()] = t3;
      });
    }
    function u2(e3) {
      e3 = L(e3);
      return e3 && !e3.disableAutodetect;
    }
    function h2(e3, t3) {
      const r3 = e3;
      i2.forEach(function(e4) {
        e4[r3] && e4[r3](t3);
      });
    }
    typeof window != "undefined" && window.addEventListener && window.addEventListener("DOMContentLoaded", function() {
      r2 && e2();
    }, false), Object.assign(n2, { highlight: l2, highlightAuto: R2, highlightAll: e2, highlightElement: t2, highlightBlock: function(e3) {
      return deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0"), deprecated("10.7.0", "Please use highlightElement now."), t2(e3);
    }, configure: function(e3) {
      C2 = inherit(C2, e3);
    }, initHighlighting: () => {
      e2(), deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    }, initHighlightingOnLoad: function() {
      e2(), deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }, registerLanguage: function(t3, e3) {
      let r3 = null;
      try {
        r3 = e3(n2);
      } catch (e4) {
        if (error("Language definition for '{}' could not be registered.".replace("{}", t3)), !k2)
          throw e4;
        error(e4), r3 = a2;
      }
      r3.name || (r3.name = t3), T2[t3] = r3, r3.rawDefinition = e3.bind(null, n2), r3.aliases && c2(r3.aliases, { languageName: t3 });
    }, unregisterLanguage: function(e3) {
      delete T2[e3];
      for (const t3 of Object.keys(o2))
        o2[t3] === e3 && delete o2[t3];
    }, listLanguages: function() {
      return Object.keys(T2);
    }, getLanguage: L, registerAliases: c2, autoDetection: u2, inherit, addPlugin: function(e3) {
      var t3;
      (t3 = e3)["before:highlightBlock"] && !t3["before:highlightElement"] && (t3["before:highlightElement"] = (e4) => {
        t3["before:highlightBlock"](Object.assign({ block: e4.el }, e4));
      }), t3["after:highlightBlock"] && !t3["after:highlightElement"] && (t3["after:highlightElement"] = (e4) => {
        t3["after:highlightBlock"](Object.assign({ block: e4.el }, e4));
      }), i2.push(e3);
    } }), n2.debugMode = function() {
      k2 = false;
    }, n2.safeMode = function() {
      k2 = true;
    }, n2.versionString = version, n2.regex = { concat, lookahead, either, optional, anyNumberOfTimes };
    for (const d2 in MODES$1)
      typeof MODES$1[d2] == "object" && deepFreeze$1(MODES$1[d2]);
    return Object.assign(n2, MODES$1), n2;
  };
  var highlight = HLJS({}), core = highlight, _a$2, _b$2, _c$2, _d$2;
  function bash(e2) {
    const t2 = e2.regex;
    var r2 = {}, n2 = { begin: /\$\{/, end: /\}/, contains: ["self", { begin: /:-/, contains: [r2] }] };
    Object.assign(r2, { className: "variable", variants: [{ begin: t2.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") }, n2] });
    const i2 = { className: "subst", begin: /\$\(/, end: /\)/, contains: [e2.BACKSLASH_ESCAPE] };
    var a2 = { begin: /<<-?\s*(?=\w+)/, starts: { contains: [e2.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: "string" })] } }, o2 = { className: "string", begin: /"/, end: /"/, contains: [e2.BACKSLASH_ESCAPE, r2, i2] };
    i2.contains.push(o2);
    var s2 = { begin: /\$\(\(/, end: /\)\)/, contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, e2.NUMBER_MODE, r2] }, l2 = e2.SHEBANG({ binary: `(${["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"].join("|")})`, relevance: 10 }), n2 = { className: "function", begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/, returnBegin: true, contains: [e2.inherit(e2.TITLE_MODE, { begin: /\w[\w\d_]*/ })], relevance: 0 };
    return { name: "Bash", aliases: ["sh"], keywords: { $pattern: /\b[a-z._-]+\b/, keyword: ["if", "then", "else", "elif", "fi", "for", "while", "in", "do", "done", "case", "esac", "function"], literal: ["true", "false"], built_in: ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset", "alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "type", "typeset", "ulimit", "unalias", "set", "shopt", "autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp", "chcon", "chgrp", "chown", "chmod", "cp", "dd", "df", "dir", "dircolors", "ln", "ls", "mkdir", "mkfifo", "mknod", "mktemp", "mv", "realpath", "rm", "rmdir", "shred", "sync", "touch", "truncate", "vdir", "b2sum", "base32", "base64", "cat", "cksum", "comm", "csplit", "cut", "expand", "fmt", "fold", "head", "join", "md5sum", "nl", "numfmt", "od", "paste", "ptx", "pr", "sha1sum", "sha224sum", "sha256sum", "sha384sum", "sha512sum", "shuf", "sort", "split", "sum", "tac", "tail", "tr", "tsort", "unexpand", "uniq", "wc", "arch", "basename", "chroot", "date", "dirname", "du", "echo", "env", "expr", "factor", "groups", "hostid", "id", "link", "logname", "nice", "nohup", "nproc", "pathchk", "pinky", "printenv", "printf", "pwd", "readlink", "runcon", "seq", "sleep", "stat", "stdbuf", "stty", "tee", "test", "timeout", "tty", "uname", "unlink", "uptime", "users", "who", "whoami", "yes"] }, contains: [l2, e2.SHEBANG(), n2, s2, e2.HASH_COMMENT_MODE, a2, { match: /(\/[a-z._-]+)+/ }, o2, { className: "", begin: /\\"/ }, { className: "string", begin: /'/, end: /'/ }, r2] };
  }
  highlight.HighlightJS = highlight, highlight.default = highlight;
  const MODES = (e2) => ({ IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: e2.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: e2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ } }), TAGS = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], MEDIA_FEATURES = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"], PSEUDO_CLASSES = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"], PSEUDO_ELEMENTS = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"], ATTRIBUTES = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-height", "max-width", "min-height", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse();
  function css(e2) {
    const t2 = e2.regex;
    var r2 = MODES(e2), e2 = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE];
    return { name: "CSS", case_insensitive: true, illegal: /[=|'\$]/, keywords: { keyframePosition: "from to" }, classNameAliases: { keyframePosition: "selector-tag" }, contains: [r2.BLOCK_COMMENT, { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, r2.CSS_NUMBER_MODE, { className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 }, { className: "selector-class", begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*", relevance: 0 }, r2.ATTRIBUTE_SELECTOR_MODE, { className: "selector-pseudo", variants: [{ begin: ":(" + PSEUDO_CLASSES.join("|") + ")" }, { begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")" }] }, r2.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b" }, { begin: /:/, end: /[;}{]/, contains: [r2.BLOCK_COMMENT, r2.HEXCOLOR, r2.IMPORTANT, r2.CSS_NUMBER_MODE, ...e2, { begin: /(url|data-uri)\(/, end: /\)/, relevance: 0, keywords: { built_in: "url data-uri" }, contains: [{ className: "string", begin: /[^)]/, endsWithParent: true, excludeEnd: true }] }, r2.FUNCTION_DISPATCH] }, { begin: t2.lookahead(/@/), end: "[{;]", relevance: 0, illegal: /:/, contains: [{ className: "keyword", begin: /@-?\w[\w]*(-\w+)*/ }, { begin: /\s/, endsWithParent: true, excludeEnd: true, relevance: 0, keywords: { $pattern: /[a-z-]+/, keyword: "and or not only", attribute: MEDIA_FEATURES.join(" ") }, contains: [{ begin: /[a-z-]+(?=:)/, className: "attribute" }, ...e2, r2.CSS_NUMBER_MODE] }] }, { className: "selector-tag", begin: "\\b(" + TAGS.join("|") + ")\\b" }] };
  }
  const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*", KEYWORDS = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], LITERALS = ["true", "false", "null", "undefined", "NaN", "Infinity"], TYPES = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], ERROR_TYPES = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], BUILT_IN_GLOBALS = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], BUILT_IN_VARIABLES = ["arguments", "this", "super", "console", "window", "document", "localStorage", "module", "global"], BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
  function javascript(e2) {
    const t2 = e2.regex;
    var r2 = IDENT_RE;
    const n2 = "<>", i2 = "</>";
    const a2 = /<[A-Za-z0-9\\._:-]+/, o2 = /\/[A-Za-z0-9\\._:-]+>|\/>/, s2 = (e3, t3) => {
      var r3, n3, i3 = e3[0].length + e3.index, a3 = e3.input[i3];
      if (a3 !== "<" && a3 !== ",") {
        a3 === ">" && ([r3, n3] = [e3, { after: i3 }["after"]], a3 = "</" + r3[0].slice(1), r3.input.indexOf(a3, n3) === -1 && t3.ignoreMatch());
        const o3 = e3.input.substr(i3);
        (i3 = o3.match(/^\s+extends\s+/)) && i3.index === 0 && t3.ignoreMatch();
      } else
        t3.ignoreMatch();
    };
    var l2 = { $pattern: IDENT_RE, keyword: KEYWORDS, literal: LITERALS, built_in: BUILT_INS, "variable.language": BUILT_IN_VARIABLES }, c2 = "[0-9](_?[0-9])*", u2 = `\\.(${c2})`, h2 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d2 = { className: "number", variants: [{ begin: `(\\b(${h2})((${u2})|\\.)?|(${u2}))[eE][+-]?(${c2})\\b` }, { begin: `\\b(${h2})\\b((${u2})\\b|\\.)?|(${u2})\\b` }, { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" }, { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" }, { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, { begin: "\\b0[0-7]+n?\\b" }], relevance: 0 };
    const p2 = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: l2, contains: [] };
    var f2 = { begin: "html`", end: "", starts: { end: "`", returnEnd: false, contains: [e2.BACKSLASH_ESCAPE, p2], subLanguage: "xml" } }, m2 = { begin: "css`", end: "", starts: { end: "`", returnEnd: false, contains: [e2.BACKSLASH_ESCAPE, p2], subLanguage: "css" } }, g2 = { className: "string", begin: "`", end: "`", contains: [e2.BACKSLASH_ESCAPE, p2] }, v2 = { className: "comment", variants: [e2.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }, { className: "type", begin: "\\{", end: "\\}", excludeEnd: true, excludeBegin: true, relevance: 0 }, { className: "variable", begin: r2 + "(?=\\s*(-)|$)", endsParent: true, relevance: 0 }, { begin: /(?=[^\n])\s/, relevance: 0 }] }] }), e2.C_BLOCK_COMMENT_MODE, e2.C_LINE_COMMENT_MODE] };
    const y = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, f2, m2, g2, d2];
    p2.contains = y.concat({ begin: /\{/, end: /\}/, keywords: l2, contains: ["self"].concat(y) });
    const _2 = [].concat(v2, p2.contains);
    var b2 = _2.concat([{ begin: /\(/, end: /\)/, keywords: l2, contains: ["self"].concat(_2) }]), x2 = { className: "params", begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: l2, contains: b2 }, w2 = { variants: [{ match: [/class/, /\s+/, r2, /\s+/, /extends/, /\s+/, t2.concat(r2, "(", t2.concat(/\./, r2), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } }, { match: [/class/, /\s+/, r2], scope: { 1: "keyword", 3: "title.class" } }] }, S2 = { relevance: 0, match: t2.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]+|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+/), className: "title.class", keywords: { _: [...TYPES, ...ERROR_TYPES] } }, M2 = { variants: [{ match: [/function/, /\s+/, r2, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [x2], illegal: /%/ };
    var E2, T2 = { match: t2.concat(/\b/, (E2 = [...BUILT_IN_GLOBALS, "super"], t2.concat("(?!", E2.join("|"), ")")), r2, t2.lookahead(/\(/)), className: "title.function", relevance: 0 }, k2 = { begin: t2.concat(/\./, t2.lookahead(t2.concat(r2, /(?![0-9A-Za-z$_(])/))), end: r2, excludeBegin: true, keywords: "prototype", className: "property", relevance: 0 }, c2 = { match: [/get|set/, /\s+/, r2, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{ begin: /\(\)/ }, x2] }, h2 = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e2.UNDERSCORE_IDENT_RE + ")\\s*=>", u2 = { match: [/const|var|let/, /\s+/, r2, /\s*/, /=\s*/, t2.lookahead(h2)], className: { 1: "keyword", 3: "title.function" }, contains: [x2] };
    return { name: "Javascript", aliases: ["js", "jsx", "mjs", "cjs"], keywords: l2, exports: { PARAMS_CONTAINS: b2, CLASS_REFERENCE: S2 }, illegal: /#(?![$_A-z])/, contains: [e2.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, f2, m2, g2, v2, d2, S2, { className: "attr", begin: r2 + t2.lookahead(":"), relevance: 0 }, u2, { begin: "(" + e2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*", keywords: "return throw case", relevance: 0, contains: [v2, e2.REGEXP_MODE, { className: "function", begin: h2, returnBegin: true, end: "\\s*=>", contains: [{ className: "params", variants: [{ begin: e2.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: true }, { begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: l2, contains: b2 }] }] }, { begin: /,/, relevance: 0 }, { match: /\s+/, relevance: 0 }, { variants: [{ begin: n2, end: i2 }, { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ }, { begin: a2, "on:begin": s2, end: o2 }], subLanguage: "xml", contains: [{ begin: a2, end: o2, skip: true, contains: ["self"] }] }] }, M2, { beginKeywords: "while if switch catch for" }, { begin: "\\b(?!function)" + e2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{", returnBegin: true, label: "func.def", contains: [x2, e2.inherit(e2.TITLE_MODE, { begin: r2, className: "title.function" })] }, { match: /\.\.\./, relevance: 0 }, k2, { match: "\\$" + r2, relevance: 0 }, { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [x2] }, T2, { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" }, w2, c2, { match: /\$[(.]/ }] };
  }
  function php(e2) {
    var t2 = { className: "variable", begin: "\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])" }, r2 = { className: "meta", variants: [{ begin: /<\?php/, relevance: 10 }, { begin: /<\?[=]?/ }, { begin: /\?>/ }] }, n2 = { className: "subst", variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] }, i2 = e2.inherit(e2.APOS_STRING_MODE, { illegal: null }), a2 = e2.inherit(e2.QUOTE_STRING_MODE, { illegal: null, contains: e2.QUOTE_STRING_MODE.contains.concat(n2) }), n2 = e2.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*(\w+)\n/, end: /[ \t]*(\w+)\b/, contains: e2.QUOTE_STRING_MODE.contains.concat(n2) }), a2 = { className: "string", contains: [e2.BACKSLASH_ESCAPE, r2], variants: [e2.inherit(i2, { begin: "b'", end: "'" }), e2.inherit(a2, { begin: 'b"', end: '"' }), a2, i2, n2] }, i2 = { className: "number", variants: [{ begin: "\\b0b[01]+(?:_[01]+)*\\b" }, { begin: "\\b0o[0-7]+(?:_[0-7]+)*\\b" }, { begin: "\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b" }, { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?" }], relevance: 0 }, n2 = { keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield", literal: "false null true", built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass" };
    return { case_insensitive: true, keywords: n2, contains: [e2.HASH_COMMENT_MODE, e2.COMMENT("//", "$", { contains: [r2] }), e2.COMMENT("/\\*", "\\*/", { contains: [{ className: "doctag", begin: "@[A-Za-z]+" }] }), e2.COMMENT("__halt_compiler.+?;", false, { endsWithParent: true, keywords: "__halt_compiler" }), r2, { className: "keyword", begin: /\$this\b/ }, t2, { begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/ }, { className: "function", relevance: 0, beginKeywords: "fn function", end: /[;{]/, excludeEnd: true, illegal: "[$%\\[]", contains: [{ beginKeywords: "use" }, e2.UNDERSCORE_TITLE_MODE, { begin: "=>", endsParent: true }, { className: "params", begin: "\\(", end: "\\)", excludeBegin: true, excludeEnd: true, keywords: n2, contains: ["self", t2, e2.C_BLOCK_COMMENT_MODE, a2, i2] }] }, { className: "class", variants: [{ beginKeywords: "enum", illegal: /[($"]/ }, { beginKeywords: "class interface trait", illegal: /[:($"]/ }], relevance: 0, end: /\{/, excludeEnd: true, contains: [{ beginKeywords: "extends implements" }, e2.UNDERSCORE_TITLE_MODE] }, { beginKeywords: "namespace", relevance: 0, end: ";", illegal: /[.']/, contains: [e2.UNDERSCORE_TITLE_MODE] }, { beginKeywords: "use", relevance: 0, end: ";", contains: [e2.UNDERSCORE_TITLE_MODE] }, a2, i2] };
  }
  function xml(e2) {
    const t2 = e2.regex;
    var r2 = t2.concat(/[A-Z_]/, t2.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/), n2 = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ }, i2 = { begin: /\s/, contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] }, a2 = e2.inherit(i2, { begin: /\(/, end: /\)/ }), o2 = e2.inherit(e2.APOS_STRING_MODE, { className: "string" }), s2 = e2.inherit(e2.QUOTE_STRING_MODE, { className: "string" }), l2 = { endsWithParent: true, illegal: /</, relevance: 0, contains: [{ className: "attr", begin: /[A-Za-z0-9._:-]+/, relevance: 0 }, { begin: /=\s*/, relevance: 0, contains: [{ className: "string", endsParent: true, variants: [{ begin: /"/, end: /"/, contains: [n2] }, { begin: /'/, end: /'/, contains: [n2] }, { begin: /[^\s"'=<>`]+/ }] }] }] };
    return { name: "HTML, XML", aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"], case_insensitive: true, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, relevance: 10, contains: [i2, s2, o2, a2, { begin: /\[/, end: /\]/, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [i2, a2, s2, o2] }] }] }, e2.COMMENT(/<!--/, /-->/, { relevance: 10 }), { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 }, n2, { className: "meta", begin: /<\?xml/, end: /\?>/, relevance: 10 }, { className: "tag", begin: /<style(?=\s|>)/, end: />/, keywords: { name: "style" }, contains: [l2], starts: { end: /<\/style>/, returnEnd: true, subLanguage: ["css", "xml"] } }, { className: "tag", begin: /<script(?=\s|>)/, end: />/, keywords: { name: "script" }, contains: [l2], starts: { end: /<\/script>/, returnEnd: true, subLanguage: ["javascript", "handlebars", "xml"] } }, { className: "tag", begin: /<>|<\/>/ }, { className: "tag", begin: t2.concat(/</, t2.lookahead(t2.concat(r2, t2.either(/\/>/, />/, /\s/)))), end: /\/?>/, contains: [{ className: "name", begin: r2, relevance: 0, starts: l2 }] }, { className: "tag", begin: t2.concat(/<\//, t2.lookahead(t2.concat(r2, />/))), contains: [{ className: "name", begin: r2, relevance: 0 }, { begin: />/, relevance: 0, endsParent: true }] }] };
  }
  let issueWarning$2;
  (_a$2 = globalThis.litIssuedWarnings) !== null && _a$2 !== void 0 || (globalThis.litIssuedWarnings = new Set()), issueWarning$2 = (e2, t2) => {
    t2 += e2 ? ` See https://lit.dev/msg/${e2} for more information.` : "", globalThis.litIssuedWarnings.has(t2) || (console.warn(t2), globalThis.litIssuedWarnings.add(t2));
  }, issueWarning$2("dev-mode", "Lit is in dev mode. Not recommended for production!");
  const wrap$3 = (_b$2 = window.ShadyDOM) !== null && _b$2 !== void 0 && _b$2.inUse && ((_c$2 = window.ShadyDOM) === null || _c$2 === void 0 ? void 0 : _c$2.noPatch) === true ? window.ShadyDOM.wrap : (e2) => e2, trustedTypes$2 = globalThis.trustedTypes, policy$2 = trustedTypes$2 ? trustedTypes$2.createPolicy("lit-html", { createHTML: (e2) => e2 }) : void 0, identityFunction$2 = (e2) => e2, noopSanitizer$2 = (e2, t2, r2) => identityFunction$2, createSanitizer$2 = (e2, t2, r2) => sanitizerFactoryInternal$2(), boundAttributeSuffix$2 = "$lit$", marker$2 = `lit$${String(Math.random()).slice(9)}$`, markerMatch$2 = "?" + marker$2, nodeMarker$2 = `<${markerMatch$2}>`, d$2 = document, createMarker$2 = (e2 = "") => d$2.createComment(e2), isPrimitive$2 = (e2) => e2 === null || typeof e2 != "object" && typeof e2 != "function", isArray$3 = Array.isArray, isIterable$2 = (e2) => {
    return isArray$3(e2) || typeof (e2 === null || e2 === void 0 ? void 0 : e2[Symbol.iterator]) == "function";
  }, SPACE_CHAR$2 = `[ 	
\f\r]`, ATTR_VALUE_CHAR$2 = `[^ 	
\f\r"'\`<>=]`, NAME_CHAR$2 = `[^\\s"'>=/]`, textEndRegex$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, COMMENT_START$2 = 1, TAG_NAME$2 = 2, DYNAMIC_TAG_NAME$2 = 3, commentEndRegex$2 = /-->/g, comment2EndRegex$2 = />/g, tagEndRegex$2 = new RegExp(`>|${SPACE_CHAR$2}(?:(${NAME_CHAR$2}+)(${SPACE_CHAR$2}*=${SPACE_CHAR$2}*(?:${ATTR_VALUE_CHAR$2}|("|')|))|$)`, "g"), ENTIRE_MATCH$2 = 0, ATTRIBUTE_NAME$2 = 1, SPACES_AND_EQUALS$2 = 2, QUOTE_CHAR$2 = 3, singleQuoteAttrEndRegex$2 = /'/g, doubleQuoteAttrEndRegex$2 = /"/g, rawTextElement$2 = /^(?:script|style|textarea)$/i, SVG_RESULT$2 = 2, ATTRIBUTE_PART$2 = 1, CHILD_PART$2 = 2, PROPERTY_PART$2 = 3, BOOLEAN_ATTRIBUTE_PART$2 = 4, EVENT_PART$2 = 5, ELEMENT_PART$2 = 6, COMMENT_PART$2 = 7, noChange$2 = Symbol.for("lit-noChange"), nothing$2 = Symbol.for("lit-nothing"), templateCache$2 = new WeakMap(), walker$2 = d$2.createTreeWalker(d$2, 129, null, false);
  let sanitizerFactoryInternal$2 = noopSanitizer$2;
  const getTemplateHtml$2 = (i2, e2) => {
    var a2, t2 = i2.length - 1;
    const o2 = [];
    let s2 = e2 === SVG_RESULT$2 ? "<svg>" : "", l2, c2 = textEndRegex$2;
    for (let n2 = 0; n2 < t2; n2++) {
      const h2 = i2[n2];
      let e3 = -1, t3, r2 = 0;
      for (; r2 < h2.length && (c2.lastIndex = r2, (a2 = c2.exec(h2)) !== null); )
        if (r2 = c2.lastIndex, c2 === textEndRegex$2) {
          if (a2[COMMENT_START$2] === "!--")
            c2 = commentEndRegex$2;
          else if (a2[COMMENT_START$2] !== void 0)
            c2 = comment2EndRegex$2;
          else if (a2[TAG_NAME$2] !== void 0)
            rawTextElement$2.test(a2[TAG_NAME$2]) && (l2 = new RegExp("</" + a2[TAG_NAME$2], "g")), c2 = tagEndRegex$2;
          else if (a2[DYNAMIC_TAG_NAME$2] !== void 0)
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
        } else
          c2 === tagEndRegex$2 ? a2[ENTIRE_MATCH$2] === ">" ? (c2 = l2 !== null && l2 !== void 0 ? l2 : textEndRegex$2, e3 = -1) : a2[ATTRIBUTE_NAME$2] === void 0 ? e3 = -2 : (e3 = c2.lastIndex - a2[SPACES_AND_EQUALS$2].length, t3 = a2[ATTRIBUTE_NAME$2], c2 = a2[QUOTE_CHAR$2] === void 0 ? tagEndRegex$2 : a2[QUOTE_CHAR$2] === '"' ? doubleQuoteAttrEndRegex$2 : singleQuoteAttrEndRegex$2) : c2 === doubleQuoteAttrEndRegex$2 || c2 === singleQuoteAttrEndRegex$2 ? c2 = tagEndRegex$2 : c2 === commentEndRegex$2 || c2 === comment2EndRegex$2 ? c2 = textEndRegex$2 : (c2 = tagEndRegex$2, l2 = void 0);
      console.assert(e3 === -1 || c2 === tagEndRegex$2 || c2 === singleQuoteAttrEndRegex$2 || c2 === doubleQuoteAttrEndRegex$2, "unexpected parse state B");
      var u2 = c2 === tagEndRegex$2 && i2[n2 + 1].startsWith("/>") ? " " : "";
      s2 += c2 === textEndRegex$2 ? h2 + nodeMarker$2 : 0 <= e3 ? (o2.push(t3), h2.slice(0, e3) + boundAttributeSuffix$2 + h2.slice(e3) + marker$2 + u2) : h2 + marker$2 + (e3 === -2 ? (o2.push(void 0), n2) : u2);
    }
    e2 = s2 + (i2[t2] || "<?>") + (e2 === SVG_RESULT$2 ? "</svg>" : "");
    return [policy$2 !== void 0 ? policy$2.createHTML(e2) : e2, o2];
  };
  class Template$2 {
    constructor({ strings: e2, _$litType$: t2 }, r2) {
      this.parts = [];
      let n2, i2 = 0, a2 = 0;
      var o2 = e2.length - 1;
      const s2 = this.parts;
      var [e2, l2] = getTemplateHtml$2(e2, t2);
      if (this.el = Template$2.createElement(e2, r2), walker$2.currentNode = this.el.content, t2 === SVG_RESULT$2) {
        const f2 = this.el.content, m2 = f2.firstChild;
        m2.remove(), f2.append(...m2.childNodes);
      }
      for (; (n2 = walker$2.nextNode()) !== null && s2.length < o2; ) {
        if (n2.nodeType === 1) {
          var c2 = n2.localName;
          if (/^(?:textarea|template)$/i.test(c2) && n2.innerHTML.includes(marker$2)) {
            var u2 = `Expressions are not supported inside \`${c2}\` elements. See https://lit.dev/msg/expression-in-${c2} for more information.`;
            if (c2 === "template")
              throw new Error(u2);
            issueWarning$2("", u2);
          }
          if (n2.hasAttributes()) {
            const g2 = [];
            for (const v2 of n2.getAttributeNames())
              if (v2.endsWith(boundAttributeSuffix$2) || v2.startsWith(marker$2)) {
                const y = l2[a2++];
                if (g2.push(v2), y !== void 0) {
                  const _2 = n2.getAttribute(y.toLowerCase() + boundAttributeSuffix$2);
                  var h2 = _2.split(marker$2), d2 = /([.?@])?(.*)/.exec(y);
                  s2.push({ type: ATTRIBUTE_PART$2, index: i2, name: d2[2], strings: h2, ctor: d2[1] === "." ? PropertyPart$2 : d2[1] === "?" ? BooleanAttributePart$2 : d2[1] === "@" ? EventPart$2 : AttributePart$2 });
                } else
                  s2.push({ type: ELEMENT_PART$2, index: i2 });
              }
            for (const b2 of g2)
              n2.removeAttribute(b2);
          }
          if (rawTextElement$2.test(n2.tagName)) {
            const x2 = n2.textContent.split(marker$2);
            var p2 = x2.length - 1;
            if (0 < p2) {
              n2.textContent = trustedTypes$2 ? trustedTypes$2.emptyScript : "";
              for (let e3 = 0; e3 < p2; e3++)
                n2.append(x2[e3], createMarker$2()), walker$2.nextNode(), s2.push({ type: CHILD_PART$2, index: ++i2 });
              n2.append(x2[p2], createMarker$2());
            }
          }
        } else if (n2.nodeType === 8)
          if (n2.data === markerMatch$2)
            s2.push({ type: CHILD_PART$2, index: i2 });
          else {
            let e3 = -1;
            for (; (e3 = n2.data.indexOf(marker$2, e3 + 1)) !== -1; )
              s2.push({ type: COMMENT_PART$2, index: i2 }), e3 += marker$2.length - 1;
          }
        i2++;
      }
    }
    static createElement(e2, t2) {
      const r2 = d$2.createElement("template");
      return r2.innerHTML = e2, r2;
    }
  }
  function resolveDirective$2(e2, t2, r2 = e2, n2) {
    var i2;
    if (t2 === noChange$2)
      return t2;
    let a2 = n2 !== void 0 ? (i2 = r2.__directives) === null || i2 === void 0 ? void 0 : i2[n2] : r2.__directive;
    const o2 = isPrimitive$2(t2) ? void 0 : t2._$litDirective$;
    return (a2 === null || a2 === void 0 ? void 0 : a2.constructor) !== o2 && ((i2 = a2 === null || a2 === void 0 ? void 0 : a2._$notifyDirectiveConnectionChanged) !== null && i2 !== void 0 && i2.call(a2, false), o2 === void 0 ? a2 = void 0 : (a2 = new o2(e2), a2._$initialize(e2, r2, n2)), n2 !== void 0 ? ((i2 = r2.__directives) !== null && i2 !== void 0 ? i2 : r2.__directives = [])[n2] = a2 : r2.__directive = a2), t2 = a2 !== void 0 ? resolveDirective$2(e2, a2._$resolve(e2, t2.values), a2, n2) : t2;
  }
  class TemplateInstance$2 {
    constructor(e2, t2) {
      this._parts = [], this._$disconnectableChildren = void 0, this._$template = e2, this._$parent = t2;
    }
    get parentNode() {
      return this._$parent.parentNode;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(t2) {
      var e2, { el: { content: r2 }, parts: n2 } = this._$template, r2 = ((e2 = t2 == null ? void 0 : t2.creationScope) !== null && e2 !== void 0 ? e2 : d$2).importNode(r2, true);
      walker$2.currentNode = r2;
      let i2 = walker$2.nextNode(), a2 = 0, o2 = 0, s2 = n2[0];
      for (; s2 !== void 0; ) {
        if (a2 === s2.index) {
          let e3;
          s2.type === CHILD_PART$2 ? e3 = new ChildPart$2(i2, i2.nextSibling, this, t2) : s2.type === ATTRIBUTE_PART$2 ? e3 = new s2.ctor(i2, s2.name, s2.strings, this, t2) : s2.type === ELEMENT_PART$2 && (e3 = new ElementPart$2(i2, this, t2)), this._parts.push(e3), s2 = n2[++o2];
        }
        a2 !== (s2 === null || s2 === void 0 ? void 0 : s2.index) && (i2 = walker$2.nextNode(), a2++);
      }
      return r2;
    }
    _update(e2) {
      let t2 = 0;
      for (const r2 of this._parts)
        r2 !== void 0 && (r2.strings !== void 0 ? (r2._$setValue(e2, r2, t2), t2 += r2.strings.length - 2) : r2._$setValue(e2[t2])), t2++;
    }
  }
  class ChildPart$2 {
    constructor(e2, t2, r2, n2) {
      this.type = CHILD_PART$2, this._$committedValue = nothing$2, this._$disconnectableChildren = void 0, this._$startNode = e2, this._$endNode = t2, this._$parent = r2, this.options = n2, this.__isConnected = (n2 = n2 == null ? void 0 : n2.isConnected) === null || n2 === void 0 || n2, this._textSanitizer = void 0;
    }
    get _$isConnected() {
      var e2;
      return (e2 = (e2 = this._$parent) === null || e2 === void 0 ? void 0 : e2._$isConnected) !== null && e2 !== void 0 ? e2 : this.__isConnected;
    }
    get parentNode() {
      let e2 = wrap$3(this._$startNode).parentNode;
      var t2 = this._$parent;
      return t2 !== void 0 && e2.nodeType === 11 && (e2 = t2.parentNode), e2;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(e2, t2 = this) {
      if (this.parentNode === null)
        throw new Error("This `ChildPart` has no `parentNode` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's `innerHTML` or `textContent` can do this.");
      e2 = resolveDirective$2(this, e2, t2), isPrimitive$2(e2) ? e2 === nothing$2 || e2 == null || e2 === "" ? (this._$committedValue !== nothing$2 && this._$clear(), this._$committedValue = nothing$2) : e2 !== this._$committedValue && e2 !== noChange$2 && this._commitText(e2) : e2._$litType$ !== void 0 ? this._commitTemplateResult(e2) : e2.nodeType !== void 0 ? this._commitNode(e2) : isIterable$2(e2) ? this._commitIterable(e2) : this._commitText(e2);
    }
    _insert(e2, t2 = this._$endNode) {
      return wrap$3(wrap$3(this._$startNode).parentNode).insertBefore(e2, t2);
    }
    _commitNode(e2) {
      if (this._$committedValue !== e2) {
        if (this._$clear(), sanitizerFactoryInternal$2 !== noopSanitizer$2) {
          var t2 = (t2 = this._$startNode.parentNode) === null || t2 === void 0 ? void 0 : t2.nodeName;
          if (t2 === "STYLE" || t2 === "SCRIPT") {
            let e3 = "Forbidden";
            throw e3 = t2 === "STYLE" ? "Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css`...` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets." : "Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.", new Error(e3);
          }
        }
        this._$committedValue = this._insert(e2);
      }
    }
    _commitText(e2) {
      if (this._$committedValue !== nothing$2 && isPrimitive$2(this._$committedValue)) {
        const t2 = wrap$3(this._$startNode).nextSibling;
        this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer$2()), e2 = this._textSanitizer(e2), t2.data = e2;
      } else {
        const r2 = document.createTextNode("");
        this._commitNode(r2), this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer$2()), e2 = this._textSanitizer(e2), r2.data = e2;
      }
      this._$committedValue = e2;
    }
    _commitTemplateResult(e2) {
      const { values: t2, _$litType$: r2 } = e2;
      var n2 = typeof r2 == "number" ? this._$getTemplate(e2) : (r2.el === void 0 && (r2.el = Template$2.createElement(r2.h, this.options)), r2);
      if (((e2 = this._$committedValue) === null || e2 === void 0 ? void 0 : e2._$template) === n2)
        this._$committedValue._update(t2);
      else {
        const i2 = new TemplateInstance$2(n2, this);
        n2 = i2._clone(this.options);
        i2._update(t2), this._commitNode(n2), this._$committedValue = i2;
      }
    }
    _$getTemplate(e2) {
      let t2 = templateCache$2.get(e2.strings);
      return t2 === void 0 && templateCache$2.set(e2.strings, t2 = new Template$2(e2)), t2;
    }
    _commitIterable(e2) {
      isArray$3(this._$committedValue) || (this._$committedValue = [], this._$clear());
      const t2 = this._$committedValue;
      let r2 = 0, n2;
      for (const i2 of e2)
        r2 === t2.length ? t2.push(n2 = new ChildPart$2(this._insert(createMarker$2()), this._insert(createMarker$2()), this, this.options)) : n2 = t2[r2], n2._$setValue(i2), r2++;
      r2 < t2.length && (this._$clear(n2 && wrap$3(n2._$endNode).nextSibling, r2), t2.length = r2);
    }
    _$clear(e2 = wrap$3(this._$startNode).nextSibling, t2) {
      var r2;
      for ((r2 = this._$notifyConnectionChanged) !== null && r2 !== void 0 && r2.call(this, false, true, t2); e2 && e2 !== this._$endNode; ) {
        var n2 = wrap$3(e2).nextSibling;
        wrap$3(e2).remove(), e2 = n2;
      }
    }
    setConnected(e2) {
      var t2;
      if (this._$parent !== void 0)
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      this.__isConnected = e2, (t2 = this._$notifyConnectionChanged) !== null && t2 !== void 0 && t2.call(this, e2);
    }
  }
  class AttributePart$2 {
    constructor(e2, t2, r2, n2, i2) {
      this.type = ATTRIBUTE_PART$2, this._$committedValue = nothing$2, this._$disconnectableChildren = void 0, this.element = e2, this.name = t2, this._$parent = n2, this.options = i2, 2 < r2.length || r2[0] !== "" || r2[1] !== "" ? (this._$committedValue = new Array(r2.length - 1).fill(new String()), this.strings = r2) : this._$committedValue = nothing$2, this._sanitizer = void 0;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(r2, n2 = this, i2, e2) {
      var a2 = this.strings;
      let o2 = false;
      if (a2 === void 0)
        r2 = resolveDirective$2(this, r2, n2, 0), o2 = !isPrimitive$2(r2) || r2 !== this._$committedValue && r2 !== noChange$2, o2 && (this._$committedValue = r2);
      else {
        var s2 = r2;
        r2 = a2[0];
        let e3, t2;
        for (e3 = 0; e3 < a2.length - 1; e3++)
          t2 = resolveDirective$2(this, s2[i2 + e3], n2, e3), t2 === noChange$2 && (t2 = this._$committedValue[e3]), o2 = o2 || (!isPrimitive$2(t2) || t2 !== this._$committedValue[e3]), t2 === nothing$2 ? r2 = nothing$2 : r2 !== nothing$2 && (r2 += (t2 !== null && t2 !== void 0 ? t2 : "") + a2[e3 + 1]), this._$committedValue[e3] = t2;
      }
      o2 && !e2 && this._commitValue(r2);
    }
    _commitValue(e2) {
      e2 === nothing$2 ? wrap$3(this.element).removeAttribute(this.name) : (this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name)), e2 = this._sanitizer(e2 != null ? e2 : ""), wrap$3(this.element).setAttribute(this.name, e2 != null ? e2 : ""));
    }
  }
  class PropertyPart$2 extends AttributePart$2 {
    constructor() {
      super(...arguments), this.type = PROPERTY_PART$2;
    }
    _commitValue(e2) {
      this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name)), e2 = this._sanitizer(e2), this.element[this.name] = e2 === nothing$2 ? void 0 : e2;
    }
  }
  class BooleanAttributePart$2 extends AttributePart$2 {
    constructor() {
      super(...arguments), this.type = BOOLEAN_ATTRIBUTE_PART$2;
    }
    _commitValue(e2) {
      e2 && e2 !== nothing$2 ? wrap$3(this.element).setAttribute(this.name, "") : wrap$3(this.element).removeAttribute(this.name);
    }
  }
  class EventPart$2 extends AttributePart$2 {
    constructor(e2, t2, r2, n2, i2) {
      if (super(e2, t2, r2, n2, i2), this.type = EVENT_PART$2, this.strings !== void 0)
        throw new Error(`A \`<${e2.localName}>\` has a \`@${t2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
    _$setValue(e2, t2 = this) {
      var r2, n2;
      (e2 = (n2 = resolveDirective$2(this, e2, t2, 0)) !== null && n2 !== void 0 ? n2 : nothing$2) !== noChange$2 && (r2 = this._$committedValue, t2 = e2 === nothing$2 && r2 !== nothing$2 || e2.capture !== r2.capture || e2.once !== r2.once || e2.passive !== r2.passive, n2 = e2 !== nothing$2 && (r2 === nothing$2 || t2), t2 && this.element.removeEventListener(this.name, this, r2), n2 && this.element.addEventListener(this.name, this, e2), this._$committedValue = e2);
    }
    handleEvent(e2) {
      var t2;
      typeof this._$committedValue == "function" ? this._$committedValue.call((t2 = (t2 = this.options) === null || t2 === void 0 ? void 0 : t2.host) !== null && t2 !== void 0 ? t2 : this.element, e2) : this._$committedValue.handleEvent(e2);
    }
  }
  class ElementPart$2 {
    constructor(e2, t2, r2) {
      this.element = e2, this.type = ELEMENT_PART$2, this._$disconnectableChildren = void 0, this._$parent = t2, this.options = r2;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(e2) {
      resolveDirective$2(this, e2);
    }
  }
  const polyfillSupport$2 = window.litHtmlPolyfillSupportDevMode;
  polyfillSupport$2 !== null && polyfillSupport$2 !== void 0 && polyfillSupport$2(Template$2, ChildPart$2), ((_d$2 = globalThis.litHtmlVersions) !== null && _d$2 !== void 0 ? _d$2 : globalThis.litHtmlVersions = []).push("2.0.1"), 1 < globalThis.litHtmlVersions.length && issueWarning$2("multiple-versions", "Multiple versions of Lit loaded. Loading multiple versions is not recommended.");
  const PartType$1 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, directive$1 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
  class Directive$1 {
    constructor(e2) {
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$initialize(e2, t2, r2) {
      this.__part = e2, this._$parent = t2, this.__attributeIndex = r2;
    }
    _$resolve(e2, t2) {
      return this.update(e2, t2);
    }
    update(e2, t2) {
      return this.render(...t2);
    }
  }
  const HTML_RESULT$2 = 1;
  class UnsafeHTMLDirective$1 extends Directive$1 {
    constructor(e2) {
      if (super(e2), this._value = nothing$2, e2.type !== PartType$1.CHILD)
        throw new Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(e2) {
      if (e2 === nothing$2 || e2 == null)
        return this._templateResult = void 0, this._value = e2;
      if (e2 === noChange$2)
        return e2;
      if (typeof e2 != "string")
        throw new Error(this.constructor.directiveName + "() called with a non-string value");
      if (e2 === this._value)
        return this._templateResult;
      const t2 = [this._value = e2];
      return t2.raw = t2, this._templateResult = { _$litType$: this.constructor.resultType, strings: t2, values: [] };
    }
  }
  UnsafeHTMLDirective$1.directiveName = "unsafeHTML", UnsafeHTMLDirective$1.resultType = HTML_RESULT$2;
  const unsafeHTML$1 = directive$1(UnsafeHTMLDirective$1), standardProperty$1 = (t2, r2) => r2.kind !== "method" || !r2.descriptor || "value" in r2.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: r2.key, initializer() {
    typeof r2.initializer == "function" && (this[r2.key] = r2.initializer.call(this));
  }, finisher(e2) {
    e2.createProperty(r2.key, t2);
  } } : __spreadProps(__spreadValues({}, r2), { finisher(e2) {
    e2.createProperty(r2.key, t2);
  } }), legacyProperty$1 = (e2, t2, r2) => {
    t2.constructor.createProperty(r2, e2);
  };
  function property$1(r2) {
    return (e2, t2) => t2 !== void 0 ? legacyProperty$1(r2, e2, t2) : standardProperty$1(r2, e2);
  }
  const decorateProperty$1 = ({ finisher: a2, descriptor: o2 }) => (e2, t2) => {
    if (t2 === void 0) {
      const n2 = (r2 = e2.originalKey) !== null && r2 !== void 0 ? r2 : e2.key, i2 = o2 != null ? { kind: "method", placement: "prototype", key: n2, descriptor: o2(e2.key) } : __spreadProps(__spreadValues({}, e2), { key: n2 });
      return a2 != null && (i2.finisher = function(e3) {
        a2(e3, n2);
      }), i2;
    }
    var r2 = e2.constructor;
    o2 !== void 0 && Object.defineProperty(e2, t2, o2(t2)), a2 != null && a2(r2, t2);
  };
  function query(n2, i2) {
    return decorateProperty$1({ descriptor: (e2) => {
      const t2 = { get() {
        var e3;
        return (e3 = (e3 = this.renderRoot) === null || e3 === void 0 ? void 0 : e3.querySelector(n2)) !== null && e3 !== void 0 ? e3 : null;
      }, enumerable: true, configurable: true };
      if (i2) {
        const r2 = typeof e2 == "symbol" ? Symbol() : "__" + e2;
        t2.get = function() {
          var e3;
          return this[r2] === void 0 && (this[r2] = (e3 = (e3 = this.renderRoot) === null || e3 === void 0 ? void 0 : e3.querySelector(n2)) !== null && e3 !== void 0 ? e3 : null), this[r2];
        };
      }
      return t2;
    } });
  }
  function queryAssignedNodes(r2 = "", n2 = false, i2 = "") {
    return decorateProperty$1({ descriptor: (e2) => ({ get() {
      var e3 = (e3 = this.renderRoot) === null || e3 === void 0 ? void 0 : e3.querySelector("slot" + (r2 ? `[name=${r2}]` : ":not([name])"));
      let t2 = (e3 = e3 === null || e3 === void 0 ? void 0 : e3.assignedNodes({ flatten: n2 })) !== null && e3 !== void 0 ? e3 : [];
      return i2 && (t2 = t2.filter((e4) => e4.nodeType === Node.ELEMENT_NODE && e4.matches(i2))), t2;
    }, enumerable: true, configurable: true }) });
  }
  function decodeHtmlEntities(e2) {
    const t2 = document.createElement("textarea");
    return t2.innerHTML = e2, t2.value;
  }
  var __css$6 = ".hljs {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-ui-code-paddingBlock, 3rem) var(--s-theme-ui-code-paddingInline, 3rem);\n    background-color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-30-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-30-lightness-offset, 0)) * 1%),var(--s-theme-color-text-30-a, 1));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n    z-index: 1;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n}\n\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    position: relative;\n    --paddingBlock: var(--s-theme-ui-code-paddingBlock, 3rem);\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(1.5em * var(--max-lines) + (var(--paddingBlock) * 2));\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n\n:not([bare]) .s-code-example__content {\n    transition: var(--s-theme-ui-code-transition, 0);\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);box-shadow: var(--s-theme-ui-code-depth, 0);\n}\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n\n:not([bare]) .s-code-example__more-bar {\n    text-align: center;\n    padding-inline: var(--s-theme-ui-default-paddingInline, 1.5em);\n    padding-block: var(--s-theme-ui-default-paddingBlock, 0.75em);\n    justify-content: center;\n}\n\n:not([bare]) .s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));background: linear-gradient(0deg, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1)) 0%, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),0) 100%);\n    }\n\n.s-code-example--more .s-code-example__more-bar:before {\n        height: 0;\n    }\n\n.s-code-example__code {\n    display: none;\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    /* transform: translate(0, -50%); */\n}\n";
  class SCodeExampleInterface extends SInterface {
    static get _definition() {
      return { active: { description: 'Specify which "tab" is active in case of multiple languages examples', type: "String" }, toolbar: { description: 'Specify what you want in the toolbar. Currently available item is "copy"', type: "Array<String>", values: ["copy"], default: ["copy"] }, toolbarPosition: { description: 'Specify the toolbar position. Can be "content" or "nav"', type: "String", values: ["content", "nav"], default: "nav" }, languages: { description: 'Specify some languages that you want to support. Must be "[key]: language" object syntax. See [highlight.js doc](https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md) for supported languages', type: "Object", default: {} }, lines: { description: "Specify how many lines to display at max", type: "Number" }, moreLabel: { description: 'Specify the "show more" button label', type: "String", default: "Show more" }, lessLabel: { description: 'Specigy the "show less" button label', type: "String", default: "Show less" }, moreAction: { type: "String", default: "toggle" }, more: { description: "Specify if you want to expand the more feature at start or not", type: "Boolean", default: false } };
    }
  }
  var __decorate$3 = globalThis && globalThis.__decorate || function(e2, t2, r2, n2) {
    var i2, a2 = arguments.length, o2 = a2 < 3 ? t2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var s2 = e2.length - 1; 0 <= s2; s2--)
        (i2 = e2[s2]) && (o2 = (a2 < 3 ? i2(o2) : 3 < a2 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return 3 < a2 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }, __awaiter$b = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  define$e();
  class SCodeExample extends SLitComponent {
    constructor() {
      var e2;
      super(__deepMerge$5({ componentUtils: { interface: SCodeExampleInterface } })), this._$copy = void 0, this._items = [], this._activeTabId = void 0;
      const t2 = Object.assign({ html: xml, javascript, js: javascript, php, bash, shell: bash, css }, (e2 = this.props.languages) !== null && e2 !== void 0 ? e2 : {});
      Object.keys(t2).forEach((e3) => {
        core.registerLanguage(e3, t2[e3]);
      });
    }
    static get properties() {
      return SLitComponent.properties({}, SCodeExampleInterface);
    }
    static get styles() {
      return r$2`
            ${o$3(__css$6)}
        `;
    }
    firstUpdated() {
      var e2;
      return __awaiter$b(this, void 0, void 0, function* () {
        return this.$templates.forEach((t2) => {
          var r2;
          if (t2.getAttribute) {
            (r2 = (r2 = t2.getAttribute("id")) !== null && r2 !== void 0 ? r2 : t2.getAttribute("language")) !== null && r2 !== void 0 ? r2 : t2.getAttribute("lang");
            let e3 = decodeHtmlEntities(t2.tagName.toLowerCase() === "textarea" && t2.value ? t2.value : t2.innerHTML);
            this._items = [...this._items, { id: (r2 = (r2 = (r2 = t2.getAttribute("id")) !== null && r2 !== void 0 ? r2 : t2.getAttribute("language")) !== null && r2 !== void 0 ? r2 : t2.getAttribute("lang")) !== null && r2 !== void 0 ? r2 : "html", lang: (r2 = (r2 = t2.getAttribute("language")) !== null && r2 !== void 0 ? r2 : t2.getAttribute("lang")) !== null && r2 !== void 0 ? r2 : "html", code: e3, lines: e3.trim().split("\n").length }], t2.remove();
          }
        }), this.active ? this.setActiveTab(this.active) : this._items[0] && this.setActiveTab(this._items[0].id), this._$pre = (e2 = this.shadowRoot) === null || e2 === void 0 ? void 0 : e2.querySelector(".s-code-example__code"), this._$root = (e2 = this.shadowRoot) === null || e2 === void 0 ? void 0 : e2.querySelector(".s-code-example"), true;
      });
    }
    setActiveTabByTab(e2) {
      this.setActiveTab(e2.target.id);
    }
    get currentItem() {
      return this._activeTabId ? this._items.find((e2) => e2.id === this._activeTabId) : {};
    }
    setActiveTab(e2) {
      return __awaiter$b(this, void 0, void 0, function* () {
        yield wait$1(), this._activeTabId = e2, this.initPrismOnTab(e2);
      });
    }
    setMoreClass() {
      return __awaiter$b(this, void 0, void 0, function* () {
        this._more ? this._$root.classList.add("s-code-example--more") : this._$root.classList.remove("s-code-example--more"), this.requestUpdate();
      });
    }
    toggleMore() {
      this._more = !this._more, this.setMoreClass();
    }
    initPrismOnTab(t2) {
      var e2;
      const r2 = (e2 = this.shadowRoot) === null || e2 === void 0 ? void 0 : e2.querySelector(`pre#${t2} code`), n2 = this._items.find((e3) => e3.id === t2);
      if (r2.hasAttribute("inited"))
        this.setMoreClass();
      else {
        r2.setAttribute("inited", "true");
        try {
          core.highlight(r2.innerHTML.replace(/<!--\?lit.*-->/, ""), { language: r2.getAttribute("lang") });
        } catch (e3) {
        }
        n2.highlightedCode = decodeHtmlEntities(""), this.setMoreClass();
      }
    }
    copy() {
      const t2 = this._activeTabId;
      var e2 = this._items.filter((e3) => e3.id === t2)[0];
      this.$copy.copy(e2.code);
    }
    render() {
      var e2, t2, r2, n2 = this.currentItem;
      return p`
            <div
                class="${this.componentUtils.className()} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.lines}"
                ?mounted="${this.mounted}"
                ?bare="${this.bare}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                <header class="${this.componentUtils.className("__nav")}">
                    <ol
                        class="${this.componentUtils.className("__tabs", "s-tabs")}"
                    >
                        ${((e2 = this._items) !== null && e2 !== void 0 ? e2 : []).map((e3) => p`
                                <li
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${e3.id}"
                                    ?active="${this._activeTabId === e3.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${e3.lang}
                                </li>
                            `)}
                    </ol>
                    ${this.toolbarPosition === "nav" ? p`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(e2 = this.props.lines) !== null && e2 !== void 0 ? e2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? p`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((e2 = this._items) !== null && e2 !== void 0 ? e2 : []).map((e3) => {
        var t3;
        return p`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(t3 = e3.id) !== null && t3 !== void 0 ? t3 : e3.lang}"
                                ?active="${this._activeTabId === ((t3 = e3.id) !== null && t3 !== void 0 ? t3 : e3.lang)}"
                            >
                            <code lang="${(t3 = e3.lang) !== null && t3 !== void 0 ? t3 : e3.id}" class="language-${e3.lang} ${e3.lang} ${this.props.bare ? "" : "hljs"}">${e3.highlightedCode ? unsafeHTML$1(e3.highlightedCode) : e3.code.trim()}</code>
                        </pre>
                        `;
      })}
                    ${this.props.lines && n2.lines > this.lines ? p`
                        <div class="${this.componentUtils.className("__more-bar")}">
                            ${this.moreAction === "toggle" ? p`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn")}"
                                              @click="${() => this.toggleMore()}"
                                          >
                                              ${this._more ? p`
                                                            ${(t2 = this.props.lessLabel) !== null && t2 !== void 0 ? t2 : "Show less"}
                                                        ` : p`
                                                            ${(t2 = this.props.moreLabel) !== null && t2 !== void 0 ? t2 : "Show more"}
                                                        `}
                                          </a>
                                      ` : p`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                              href="${this.moreAction}"
                                          >
                                              ${this._more ? p`
                                                            ${(r2 = this.props.lessLabel) !== null && r2 !== void 0 ? r2 : "Show less"}
                                                        ` : p`
                                                            ${(r2 = this.props.moreLabel) !== null && r2 !== void 0 ? r2 : "Show more"}
                                                        `}
                                          </a>
                                      `}                        
                            </a>
                        </div>
                    ` : ""}
                </div>
            </div>
        `;
    }
  }
  function define$d(e2 = {}, t2 = "s-code-example") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SCodeExample);
  }
  __decorate$3([property$1()], SCodeExample.prototype, "_items", void 0), __decorate$3([property$1()], SCodeExample.prototype, "_activeTabId", void 0), __decorate$3([property$1({ type: String })], SCodeExample.prototype, "active", void 0), __decorate$3([property$1()], SCodeExample.prototype, "props", void 0), __decorate$3([query("s-clipboard-copy")], SCodeExample.prototype, "$copy", void 0), __decorate$3([query(".templates")], SCodeExample.prototype, "$templatesContainer", void 0), __decorate$3([queryAssignedNodes()], SCodeExample.prototype, "$templates", void 0);
  var pickr_min = { exports: {} };
  self, pickr_min.exports = (() => {
    var n2 = { d: (e3, t3) => {
      for (var r3 in t3)
        n2.o(t3, r3) && !n2.o(e3, r3) && Object.defineProperty(e3, r3, { enumerable: true, get: t3[r3] });
    }, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), r: (e3) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
    } }, e2 = {};
    n2.d(e2, { default: () => S2 });
    var t2 = {};
    function r2(e3, t3, r3, n3, i3 = {}) {
      t3 instanceof HTMLCollection || t3 instanceof NodeList ? t3 = Array.from(t3) : Array.isArray(t3) || (t3 = [t3]), Array.isArray(r3) || (r3 = [r3]);
      for (const a3 of t3)
        for (const t4 of r3)
          a3[e3](t4, n3, __spreadValues({ capture: false }, i3));
      return Array.prototype.slice.call(arguments, 1);
    }
    n2.r(t2), n2.d(t2, { adjustableInputNumbers: () => c2, createElementFromString: () => s2, createFromTemplate: () => h2, eventPath: () => l2, off: () => i2, on: () => o2, resolveElement: () => a2 });
    const o2 = r2.bind(null, "addEventListener"), i2 = r2.bind(null, "removeEventListener");
    function s2(e3) {
      const t3 = document.createElement("div");
      return t3.innerHTML = e3.trim(), t3.firstElementChild;
    }
    function h2(e3) {
      const a3 = (e4, t3) => {
        var r3 = e4.getAttribute(t3);
        return e4.removeAttribute(t3), r3;
      }, o3 = (e4, t3 = {}) => {
        const r3 = a3(e4, ":obj"), n3 = a3(e4, ":ref"), i3 = r3 ? t3[r3] = {} : t3;
        n3 && (t3[n3] = e4);
        for (const t4 of Array.from(e4.children)) {
          const e5 = a3(t4, ":arr"), r4 = o3(t4, e5 ? {} : i3);
          e5 && (i3[e5] || (i3[e5] = [])).push(Object.keys(r4).length ? r4 : t4);
        }
        return t3;
      };
      return o3(s2(e3));
    }
    function l2(e3) {
      let t3 = e3.path || e3.composedPath && e3.composedPath();
      if (t3)
        return t3;
      let r3 = e3.target.parentElement;
      for (t3 = [e3.target, r3]; r3 = r3.parentElement; )
        t3.push(r3);
      return t3.push(document, window), t3;
    }
    function a2(e3) {
      return e3 instanceof Element ? e3 : typeof e3 == "string" ? e3.split(/>>/g).reduce((e4, t3, r3, n3) => (e4 = e4.querySelector(t3), r3 < n3.length - 1 ? e4.shadowRoot : e4), document) : null;
    }
    function c2(t3, a3 = (e3) => e3) {
      function e3(e4) {
        const r3 = [1e-3, 0.01, 0.1][Number(e4.shiftKey || 2 * e4.ctrlKey)] * (e4.deltaY < 0 ? 1 : -1);
        let n3 = 0, i3 = t3.selectionStart;
        t3.value = t3.value.replace(/[\d.]+/g, (e5, t4) => t4 <= i3 && t4 + e5.length >= i3 ? (i3 = t4, a3(Number(e5), r3, n3)) : (n3++, e5)), t3.focus(), t3.setSelectionRange(i3, i3), e4.preventDefault(), t3.dispatchEvent(new Event("input"));
      }
      o2(t3, "focus", () => o2(window, "wheel", e3, { passive: false })), o2(t3, "blur", () => i2(window, "wheel", e3));
    }
    const { min: y, max: u2, floor: d2, round: p2 } = Math;
    function f2(e3, t3, r3) {
      t3 /= 100, r3 /= 100;
      var n3 = d2(e3 = e3 / 360 * 6), i3 = e3 - n3, a3 = r3 * (1 - t3), e3 = r3 * (1 - i3 * t3), t3 = r3 * (1 - (1 - i3) * t3), n3 = n3 % 6;
      return [255 * [r3, e3, a3, a3, t3, r3][n3], 255 * [t3, r3, r3, e3, a3, a3][n3], 255 * [a3, a3, t3, r3, r3, e3][n3]];
    }
    function _2(e3, t3, r3) {
      const n3 = y(e3 /= 255, t3 /= 255, r3 /= 255), i3 = u2(e3, t3, r3), a3 = i3 - n3;
      let o3, s3;
      if (a3 == 0)
        o3 = s3 = 0;
      else {
        s3 = a3 / i3;
        const n4 = ((i3 - e3) / 6 + a3 / 2) / a3, l3 = ((i3 - t3) / 6 + a3 / 2) / a3, c3 = ((i3 - r3) / 6 + a3 / 2) / a3;
        e3 === i3 ? o3 = c3 - l3 : t3 === i3 ? o3 = 1 / 3 + n4 - c3 : r3 === i3 && (o3 = 2 / 3 + l3 - n4), o3 < 0 ? o3 += 1 : 1 < o3 && --o3;
      }
      return [360 * o3, 100 * s3, 100 * i3];
    }
    function m2(e3) {
      e3 = e3.match(/^[a-zA-Z]+$/) ? function(e4) {
        if (e4.toLowerCase() === "black")
          return "#000";
        const t4 = document.createElement("canvas").getContext("2d");
        return t4.fillStyle = e4, t4.fillStyle === "#000" ? null : t4.fillStyle;
      }(e3) : e3;
      const r3 = { cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i, rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i }, t3 = (e4) => e4.map((e5) => /^(|\d+)\.\d+|\d+$/.test(e5) ? Number(e5) : void 0);
      let n3;
      e:
        for (const c3 in r3)
          if (n3 = r3[c3].exec(e3)) {
            var i3 = (e4) => !!n3[2] == (typeof e4 == "number");
            switch (c3) {
              case "cmyk": {
                const [, e4, r4, u3, h3] = t3(n3);
                if (100 < e4 || 100 < r4 || 100 < u3 || 100 < h3)
                  break e;
                return { values: (a3 = e4, o3 = r4, s3 = u3, l3 = h3, o3 /= 100, s3 /= 100, [..._2(255 * (1 - y(1, (a3 /= 100) * (1 - (l3 /= 100)) + l3)), 255 * (1 - y(1, o3 * (1 - l3) + l3)), 255 * (1 - y(1, s3 * (1 - l3) + l3)))]), type: c3 };
              }
              case "rgba": {
                const [, , , e4, r4, d3, p3] = t3(n3);
                if (255 < e4 || 255 < r4 || 255 < d3 || p3 < 0 || 1 < p3 || !i3(p3))
                  break e;
                return { values: [..._2(e4, r4, d3), p3], a: p3, type: c3 };
              }
              case "hexa": {
                let [, e4] = n3;
                e4.length !== 4 && e4.length !== 3 || (e4 = e4.split("").map((e5) => e5 + e5).join(""));
                const r4 = e4.substring(0, 6);
                let t4 = e4.substring(6);
                return t4 = t4 ? parseInt(t4, 16) / 255 : void 0, { values: [..._2(...r4.match(/.{2}/g).map((e5) => parseInt(e5, 16))), t4], a: t4, type: c3 };
              }
              case "hsla": {
                const [, , , e4, r4, f3, m3] = t3(n3);
                if (360 < e4 || 100 < r4 || 100 < f3 || m3 < 0 || 1 < m3 || !i3(m3))
                  break e;
                return { values: [...function(e5, t4, r5) {
                  t4 /= 100;
                  var n4 = 2 * (t4 *= (r5 /= 100) < 0.5 ? r5 : 1 - r5) / (r5 + t4) * 100, t4 = 100 * (r5 + t4);
                  return [e5, isNaN(n4) ? 0 : n4, t4];
                }(e4, r4, f3), m3], a: m3, type: c3 };
              }
              case "hsva": {
                const [, , , e4, r4, g3, v3] = t3(n3);
                if (360 < e4 || 100 < r4 || 100 < g3 || v3 < 0 || 1 < v3 || !i3(v3))
                  break e;
                return { values: [e4, r4, g3, v3], a: v3, type: c3 };
              }
            }
          }
      var a3, o3, s3, l3;
      return { values: null, type: null };
    }
    function g2(e3 = 0, t3 = 0, r3 = 0, n3 = 1) {
      const a3 = (e4, r4) => (t4 = -1) => r4(~t4 ? e4.map((e5) => Number(e5.toFixed(t4))) : e4), o3 = { h: e3, s: t3, v: r3, a: n3, toHSVA() {
        const e4 = [o3.h, o3.s, o3.v, o3.a];
        return e4.toString = a3(e4, (e5) => `hsva(${e5[0]}, ${e5[1]}%, ${e5[2]}%, ${o3.a})`), e4;
      }, toHSLA() {
        const e4 = [...(t4 = o3.h, r4 = o3.s, n4 = o3.v, i3 = (2 - (r4 /= 100)) * (n4 /= 100) / 2, [t4, 100 * (r4 = i3 != 0 ? i3 == 1 ? 0 : i3 < 0.5 ? r4 * n4 / (2 * i3) : r4 * n4 / (2 - 2 * i3) : r4), 100 * i3]), o3.a];
        var t4, r4, n4, i3;
        return e4.toString = a3(e4, (e5) => `hsla(${e5[0]}, ${e5[1]}%, ${e5[2]}%, ${o3.a})`), e4;
      }, toRGBA() {
        const e4 = [...f2(o3.h, o3.s, o3.v), o3.a];
        return e4.toString = a3(e4, (e5) => `rgba(${e5[0]}, ${e5[1]}, ${e5[2]}, ${o3.a})`), e4;
      }, toCMYK() {
        const e4 = (t4 = f2(o3.h, o3.s, o3.v), r4 = t4[0] / 255, n4 = t4[1] / 255, i3 = t4[2] / 255, [100 * ((t4 = y(1 - r4, 1 - n4, 1 - i3)) === 1 ? 0 : (1 - r4 - t4) / (1 - t4)), 100 * (t4 === 1 ? 0 : (1 - n4 - t4) / (1 - t4)), 100 * (t4 === 1 ? 0 : (1 - i3 - t4) / (1 - t4)), 100 * t4]);
        var t4, r4, n4, i3;
        return e4.toString = a3(e4, (e5) => `cmyk(${e5[0]}%, ${e5[1]}%, ${e5[2]}%, ${e5[3]}%)`), e4;
      }, toHEXA() {
        const e4 = f2(o3.h, o3.s, o3.v).map((e5) => p2(e5).toString(16).padStart(2, "0")), t4 = 1 <= o3.a ? "" : Number((255 * o3.a).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
        return t4 && e4.push(t4), e4.toString = () => "#" + e4.join("").toUpperCase(), e4;
      }, clone: () => g2(o3.h, o3.s, o3.v, o3.a) };
      return o3;
    }
    const v2 = (e3) => Math.max(Math.min(e3, 1), 0);
    function b2(e3) {
      const h3 = { options: Object.assign({ lock: null, onchange: () => 0, onstop: () => 0 }, e3), _keyboard(r4) {
        const n4 = h3["options"], { type: e4, key: t4 } = r4;
        if (document.activeElement === n4.wrapper) {
          const n5 = h3.options["lock"], i3 = t4 === "ArrowUp", a3 = t4 === "ArrowRight", o3 = t4 === "ArrowDown", s3 = t4 === "ArrowLeft";
          if (e4 === "keydown" && (i3 || a3 || o3 || s3)) {
            let e5 = 0, t5 = 0;
            e5 = n5 === "v" ? i3 || a3 ? 1 : -1 : n5 === "h" ? i3 || a3 ? -1 : 1 : (t5 = i3 ? -1 : o3 ? 1 : 0, s3 ? -1 : a3 ? 1 : 0), h3.update(v2(h3.cache.x + 0.01 * e5), v2(h3.cache.y + 0.01 * t5)), r4.preventDefault();
          } else
            t4.startsWith("Arrow") && (h3.options.onstop(), r4.preventDefault());
        }
      }, _tapstart(e4) {
        o2(document, ["mouseup", "touchend", "touchcancel"], h3._tapstop), o2(document, ["mousemove", "touchmove"], h3._tapmove), e4.cancelable && e4.preventDefault(), h3._tapmove(e4);
      }, _tapmove(e4) {
        const { options: t4, cache: r4 } = h3, { lock: n4, element: i3, wrapper: a3 } = t4, o3 = a3.getBoundingClientRect();
        let s3 = 0, l3 = 0;
        if (e4) {
          const h4 = e4 && e4.touches && e4.touches[0];
          s3 = e4 ? (h4 || e4).clientX : 0, l3 = e4 ? (h4 || e4).clientY : 0, s3 < o3.left ? s3 = o3.left : s3 > o3.left + o3.width && (s3 = o3.left + o3.width), l3 < o3.top ? l3 = o3.top : l3 > o3.top + o3.height && (l3 = o3.top + o3.height), s3 -= o3.left, l3 -= o3.top;
        } else
          r4 && (s3 = r4.x * o3.width, l3 = r4.y * o3.height);
        n4 !== "h" && (i3.style.left = `calc(${s3 / o3.width * 100}% - ${i3.offsetWidth / 2}px)`), n4 !== "v" && (i3.style.top = `calc(${l3 / o3.height * 100}% - ${i3.offsetHeight / 2}px)`), h3.cache = { x: s3 / o3.width, y: l3 / o3.height };
        var c3 = v2(s3 / o3.width), u3 = v2(l3 / o3.height);
        switch (n4) {
          case "v":
            return t4.onchange(c3);
          case "h":
            return t4.onchange(u3);
          default:
            return t4.onchange(c3, u3);
        }
      }, _tapstop() {
        h3.options.onstop(), i2(document, ["mouseup", "touchend", "touchcancel"], h3._tapstop), i2(document, ["mousemove", "touchmove"], h3._tapmove);
      }, trigger() {
        h3._tapmove();
      }, update(e4 = 0, t4 = 0) {
        var { left: r4, top: n4, width: i3, height: a3 } = h3.options.wrapper.getBoundingClientRect();
        h3.options.lock === "h" && (t4 = e4), h3._tapmove({ clientX: r4 + i3 * e4, clientY: n4 + a3 * t4 });
      }, destroy() {
        var { options: e4, _tapstart: t4, _keyboard: r4 } = h3;
        i2(document, ["keydown", "keyup"], r4), i2([e4.wrapper, e4.element], "mousedown", t4), i2([e4.wrapper, e4.element], "touchstart", t4, { passive: false });
      } }, { options: t3, _tapstart: r3, _keyboard: n3 } = h3;
      return o2([t3.wrapper, t3.element], "mousedown", r3), o2([t3.wrapper, t3.element], "touchstart", r3, { passive: false }), o2(document, ["keydown", "keyup"], n3), h3;
    }
    const w2 = { variantFlipOrder: { start: "sme", middle: "mse", end: "ems" }, positionFlipOrder: { top: "tbrl", right: "rltb", bottom: "btrl", left: "lrbt" }, position: "bottom", margin: 8 };
    function x2(e3, t3, r3) {
      return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
    }
    class S2 {
      constructor(t3) {
        x2(this, "_initializingActive", true), x2(this, "_recalc", true), x2(this, "_nanopop", null), x2(this, "_root", null), x2(this, "_color", g2()), x2(this, "_lastColor", g2()), x2(this, "_swatchColors", []), x2(this, "_setupAnimationFrame", null), x2(this, "_eventListener", { init: [], save: [], hide: [], show: [], clear: [], change: [], changestop: [], cancel: [], swatchselect: [] }), this.options = t3 = Object.assign(__spreadValues({}, S2.DEFAULT_OPTIONS), t3);
        const { swatches: e3, components: r3, theme: n3, sliders: i3, lockOpacity: a3, padding: o3 } = t3;
        ["nano", "monolith"].includes(n3) && !i3 && (t3.sliders = "h"), r3.interaction || (r3.interaction = {});
        var { preview: s3, opacity: l3, hue: c3, palette: u3 } = r3;
        r3.opacity = !a3 && l3, r3.palette = u3 || s3 || l3 || c3, this._preBuild(), this._buildComponents(), this._bindEvents(), this._finalBuild(), e3 && e3.length && e3.forEach((e4) => this.addSwatch(e4));
        const { button: h3, app: d3 } = this._root;
        this._nanopop = ((e4, t4) => {
          const r4 = typeof e4 != "object" || e4 instanceof HTMLElement ? __spreadValues({ reference: e4, popper: t4 }, { margin: o3 }) : e4;
          return { update(e5 = r4) {
            var { reference: t5, popper: e5 } = Object.assign(r4, e5);
            if (!e5 || !t5)
              throw new Error("Popper- or reference-element missing.");
            return ((e6, t6, r5) => {
              const { container: n4, margin: i4, position: a4, variantFlipOrder: o4, positionFlipOrder: s4 } = __spreadValues(__spreadValues({ container: document.documentElement.getBoundingClientRect() }, w2), r5), { left: l4, top: c4 } = t6.style;
              t6.style.left = "0", t6.style.top = "0";
              const u4 = e6.getBoundingClientRect(), h4 = t6.getBoundingClientRect(), d4 = { t: u4.top - h4.height - i4, b: u4.bottom + i4, r: u4.right + i4, l: u4.left - h4.width - i4 }, p4 = { vs: u4.left, vm: u4.left + u4.width / 2 + -h4.width / 2, ve: u4.left + u4.width - h4.width, hs: u4.top, hm: u4.bottom - u4.height / 2 - h4.height / 2, he: u4.bottom - h4.height }, [f3, m3 = "middle"] = a4.split("-"), g3 = s4[f3], v3 = o4[m3], { top: y2, left: _3, bottom: b3, right: x3 } = n4;
              for (const e7 of g3) {
                const r6 = e7 === "t" || e7 === "b", n5 = d4[e7], [i5, a5] = r6 ? ["top", "left"] : ["left", "top"], [o5, s5] = r6 ? [h4.height, h4.width] : [h4.width, h4.height], [l5, c5] = r6 ? [b3, x3] : [x3, b3], [u5, f4] = r6 ? [y2, _3] : [_3, y2];
                if (!(n5 < u5 || n5 + o5 > l5))
                  for (const o6 of v3) {
                    const l6 = p4[(r6 ? "v" : "h") + o6];
                    if (!(l6 < f4 || l6 + s5 > c5))
                      return t6.style[a5] = l6 - h4[a5] + "px", t6.style[i5] = n5 - h4[i5] + "px", e7 + o6;
                  }
              }
              return t6.style.left = l4, t6.style.top = c4, null;
            })(t5, e5, r4);
          } };
        })(h3, d3), h3.setAttribute("role", "button"), h3.setAttribute("aria-label", this._t("btn:toggle"));
        const p3 = this;
        this._setupAnimationFrame = requestAnimationFrame(function e4() {
          return d3.offsetWidth ? (p3.setColor(t3.default), p3._rePositioningPicker(), t3.defaultRepresentation && (p3._representation = t3.defaultRepresentation, p3.setColorRepresentation(p3._representation)), t3.showAlways && p3.show(), p3._initializingActive = false, void p3._emit("init")) : requestAnimationFrame(e4);
        });
      }
      _preBuild() {
        const e3 = this["options"];
        for (const t3 of ["el", "container"])
          e3[t3] = a2(e3[t3]);
        this._root = ((t3) => {
          const { components: e4, useAsButton: r3, inline: n3, appClass: i3, theme: a3, lockOpacity: o3 } = t3.options, s3 = (e5) => e5 ? "" : 'style="display:none" hidden', l3 = (e5) => t3._t(e5), c3 = h2(`
      <div :ref="root" class="pickr">

        ${r3 ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${i3 || ""}" data-theme="${a3}" ${n3 ? 'style="position: unset"' : ""} aria-label="${l3("ui:dialog")}" role="window">
          <div class="pcr-selection" ${s3(e4.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${s3(e4.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${l3("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${l3("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${s3(e4.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${l3("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${s3(e4.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${l3("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e4.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${s3(Object.keys(e4.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${s3(e4.interaction.input)} aria-label="${l3("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${o3 ? "HEX" : "HEXA"}" type="button" ${s3(e4.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${o3 ? "RGB" : "RGBA"}" type="button" ${s3(e4.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${o3 ? "HSL" : "HSLA"}" type="button" ${s3(e4.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${o3 ? "HSV" : "HSVA"}" type="button" ${s3(e4.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${s3(e4.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${l3("btn:save")}" type="button" ${s3(e4.interaction.save)} aria-label="${l3("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${l3("btn:cancel")}" type="button" ${s3(e4.interaction.cancel)} aria-label="${l3("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${l3("btn:clear")}" type="button" ${s3(e4.interaction.clear)} aria-label="${l3("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `), u3 = c3.interaction;
          return u3.options.find((e5) => !e5.hidden && !e5.classList.add("active")), u3.type = () => u3.options.find((e5) => e5.classList.contains("active")), c3;
        })(this), e3.useAsButton && (this._root.button = e3.el), e3.container.appendChild(this._root.root);
      }
      _finalBuild() {
        const e3 = this.options, t3 = this._root;
        if (e3.container.removeChild(t3.root), e3.inline) {
          const r3 = e3.el.parentElement;
          e3.el.nextSibling ? r3.insertBefore(t3.app, e3.el.nextSibling) : r3.appendChild(t3.app);
        } else
          e3.container.appendChild(t3.app);
        e3.useAsButton ? e3.inline && e3.el.remove() : e3.el.parentNode.replaceChild(t3.root, e3.el), e3.disabled && this.disable(), e3.comparison || (t3.button.style.transition = "none", e3.useAsButton || (t3.preview.lastColor.style.transition = "none")), this.hide();
      }
      _buildComponents() {
        const l3 = this, c3 = this.options.components, e3 = (l3.options.sliders || "v").repeat(2), [t3, r3] = e3.match(/^[vh]+$/g) ? e3 : [], u3 = () => this._color || (this._color = this._lastColor.clone()), n3 = { palette: b2({ element: l3._root.palette.picker, wrapper: l3._root.palette.palette, onstop: () => l3._emit("changestop", "slider", l3), onchange(e4, t4) {
          if (c3.palette) {
            const n4 = u3(), { _root: i3, options: a3 } = l3, { lastColor: o3, currentColor: s3 } = i3.preview;
            l3._recalc && (n4.s = 100 * e4, n4.v = 100 - 100 * t4, n4.v < 0 && (n4.v = 0), l3._updateOutput("slider"));
            t4 = n4.toRGBA().toString(0);
            this.element.style.background = t4, this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${n4.a}), transparent),
                        linear-gradient(to left, hsla(${n4.h}, 100%, 50%, ${n4.a}), rgba(255, 255, 255, ${n4.a}))
                    `, a3.comparison ? a3.useAsButton || l3._lastColor || o3.style.setProperty("--pcr-color", t4) : (i3.button.style.setProperty("--pcr-color", t4), i3.button.classList.remove("clear"));
            var r4 = n4.toHEXA().toString();
            for (const { el: c4, color: e5 } of l3._swatchColors)
              c4.classList[r4 === e5.toHEXA().toString() ? "add" : "remove"]("pcr-active");
            s3.style.setProperty("--pcr-color", t4);
          }
        } }), hue: b2({ lock: r3 === "v" ? "h" : "v", element: l3._root.hue.picker, wrapper: l3._root.hue.slider, onstop: () => l3._emit("changestop", "slider", l3), onchange(e4) {
          if (c3.hue && c3.palette) {
            const t4 = u3();
            l3._recalc && (t4.h = 360 * e4), this.element.style.backgroundColor = `hsl(${t4.h}, 100%, 50%)`, n3.palette.trigger();
          }
        } }), opacity: b2({ lock: t3 === "v" ? "h" : "v", element: l3._root.opacity.picker, wrapper: l3._root.opacity.slider, onstop: () => l3._emit("changestop", "slider", l3), onchange(e4) {
          if (c3.opacity && c3.palette) {
            const t4 = u3();
            l3._recalc && (t4.a = Math.round(100 * e4) / 100), this.element.style.background = `rgba(0, 0, 0, ${t4.a})`, n3.palette.trigger();
          }
        } }), selectable: function(r4) {
          r4 = Object.assign({ onchange: () => 0, className: "", elements: [] }, r4);
          const e4 = o2(r4.elements, "click", (t4) => {
            r4.elements.forEach((e5) => e5.classList[t4.target === e5 ? "add" : "remove"](r4.className)), r4.onchange(t4), t4.stopPropagation();
          });
          return { destroy: () => i2(...e4) };
        }({ elements: l3._root.interaction.options, className: "active", onchange(e4) {
          l3._representation = e4.target.getAttribute("data-type").toUpperCase(), l3._recalc && l3._updateOutput("swatch");
        } }) };
        this._components = n3;
      }
      _bindEvents() {
        const { _root: t3, options: a3 } = this, e3 = [o2(t3.interaction.clear, "click", () => this._clearColor()), o2([t3.interaction.cancel, t3.preview.lastColor], "click", () => {
          this.setHSVA(...(this._lastColor || this._color).toHSVA(), true), this._emit("cancel");
        }), o2(t3.interaction.save, "click", () => {
          this.applyColor() || a3.showAlways || this.hide();
        }), o2(t3.interaction.result, ["keyup", "input"], (e4) => {
          this.setColor(e4.target.value, true) && !this._initializingActive && (this._emit("change", this._color, "input", this), this._emit("changestop", "input", this)), e4.stopImmediatePropagation();
        }), o2(t3.interaction.result, ["focus", "blur"], (e4) => {
          this._recalc = e4.type === "blur", this._recalc && this._updateOutput(null);
        }), o2([t3.palette.palette, t3.palette.picker, t3.hue.slider, t3.hue.picker, t3.opacity.slider, t3.opacity.picker], ["mousedown", "touchstart"], () => this._recalc = true, { passive: true })];
        if (!a3.showAlways) {
          const r3 = a3.closeWithKey;
          e3.push(o2(t3.button, "click", () => this.isOpen() ? this.hide() : this.show()), o2(document, "keyup", (e4) => this.isOpen() && (e4.key === r3 || e4.code === r3) && this.hide()), o2(document, ["touchstart", "mousedown"], (e4) => {
            this.isOpen() && !l2(e4).some((e5) => e5 === t3.app || e5 === t3.button) && this.hide();
          }, { capture: true }));
        }
        if (a3.adjustableNumbers) {
          const a4 = { rgba: [255, 255, 255, 1], hsva: [360, 100, 100, 1], hsla: [360, 100, 100, 1], cmyk: [100, 100, 100, 100] };
          c2(t3.interaction.result, (e4, t4, r3) => {
            var n3 = a4[this.getColorRepresentation().toLowerCase()];
            if (n3) {
              const a5 = n3[r3], i3 = e4 + (100 <= a5 ? 1e3 * t4 : t4);
              return i3 <= 0 ? 0 : Number((i3 < a5 ? i3 : a5).toPrecision(3));
            }
            return e4;
          });
        }
        if (a3.autoReposition && !a3.inline) {
          let t4 = null;
          const n3 = this;
          e3.push(o2(window, ["scroll", "resize"], () => {
            n3.isOpen() && (a3.closeOnScroll && n3.hide(), t4 === null ? (t4 = setTimeout(() => t4 = null, 100), requestAnimationFrame(function e4() {
              n3._rePositioningPicker(), t4 !== null && requestAnimationFrame(e4);
            })) : (clearTimeout(t4), t4 = setTimeout(() => t4 = null, 100)));
          }, { capture: true }));
        }
        this._eventBindings = e3;
      }
      _rePositioningPicker() {
        const e3 = this["options"];
        if (!e3.inline && !this._nanopop.update({ container: document.body.getBoundingClientRect(), position: e3.position })) {
          const e4 = this._root.app, t3 = e4.getBoundingClientRect();
          e4.style.top = (window.innerHeight - t3.height) / 2 + "px", e4.style.left = (window.innerWidth - t3.width) / 2 + "px";
        }
      }
      _updateOutput(e3) {
        const { _root: t3, _color: r3, options: n3 } = this;
        if (t3.interaction.type()) {
          const e4 = "to" + t3.interaction.type().getAttribute("data-type");
          t3.interaction.result.value = typeof r3[e4] == "function" ? r3[e4]().toString(n3.outputPrecision) : "";
        }
        !this._initializingActive && this._recalc && this._emit("change", r3, e3, this);
      }
      _clearColor(e3 = false) {
        const { _root: t3, options: r3 } = this;
        r3.useAsButton || t3.button.style.setProperty("--pcr-color", "rgba(0, 0, 0, 0.15)"), t3.button.classList.add("clear"), r3.showAlways || this.hide(), this._lastColor = null, this._initializingActive || e3 || (this._emit("save", null), this._emit("clear"));
      }
      _parseLocalColor(e3) {
        const { values: t3, type: r3, a: n3 } = m2(e3), i3 = this.options["lockOpacity"], a3 = n3 !== void 0 && n3 !== 1;
        return t3 && t3.length === 3 && (t3[3] = void 0), { values: !t3 || i3 && a3 ? null : t3, type: r3 };
      }
      _t(e3) {
        return this.options.i18n[e3] || S2.I18N_DEFAULTS[e3];
      }
      _emit(e3, ...t3) {
        this._eventListener[e3].forEach((e4) => e4(...t3, this));
      }
      on(e3, t3) {
        return this._eventListener[e3].push(t3), this;
      }
      off(e3, t3) {
        const r3 = this._eventListener[e3] || [], n3 = r3.indexOf(t3);
        return ~n3 && r3.splice(n3, 1), this;
      }
      addSwatch(e3) {
        var e3 = this._parseLocalColor(e3)["values"];
        if (e3) {
          const { _swatchColors: t3, _root: r3 } = this, n3 = g2(...e3), i3 = s2(`<button type="button" style="--pcr-color: ${n3.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);
          return r3.swatches.appendChild(i3), t3.push({ el: i3, color: n3 }), this._eventBindings.push(o2(i3, "click", () => {
            this.setHSVA(...n3.toHSVA(), true), this._emit("swatchselect", n3), this._emit("change", n3, "swatch", this);
          })), true;
        }
        return false;
      }
      removeSwatch(e3) {
        var t3 = this._swatchColors[e3];
        if (t3) {
          var t3 = t3["el"];
          return this._root.swatches.removeChild(t3), this._swatchColors.splice(e3, 1), true;
        }
        return false;
      }
      applyColor(e3 = false) {
        const { preview: t3, button: r3 } = this._root, n3 = this._color.toRGBA().toString(0);
        return t3.lastColor.style.setProperty("--pcr-color", n3), this.options.useAsButton || r3.style.setProperty("--pcr-color", n3), r3.classList.remove("clear"), this._lastColor = this._color.clone(), this._initializingActive || e3 || this._emit("save", this._color), this;
      }
      destroy() {
        cancelAnimationFrame(this._setupAnimationFrame), this._eventBindings.forEach((e3) => i2(...e3)), Object.keys(this._components).forEach((e3) => this._components[e3].destroy());
      }
      destroyAndRemove() {
        this.destroy();
        const { root: e3, app: t3 } = this._root;
        e3.parentElement && e3.parentElement.removeChild(e3), t3.parentElement.removeChild(t3), Object.keys(this).forEach((e4) => this[e4] = null);
      }
      hide() {
        return !!this.isOpen() && (this._root.app.classList.remove("visible"), this._emit("hide"), true);
      }
      show() {
        return !this.options.disabled && !this.isOpen() && (this._root.app.classList.add("visible"), this._rePositioningPicker(), this._emit("show", this._color), this);
      }
      isOpen() {
        return this._root.app.classList.contains("visible");
      }
      setHSVA(e3 = 360, t3 = 0, r3 = 0, n3 = 1, i3 = false) {
        var a3 = this._recalc;
        if (this._recalc = false, e3 < 0 || 360 < e3 || t3 < 0 || 100 < t3 || r3 < 0 || 100 < r3 || n3 < 0 || 1 < n3)
          return false;
        this._color = g2(e3, t3, r3, n3);
        const { hue: o3, opacity: s3, palette: l3 } = this._components;
        return o3.update(e3 / 360), s3.update(n3), l3.update(t3 / 100, 1 - r3 / 100), i3 || this.applyColor(), a3 && this._updateOutput(), this._recalc = a3, true;
      }
      setColor(t3, e3 = false) {
        if (t3 === null)
          return this._clearColor(e3), true;
        const { values: r3, type: n3 } = this._parseLocalColor(t3);
        if (r3) {
          const t4 = n3.toUpperCase(), i3 = this._root.interaction["options"], a3 = i3.find((e4) => e4.getAttribute("data-type") === t4);
          if (a3 && !a3.hidden)
            for (const t5 of i3)
              t5.classList[t5 === a3 ? "add" : "remove"]("active");
          return !!this.setHSVA(...r3, e3) && this.setColorRepresentation(t4);
        }
        return false;
      }
      setColorRepresentation(t3) {
        return t3 = t3.toUpperCase(), !!this._root.interaction.options.find((e3) => e3.getAttribute("data-type").startsWith(t3) && !e3.click());
      }
      getColorRepresentation() {
        return this._representation;
      }
      getColor() {
        return this._color;
      }
      getSelectedColor() {
        return this._lastColor;
      }
      getRoot() {
        return this._root;
      }
      disable() {
        return this.hide(), this.options.disabled = true, this._root.button.classList.add("disabled"), this;
      }
      enable() {
        return this.options.disabled = false, this._root.button.classList.remove("disabled"), this;
      }
    }
    return x2(S2, "utils", t2), x2(S2, "version", "1.8.2"), x2(S2, "I18N_DEFAULTS", { "ui:dialog": "color picker dialog", "btn:toggle": "toggle color picker dialog", "btn:swatch": "color swatch", "btn:last-color": "use previous color", "btn:save": "Save", "btn:cancel": "Cancel", "btn:clear": "Clear", "aria:btn:save": "save and close", "aria:btn:cancel": "cancel and close", "aria:btn:clear": "clear and close", "aria:input": "color input field", "aria:palette": "color selection area", "aria:hue": "hue selection slider", "aria:opacity": "selection slider" }), x2(S2, "DEFAULT_OPTIONS", { appClass: null, theme: "classic", useAsButton: false, padding: 8, disabled: false, comparison: true, closeOnScroll: false, outputPrecision: 0, lockOpacity: false, autoReposition: true, container: "body", components: { interaction: {} }, i18n: {}, swatches: null, inline: false, sliders: null, default: "#42445a", defaultRepresentation: null, position: "bottom-middle", adjustableNumbers: true, showAlways: false, closeWithKey: "Escape" }), x2(S2, "create", (e3) => new S2(e3)), e2.default;
  })();
  var __Pickr = getDefaultExportFromCjs(pickr_min.exports);
  function plainObject$4(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$4(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$4(a2[e4]) && plainObject$4(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  var __baseCss$1 = `/*! Pickr 1.8.2 MIT | https://github.com/Simonwep/pickr */
.pickr{position:relative;overflow:visible;transform:translateY(0)}
.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}
.pickr .pcr-button{position:relative;height:2em;width:2em;padding:0.5em;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Helvetica Neue",Arial,sans-serif;border-radius:.15em;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" stroke="%2342445A" stroke-width="5px" stroke-linecap="round"><path d="M45,45L5,5"></path><path d="M45,5L5,45"></path></svg>') no-repeat center;background-size:0;transition:all 0.3s}
.pickr .pcr-button::before{position:absolute;content:'';top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}
.pickr .pcr-button::before{z-index:initial}
.pickr .pcr-button::after{position:absolute;content:'';top:0;left:0;height:100%;width:100%;transition:background 0.3s;background:var(--pcr-color);border-radius:.15em}
.pickr .pcr-button.clear{background-size:70%}
.pickr .pcr-button.clear::before{opacity:0}
.pickr .pcr-button.clear:focus{box-shadow:0 0 0 1px rgba(255,255,255,0.85),0 0 0 3px var(--pcr-color)}
.pickr .pcr-button.disabled{cursor:not-allowed}
.pickr *,.pcr-app *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}
.pickr input:focus,.pickr input.pcr-active,.pickr button:focus,.pickr button.pcr-active,.pcr-app input:focus,.pcr-app input.pcr-active,.pcr-app button:focus,.pcr-app button.pcr-active{box-shadow:0 0 0 1px rgba(255,255,255,0.85),0 0 0 3px var(--pcr-color)}
.pickr .pcr-palette,.pickr .pcr-slider,.pcr-app .pcr-palette,.pcr-app .pcr-slider{transition:box-shadow 0.3s}
.pickr .pcr-palette:focus,.pickr .pcr-slider:focus,.pcr-app .pcr-palette:focus,.pcr-app .pcr-slider:focus{box-shadow:0 0 0 1px rgba(255,255,255,0.85),0 0 0 3px rgba(0,0,0,0.25)}
.pcr-app{position:fixed;display:flex;flex-direction:column;z-index:10000;border-radius:0.1em;background:#fff;opacity:0;visibility:hidden;transition:opacity 0.3s, visibility 0s 0.3s;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Helvetica Neue",Arial,sans-serif;box-shadow:0 0.15em 1.5em 0 rgba(0,0,0,0.1),0 0 1em 0 rgba(0,0,0,0.03);left:0;top:0}
.pcr-app.visible{transition:opacity 0.3s;visibility:visible;opacity:1}
.pcr-app .pcr-swatches{display:flex;flex-wrap:wrap;margin-top:0.75em}
.pcr-app .pcr-swatches.pcr-last{margin:0}
@supports (display: grid){.pcr-app .pcr-swatches{display:grid;align-items:center;grid-template-columns:repeat(auto-fit, 1.75em)}}
.pcr-app .pcr-swatches>button{font-size:1em;position:relative;width:calc(1.75em - 5px);height:calc(1.75em - 5px);border-radius:0.15em;cursor:pointer;margin:2.5px;flex-shrink:0;justify-self:center;transition:all 0.15s;overflow:hidden;background:transparent;z-index:1}
.pcr-app .pcr-swatches>button::before{position:absolute;content:'';top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:6px;border-radius:.15em;z-index:-1}
.pcr-app .pcr-swatches>button::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:var(--pcr-color);border:1px solid rgba(0,0,0,0.05);border-radius:0.15em;box-sizing:border-box}
.pcr-app .pcr-swatches>button:hover{filter:brightness(1.05)}
.pcr-app .pcr-swatches>button:not(.pcr-active){box-shadow:none}
.pcr-app .pcr-interaction{display:flex;flex-wrap:wrap;align-items:center;margin:0 -0.2em 0 -0.2em}
.pcr-app .pcr-interaction>*{margin:0 0.2em}
.pcr-app .pcr-interaction input{letter-spacing:0.07em;font-size:0.75em;text-align:center;cursor:pointer;color:#75797e;background:#f1f3f4;border-radius:.15em;transition:all 0.15s;padding:0.45em 0.5em;margin-top:0.75em}
.pcr-app .pcr-interaction input:hover{filter:brightness(0.975)}
.pcr-app .pcr-interaction input:focus{box-shadow:0 0 0 1px rgba(255,255,255,0.85),0 0 0 3px rgba(66,133,244,0.75)}
.pcr-app .pcr-interaction .pcr-result{color:#75797e;text-align:left;flex:1 1 8em;min-width:8em;transition:all 0.2s;border-radius:.15em;background:#f1f3f4;cursor:text}
.pcr-app .pcr-interaction .pcr-result::-moz-selection{background:#4285f4;color:#fff}
.pcr-app .pcr-interaction .pcr-result::selection{background:#4285f4;color:#fff}
.pcr-app .pcr-interaction .pcr-type.active{color:#fff;background:#4285f4}
.pcr-app .pcr-interaction .pcr-save,.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear{color:#fff;width:auto}
.pcr-app .pcr-interaction .pcr-save,.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear{color:#fff}
.pcr-app .pcr-interaction .pcr-save:hover,.pcr-app .pcr-interaction .pcr-cancel:hover,.pcr-app .pcr-interaction .pcr-clear:hover{filter:brightness(0.925)}
.pcr-app .pcr-interaction .pcr-save{background:#4285f4}
.pcr-app .pcr-interaction .pcr-clear,.pcr-app .pcr-interaction .pcr-cancel{background:#f44250}
.pcr-app .pcr-interaction .pcr-clear:focus,.pcr-app .pcr-interaction .pcr-cancel:focus{box-shadow:0 0 0 1px rgba(255,255,255,0.85),0 0 0 3px rgba(244,66,80,0.75)}
.pcr-app .pcr-selection .pcr-picker{position:absolute;height:18px;width:18px;border:2px solid #fff;border-radius:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.pcr-app .pcr-selection .pcr-color-palette,.pcr-app .pcr-selection .pcr-color-chooser,.pcr-app .pcr-selection .pcr-color-opacity{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;cursor:grab;cursor:-webkit-grab}
.pcr-app .pcr-selection .pcr-color-palette:active,.pcr-app .pcr-selection .pcr-color-chooser:active,.pcr-app .pcr-selection .pcr-color-opacity:active{cursor:grabbing;cursor:-webkit-grabbing}
.pcr-app[data-theme='nano']{width:14.25em;max-width:95vw}
.pcr-app[data-theme='nano'] .pcr-swatches{margin-top:.6em;padding:0 .6em}
.pcr-app[data-theme='nano'] .pcr-interaction{padding:0 .6em .6em .6em}
.pcr-app[data-theme='nano'] .pcr-selection{display:grid;grid-gap:.6em;grid-template-columns:1fr 4fr;grid-template-rows:5fr auto auto;align-items:center;height:10.5em;width:100%;align-self:flex-start}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-preview{grid-area:2 / 1 / 4 / 1;height:100%;width:100%;display:flex;flex-direction:row;justify-content:center;margin-left:.6em}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-preview .pcr-last-color{display:none}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-preview .pcr-current-color{position:relative;background:var(--pcr-color);width:2em;height:2em;border-radius:50em;overflow:hidden}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-preview .pcr-current-color::before{position:absolute;content:'';top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-palette{grid-area:1 / 1 / 2 / 3;width:100%;height:100%;z-index:1}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-palette .pcr-palette{border-radius:.15em;width:100%;height:100%}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-palette .pcr-palette::before{position:absolute;content:'';top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-chooser{grid-area:2 / 2 / 2 / 2}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-opacity{grid-area:3 / 2 / 3 / 2}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-chooser,.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-opacity{height:0.5em;margin:0 .6em}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-chooser .pcr-picker,.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-opacity .pcr-picker{top:50%;transform:translateY(-50%)}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-chooser .pcr-slider,.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-opacity .pcr-slider{flex-grow:1;border-radius:50em}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-chooser .pcr-slider{background:linear-gradient(to right, red, #ff0, lime, cyan, blue, #f0f, red)}
.pcr-app[data-theme='nano'] .pcr-selection .pcr-color-opacity .pcr-slider{background:linear-gradient(to right, transparent, black),url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:100%, 0.25em}

`, __css$5 = "s-color-picker:not([mounted]) > * {\n        display: none;\n    }\n    s-color-picker:not([no-input]) .s-color-picker {\n        display: flex;\n        position: relative;\n        align-items: center;\n    }\n    s-color-picker[no-input] .s-color-picker {\n        position: relative;\n        display: inline-block;\n    }\n    s-color-picker .s-color-picker--top .s-color-picker__picker {\n        position: absolute !important;\n        top: auto !important;\n        right: 0 !important;\n        left: auto !important;\n        bottom: 100% !important;\n        pointer-events: all !important;\n    }\n    s-color-picker .s-color-picker--bottom .s-color-picker__picker {\n        position: absolute !important;\n        top: 100% !important;\n        right: 0 !important;\n        left: auto !important;\n        pointer-events: all !important;\n    }\n    s-color-picker[no-preview] .s-color-picker__picker-wrapper,\n    s-color-picker[no-preview] .s-color-picker__preview {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n    }\n    s-color-picker[no-preview] .s-color-picker__picker-wrapper button, s-color-picker[no-preview] .s-color-picker__preview button {\n            width: 100%;\n            height: 100%;\n            position: absolute;\n            top: 0;\n            left: 0;\n            background: none !important;\n            pointer-events: none;\n        }\n    s-color-picker[no-preview] .s-color-picker__picker-wrapper button:before,\n            s-color-picker[no-preview] .s-color-picker__picker-wrapper button:after,\n            s-color-picker[no-preview] .s-color-picker__preview button:before,\n            s-color-picker[no-preview] .s-color-picker__preview button:after {\n                content: initial;\n            }\n    s-color-picker :not([bare]) input:not([type='hidden']) ~ .s-color-picker__preview {\n        position: absolute;\n        top: 50%;\n        right: 0;\n        transform: translate(-50%, -50%);\n    }\n\n.s-color-picker__input {\n    /* border-top-right-radius: 0 !important;\n    border-bottom-right-radius: 0 !important; */\n\n    /* :not([bare]) & ~ .s-color-picker__preview {\n        display: block;\n        aspect-ratio: 1;\n        height: 100%;\n\n        button {\n            width: 100% !important;\n            height: 100% !important;\n\n            &,\n            &:before,\n            &:after {\n                border-top-left-radius: 0 !important;\n                border-bottom-left-radius: 0 !important;\n            }\n        }\n    } */\n}\n\n.s-color-picker__picker {\n    position: absolute !important;\n    top: 100% !important;\n    right: 0 !important;\n    left: auto !important;\n    z-index: 10;\n}\n\n:not([bare]) .s-color-picker__picker {\n        background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n        overflow: hidden;box-shadow: var(--s-theme-ui-colorPicker-depth, 0);\n        border-radius: var(--s-theme-ui-colorPicker-borderRadius, 10px);\n        padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n        padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n    }\n\n.pickr.s-color-picker__preview {\n    display: inline-block;\n    outline: none;\n    width: 1em;\n    height: 1em;\n}\n\n:not([bare]) .pickr.s-color-picker__preview {\n        transition: var(--s-theme-transition-fast, all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n/* button:focus {\n        display: none;\n    } */\n\n.pickr.s-color-picker__preview button {\n        position: absolute;\n        width: 1em;\n        height: 1em;\n        top: 0;\n        left: 0;\n        border-radius: var(--s-theme-border-radius-default) ;\n    }\n\n.pickr.s-color-picker__preview button:before,\n        .pickr.s-color-picker__preview button:after {\n            border-radius: var(--s-theme-border-radius-default) ;\n        }\n";
  class SColorPickerComponentInterface extends SInterface {
    static get _definition() {
      return { name: { description: "Specify the name that will be assigned to the injected input if you don't provide one yourself", type: "String", default: "date" }, value: { description: "Specify the initial value for your picker", type: "String" }, placeholder: { description: "Specify the placeholder that will be assigned to the injected input if you don't provide one yourself", type: "String", default: "Select a color" }, theme: { description: "Specify the theme you want to use for this picker", type: "String", values: ["nano", "monolith"], default: "nano" }, noInput: { description: "Specify if you dont want an automatically injected text input when you dont provide yours", type: "Boolean", default: false }, noPreview: { description: "Specify if you want to display the preview or not", type: "Boolean", default: false, physical: true }, position: { description: 'Specify the position of the picker. Can be "top" or "bottom"', type: "String", values: ["top", "bottom"], default: "bottom" }, swatches: { description: "Specify some colors you want in your swatches", type: "Array<String>", default: [] } };
    }
  }
  function wait(t2 = 0) {
    return new Promise((e2) => {
      setTimeout(() => {
        e2();
      }, t2);
    });
  }
  var __awaiter$a = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SColorPicker extends SLitComponent {
    static get properties() {
      return SLitComponent.properties({}, SColorPickerComponentInterface);
    }
    static get styles() {
      return r$2`
            ${o$3(`
            ${__baseCss$1}
            ${__css$5}
        `)}
        `;
    }
    constructor() {
      super(__deepMerge$4({ litComponent: { shadowDom: false }, componentUtils: { interface: SColorPickerComponentInterface } }));
    }
    firstUpdated() {
      var s2;
      return __awaiter$a(this, void 0, void 0, function* () {
        yield wait(100);
        let r2 = this.querySelector("input");
        var e2 = (s2 = (s2 = this.props.value) !== null && s2 !== void 0 ? s2 : r2 === null || r2 === void 0 ? void 0 : r2.value) !== null && s2 !== void 0 ? s2 : "#ff0000";
        r2 ? r2.classList.add(this.componentUtils.className("__input")) : (r2 = document.createElement("input"), r2.setAttribute("type", this.props.noInput ? "hidden" : "text"), this.props.noInput || r2.setAttribute("class", this.componentUtils.className("__input", "s-input"))), r2.hasAttribute("name") || r2.setAttribute("name", this.props.name), r2.hasAttribute("placeholder") || r2.setAttribute("placeholder", this.props.placeholder), r2.hasAttribute("autocomplete") || r2.setAttribute("autocomplete", "off");
        const t2 = this.querySelector("." + this.componentUtils.className(""));
        r2 && (t2.prepend(r2), r2.classList.add(this.componentUtils.className("__input")));
        const o2 = __Pickr.create({ el: (s2 = this.querySelector(".s-color-picker__preview")) !== null && s2 !== void 0 ? s2 : this, theme: "nano", container: this.querySelector(".s-color-picker__picker-wrapper"), default: e2, inline: true, comparison: false, swatches: [], components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, hsla: true, input: true, clear: true } } });
        function n2() {
          const e3 = o2.getColor(), t3 = e3.toHSLA(), r3 = e3.toHSVA(), n3 = e3.toRGBA(), i3 = e3.toHEXA(), a3 = e3.toCMYK();
          return { isOpened: o2.isOpen(), hsla: { h: t3[0], s: t3[1], l: t3[2], a: t3[3], string: `hsla(${t3[0]},${t3[1]},${t3[2]},${t3[3]})` }, hsva: { h: r3[0], s: r3[1], v: r3[2], a: r3[3], string: `hsva(${r3[0]},${r3[1]},${r3[2]},${r3[3]})` }, rgba: { r: n3[0], g: n3[1], b: n3[2], a: n3[3], string: `rgba(${n3[0]},${n3[1]},${n3[2]},${n3[3]})` }, hex: i3.toString(), cmyk: { c: a3[0], m: a3[1], y: a3[2], k: a3[3], string: `cmyk(${a3[0]},${a3[1]},${a3[2]},${a3[3]})` } };
        }
        o2.on("change", () => {
          o2.applyColor();
          var e3 = n2(), t3 = new CustomEvent("change", { detail: e3 });
          r2 && (r2.value = e3.hex), this.dispatchEvent(t3);
        }), o2.on("show", () => {
          var e3 = n2(), e3 = new CustomEvent("show", { detail: e3 });
          this.dispatchEvent(e3);
        }), o2.on("hide", () => {
          var e3 = n2(), e3 = new CustomEvent("hide", { detail: e3 });
          this.dispatchEvent(e3);
        }), o2.on("cancel", () => {
          var e3 = n2(), e3 = new CustomEvent("cancel", { detail: e3 });
          this.dispatchEvent(e3);
        }), r2 && (r2.addEventListener("focus", () => {
          o2.show();
        }), r2.addEventListener("change", () => {
          o2.setColor(r2.value);
        }));
        const i2 = this.querySelector(".pcr-app");
        i2 !== null && i2 !== void 0 && i2.classList.add(this.componentUtils.className("__picker"));
        const a2 = this.querySelector(".pickr");
        a2 !== null && a2 !== void 0 && a2.classList.add(this.componentUtils.className("__preview"));
      });
    }
    render() {
      return p`
            <div
                class="${this.componentUtils.className("")} ${this.componentUtils.className("")}--${this.props.position}"
            >
                <div
                    class="${this.componentUtils.className("__picker-wrapper")}"
                ></div>
                <div
                    class="${this.componentUtils.className("__preview")}"
                ></div>
            </div>
        `;
    }
  }
  function define$c(e2 = {}, t2 = "s-color-picker") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SColorPicker);
  }
  class SSugarConfig {
    static get(e2) {
      var t2;
      return get$3((t2 = (t2 = (t2 = window.env) === null || t2 === void 0 ? void 0 : t2.SUGAR) === null || t2 === void 0 ? void 0 : t2.config) !== null && t2 !== void 0 ? t2 : {}, e2);
    }
  }
  var pikaday = { exports: {} }, Cma;
  Cma = pikaday, function() {
    var i2, a2, o2, d2, l2, s2, t2, c2, p2, f2, g2, $2, R2, L, O, u2, h2, r2, n2, m2, P2, I2, e2;
    try {
      e2 = require("moment");
    } catch (e3) {
    }
    Cma.exports = (a2 = typeof (i2 = e2) == "function", o2 = !!window.addEventListener, d2 = window.document, l2 = window.setTimeout, s2 = function(e3, t3, r3, n3) {
      o2 ? e3.addEventListener(t3, r3, !!n3) : e3.attachEvent("on" + t3, r3);
    }, t2 = function(e3, t3, r3, n3) {
      o2 ? e3.removeEventListener(t3, r3, !!n3) : e3.detachEvent("on" + t3, r3);
    }, c2 = function(e3, t3) {
      return (" " + e3.className + " ").indexOf(" " + t3 + " ") !== -1;
    }, p2 = function(e3, t3) {
      c2(e3, t3) || (e3.className = e3.className === "" ? t3 : e3.className + " " + t3);
    }, f2 = function(e3, t3) {
      e3.className = (t3 = (" " + e3.className + " ").replace(" " + t3 + " ", " ")).trim ? t3.trim() : t3.replace(/^\s+|\s+$/g, "");
    }, n2 = { field: null, bound: void 0, ariaLabel: "Use the arrow keys to pick a date", position: "bottom left", reposition: true, format: "YYYY-MM-DD", toString: null, parse: null, defaultDate: null, setDefaultDate: !(r2 = function(e3) {
      return e3.month < 0 && (e3.year -= Math.ceil(Math.abs(e3.month) / 12), e3.month += 12), 11 < e3.month && (e3.year += Math.floor(Math.abs(e3.month) / 12), e3.month -= 12), e3;
    }), firstDay: 0, firstWeekOfYearMinDays: 4, formatStrict: !(h2 = function(e3, t3, r3) {
      var n3;
      d2.createEvent ? ((n3 = d2.createEvent("HTMLEvents")).initEvent(t3, true, false), n3 = u2(n3, r3), e3.dispatchEvent(n3)) : d2.createEventObject && (n3 = d2.createEventObject(), n3 = u2(n3, r3), e3.fireEvent("on" + t3, n3));
    }), minDate: null, maxDate: null, yearRange: 10, showWeekNumber: !(u2 = function(e3, t3, r3) {
      var n3, i3;
      for (n3 in t3)
        (i3 = e3[n3] !== void 0) && typeof t3[n3] == "object" && t3[n3] !== null && t3[n3].nodeName === void 0 ? $2(t3[n3]) ? r3 && (e3[n3] = new Date(t3[n3].getTime())) : g2(t3[n3]) ? r3 && (e3[n3] = t3[n3].slice(0)) : e3[n3] = u2({}, t3[n3], r3) : !r3 && i3 || (e3[n3] = t3[n3]);
      return e3;
    }), pickWholeWeek: !(O = function(e3, t3) {
      return e3.getTime() === t3.getTime();
    }), minYear: 0, maxYear: 9999, minMonth: void 0, maxMonth: void 0, startRange: null, endRange: null, isRTL: !(L = function(e3) {
      $2(e3) && e3.setHours(0, 0, 0, 0);
    }), yearSuffix: "", showMonthAfterYear: !(R2 = function(e3, t3) {
      return [31, (e3 = e3) % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t3];
    }), showDaysInNextAndPreviousMonths: !($2 = function(e3) {
      return /Date/.test(Object.prototype.toString.call(e3)) && !isNaN(e3.getTime());
    }), enableSelectionDaysInNextAndPreviousMonths: !(g2 = function(e3) {
      return /Array/.test(Object.prototype.toString.call(e3));
    }), numberOfMonths: 1, mainCalendar: "left", container: void 0, blurFieldOnSelect: true, i18n: { previousMonth: "Previous Month", nextMonth: "Next Month", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] }, theme: null, events: [], onSelect: null, onOpen: null, onClose: null, onDraw: null, keyboardInput: true }, m2 = function(e3, t3, r3) {
      for (t3 += e3.firstDay; 7 <= t3; )
        t3 -= 7;
      return (r3 ? e3.i18n.weekdaysShort : e3.i18n.weekdays)[t3];
    }, P2 = function(e3, t3, r3, n3) {
      e3 = new Date(r3, t3, e3);
      return '<td class="pika-week">' + (a2 ? i2(e3).isoWeek() : function(e4, t4) {
        e4.setHours(0, 0, 0, 0);
        var r4 = e4.getDate(), n4 = e4.getDay(), i3 = t4, a3 = i3 - 1, t4 = function(e5) {
          return (e5 + 7 - 1) % 7;
        };
        e4.setDate(r4 + a3 - t4(n4));
        i3 = new Date(e4.getFullYear(), 0, i3), e4 = (e4.getTime() - i3.getTime()) / 864e5;
        return 1 + Math.round((e4 - a3 + t4(i3.getDay())) / 7);
      }(e3, n3)) + "</td>";
    }, I2 = function(e3, t3, r3) {
      return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + r3 + '">' + function(e4) {
        var t4, r4 = [];
        for (e4.showWeekNumber && r4.push("<th></th>"), t4 = 0; t4 < 7; t4++)
          r4.push('<th scope="col"><abbr title="' + m2(e4, t4) + '">' + m2(e4, t4, true) + "</abbr></th>");
        return "<thead><tr>" + (e4.isRTL ? r4.reverse() : r4).join("") + "</tr></thead>";
      }(e3) + "<tbody>" + t3.join("") + "</tbody></table>";
    }, (e2 = function(e3) {
      var r3 = this, n3 = r3.config(e3);
      r3._onMouseDown = function(e4) {
        if (r3._v) {
          var t3 = (e4 = e4 || window.event).target || e4.srcElement;
          if (t3)
            if (c2(t3, "is-disabled") || (!c2(t3, "pika-button") || c2(t3, "is-empty") || c2(t3.parentNode, "is-disabled") ? c2(t3, "pika-prev") ? r3.prevMonth() : c2(t3, "pika-next") && r3.nextMonth() : (r3.setDate(new Date(t3.getAttribute("data-pika-year"), t3.getAttribute("data-pika-month"), t3.getAttribute("data-pika-day"))), n3.bound && l2(function() {
              r3.hide(), n3.blurFieldOnSelect && n3.field && n3.field.blur();
            }, 100))), c2(t3, "pika-select"))
              r3._c = true;
            else {
              if (!e4.preventDefault)
                return e4.returnValue = false;
              e4.preventDefault();
            }
        }
      }, r3._onChange = function(e4) {
        e4 = (e4 = e4 || window.event).target || e4.srcElement;
        e4 && (c2(e4, "pika-select-month") ? r3.gotoMonth(e4.value) : c2(e4, "pika-select-year") && r3.gotoYear(e4.value));
      }, r3._onKeyChange = function(e4) {
        if (e4 = e4 || window.event, r3.isVisible())
          switch (e4.keyCode) {
            case 13:
            case 27:
              n3.field && n3.field.blur();
              break;
            case 37:
              r3.adjustDate("subtract", 1);
              break;
            case 38:
              r3.adjustDate("subtract", 7);
              break;
            case 39:
              r3.adjustDate("add", 1);
              break;
            case 40:
              r3.adjustDate("add", 7);
              break;
            case 8:
            case 46:
              r3.setDate(null);
          }
      }, r3._parseFieldValue = function() {
        if (n3.parse)
          return n3.parse(n3.field.value, n3.format);
        if (a2) {
          var e4 = i2(n3.field.value, n3.format, n3.formatStrict);
          return e4 && e4.isValid() ? e4.toDate() : null;
        }
        return new Date(Date.parse(n3.field.value));
      }, r3._onInputChange = function(e4) {
        e4.firedBy !== r3 && (e4 = r3._parseFieldValue(), $2(e4) && r3.setDate(e4), r3._v || r3.show());
      }, r3._onInputFocus = function() {
        r3.show();
      }, r3._onInputClick = function() {
        r3.show();
      }, r3._onInputBlur = function() {
        var e4 = d2.activeElement;
        do {
          if (c2(e4, "pika-single"))
            return;
        } while (e4 = e4.parentNode);
        r3._c || (r3._b = l2(function() {
          r3.hide();
        }, 50)), r3._c = false;
      }, r3._onClick = function(e4) {
        var e4 = (e4 = e4 || window.event).target || e4.srcElement, t3 = e4;
        if (e4) {
          !o2 && c2(e4, "pika-select") && (e4.onchange || (e4.setAttribute("onchange", "return;"), s2(e4, "change", r3._onChange)));
          do {
            if (c2(t3, "pika-single") || t3 === n3.trigger)
              return;
          } while (t3 = t3.parentNode);
          r3._v && e4 !== n3.trigger && t3 !== n3.trigger && r3.hide();
        }
      }, r3.el = d2.createElement("div"), r3.el.className = "pika-single" + (n3.isRTL ? " is-rtl" : "") + (n3.theme ? " " + n3.theme : ""), s2(r3.el, "mousedown", r3._onMouseDown, true), s2(r3.el, "touchend", r3._onMouseDown, true), s2(r3.el, "change", r3._onChange), n3.keyboardInput && s2(d2, "keydown", r3._onKeyChange), n3.field && (n3.container ? n3.container.appendChild(r3.el) : n3.bound ? d2.body.appendChild(r3.el) : n3.field.parentNode.insertBefore(r3.el, n3.field.nextSibling), s2(n3.field, "change", r3._onInputChange), n3.defaultDate || (n3.defaultDate = r3._parseFieldValue(), n3.setDefaultDate = true));
      e3 = n3.defaultDate;
      $2(e3) ? n3.setDefaultDate ? r3.setDate(e3, true) : r3.gotoDate(e3) : r3.gotoDate(new Date()), n3.bound ? (this.hide(), r3.el.className += " is-bound", s2(n3.trigger, "click", r3._onInputClick), s2(n3.trigger, "focus", r3._onInputFocus), s2(n3.trigger, "blur", r3._onInputBlur)) : this.show();
    }).prototype = { config: function(e3) {
      this._o || (this._o = u2({}, n2, true));
      var t3 = u2(this._o, e3, true);
      t3.isRTL = !!t3.isRTL, t3.field = t3.field && t3.field.nodeName ? t3.field : null, t3.theme = typeof t3.theme == "string" && t3.theme ? t3.theme : null, t3.bound = !!(t3.bound !== void 0 ? t3.field && t3.bound : t3.field), t3.trigger = t3.trigger && t3.trigger.nodeName ? t3.trigger : t3.field, t3.disableWeekends = !!t3.disableWeekends, t3.disableDayFn = typeof t3.disableDayFn == "function" ? t3.disableDayFn : null;
      e3 = parseInt(t3.numberOfMonths, 10) || 1;
      return t3.numberOfMonths = 4 < e3 ? 4 : e3, $2(t3.minDate) || (t3.minDate = false), $2(t3.maxDate) || (t3.maxDate = false), t3.minDate && t3.maxDate && t3.maxDate < t3.minDate && (t3.maxDate = t3.minDate = false), t3.minDate && this.setMinDate(t3.minDate), t3.maxDate && this.setMaxDate(t3.maxDate), g2(t3.yearRange) ? (e3 = new Date().getFullYear() - 10, t3.yearRange[0] = parseInt(t3.yearRange[0], 10) || e3, t3.yearRange[1] = parseInt(t3.yearRange[1], 10) || e3) : (t3.yearRange = Math.abs(parseInt(t3.yearRange, 10)) || n2.yearRange, 100 < t3.yearRange && (t3.yearRange = 100)), t3;
    }, toString: function(e3) {
      return e3 = e3 || this._o.format, $2(this._d) ? this._o.toString ? this._o.toString(this._d, e3) : a2 ? i2(this._d).format(e3) : this._d.toDateString() : "";
    }, getMoment: function() {
      return a2 ? i2(this._d) : null;
    }, setMoment: function(e3, t3) {
      a2 && i2.isMoment(e3) && this.setDate(e3.toDate(), t3);
    }, getDate: function() {
      return $2(this._d) ? new Date(this._d.getTime()) : null;
    }, setDate: function(e3, t3) {
      if (!e3)
        return this._d = null, this._o.field && (this._o.field.value = "", h2(this._o.field, "change", { firedBy: this })), this.draw();
      var r3, n3;
      typeof e3 == "string" && (e3 = new Date(Date.parse(e3))), $2(e3) && (r3 = this._o.minDate, n3 = this._o.maxDate, $2(r3) && e3 < r3 ? e3 = r3 : $2(n3) && n3 < e3 && (e3 = n3), this._d = new Date(e3.getTime()), L(this._d), this.gotoDate(this._d), this._o.field && (this._o.field.value = this.toString(), h2(this._o.field, "change", { firedBy: this })), t3 || typeof this._o.onSelect != "function" || this._o.onSelect.call(this, this.getDate()));
    }, clear: function() {
      this.setDate(null);
    }, gotoDate: function(e3) {
      var t3, r3, n3, i3 = true;
      $2(e3) && (this.calendars && (t3 = new Date(this.calendars[0].year, this.calendars[0].month, 1), r3 = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), n3 = e3.getTime(), r3.setMonth(r3.getMonth() + 1), r3.setDate(r3.getDate() - 1), i3 = n3 < t3.getTime() || r3.getTime() < n3), i3 && (this.calendars = [{ month: e3.getMonth(), year: e3.getFullYear() }], this._o.mainCalendar === "right" && (this.calendars[0].month += 1 - this._o.numberOfMonths)), this.adjustCalendars());
    }, adjustDate: function(e3, t3) {
      var r3, n3 = this.getDate() || new Date(), t3 = 24 * parseInt(t3) * 60 * 60 * 1e3;
      e3 === "add" ? r3 = new Date(n3.valueOf() + t3) : e3 === "subtract" && (r3 = new Date(n3.valueOf() - t3)), this.setDate(r3);
    }, adjustCalendars: function() {
      this.calendars[0] = r2(this.calendars[0]);
      for (var e3 = 1; e3 < this._o.numberOfMonths; e3++)
        this.calendars[e3] = r2({ month: this.calendars[0].month + e3, year: this.calendars[0].year });
      this.draw();
    }, gotoToday: function() {
      this.gotoDate(new Date());
    }, gotoMonth: function(e3) {
      isNaN(e3) || (this.calendars[0].month = parseInt(e3, 10), this.adjustCalendars());
    }, nextMonth: function() {
      this.calendars[0].month++, this.adjustCalendars();
    }, prevMonth: function() {
      this.calendars[0].month--, this.adjustCalendars();
    }, gotoYear: function(e3) {
      isNaN(e3) || (this.calendars[0].year = parseInt(e3, 10), this.adjustCalendars());
    }, setMinDate: function(e3) {
      e3 instanceof Date ? (L(e3), this._o.minDate = e3, this._o.minYear = e3.getFullYear(), this._o.minMonth = e3.getMonth()) : (this._o.minDate = n2.minDate, this._o.minYear = n2.minYear, this._o.minMonth = n2.minMonth, this._o.startRange = n2.startRange), this.draw();
    }, setMaxDate: function(e3) {
      e3 instanceof Date ? (L(e3), this._o.maxDate = e3, this._o.maxYear = e3.getFullYear(), this._o.maxMonth = e3.getMonth()) : (this._o.maxDate = n2.maxDate, this._o.maxYear = n2.maxYear, this._o.maxMonth = n2.maxMonth, this._o.endRange = n2.endRange), this.draw();
    }, setStartRange: function(e3) {
      this._o.startRange = e3;
    }, setEndRange: function(e3) {
      this._o.endRange = e3;
    }, draw: function(e3) {
      if (this._v || e3) {
        var t3, r3 = this._o, n3 = r3.minYear, i3 = r3.maxYear, a3 = r3.minMonth, e3 = r3.maxMonth, o3 = "";
        this._y <= n3 && (this._y = n3, !isNaN(a3) && this._m < a3 && (this._m = a3)), this._y >= i3 && (this._y = i3, !isNaN(e3) && this._m > e3 && (this._m = e3));
        for (var s3 = 0; s3 < r3.numberOfMonths; s3++)
          t3 = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2), o3 += '<div class="pika-lendar">' + function(e4, t4, r4, n4, i4, a4) {
            for (var o4, s4, l3 = e4._o, c3 = r4 === l3.minYear, u3 = r4 === l3.maxYear, h3 = '<div id="' + a4 + '" class="pika-title" role="heading" aria-live="assertive">', d3 = true, p3 = true, f3 = [], m3 = 0; m3 < 12; m3++)
              f3.push('<option value="' + (r4 === i4 ? m3 - t4 : 12 + m3 - t4) + '"' + (m3 === n4 ? ' selected="selected"' : "") + (c3 && m3 < l3.minMonth || u3 && m3 > l3.maxMonth ? ' disabled="disabled"' : "") + ">" + l3.i18n.months[m3] + "</option>");
            for (s4 = '<div class="pika-label">' + l3.i18n.months[n4] + '<select class="pika-select pika-select-month" tabindex="-1">' + f3.join("") + "</select></div>", o4 = g2(l3.yearRange) ? (m3 = l3.yearRange[0], l3.yearRange[1] + 1) : (m3 = r4 - l3.yearRange, 1 + r4 + l3.yearRange), f3 = []; m3 < o4 && m3 <= l3.maxYear; m3++)
              m3 >= l3.minYear && f3.push('<option value="' + m3 + '"' + (m3 === r4 ? ' selected="selected"' : "") + ">" + m3 + "</option>");
            return a4 = '<div class="pika-label">' + r4 + l3.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + f3.join("") + "</select></div>", l3.showMonthAfterYear ? h3 += a4 + s4 : h3 += s4 + a4, c3 && (n4 === 0 || l3.minMonth >= n4) && (d3 = false), u3 && (n4 === 11 || l3.maxMonth <= n4) && (p3 = false), t4 === 0 && (h3 += '<button class="pika-prev' + (d3 ? "" : " is-disabled") + '" type="button">' + l3.i18n.previousMonth + "</button>"), t4 === e4._o.numberOfMonths - 1 && (h3 += '<button class="pika-next' + (p3 ? "" : " is-disabled") + '" type="button">' + l3.i18n.nextMonth + "</button>"), h3 + "</div>";
          }(this, s3, this.calendars[s3].year, this.calendars[s3].month, this.calendars[0].year, t3) + this.render(this.calendars[s3].year, this.calendars[s3].month, t3) + "</div>";
        this.el.innerHTML = o3, r3.bound && r3.field.type !== "hidden" && l2(function() {
          r3.trigger.focus();
        }, 1), typeof this._o.onDraw == "function" && this._o.onDraw(this), r3.bound && r3.field.setAttribute("aria-label", r3.ariaLabel);
      }
    }, adjustPosition: function() {
      var e3, t3, r3, n3, i3, a3, o3, s3, l3, c3, u3, h3;
      if (!this._o.container) {
        if (this.el.style.position = "absolute", t3 = e3 = this._o.trigger, r3 = this.el.offsetWidth, n3 = this.el.offsetHeight, i3 = window.innerWidth || d2.documentElement.clientWidth, a3 = window.innerHeight || d2.documentElement.clientHeight, o3 = window.pageYOffset || d2.body.scrollTop || d2.documentElement.scrollTop, h3 = u3 = true, typeof e3.getBoundingClientRect == "function")
          s3 = (c3 = e3.getBoundingClientRect()).left + window.pageXOffset, l3 = c3.bottom + window.pageYOffset;
        else
          for (s3 = t3.offsetLeft, l3 = t3.offsetTop + t3.offsetHeight; t3 = t3.offsetParent; )
            s3 += t3.offsetLeft, l3 += t3.offsetTop;
        (this._o.reposition && i3 < s3 + r3 || -1 < this._o.position.indexOf("right") && 0 < s3 - r3 + e3.offsetWidth) && (s3 = s3 - r3 + e3.offsetWidth, u3 = false), (this._o.reposition && a3 + o3 < l3 + n3 || -1 < this._o.position.indexOf("top") && 0 < l3 - n3 - e3.offsetHeight) && (l3 = l3 - n3 - e3.offsetHeight, h3 = false), this.el.style.left = s3 + "px", this.el.style.top = l3 + "px", p2(this.el, u3 ? "left-aligned" : "right-aligned"), p2(this.el, h3 ? "bottom-aligned" : "top-aligned"), f2(this.el, u3 ? "right-aligned" : "left-aligned"), f2(this.el, h3 ? "top-aligned" : "bottom-aligned");
      }
    }, render: function(e3, t3, r3) {
      var n3 = this._o, i3 = new Date(), a3 = R2(e3, t3), o3 = new Date(e3, t3, 1).getDay(), s3 = [], l3 = [];
      L(i3), 0 < n3.firstDay && (o3 -= n3.firstDay) < 0 && (o3 += 7);
      for (var c3 = t3 === 0 ? 11 : t3 - 1, u3 = t3 === 11 ? 0 : t3 + 1, h3 = t3 === 0 ? e3 - 1 : e3, d3 = t3 === 11 ? e3 + 1 : e3, p3 = R2(h3, c3), f3 = a3 + o3, m3 = f3; 7 < m3; )
        m3 -= 7;
      f3 += 7 - m3;
      for (var g3 = false, v2 = 0, y = 0; v2 < f3; v2++) {
        var _2 = new Date(e3, t3, v2 - o3 + 1), b2 = !!$2(this._d) && O(_2, this._d), x2 = O(_2, i3), w2 = n3.events.indexOf(_2.toDateString()) !== -1, S2 = v2 < o3 || a3 + o3 <= v2, M2 = v2 - o3 + 1, E2 = t3, T2 = e3, k2 = n3.startRange && O(n3.startRange, _2), A2 = n3.endRange && O(n3.endRange, _2), C2 = n3.startRange && n3.endRange && n3.startRange < _2 && _2 < n3.endRange;
        S2 && (T2 = v2 < o3 ? (M2 = p3 + M2, E2 = c3, h3) : (M2 -= a3, E2 = u3, d3));
        var C2 = { day: M2, month: E2, year: T2, hasEvent: w2, isSelected: b2, isToday: x2, isDisabled: n3.minDate && _2 < n3.minDate || n3.maxDate && _2 > n3.maxDate || n3.disableWeekends && function(e4) {
          e4 = e4.getDay();
          return e4 === 0 || e4 === 6;
        }(_2) || n3.disableDayFn && n3.disableDayFn(_2), isEmpty: S2, isStartRange: k2, isEndRange: A2, isInRange: C2, showDaysInNextAndPreviousMonths: n3.showDaysInNextAndPreviousMonths, enableSelectionDaysInNextAndPreviousMonths: n3.enableSelectionDaysInNextAndPreviousMonths };
        n3.pickWholeWeek && b2 && (g3 = true), l3.push(function(e4) {
          var t4 = [], r4 = "false";
          if (e4.isEmpty) {
            if (!e4.showDaysInNextAndPreviousMonths)
              return '<td class="is-empty"></td>';
            t4.push("is-outside-current-month"), e4.enableSelectionDaysInNextAndPreviousMonths || t4.push("is-selection-disabled");
          }
          return e4.isDisabled && t4.push("is-disabled"), e4.isToday && t4.push("is-today"), e4.isSelected && (t4.push("is-selected"), r4 = "true"), e4.hasEvent && t4.push("has-event"), e4.isInRange && t4.push("is-inrange"), e4.isStartRange && t4.push("is-startrange"), e4.isEndRange && t4.push("is-endrange"), '<td data-day="' + e4.day + '" class="' + t4.join(" ") + '" aria-selected="' + r4 + '"><button class="pika-button pika-day" type="button" data-pika-year="' + e4.year + '" data-pika-month="' + e4.month + '" data-pika-day="' + e4.day + '">' + e4.day + "</button></td>";
        }(C2)), ++y == 7 && (n3.showWeekNumber && l3.unshift(P2(v2 - o3, t3, e3, n3.firstWeekOfYearMinDays)), s3.push((b2 = l3, C2 = n3.isRTL, '<tr class="pika-row' + (n3.pickWholeWeek ? " pick-whole-week" : "") + (g3 ? " is-selected" : "") + '">' + (C2 ? b2.reverse() : b2).join("") + "</tr>")), y = 0, g3 = !(l3 = []));
      }
      return I2(n3, s3, r3);
    }, isVisible: function() {
      return this._v;
    }, show: function() {
      this.isVisible() || (this._v = true, this.draw(), f2(this.el, "is-hidden"), this._o.bound && (s2(d2, "click", this._onClick), this.adjustPosition()), typeof this._o.onOpen == "function" && this._o.onOpen.call(this));
    }, hide: function() {
      var e3 = this._v;
      e3 !== false && (this._o.bound && t2(d2, "click", this._onClick), this._o.container || (this.el.style.position = "static", this.el.style.left = "auto", this.el.style.top = "auto"), p2(this.el, "is-hidden"), this._v = false, e3 !== void 0 && typeof this._o.onClose == "function" && this._o.onClose.call(this));
    }, destroy: function() {
      var e3 = this._o;
      this.hide(), t2(this.el, "mousedown", this._onMouseDown, true), t2(this.el, "touchend", this._onMouseDown, true), t2(this.el, "change", this._onChange), e3.keyboardInput && t2(d2, "keydown", this._onKeyChange), e3.field && (t2(e3.field, "change", this._onInputChange), e3.bound && (t2(e3.trigger, "click", this._onInputClick), t2(e3.trigger, "focus", this._onInputFocus), t2(e3.trigger, "blur", this._onInputBlur))), this.el.parentNode && this.el.parentNode.removeChild(this.el);
    } }, e2);
  }();
  var __pikaday = pikaday.exports, hookCallback, some;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(e2) {
    hookCallback = e2;
  }
  function isArray$2(e2) {
    return e2 instanceof Array || Object.prototype.toString.call(e2) === "[object Array]";
  }
  function isObject(e2) {
    return e2 != null && Object.prototype.toString.call(e2) === "[object Object]";
  }
  function hasOwnProp(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  }
  function isObjectEmpty(e2) {
    if (Object.getOwnPropertyNames)
      return Object.getOwnPropertyNames(e2).length === 0;
    for (var t2 in e2)
      if (hasOwnProp(e2, t2))
        return;
    return 1;
  }
  function isUndefined(e2) {
    return e2 === void 0;
  }
  function isNumber(e2) {
    return typeof e2 == "number" || Object.prototype.toString.call(e2) === "[object Number]";
  }
  function isDate(e2) {
    return e2 instanceof Date || Object.prototype.toString.call(e2) === "[object Date]";
  }
  function map(e2, t2) {
    for (var r2 = [], n2 = 0; n2 < e2.length; ++n2)
      r2.push(t2(e2[n2], n2));
    return r2;
  }
  function extend(e2, t2) {
    for (var r2 in t2)
      hasOwnProp(t2, r2) && (e2[r2] = t2[r2]);
    return hasOwnProp(t2, "toString") && (e2.toString = t2.toString), hasOwnProp(t2, "valueOf") && (e2.valueOf = t2.valueOf), e2;
  }
  function createUTC(e2, t2, r2, n2) {
    return createLocalOrUTC(e2, t2, r2, n2, true).utc();
  }
  function defaultParsingFlags() {
    return { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidEra: null, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], era: null, meridiem: null, rfc2822: false, weekdayMismatch: false };
  }
  function getParsingFlags(e2) {
    return e2._pf == null && (e2._pf = defaultParsingFlags()), e2._pf;
  }
  function isValid(e2) {
    if (e2._isValid == null) {
      var t2 = getParsingFlags(e2), r2 = some.call(t2.parsedDateParts, function(e3) {
        return e3 != null;
      }), r2 = !isNaN(e2._d.getTime()) && t2.overflow < 0 && !t2.empty && !t2.invalidEra && !t2.invalidMonth && !t2.invalidWeekday && !t2.weekdayMismatch && !t2.nullInput && !t2.invalidFormat && !t2.userInvalidated && (!t2.meridiem || t2.meridiem && r2);
      if (e2._strict && (r2 = r2 && t2.charsLeftOver === 0 && t2.unusedTokens.length === 0 && t2.bigHour === void 0), Object.isFrozen != null && Object.isFrozen(e2))
        return r2;
      e2._isValid = r2;
    }
    return e2._isValid;
  }
  function createInvalid(e2) {
    var t2 = createUTC(NaN);
    return e2 != null ? extend(getParsingFlags(t2), e2) : getParsingFlags(t2).userInvalidated = true, t2;
  }
  var some = Array.prototype.some || function(e2) {
    for (var t2 = Object(this), r2 = t2.length >>> 0, n2 = 0; n2 < r2; n2++)
      if (n2 in t2 && e2.call(this, t2[n2], n2, t2))
        return true;
    return false;
  }, momentProperties = hooks.momentProperties = [], updateInProgress = false;
  function copyConfig(e2, t2) {
    var r2, n2, i2;
    if (isUndefined(t2._isAMomentObject) || (e2._isAMomentObject = t2._isAMomentObject), isUndefined(t2._i) || (e2._i = t2._i), isUndefined(t2._f) || (e2._f = t2._f), isUndefined(t2._l) || (e2._l = t2._l), isUndefined(t2._strict) || (e2._strict = t2._strict), isUndefined(t2._tzm) || (e2._tzm = t2._tzm), isUndefined(t2._isUTC) || (e2._isUTC = t2._isUTC), isUndefined(t2._offset) || (e2._offset = t2._offset), isUndefined(t2._pf) || (e2._pf = getParsingFlags(t2)), isUndefined(t2._locale) || (e2._locale = t2._locale), 0 < momentProperties.length)
      for (r2 = 0; r2 < momentProperties.length; r2++)
        isUndefined(i2 = t2[n2 = momentProperties[r2]]) || (e2[n2] = i2);
    return e2;
  }
  function Moment(e2) {
    copyConfig(this, e2), this._d = new Date(e2._d != null ? e2._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), updateInProgress === false && (updateInProgress = true, hooks.updateOffset(this), updateInProgress = false);
  }
  function isMoment(e2) {
    return e2 instanceof Moment || e2 != null && e2._isAMomentObject != null;
  }
  function warn(e2) {
    hooks.suppressDeprecationWarnings === false && typeof console != "undefined" && console.warn && console.warn("Deprecation warning: " + e2);
  }
  function deprecate(i2, a2) {
    var o2 = true;
    return extend(function() {
      if (hooks.deprecationHandler != null && hooks.deprecationHandler(null, i2), o2) {
        for (var e2, t2, r2 = [], n2 = 0; n2 < arguments.length; n2++) {
          if (e2 = "", typeof arguments[n2] == "object") {
            for (t2 in e2 += "\n[" + n2 + "] ", arguments[0])
              hasOwnProp(arguments[0], t2) && (e2 += t2 + ": " + arguments[0][t2] + ", ");
            e2 = e2.slice(0, -2);
          } else
            e2 = arguments[n2];
          r2.push(e2);
        }
        warn(i2 + "\nArguments: " + Array.prototype.slice.call(r2).join("") + "\n" + new Error().stack), o2 = false;
      }
      return a2.apply(this, arguments);
    }, a2);
  }
  var deprecations = {}, keys;
  function deprecateSimple(e2, t2) {
    hooks.deprecationHandler != null && hooks.deprecationHandler(e2, t2), deprecations[e2] || (warn(t2), deprecations[e2] = true);
  }
  function isFunction(e2) {
    return typeof Function != "undefined" && e2 instanceof Function || Object.prototype.toString.call(e2) === "[object Function]";
  }
  function set$1(e2) {
    var t2, r2;
    for (r2 in e2)
      hasOwnProp(e2, r2) && (isFunction(t2 = e2[r2]) ? this[r2] = t2 : this["_" + r2] = t2);
    this._config = e2, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
  }
  function mergeConfigs(e2, t2) {
    var r2, n2 = extend({}, e2);
    for (r2 in t2)
      hasOwnProp(t2, r2) && (isObject(e2[r2]) && isObject(t2[r2]) ? (n2[r2] = {}, extend(n2[r2], e2[r2]), extend(n2[r2], t2[r2])) : t2[r2] != null ? n2[r2] = t2[r2] : delete n2[r2]);
    for (r2 in e2)
      hasOwnProp(e2, r2) && !hasOwnProp(t2, r2) && isObject(e2[r2]) && (n2[r2] = extend({}, n2[r2]));
    return n2;
  }
  function Locale(e2) {
    e2 != null && this.set(e2);
  }
  hooks.suppressDeprecationWarnings = false, hooks.deprecationHandler = null;
  var keys = Object.keys || function(e2) {
    var t2, r2 = [];
    for (t2 in e2)
      hasOwnProp(e2, t2) && r2.push(t2);
    return r2;
  }, defaultCalendar = { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" };
  function calendar(e2, t2, r2) {
    e2 = this._calendar[e2] || this._calendar.sameElse;
    return isFunction(e2) ? e2.call(t2, r2) : e2;
  }
  function zeroFill(e2, t2, r2) {
    var n2 = "" + Math.abs(e2);
    return (0 <= e2 ? r2 ? "+" : "" : "-") + Math.pow(10, Math.max(0, t2 - n2.length)).toString().substr(1) + n2;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
  function addFormatToken(e2, t2, r2, n2) {
    var i2 = typeof n2 == "string" ? function() {
      return this[n2]();
    } : n2;
    e2 && (formatTokenFunctions[e2] = i2), t2 && (formatTokenFunctions[t2[0]] = function() {
      return zeroFill(i2.apply(this, arguments), t2[1], t2[2]);
    }), r2 && (formatTokenFunctions[r2] = function() {
      return this.localeData().ordinal(i2.apply(this, arguments), e2);
    });
  }
  function removeFormattingTokens(e2) {
    return e2.match(/\[[\s\S]/) ? e2.replace(/^\[|\]$/g, "") : e2.replace(/\\/g, "");
  }
  function makeFormatFunction(n2) {
    for (var i2 = n2.match(formattingTokens), e2 = 0, a2 = i2.length; e2 < a2; e2++)
      formatTokenFunctions[i2[e2]] ? i2[e2] = formatTokenFunctions[i2[e2]] : i2[e2] = removeFormattingTokens(i2[e2]);
    return function(e3) {
      for (var t2 = "", r2 = 0; r2 < a2; r2++)
        t2 += isFunction(i2[r2]) ? i2[r2].call(e3, n2) : i2[r2];
      return t2;
    };
  }
  function formatMoment(e2, t2) {
    return e2.isValid() ? (t2 = expandFormat(t2, e2.localeData()), formatFunctions[t2] = formatFunctions[t2] || makeFormatFunction(t2), formatFunctions[t2](e2)) : e2.localeData().invalidDate();
  }
  function expandFormat(e2, t2) {
    var r2 = 5;
    function n2(e3) {
      return t2.longDateFormat(e3) || e3;
    }
    for (localFormattingTokens.lastIndex = 0; 0 <= r2 && localFormattingTokens.test(e2); )
      e2 = e2.replace(localFormattingTokens, n2), localFormattingTokens.lastIndex = 0, --r2;
    return e2;
  }
  var defaultLongDateFormat = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
  function longDateFormat(e2) {
    var t2 = this._longDateFormat[e2], r2 = this._longDateFormat[e2.toUpperCase()];
    return t2 || !r2 ? t2 : (this._longDateFormat[e2] = r2.match(formattingTokens).map(function(e3) {
      return e3 === "MMMM" || e3 === "MM" || e3 === "DD" || e3 === "dddd" ? e3.slice(1) : e3;
    }).join(""), this._longDateFormat[e2]);
  }
  var defaultInvalidDate = "Invalid date";
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(e2) {
    return this._ordinal.replace("%d", e2);
  }
  var defaultRelativeTime = { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
  function relativeTime(e2, t2, r2, n2) {
    var i2 = this._relativeTime[r2];
    return isFunction(i2) ? i2(e2, t2, r2, n2) : i2.replace(/%d/i, e2);
  }
  function pastFuture(e2, t2) {
    e2 = this._relativeTime[0 < e2 ? "future" : "past"];
    return isFunction(e2) ? e2(t2) : e2.replace(/%s/i, t2);
  }
  var aliases = {};
  function addUnitAlias(e2, t2) {
    var r2 = e2.toLowerCase();
    aliases[r2] = aliases[r2 + "s"] = aliases[t2] = e2;
  }
  function normalizeUnits(e2) {
    return typeof e2 == "string" ? aliases[e2] || aliases[e2.toLowerCase()] : void 0;
  }
  function normalizeObjectUnits(e2) {
    var t2, r2, n2 = {};
    for (r2 in e2)
      hasOwnProp(e2, r2) && (t2 = normalizeUnits(r2)) && (n2[t2] = e2[r2]);
    return n2;
  }
  var priorities = {};
  function addUnitPriority(e2, t2) {
    priorities[e2] = t2;
  }
  function getPrioritizedUnits(e2) {
    var t2, r2 = [];
    for (t2 in e2)
      hasOwnProp(e2, t2) && r2.push({ unit: t2, priority: priorities[t2] });
    return r2.sort(function(e3, t3) {
      return e3.priority - t3.priority;
    }), r2;
  }
  function isLeapYear(e2) {
    return e2 % 4 == 0 && e2 % 100 != 0 || e2 % 400 == 0;
  }
  function absFloor(e2) {
    return e2 < 0 ? Math.ceil(e2) || 0 : Math.floor(e2);
  }
  function toInt(e2) {
    var t2 = +e2, e2 = 0;
    return e2 = t2 != 0 && isFinite(t2) ? absFloor(t2) : e2;
  }
  function makeGetSet(t2, r2) {
    return function(e2) {
      return e2 != null ? (set$1$1(this, t2, e2), hooks.updateOffset(this, r2), this) : get(this, t2);
    };
  }
  function get(e2, t2) {
    return e2.isValid() ? e2._d["get" + (e2._isUTC ? "UTC" : "") + t2]() : NaN;
  }
  function set$1$1(e2, t2, r2) {
    e2.isValid() && !isNaN(r2) && (t2 === "FullYear" && isLeapYear(e2.year()) && e2.month() === 1 && e2.date() === 29 ? (r2 = toInt(r2), e2._d["set" + (e2._isUTC ? "UTC" : "") + t2](r2, e2.month(), daysInMonth(r2, e2.month()))) : e2._d["set" + (e2._isUTC ? "UTC" : "") + t2](r2));
  }
  function stringGet(e2) {
    return isFunction(this[e2 = normalizeUnits(e2)]) ? this[e2]() : this;
  }
  function stringSet(e2, t2) {
    if (typeof e2 == "object")
      for (var r2 = getPrioritizedUnits(e2 = normalizeObjectUnits(e2)), n2 = 0; n2 < r2.length; n2++)
        this[r2[n2].unit](e2[r2[n2].unit]);
    else if (isFunction(this[e2 = normalizeUnits(e2)]))
      return this[e2](t2);
    return this;
  }
  var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
  function addRegexToken(e2, r2, n2) {
    regexes[e2] = isFunction(r2) ? r2 : function(e3, t2) {
      return e3 && n2 ? n2 : r2;
    };
  }
  function getParseRegexForToken(e2, t2) {
    return hasOwnProp(regexes, e2) ? regexes[e2](t2._strict, t2._locale) : new RegExp(unescapeFormat(e2));
  }
  function unescapeFormat(e2) {
    return regexEscape(e2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e3, t2, r2, n2, i2) {
      return t2 || r2 || n2 || i2;
    }));
  }
  function regexEscape(e2) {
    return e2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var regexes = {}, tokens = {};
  function addParseToken(e2, r2) {
    var t2, n2 = r2;
    for (typeof e2 == "string" && (e2 = [e2]), isNumber(r2) && (n2 = function(e3, t3) {
      t3[r2] = toInt(e3);
    }), t2 = 0; t2 < e2.length; t2++)
      tokens[e2[t2]] = n2;
  }
  function addWeekParseToken(e2, i2) {
    addParseToken(e2, function(e3, t2, r2, n2) {
      r2._w = r2._w || {}, i2(e3, r2._w, r2, n2);
    });
  }
  function addTimeToArrayFromToken(e2, t2, r2) {
    t2 != null && hasOwnProp(tokens, e2) && tokens[e2](t2, r2._a, r2, e2);
  }
  var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8, indexOf;
  function mod(e2, t2) {
    return (e2 % t2 + t2) % t2;
  }
  function daysInMonth(e2, t2) {
    if (isNaN(e2) || isNaN(t2))
      return NaN;
    var r2 = mod(t2, 12);
    return e2 += (t2 - r2) / 12, r2 === 1 ? isLeapYear(e2) ? 29 : 28 : 31 - r2 % 7 % 2;
  }
  indexOf = Array.prototype.indexOf || function(e2) {
    for (var t2 = 0; t2 < this.length; ++t2)
      if (this[t2] === e2)
        return t2;
    return -1;
  }, addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  }), addFormatToken("MMM", 0, 0, function(e2) {
    return this.localeData().monthsShort(this, e2);
  }), addFormatToken("MMMM", 0, 0, function(e2) {
    return this.localeData().months(this, e2);
  }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), addRegexToken("MM", match1to2, match2), addRegexToken("MMM", function(e2, t2) {
    return t2.monthsShortRegex(e2);
  }), addRegexToken("MMMM", function(e2, t2) {
    return t2.monthsRegex(e2);
  }), addParseToken(["M", "MM"], function(e2, t2) {
    t2[MONTH] = toInt(e2) - 1;
  }), addParseToken(["MMM", "MMMM"], function(e2, t2, r2, n2) {
    n2 = r2._locale.monthsParse(e2, n2, r2._strict);
    n2 != null ? t2[MONTH] = n2 : getParsingFlags(r2).invalidMonth = e2;
  });
  var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
  function localeMonths(e2, t2) {
    return e2 ? (isArray$2(this._months) ? this._months : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(t2) ? "format" : "standalone"])[e2.month()] : isArray$2(this._months) ? this._months : this._months.standalone;
  }
  function localeMonthsShort(e2, t2) {
    return e2 ? (isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort[MONTHS_IN_FORMAT.test(t2) ? "format" : "standalone"])[e2.month()] : isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
  }
  function handleStrictParse(e2, t2, r2) {
    var n2, i2, a2, e2 = e2.toLocaleLowerCase();
    if (!this._monthsParse)
      for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n2 = 0; n2 < 12; ++n2)
        a2 = createUTC([2e3, n2]), this._shortMonthsParse[n2] = this.monthsShort(a2, "").toLocaleLowerCase(), this._longMonthsParse[n2] = this.months(a2, "").toLocaleLowerCase();
    return r2 ? t2 === "MMM" ? (i2 = indexOf.call(this._shortMonthsParse, e2)) !== -1 ? i2 : null : (i2 = indexOf.call(this._longMonthsParse, e2)) !== -1 ? i2 : null : t2 === "MMM" ? (i2 = indexOf.call(this._shortMonthsParse, e2)) !== -1 || (i2 = indexOf.call(this._longMonthsParse, e2)) !== -1 ? i2 : null : (i2 = indexOf.call(this._longMonthsParse, e2)) !== -1 || (i2 = indexOf.call(this._shortMonthsParse, e2)) !== -1 ? i2 : null;
  }
  function localeMonthsParse(e2, t2, r2) {
    var n2, i2;
    if (this._monthsParseExact)
      return handleStrictParse.call(this, e2, t2, r2);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n2 = 0; n2 < 12; n2++) {
      if (i2 = createUTC([2e3, n2]), r2 && !this._longMonthsParse[n2] && (this._longMonthsParse[n2] = new RegExp("^" + this.months(i2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n2] = new RegExp("^" + this.monthsShort(i2, "").replace(".", "") + "$", "i")), r2 || this._monthsParse[n2] || (i2 = "^" + this.months(i2, "") + "|^" + this.monthsShort(i2, ""), this._monthsParse[n2] = new RegExp(i2.replace(".", ""), "i")), r2 && t2 === "MMMM" && this._longMonthsParse[n2].test(e2))
        return n2;
      if (r2 && t2 === "MMM" && this._shortMonthsParse[n2].test(e2))
        return n2;
      if (!r2 && this._monthsParse[n2].test(e2))
        return n2;
    }
  }
  function setMonth(e2, t2) {
    var r2;
    if (!e2.isValid())
      return e2;
    if (typeof t2 == "string") {
      if (/^\d+$/.test(t2))
        t2 = toInt(t2);
      else if (!isNumber(t2 = e2.localeData().monthsParse(t2)))
        return e2;
    }
    return r2 = Math.min(e2.date(), daysInMonth(e2.year(), t2)), e2._d["set" + (e2._isUTC ? "UTC" : "") + "Month"](t2, r2), e2;
  }
  function getSetMonth(e2) {
    return e2 != null ? (setMonth(this, e2), hooks.updateOffset(this, true), this) : get(this, "Month");
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function monthsShortRegex(e2) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), e2 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), this._monthsShortStrictRegex && e2 ? this._monthsShortStrictRegex : this._monthsShortRegex);
  }
  function monthsRegex(e2) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), e2 ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), this._monthsStrictRegex && e2 ? this._monthsStrictRegex : this._monthsRegex);
  }
  function computeMonthsParse() {
    function e2(e3, t3) {
      return t3.length - e3.length;
    }
    for (var t2, r2 = [], n2 = [], i2 = [], a2 = 0; a2 < 12; a2++)
      t2 = createUTC([2e3, a2]), r2.push(this.monthsShort(t2, "")), n2.push(this.months(t2, "")), i2.push(this.months(t2, "")), i2.push(this.monthsShort(t2, ""));
    for (r2.sort(e2), n2.sort(e2), i2.sort(e2), a2 = 0; a2 < 12; a2++)
      r2[a2] = regexEscape(r2[a2]), n2[a2] = regexEscape(n2[a2]);
    for (a2 = 0; a2 < 24; a2++)
      i2[a2] = regexEscape(i2[a2]);
    this._monthsRegex = new RegExp("^(" + i2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + n2.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i");
  }
  function daysInYear(e2) {
    return isLeapYear(e2) ? 366 : 365;
  }
  addFormatToken("Y", 0, 0, function() {
    var e2 = this.year();
    return e2 <= 9999 ? zeroFill(e2, 4) : "+" + e2;
  }), addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  }), addFormatToken(0, ["YYYY", 4], 0, "year"), addFormatToken(0, ["YYYYY", 5], 0, "year"), addFormatToken(0, ["YYYYYY", 6, true], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), addParseToken(["YYYYY", "YYYYYY"], YEAR), addParseToken("YYYY", function(e2, t2) {
    t2[YEAR] = e2.length === 2 ? hooks.parseTwoDigitYear(e2) : toInt(e2);
  }), addParseToken("YY", function(e2, t2) {
    t2[YEAR] = hooks.parseTwoDigitYear(e2);
  }), addParseToken("Y", function(e2, t2) {
    t2[YEAR] = parseInt(e2, 10);
  }), hooks.parseTwoDigitYear = function(e2) {
    return toInt(e2) + (68 < toInt(e2) ? 1900 : 2e3);
  };
  var getSetYear = makeGetSet("FullYear", true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(e2, t2, r2, n2, i2, a2, o2) {
    var s2;
    return e2 < 100 && 0 <= e2 ? (s2 = new Date(e2 + 400, t2, r2, n2, i2, a2, o2), isFinite(s2.getFullYear()) && s2.setFullYear(e2)) : s2 = new Date(e2, t2, r2, n2, i2, a2, o2), s2;
  }
  function createUTCDate(e2) {
    var t2;
    return e2 < 100 && 0 <= e2 ? ((t2 = Array.prototype.slice.call(arguments))[0] = e2 + 400, t2 = new Date(Date.UTC.apply(null, t2)), isFinite(t2.getUTCFullYear()) && t2.setUTCFullYear(e2)) : t2 = new Date(Date.UTC.apply(null, arguments)), t2;
  }
  function firstWeekOffset(e2, t2, r2) {
    r2 = 7 + t2 - r2;
    return r2 - (7 + createUTCDate(e2, 0, r2).getUTCDay() - t2) % 7 - 1;
  }
  function dayOfYearFromWeeks(e2, t2, r2, n2, i2) {
    var a2, i2 = 1 + 7 * (t2 - 1) + (7 + r2 - n2) % 7 + firstWeekOffset(e2, n2, i2), i2 = i2 <= 0 ? daysInYear(a2 = e2 - 1) + i2 : i2 > daysInYear(e2) ? (a2 = e2 + 1, i2 - daysInYear(e2)) : (a2 = e2, i2);
    return { year: a2, dayOfYear: i2 };
  }
  function weekOfYear(e2, t2, r2) {
    var n2, i2, a2 = firstWeekOffset(e2.year(), t2, r2), a2 = Math.floor((e2.dayOfYear() - a2 - 1) / 7) + 1;
    return a2 < 1 ? n2 = a2 + weeksInYear(i2 = e2.year() - 1, t2, r2) : a2 > weeksInYear(e2.year(), t2, r2) ? (n2 = a2 - weeksInYear(e2.year(), t2, r2), i2 = e2.year() + 1) : (i2 = e2.year(), n2 = a2), { week: n2, year: i2 };
  }
  function weeksInYear(e2, t2, r2) {
    var n2 = firstWeekOffset(e2, t2, r2), r2 = firstWeekOffset(e2 + 1, t2, r2);
    return (daysInYear(e2) - n2 + r2) / 7;
  }
  function localeWeek(e2) {
    return weekOfYear(e2, this._week.dow, this._week.doy).week;
  }
  addFormatToken("w", ["ww", 2], "wo", "week"), addFormatToken("W", ["WW", 2], "Wo", "isoWeek"), addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken(["w", "ww", "W", "WW"], function(e2, t2, r2, n2) {
    t2[n2.substr(0, 1)] = toInt(e2);
  });
  var defaultLocaleWeek = { dow: 0, doy: 6 };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(e2) {
    var t2 = this.localeData().week(this);
    return e2 == null ? t2 : this.add(7 * (e2 - t2), "d");
  }
  function getSetISOWeek(e2) {
    var t2 = weekOfYear(this, 1, 4).week;
    return e2 == null ? t2 : this.add(7 * (e2 - t2), "d");
  }
  function parseWeekday(e2, t2) {
    return typeof e2 != "string" ? e2 : isNaN(e2) ? typeof (e2 = t2.weekdaysParse(e2)) == "number" ? e2 : null : parseInt(e2, 10);
  }
  function parseIsoWeekday(e2, t2) {
    return typeof e2 == "string" ? t2.weekdaysParse(e2) % 7 || 7 : isNaN(e2) ? null : e2;
  }
  function shiftWeekdays(e2, t2) {
    return e2.slice(t2, 7).concat(e2.slice(0, t2));
  }
  addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(e2) {
    return this.localeData().weekdaysMin(this, e2);
  }), addFormatToken("ddd", 0, 0, function(e2) {
    return this.localeData().weekdaysShort(this, e2);
  }), addFormatToken("dddd", 0, 0, function(e2) {
    return this.localeData().weekdays(this, e2);
  }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), addRegexToken("dd", function(e2, t2) {
    return t2.weekdaysMinRegex(e2);
  }), addRegexToken("ddd", function(e2, t2) {
    return t2.weekdaysShortRegex(e2);
  }), addRegexToken("dddd", function(e2, t2) {
    return t2.weekdaysRegex(e2);
  }), addWeekParseToken(["dd", "ddd", "dddd"], function(e2, t2, r2, n2) {
    n2 = r2._locale.weekdaysParse(e2, n2, r2._strict);
    n2 != null ? t2.d = n2 : getParsingFlags(r2).invalidWeekday = e2;
  }), addWeekParseToken(["d", "e", "E"], function(e2, t2, r2, n2) {
    t2[n2] = toInt(e2);
  });
  var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
  function localeWeekdays(e2, t2) {
    t2 = isArray$2(this._weekdays) ? this._weekdays : this._weekdays[e2 && e2 !== true && this._weekdays.isFormat.test(t2) ? "format" : "standalone"];
    return e2 === true ? shiftWeekdays(t2, this._week.dow) : e2 ? t2[e2.day()] : t2;
  }
  function localeWeekdaysShort(e2) {
    return e2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : e2 ? this._weekdaysShort[e2.day()] : this._weekdaysShort;
  }
  function localeWeekdaysMin(e2) {
    return e2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : e2 ? this._weekdaysMin[e2.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(e2, t2, r2) {
    var n2, i2, a2, e2 = e2.toLocaleLowerCase();
    if (!this._weekdaysParse)
      for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n2 = 0; n2 < 7; ++n2)
        a2 = createUTC([2e3, 1]).day(n2), this._minWeekdaysParse[n2] = this.weekdaysMin(a2, "").toLocaleLowerCase(), this._shortWeekdaysParse[n2] = this.weekdaysShort(a2, "").toLocaleLowerCase(), this._weekdaysParse[n2] = this.weekdays(a2, "").toLocaleLowerCase();
    return r2 ? t2 === "dddd" ? (i2 = indexOf.call(this._weekdaysParse, e2)) !== -1 ? i2 : null : t2 === "ddd" ? (i2 = indexOf.call(this._shortWeekdaysParse, e2)) !== -1 ? i2 : null : (i2 = indexOf.call(this._minWeekdaysParse, e2)) !== -1 ? i2 : null : t2 === "dddd" ? (i2 = indexOf.call(this._weekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._shortWeekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._minWeekdaysParse, e2)) !== -1 ? i2 : null : t2 === "ddd" ? (i2 = indexOf.call(this._shortWeekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._weekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._minWeekdaysParse, e2)) !== -1 ? i2 : null : (i2 = indexOf.call(this._minWeekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._weekdaysParse, e2)) !== -1 || (i2 = indexOf.call(this._shortWeekdaysParse, e2)) !== -1 ? i2 : null;
  }
  function localeWeekdaysParse(e2, t2, r2) {
    var n2, i2;
    if (this._weekdaysParseExact)
      return handleStrictParse$1.call(this, e2, t2, r2);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n2 = 0; n2 < 7; n2++) {
      if (i2 = createUTC([2e3, 1]).day(n2), r2 && !this._fullWeekdaysParse[n2] && (this._fullWeekdaysParse[n2] = new RegExp("^" + this.weekdays(i2, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[n2] = new RegExp("^" + this.weekdaysShort(i2, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[n2] = new RegExp("^" + this.weekdaysMin(i2, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[n2] || (i2 = "^" + this.weekdays(i2, "") + "|^" + this.weekdaysShort(i2, "") + "|^" + this.weekdaysMin(i2, ""), this._weekdaysParse[n2] = new RegExp(i2.replace(".", ""), "i")), r2 && t2 === "dddd" && this._fullWeekdaysParse[n2].test(e2))
        return n2;
      if (r2 && t2 === "ddd" && this._shortWeekdaysParse[n2].test(e2))
        return n2;
      if (r2 && t2 === "dd" && this._minWeekdaysParse[n2].test(e2))
        return n2;
      if (!r2 && this._weekdaysParse[n2].test(e2))
        return n2;
    }
  }
  function getSetDayOfWeek(e2) {
    if (!this.isValid())
      return e2 != null ? this : NaN;
    var t2 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return e2 != null ? (e2 = parseWeekday(e2, this.localeData()), this.add(e2 - t2, "d")) : t2;
  }
  function getSetLocaleDayOfWeek(e2) {
    if (!this.isValid())
      return e2 != null ? this : NaN;
    var t2 = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return e2 == null ? t2 : this.add(e2 - t2, "d");
  }
  function getSetISODayOfWeek(e2) {
    if (!this.isValid())
      return e2 != null ? this : NaN;
    if (e2 == null)
      return this.day() || 7;
    e2 = parseIsoWeekday(e2, this.localeData());
    return this.day(this.day() % 7 ? e2 : e2 - 7);
  }
  function weekdaysRegex(e2) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), e2 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), this._weekdaysStrictRegex && e2 ? this._weekdaysStrictRegex : this._weekdaysRegex);
  }
  function weekdaysShortRegex(e2) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), e2 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), this._weekdaysShortStrictRegex && e2 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
  }
  function weekdaysMinRegex(e2) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), e2 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), this._weekdaysMinStrictRegex && e2 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
  }
  function computeWeekdaysParse() {
    function e2(e3, t3) {
      return t3.length - e3.length;
    }
    for (var t2, r2, n2, i2 = [], a2 = [], o2 = [], s2 = [], l2 = 0; l2 < 7; l2++)
      n2 = createUTC([2e3, 1]).day(l2), t2 = regexEscape(this.weekdaysMin(n2, "")), r2 = regexEscape(this.weekdaysShort(n2, "")), n2 = regexEscape(this.weekdays(n2, "")), i2.push(t2), a2.push(r2), o2.push(n2), s2.push(t2), s2.push(r2), s2.push(n2);
    i2.sort(e2), a2.sort(e2), o2.sort(e2), s2.sort(e2), this._weekdaysRegex = new RegExp("^(" + s2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + o2.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + a2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + i2.join("|") + ")", "i");
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  function meridiem(e2, t2) {
    addFormatToken(e2, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), t2);
    });
  }
  function matchMeridiem(e2, t2) {
    return t2._meridiemParse;
  }
  function localeIsPM(e2) {
    return (e2 + "").toLowerCase().charAt(0) === "p";
  }
  addFormatToken("H", ["HH", 2], 0, "hour"), addFormatToken("h", ["hh", 2], 0, hFormat), addFormatToken("k", ["kk", 2], 0, kFormat), addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  }), addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  }), addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  }), addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  }), meridiem("a", true), meridiem("A", false), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), addRegexToken("h", match1to2), addRegexToken("k", match1to2), addRegexToken("HH", match1to2, match2), addRegexToken("hh", match1to2, match2), addRegexToken("kk", match1to2, match2), addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), addRegexToken("Hmmss", match5to6), addParseToken(["H", "HH"], HOUR), addParseToken(["k", "kk"], function(e2, t2, r2) {
    e2 = toInt(e2);
    t2[HOUR] = e2 === 24 ? 0 : e2;
  }), addParseToken(["a", "A"], function(e2, t2, r2) {
    r2._isPm = r2._locale.isPM(e2), r2._meridiem = e2;
  }), addParseToken(["h", "hh"], function(e2, t2, r2) {
    t2[HOUR] = toInt(e2), getParsingFlags(r2).bigHour = true;
  }), addParseToken("hmm", function(e2, t2, r2) {
    var n2 = e2.length - 2;
    t2[HOUR] = toInt(e2.substr(0, n2)), t2[MINUTE] = toInt(e2.substr(n2)), getParsingFlags(r2).bigHour = true;
  }), addParseToken("hmmss", function(e2, t2, r2) {
    var n2 = e2.length - 4, i2 = e2.length - 2;
    t2[HOUR] = toInt(e2.substr(0, n2)), t2[MINUTE] = toInt(e2.substr(n2, 2)), t2[SECOND] = toInt(e2.substr(i2)), getParsingFlags(r2).bigHour = true;
  }), addParseToken("Hmm", function(e2, t2, r2) {
    var n2 = e2.length - 2;
    t2[HOUR] = toInt(e2.substr(0, n2)), t2[MINUTE] = toInt(e2.substr(n2));
  }), addParseToken("Hmmss", function(e2, t2, r2) {
    var n2 = e2.length - 4, i2 = e2.length - 2;
    t2[HOUR] = toInt(e2.substr(0, n2)), t2[MINUTE] = toInt(e2.substr(n2, 2)), t2[SECOND] = toInt(e2.substr(i2));
  });
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
  function localeMeridiem(e2, t2, r2) {
    return 11 < e2 ? r2 ? "pm" : "PM" : r2 ? "am" : "AM";
  }
  var baseConfig = { calendar: defaultCalendar, longDateFormat: defaultLongDateFormat, invalidDate: defaultInvalidDate, ordinal: defaultOrdinal, dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse, relativeTime: defaultRelativeTime, months: defaultLocaleMonths, monthsShort: defaultLocaleMonthsShort, week: defaultLocaleWeek, weekdays: defaultLocaleWeekdays, weekdaysMin: defaultLocaleWeekdaysMin, weekdaysShort: defaultLocaleWeekdaysShort, meridiemParse: defaultLocaleMeridiemParse }, locales = {}, localeFamilies = {}, globalLocale;
  function commonPrefix(e2, t2) {
    for (var r2 = Math.min(e2.length, t2.length), n2 = 0; n2 < r2; n2 += 1)
      if (e2[n2] !== t2[n2])
        return n2;
    return r2;
  }
  function normalizeLocale(e2) {
    return e2 && e2.toLowerCase().replace("_", "-");
  }
  function chooseLocale(e2) {
    for (var t2, r2, n2, i2, a2 = 0; a2 < e2.length; ) {
      for (t2 = (i2 = normalizeLocale(e2[a2]).split("-")).length, r2 = (r2 = normalizeLocale(e2[a2 + 1])) ? r2.split("-") : null; 0 < t2; ) {
        if (n2 = loadLocale(i2.slice(0, t2).join("-")))
          return n2;
        if (r2 && r2.length >= t2 && commonPrefix(i2, r2) >= t2 - 1)
          break;
        t2--;
      }
      a2++;
    }
    return globalLocale;
  }
  function loadLocale(t2) {
    var e2;
    if (locales[t2] === void 0 && typeof module != "undefined" && module && module.exports)
      try {
        e2 = globalLocale._abbr, require("./locale/" + t2), getSetGlobalLocale(e2);
      } catch (e3) {
        locales[t2] = null;
      }
    return locales[t2];
  }
  function getSetGlobalLocale(e2, t2) {
    return e2 && ((t2 = isUndefined(t2) ? getLocale(e2) : defineLocale(e2, t2)) ? globalLocale = t2 : typeof console != "undefined" && console.warn && console.warn("Locale " + e2 + " not found. Did you forget to load it?")), globalLocale._abbr;
  }
  function defineLocale(e2, t2) {
    if (t2 === null)
      return delete locales[e2], null;
    var r2, n2 = baseConfig;
    if (t2.abbr = e2, locales[e2] != null)
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n2 = locales[e2]._config;
    else if (t2.parentLocale != null)
      if (locales[t2.parentLocale] != null)
        n2 = locales[t2.parentLocale]._config;
      else {
        if ((r2 = loadLocale(t2.parentLocale)) == null)
          return localeFamilies[t2.parentLocale] || (localeFamilies[t2.parentLocale] = []), localeFamilies[t2.parentLocale].push({ name: e2, config: t2 }), null;
        n2 = r2._config;
      }
    return locales[e2] = new Locale(mergeConfigs(n2, t2)), localeFamilies[e2] && localeFamilies[e2].forEach(function(e3) {
      defineLocale(e3.name, e3.config);
    }), getSetGlobalLocale(e2), locales[e2];
  }
  function updateLocale(e2, t2) {
    var r2, n2;
    return t2 != null ? (n2 = baseConfig, locales[e2] != null && locales[e2].parentLocale != null ? locales[e2].set(mergeConfigs(locales[e2]._config, t2)) : (t2 = mergeConfigs(n2 = (r2 = loadLocale(e2)) != null ? r2._config : n2, t2), r2 == null && (t2.abbr = e2), (t2 = new Locale(t2)).parentLocale = locales[e2], locales[e2] = t2), getSetGlobalLocale(e2)) : locales[e2] != null && (locales[e2].parentLocale != null ? (locales[e2] = locales[e2].parentLocale, e2 === getSetGlobalLocale() && getSetGlobalLocale(e2)) : locales[e2] != null && delete locales[e2]), locales[e2];
  }
  function getLocale(e2) {
    var t2;
    if (!(e2 = e2 && e2._locale && e2._locale._abbr ? e2._locale._abbr : e2))
      return globalLocale;
    if (!isArray$2(e2)) {
      if (t2 = loadLocale(e2))
        return t2;
      e2 = [e2];
    }
    return chooseLocale(e2);
  }
  function listLocales() {
    return keys(locales);
  }
  function checkOverflow(e2) {
    var t2 = e2._a;
    return t2 && getParsingFlags(e2).overflow === -2 && (t2 = t2[MONTH] < 0 || 11 < t2[MONTH] ? MONTH : t2[DATE] < 1 || t2[DATE] > daysInMonth(t2[YEAR], t2[MONTH]) ? DATE : t2[HOUR] < 0 || 24 < t2[HOUR] || t2[HOUR] === 24 && (t2[MINUTE] !== 0 || t2[SECOND] !== 0 || t2[MILLISECOND] !== 0) ? HOUR : t2[MINUTE] < 0 || 59 < t2[MINUTE] ? MINUTE : t2[SECOND] < 0 || 59 < t2[SECOND] ? SECOND : t2[MILLISECOND] < 0 || 999 < t2[MILLISECOND] ? MILLISECOND : -1, getParsingFlags(e2)._overflowDayOfYear && (t2 < YEAR || DATE < t2) && (t2 = DATE), getParsingFlags(e2)._overflowWeeks && t2 === -1 && (t2 = WEEK), getParsingFlags(e2)._overflowWeekday && t2 === -1 && (t2 = WEEKDAY), getParsingFlags(e2).overflow = t2), e2;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], isoTimes = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
  function configFromISO(e2) {
    var t2, r2, n2, i2, a2, o2, s2 = e2._i, l2 = extendedIsoRegex.exec(s2) || basicIsoRegex.exec(s2);
    if (l2) {
      for (getParsingFlags(e2).iso = true, t2 = 0, r2 = isoDates.length; t2 < r2; t2++)
        if (isoDates[t2][1].exec(l2[1])) {
          i2 = isoDates[t2][0], n2 = isoDates[t2][2] !== false;
          break;
        }
      if (i2 != null) {
        if (l2[3]) {
          for (t2 = 0, r2 = isoTimes.length; t2 < r2; t2++)
            if (isoTimes[t2][1].exec(l2[3])) {
              a2 = (l2[2] || " ") + isoTimes[t2][0];
              break;
            }
          if (a2 == null)
            return void (e2._isValid = false);
        }
        if (n2 || a2 == null) {
          if (l2[4]) {
            if (!tzRegex.exec(l2[4]))
              return void (e2._isValid = false);
            o2 = "Z";
          }
          e2._f = i2 + (a2 || "") + (o2 || ""), configFromStringAndFormat(e2);
        } else
          e2._isValid = false;
      } else
        e2._isValid = false;
    } else
      e2._isValid = false;
  }
  function extractFromRFC2822Strings(e2, t2, r2, n2, i2, a2) {
    i2 = [untruncateYear(e2), defaultLocaleMonthsShort.indexOf(t2), parseInt(r2, 10), parseInt(n2, 10), parseInt(i2, 10)];
    return a2 && i2.push(parseInt(a2, 10)), i2;
  }
  function untruncateYear(e2) {
    e2 = parseInt(e2, 10);
    return e2 <= 49 ? 2e3 + e2 : e2 <= 999 ? 1900 + e2 : e2;
  }
  function preprocessRFC2822(e2) {
    return e2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function checkWeekday(e2, t2, r2) {
    if (e2 && defaultLocaleWeekdaysShort.indexOf(e2) !== new Date(t2[0], t2[1], t2[2]).getDay())
      return getParsingFlags(r2).weekdayMismatch = true, void (r2._isValid = false);
    return 1;
  }
  function calculateOffset(e2, t2, r2) {
    if (e2)
      return obsOffsets[e2];
    if (t2)
      return 0;
    t2 = parseInt(r2, 10), r2 = t2 % 100;
    return 60 * ((t2 - r2) / 100) + r2;
  }
  function configFromRFC2822(e2) {
    var t2, r2 = rfc2822.exec(preprocessRFC2822(e2._i));
    r2 ? (t2 = extractFromRFC2822Strings(r2[4], r2[3], r2[2], r2[5], r2[6], r2[7]), checkWeekday(r2[1], t2, e2) && (e2._a = t2, e2._tzm = calculateOffset(r2[8], r2[9], r2[10]), e2._d = createUTCDate.apply(null, e2._a), e2._d.setUTCMinutes(e2._d.getUTCMinutes() - e2._tzm), getParsingFlags(e2).rfc2822 = true)) : e2._isValid = false;
  }
  function configFromString(e2) {
    var t2 = aspNetJsonRegex.exec(e2._i);
    t2 === null ? (configFromISO(e2), e2._isValid === false && (delete e2._isValid, configFromRFC2822(e2), e2._isValid === false && (delete e2._isValid, e2._strict ? e2._isValid = false : hooks.createFromInputFallback(e2)))) : e2._d = new Date(+t2[1]);
  }
  function defaults(e2, t2, r2) {
    return e2 != null ? e2 : t2 != null ? t2 : r2;
  }
  function currentDateArray(e2) {
    var t2 = new Date(hooks.now());
    return e2._useUTC ? [t2.getUTCFullYear(), t2.getUTCMonth(), t2.getUTCDate()] : [t2.getFullYear(), t2.getMonth(), t2.getDate()];
  }
  function configFromArray(e2) {
    var t2, r2, n2, i2 = [];
    if (!e2._d) {
      for (r2 = currentDateArray(e2), e2._w && e2._a[DATE] == null && e2._a[MONTH] == null && dayOfYearFromWeekInfo(e2), e2._dayOfYear != null && (n2 = defaults(e2._a[YEAR], r2[YEAR]), (e2._dayOfYear > daysInYear(n2) || e2._dayOfYear === 0) && (getParsingFlags(e2)._overflowDayOfYear = true), n2 = createUTCDate(n2, 0, e2._dayOfYear), e2._a[MONTH] = n2.getUTCMonth(), e2._a[DATE] = n2.getUTCDate()), t2 = 0; t2 < 3 && e2._a[t2] == null; ++t2)
        e2._a[t2] = i2[t2] = r2[t2];
      for (; t2 < 7; t2++)
        e2._a[t2] = i2[t2] = e2._a[t2] == null ? t2 === 2 ? 1 : 0 : e2._a[t2];
      e2._a[HOUR] === 24 && e2._a[MINUTE] === 0 && e2._a[SECOND] === 0 && e2._a[MILLISECOND] === 0 && (e2._nextDay = true, e2._a[HOUR] = 0), e2._d = (e2._useUTC ? createUTCDate : createDate).apply(null, i2), n2 = e2._useUTC ? e2._d.getUTCDay() : e2._d.getDay(), e2._tzm != null && e2._d.setUTCMinutes(e2._d.getUTCMinutes() - e2._tzm), e2._nextDay && (e2._a[HOUR] = 24), e2._w && e2._w.d !== void 0 && e2._w.d !== n2 && (getParsingFlags(e2).weekdayMismatch = true);
    }
  }
  function dayOfYearFromWeekInfo(e2) {
    var t2, r2, n2, i2, a2, o2, s2, l2 = e2._w;
    l2.GG != null || l2.W != null || l2.E != null ? (i2 = 1, a2 = 4, t2 = defaults(l2.GG, e2._a[YEAR], weekOfYear(createLocal(), 1, 4).year), r2 = defaults(l2.W, 1), ((n2 = defaults(l2.E, 1)) < 1 || 7 < n2) && (o2 = true)) : (i2 = e2._locale._week.dow, a2 = e2._locale._week.doy, s2 = weekOfYear(createLocal(), i2, a2), t2 = defaults(l2.gg, e2._a[YEAR], s2.year), r2 = defaults(l2.w, s2.week), l2.d != null ? ((n2 = l2.d) < 0 || 6 < n2) && (o2 = true) : l2.e != null ? (n2 = l2.e + i2, (l2.e < 0 || 6 < l2.e) && (o2 = true)) : n2 = i2), r2 < 1 || r2 > weeksInYear(t2, i2, a2) ? getParsingFlags(e2)._overflowWeeks = true : o2 != null ? getParsingFlags(e2)._overflowWeekday = true : (a2 = dayOfYearFromWeeks(t2, r2, n2, i2, a2), e2._a[YEAR] = a2.year, e2._dayOfYear = a2.dayOfYear);
  }
  function configFromStringAndFormat(e2) {
    if (e2._f !== hooks.ISO_8601)
      if (e2._f !== hooks.RFC_2822) {
        e2._a = [], getParsingFlags(e2).empty = true;
        for (var t2, r2, n2, i2 = "" + e2._i, a2 = i2.length, o2 = 0, s2 = expandFormat(e2._f, e2._locale).match(formattingTokens) || [], l2 = 0; l2 < s2.length; l2++)
          r2 = s2[l2], (t2 = (i2.match(getParseRegexForToken(r2, e2)) || [])[0]) && (0 < (n2 = i2.substr(0, i2.indexOf(t2))).length && getParsingFlags(e2).unusedInput.push(n2), i2 = i2.slice(i2.indexOf(t2) + t2.length), o2 += t2.length), formatTokenFunctions[r2] ? (t2 ? getParsingFlags(e2).empty = false : getParsingFlags(e2).unusedTokens.push(r2), addTimeToArrayFromToken(r2, t2, e2)) : e2._strict && !t2 && getParsingFlags(e2).unusedTokens.push(r2);
        getParsingFlags(e2).charsLeftOver = a2 - o2, 0 < i2.length && getParsingFlags(e2).unusedInput.push(i2), e2._a[HOUR] <= 12 && getParsingFlags(e2).bigHour === true && 0 < e2._a[HOUR] && (getParsingFlags(e2).bigHour = void 0), getParsingFlags(e2).parsedDateParts = e2._a.slice(0), getParsingFlags(e2).meridiem = e2._meridiem, e2._a[HOUR] = meridiemFixWrap(e2._locale, e2._a[HOUR], e2._meridiem), (a2 = getParsingFlags(e2).era) !== null && (e2._a[YEAR] = e2._locale.erasConvertYear(a2, e2._a[YEAR])), configFromArray(e2), checkOverflow(e2);
      } else
        configFromRFC2822(e2);
    else
      configFromISO(e2);
  }
  function meridiemFixWrap(e2, t2, r2) {
    return r2 == null ? t2 : e2.meridiemHour != null ? e2.meridiemHour(t2, r2) : e2.isPM != null ? ((r2 = e2.isPM(r2)) && t2 < 12 && (t2 += 12), r2 || t2 !== 12 ? t2 : 0) : t2;
  }
  function configFromStringAndArray(e2) {
    var t2, r2, n2, i2, a2, o2, s2 = false;
    if (e2._f.length === 0)
      return getParsingFlags(e2).invalidFormat = true, void (e2._d = new Date(NaN));
    for (i2 = 0; i2 < e2._f.length; i2++)
      a2 = 0, o2 = false, t2 = copyConfig({}, e2), e2._useUTC != null && (t2._useUTC = e2._useUTC), t2._f = e2._f[i2], configFromStringAndFormat(t2), isValid(t2) && (o2 = true), a2 += getParsingFlags(t2).charsLeftOver, a2 += 10 * getParsingFlags(t2).unusedTokens.length, getParsingFlags(t2).score = a2, s2 ? a2 < n2 && (n2 = a2, r2 = t2) : (n2 == null || a2 < n2 || o2) && (n2 = a2, r2 = t2, o2 && (s2 = true));
    extend(e2, r2 || t2);
  }
  function configFromObject(e2) {
    var t2, r2;
    e2._d || (r2 = (t2 = normalizeObjectUnits(e2._i)).day === void 0 ? t2.date : t2.day, e2._a = map([t2.year, t2.month, r2, t2.hour, t2.minute, t2.second, t2.millisecond], function(e3) {
      return e3 && parseInt(e3, 10);
    }), configFromArray(e2));
  }
  function createFromConfig(e2) {
    e2 = new Moment(checkOverflow(prepareConfig(e2)));
    return e2._nextDay && (e2.add(1, "d"), e2._nextDay = void 0), e2;
  }
  function prepareConfig(e2) {
    var t2 = e2._i, r2 = e2._f;
    return e2._locale = e2._locale || getLocale(e2._l), t2 === null || r2 === void 0 && t2 === "" ? createInvalid({ nullInput: true }) : (typeof t2 == "string" && (e2._i = t2 = e2._locale.preparse(t2)), isMoment(t2) ? new Moment(checkOverflow(t2)) : (isDate(t2) ? e2._d = t2 : (isArray$2(r2) ? configFromStringAndArray : r2 ? configFromStringAndFormat : configFromInput)(e2), isValid(e2) || (e2._d = null), e2));
  }
  function configFromInput(e2) {
    var t2 = e2._i;
    isUndefined(t2) ? e2._d = new Date(hooks.now()) : isDate(t2) ? e2._d = new Date(t2.valueOf()) : typeof t2 == "string" ? configFromString(e2) : isArray$2(t2) ? (e2._a = map(t2.slice(0), function(e3) {
      return parseInt(e3, 10);
    }), configFromArray(e2)) : isObject(t2) ? configFromObject(e2) : isNumber(t2) ? e2._d = new Date(t2) : hooks.createFromInputFallback(e2);
  }
  function createLocalOrUTC(e2, t2, r2, n2, i2) {
    var a2 = {};
    return t2 !== true && t2 !== false || (n2 = t2, t2 = void 0), r2 !== true && r2 !== false || (n2 = r2, r2 = void 0), (isObject(e2) && isObjectEmpty(e2) || isArray$2(e2) && e2.length === 0) && (e2 = void 0), a2._isAMomentObject = true, a2._useUTC = a2._isUTC = i2, a2._l = r2, a2._i = e2, a2._f = t2, a2._strict = n2, createFromConfig(a2);
  }
  function createLocal(e2, t2, r2, n2) {
    return createLocalOrUTC(e2, t2, r2, n2, false);
  }
  hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e2) {
    e2._d = new Date(e2._i + (e2._useUTC ? " UTC" : ""));
  }), hooks.ISO_8601 = function() {
  }, hooks.RFC_2822 = function() {
  };
  var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var e2 = createLocal.apply(null, arguments);
    return this.isValid() && e2.isValid() ? e2 < this ? this : e2 : createInvalid();
  }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var e2 = createLocal.apply(null, arguments);
    return this.isValid() && e2.isValid() ? this < e2 ? this : e2 : createInvalid();
  });
  function pickBy(e2, t2) {
    var r2, n2;
    if (!(t2 = t2.length === 1 && isArray$2(t2[0]) ? t2[0] : t2).length)
      return createLocal();
    for (r2 = t2[0], n2 = 1; n2 < t2.length; ++n2)
      t2[n2].isValid() && !t2[n2][e2](r2) || (r2 = t2[n2]);
    return r2;
  }
  function min() {
    return pickBy("isBefore", [].slice.call(arguments, 0));
  }
  function max() {
    return pickBy("isAfter", [].slice.call(arguments, 0));
  }
  var now$1 = function() {
    return Date.now ? Date.now() : +new Date();
  }, ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
  function isDurationValid(e2) {
    var t2, r2, n2 = false;
    for (t2 in e2)
      if (hasOwnProp(e2, t2) && (indexOf.call(ordering, t2) === -1 || e2[t2] != null && isNaN(e2[t2])))
        return false;
    for (r2 = 0; r2 < ordering.length; ++r2)
      if (e2[ordering[r2]]) {
        if (n2)
          return false;
        parseFloat(e2[ordering[r2]]) !== toInt(e2[ordering[r2]]) && (n2 = true);
      }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(e2) {
    var t2 = normalizeObjectUnits(e2), r2 = t2.year || 0, n2 = t2.quarter || 0, i2 = t2.month || 0, a2 = t2.week || t2.isoWeek || 0, o2 = t2.day || 0, s2 = t2.hour || 0, l2 = t2.minute || 0, c2 = t2.second || 0, e2 = t2.millisecond || 0;
    this._isValid = isDurationValid(t2), this._milliseconds = +e2 + 1e3 * c2 + 6e4 * l2 + 1e3 * s2 * 60 * 60, this._days = +o2 + 7 * a2, this._months = +i2 + 3 * n2 + 12 * r2, this._data = {}, this._locale = getLocale(), this._bubble();
  }
  function isDuration(e2) {
    return e2 instanceof Duration;
  }
  function absRound(e2) {
    return e2 < 0 ? -1 * Math.round(-1 * e2) : Math.round(e2);
  }
  function compareArrays(e2, t2, r2) {
    for (var n2 = Math.min(e2.length, t2.length), i2 = Math.abs(e2.length - t2.length), a2 = 0, o2 = 0; o2 < n2; o2++)
      (r2 && e2[o2] !== t2[o2] || !r2 && toInt(e2[o2]) !== toInt(t2[o2])) && a2++;
    return a2 + i2;
  }
  function offset$1(e2, r2) {
    addFormatToken(e2, 0, 0, function() {
      var e3 = this.utcOffset(), t2 = "+";
      return e3 < 0 && (e3 = -e3, t2 = "-"), t2 + zeroFill(~~(e3 / 60), 2) + r2 + zeroFill(~~e3 % 60, 2);
    });
  }
  offset$1("Z", ":"), offset$1("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), addParseToken(["Z", "ZZ"], function(e2, t2, r2) {
    r2._useUTC = true, r2._tzm = offsetFromString(matchShortOffset, e2);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(e2, t2) {
    t2 = (t2 || "").match(e2);
    return t2 === null ? null : (t2 = 60 * (e2 = ((t2[t2.length - 1] || []) + "").match(chunkOffset) || ["-", 0, 0])[1] + toInt(e2[2])) === 0 ? 0 : e2[0] === "+" ? t2 : -t2;
  }
  function cloneWithOffset(e2, t2) {
    var r2;
    return t2._isUTC ? (r2 = t2.clone(), t2 = (isMoment(e2) || isDate(e2) ? e2 : createLocal(e2)).valueOf() - r2.valueOf(), r2._d.setTime(r2._d.valueOf() + t2), hooks.updateOffset(r2, false), r2) : createLocal(e2).local();
  }
  function getDateOffset(e2) {
    return -Math.round(e2._d.getTimezoneOffset());
  }
  function getSetOffset(e2, t2, r2) {
    var n2, i2 = this._offset || 0;
    if (!this.isValid())
      return e2 != null ? this : NaN;
    if (e2 == null)
      return this._isUTC ? i2 : getDateOffset(this);
    if (typeof e2 == "string") {
      if ((e2 = offsetFromString(matchShortOffset, e2)) === null)
        return this;
    } else
      Math.abs(e2) < 16 && !r2 && (e2 *= 60);
    return !this._isUTC && t2 && (n2 = getDateOffset(this)), this._offset = e2, this._isUTC = true, n2 != null && this.add(n2, "m"), i2 !== e2 && (!t2 || this._changeInProgress ? addSubtract(this, createDuration(e2 - i2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, hooks.updateOffset(this, true), this._changeInProgress = null)), this;
  }
  function getSetZone(e2, t2) {
    return e2 != null ? (this.utcOffset(e2 = typeof e2 != "string" ? -e2 : e2, t2), this) : -this.utcOffset();
  }
  function setOffsetToUTC(e2) {
    return this.utcOffset(0, e2);
  }
  function setOffsetToLocal(e2) {
    return this._isUTC && (this.utcOffset(0, e2), this._isUTC = false, e2 && this.subtract(getDateOffset(this), "m")), this;
  }
  function setOffsetToParsedOffset() {
    var e2;
    return this._tzm != null ? this.utcOffset(this._tzm, false, true) : typeof this._i == "string" && ((e2 = offsetFromString(matchOffset, this._i)) != null ? this.utcOffset(e2) : this.utcOffset(0, true)), this;
  }
  function hasAlignedHourOffset(e2) {
    return !!this.isValid() && (e2 = e2 ? createLocal(e2).utcOffset() : 0, (this.utcOffset() - e2) % 60 == 0);
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted))
      return this._isDSTShifted;
    var e2, t2 = {};
    return copyConfig(t2, this), (t2 = prepareConfig(t2))._a ? (e2 = (t2._isUTC ? createUTC : createLocal)(t2._a), this._isDSTShifted = this.isValid() && 0 < compareArrays(t2._a, e2.toArray())) : this._isDSTShifted = false, this._isDSTShifted;
  }
  function isLocal() {
    return !!this.isValid() && !this._isUTC;
  }
  function isUtcOffset() {
    return !!this.isValid() && this._isUTC;
  }
  function isUtc() {
    return !!this.isValid() && (this._isUTC && this._offset === 0);
  }
  hooks.updateOffset = function() {
  };
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(e2, t2) {
    var r2, n2 = e2, i2 = null;
    return isDuration(e2) ? n2 = { ms: e2._milliseconds, d: e2._days, M: e2._months } : isNumber(e2) || !isNaN(+e2) ? (n2 = {}, t2 ? n2[t2] = +e2 : n2.milliseconds = +e2) : (i2 = aspNetRegex.exec(e2)) ? (r2 = i2[1] === "-" ? -1 : 1, n2 = { y: 0, d: toInt(i2[DATE]) * r2, h: toInt(i2[HOUR]) * r2, m: toInt(i2[MINUTE]) * r2, s: toInt(i2[SECOND]) * r2, ms: toInt(absRound(1e3 * i2[MILLISECOND])) * r2 }) : (i2 = isoRegex.exec(e2)) ? (r2 = i2[1] === "-" ? -1 : 1, n2 = { y: parseIso(i2[2], r2), M: parseIso(i2[3], r2), w: parseIso(i2[4], r2), d: parseIso(i2[5], r2), h: parseIso(i2[6], r2), m: parseIso(i2[7], r2), s: parseIso(i2[8], r2) }) : n2 == null ? n2 = {} : typeof n2 == "object" && ("from" in n2 || "to" in n2) && (r2 = momentsDifference(createLocal(n2.from), createLocal(n2.to)), (n2 = {}).ms = r2.milliseconds, n2.M = r2.months), n2 = new Duration(n2), isDuration(e2) && hasOwnProp(e2, "_locale") && (n2._locale = e2._locale), isDuration(e2) && hasOwnProp(e2, "_isValid") && (n2._isValid = e2._isValid), n2;
  }
  function parseIso(e2, t2) {
    e2 = e2 && parseFloat(e2.replace(",", "."));
    return (isNaN(e2) ? 0 : e2) * t2;
  }
  function positiveMomentsDifference(e2, t2) {
    var r2 = {};
    return r2.months = t2.month() - e2.month() + 12 * (t2.year() - e2.year()), e2.clone().add(r2.months, "M").isAfter(t2) && --r2.months, r2.milliseconds = +t2 - +e2.clone().add(r2.months, "M"), r2;
  }
  function momentsDifference(e2, t2) {
    var r2;
    return e2.isValid() && t2.isValid() ? (t2 = cloneWithOffset(t2, e2), e2.isBefore(t2) ? r2 = positiveMomentsDifference(e2, t2) : ((r2 = positiveMomentsDifference(t2, e2)).milliseconds = -r2.milliseconds, r2.months = -r2.months), r2) : { milliseconds: 0, months: 0 };
  }
  function createAdder(n2, i2) {
    return function(e2, t2) {
      var r2;
      return t2 === null || isNaN(+t2) || (deprecateSimple(i2, "moment()." + i2 + "(period, number) is deprecated. Please use moment()." + i2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r2 = e2, e2 = t2, t2 = r2), addSubtract(this, createDuration(e2, t2), n2), this;
    };
  }
  function addSubtract(e2, t2, r2, n2) {
    var i2 = t2._milliseconds, a2 = absRound(t2._days), t2 = absRound(t2._months);
    e2.isValid() && (n2 = n2 == null || n2, t2 && setMonth(e2, get(e2, "Month") + t2 * r2), a2 && set$1$1(e2, "Date", get(e2, "Date") + a2 * r2), i2 && e2._d.setTime(e2._d.valueOf() + i2 * r2), n2 && hooks.updateOffset(e2, a2 || t2));
  }
  createDuration.fn = Duration.prototype, createDuration.invalid = createInvalid$1;
  var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
  function isString(e2) {
    return typeof e2 == "string" || e2 instanceof String;
  }
  function isMomentInput(e2) {
    return isMoment(e2) || isDate(e2) || isString(e2) || isNumber(e2) || isNumberOrStringArray(e2) || isMomentInputObject(e2) || e2 == null;
  }
  function isMomentInputObject(e2) {
    for (var t2 = isObject(e2) && !isObjectEmpty(e2), r2 = false, n2 = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], i2 = 0; i2 < n2.length; i2 += 1)
      r2 = r2 || hasOwnProp(e2, n2[i2]);
    return t2 && r2;
  }
  function isNumberOrStringArray(t2) {
    var e2 = isArray$2(t2), r2 = false;
    return e2 && (r2 = t2.filter(function(e3) {
      return !isNumber(e3) && isString(t2);
    }).length === 0), e2 && r2;
  }
  function isCalendarSpec(e2) {
    for (var t2 = isObject(e2) && !isObjectEmpty(e2), r2 = false, n2 = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i2 = 0; i2 < n2.length; i2 += 1)
      r2 = r2 || hasOwnProp(e2, n2[i2]);
    return t2 && r2;
  }
  function getCalendarFormat(e2, t2) {
    t2 = e2.diff(t2, "days", true);
    return t2 < -6 ? "sameElse" : t2 < -1 ? "lastWeek" : t2 < 0 ? "lastDay" : t2 < 1 ? "sameDay" : t2 < 2 ? "nextDay" : t2 < 7 ? "nextWeek" : "sameElse";
  }
  function calendar$1(e2, t2) {
    arguments.length === 1 && (arguments[0] ? isMomentInput(arguments[0]) ? (e2 = arguments[0], t2 = void 0) : isCalendarSpec(arguments[0]) && (t2 = arguments[0], e2 = void 0) : t2 = e2 = void 0);
    var r2 = e2 || createLocal(), e2 = cloneWithOffset(r2, this).startOf("day"), e2 = hooks.calendarFormat(this, e2) || "sameElse", t2 = t2 && (isFunction(t2[e2]) ? t2[e2].call(this, r2) : t2[e2]);
    return this.format(t2 || this.localeData().calendar(e2, this, createLocal(r2)));
  }
  function clone$1() {
    return new Moment(this);
  }
  function isAfter(e2, t2) {
    e2 = isMoment(e2) ? e2 : createLocal(e2);
    return !(!this.isValid() || !e2.isValid()) && ((t2 = normalizeUnits(t2) || "millisecond") === "millisecond" ? this.valueOf() > e2.valueOf() : e2.valueOf() < this.clone().startOf(t2).valueOf());
  }
  function isBefore(e2, t2) {
    e2 = isMoment(e2) ? e2 : createLocal(e2);
    return !(!this.isValid() || !e2.isValid()) && ((t2 = normalizeUnits(t2) || "millisecond") === "millisecond" ? this.valueOf() < e2.valueOf() : this.clone().endOf(t2).valueOf() < e2.valueOf());
  }
  function isBetween(e2, t2, r2, n2) {
    e2 = isMoment(e2) ? e2 : createLocal(e2), t2 = isMoment(t2) ? t2 : createLocal(t2);
    return !!(this.isValid() && e2.isValid() && t2.isValid()) && (((n2 = n2 || "()")[0] === "(" ? this.isAfter(e2, r2) : !this.isBefore(e2, r2)) && (n2[1] === ")" ? this.isBefore(t2, r2) : !this.isAfter(t2, r2)));
  }
  function isSame(e2, t2) {
    e2 = isMoment(e2) ? e2 : createLocal(e2);
    return !(!this.isValid() || !e2.isValid()) && ((t2 = normalizeUnits(t2) || "millisecond") === "millisecond" ? this.valueOf() === e2.valueOf() : (e2 = e2.valueOf(), this.clone().startOf(t2).valueOf() <= e2 && e2 <= this.clone().endOf(t2).valueOf()));
  }
  function isSameOrAfter(e2, t2) {
    return this.isSame(e2, t2) || this.isAfter(e2, t2);
  }
  function isSameOrBefore(e2, t2) {
    return this.isSame(e2, t2) || this.isBefore(e2, t2);
  }
  function diff(e2, t2, r2) {
    var n2, i2, a2;
    if (!this.isValid())
      return NaN;
    if (!(n2 = cloneWithOffset(e2, this)).isValid())
      return NaN;
    switch (i2 = 6e4 * (n2.utcOffset() - this.utcOffset()), t2 = normalizeUnits(t2)) {
      case "year":
        a2 = monthDiff(this, n2) / 12;
        break;
      case "month":
        a2 = monthDiff(this, n2);
        break;
      case "quarter":
        a2 = monthDiff(this, n2) / 3;
        break;
      case "second":
        a2 = (this - n2) / 1e3;
        break;
      case "minute":
        a2 = (this - n2) / 6e4;
        break;
      case "hour":
        a2 = (this - n2) / 36e5;
        break;
      case "day":
        a2 = (this - n2 - i2) / 864e5;
        break;
      case "week":
        a2 = (this - n2 - i2) / 6048e5;
        break;
      default:
        a2 = this - n2;
    }
    return r2 ? a2 : absFloor(a2);
  }
  function monthDiff(e2, t2) {
    if (e2.date() < t2.date())
      return -monthDiff(t2, e2);
    var r2 = 12 * (t2.year() - e2.year()) + (t2.month() - e2.month()), n2 = e2.clone().add(r2, "months"), n2 = t2 - n2 < 0 ? (t2 - n2) / (n2 - e2.clone().add(r2 - 1, "months")) : (t2 - n2) / (e2.clone().add(1 + r2, "months") - n2);
    return -(r2 + n2) || 0;
  }
  function toString$2() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function toISOString(e2) {
    if (!this.isValid())
      return null;
    var t2 = e2 !== true, e2 = t2 ? this.clone().utc() : this;
    return e2.year() < 0 || 9999 < e2.year() ? formatMoment(e2, t2 ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? t2 ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", formatMoment(e2, "Z")) : formatMoment(e2, t2 ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  function inspect() {
    if (!this.isValid())
      return "moment.invalid(/* " + this._i + " */)";
    var e2, t2 = "moment", r2 = "";
    return this.isLocal() || (t2 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", r2 = "Z"), e2 = "[" + t2 + '("]', t2 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", this.format(e2 + t2 + "-MM-DD[T]HH:mm:ss.SSS" + (r2 + '[")]'));
  }
  function format$1(e2) {
    e2 = e2 || (this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
    e2 = formatMoment(this, e2);
    return this.localeData().postformat(e2);
  }
  function from(e2, t2) {
    return this.isValid() && (isMoment(e2) && e2.isValid() || createLocal(e2).isValid()) ? createDuration({ to: this, from: e2 }).locale(this.locale()).humanize(!t2) : this.localeData().invalidDate();
  }
  function fromNow(e2) {
    return this.from(createLocal(), e2);
  }
  function to(e2, t2) {
    return this.isValid() && (isMoment(e2) && e2.isValid() || createLocal(e2).isValid()) ? createDuration({ from: this, to: e2 }).locale(this.locale()).humanize(!t2) : this.localeData().invalidDate();
  }
  function toNow(e2) {
    return this.to(createLocal(), e2);
  }
  function locale(e2) {
    return e2 === void 0 ? this._locale._abbr : ((e2 = getLocale(e2)) != null && (this._locale = e2), this);
  }
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e2) {
    return e2 === void 0 ? this.localeData() : this.locale(e2);
  });
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = 3506328 * MS_PER_HOUR;
  function mod$1(e2, t2) {
    return (e2 % t2 + t2) % t2;
  }
  function localStartOfDate(e2, t2, r2) {
    return e2 < 100 && 0 <= e2 ? new Date(e2 + 400, t2, r2) - MS_PER_400_YEARS : new Date(e2, t2, r2).valueOf();
  }
  function utcStartOfDate(e2, t2, r2) {
    return e2 < 100 && 0 <= e2 ? Date.UTC(e2 + 400, t2, r2) - MS_PER_400_YEARS : Date.UTC(e2, t2, r2);
  }
  function startOf(e2) {
    var t2, r2;
    if ((e2 = normalizeUnits(e2)) === void 0 || e2 === "millisecond" || !this.isValid())
      return this;
    switch (r2 = this._isUTC ? utcStartOfDate : localStartOfDate, e2) {
      case "year":
        t2 = r2(this.year(), 0, 1);
        break;
      case "quarter":
        t2 = r2(this.year(), this.month() - this.month() % 3, 1);
        break;
      case "month":
        t2 = r2(this.year(), this.month(), 1);
        break;
      case "week":
        t2 = r2(this.year(), this.month(), this.date() - this.weekday());
        break;
      case "isoWeek":
        t2 = r2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case "day":
      case "date":
        t2 = r2(this.year(), this.month(), this.date());
        break;
      case "hour":
        t2 = this._d.valueOf(), t2 -= mod$1(t2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;
      case "minute":
        t2 = this._d.valueOf(), t2 -= mod$1(t2, MS_PER_MINUTE);
        break;
      case "second":
        t2 = this._d.valueOf(), t2 -= mod$1(t2, MS_PER_SECOND);
    }
    return this._d.setTime(t2), hooks.updateOffset(this, true), this;
  }
  function endOf(e2) {
    var t2, r2;
    if ((e2 = normalizeUnits(e2)) === void 0 || e2 === "millisecond" || !this.isValid())
      return this;
    switch (r2 = this._isUTC ? utcStartOfDate : localStartOfDate, e2) {
      case "year":
        t2 = r2(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        t2 = r2(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case "month":
        t2 = r2(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        t2 = r2(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case "isoWeek":
        t2 = r2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case "day":
      case "date":
        t2 = r2(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        t2 = this._d.valueOf(), t2 += MS_PER_HOUR - mod$1(t2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;
      case "minute":
        t2 = this._d.valueOf(), t2 += MS_PER_MINUTE - mod$1(t2, MS_PER_MINUTE) - 1;
        break;
      case "second":
        t2 = this._d.valueOf(), t2 += MS_PER_SECOND - mod$1(t2, MS_PER_SECOND) - 1;
    }
    return this._d.setTime(t2), hooks.updateOffset(this, true), this;
  }
  function valueOf() {
    return this._d.valueOf() - 6e4 * (this._offset || 0);
  }
  function unix() {
    return Math.floor(this.valueOf() / 1e3);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()];
  }
  function toObject() {
    return { years: this.year(), months: this.month(), date: this.date(), hours: this.hours(), minutes: this.minutes(), seconds: this.seconds(), milliseconds: this.milliseconds() };
  }
  function toJSON$2() {
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
  }
  function localeEras(e2, t2) {
    for (var r2, n2 = this._eras || getLocale("en")._eras, i2 = 0, a2 = n2.length; i2 < a2; ++i2)
      switch (typeof n2[i2].since == "string" && (r2 = hooks(n2[i2].since).startOf("day"), n2[i2].since = r2.valueOf()), typeof n2[i2].until) {
        case "undefined":
          n2[i2].until = 1 / 0;
          break;
        case "string":
          r2 = hooks(n2[i2].until).startOf("day").valueOf(), n2[i2].until = r2.valueOf();
      }
    return n2;
  }
  function localeErasParse(e2, t2, r2) {
    var n2, i2, a2, o2, s2, l2 = this.eras();
    for (e2 = e2.toUpperCase(), n2 = 0, i2 = l2.length; n2 < i2; ++n2)
      if (a2 = l2[n2].name.toUpperCase(), o2 = l2[n2].abbr.toUpperCase(), s2 = l2[n2].narrow.toUpperCase(), r2)
        switch (t2) {
          case "N":
          case "NN":
          case "NNN":
            if (o2 === e2)
              return l2[n2];
            break;
          case "NNNN":
            if (a2 === e2)
              return l2[n2];
            break;
          case "NNNNN":
            if (s2 === e2)
              return l2[n2];
        }
      else if (0 <= [a2, o2, s2].indexOf(e2))
        return l2[n2];
  }
  function localeErasConvertYear(e2, t2) {
    var r2 = e2.since <= e2.until ? 1 : -1;
    return t2 === void 0 ? hooks(e2.since).year() : hooks(e2.since).year() + (t2 - e2.offset) * r2;
  }
  function getEraName() {
    for (var e2, t2 = this.localeData().eras(), r2 = 0, n2 = t2.length; r2 < n2; ++r2) {
      if (e2 = this.clone().startOf("day").valueOf(), t2[r2].since <= e2 && e2 <= t2[r2].until)
        return t2[r2].name;
      if (t2[r2].until <= e2 && e2 <= t2[r2].since)
        return t2[r2].name;
    }
    return "";
  }
  function getEraNarrow() {
    for (var e2, t2 = this.localeData().eras(), r2 = 0, n2 = t2.length; r2 < n2; ++r2) {
      if (e2 = this.clone().startOf("day").valueOf(), t2[r2].since <= e2 && e2 <= t2[r2].until)
        return t2[r2].narrow;
      if (t2[r2].until <= e2 && e2 <= t2[r2].since)
        return t2[r2].narrow;
    }
    return "";
  }
  function getEraAbbr() {
    for (var e2, t2 = this.localeData().eras(), r2 = 0, n2 = t2.length; r2 < n2; ++r2) {
      if (e2 = this.clone().startOf("day").valueOf(), t2[r2].since <= e2 && e2 <= t2[r2].until)
        return t2[r2].abbr;
      if (t2[r2].until <= e2 && e2 <= t2[r2].since)
        return t2[r2].abbr;
    }
    return "";
  }
  function getEraYear() {
    for (var e2, t2, r2 = this.localeData().eras(), n2 = 0, i2 = r2.length; n2 < i2; ++n2)
      if (e2 = r2[n2].since <= r2[n2].until ? 1 : -1, t2 = this.clone().startOf("day").valueOf(), r2[n2].since <= t2 && t2 <= r2[n2].until || r2[n2].until <= t2 && t2 <= r2[n2].since)
        return (this.year() - hooks(r2[n2].since).year()) * e2 + r2[n2].offset;
    return this.year();
  }
  function erasNameRegex(e2) {
    return hasOwnProp(this, "_erasNameRegex") || computeErasParse.call(this), e2 ? this._erasNameRegex : this._erasRegex;
  }
  function erasAbbrRegex(e2) {
    return hasOwnProp(this, "_erasAbbrRegex") || computeErasParse.call(this), e2 ? this._erasAbbrRegex : this._erasRegex;
  }
  function erasNarrowRegex(e2) {
    return hasOwnProp(this, "_erasNarrowRegex") || computeErasParse.call(this), e2 ? this._erasNarrowRegex : this._erasRegex;
  }
  function matchEraAbbr(e2, t2) {
    return t2.erasAbbrRegex(e2);
  }
  function matchEraName(e2, t2) {
    return t2.erasNameRegex(e2);
  }
  function matchEraNarrow(e2, t2) {
    return t2.erasNarrowRegex(e2);
  }
  function matchEraYearOrdinal(e2, t2) {
    return t2._eraYearOrdinalRegex || matchUnsigned;
  }
  function computeErasParse() {
    for (var e2 = [], t2 = [], r2 = [], n2 = [], i2 = this.eras(), a2 = 0, o2 = i2.length; a2 < o2; ++a2)
      t2.push(regexEscape(i2[a2].name)), e2.push(regexEscape(i2[a2].abbr)), r2.push(regexEscape(i2[a2].narrow)), n2.push(regexEscape(i2[a2].name)), n2.push(regexEscape(i2[a2].abbr)), n2.push(regexEscape(i2[a2].narrow));
    this._erasRegex = new RegExp("^(" + n2.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t2.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e2.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + r2.join("|") + ")", "i");
  }
  function addWeekYearFormatToken(e2, t2) {
    addFormatToken(0, [e2, e2.length], 0, t2);
  }
  function getSetWeekYear(e2) {
    return getSetWeekYearHelper.call(this, e2, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(e2) {
    return getSetWeekYearHelper.call(this, e2, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }
  function getWeeksInYear() {
    var e2 = this.localeData()._week;
    return weeksInYear(this.year(), e2.dow, e2.doy);
  }
  function getWeeksInWeekYear() {
    var e2 = this.localeData()._week;
    return weeksInYear(this.weekYear(), e2.dow, e2.doy);
  }
  function getSetWeekYearHelper(e2, t2, r2, n2, i2) {
    var a2;
    return e2 == null ? weekOfYear(this, n2, i2).year : (a2 = weeksInYear(e2, n2, i2), setWeekAll.call(this, e2, t2 = a2 < t2 ? a2 : t2, r2, n2, i2));
  }
  function setWeekAll(e2, t2, r2, n2, i2) {
    i2 = dayOfYearFromWeeks(e2, t2, r2, n2, i2), i2 = createUTCDate(i2.year, 0, i2.dayOfYear);
    return this.year(i2.getUTCFullYear()), this.month(i2.getUTCMonth()), this.date(i2.getUTCDate()), this;
  }
  function getSetQuarter(e2) {
    return e2 == null ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e2 - 1) + this.month() % 3);
  }
  addFormatToken("N", 0, 0, "eraAbbr"), addFormatToken("NN", 0, 0, "eraAbbr"), addFormatToken("NNN", 0, 0, "eraAbbr"), addFormatToken("NNNN", 0, 0, "eraName"), addFormatToken("NNNNN", 0, 0, "eraNarrow"), addFormatToken("y", ["y", 1], "yo", "eraYear"), addFormatToken("y", ["yy", 2], 0, "eraYear"), addFormatToken("y", ["yyy", 3], 0, "eraYear"), addFormatToken("y", ["yyyy", 4], 0, "eraYear"), addRegexToken("N", matchEraAbbr), addRegexToken("NN", matchEraAbbr), addRegexToken("NNN", matchEraAbbr), addRegexToken("NNNN", matchEraName), addRegexToken("NNNNN", matchEraNarrow), addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e2, t2, r2, n2) {
    n2 = r2._locale.erasParse(e2, n2, r2._strict);
    n2 ? getParsingFlags(r2).era = n2 : getParsingFlags(r2).invalidEra = e2;
  }), addRegexToken("y", matchUnsigned), addRegexToken("yy", matchUnsigned), addRegexToken("yyy", matchUnsigned), addRegexToken("yyyy", matchUnsigned), addRegexToken("yo", matchEraYearOrdinal), addParseToken(["y", "yy", "yyy", "yyyy"], YEAR), addParseToken(["yo"], function(e2, t2, r2, n2) {
    var i2;
    r2._locale._eraYearOrdinalRegex && (i2 = e2.match(r2._locale._eraYearOrdinalRegex)), r2._locale.eraYearOrdinalParse ? t2[YEAR] = r2._locale.eraYearOrdinalParse(e2, i2) : t2[YEAR] = parseInt(e2, 10);
  }), addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  }), addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(e2, t2, r2, n2) {
    t2[n2.substr(0, 2)] = toInt(e2);
  }), addWeekParseToken(["gg", "GG"], function(e2, t2, r2, n2) {
    t2[n2] = hooks.parseTwoDigitYear(e2);
  }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), addRegexToken("Q", match1), addParseToken("Q", function(e2, t2) {
    t2[MONTH] = 3 * (toInt(e2) - 1);
  }), addFormatToken("D", ["DD", 2], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", function(e2, t2) {
    return e2 ? t2._dayOfMonthOrdinalParse || t2._ordinalParse : t2._dayOfMonthOrdinalParseLenient;
  }), addParseToken(["D", "DD"], DATE), addParseToken("Do", function(e2, t2) {
    t2[DATE] = toInt(e2.match(match1to2)[0]);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  function getSetDayOfYear(e2) {
    var t2 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return e2 == null ? t2 : this.add(e2 - t2, "d");
  }
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), addParseToken(["DDD", "DDDD"], function(e2, t2, r2) {
    r2._dayOfYear = toInt(e2);
  }), addFormatToken("m", ["mm", 2], 0, "minute"), addUnitAlias("minute", "m"), addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), addParseToken(["m", "mm"], MINUTE);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken(["s", "ss"], SECOND);
  var getSetSecond = makeGetSet("Seconds", false), token, getSetMillisecond;
  for (addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  }), addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  }), addFormatToken(0, ["SSS", 3], 0, "millisecond"), addFormatToken(0, ["SSSS", 4], 0, function() {
    return 10 * this.millisecond();
  }), addFormatToken(0, ["SSSSS", 5], 0, function() {
    return 100 * this.millisecond();
  }), addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return 1e3 * this.millisecond();
  }), addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return 1e4 * this.millisecond();
  }), addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return 1e5 * this.millisecond();
  }), addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return 1e6 * this.millisecond();
  }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3), token = "SSSS"; token.length <= 9; token += "S")
    addRegexToken(token, matchUnsigned);
  function parseMs(e2, t2) {
    t2[MILLISECOND] = toInt(1e3 * ("0." + e2));
  }
  for (token = "S"; token.length <= 9; token += "S")
    addParseToken(token, parseMs);
  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }
  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  getSetMillisecond = makeGetSet("Milliseconds", false), addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
  var proto = Moment.prototype;
  function createUnix(e2) {
    return createLocal(1e3 * e2);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(e2) {
    return e2;
  }
  proto.add = add, proto.calendar = calendar$1, proto.clone = clone$1, proto.diff = diff, proto.endOf = endOf, proto.format = format$1, proto.from = from, proto.fromNow = fromNow, proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, proto.isValid = isValid$2, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, proto.inspect = inspect, typeof Symbol != "undefined" && Symbol.for != null && (proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  }), proto.toJSON = toJSON$2, proto.toString = toString$2, proto.unix = unix, proto.valueOf = valueOf, proto.creationData = creationData, proto.eraName = getEraName, proto.eraNarrow = getEraNarrow, proto.eraAbbr = getEraAbbr, proto.eraYear = getEraYear, proto.year = getSetYear, proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, proto.weeksInYear = getWeeksInYear, proto.weeksInWeekYear = getWeeksInWeekYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear, proto.date = getSetDayOfMonth, proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
  var proto$1 = Locale.prototype;
  function get$1(e2, t2, r2, n2) {
    var i2 = getLocale(), t2 = createUTC().set(n2, t2);
    return i2[r2](t2, e2);
  }
  function listMonthsImpl(e2, t2, r2) {
    if (isNumber(e2) && (t2 = e2, e2 = void 0), e2 = e2 || "", t2 != null)
      return get$1(e2, t2, r2, "month");
    for (var n2 = [], i2 = 0; i2 < 12; i2++)
      n2[i2] = get$1(e2, i2, r2, "month");
    return n2;
  }
  function listWeekdaysImpl(e2, t2, r2, n2) {
    t2 = (typeof e2 == "boolean" ? isNumber(t2) && (r2 = t2, t2 = void 0) : (t2 = e2, e2 = false, isNumber(r2 = t2) && (r2 = t2, t2 = void 0)), t2 || "");
    var i2, a2 = getLocale(), o2 = e2 ? a2._week.dow : 0, s2 = [];
    if (r2 != null)
      return get$1(t2, (r2 + o2) % 7, n2, "day");
    for (i2 = 0; i2 < 7; i2++)
      s2[i2] = get$1(t2, (i2 + o2) % 7, n2, "day");
    return s2;
  }
  function listMonths(e2, t2) {
    return listMonthsImpl(e2, t2, "months");
  }
  function listMonthsShort(e2, t2) {
    return listMonthsImpl(e2, t2, "monthsShort");
  }
  function listWeekdays(e2, t2, r2) {
    return listWeekdaysImpl(e2, t2, r2, "weekdays");
  }
  function listWeekdaysShort(e2, t2, r2) {
    return listWeekdaysImpl(e2, t2, r2, "weekdaysShort");
  }
  function listWeekdaysMin(e2, t2, r2) {
    return listWeekdaysImpl(e2, t2, r2, "weekdaysMin");
  }
  proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set$1, proto$1.eras = localeEras, proto$1.erasParse = localeErasParse, proto$1.erasConvertYear = localeErasConvertYear, proto$1.erasAbbrRegex = erasAbbrRegex, proto$1.erasNameRegex = erasNameRegex, proto$1.erasNarrowRegex = erasNarrowRegex, proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e2) {
    var t2 = e2 % 10;
    return e2 + (toInt(e2 % 100 / 10) === 1 ? "th" : t2 == 1 ? "st" : t2 == 2 ? "nd" : t2 == 3 ? "rd" : "th");
  } }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
  var mathAbs = Math.abs;
  function abs() {
    var e2 = this._data;
    return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), this._months = mathAbs(this._months), e2.milliseconds = mathAbs(e2.milliseconds), e2.seconds = mathAbs(e2.seconds), e2.minutes = mathAbs(e2.minutes), e2.hours = mathAbs(e2.hours), e2.months = mathAbs(e2.months), e2.years = mathAbs(e2.years), this;
  }
  function addSubtract$1(e2, t2, r2, n2) {
    r2 = createDuration(t2, r2);
    return e2._milliseconds += n2 * r2._milliseconds, e2._days += n2 * r2._days, e2._months += n2 * r2._months, e2._bubble();
  }
  function add$1(e2, t2) {
    return addSubtract$1(this, e2, t2, 1);
  }
  function subtract$1(e2, t2) {
    return addSubtract$1(this, e2, t2, -1);
  }
  function absCeil(e2) {
    return e2 < 0 ? Math.floor(e2) : Math.ceil(e2);
  }
  function bubble() {
    var e2 = this._milliseconds, t2 = this._days, r2 = this._months, n2 = this._data;
    return 0 <= e2 && 0 <= t2 && 0 <= r2 || e2 <= 0 && t2 <= 0 && r2 <= 0 || (e2 += 864e5 * absCeil(monthsToDays(r2) + t2), r2 = t2 = 0), n2.milliseconds = e2 % 1e3, e2 = absFloor(e2 / 1e3), n2.seconds = e2 % 60, e2 = absFloor(e2 / 60), n2.minutes = e2 % 60, e2 = absFloor(e2 / 60), n2.hours = e2 % 24, t2 += absFloor(e2 / 24), r2 += e2 = absFloor(daysToMonths(t2)), t2 -= absCeil(monthsToDays(e2)), e2 = absFloor(r2 / 12), r2 %= 12, n2.days = t2, n2.months = r2, n2.years = e2, this;
  }
  function daysToMonths(e2) {
    return 4800 * e2 / 146097;
  }
  function monthsToDays(e2) {
    return 146097 * e2 / 4800;
  }
  function as(e2) {
    if (!this.isValid())
      return NaN;
    var t2, r2, n2 = this._milliseconds;
    if ((e2 = normalizeUnits(e2)) === "month" || e2 === "quarter" || e2 === "year")
      switch (t2 = this._days + n2 / 864e5, r2 = this._months + daysToMonths(t2), e2) {
        case "month":
          return r2;
        case "quarter":
          return r2 / 3;
        case "year":
          return r2 / 12;
      }
    else
      switch (t2 = this._days + Math.round(monthsToDays(this._months)), e2) {
        case "week":
          return t2 / 7 + n2 / 6048e5;
        case "day":
          return t2 + n2 / 864e5;
        case "hour":
          return 24 * t2 + n2 / 36e5;
        case "minute":
          return 1440 * t2 + n2 / 6e4;
        case "second":
          return 86400 * t2 + n2 / 1e3;
        case "millisecond":
          return Math.floor(864e5 * t2) + n2;
        default:
          throw new Error("Unknown unit " + e2);
      }
  }
  function valueOf$1() {
    return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12) : NaN;
  }
  function makeAs(e2) {
    return function() {
      return this.as(e2);
    };
  }
  var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
  function clone$1$1() {
    return createDuration(this);
  }
  function get$2(e2) {
    return e2 = normalizeUnits(e2), this.isValid() ? this[e2 + "s"]() : NaN;
  }
  function makeGetter(e2) {
    return function() {
      return this.isValid() ? this._data[e2] : NaN;
    };
  }
  var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round, thresholds = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
  function substituteTimeAgo(e2, t2, r2, n2, i2) {
    return i2.relativeTime(t2 || 1, !!r2, e2, n2);
  }
  function relativeTime$1(e2, t2, r2, n2) {
    var i2 = createDuration(e2).abs(), a2 = round(i2.as("s")), o2 = round(i2.as("m")), s2 = round(i2.as("h")), l2 = round(i2.as("d")), c2 = round(i2.as("M")), u2 = round(i2.as("w")), i2 = round(i2.as("y")), l2 = (a2 <= r2.ss ? ["s", a2] : a2 < r2.s && ["ss", a2]) || o2 <= 1 && ["m"] || o2 < r2.m && ["mm", o2] || s2 <= 1 && ["h"] || s2 < r2.h && ["hh", s2] || l2 <= 1 && ["d"] || l2 < r2.d && ["dd", l2];
    return (l2 = (l2 = r2.w != null ? l2 || u2 <= 1 && ["w"] || u2 < r2.w && ["ww", u2] : l2) || c2 <= 1 && ["M"] || c2 < r2.M && ["MM", c2] || i2 <= 1 && ["y"] || ["yy", i2])[2] = t2, l2[3] = 0 < +e2, l2[4] = n2, substituteTimeAgo.apply(null, l2);
  }
  function getSetRelativeTimeRounding(e2) {
    return e2 === void 0 ? round : typeof e2 == "function" && (round = e2, true);
  }
  function getSetRelativeTimeThreshold(e2, t2) {
    return thresholds[e2] !== void 0 && (t2 === void 0 ? thresholds[e2] : (thresholds[e2] = t2, e2 === "s" && (thresholds.ss = t2 - 1), true));
  }
  function humanize(e2, t2) {
    if (!this.isValid())
      return this.localeData().invalidDate();
    var r2 = false, n2 = thresholds;
    return typeof e2 == "object" && (t2 = e2, e2 = false), typeof e2 == "boolean" && (r2 = e2), typeof t2 == "object" && (n2 = Object.assign({}, thresholds, t2), t2.s != null && t2.ss == null && (n2.ss = t2.s - 1)), t2 = this.localeData(), n2 = relativeTime$1(this, !r2, n2, t2), r2 && (n2 = t2.pastFuture(+this, n2)), t2.postformat(n2);
  }
  var abs$1 = Math.abs;
  function sign$1(e2) {
    return (0 < e2) - (e2 < 0) || +e2;
  }
  function toISOString$1() {
    if (!this.isValid())
      return this.localeData().invalidDate();
    var e2, t2, r2, n2, i2, a2, o2, s2 = abs$1(this._milliseconds) / 1e3, l2 = abs$1(this._days), c2 = abs$1(this._months), u2 = this.asSeconds();
    return u2 ? (e2 = absFloor(s2 / 60), t2 = absFloor(e2 / 60), s2 %= 60, e2 %= 60, r2 = absFloor(c2 / 12), c2 %= 12, n2 = s2 ? s2.toFixed(3).replace(/\.?0+$/, "") : "", i2 = u2 < 0 ? "-" : "", a2 = sign$1(this._months) !== sign$1(u2) ? "-" : "", o2 = sign$1(this._days) !== sign$1(u2) ? "-" : "", u2 = sign$1(this._milliseconds) !== sign$1(u2) ? "-" : "", i2 + "P" + (r2 ? a2 + r2 + "Y" : "") + (c2 ? a2 + c2 + "M" : "") + (l2 ? o2 + l2 + "D" : "") + (t2 || e2 || s2 ? "T" : "") + (t2 ? u2 + t2 + "H" : "") + (e2 ? u2 + e2 + "M" : "") + (s2 ? u2 + n2 + "S" : "")) : "P0D";
  }
  var proto$2 = Duration.prototype, _a$1, _b$1, _c$1, _d$1;
  proto$2.isValid = isValid$1, proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, proto$2.as = as, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asQuarters = asQuarters, proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, proto$2.clone = clone$1$1, proto$2.get = get$2, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = weeks, proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", function(e2, t2, r2) {
    r2._d = new Date(1e3 * parseFloat(e2));
  }), addParseToken("x", function(e2, t2, r2) {
    r2._d = new Date(toInt(e2));
  }), hooks.version = "2.29.1", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, hooks.max = max, hooks.now = now$1, hooks.utc = createUTC, hooks.unix = createUnix, hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" };
  let issueWarning$1;
  (_a$1 = globalThis.litIssuedWarnings) !== null && _a$1 !== void 0 || (globalThis.litIssuedWarnings = new Set()), issueWarning$1 = (e2, t2) => {
    t2 += e2 ? ` See https://lit.dev/msg/${e2} for more information.` : "", globalThis.litIssuedWarnings.has(t2) || (console.warn(t2), globalThis.litIssuedWarnings.add(t2));
  }, issueWarning$1("dev-mode", "Lit is in dev mode. Not recommended for production!");
  const wrap$2 = (_b$1 = window.ShadyDOM) !== null && _b$1 !== void 0 && _b$1.inUse && ((_c$1 = window.ShadyDOM) === null || _c$1 === void 0 ? void 0 : _c$1.noPatch) === true ? window.ShadyDOM.wrap : (e2) => e2, trustedTypes$1 = globalThis.trustedTypes, policy$1 = trustedTypes$1 ? trustedTypes$1.createPolicy("lit-html", { createHTML: (e2) => e2 }) : void 0, identityFunction$1 = (e2) => e2, noopSanitizer$1 = (e2, t2, r2) => identityFunction$1, createSanitizer$1 = (e2, t2, r2) => sanitizerFactoryInternal$1(), boundAttributeSuffix$1 = "$lit$", marker$1 = `lit$${String(Math.random()).slice(9)}$`, markerMatch$1 = "?" + marker$1, nodeMarker$1 = `<${markerMatch$1}>`, d$1 = document, createMarker$1 = (e2 = "") => d$1.createComment(e2), isPrimitive$1 = (e2) => e2 === null || typeof e2 != "object" && typeof e2 != "function", isArray$1 = Array.isArray, isIterable$1 = (e2) => {
    return isArray$1(e2) || typeof (e2 === null || e2 === void 0 ? void 0 : e2[Symbol.iterator]) == "function";
  }, SPACE_CHAR$1 = `[ 	
\f\r]`, ATTR_VALUE_CHAR$1 = `[^ 	
\f\r"'\`<>=]`, NAME_CHAR$1 = `[^\\s"'>=/]`, textEndRegex$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, COMMENT_START$1 = 1, TAG_NAME$1 = 2, DYNAMIC_TAG_NAME$1 = 3, commentEndRegex$1 = /-->/g, comment2EndRegex$1 = />/g, tagEndRegex$1 = new RegExp(`>|${SPACE_CHAR$1}(?:(${NAME_CHAR$1}+)(${SPACE_CHAR$1}*=${SPACE_CHAR$1}*(?:${ATTR_VALUE_CHAR$1}|("|')|))|$)`, "g"), ENTIRE_MATCH$1 = 0, ATTRIBUTE_NAME$1 = 1, SPACES_AND_EQUALS$1 = 2, QUOTE_CHAR$1 = 3, singleQuoteAttrEndRegex$1 = /'/g, doubleQuoteAttrEndRegex$1 = /"/g, rawTextElement$1 = /^(?:script|style|textarea)$/i, HTML_RESULT$1 = 1, SVG_RESULT$1 = 2, ATTRIBUTE_PART$1 = 1, CHILD_PART$1 = 2, PROPERTY_PART$1 = 3, BOOLEAN_ATTRIBUTE_PART$1 = 4, EVENT_PART$1 = 5, ELEMENT_PART$1 = 6, COMMENT_PART$1 = 7, tag = (r2) => (e2, ...t2) => (e2.some((e3) => e3 === void 0) && console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences."), { _$litType$: r2, strings: e2, values: t2 }), html$1 = tag(HTML_RESULT$1), noChange$1 = Symbol.for("lit-noChange"), nothing$1 = Symbol.for("lit-nothing"), templateCache$1 = new WeakMap(), walker$1 = d$1.createTreeWalker(d$1, 129, null, false);
  let sanitizerFactoryInternal$1 = noopSanitizer$1;
  const getTemplateHtml$1 = (i2, e2) => {
    var a2, t2 = i2.length - 1;
    const o2 = [];
    let s2 = e2 === SVG_RESULT$1 ? "<svg>" : "", l2, c2 = textEndRegex$1;
    for (let n2 = 0; n2 < t2; n2++) {
      const h2 = i2[n2];
      let e3 = -1, t3, r2 = 0;
      for (; r2 < h2.length && (c2.lastIndex = r2, (a2 = c2.exec(h2)) !== null); )
        if (r2 = c2.lastIndex, c2 === textEndRegex$1) {
          if (a2[COMMENT_START$1] === "!--")
            c2 = commentEndRegex$1;
          else if (a2[COMMENT_START$1] !== void 0)
            c2 = comment2EndRegex$1;
          else if (a2[TAG_NAME$1] !== void 0)
            rawTextElement$1.test(a2[TAG_NAME$1]) && (l2 = new RegExp("</" + a2[TAG_NAME$1], "g")), c2 = tagEndRegex$1;
          else if (a2[DYNAMIC_TAG_NAME$1] !== void 0)
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
        } else
          c2 === tagEndRegex$1 ? a2[ENTIRE_MATCH$1] === ">" ? (c2 = l2 !== null && l2 !== void 0 ? l2 : textEndRegex$1, e3 = -1) : a2[ATTRIBUTE_NAME$1] === void 0 ? e3 = -2 : (e3 = c2.lastIndex - a2[SPACES_AND_EQUALS$1].length, t3 = a2[ATTRIBUTE_NAME$1], c2 = a2[QUOTE_CHAR$1] === void 0 ? tagEndRegex$1 : a2[QUOTE_CHAR$1] === '"' ? doubleQuoteAttrEndRegex$1 : singleQuoteAttrEndRegex$1) : c2 === doubleQuoteAttrEndRegex$1 || c2 === singleQuoteAttrEndRegex$1 ? c2 = tagEndRegex$1 : c2 === commentEndRegex$1 || c2 === comment2EndRegex$1 ? c2 = textEndRegex$1 : (c2 = tagEndRegex$1, l2 = void 0);
      console.assert(e3 === -1 || c2 === tagEndRegex$1 || c2 === singleQuoteAttrEndRegex$1 || c2 === doubleQuoteAttrEndRegex$1, "unexpected parse state B");
      var u2 = c2 === tagEndRegex$1 && i2[n2 + 1].startsWith("/>") ? " " : "";
      s2 += c2 === textEndRegex$1 ? h2 + nodeMarker$1 : 0 <= e3 ? (o2.push(t3), h2.slice(0, e3) + boundAttributeSuffix$1 + h2.slice(e3) + marker$1 + u2) : h2 + marker$1 + (e3 === -2 ? (o2.push(void 0), n2) : u2);
    }
    e2 = s2 + (i2[t2] || "<?>") + (e2 === SVG_RESULT$1 ? "</svg>" : "");
    return [policy$1 !== void 0 ? policy$1.createHTML(e2) : e2, o2];
  };
  class Template$1 {
    constructor({ strings: e2, _$litType$: t2 }, r2) {
      this.parts = [];
      let n2, i2 = 0, a2 = 0;
      var o2 = e2.length - 1;
      const s2 = this.parts;
      var [e2, l2] = getTemplateHtml$1(e2, t2);
      if (this.el = Template$1.createElement(e2, r2), walker$1.currentNode = this.el.content, t2 === SVG_RESULT$1) {
        const f2 = this.el.content, m2 = f2.firstChild;
        m2.remove(), f2.append(...m2.childNodes);
      }
      for (; (n2 = walker$1.nextNode()) !== null && s2.length < o2; ) {
        if (n2.nodeType === 1) {
          var c2 = n2.localName;
          if (/^(?:textarea|template)$/i.test(c2) && n2.innerHTML.includes(marker$1)) {
            var u2 = `Expressions are not supported inside \`${c2}\` elements. See https://lit.dev/msg/expression-in-${c2} for more information.`;
            if (c2 === "template")
              throw new Error(u2);
            issueWarning$1("", u2);
          }
          if (n2.hasAttributes()) {
            const g2 = [];
            for (const v2 of n2.getAttributeNames())
              if (v2.endsWith(boundAttributeSuffix$1) || v2.startsWith(marker$1)) {
                const y = l2[a2++];
                if (g2.push(v2), y !== void 0) {
                  const _2 = n2.getAttribute(y.toLowerCase() + boundAttributeSuffix$1);
                  var h2 = _2.split(marker$1), d2 = /([.?@])?(.*)/.exec(y);
                  s2.push({ type: ATTRIBUTE_PART$1, index: i2, name: d2[2], strings: h2, ctor: d2[1] === "." ? PropertyPart$1 : d2[1] === "?" ? BooleanAttributePart$1 : d2[1] === "@" ? EventPart$1 : AttributePart$1 });
                } else
                  s2.push({ type: ELEMENT_PART$1, index: i2 });
              }
            for (const b2 of g2)
              n2.removeAttribute(b2);
          }
          if (rawTextElement$1.test(n2.tagName)) {
            const x2 = n2.textContent.split(marker$1);
            var p2 = x2.length - 1;
            if (0 < p2) {
              n2.textContent = trustedTypes$1 ? trustedTypes$1.emptyScript : "";
              for (let e3 = 0; e3 < p2; e3++)
                n2.append(x2[e3], createMarker$1()), walker$1.nextNode(), s2.push({ type: CHILD_PART$1, index: ++i2 });
              n2.append(x2[p2], createMarker$1());
            }
          }
        } else if (n2.nodeType === 8)
          if (n2.data === markerMatch$1)
            s2.push({ type: CHILD_PART$1, index: i2 });
          else {
            let e3 = -1;
            for (; (e3 = n2.data.indexOf(marker$1, e3 + 1)) !== -1; )
              s2.push({ type: COMMENT_PART$1, index: i2 }), e3 += marker$1.length - 1;
          }
        i2++;
      }
    }
    static createElement(e2, t2) {
      const r2 = d$1.createElement("template");
      return r2.innerHTML = e2, r2;
    }
  }
  function resolveDirective$1(e2, t2, r2 = e2, n2) {
    var i2;
    if (t2 === noChange$1)
      return t2;
    let a2 = n2 !== void 0 ? (i2 = r2.__directives) === null || i2 === void 0 ? void 0 : i2[n2] : r2.__directive;
    const o2 = isPrimitive$1(t2) ? void 0 : t2._$litDirective$;
    return (a2 === null || a2 === void 0 ? void 0 : a2.constructor) !== o2 && ((i2 = a2 === null || a2 === void 0 ? void 0 : a2._$notifyDirectiveConnectionChanged) !== null && i2 !== void 0 && i2.call(a2, false), o2 === void 0 ? a2 = void 0 : (a2 = new o2(e2), a2._$initialize(e2, r2, n2)), n2 !== void 0 ? ((i2 = r2.__directives) !== null && i2 !== void 0 ? i2 : r2.__directives = [])[n2] = a2 : r2.__directive = a2), t2 = a2 !== void 0 ? resolveDirective$1(e2, a2._$resolve(e2, t2.values), a2, n2) : t2;
  }
  class TemplateInstance$1 {
    constructor(e2, t2) {
      this._parts = [], this._$disconnectableChildren = void 0, this._$template = e2, this._$parent = t2;
    }
    get parentNode() {
      return this._$parent.parentNode;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(t2) {
      var e2, { el: { content: r2 }, parts: n2 } = this._$template, r2 = ((e2 = t2 == null ? void 0 : t2.creationScope) !== null && e2 !== void 0 ? e2 : d$1).importNode(r2, true);
      walker$1.currentNode = r2;
      let i2 = walker$1.nextNode(), a2 = 0, o2 = 0, s2 = n2[0];
      for (; s2 !== void 0; ) {
        if (a2 === s2.index) {
          let e3;
          s2.type === CHILD_PART$1 ? e3 = new ChildPart$1(i2, i2.nextSibling, this, t2) : s2.type === ATTRIBUTE_PART$1 ? e3 = new s2.ctor(i2, s2.name, s2.strings, this, t2) : s2.type === ELEMENT_PART$1 && (e3 = new ElementPart$1(i2, this, t2)), this._parts.push(e3), s2 = n2[++o2];
        }
        a2 !== (s2 === null || s2 === void 0 ? void 0 : s2.index) && (i2 = walker$1.nextNode(), a2++);
      }
      return r2;
    }
    _update(e2) {
      let t2 = 0;
      for (const r2 of this._parts)
        r2 !== void 0 && (r2.strings !== void 0 ? (r2._$setValue(e2, r2, t2), t2 += r2.strings.length - 2) : r2._$setValue(e2[t2])), t2++;
    }
  }
  class ChildPart$1 {
    constructor(e2, t2, r2, n2) {
      this.type = CHILD_PART$1, this._$committedValue = nothing$1, this._$disconnectableChildren = void 0, this._$startNode = e2, this._$endNode = t2, this._$parent = r2, this.options = n2, this.__isConnected = (n2 = n2 == null ? void 0 : n2.isConnected) === null || n2 === void 0 || n2, this._textSanitizer = void 0;
    }
    get _$isConnected() {
      var e2;
      return (e2 = (e2 = this._$parent) === null || e2 === void 0 ? void 0 : e2._$isConnected) !== null && e2 !== void 0 ? e2 : this.__isConnected;
    }
    get parentNode() {
      let e2 = wrap$2(this._$startNode).parentNode;
      var t2 = this._$parent;
      return t2 !== void 0 && e2.nodeType === 11 && (e2 = t2.parentNode), e2;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(e2, t2 = this) {
      if (this.parentNode === null)
        throw new Error("This `ChildPart` has no `parentNode` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's `innerHTML` or `textContent` can do this.");
      e2 = resolveDirective$1(this, e2, t2), isPrimitive$1(e2) ? e2 === nothing$1 || e2 == null || e2 === "" ? (this._$committedValue !== nothing$1 && this._$clear(), this._$committedValue = nothing$1) : e2 !== this._$committedValue && e2 !== noChange$1 && this._commitText(e2) : e2._$litType$ !== void 0 ? this._commitTemplateResult(e2) : e2.nodeType !== void 0 ? this._commitNode(e2) : isIterable$1(e2) ? this._commitIterable(e2) : this._commitText(e2);
    }
    _insert(e2, t2 = this._$endNode) {
      return wrap$2(wrap$2(this._$startNode).parentNode).insertBefore(e2, t2);
    }
    _commitNode(e2) {
      if (this._$committedValue !== e2) {
        if (this._$clear(), sanitizerFactoryInternal$1 !== noopSanitizer$1) {
          var t2 = (t2 = this._$startNode.parentNode) === null || t2 === void 0 ? void 0 : t2.nodeName;
          if (t2 === "STYLE" || t2 === "SCRIPT") {
            let e3 = "Forbidden";
            throw e3 = t2 === "STYLE" ? "Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css`...` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets." : "Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.", new Error(e3);
          }
        }
        this._$committedValue = this._insert(e2);
      }
    }
    _commitText(e2) {
      if (this._$committedValue !== nothing$1 && isPrimitive$1(this._$committedValue)) {
        const t2 = wrap$2(this._$startNode).nextSibling;
        this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer$1()), e2 = this._textSanitizer(e2), t2.data = e2;
      } else {
        const r2 = document.createTextNode("");
        this._commitNode(r2), this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer$1()), e2 = this._textSanitizer(e2), r2.data = e2;
      }
      this._$committedValue = e2;
    }
    _commitTemplateResult(e2) {
      const { values: t2, _$litType$: r2 } = e2;
      var n2 = typeof r2 == "number" ? this._$getTemplate(e2) : (r2.el === void 0 && (r2.el = Template$1.createElement(r2.h, this.options)), r2);
      if (((e2 = this._$committedValue) === null || e2 === void 0 ? void 0 : e2._$template) === n2)
        this._$committedValue._update(t2);
      else {
        const i2 = new TemplateInstance$1(n2, this);
        n2 = i2._clone(this.options);
        i2._update(t2), this._commitNode(n2), this._$committedValue = i2;
      }
    }
    _$getTemplate(e2) {
      let t2 = templateCache$1.get(e2.strings);
      return t2 === void 0 && templateCache$1.set(e2.strings, t2 = new Template$1(e2)), t2;
    }
    _commitIterable(e2) {
      isArray$1(this._$committedValue) || (this._$committedValue = [], this._$clear());
      const t2 = this._$committedValue;
      let r2 = 0, n2;
      for (const i2 of e2)
        r2 === t2.length ? t2.push(n2 = new ChildPart$1(this._insert(createMarker$1()), this._insert(createMarker$1()), this, this.options)) : n2 = t2[r2], n2._$setValue(i2), r2++;
      r2 < t2.length && (this._$clear(n2 && wrap$2(n2._$endNode).nextSibling, r2), t2.length = r2);
    }
    _$clear(e2 = wrap$2(this._$startNode).nextSibling, t2) {
      var r2;
      for ((r2 = this._$notifyConnectionChanged) !== null && r2 !== void 0 && r2.call(this, false, true, t2); e2 && e2 !== this._$endNode; ) {
        var n2 = wrap$2(e2).nextSibling;
        wrap$2(e2).remove(), e2 = n2;
      }
    }
    setConnected(e2) {
      var t2;
      if (this._$parent !== void 0)
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      this.__isConnected = e2, (t2 = this._$notifyConnectionChanged) !== null && t2 !== void 0 && t2.call(this, e2);
    }
  }
  class AttributePart$1 {
    constructor(e2, t2, r2, n2, i2) {
      this.type = ATTRIBUTE_PART$1, this._$committedValue = nothing$1, this._$disconnectableChildren = void 0, this.element = e2, this.name = t2, this._$parent = n2, this.options = i2, 2 < r2.length || r2[0] !== "" || r2[1] !== "" ? (this._$committedValue = new Array(r2.length - 1).fill(new String()), this.strings = r2) : this._$committedValue = nothing$1, this._sanitizer = void 0;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(r2, n2 = this, i2, e2) {
      var a2 = this.strings;
      let o2 = false;
      if (a2 === void 0)
        r2 = resolveDirective$1(this, r2, n2, 0), o2 = !isPrimitive$1(r2) || r2 !== this._$committedValue && r2 !== noChange$1, o2 && (this._$committedValue = r2);
      else {
        var s2 = r2;
        r2 = a2[0];
        let e3, t2;
        for (e3 = 0; e3 < a2.length - 1; e3++)
          t2 = resolveDirective$1(this, s2[i2 + e3], n2, e3), t2 === noChange$1 && (t2 = this._$committedValue[e3]), o2 = o2 || (!isPrimitive$1(t2) || t2 !== this._$committedValue[e3]), t2 === nothing$1 ? r2 = nothing$1 : r2 !== nothing$1 && (r2 += (t2 !== null && t2 !== void 0 ? t2 : "") + a2[e3 + 1]), this._$committedValue[e3] = t2;
      }
      o2 && !e2 && this._commitValue(r2);
    }
    _commitValue(e2) {
      e2 === nothing$1 ? wrap$2(this.element).removeAttribute(this.name) : (this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name)), e2 = this._sanitizer(e2 != null ? e2 : ""), wrap$2(this.element).setAttribute(this.name, e2 != null ? e2 : ""));
    }
  }
  class PropertyPart$1 extends AttributePart$1 {
    constructor() {
      super(...arguments), this.type = PROPERTY_PART$1;
    }
    _commitValue(e2) {
      this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name)), e2 = this._sanitizer(e2), this.element[this.name] = e2 === nothing$1 ? void 0 : e2;
    }
  }
  class BooleanAttributePart$1 extends AttributePart$1 {
    constructor() {
      super(...arguments), this.type = BOOLEAN_ATTRIBUTE_PART$1;
    }
    _commitValue(e2) {
      e2 && e2 !== nothing$1 ? wrap$2(this.element).setAttribute(this.name, "") : wrap$2(this.element).removeAttribute(this.name);
    }
  }
  class EventPart$1 extends AttributePart$1 {
    constructor(e2, t2, r2, n2, i2) {
      if (super(e2, t2, r2, n2, i2), this.type = EVENT_PART$1, this.strings !== void 0)
        throw new Error(`A \`<${e2.localName}>\` has a \`@${t2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
    _$setValue(e2, t2 = this) {
      var r2, n2;
      (e2 = (n2 = resolveDirective$1(this, e2, t2, 0)) !== null && n2 !== void 0 ? n2 : nothing$1) !== noChange$1 && (r2 = this._$committedValue, t2 = e2 === nothing$1 && r2 !== nothing$1 || e2.capture !== r2.capture || e2.once !== r2.once || e2.passive !== r2.passive, n2 = e2 !== nothing$1 && (r2 === nothing$1 || t2), t2 && this.element.removeEventListener(this.name, this, r2), n2 && this.element.addEventListener(this.name, this, e2), this._$committedValue = e2);
    }
    handleEvent(e2) {
      var t2;
      typeof this._$committedValue == "function" ? this._$committedValue.call((t2 = (t2 = this.options) === null || t2 === void 0 ? void 0 : t2.host) !== null && t2 !== void 0 ? t2 : this.element, e2) : this._$committedValue.handleEvent(e2);
    }
  }
  class ElementPart$1 {
    constructor(e2, t2, r2) {
      this.element = e2, this.type = ELEMENT_PART$1, this._$disconnectableChildren = void 0, this._$parent = t2, this.options = r2;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(e2) {
      resolveDirective$1(this, e2);
    }
  }
  const polyfillSupport$1 = window.litHtmlPolyfillSupportDevMode;
  polyfillSupport$1 !== null && polyfillSupport$1 !== void 0 && polyfillSupport$1(Template$1, ChildPart$1), ((_d$1 = globalThis.litHtmlVersions) !== null && _d$1 !== void 0 ? _d$1 : globalThis.litHtmlVersions = []).push("2.0.1"), 1 < globalThis.litHtmlVersions.length && issueWarning$1("multiple-versions", "Multiple versions of Lit loaded. Loading multiple versions is not recommended.");
  const stringsCache = new Map(), withStatic = (d2) => (e2, ...t2) => {
    var r2, n2, i2 = t2.length;
    let a2, o2;
    const s2 = [], l2 = [];
    let c2 = 0, u2 = false, h2;
    for (; c2 < i2; ) {
      for (h2 = e2[c2]; c2 < i2 && (o2 = t2[c2], a2 = (r2 = o2) === null || r2 === void 0 ? void 0 : r2._$litStatic$) !== void 0; )
        h2 += a2 + e2[++c2], u2 = true;
      l2.push(o2), s2.push(h2), c2++;
    }
    return c2 === i2 && s2.push(e2[i2]), u2 && (n2 = s2.join("$$lit$$"), (e2 = stringsCache.get(n2)) === void 0 && stringsCache.set(n2, e2 = s2), t2 = l2), d2(e2, ...t2);
  }, html = withStatic(html$1), decorateProperty = ({ finisher: a2, descriptor: o2 }) => (e2, t2) => {
    if (t2 === void 0) {
      const n2 = (r2 = e2.originalKey) !== null && r2 !== void 0 ? r2 : e2.key, i2 = o2 != null ? { kind: "method", placement: "prototype", key: n2, descriptor: o2(e2.key) } : __spreadProps(__spreadValues({}, e2), { key: n2 });
      return a2 != null && (i2.finisher = function(e3) {
        a2(e3, n2);
      }), i2;
    }
    var r2 = e2.constructor;
    o2 !== void 0 && Object.defineProperty(e2, t2, o2(t2)), a2 != null && a2(r2, t2);
  };
  function queryAsync(t2) {
    return decorateProperty({ descriptor: (e2) => ({ get() {
      return __async(this, null, function* () {
        var e3;
        return yield this.updateComplete, (e3 = this.renderRoot) === null || e3 === void 0 ? void 0 : e3.querySelector(t2);
      });
    }, enumerable: true, configurable: true }) });
  }
  var __isNode = () => typeof process != "undefined" && process.release && process.release.name === "node";
  class SDatePickerComponentInterface extends SInterface {
    static get _definition() {
      var e2, t2;
      return { name: { descrition: "Specify the name for your input name", type: "String", required: true }, value: { description: "Specify the initial value", type: "String" }, placeholder: { description: "Specify a placeholder for your input", type: "String", default: "Select a date" }, format: { description: "Specify the format to use for your datepicker", type: "String", default: (e2 = SSugarConfig.get("datetime.dateFormat")) !== null && e2 !== void 0 ? e2 : "YYYY-MM-DD" }, firstDay: { type: "Number", description: "Specify the first day of the week. 0 is sunday, 1 monday, etc...", default: 1 }, minDate: { type: "String", description: "the minimum/earliest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())" }, maxDate: { type: "String", description: "the maximum/latest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())" }, disableWeekends: { type: "Boolean", description: "disallow selection of Saturdays or Sundays", default: false }, yearRange: { type: { type: "Array<Number>", splitChars: [","] }, description: "number of years either side (e.g. 10) or array of upper/lower range (e.g. [1900,2015])" }, rtl: { type: "Boolean", description: "reverse the calendar for right-to-left languages", default: !__isNode() && ((t2 = document.querySelector("html")) === null || t2 === void 0 ? void 0 : t2.getAttribute("dir")) === "rtl" }, i18n: { type: "String", description: "language defaults for month and weekday names", default: (t2 = SSugarConfig.get("datetime.i18n")) !== null && t2 !== void 0 ? t2 : { previousMonth: "Previous Month", nextMonth: "Next Month", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] } }, numberOfMonths: { type: "Number", description: "number of visible calendars", default: 1 }, events: { type: { type: "Array<String>", splitChars: [","] }, description: "array of dates that you would like to differentiate from regular days (e.g. ['Sat Jun 28 2017', 'Sun Jun 29 2017', 'Tue Jul 01 2017',])", default: [] }, noInput: { description: "Specify if you want a visible input injected if you don't have specified yours.", type: "Boolean", default: false, physical: true }, noButton: { description: "Specify if you want a button attached to your input or not", type: "Boolean", default: false, physical: true }, arrowIcon: { description: "Specify the svg code for the arrow used across the datepicker", type: "String", default: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.122 24l-4.122-4 8-8-8-8 4.122-4 11.878 12z"/></svg>' }, calendarIcon: { description: "Specify the svg code for the calendar icon used in the button", type: "String", default: '<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="calendar-alt" class="svg-inline--fa fa-calendar-alt fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"></path></svg>' } };
    }
  }
  function plainObject$3(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$3(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$3(a2[e4]) && plainObject$3(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  function whenInteract(c2, u2) {
    return new Promise((t2, e2) => {
      function r2(e3) {
        t2(e3), c2.removeEventListener("mouseover", n2), c2.removeEventListener("mouseout", i2), c2.removeEventListener("click", a2), c2.removeEventListener("touchstart", o2), c2.removeEventListener("touchend", s2), c2.removeEventListener("focus", l2), c2.removeEventListener("focusin", l2);
      }
      function n2(e3) {
        r2("mouseover");
      }
      function i2(e3) {
        r2("mouseout");
      }
      function a2(e3) {
        r2("click");
      }
      function o2(e3) {
        r2("touchstart");
      }
      function s2(e3) {
        r2("touchend");
      }
      function l2(e3) {
        r2("focus");
      }
      (u2 = __deepMerge$3({ mouse: { over: true, out: true, click: true }, touch: { start: true, end: true }, focus: true }, u2 != null ? u2 : {})).mouse !== true && !u2.mouse.over || c2.addEventListener("mouseover", n2), u2.mouse !== true && !u2.mouse.out || c2.addEventListener("mouseout", i2), u2.mouse !== true && !u2.mouse.click || c2.addEventListener("click", a2), u2.touch !== true && !u2.touch.start || c2.addEventListener("touchstart", o2), u2.touch !== true && !u2.touch.start || c2.addEventListener("touchend", s2), u2.focus === true && (c2.addEventListener("focus", l2), c2.addEventListener("focusin", l2));
    });
  }
  var __css$4 = "s-date-picker {\n    display: inline-block;\n    position: relative;\n}\n.s-date-picker {\n    display: flex;\n    width: 100%;\n}\n.s-date-picker__input {\n    flex-grow: 1;\n    padding-inline: var(--s-theme-ui-datePicker-paddingInline, 0.75em);\n    padding-block: var(--s-theme-ui-datePicker-paddingBlock, 0.375em);\n}\n.s-date-picker__button {\n    padding-inline: var(--s-theme-ui-datePicker-paddingInline, 0.75em);\n    padding-block: var(--s-theme-ui-datePicker-paddingBlock, 0.375em);\n    cursor: pointer;\n}\n.s-pikaday {\n    top: 100%;\n    left: auto;\n    right: 0;\n    bottom: auto;\n    display: flex;\n}\ns-date-picker[rtl] .s-pikaday {\n    top: 100%;\n    left: 0;\n    right: auto;\n    bottom: auto;\n}\ns-date-picker:not([bare]):not([rtl]):not([no-button]):not([no-input]) .s-date-picker__input {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n        }\ns-date-picker:not([bare]):not([rtl]):not([no-button]):not([no-input]) .s-date-picker__button {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n        }\ns-date-picker:not([bare])[rtl]:not([no-button]):not([no-input]) .s-date-picker__button {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n            order: 0;\n        }\ns-date-picker:not([bare])[rtl]:not([no-button]):not([no-input]) .s-date-picker__input {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n            order: 1;\n        }\n.s-date-picker__button svg {\n        height: 1em;\n    }\n.s-date-picker__button svg,\n        .s-date-picker__button svg > * {\n            box-shadow: 0px 0px 3px 0 hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + -10) * 1%),1);\n        }\n", __themeCss = "/**\n * This theme is an example to show how you can create your own.\n */\n\n.pika-lendar {\n    width: auto;\n}\n\n.pika-single.s-pikaday {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-foreground-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-main-foreground-a, 1));\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-surface-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-main-surface-a, 1));\n    border: 1px solid hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-border-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-border-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-border-lightness-offset, 0)) * 1%),var(--s-theme-color-current-border-a, 1));box-shadow: var(--s-theme-depth-100, 0);\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 10px);\n    padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n    padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n}\n\n.s-pikaday .pika-label {\n    background-color: transparent;\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1));\n    top: -0.5em;\n}\n\n.s-pikaday .pika-prev,\n.s-pikaday .is-rtl .pika-next,\n.s-pikaday .pika-next,\n.s-pikaday .is-rtl .pika-prev {\n    background: none;\n    position: relative;\n    display: inline-block;\n    font-size: 0;\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1));\n    overflow: visible;\n    background: red;\n    opacity: 1;\n    width: 1em;\n    height: 1em;\n    opacity: 0.7;\n}\n\n.s-pikaday .pika-prev:hover,\n    .s-pikaday .pika-prev:focus,\n    .s-pikaday .is-rtl .pika-next:hover,\n    .s-pikaday .is-rtl .pika-next:focus,\n    .s-pikaday .pika-next:hover,\n    .s-pikaday .pika-next:focus,\n    .s-pikaday .is-rtl .pika-prev:hover,\n    .s-pikaday .is-rtl .pika-prev:focus {\n        opacity: 1;\n    }\n\n.s-pikaday .pika-prev:after, .s-pikaday .is-rtl .pika-next:after, .s-pikaday .pika-next:after, .s-pikaday .is-rtl .pika-prev:after {\n        content: '\u276F';\n        color: inherit;\n        font-size: 1rem;\n        position: absolute;\n        top: 0;\n        left: -2.2em;\n    }\n\n.s-pikaday .pika-prev:after, .s-pikaday.is-rtl .pika-next:after {\n        transform: rotate(180deg);\n        left: 1em;\n    }\n\n.s-pikaday.is-rtl .pika-prev:after {\n        transform: rotate(0deg) !important;\n        left: -2em;\n    }\n\n.s-pikaday .pika-table {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 10px);\n    padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n    padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n}\n\n.s-pikaday .pika-table th * {\n    text-decoration: none;\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n}\n\n.s-pikaday .pika-button {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n    padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n}\n\n.s-pikaday .pika-week {\n    text-decoration: none;\n}\n\n.s-pikaday .is-today .pika-button {\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1));\n    outline: none;\n}\n\n.s-pikaday .is-selected .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),0.5);\n    box-shadow: none !important;\n}\n\n.s-pikaday .is-disabled .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));opacity: var(--s-theme-helpers-disabled-opacity, 0.3) !important;\n}\n\n.s-pikaday .is-disabled .pika-button:hover, .s-pikaday .is-disabled .pika-button:focus, .s-pikaday .is-disabled .pika-button:active {\n            opacity: var(--s-theme-helpers-disabled-opacity, 0.3) !important;\n        }\n\n.s-pikaday .is-disabled .pika-button, .s-pikaday .is-disabled .pika-button * {\n            cursor: not-allowed !important;\n            -webkit-user-select: none !important;\n               -moz-user-select: none !important;\n                -ms-user-select: none !important;\n                    user-select: none !important;\n        }\n\n.s-pikaday .pika-button:hover {\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-foreground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-foreground-a, 1)) !important;\n    background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1)) !important;\n}\n", __baseCss = `@charset "UTF-8";

/*!
 * Pikaday
 * Copyright \xA9 2014 David Bushell | BSD & MIT license | https://dbushell.com/
 */

.pika-single {
    z-index: 9999;
    display: block;
    position: relative;
    color: #333;
    background: #fff;
    border: 1px solid #ccc;
    border-bottom-color: #bbb;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

/*
clear child float (pika-lendar), using the famous micro clearfix hack
http://nicolasgallagher.com/micro-clearfix-hack/
*/

.pika-single:before,
.pika-single:after {
    content: " ";
    display: table;
}

.pika-single:after { clear: both }

.pika-single.is-hidden {
    display: none;
}

.pika-single.is-bound {
    position: absolute;
    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);
}

.pika-lendar {
    float: left;
    width: 240px;
    margin: 8px;
}

.pika-title {
    position: relative;
    text-align: center;
}

.pika-label {
    display: inline-block;
    position: relative;
    z-index: 9999;
    overflow: hidden;
    margin: 0;
    padding: 5px 3px;
    font-size: 14px;
    line-height: 20px;
    font-weight: bold;
    background-color: #fff;
}

.pika-title select {
    cursor: pointer;
    position: absolute;
    z-index: 9998;
    margin: 0;
    left: 0;
    top: 5px;
    opacity: 0;
}

.pika-prev,
.pika-next {
    display: block;
    cursor: pointer;
    position: relative;
    outline: none;
    border: 0;
    padding: 0;
    width: 20px;
    height: 30px;
    /* hide text using text-indent trick, using width value (it's enough) */
    text-indent: 20px;
    white-space: nowrap;
    overflow: hidden;
    background-color: transparent;
    background-position: center center;
    background-repeat: no-repeat;
    background-size: 75% 75%;
    opacity: .5;
}

.pika-prev:hover,
.pika-next:hover {
    opacity: 1;
}

.pika-prev,
.is-rtl .pika-next {
    float: left;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');
}

.pika-next,
.is-rtl .pika-prev {
    float: right;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');
}

.pika-prev.is-disabled,
.pika-next.is-disabled {
    cursor: default;
    opacity: .2;
}

.pika-select {
    display: inline-block;
}

.pika-table {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    border: 0;
}

.pika-table th,
.pika-table td {
    width: 14.285714285714286%;
    padding: 0;
}

.pika-table th {
    color: #999;
    font-size: 12px;
    line-height: 25px;
    font-weight: bold;
    text-align: center;
}

.pika-button {
    cursor: pointer;
    display: block;
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    outline: none;
    border: 0;
    margin: 0;
    width: 100%;
    padding: 5px;
    color: #666;
    font-size: 12px;
    line-height: 15px;
    text-align: right;
    background: #f5f5f5;
    height: initial;
}

.pika-week {
    font-size: 11px;
    color: #999;
}

.is-today .pika-button {
    color: #33aaff;
    font-weight: bold;
}

.is-selected .pika-button,
.has-event .pika-button {
    color: #fff;
    font-weight: bold;
    background: #33aaff;
    box-shadow: inset 0 1px 3px #178fe5;
    border-radius: 3px;
}

.has-event .pika-button {
    background: #005da9;
    box-shadow: inset 0 1px 3px #0076c9;
}

.is-disabled .pika-button,
.is-inrange .pika-button {
    background: #D5E9F7;
}

.is-startrange .pika-button {
    color: #fff;
    background: #6CB31D;
    box-shadow: none;
    border-radius: 3px;
}

.is-endrange .pika-button {
    color: #fff;
    background: #33aaff;
    box-shadow: none;
    border-radius: 3px;
}

.is-disabled .pika-button {
    pointer-events: none;
    cursor: default;
    color: #999;
    opacity: .3;
}

.is-outside-current-month .pika-button {
    color: #999;
    opacity: .3;
}

.is-selection-disabled {
    pointer-events: none;
    cursor: default;
}

.pika-button:hover,
.pika-row.pick-whole-week:hover .pika-button {
    color: #fff;
    background: #ff8000;
    box-shadow: none;
    border-radius: 3px;
}

/* styling for abbr */

.pika-table abbr {
    border-bottom: none;
    cursor: help;
}
`, __decorate$2 = globalThis && globalThis.__decorate || function(e2, t2, r2, n2) {
    var i2, a2 = arguments.length, o2 = a2 < 3 ? t2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var s2 = e2.length - 1; 0 <= s2; s2--)
        (i2 = e2[s2]) && (o2 = (a2 < 3 ? i2(o2) : 3 < a2 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return 3 < a2 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }, __awaiter$9 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SDatePicker extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false }, componentUtils: { interface: SDatePickerComponentInterface } });
    }
    static get properties() {
      return SLitComponent.properties({}, SDatePickerComponentInterface);
    }
    static get styles() {
      return r$2`
            ${o$3(`
                ${__baseCss}
                ${__css$4}
                ${__themeCss}
            `)}
        `;
    }
    firstUpdated() {
      return __awaiter$9(this, void 0, void 0, function* () {
        this._$root = this.querySelector("." + this.componentUtils.className("")), this._$input = this.querySelector("input"), this._$input ? this._$input.classList.add(this.componentUtils.className("__input")) : (this._$input = document.createElement("input"), this._$input.setAttribute("type", this.props.noInput ? "hidden" : "text"), this.props.noInput || this._$input.setAttribute("class", this.componentUtils.className("__input", "s-input"))), this._$input.hasAttribute("name") || this._$input.setAttribute("name", this.props.name), this._$input.hasAttribute("placeholder") || this._$input.setAttribute("placeholder", this.props.placeholder), this._$input.hasAttribute("autocomplete") || this._$input.setAttribute("autocomplete", "off"), this.props.rtl && this._$input.setAttribute("rtl", "true"), this._$root.prepend(this._$input);
        let e2;
        this.props.noButton || (e2 = yield this._$button), yield whenInteract(this);
        const r2 = this;
        this._picker = new __pikaday({ field: this._$input, format: this.props.format, trigger: e2, firstDay: this.props.firstDay, minDate: this.parseDate(this.props.minDate), maxDate: this.parseDate(this.props.maxDate), disableWeekends: this.props.disableWeekends, yearRange: this.props.yearRange, container: this, position: this.props.rtl ? "bottom right" : "bottom left", reposition: true, isRTL: this.props.rtl, i18n: this.props.i18n, numberOfMonths: this.props.numberOfMonths, events: this.props.events, defaultDate: this.props.value, theme: this.props.bare ? "" : "s-pikaday", toString(e3, t2) {
          return r2.dateToString(e3, t2);
        }, parse(e3, t2) {
          return r2.parseDate(e3, t2);
        }, onSelect: () => {
          this._dispatchEvent("select");
        }, onOpen: () => {
          this._dispatchEvent("open");
        }, onClose: () => {
          this._dispatchEvent("close");
        }, onDraw: () => {
          this._dispatchEvent("draw");
        } }), Array.from(this.classList).forEach((e3) => {
          e3.match(/^s-cs/) && this._picker.el.classList.add(e3);
        }), ["toString", "getDate", "setDate", "getMoment", "clear", "gotoDate", "gotoToday", "gotoMonth", "nextMonth", "prevMonth", "gotoYear", "setMinDate", "setMaxDate", "setStartRange", "setEndRange", "isVisible", "show", "adjustPosition", "hide", "destroy"].forEach((e3) => {
          this[e3] = this._picker[e3].bind(this._picker);
        });
      });
    }
    parseDate(e2, t2 = this.props.format) {
      return hooks(e2, t2).toDate();
    }
    dateToString(e2, t2 = this.props.format) {
      return hooks(e2).format(t2);
    }
    _dispatchEvent(e2) {
      e2 = new CustomEvent(e2, { detail: { dateStr: this._picker.toString(), date: this._picker.getDate() } });
      this.dispatchEvent(e2);
    }
    render() {
      return p`
            <div class="${this.componentUtils.className("")}">
                <slot></slot>
                ${this.props.noButton ? "" : p`
                          <button
                              onclick="return false"
                              class="${this.componentUtils.className("__button", "s-btn")}"
                          >
                              ${html([this.calendarIcon])}
                          </button>
                      `}
            </div>
        `;
    }
  }
  function define$b(e2 = {}, t2 = "s-date-picker") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SDatePicker);
  }
  __decorate$2([queryAsync("button")], SDatePicker.prototype, "_$button", void 0);
  class SFormValidateFeatureInterface extends SInterface {
    static get _definition() {
      return { type: { description: "Specify the validation type. Usually automatically detected depending on the field type", type: "String", default: "text" }, on: { description: 'Specify when to trigger a validation. Can be "change","submit","enter" and/or "reset"', type: "Array<String>", values: ["change", "submit", "enter", "reset"], default: ["change", "submit", "enter", "reset"] }, wrap: { description: "Specify if you want to wrap your s-form-validate element when theres an error", type: "Boolean", default: true }, errorClass: { description: "Specify the class to apply when theres an error", type: "String", default: "s-form-validate s-form-validate--error s-color--error" }, errorMessageClass: { description: "Specify the class to apply on the injected error message container", type: "String", default: "s-form-validate__error-message" }, validClass: { description: "Specify the class to apply on your s-form-validate element when validation is passed successfully", type: "String", default: "s-form-validate s-form-validate--valid s-color--success" }, customValidations: { description: "Specify some custom validations [key]: function(value, helpers). For mor info check out the [Joi](https://joi.dev/api/?v=17.4.2#anycustommethod-description) custom validation doc", type: "Object", default: {} }, joiOptions: { description: "Specify some [Joi](https://joi.dev/) options to use for your validation", type: "Object", default: {} }, language: { description: "Specify the language you want to use for messages", type: "String", default: "fr" }, displayError: { description: "Specify if you want to display the error messages or not", type: "Boolean", default: true }, alphanum: { type: "Boolean", description: "String: Requires the string value to only contain a-z, A-Z, and 0-9." }, base64: { type: "Boolean", description: "String: Requires the string value to be a valid base64 string; does not check the decoded value." }, case: { type: "String", values: ["upper", "lower"], description: "String: Sets the required string case" }, creditCard: { type: "Boolean", description: "String: Requires the number to be a credit card number (Using Luhn Algorithm)." }, dataUri: { type: "Boolean", description: "String: Requires the string value to be a valid data URI string." }, domain: { type: "Boolean|String", description: "String: Requires the string value to be a valid domain name." }, email: { type: "Boolean|String", description: "String: Requires the string value to be a valid email address." }, guid: { type: "Boolean|String", description: "String: Requires the string value to be a valid GUID." }, hex: { type: "Boolean|String", description: "String: Requires the string value to be a valid hexadecimal string." }, hostname: { type: "Boolean|String", description: "String: Requires the string value to be a valid hostname as per RFC1123." }, insensitive: { type: "Boolean|String", description: "String: Allows the value to match any value in the allowed list or disallowed list in a case insensitive comparison." }, ip: { type: "Boolean|String", description: "String: Requires the string value to be a valid ip address." }, isoDate: { type: "Boolean|String", description: "String: Requires the string value to be in valid ISO 8601 date format." }, isoDuration: { type: "Boolean|String", description: "String: Requires the string value to be in valid ISO 8601 duration format." }, length: { type: "Number", description: "String: Specifies the exact string length required" }, lowercase: { type: "Boolean|String", description: "String: Requires the string value to be all lowercase. If the validation convert option is on (enabled by default), the string will be forced to lowercase." }, max: { type: "Number", description: "String: String: Specifies the maximum number of string characters\nDate: Specifies the latest date allowed\nNumber: Specifies the minimum value" }, min: { type: "Number", description: "String: String: Specifies the minimum number string characters\nDate: Specifies the oldest date allowed\nNumber: Specifies the minimum value" }, normalize: { type: "String", description: "String: Requires the string value to be in a Unicode normalized form. If the validation convert option is on (enabled by default), the string will be normalized." }, pattern: { type: "String", description: "String: a regular expression object the string value must match against. Note that if the pattern is a regular expression, for it to match the entire key name, it must begin with ^ and end with $." }, token: { type: "Boolean", description: "String: Requires the string value to only contain a-z, A-Z, 0-9, and underscore _." }, trim: { type: "Boolean", description: "String: Requires the string value to contain no whitespace before or after. If the validation convert option is on (enabled by default), the string will be trimmed." }, truncate: { type: "Boolean", description: "String: Specifies whether the string.max() limit should be used as a truncation." }, uppercase: { type: "Boolean", description: "String: Requires the string value to be all uppercase. If the validation convert option is on (enabled by default), the string will be forced to uppercase." }, uri: { type: "Boolean|String", description: "String: Requires the string value to be a valid RFC 3986 URI." }, greater: { type: "String", description: "String: Date: Specifies that the value must be greater than date (or a reference)\nNumber: Specifies that the value must be greater than limit or a reference." }, less: { type: "String", description: "String: Date: Specifies that the value must be less than date (or a reference)\nNumber: Specifies that the value must be less than limit or a reference." }, iso: { type: "Boolean", description: "Date: Requires the string value to be in valid ISO 8601 date format." }, timestamp: { type: "Boolean|String", description: "Date: Requires the value to be a timestamp interval from Unix Time" }, integer: { type: "Boolean", description: "Number: Requires the number to be an integer (no floating point)." }, multiple: { type: "Number", description: "Number: Specifies that the value must be a multiple of base (or a reference):" }, negative: { type: "Boolean", description: "Number: Requires the number to be negative" }, port: { type: "Boolean", description: "Number: Requires the number to be a TCP port, so between 0 and 65535." }, positive: { type: "Boolean", description: "Number: Requires the number to be positive" }, precision: { type: "Number", description: "Number: Specifies the maximum number of decimal places" }, unsafe: { type: "Boolean", description: "Number: By default, numbers must be within JavaScript's safety range (Number.MIN_SAFE_INTEGER & Number.MAX_SAFE_INTEGER), and when given a string, should be converted without loss of information. You can allow unsafe numbers at your own risks by calling number.unsafe()." } };
    }
  }
  var joiBrowser_min = { exports: {} }, CMa, DMa;
  self, joiBrowser_min.exports = (CMa = { 1238: (e2) => {
    e2.exports = { version: "17.4.2" };
  }, 7629: (e2, t2, r2) => {
    const l2 = r2(375), o2 = r2(8571), a2 = r2(9474), c2 = r2(1687), n2 = r2(8652), u2 = r2(8160), i2 = r2(3292), s2 = r2(6354), h2 = r2(8901), d2 = r2(9708), p2 = r2(6914), f2 = r2(2294), m2 = r2(6133), g2 = r2(1152), v2 = r2(8863), y = r2(2036), _2 = { Base: class {
      constructor(e3) {
        this.type = e3, this.$_root = null, this._definition = {}, this._reset();
      }
      _reset() {
        this._ids = new f2.Ids(), this._preferences = null, this._refs = new m2.Manager(), this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = new Map(), this.$_terms = {}, this.$_temp = { ruleset: null, whens: {} };
      }
      describe() {
        return l2(typeof d2.describe == "function", "Manifest functionality disabled"), d2.describe(this);
      }
      allow(...e3) {
        return u2.verifyFlat(e3, "allow"), this._values(e3, "_valids");
      }
      alter(e3) {
        l2(e3 && typeof e3 == "object" && !Array.isArray(e3), "Invalid targets argument"), l2(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const t3 = this.clone();
        t3.$_terms.alterations = t3.$_terms.alterations || [];
        for (const n3 in e3) {
          var r3 = e3[n3];
          l2(typeof r3 == "function", "Alteration adjuster for", n3, "must be a function"), t3.$_terms.alterations.push({ target: n3, adjuster: r3 });
        }
        return t3.$_temp.ruleset = false, t3;
      }
      artifact(e3) {
        return l2(e3 !== void 0, "Artifact cannot be undefined"), l2(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", e3);
      }
      cast(e3) {
        return l2(e3 === false || typeof e3 == "string", "Invalid to value"), l2(e3 === false || this._definition.cast[e3], "Type", this.type, "does not support casting to", e3), this.$_setFlag("cast", e3 === false ? void 0 : e3);
      }
      default(e3, t3) {
        return this._default("default", e3, t3);
      }
      description(e3) {
        return l2(e3 && typeof e3 == "string", "Description must be a non-empty string"), this.$_setFlag("description", e3);
      }
      empty(e3) {
        const t3 = this.clone();
        return e3 !== void 0 && (e3 = t3.$_compile(e3, { override: false })), t3.$_setFlag("empty", e3, { clone: false });
      }
      error(e3) {
        return l2(e3, "Missing error"), l2(e3 instanceof Error || typeof e3 == "function", "Must provide a valid Error object or a function"), this.$_setFlag("error", e3);
      }
      example(e3, t3 = {}) {
        return l2(e3 !== void 0, "Missing example"), u2.assertOptions(t3, ["override"]), this._inner("examples", e3, { single: true, override: t3.override });
      }
      external(e3, t3) {
        return typeof e3 == "object" && (l2(!t3, "Cannot combine options with description"), t3 = e3.description, e3 = e3.method), l2(typeof e3 == "function", "Method must be a function"), l2(t3 === void 0 || t3 && typeof t3 == "string", "Description must be a non-empty string"), this._inner("externals", { method: e3, description: t3 }, { single: true });
      }
      failover(e3, t3) {
        return this._default("failover", e3, t3);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(e3) {
        return e3 ? (l2(typeof e3 == "string", "id must be a non-empty string"), l2(/^[^\.]+$/.test(e3), "id cannot contain period character"), this.$_setFlag("id", e3)) : this.$_setFlag("id", void 0);
      }
      invalid(...e3) {
        return this._values(e3, "_invalids");
      }
      label(e3) {
        return l2(e3 && typeof e3 == "string", "Label name must be a non-empty string"), this.$_setFlag("label", e3);
      }
      meta(e3) {
        return l2(e3 !== void 0, "Meta cannot be undefined"), this._inner("metas", e3, { single: true });
      }
      note(...e3) {
        l2(e3.length, "Missing notes");
        for (const t3 of e3)
          l2(t3 && typeof t3 == "string", "Notes must be non-empty strings");
        return this._inner("notes", e3);
      }
      only(e3 = true) {
        return l2(typeof e3 == "boolean", "Invalid mode:", e3), this.$_setFlag("only", e3);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(e3) {
        l2(e3, "Missing preferences"), l2(e3.context === void 0, "Cannot override context"), l2(e3.externals === void 0, "Cannot override externals"), l2(e3.warnings === void 0, "Cannot override warnings"), l2(e3.debug === void 0, "Cannot override debug"), u2.checkPreferences(e3);
        const t3 = this.clone();
        return t3._preferences = u2.preferences(t3._preferences, e3), t3;
      }
      presence(e3) {
        return l2(["optional", "required", "forbidden"].includes(e3), "Unknown presence mode", e3), this.$_setFlag("presence", e3);
      }
      raw(e3 = true) {
        return this.$_setFlag("result", e3 ? "raw" : void 0);
      }
      result(e3) {
        return l2(["raw", "strip"].includes(e3), "Unknown result mode", e3), this.$_setFlag("result", e3);
      }
      required() {
        return this.presence("required");
      }
      strict(e3) {
        const t3 = this.clone(), r3 = e3 !== void 0 && !e3;
        return t3._preferences = u2.preferences(t3._preferences, { convert: r3 }), t3;
      }
      strip(e3 = true) {
        return this.$_setFlag("result", e3 ? "strip" : void 0);
      }
      tag(...e3) {
        l2(e3.length, "Missing tags");
        for (const t3 of e3)
          l2(t3 && typeof t3 == "string", "Tags must be non-empty strings");
        return this._inner("tags", e3);
      }
      unit(e3) {
        return l2(e3 && typeof e3 == "string", "Unit name must be a non-empty string"), this.$_setFlag("unit", e3);
      }
      valid(...e3) {
        u2.verifyFlat(e3, "valid");
        const t3 = this.allow(...e3);
        return t3.$_setFlag("only", !!t3._valids, { clone: false }), t3;
      }
      when(e3, t3) {
        const r3 = this.clone();
        r3.$_terms.whens || (r3.$_terms.whens = []);
        t3 = i2.when(r3, e3, t3);
        if (!["any", "link"].includes(r3.type)) {
          const e4 = t3.is ? [t3] : t3.switch;
          for (const n3 of e4)
            l2(!n3.then || n3.then.type === "any" || n3.then.type === r3.type, "Cannot combine", r3.type, "with", n3.then && n3.then.type), l2(!n3.otherwise || n3.otherwise.type === "any" || n3.otherwise.type === r3.type, "Cannot combine", r3.type, "with", n3.otherwise && n3.otherwise.type);
        }
        return r3.$_terms.whens.push(t3), r3.$_mutateRebuild();
      }
      cache(e3) {
        l2(!this._inRuleset(), "Cannot set caching inside a ruleset"), l2(!this._cache, "Cannot override schema cache"), l2(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const t3 = this.clone();
        return t3._cache = e3 || n2.provider.provision(), t3.$_temp.ruleset = false, t3;
      }
      clone() {
        var e3 = Object.create(Object.getPrototypeOf(this));
        return this._assign(e3);
      }
      concat(e3) {
        l2(u2.isSchema(e3), "Invalid schema object"), l2(this.type === "any" || e3.type === "any" || e3.type === this.type, "Cannot merge type", this.type, "with another type:", e3.type), l2(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), l2(!e3._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let t3 = this.clone();
        if (this.type === "any" && e3.type !== "any") {
          const r3 = e3.clone();
          for (const e4 of Object.keys(t3))
            e4 !== "type" && (r3[e4] = t3[e4]);
          t3 = r3;
        }
        t3._ids.concat(e3._ids), t3._refs.register(e3, m2.toSibling), t3._preferences = t3._preferences ? u2.preferences(t3._preferences, e3._preferences) : e3._preferences, t3._valids = y.merge(t3._valids, e3._valids, e3._invalids), t3._invalids = y.merge(t3._invalids, e3._invalids, e3._valids);
        for (const n3 of e3._singleRules.keys())
          t3._singleRules.has(n3) && (t3._rules = t3._rules.filter((e4) => e4.keep || e4.name !== n3), t3._singleRules.delete(n3));
        for (const i3 of e3._rules)
          e3._definition.rules[i3.method].multi || t3._singleRules.set(i3.name, i3), t3._rules.push(i3);
        if (t3._flags.empty && e3._flags.empty) {
          t3._flags.empty = t3._flags.empty.concat(e3._flags.empty);
          const a3 = Object.assign({}, e3._flags);
          delete a3.empty, c2(t3._flags, a3);
        } else if (e3._flags.empty) {
          t3._flags.empty = e3._flags.empty;
          const o3 = Object.assign({}, e3._flags);
          delete o3.empty, c2(t3._flags, o3);
        } else
          c2(t3._flags, e3._flags);
        for (const s3 in e3.$_terms) {
          const l3 = e3.$_terms[s3];
          l3 ? t3.$_terms[s3] ? t3.$_terms[s3] = t3.$_terms[s3].concat(l3) : t3.$_terms[s3] = l3.slice() : t3.$_terms[s3] || (t3.$_terms[s3] = l3);
        }
        return this.$_root._tracer && this.$_root._tracer._combine(t3, [this, e3]), t3.$_mutateRebuild();
      }
      extend(e3) {
        return l2(!e3.base, "Cannot extend type with another base"), h2.type(this, e3);
      }
      extract(e3) {
        return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.reach(e3);
      }
      fork(e3, t3) {
        l2(!this._inRuleset(), "Cannot fork inside a ruleset");
        let r3 = this;
        for (var n3 of [].concat(e3))
          n3 = Array.isArray(n3) ? n3 : n3.split("."), r3 = r3._ids.fork(n3, t3, r3);
        return r3.$_temp.ruleset = false, r3;
      }
      rule(t3) {
        const r3 = this._definition;
        u2.assertOptions(t3, Object.keys(r3.modifiers)), l2(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const n3 = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        l2(0 <= n3 && n3 < this._rules.length, "Cannot apply rules to empty ruleset");
        const i3 = this.clone();
        for (let e3 = n3; e3 < i3._rules.length; ++e3) {
          const n4 = i3._rules[e3], a3 = o2(n4);
          for (const o3 in t3)
            r3.modifiers[o3](a3, t3[o3]), l2(a3.name === n4.name, "Cannot change rule name");
          i3._rules[e3] = a3, i3._singleRules.get(a3.name) === n4 && i3._singleRules.set(a3.name, a3);
        }
        return i3.$_temp.ruleset = false, i3.$_mutateRebuild();
      }
      get ruleset() {
        l2(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const e3 = this.clone();
        return e3.$_temp.ruleset = e3._rules.length, e3;
      }
      get $() {
        return this.ruleset;
      }
      tailor(t3) {
        t3 = [].concat(t3), l2(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let e3 = this;
        if (this.$_terms.alterations)
          for (var { target: r3, adjuster: n3 } of this.$_terms.alterations)
            t3.includes(r3) && (e3 = n3(e3), l2(u2.isSchema(e3), "Alteration adjuster for", r3, "failed to return a schema object"));
        return e3 = e3.$_modify({ each: (e4) => e4.tailor(t3), ref: false }), e3.$_temp.ruleset = false, e3.$_mutateRebuild();
      }
      tracer() {
        return g2.location ? g2.location(this) : this;
      }
      validate(e3, t3) {
        return v2.entry(e3, this, t3);
      }
      validateAsync(e3, t3) {
        return v2.entryAsync(e3, this, t3);
      }
      $_addRule(t3) {
        typeof t3 == "string" && (t3 = { name: t3 }), l2(t3 && typeof t3 == "object", "Invalid options"), l2(t3.name && typeof t3.name == "string", "Invalid rule name");
        for (const r4 in t3)
          l2(r4[0] !== "_", "Cannot set private rule properties");
        const r3 = Object.assign({}, t3);
        r3._resolve = [], r3.method = r3.method || r3.name;
        const n3 = this._definition.rules[r3.method], i3 = r3.args;
        l2(n3, "Unknown rule", r3.method);
        const a3 = this.clone();
        if (i3) {
          l2(Object.keys(i3).length === 1 || Object.keys(i3).length === this._definition.rules[r3.name].args.length, "Invalid rule definition for", this.type, r3.name);
          for (const t4 in i3) {
            let e3 = i3[t4];
            if (e3 !== void 0) {
              if (n3.argsByName) {
                const o3 = n3.argsByName.get(t4);
                if (o3.ref && u2.isResolvable(e3))
                  r3._resolve.push(t4), a3.$_mutateRegister(e3);
                else if (o3.normalize && (e3 = o3.normalize(e3), i3[t4] = e3), o3.assert) {
                  const r4 = u2.validateArg(e3, t4, o3);
                  l2(!r4, r4, "or reference");
                }
              }
              i3[t4] = e3;
            } else
              delete i3[t4];
          }
        }
        return n3.multi || (a3._ruleRemove(r3.name, { clone: false }), a3._singleRules.set(r3.name, r3)), a3.$_temp.ruleset === false && (a3.$_temp.ruleset = null), n3.priority ? a3._rules.unshift(r3) : a3._rules.push(r3), a3;
      }
      $_compile(e3, t3) {
        return i2.schema(this.$_root, e3, t3);
      }
      $_createError(e3, t3, r3, n3, i3, a3 = {}) {
        var o3 = a3.flags !== false ? this._flags : {}, a3 = a3.messages ? p2.merge(this._definition.messages, a3.messages) : this._definition.messages;
        return new s2.Report(e3, t3, r3, o3, a3, n3, i3);
      }
      $_getFlag(e3) {
        return this._flags[e3];
      }
      $_getRule(e3) {
        return this._singleRules.get(e3);
      }
      $_mapLabels(e3) {
        return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.labels(e3);
      }
      $_match(e3, t3, r3, n3) {
        (r3 = Object.assign({}, r3)).abortEarly = true, r3._externals = false, t3.snapshot();
        n3 = !v2.validate(e3, this, t3, r3, n3).errors;
        return t3.restore(), n3;
      }
      $_modify(e3) {
        return u2.assertOptions(e3, ["each", "once", "ref", "schema"]), f2.schema(this, e3) || this;
      }
      $_mutateRebuild() {
        return l2(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({ each: (e3, { source: t3, name: r3, key: n3 }) => {
          r3 = this._definition[t3][r3] && this._definition[t3][r3].register;
          r3 !== false && this.$_mutateRegister(e3, { family: r3, key: n3 });
        } }), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = false, this;
      }
      $_mutateRegister(e3, { family: t3, key: r3 } = {}) {
        this._refs.register(e3, t3), this._ids.register(e3, { key: r3 });
      }
      $_property(e3) {
        return this._definition.properties[e3];
      }
      $_reach(e3) {
        return this._ids.reach(e3);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(e3, t3, r3 = {}) {
        l2(e3[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        var n3 = this._definition.flags[e3] || {};
        if (a2(t3, n3.default) && (t3 = void 0), a2(t3, this._flags[e3]))
          return this;
        const i3 = r3.clone !== false ? this.clone() : this;
        return t3 !== void 0 ? (i3._flags[e3] = t3, i3.$_mutateRegister(t3)) : delete i3._flags[e3], e3[0] !== "_" && (i3.$_temp.ruleset = false), i3;
      }
      $_parent(e3, ...t3) {
        return this[e3][u2.symbols.parent].call(this, ...t3);
      }
      $_validate(e3, t3, r3) {
        return v2.validate(e3, this, t3, r3);
      }
      _assign(e3) {
        e3.type = this.type, e3.$_root = this.$_root, e3.$_temp = Object.assign({}, this.$_temp), e3.$_temp.whens = {}, e3._ids = this._ids.clone(), e3._preferences = this._preferences, e3._valids = this._valids && this._valids.clone(), e3._invalids = this._invalids && this._invalids.clone(), e3._rules = this._rules.slice(), e3._singleRules = o2(this._singleRules, { shallow: true }), e3._refs = this._refs.clone(), e3._flags = Object.assign({}, this._flags), e3._cache = null, e3.$_terms = {};
        for (const t3 in this.$_terms)
          e3.$_terms[t3] = this.$_terms[t3] ? this.$_terms[t3].slice() : null;
        e3.$_super = {};
        for (const r3 in this.$_super)
          e3.$_super[r3] = this._super[r3].bind(e3);
        return e3;
      }
      _bare() {
        const e3 = this.clone();
        e3._reset();
        var t3 = e3._definition.terms;
        for (const n3 in t3) {
          var r3 = t3[n3];
          e3.$_terms[n3] = r3.init;
        }
        return e3.$_mutateRebuild();
      }
      _default(e3, t3, r3 = {}) {
        return u2.assertOptions(r3, "literal"), l2(t3 !== void 0, "Missing", e3, "value"), l2(typeof t3 == "function" || !r3.literal, "Only function value supports literal option"), typeof t3 == "function" && r3.literal && (t3 = { [u2.symbols.literal]: true, literal: t3 }), this.$_setFlag(e3, t3);
      }
      _generate(r3, n3, i3) {
        if (!this.$_terms.whens)
          return { schema: this };
        const a3 = [], o3 = [];
        for (let t3 = 0; t3 < this.$_terms.whens.length; ++t3) {
          const u4 = this.$_terms.whens[t3];
          if (u4.concat)
            a3.push(u4.concat), o3.push("".concat(t3, ".concat"));
          else {
            var s3 = u4.ref ? u4.ref.resolve(r3, n3, i3) : r3, l3 = u4.is ? [u4] : u4.switch, e3 = o3.length;
            for (let e4 = 0; e4 < l3.length; ++e4) {
              const { is: h3, then: d3, otherwise: p3 } = l3[e4], f3 = "".concat(t3).concat(u4.switch ? "." + e4 : "");
              if (h3.$_match(s3, n3.nest(h3, "".concat(f3, ".is")), i3)) {
                if (d3) {
                  const c4 = n3.localize([...n3.path, "".concat(f3, ".then")], n3.ancestors, n3.schemas), { schema: u5, id: m3 } = d3._generate(r3, c4, i3);
                  a3.push(u5), o3.push("".concat(f3, ".then").concat(m3 ? "(".concat(m3, ")") : ""));
                  break;
                }
              } else if (p3) {
                const c4 = n3.localize([...n3.path, "".concat(f3, ".otherwise")], n3.ancestors, n3.schemas), { schema: u5, id: g3 } = p3._generate(r3, c4, i3);
                a3.push(u5), o3.push("".concat(f3, ".otherwise").concat(g3 ? "(".concat(g3, ")") : ""));
                break;
              }
            }
            if (u4.break && o3.length > e3)
              break;
          }
        }
        const c3 = o3.join(", ");
        if (n3.mainstay.tracer.debug(n3, "rule", "when", c3), !c3)
          return { schema: this };
        if (!n3.mainstay.tracer.active && this.$_temp.whens[c3])
          return { schema: this.$_temp.whens[c3], id: c3 };
        let u3 = this;
        this._definition.generate && (u3 = this._definition.generate(this, r3, n3, i3));
        for (const r4 of a3)
          u3 = u3.concat(r4);
        return this.$_root._tracer && this.$_root._tracer._combine(u3, [this, ...a3]), this.$_temp.whens[c3] = u3, { schema: u3, id: c3 };
      }
      _inner(e3, t3, r3 = {}) {
        l2(!this._inRuleset(), "Cannot set ".concat(e3, " inside a ruleset"));
        const n3 = this.clone();
        return n3.$_terms[e3] && !r3.override || (n3.$_terms[e3] = []), r3.single ? n3.$_terms[e3].push(t3) : n3.$_terms[e3].push(...t3), n3.$_temp.ruleset = false, n3;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(t3, e3 = {}) {
        if (!this._singleRules.has(t3))
          return this;
        const r3 = e3.clone !== false ? this.clone() : this;
        r3._singleRules.delete(t3);
        const n3 = [];
        for (let e4 = 0; e4 < r3._rules.length; ++e4) {
          var i3 = r3._rules[e4];
          i3.name !== t3 || i3.keep ? n3.push(i3) : r3._inRuleset() && e4 < r3.$_temp.ruleset && --r3.$_temp.ruleset;
        }
        return r3._rules = n3, r3;
      }
      _values(e3, t3) {
        u2.verifyFlat(e3, t3.slice(1, -1));
        const r3 = this.clone(), n3 = e3[0] === u2.symbols.override;
        if (n3 && (e3 = e3.slice(1)), !r3[t3] && e3.length ? r3[t3] = new y() : n3 && (r3[t3] = e3.length ? new y() : null, r3.$_mutateRebuild()), !r3[t3])
          return r3;
        n3 && r3[t3].override();
        for (const n4 of e3) {
          l2(n4 !== void 0, "Cannot call allow/valid/invalid with undefined"), l2(n4 !== u2.symbols.override, "Override must be the first value");
          const e4 = t3 === "_invalids" ? "_valids" : "_invalids";
          r3[e4] && (r3[e4].remove(n4), r3[e4].length || (l2(t3 === "_valids" || !r3._flags.only, "Setting invalid value", n4, "leaves schema rejecting all values due to previous valid rule"), r3[e4] = null)), r3[t3].add(n4, r3._refs);
        }
        return r3;
      }
    } };
    _2.Base.prototype[u2.symbols.any] = { version: u2.version, compile: i2.compile, root: "$_root" }, _2.Base.prototype.isImmutable = true, _2.Base.prototype.deny = _2.Base.prototype.invalid, _2.Base.prototype.disallow = _2.Base.prototype.invalid, _2.Base.prototype.equal = _2.Base.prototype.valid, _2.Base.prototype.exist = _2.Base.prototype.required, _2.Base.prototype.not = _2.Base.prototype.invalid, _2.Base.prototype.options = _2.Base.prototype.prefs, _2.Base.prototype.preferences = _2.Base.prototype.prefs, e2.exports = new _2.Base();
  }, 8652: (e2, t2, r2) => {
    const n2 = r2(375), i2 = r2(8571), a2 = r2(8160), o2 = { max: 1e3, supported: new Set(["undefined", "boolean", "number", "string"]) };
    t2.provider = { provision: (e3) => new o2.Cache(e3) }, o2.Cache = class {
      constructor(e3 = {}) {
        a2.assertOptions(e3, ["max"]), n2(e3.max === void 0 || e3.max && 0 < e3.max && isFinite(e3.max), "Invalid max cache size"), this._max = e3.max || o2.max, this._map = new Map(), this._list = new o2.List();
      }
      get length() {
        return this._map.size;
      }
      set(t3, r3) {
        if (t3 === null || o2.supported.has(typeof t3)) {
          let e3 = this._map.get(t3);
          if (e3)
            return e3.value = r3, void this._list.first(e3);
          e3 = this._list.unshift({ key: t3, value: r3 }), this._map.set(t3, e3), this._compact();
        }
      }
      get(e3) {
        e3 = this._map.get(e3);
        if (e3)
          return this._list.first(e3), i2(e3.value);
      }
      _compact() {
        var e3;
        this._map.size > this._max && (e3 = this._list.pop(), this._map.delete(e3.key));
      }
    }, o2.List = class {
      constructor() {
        this.tail = null, this.head = null;
      }
      unshift(e3) {
        return e3.next = null, e3.prev = this.head, this.head && (this.head.next = e3), this.head = e3, this.tail || (this.tail = e3), e3;
      }
      first(e3) {
        e3 !== this.head && (this._remove(e3), this.unshift(e3));
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(e3) {
        const { next: t3, prev: r3 } = e3;
        return t3.prev = r3, r3 && (r3.next = t3), e3 === this.tail && (this.tail = t3), e3.prev = null, e3.next = null, e3;
      }
    };
  }, 8160: (e2, i2, n2) => {
    const a2 = n2(375), t2 = n2(7916), r2 = n2(1238);
    let o2, s2;
    const l2 = { isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/ };
    i2.version = r2.version, i2.defaults = { abortEarly: true, allowUnknown: false, artifacts: false, cache: true, context: null, convert: true, dateFormat: "iso", errors: { escapeHtml: false, label: "path", language: null, render: true, stack: false, wrap: { label: '"', array: "[]" } }, externals: true, messages: {}, nonEnumerables: false, noDefaults: false, presence: "optional", skipFunctions: false, stripUnknown: false, warnings: false }, i2.symbols = { any: Symbol.for("@hapi/joi/schema"), arraySingle: Symbol("arraySingle"), deepDefault: Symbol("deepDefault"), errors: Symbol("errors"), literal: Symbol("literal"), override: Symbol("override"), parent: Symbol("parent"), prefs: Symbol("prefs"), ref: Symbol("ref"), template: Symbol("template"), values: Symbol("values") }, i2.assertOptions = function(e3, t3, r3 = "Options") {
      a2(e3 && typeof e3 == "object" && !Array.isArray(e3), "Options must be of type object");
      e3 = Object.keys(e3).filter((e4) => !t3.includes(e4));
      a2(e3.length === 0, "".concat(r3, " contain unknown keys: ").concat(e3));
    }, i2.checkPreferences = function(e3) {
      s2 = s2 || n2(3378);
      e3 = s2.preferences.validate(e3);
      if (e3.error)
        throw new t2([e3.error.details[0].message]);
    }, i2.compare = function(e3, t3, r3) {
      switch (r3) {
        case "=":
          return e3 === t3;
        case ">":
          return t3 < e3;
        case "<":
          return e3 < t3;
        case ">=":
          return t3 <= e3;
        case "<=":
          return e3 <= t3;
      }
    }, i2.default = function(e3, t3) {
      return e3 === void 0 ? t3 : e3;
    }, i2.isIsoDate = function(e3) {
      return l2.isoDate.test(e3);
    }, i2.isNumber = function(e3) {
      return typeof e3 == "number" && !isNaN(e3);
    }, i2.isResolvable = function(e3) {
      return !!e3 && (e3[i2.symbols.ref] || e3[i2.symbols.template]);
    }, i2.isSchema = function(e3, t3 = {}) {
      e3 = e3 && e3[i2.symbols.any];
      return !!e3 && (a2(t3.legacy || e3.version === i2.version, "Cannot mix different versions of joi schemas"), true);
    }, i2.isValues = function(e3) {
      return e3[i2.symbols.values];
    }, i2.limit = function(e3) {
      return Number.isSafeInteger(e3) && 0 <= e3;
    }, i2.preferences = function(e3, t3) {
      o2 = o2 || n2(6914), e3 = e3 || {}, t3 = t3 || {};
      const r3 = Object.assign({}, e3, t3);
      return t3.errors && e3.errors && (r3.errors = Object.assign({}, e3.errors, t3.errors), r3.errors.wrap = Object.assign({}, e3.errors.wrap, t3.errors.wrap)), t3.messages && (r3.messages = o2.compile(t3.messages, e3.messages)), delete r3[i2.symbols.prefs], r3;
    }, i2.tryWithPath = function(e3, t3, r3 = {}) {
      try {
        return e3();
      } catch (e4) {
        throw e4.path !== void 0 ? e4.path = t3 + "." + e4.path : e4.path = t3, r3.append && (e4.message = "".concat(e4.message, " (").concat(e4.path, ")")), e4;
      }
    }, i2.validateArg = function(e3, t3, { assert: r3, message: n3 }) {
      if (i2.isSchema(r3)) {
        const i3 = r3.validate(e3);
        return i3.error ? i3.error.message : void 0;
      }
      if (!r3(e3))
        return t3 ? "".concat(t3, " ").concat(n3) : n3;
    }, i2.verifyFlat = function(e3, t3) {
      for (const r3 of e3)
        a2(!Array.isArray(r3), "Method no longer accepts array arguments:", t3);
    };
  }, 3292: (e2, o2, t2) => {
    const s2 = t2(375), l2 = t2(8160), c2 = t2(6133), u2 = {};
    o2.schema = function(e3, t3, r2 = {}) {
      l2.assertOptions(r2, ["appendPath", "override"]);
      try {
        return u2.schema(e3, t3, r2);
      } catch (e4) {
        throw r2.appendPath && e4.path !== void 0 && (e4.message = "".concat(e4.message, " (").concat(e4.path, ")")), e4;
      }
    }, u2.schema = function(r2, e3, n2) {
      s2(e3 !== void 0, "Invalid undefined schema"), Array.isArray(e3) && (s2(e3.length, "Invalid empty array schema"), e3.length === 1 && (e3 = e3[0]));
      var t3 = (e4, ...t4) => n2.override !== false ? e4.valid(r2.override, ...t4) : e4.valid(...t4);
      if (u2.simple(e3))
        return t3(r2, e3);
      if (typeof e3 == "function")
        return r2.custom(e3);
      if (s2(typeof e3 == "object", "Invalid schema content:", typeof e3), l2.isResolvable(e3))
        return t3(r2, e3);
      if (l2.isSchema(e3))
        return e3;
      if (Array.isArray(e3)) {
        for (const n3 of e3)
          if (!u2.simple(n3))
            return r2.alternatives().try(...e3);
        return t3(r2, ...e3);
      }
      return e3 instanceof RegExp ? r2.string().regex(e3) : e3 instanceof Date ? t3(r2.date(), e3) : (s2(Object.getPrototypeOf(e3) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), r2.object().keys(e3));
    }, o2.ref = function(e3, t3) {
      return c2.isRef(e3) ? e3 : c2.create(e3, t3);
    }, o2.compile = function(e3, t3, r2 = {}) {
      l2.assertOptions(r2, ["legacy"]);
      var n2 = t3 && t3[l2.symbols.any];
      if (n2)
        return s2(r2.legacy || n2.version === l2.version, "Cannot mix different versions of joi schemas:", n2.version, l2.version), t3;
      if (typeof t3 != "object" || !r2.legacy)
        return o2.schema(e3, t3, { appendPath: true });
      const i2 = u2.walk(t3);
      return i2 ? i2.compile(i2.root, t3) : o2.schema(e3, t3, { appendPath: true });
    }, u2.walk = function(e3) {
      if (typeof e3 != "object")
        return null;
      if (Array.isArray(e3)) {
        for (const t4 of e3) {
          const e4 = u2.walk(t4);
          if (e4)
            return e4;
        }
        return null;
      }
      const t3 = e3[l2.symbols.any];
      if (t3)
        return { root: e3[t3.root], compile: t3.compile };
      s2(Object.getPrototypeOf(e3) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const t4 in e3) {
        var r2 = u2.walk(e3[t4]);
        if (r2)
          return r2;
      }
      return null;
    }, u2.simple = function(e3) {
      return e3 === null || ["boolean", "string", "number"].includes(typeof e3);
    }, o2.when = function(r2, n2, i2) {
      if (i2 === void 0 && (s2(n2 && typeof n2 == "object", "Missing options"), i2 = n2, n2 = c2.create(".")), Array.isArray(i2) && (i2 = { switch: i2 }), l2.assertOptions(i2, ["is", "not", "then", "otherwise", "switch", "break"]), l2.isSchema(n2))
        return s2(i2.is === void 0, '"is" can not be used with a schema condition'), s2(i2.not === void 0, '"not" can not be used with a schema condition'), s2(i2.switch === void 0, '"switch" can not be used with a schema condition'), u2.condition(r2, { is: n2, then: i2.then, otherwise: i2.otherwise, break: i2.break });
      if (s2(c2.isRef(n2) || typeof n2 == "string", "Invalid condition:", n2), s2(i2.not === void 0 || i2.is === void 0, 'Cannot combine "is" with "not"'), i2.switch === void 0) {
        let e3 = i2;
        i2.not !== void 0 && (e3 = { is: i2.not, then: i2.otherwise, otherwise: i2.then, break: i2.break });
        let t4 = e3.is !== void 0 ? r2.$_compile(e3.is) : r2.$_root.invalid(null, false, 0, "").required();
        return s2(e3.then !== void 0 || e3.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"'), s2(e3.break === void 0 || e3.then === void 0 || e3.otherwise === void 0, "Cannot specify then, otherwise, and break all together"), i2.is === void 0 || c2.isRef(i2.is) || l2.isSchema(i2.is) || (t4 = t4.required()), u2.condition(r2, { ref: o2.ref(n2), is: t4, then: e3.then, otherwise: e3.otherwise, break: e3.break });
      }
      s2(Array.isArray(i2.switch), '"switch" must be an array'), s2(i2.is === void 0, 'Cannot combine "switch" with "is"'), s2(i2.not === void 0, 'Cannot combine "switch" with "not"'), s2(i2.then === void 0, 'Cannot combine "switch" with "then"');
      const t3 = { ref: o2.ref(n2), switch: [], break: i2.break };
      for (let e3 = 0; e3 < i2.switch.length; ++e3) {
        const n3 = i2.switch[e3], u3 = e3 === i2.switch.length - 1;
        l2.assertOptions(n3, u3 ? ["is", "then", "otherwise"] : ["is", "then"]), s2(n3.is !== void 0, 'Switch statement missing "is"'), s2(n3.then !== void 0, 'Switch statement missing "then"');
        const a2 = { is: r2.$_compile(n3.is), then: r2.$_compile(n3.then) };
        if (c2.isRef(n3.is) || l2.isSchema(n3.is) || (a2.is = a2.is.required()), u3) {
          s2(i2.otherwise === void 0 || n3.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const o3 = (i2.otherwise !== void 0 ? i2 : n3).otherwise;
          o3 !== void 0 && (s2(t3.break === void 0, "Cannot specify both otherwise and break"), a2.otherwise = r2.$_compile(o3));
        }
        t3.switch.push(a2);
      }
      return t3;
    }, u2.condition = function(e3, t3) {
      for (const r2 of ["then", "otherwise"])
        t3[r2] === void 0 ? delete t3[r2] : t3[r2] = e3.$_compile(t3[r2]);
      return t3;
    };
  }, 6354: (e2, s2, t2) => {
    const r2 = t2(5688), o2 = t2(8160), l2 = t2(3328);
    s2.Report = class {
      constructor(e3, t3, r3, n2, i2, a2, o3) {
        if (this.code = e3, this.flags = n2, this.messages = i2, this.path = a2.path, this.prefs = o3, this.state = a2, this.value = t3, this.message = null, this.template = null, this.local = r3 || {}, this.local.label = s2.label(this.flags, this.state, this.prefs, this.messages), this.value === void 0 || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
          const e4 = this.path[this.path.length - 1];
          typeof e4 != "object" && (this.local.key = e4);
        }
      }
      _setTemplate(e3) {
        if (this.template = e3, !this.flags.label && this.path.length === 0) {
          const e4 = this._template(this.template, "root");
          e4 && (this.local.label = e4);
        }
      }
      toString() {
        if (this.message)
          return this.message;
        var e3 = this.code;
        if (!this.prefs.errors.render)
          return this.code;
        const t3 = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        return t3 === void 0 ? 'Error code "'.concat(e3, '" is not defined, your custom type is missing the correct messages definition') : (this.message = t3.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] }), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message);
      }
      _template(e3, t3) {
        return s2.template(this.value, e3, t3 || this.code, this.state, this.prefs);
      }
    }, s2.path = function(e3) {
      let t3 = "";
      for (const r3 of e3)
        typeof r3 != "object" && (typeof r3 == "string" ? (t3 && (t3 += "."), t3 += r3) : t3 += "[".concat(r3, "]"));
      return t3;
    }, s2.template = function(t3, r3, n2, i2, a2) {
      if (r3) {
        if (l2.isTemplate(r3))
          return n2 !== "root" ? r3 : null;
        let e3 = a2.errors.language;
        return o2.isResolvable(e3) && (e3 = e3.resolve(t3, i2, a2)), (e3 && r3[e3] && r3[e3][n2] !== void 0 ? r3[e3] : r3)[n2];
      }
    }, s2.label = function(e3, t3, r3, n2) {
      if (e3.label)
        return e3.label;
      if (!r3.errors.label)
        return "";
      let i2 = t3.path;
      return r3.errors.label === "key" && 1 < t3.path.length && (i2 = t3.path.slice(-1)), s2.path(i2) || s2.template(null, r3.messages, "root", t3, r3) || n2 && s2.template(null, n2, "root", t3, r3) || "value";
    }, s2.process = function(e3, t3, r3) {
      if (!e3)
        return null;
      var { override: n2, message: i2, details: e3 } = s2.details(e3);
      if (n2)
        return n2;
      if (r3.errors.stack)
        return new s2.ValidationError(i2, e3, t3);
      r3 = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      t3 = new s2.ValidationError(i2, e3, t3);
      return Error.stackTraceLimit = r3, t3;
    }, s2.details = function(e3, t3 = {}) {
      let r3 = [];
      const n2 = [];
      for (const i2 of e3)
        if (i2 instanceof Error) {
          if (t3.override !== false)
            return { override: i2 };
          const e4 = i2.toString();
          r3.push(e4), n2.push({ message: e4, type: "override", context: { error: i2 } });
        } else {
          const e4 = i2.toString();
          r3.push(e4), n2.push({ message: e4, path: i2.path.filter((e5) => typeof e5 != "object"), type: i2.code, context: i2.local });
        }
      return 1 < r3.length && (r3 = [...new Set(r3)]), { message: r3.join(". "), details: n2 };
    }, s2.ValidationError = class extends Error {
      constructor(e3, t3, r3) {
        super(e3), this._original = r3, this.details = t3;
      }
      static isError(e3) {
        return e3 instanceof s2.ValidationError;
      }
    }, s2.ValidationError.prototype.isJoi = true, s2.ValidationError.prototype.name = "ValidationError", s2.ValidationError.prototype.annotate = r2.error;
  }, 8901: (e2, t2, r2) => {
    const h2 = r2(375), d2 = r2(8571), p2 = r2(8160), f2 = r2(6914), m2 = {};
    t2.type = function(t3, e3) {
      const r3 = Object.getPrototypeOf(t3), n2 = d2(r3), i2 = t3._assign(Object.create(n2)), a2 = Object.assign({}, e3);
      delete a2.base, n2._definition = a2;
      e3 = r3._definition || {};
      a2.messages = f2.merge(e3.messages, a2.messages), a2.properties = Object.assign({}, e3.properties, a2.properties), i2.type = a2.type, a2.flags = Object.assign({}, e3.flags, a2.flags);
      const o2 = Object.assign({}, e3.terms);
      if (a2.terms)
        for (const t4 in a2.terms) {
          const u2 = a2.terms[t4];
          h2(i2.$_terms[t4] === void 0, "Invalid term override for", a2.type, t4), i2.$_terms[t4] = u2.init, o2[t4] = u2;
        }
      a2.terms = o2, a2.args || (a2.args = e3.args), a2.prepare = m2.prepare(a2.prepare, e3.prepare), a2.coerce && (typeof a2.coerce == "function" && (a2.coerce = { method: a2.coerce }), a2.coerce.from && !Array.isArray(a2.coerce.from) && (a2.coerce = { method: a2.coerce.method, from: [].concat(a2.coerce.from) })), a2.coerce = m2.coerce(a2.coerce, e3.coerce), a2.validate = m2.validate(a2.validate, e3.validate);
      const s2 = Object.assign({}, e3.rules);
      if (a2.rules)
        for (const t4 in a2.rules) {
          const u2 = a2.rules[t4];
          h2(typeof u2 == "object", "Invalid rule definition for", a2.type, t4);
          let e4 = u2.method;
          if (e4 === void 0 && (e4 = function() {
            return this.$_addRule(t4);
          }), e4 && (h2(!n2[t4], "Rule conflict in", a2.type, t4), n2[t4] = e4), h2(!s2[t4], "Rule conflict in", a2.type, t4), s2[t4] = u2, u2.alias) {
            const t5 = [].concat(u2.alias);
            for (const r4 of t5)
              n2[r4] = u2.method;
          }
          u2.args && (u2.argsByName = new Map(), u2.args = u2.args.map((e5) => (typeof e5 == "string" && (e5 = { name: e5 }), h2(!u2.argsByName.has(e5.name), "Duplicated argument name", e5.name), p2.isSchema(e5.assert) && (e5.assert = e5.assert.strict().label(e5.name)), u2.argsByName.set(e5.name, e5), e5)));
        }
      a2.rules = s2;
      const l2 = Object.assign({}, e3.modifiers);
      if (a2.modifiers)
        for (const t4 in a2.modifiers) {
          h2(!n2[t4], "Rule conflict in", a2.type, t4);
          const u2 = a2.modifiers[t4];
          h2(typeof u2 == "function", "Invalid modifier definition for", a2.type, t4);
          const r4 = function(e4) {
            return this.rule({ [t4]: e4 });
          };
          n2[t4] = r4, l2[t4] = u2;
        }
      if (a2.modifiers = l2, a2.overrides) {
        n2._super = r3, i2.$_super = {};
        for (const t4 in a2.overrides)
          h2(r3[t4], "Cannot override missing", t4), a2.overrides[t4][p2.symbols.parent] = r3[t4], i2.$_super[t4] = r3[t4].bind(i2);
        Object.assign(n2, a2.overrides);
      }
      a2.cast = Object.assign({}, e3.cast, a2.cast);
      const c2 = Object.assign({}, e3.manifest, a2.manifest);
      return c2.build = m2.build(a2.manifest && a2.manifest.build, e3.manifest && e3.manifest.build), a2.manifest = c2, a2.rebuild = m2.rebuild(a2.rebuild, e3.rebuild), i2;
    }, m2.build = function(r3, n2) {
      return r3 && n2 ? function(e3, t3) {
        return n2(r3(e3, t3), t3);
      } : r3 || n2;
    }, m2.coerce = function(n2, i2) {
      return n2 && i2 ? { from: n2.from && i2.from ? [...new Set([...n2.from, ...i2.from])] : null, method(e3, t3) {
        let r3;
        if ((!i2.from || i2.from.includes(typeof e3)) && (r3 = i2.method(e3, t3), r3)) {
          if (r3.errors || r3.value === void 0)
            return r3;
          e3 = r3.value;
        }
        if (!n2.from || n2.from.includes(typeof e3)) {
          const i3 = n2.method(e3, t3);
          if (i3)
            return i3;
        }
        return r3;
      } } : n2 || i2;
    }, m2.prepare = function(n2, i2) {
      return n2 && i2 ? function(e3, t3) {
        var r3 = n2(e3, t3);
        if (r3) {
          if (r3.errors || r3.value === void 0)
            return r3;
          e3 = r3.value;
        }
        return i2(e3, t3) || r3;
      } : n2 || i2;
    }, m2.rebuild = function(t3, r3) {
      return t3 && r3 ? function(e3) {
        r3(e3), t3(e3);
      } : t3 || r3;
    }, m2.validate = function(n2, i2) {
      return n2 && i2 ? function(e3, t3) {
        var r3 = i2(e3, t3);
        if (r3) {
          if (r3.errors && (!Array.isArray(r3.errors) || r3.errors.length))
            return r3;
          e3 = r3.value;
        }
        return n2(e3, t3) || r3;
      } : n2 || i2;
    };
  }, 5107: (e2, t2, i2) => {
    const a2 = i2(375), o2 = i2(8571), r2 = i2(8652), s2 = i2(8160), n2 = i2(3292), l2 = i2(6354), c2 = i2(8901), u2 = i2(9708), h2 = i2(6133), d2 = i2(3328), p2 = i2(1152);
    let f2;
    const m2 = { types: { alternatives: i2(4946), any: i2(8068), array: i2(546), boolean: i2(4937), date: i2(7500), function: i2(390), link: i2(8785), number: i2(3832), object: i2(8966), string: i2(7417), symbol: i2(8826) }, aliases: { alt: "alternatives", bool: "boolean", func: "function" }, root: function() {
      const e3 = { _types: new Set(Object.keys(m2.types)) };
      for (const r3 of e3._types)
        e3[r3] = function(...e4) {
          return a2(!e4.length || ["alternatives", "link", "object"].includes(r3), "The", r3, "type does not allow arguments"), m2.generate(this, m2.types[r3], e4);
        };
      for (const n3 of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"])
        e3[n3] = function(...e4) {
          return this.any()[n3](...e4);
        };
      Object.assign(e3, m2.methods);
      for (const i3 in m2.aliases) {
        var t3 = m2.aliases[i3];
        e3[i3] = e3[t3];
      }
      return e3.x = e3.expression, p2.setup && p2.setup(e3), e3;
    } };
    m2.methods = { ValidationError: l2.ValidationError, version: s2.version, cache: r2.provider, assert(e3, t3, ...r3) {
      m2.assert(e3, t3, true, r3);
    }, attempt: (e3, t3, ...r3) => m2.assert(e3, t3, false, r3), build(e3) {
      return a2(typeof u2.build == "function", "Manifest functionality disabled"), u2.build(this, e3);
    }, checkPreferences(e3) {
      s2.checkPreferences(e3);
    }, compile(e3, t3) {
      return n2.compile(this, e3, t3);
    }, defaults(e3) {
      a2(typeof e3 == "function", "modifier must be a function");
      const t3 = Object.assign({}, this);
      for (const r3 of t3._types) {
        const n3 = e3(t3[r3]());
        a2(s2.isSchema(n3), "modifier must return a valid schema object"), t3[r3] = function(...e4) {
          return m2.generate(this, n3, e4);
        };
      }
      return t3;
    }, expression: (...e3) => new d2(...e3), extend(...e3) {
      s2.verifyFlat(e3, "extend"), f2 = f2 || i2(3378), a2(e3.length, "You need to provide at least one extension"), this.assert(e3, f2.extensions);
      const t3 = Object.assign({}, this);
      t3._types = new Set(t3._types);
      for (var r3 of e3) {
        typeof r3 == "function" && (r3 = r3(t3)), this.assert(r3, f2.extension);
        const e4 = m2.expandExtension(r3, t3);
        for (const i3 of e4) {
          a2(t3[i3.type] === void 0 || t3._types.has(i3.type), "Cannot override name", i3.type);
          const e5 = i3.base || this.any(), n3 = c2.type(e5, i3);
          t3._types.add(i3.type), t3[i3.type] = function(...e6) {
            return m2.generate(this, n3, e6);
          };
        }
      }
      return t3;
    }, isError: l2.ValidationError.isError, isExpression: d2.isTemplate, isRef: h2.isRef, isSchema: s2.isSchema, in: (...e3) => h2.in(...e3), override: s2.symbols.override, ref: (...e3) => h2.create(...e3), types() {
      const e3 = {};
      for (const t3 of this._types)
        e3[t3] = this[t3]();
      for (const r3 in m2.aliases)
        e3[r3] = this[r3]();
      return e3;
    } }, m2.assert = function(e3, t3, r3, n3) {
      var i3 = n3[0] instanceof Error || typeof n3[0] == "string" ? n3[0] : null, n3 = i3 ? n3[1] : n3[0], n3 = t3.validate(e3, s2.preferences({ errors: { stack: true } }, n3 || {}));
      let a3 = n3.error;
      if (!a3)
        return n3.value;
      if (i3 instanceof Error)
        throw i3;
      r3 = r3 && typeof a3.annotate == "function" ? a3.annotate() : a3.message;
      throw a3 instanceof l2.ValidationError == 0 && (a3 = o2(a3)), a3.message = i3 ? "".concat(i3, " ").concat(r3) : r3, a3;
    }, m2.generate = function(e3, t3, r3) {
      return a2(e3, "Must be invoked on a Joi instance."), t3.$_root = e3, t3._definition.args && r3.length ? t3._definition.args(t3, ...r3) : t3;
    }, m2.expandExtension = function(e3, t3) {
      if (typeof e3.type == "string")
        return [e3];
      const r3 = [];
      for (const n3 of t3._types)
        if (e3.type.test(n3)) {
          const i3 = Object.assign({}, e3);
          i3.type = n3, i3.base = t3[n3](), r3.push(i3);
        }
      return r3;
    }, e2.exports = m2.root();
  }, 6914: (e2, i2, t2) => {
    const a2 = t2(375), o2 = t2(8571), s2 = t2(3328);
    i2.compile = function(e3, t3) {
      if (typeof e3 == "string")
        return a2(!t3, "Cannot set single message string"), new s2(e3);
      if (s2.isTemplate(e3))
        return a2(!t3, "Cannot set single message template"), e3;
      for (var r2 in a2(typeof e3 == "object" && !Array.isArray(e3), "Invalid message options"), t3 = t3 ? o2(t3) : {}, e3) {
        const o3 = e3[r2];
        if (r2 === "root" || s2.isTemplate(o3))
          t3[r2] = o3;
        else if (typeof o3 != "string") {
          a2(typeof o3 == "object" && !Array.isArray(o3), "Invalid message for", r2);
          var n2 = r2;
          for (r2 in t3[n2] = t3[n2] || {}, o3) {
            const e4 = o3[r2];
            r2 === "root" || s2.isTemplate(e4) ? t3[n2][r2] = e4 : (a2(typeof e4 == "string", "Invalid message for", r2, "in", n2), t3[n2][r2] = new s2(e4));
          }
        } else
          t3[r2] = new s2(o3);
      }
      return t3;
    }, i2.decompile = function(e3) {
      const t3 = {};
      for (var r2 in e3) {
        const i3 = e3[r2];
        if (r2 !== "root")
          if (s2.isTemplate(i3))
            t3[r2] = i3.describe({ compact: true });
          else {
            var n2 = r2;
            for (r2 in t3[n2] = {}, i3) {
              const e4 = i3[r2];
              t3[n2][r2] = r2 !== "root" ? e4.describe({ compact: true }) : e4;
            }
          }
        else
          t3[r2] = i3;
      }
      return t3;
    }, i2.merge = function(e3, t3) {
      if (!e3)
        return i2.compile(t3);
      if (!t3)
        return e3;
      if (typeof t3 == "string")
        return new s2(t3);
      if (s2.isTemplate(t3))
        return t3;
      const r2 = o2(e3);
      for (var n2 in t3) {
        const i3 = t3[n2];
        if (n2 === "root" || s2.isTemplate(i3))
          r2[n2] = i3;
        else if (typeof i3 != "string") {
          a2(typeof i3 == "object" && !Array.isArray(i3), "Invalid message for", n2);
          const o3 = n2;
          for (n2 in r2[o3] = r2[o3] || {}, i3) {
            const t4 = i3[n2];
            n2 === "root" || s2.isTemplate(t4) ? r2[o3][n2] = t4 : (a2(typeof t4 == "string", "Invalid message for", n2, "in", o3), r2[o3][n2] = new s2(t4));
          }
        } else
          r2[n2] = new s2(i3);
      }
      return r2;
    };
  }, 2294: (e2, i2, t2) => {
    function r2(t3, e3) {
      var r3, n2 = Object.keys(t3);
      return Object.getOwnPropertySymbols && (r3 = Object.getOwnPropertySymbols(t3), e3 && (r3 = r3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), n2.push.apply(n2, r3)), n2;
    }
    function s2(n2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? r2(Object(i3), true).forEach(function(e4) {
          var t3, r3;
          t3 = n2, e4 = i3[r3 = e4], r3 in t3 ? Object.defineProperty(t3, r3, { value: e4, enumerable: true, configurable: true, writable: true }) : t3[r3] = e4;
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n2, Object.getOwnPropertyDescriptors(i3)) : r2(Object(i3)).forEach(function(e4) {
          Object.defineProperty(n2, e4, Object.getOwnPropertyDescriptor(i3, e4));
        });
      }
      return n2;
    }
    const a2 = t2(375), l2 = t2(8160), c2 = t2(6133), u2 = {};
    i2.Ids = u2.Ids = class {
      constructor() {
        this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
      }
      clone() {
        const e3 = new u2.Ids();
        return e3._byId = new Map(this._byId), e3._byKey = new Map(this._byKey), e3._schemaChain = this._schemaChain, e3;
      }
      concat(e3) {
        e3._schemaChain && (this._schemaChain = true);
        for (var [t3, r3] of e3._byId.entries())
          a2(!this._byKey.has(t3), "Schema id conflicts with existing key:", t3), this._byId.set(t3, r3);
        for (var [n2, i3] of e3._byKey.entries())
          a2(!this._byId.has(n2), "Schema key conflicts with existing id:", n2), this._byKey.set(n2, i3);
      }
      fork(e3, t3, r3) {
        const n2 = this._collect(e3);
        n2.push({ schema: r3 });
        r3 = n2.shift();
        let i3 = { id: r3.id, schema: t3(r3.schema) };
        a2(l2.isSchema(i3.schema), "adjuster function failed to return a joi schema type");
        for (const e4 of n2)
          i3 = { id: e4.id, schema: u2.fork(e4.schema, i3.id, i3.schema) };
        return i3.schema;
      }
      labels(e3, t3 = []) {
        const r3 = e3[0], n2 = this._get(r3);
        if (!n2)
          return [...t3, ...e3].join(".");
        e3 = e3.slice(1);
        return t3 = [...t3, n2.schema._flags.label || r3], e3.length ? n2.schema._ids.labels(e3, t3) : t3.join(".");
      }
      reach(e3, t3 = []) {
        const r3 = e3[0], n2 = this._get(r3);
        a2(n2, "Schema does not contain path", [...t3, ...e3].join("."));
        e3 = e3.slice(1);
        return e3.length ? n2.schema._ids.reach(e3, [...t3, r3]) : n2.schema;
      }
      register(e3, { key: t3 } = {}) {
        if (e3 && l2.isSchema(e3)) {
          (e3.$_property("schemaChain") || e3._ids._schemaChain) && (this._schemaChain = true);
          var r3 = e3._flags.id;
          if (r3) {
            const t4 = this._byId.get(r3);
            a2(!t4 || t4.schema === e3, "Cannot add different schemas with the same id:", r3), a2(!this._byKey.has(r3), "Schema id conflicts with existing key:", r3), this._byId.set(r3, { schema: e3, id: r3 });
          }
          t3 && (a2(!this._byKey.has(t3), "Schema already contains key:", t3), a2(!this._byId.has(t3), "Schema key conflicts with existing id:", t3), this._byKey.set(t3, { schema: e3, id: t3 }));
        }
      }
      reset() {
        this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
      }
      _collect(e3, t3 = [], r3 = []) {
        const n2 = e3[0], i3 = this._get(n2);
        a2(i3, "Schema does not contain path", [...t3, ...e3].join(".")), r3 = [i3, ...r3];
        e3 = e3.slice(1);
        return e3.length ? i3.schema._ids._collect(e3, [...t3, n2], r3) : r3;
      }
      _get(e3) {
        return this._byId.get(e3) || this._byKey.get(e3);
      }
    }, u2.fork = function(e3, r3, n2) {
      const t3 = i2.schema(e3, { each: (e4, { key: t4 }) => {
        if (r3 === (e4._flags.id || t4))
          return n2;
      }, ref: false });
      return t3 ? t3.$_mutateRebuild() : e3;
    }, i2.schema = function(t3, r3) {
      let n2;
      for (const s3 in t3._flags) {
        var e3;
        s3[0] !== "_" && ((e3 = u2.scan(t3._flags[s3], { source: "flags", name: s3 }, r3)) !== void 0 && (n2 = n2 || t3.clone(), n2._flags[s3] = e3));
      }
      for (let e4 = 0; e4 < t3._rules.length; ++e4) {
        var i3 = t3._rules[e4], a3 = u2.scan(i3.args, { source: "rules", name: i3.name }, r3);
        if (a3 !== void 0) {
          n2 = n2 || t3.clone();
          const r4 = Object.assign({}, i3);
          r4.args = a3, n2._rules[e4] = r4, n2._singleRules.get(i3.name) === i3 && n2._singleRules.set(i3.name, r4);
        }
      }
      for (const l3 in t3.$_terms) {
        var o2;
        l3[0] !== "_" && ((o2 = u2.scan(t3.$_terms[l3], { source: "terms", name: l3 }, r3)) !== void 0 && (n2 = n2 || t3.clone(), n2.$_terms[l3] = o2));
      }
      return n2;
    }, u2.scan = function(r3, n2, i3, e3, a3) {
      var o2 = e3 || [];
      if (r3 !== null && typeof r3 == "object") {
        let t3;
        if (Array.isArray(r3)) {
          for (let e4 = 0; e4 < r3.length; ++e4) {
            const s3 = n2.source === "terms" && n2.name === "keys" && r3[e4].key, a4 = u2.scan(r3[e4], n2, i3, [e4, ...o2], s3);
            a4 !== void 0 && (t3 = t3 || r3.slice(), t3[e4] = a4);
          }
          return t3;
        }
        if (i3.schema !== false && l2.isSchema(r3) || i3.ref !== false && c2.isRef(r3)) {
          const e4 = i3.each(r3, s2(s2({}, n2), {}, { path: o2, key: a3 }));
          return e4 === r3 ? void 0 : e4;
        }
        for (const e4 in r3)
          if (e4[0] !== "_") {
            const s3 = u2.scan(r3[e4], n2, i3, [e4, ...o2], a3);
            s3 !== void 0 && (t3 = t3 || Object.assign({}, r3), t3[e4] = s3);
          }
        return t3;
      }
    };
  }, 6133: (e2, r2, n2) => {
    function t2(t3, e3) {
      var r3, n3 = Object.keys(t3);
      return Object.getOwnPropertySymbols && (r3 = Object.getOwnPropertySymbols(t3), e3 && (r3 = r3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), n3.push.apply(n3, r3)), n3;
    }
    function i2(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? t2(Object(i3), true).forEach(function(e4) {
          var t3, r3;
          t3 = n3, e4 = i3[r3 = e4], r3 in t3 ? Object.defineProperty(t3, r3, { value: e4, enumerable: true, configurable: true, writable: true }) : t3[r3] = e4;
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n3, Object.getOwnPropertyDescriptors(i3)) : t2(Object(i3)).forEach(function(e4) {
          Object.defineProperty(n3, e4, Object.getOwnPropertyDescriptor(i3, e4));
        });
      }
      return n3;
    }
    const a2 = n2(375), o2 = n2(8571), s2 = n2(9621), l2 = n2(8160);
    let c2;
    const u2 = { symbol: Symbol("ref"), defaults: { adjust: null, in: false, iterables: null, map: null, separator: ".", type: "value" } };
    r2.create = function(e3, t3 = {}) {
      a2(typeof e3 == "string", "Invalid reference key:", e3), l2.assertOptions(t3, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), a2(!t3.prefix || typeof t3.prefix == "object", "options.prefix must be of type object");
      const r3 = Object.assign({}, u2.defaults, t3);
      delete r3.prefix;
      const n3 = r3.separator, i3 = u2.context(e3, n3, t3.prefix);
      if (r3.type = i3.type, e3 = i3.key, r3.type === "value")
        if (i3.root && (a2(!n3 || e3[0] !== n3, "Cannot specify relative path with root prefix"), r3.ancestor = "root", e3 = e3 || null), n3 && n3 === e3)
          e3 = null, r3.ancestor = 0;
        else if (r3.ancestor !== void 0)
          a2(!n3 || !e3 || e3[0] !== n3, "Cannot combine prefix with ancestor option");
        else {
          const [t4, i4] = u2.ancestor(e3, n3);
          i4 && (e3 = e3.slice(i4)) === "" && (e3 = null), r3.ancestor = t4;
        }
      return r3.path = n3 ? e3 === null ? [] : e3.split(n3) : [e3], new u2.Ref(r3);
    }, r2.in = function(e3, t3 = {}) {
      return r2.create(e3, i2(i2({}, t3), {}, { in: true }));
    }, r2.isRef = function(e3) {
      return !!e3 && !!e3[l2.symbols.ref];
    }, u2.Ref = class {
      constructor(e3) {
        a2(typeof e3 == "object", "Invalid reference construction"), l2.assertOptions(e3, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), a2([false, void 0].includes(e3.separator) || typeof e3.separator == "string" && e3.separator.length === 1, "Invalid separator"), a2(!e3.adjust || typeof e3.adjust == "function", "options.adjust must be a function"), a2(!e3.map || Array.isArray(e3.map), "options.map must be an array"), a2(!e3.map || !e3.adjust, "Cannot set both map and adjust options"), Object.assign(this, u2.defaults, e3), a2(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay();
      }
      resolve(e3, t3, r3, n3, i3 = {}) {
        return a2(!this.in || i3.in, "Invalid in() reference usage"), this.type === "global" ? this._resolve(r3.context, t3, i3) : this.type === "local" ? this._resolve(n3, t3, i3) : this.ancestor ? this.ancestor === "root" ? this._resolve(t3.ancestors[t3.ancestors.length - 1], t3, i3) : (a2(this.ancestor <= t3.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(t3.ancestors[this.ancestor - 1], t3, i3)) : this._resolve(e3, t3, i3);
      }
      _resolve(e3, t3, r3) {
        let n3;
        if (this.type === "value" && t3.mainstay.shadow && r3.shadow !== false && (n3 = t3.mainstay.shadow.get(this.absolute(t3))), n3 === void 0 && (n3 = s2(e3, this.path, { iterables: this.iterables, functions: true })), this.adjust && (n3 = this.adjust(n3)), this.map) {
          const e4 = this.map.get(n3);
          e4 !== void 0 && (n3 = e4);
        }
        return t3.mainstay && t3.mainstay.tracer.resolve(t3, this, n3), n3;
      }
      toString() {
        return this.display;
      }
      absolute(e3) {
        return [...e3.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new u2.Ref(this);
      }
      describe() {
        const e3 = { path: this.path };
        this.type !== "value" && (e3.type = this.type), this.separator !== "." && (e3.separator = this.separator), this.type === "value" && this.ancestor !== 1 && (e3.ancestor = this.ancestor), this.map && (e3.map = [...this.map]);
        for (const t3 of ["adjust", "iterables", "render"])
          this[t3] !== null && this[t3] !== void 0 && (e3[t3] = this[t3]);
        return this.in !== false && (e3.in = true), { ref: e3 };
      }
      updateDisplay() {
        var e3, t3 = this.key !== null ? this.key : "";
        this.type === "value" ? this.separator ? this.ancestor ? this.ancestor !== "root" ? this.ancestor !== 1 ? (e3 = new Array(this.ancestor + 1).fill(this.separator).join(""), this.display = "ref:".concat(e3).concat(t3 || "")) : this.display = "ref:".concat(t3 || "..") : this.display = "ref:root:".concat(t3) : this.display = "ref:".concat(this.separator).concat(t3) : this.display = "ref:".concat(t3) : this.display = "ref:".concat(this.type, ":").concat(t3);
      }
    }, u2.Ref.prototype[l2.symbols.ref] = true, r2.build = function(e3) {
      return (e3 = Object.assign({}, u2.defaults, e3)).type === "value" && e3.ancestor === void 0 && (e3.ancestor = 1), new u2.Ref(e3);
    }, u2.context = function(e3, t3, r3 = {}) {
      if (e3 = e3.trim(), r3) {
        var n3 = r3.global === void 0 ? "$" : r3.global;
        if (n3 !== t3 && e3.startsWith(n3))
          return { key: e3.slice(n3.length), type: "global" };
        n3 = r3.local === void 0 ? "#" : r3.local;
        if (n3 !== t3 && e3.startsWith(n3))
          return { key: e3.slice(n3.length), type: "local" };
        r3 = r3.root === void 0 ? "/" : r3.root;
        if (r3 !== t3 && e3.startsWith(r3))
          return { key: e3.slice(r3.length), type: "value", root: true };
      }
      return { key: e3, type: "value" };
    }, u2.ancestor = function(e3, t3) {
      if (!t3)
        return [1, 0];
      if (e3[0] !== t3)
        return [1, 0];
      if (e3[1] !== t3)
        return [0, 1];
      let r3 = 2;
      for (; e3[r3] === t3; )
        ++r3;
      return [r3 - 1, r3];
    }, r2.toSibling = 0, r2.toParent = 1, r2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(e3, t3) {
        if (e3)
          if (t3 = t3 === void 0 ? r2.toParent : t3, Array.isArray(e3))
            for (const r3 of e3)
              this.register(r3, t3);
          else if (l2.isSchema(e3))
            for (const r3 of e3._refs.refs)
              0 <= r3.ancestor - t3 && this.refs.push({ ancestor: r3.ancestor - t3, root: r3.root });
          else
            r2.isRef(e3) && e3.type === "value" && 0 <= e3.ancestor - t3 && this.refs.push({ ancestor: e3.ancestor - t3, root: e3.root }), c2 = c2 || n2(3328), c2.isTemplate(e3) && this.register(e3.refs(), t3);
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const e3 = new r2.Manager();
        return e3.refs = o2(this.refs), e3;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((e3) => !e3.ancestor).map((e3) => e3.root);
      }
    };
  }, 3378: (e2, t2, r2) => {
    const n2 = r2(5107), i2 = {};
    i2.wrap = n2.string().min(1).max(2).allow(false), t2.preferences = n2.object({ allowUnknown: n2.boolean(), abortEarly: n2.boolean(), artifacts: n2.boolean(), cache: n2.boolean(), context: n2.object(), convert: n2.boolean(), dateFormat: n2.valid("date", "iso", "string", "time", "utc"), debug: n2.boolean(), errors: { escapeHtml: n2.boolean(), label: n2.valid("path", "key", false), language: [n2.string(), n2.object().ref()], render: n2.boolean(), stack: n2.boolean(), wrap: { label: i2.wrap, array: i2.wrap } }, externals: n2.boolean(), messages: n2.object(), noDefaults: n2.boolean(), nonEnumerables: n2.boolean(), presence: n2.valid("required", "optional", "forbidden"), skipFunctions: n2.boolean(), stripUnknown: n2.object({ arrays: n2.boolean(), objects: n2.boolean() }).or("arrays", "objects").allow(true, false), warnings: n2.boolean() }).strict(), i2.nameRx = /^[a-zA-Z0-9]\w*$/, i2.rule = n2.object({ alias: n2.array().items(n2.string().pattern(i2.nameRx)).single(), args: n2.array().items(n2.string(), n2.object({ name: n2.string().pattern(i2.nameRx).required(), ref: n2.boolean(), assert: n2.alternatives([n2.function(), n2.object().schema()]).conditional("ref", { is: true, then: n2.required() }), normalize: n2.function(), message: n2.string().when("assert", { is: n2.function(), then: n2.required() }) })), convert: n2.boolean(), manifest: n2.boolean(), method: n2.function().allow(false), multi: n2.boolean(), validate: n2.function() }), t2.extension = n2.object({ type: n2.alternatives([n2.string(), n2.object().regex()]).required(), args: n2.function(), cast: n2.object().pattern(i2.nameRx, n2.object({ from: n2.function().maxArity(1).required(), to: n2.function().minArity(1).maxArity(2).required() })), base: n2.object().schema().when("type", { is: n2.object().regex(), then: n2.forbidden() }), coerce: [n2.function().maxArity(3), n2.object({ method: n2.function().maxArity(3).required(), from: n2.array().items(n2.string()).single() })], flags: n2.object().pattern(i2.nameRx, n2.object({ setter: n2.string(), default: n2.any() })), manifest: { build: n2.function().arity(2) }, messages: [n2.object(), n2.string()], modifiers: n2.object().pattern(i2.nameRx, n2.function().minArity(1).maxArity(2)), overrides: n2.object().pattern(i2.nameRx, n2.function()), prepare: n2.function().maxArity(3), rebuild: n2.function().arity(1), rules: n2.object().pattern(i2.nameRx, i2.rule), terms: n2.object().pattern(i2.nameRx, n2.object({ init: n2.array().allow(null).required(), manifest: n2.object().pattern(/.+/, [n2.valid("schema", "single"), n2.object({ mapped: n2.object({ from: n2.string().required(), to: n2.string().required() }).required() })]) })), validate: n2.function().maxArity(3) }).strict(), t2.extensions = n2.array().items(n2.object(), n2.function().arity(1)).strict(), i2.desc = { buffer: n2.object({ buffer: n2.string() }), func: n2.object({ function: n2.function().required(), options: { literal: true } }), override: n2.object({ override: true }), ref: n2.object({ ref: n2.object({ type: n2.valid("value", "global", "local"), path: n2.array().required(), separator: n2.string().length(1).allow(false), ancestor: n2.number().min(0).integer().allow("root"), map: n2.array().items(n2.array().length(2)).min(1), adjust: n2.function(), iterables: n2.boolean(), in: n2.boolean(), render: n2.boolean() }).required() }), regex: n2.object({ regex: n2.string().min(3) }), special: n2.object({ special: n2.valid("deep").required() }), template: n2.object({ template: n2.string().required(), options: n2.object() }), value: n2.object({ value: n2.alternatives([n2.object(), n2.array()]).required() }) }, i2.desc.entity = n2.alternatives([n2.array().items(n2.link("...")), n2.boolean(), n2.function(), n2.number(), n2.string(), i2.desc.buffer, i2.desc.func, i2.desc.ref, i2.desc.regex, i2.desc.special, i2.desc.template, i2.desc.value, n2.link("/")]), i2.desc.values = n2.array().items(null, n2.boolean(), n2.function(), n2.number().allow(1 / 0, -1 / 0), n2.string().allow(""), n2.symbol(), i2.desc.buffer, i2.desc.func, i2.desc.override, i2.desc.ref, i2.desc.regex, i2.desc.template, i2.desc.value), i2.desc.messages = n2.object().pattern(/.+/, [n2.string(), i2.desc.template, n2.object().pattern(/.+/, [n2.string(), i2.desc.template])]), t2.description = n2.object({ type: n2.string().required(), flags: n2.object({ cast: n2.string(), default: n2.any(), description: n2.string(), empty: n2.link("/"), failover: i2.desc.entity, id: n2.string(), label: n2.string(), only: true, presence: ["optional", "required", "forbidden"], result: ["raw", "strip"], strip: n2.boolean(), unit: n2.string() }).unknown(), preferences: { allowUnknown: n2.boolean(), abortEarly: n2.boolean(), artifacts: n2.boolean(), cache: n2.boolean(), convert: n2.boolean(), dateFormat: ["date", "iso", "string", "time", "utc"], errors: { escapeHtml: n2.boolean(), label: ["path", "key"], language: [n2.string(), i2.desc.ref], wrap: { label: i2.wrap, array: i2.wrap } }, externals: n2.boolean(), messages: i2.desc.messages, noDefaults: n2.boolean(), nonEnumerables: n2.boolean(), presence: ["required", "optional", "forbidden"], skipFunctions: n2.boolean(), stripUnknown: n2.object({ arrays: n2.boolean(), objects: n2.boolean() }).or("arrays", "objects").allow(true, false), warnings: n2.boolean() }, allow: i2.desc.values, invalid: i2.desc.values, rules: n2.array().min(1).items({ name: n2.string().required(), args: n2.object().min(1), keep: n2.boolean(), message: [n2.string(), i2.desc.messages], warn: n2.boolean() }), keys: n2.object().pattern(/.*/, n2.link("/")), link: i2.desc.ref }).pattern(/^[a-z]\w*$/, n2.any());
  }, 493: (e2, t2, r2) => {
    const n2 = r2(8571), a2 = r2(9621), i2 = r2(8160), o2 = { value: Symbol("value") };
    e2.exports = o2.State = class {
      constructor(e3, t3, r3) {
        this.path = e3, this.ancestors = t3, this.mainstay = r3.mainstay, this.schemas = r3.schemas, this.debug = null;
      }
      localize(e3, t3 = null, r3 = null) {
        const n3 = new o2.State(e3, t3, this);
        return r3 && n3.schemas && (n3.schemas = [o2.schemas(r3), ...n3.schemas]), n3;
      }
      nest(e3, t3) {
        const r3 = new o2.State(this.path, this.ancestors, this);
        return r3.schemas = r3.schemas && [o2.schemas(e3), ...r3.schemas], r3.debug = t3, r3;
      }
      shadow(e3, t3) {
        this.mainstay.shadow = this.mainstay.shadow || new o2.Shadow(), this.mainstay.shadow.set(this.path, e3, t3);
      }
      snapshot() {
        this.mainstay.shadow && (this._snapshot = n2(this.mainstay.shadow.node(this.path)));
      }
      restore() {
        this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0);
      }
    }, o2.schemas = function(e3) {
      return i2.isSchema(e3) ? { schema: e3 } : e3;
    }, o2.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(n3, e3, i3) {
        if (n3.length && (i3 !== "strip" || typeof n3[n3.length - 1] != "number")) {
          this._values = this._values || new Map();
          let r3 = this._values;
          for (let t3 = 0; t3 < n3.length; ++t3) {
            const i4 = n3[t3];
            let e4 = r3.get(i4);
            e4 || (e4 = new Map(), r3.set(i4, e4)), r3 = e4;
          }
          r3[o2.value] = e3;
        }
      }
      get(e3) {
        e3 = this.node(e3);
        if (e3)
          return e3[o2.value];
      }
      node(e3) {
        if (this._values)
          return a2(this._values, e3, { iterables: true });
      }
      override(e3, t3) {
        if (this._values) {
          const r3 = e3.slice(0, -1), n3 = e3[e3.length - 1], i3 = a2(this._values, r3, { iterables: true });
          t3 ? i3.set(n3, t3) : i3 && i3.delete(n3);
        }
      }
    };
  }, 3328: (e2, t2, r2) => {
    function c2(t3, e3) {
      var r3, n3 = Object.keys(t3);
      return Object.getOwnPropertySymbols && (r3 = Object.getOwnPropertySymbols(t3), e3 && (r3 = r3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), n3.push.apply(n3, r3)), n3;
    }
    const n2 = r2(375), i2 = r2(8571), l2 = r2(5277), o2 = r2(1447), a2 = r2(8160), u2 = r2(6354), h2 = r2(6133), d2 = { symbol: Symbol("template"), opens: new Array(1e3).join("\0"), closes: new Array(1e3).join(""), dateFormat: { date: Date.prototype.toDateString, iso: Date.prototype.toISOString, string: Date.prototype.toString, time: Date.prototype.toTimeString, utc: Date.prototype.toUTCString } };
    e2.exports = d2.Template = class {
      constructor(e3, t3) {
        n2(typeof e3 == "string", "Template source must be a string"), n2(!e3.includes("\0") && !e3.includes(""), "Template source cannot contain reserved control characters"), this.source = e3, this.rendered = e3, this._template = null, this._settings = i2(t3), this._parse();
      }
      _parse() {
        if (this.source.includes("{")) {
          const n3 = d2.encode(this.source), i3 = d2.split(n3);
          let t3 = false;
          const a3 = [], o3 = i3.shift();
          o3 && a3.push(o3);
          for (const n4 of i3) {
            const i4 = n4[0] !== "{", o4 = i4 ? "}" : "}}", s2 = n4.indexOf(o4);
            if (s2 !== -1 && n4[1] !== "{") {
              let e3 = n4.slice(i4 ? 0 : 1, s2);
              var r3 = e3[0] === ":";
              r3 && (e3 = e3.slice(1));
              r3 = this._ref(d2.decode(e3), { raw: i4, wrapped: r3 });
              a3.push(r3), typeof r3 != "string" && (t3 = true);
              r3 = n4.slice(s2 + o4.length);
              r3 && a3.push(d2.decode(r3));
            } else
              a3.push("{".concat(d2.decode(n4)));
          }
          t3 ? this._template = a3 : this.rendered = a3.join("");
        }
      }
      static date(e3, t3) {
        return d2.dateFormat[t3.dateFormat].call(e3);
      }
      describe(e3 = {}) {
        if (!this._settings && e3.compact)
          return this.source;
        const t3 = { template: this.source };
        return this._settings && (t3.options = this._settings), t3;
      }
      static build(e3) {
        return new d2.Template(e3.template, e3.options);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(e3) {
        return !!e3 && !!e3[a2.symbols.template];
      }
      refs() {
        if (this._template) {
          const e3 = [];
          for (const t3 of this._template)
            typeof t3 != "string" && e3.push(...t3.refs);
          return e3;
        }
      }
      resolve(e3, t3, r3, n3) {
        return this._template && this._template.length === 1 ? this._part(this._template[0], e3, t3, r3, n3, {}) : this.render(e3, t3, r3, n3);
      }
      _part(e3, ...t3) {
        return e3.ref ? e3.ref.resolve(...t3) : e3.formula.evaluate(t3);
      }
      render(e3, t3, r3, n3, i3 = {}) {
        if (!this.isDynamic())
          return this.rendered;
        const a3 = [];
        for (const s2 of this._template)
          if (typeof s2 == "string")
            a3.push(s2);
          else {
            var o3 = this._part(s2, e3, t3, r3, n3, i3), o3 = d2.stringify(o3, e3, t3, r3, n3, i3);
            if (o3 !== void 0) {
              const e4 = s2.raw || (i3.errors && i3.errors.escapeHtml) === false ? o3 : l2(o3);
              a3.push(d2.wrap(e4, s2.wrapped && r3.errors.wrap.label));
            }
          }
        return a3.join("");
      }
      _ref(e3, { raw: t3, wrapped: r3 }) {
        const n3 = [], i3 = (e4) => {
          const t4 = h2.create(e4, this._settings);
          return n3.push(t4), (e5) => t4.resolve(...e5);
        };
        try {
          var a3 = new o2.Parser(e3, { reference: i3, functions: d2.functions, constants: d2.constants });
        } catch (t4) {
          throw t4.message = 'Invalid template variable "'.concat(e3, '" fails due to: ').concat(t4.message), t4;
        }
        if (a3.single) {
          if (a3.single.type !== "reference")
            return d2.stringify(a3.single.value);
          {
            const e4 = n3[0];
            return { ref: e4, raw: t3, refs: n3, wrapped: r3 || e4.type === "local" && e4.key === "label" };
          }
        }
        return { formula: a3, raw: t3, refs: n3 };
      }
      toString() {
        return this.source;
      }
    }, d2.Template.prototype[a2.symbols.template] = true, d2.Template.prototype.isImmutable = true, d2.encode = function(e3) {
      return e3.replace(/\\(\{+)/g, (e4, t3) => d2.opens.slice(0, t3.length)).replace(/\\(\}+)/g, (e4, t3) => d2.closes.slice(0, t3.length));
    }, d2.decode = function(e3) {
      return e3.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    }, d2.split = function(r3) {
      const n3 = [];
      let i3 = "";
      for (let t3 = 0; t3 < r3.length; ++t3) {
        var e3 = r3[t3];
        if (e3 === "{") {
          let e4 = "";
          for (; t3 + 1 < r3.length && r3[t3 + 1] === "{"; )
            e4 += "{", ++t3;
          n3.push(i3), i3 = e4;
        } else
          i3 += e3;
      }
      return n3.push(i3), n3;
    }, d2.wrap = function(e3, t3) {
      return t3 ? t3.length === 1 ? "".concat(t3).concat(e3).concat(t3) : "".concat(t3[0]).concat(e3).concat(t3[1]) : e3;
    }, d2.stringify = function(e3, t3, r3, n3, i3, a3) {
      var o3 = typeof e3;
      let s2 = false;
      if (h2.isRef(e3) && e3.render && (s2 = e3.in, e3 = e3.resolve(t3, r3, n3, i3, function(n4) {
        for (var e4 = 1; e4 < arguments.length; e4++) {
          var i4 = arguments[e4] != null ? arguments[e4] : {};
          e4 % 2 ? c2(Object(i4), true).forEach(function(e5) {
            var t4, r4;
            t4 = n4, e5 = i4[r4 = e5], r4 in t4 ? Object.defineProperty(t4, r4, { value: e5, enumerable: true, configurable: true, writable: true }) : t4[r4] = e5;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n4, Object.getOwnPropertyDescriptors(i4)) : c2(Object(i4)).forEach(function(e5) {
            Object.defineProperty(n4, e5, Object.getOwnPropertyDescriptor(i4, e5));
          });
        }
        return n4;
      }({ in: e3.in }, a3))), e3 === null)
        return "null";
      if (o3 == "string")
        return e3;
      if (o3 == "number" || o3 == "function" || o3 == "symbol")
        return e3.toString();
      if (o3 != "object")
        return JSON.stringify(e3);
      if (e3 instanceof Date)
        return d2.Template.date(e3, n3);
      if (e3 instanceof Map) {
        const t4 = [];
        for (const [r4, c3] of e3.entries())
          t4.push("".concat(r4.toString(), " -> ").concat(c3.toString()));
        e3 = t4;
      }
      if (!Array.isArray(e3))
        return e3.toString();
      let l3 = "";
      for (const c3 of e3)
        l3 = l3 + (l3.length ? ", " : "") + d2.stringify(c3, t3, r3, n3, i3, a3);
      return s2 ? l3 : d2.wrap(l3, n3.errors.wrap.array);
    }, d2.constants = { true: true, false: false, null: null, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }, d2.functions = { if: (e3, t3, r3) => e3 ? t3 : r3, msg(e3) {
      var [t3, r3, n3, i3, a3] = this, o3 = a3.messages;
      if (!o3)
        return "";
      const s2 = u2.template(t3, o3[0], e3, r3, n3) || u2.template(t3, o3[1], e3, r3, n3);
      return s2 ? s2.render(t3, r3, n3, i3, a3) : "";
    }, number: (e3) => typeof e3 == "number" ? e3 : typeof e3 == "string" ? parseFloat(e3) : typeof e3 == "boolean" ? e3 ? 1 : 0 : e3 instanceof Date ? e3.getTime() : null };
  }, 4946: (e2, t2, r2) => {
    const a2 = r2(375), p2 = r2(1687), n2 = r2(8068), i2 = r2(8160), o2 = r2(3292), c2 = r2(6354), s2 = r2(6133), f2 = {};
    e2.exports = n2.extend({ type: "alternatives", flags: { match: { default: "any" } }, terms: { matches: { init: [], register: s2.toSibling } }, args: (e3, ...t3) => t3.length === 1 && Array.isArray(t3[0]) ? e3.try(...t3[0]) : e3.try(...t3), validate(r3, t3) {
      const { schema: n3, error: i3, state: a3, prefs: o3 } = t3;
      if (n3._flags.match) {
        const t4 = [];
        for (let e3 = 0; e3 < n3.$_terms.matches.length; ++e3) {
          const p3 = n3.$_terms.matches[e3], l3 = a3.nest(p3.schema, "match.".concat(e3));
          l3.snapshot();
          var s3 = p3.schema.$_validate(r3, l3, o3);
          s3.errors ? l3.restore() : t4.push(s3.value);
        }
        return t4.length === 0 ? { errors: i3("alternatives.any") } : n3._flags.match === "one" ? t4.length === 1 ? { value: t4[0] } : { errors: i3("alternatives.one") } : t4.length !== n3.$_terms.matches.length ? { errors: i3("alternatives.all") } : n3.$_terms.matches.reduce((e3, t5) => e3 && t5.schema.type === "object", true) ? { value: t4.reduce((e3, t5) => p2(e3, t5, { mergeArrays: false })) } : { value: t4[t4.length - 1] };
      }
      const l2 = [];
      for (let t4 = 0; t4 < n3.$_terms.matches.length; ++t4) {
        const i4 = n3.$_terms.matches[t4];
        if (i4.schema) {
          const n4 = a3.nest(i4.schema, "match.".concat(t4));
          n4.snapshot();
          const p3 = i4.schema.$_validate(r3, n4, o3);
          if (!p3.errors)
            return p3;
          n4.restore(), l2.push({ schema: i4.schema, reports: p3.errors });
        } else {
          const p3 = i4.ref ? i4.ref.resolve(r3, a3, o3) : r3, c3 = i4.is ? [i4] : i4.switch;
          for (let e3 = 0; e3 < c3.length; ++e3) {
            const l3 = c3[e3], { is: u2, then: f3, otherwise: h2 } = l3, d2 = "match.".concat(t4).concat(i4.switch ? "." + e3 : "");
            if (u2.$_match(p3, a3.nest(u2, "".concat(d2, ".is")), o3)) {
              if (f3)
                return f3.$_validate(r3, a3.nest(f3, "".concat(d2, ".then")), o3);
            } else if (h2)
              return h2.$_validate(r3, a3.nest(h2, "".concat(d2, ".otherwise")), o3);
          }
        }
      }
      return f2.errors(l2, t3);
    }, rules: { conditional: { method(e3, t3) {
      a2(!this._flags._endedSwitch, "Unreachable condition"), a2(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), a2(t3.break === void 0, "Cannot use break option with alternatives conditional");
      const r3 = this.clone(), n3 = o2.when(r3, e3, t3), i3 = n3.is ? [n3] : n3.switch;
      for (const e4 of i3)
        if (e4.then && e4.otherwise) {
          r3.$_setFlag("_endedSwitch", true, { clone: false });
          break;
        }
      return r3.$_terms.matches.push(n3), r3.$_mutateRebuild();
    } }, match: { method(e3) {
      if (a2(["any", "one", "all"].includes(e3), "Invalid alternatives match mode", e3), e3 !== "any")
        for (const t3 of this.$_terms.matches)
          a2(t3.schema, "Cannot combine match mode", e3, "with conditional rules");
      return this.$_setFlag("match", e3);
    } }, try: { method(...e3) {
      a2(e3.length, "Missing alternative schemas"), i2.verifyFlat(e3, "try"), a2(!this._flags._endedSwitch, "Unreachable condition");
      const t3 = this.clone();
      for (const r3 of e3)
        t3.$_terms.matches.push({ schema: t3.$_compile(r3) });
      return t3.$_mutateRebuild();
    } } }, overrides: { label(r3) {
      return this.$_parent("label", r3).$_modify({ each: (e3, t3) => t3.path[0] !== "is" ? e3.label(r3) : void 0, ref: false });
    } }, rebuild(t3) {
      t3.$_modify({ each: (e3) => {
        i2.isSchema(e3) && e3.type === "array" && t3.$_setFlag("_arrayItems", true, { clone: false });
      } });
    }, manifest: { build(e3, t3) {
      if (t3.matches)
        for (const r3 of t3.matches) {
          const { schema: t4, ref: n3, is: i3, not: a3, then: o3, otherwise: s3 } = r3;
          e3 = t4 ? e3.try(t4) : n3 ? e3.conditional(n3, { is: i3, then: o3, not: a3, otherwise: s3, switch: r3.switch }) : e3.conditional(i3, { then: o3, otherwise: s3 });
        }
      return e3;
    } }, messages: { "alternatives.all": "{{#label}} does not match all of the required types", "alternatives.any": "{{#label}} does not match any of the allowed types", "alternatives.match": "{{#label}} does not match any of the allowed types", "alternatives.one": "{{#label}} matches more than one allowed type", "alternatives.types": "{{#label}} must be one of {{#types}}" } }), f2.errors = function(e3, { error: t3, state: r3 }) {
      if (!e3.length)
        return { errors: t3("alternatives.any") };
      if (e3.length === 1)
        return { errors: e3[0].reports };
      const n3 = new Set(), i3 = [];
      for (var { reports: a3, schema: o3 } of e3) {
        if (1 < a3.length)
          return f2.unmatched(e3, t3);
        const l2 = a3[0];
        if (l2 instanceof c2.Report == 0)
          return f2.unmatched(e3, t3);
        if (l2.state.path.length === r3.path.length)
          if (l2.code !== "any.only") {
            var [s3, a3] = l2.code.split(".");
            a3 === "base" ? n3.add(s3) : i3.push({ type: o3.type, report: l2 });
          } else
            for (const e4 of l2.local.valids)
              n3.add(e4);
        else
          i3.push({ type: o3.type, report: l2 });
      }
      return i3.length ? i3.length === 1 ? { errors: i3[0].report } : f2.unmatched(e3, t3) : { errors: t3("alternatives.types", { types: [...n3] }) };
    }, f2.unmatched = function(e3, t3) {
      const r3 = [];
      for (const t4 of e3)
        r3.push(...t4.reports);
      return { errors: t3("alternatives.match", c2.details(r3, { override: false })) };
    };
  }, 8068: (e2, t2, r2) => {
    const n2 = r2(375), i2 = r2(7629), a2 = r2(8160), o2 = r2(6914);
    e2.exports = i2.extend({ type: "any", flags: { only: { default: false } }, terms: { alterations: { init: null }, examples: { init: null }, externals: { init: null }, metas: { init: [] }, notes: { init: [] }, shared: { init: null }, tags: { init: [] }, whens: { init: null } }, rules: { custom: { method(e3, t3) {
      return n2(typeof e3 == "function", "Method must be a function"), n2(t3 === void 0 || t3 && typeof t3 == "string", "Description must be a non-empty string"), this.$_addRule({ name: "custom", args: { method: e3, description: t3 } });
    }, validate(e3, t3, { method: r3 }) {
      try {
        return r3(e3, t3);
      } catch (e4) {
        return t3.error("any.custom", { error: e4 });
      }
    }, args: ["method", "description"], multi: true }, messages: { method(e3) {
      return this.prefs({ messages: e3 });
    } }, shared: { method(e3) {
      n2(a2.isSchema(e3) && e3._flags.id, "Schema must be a schema with an id");
      const t3 = this.clone();
      return t3.$_terms.shared = t3.$_terms.shared || [], t3.$_terms.shared.push(e3), t3.$_mutateRegister(e3), t3;
    } }, warning: { method(e3, t3) {
      return n2(e3 && typeof e3 == "string", "Invalid warning code"), this.$_addRule({ name: "warning", args: { code: e3, local: t3 }, warn: true });
    }, validate: (e3, t3, { code: r3, local: n3 }) => t3.error(r3, n3), args: ["code", "local"], multi: true } }, modifiers: { keep(e3, t3 = true) {
      e3.keep = t3;
    }, message(e3, t3) {
      e3.message = o2.compile(t3);
    }, warn(e3, t3 = true) {
      e3.warn = t3;
    } }, manifest: { build(e3, t3) {
      for (const c2 in t3) {
        var r3 = t3[c2];
        if (["examples", "externals", "metas", "notes", "tags"].includes(c2))
          for (const t4 of r3)
            e3 = e3[c2.slice(0, -1)](t4);
        else if (c2 !== "alterations")
          if (c2 !== "whens") {
            if (c2 === "shared")
              for (const t4 of r3)
                e3 = e3.shared(t4);
          } else
            for (const t4 of r3) {
              var { ref: n3, is: i3, not: a3, then: o3, otherwise: s2, concat: l2 } = t4;
              e3 = l2 ? e3.concat(l2) : n3 ? e3.when(n3, { is: i3, not: a3, then: o3, otherwise: s2, switch: t4.switch, break: t4.break }) : e3.when(i3, { then: o3, otherwise: s2, break: t4.break });
            }
        else {
          const t4 = {};
          for (const { target: e4, adjuster: u2 } of r3)
            t4[e4] = u2;
          e3 = e3.alter(t4);
        }
      }
      return e3;
    } }, messages: { "any.custom": "{{#label}} failed custom validation because {{#error.message}}", "any.default": "{{#label}} threw an error when running default method", "any.failover": "{{#label}} threw an error when running failover method", "any.invalid": "{{#label}} contains an invalid value", "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}', "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}", "any.required": "{{#label}} is required", "any.unknown": "{{#label}} is not allowed" } });
  }, 546: (e2, t2, r2) => {
    const p2 = r2(375), f2 = r2(9474), m2 = r2(9621), n2 = r2(8068), x2 = r2(8160), i2 = r2(3292), w2 = {};
    e2.exports = n2.extend({ type: "array", flags: { single: { default: false }, sparse: { default: false } }, terms: { items: { init: [], manifest: "schema" }, ordered: { init: [], manifest: "schema" }, _exclusions: { init: [] }, _inclusions: { init: [] }, _requireds: { init: [] } }, coerce: { from: "object", method(e3, { schema: t3, state: r3, prefs: n3 }) {
      if (Array.isArray(e3)) {
        var i3 = t3.$_getRule("sort");
        return i3 ? w2.sort(t3, e3, i3.args.options, r3, n3) : void 0;
      }
    } }, validate(e3, { schema: t3, error: r3 }) {
      if (!Array.isArray(e3)) {
        if (t3._flags.single) {
          const t4 = [e3];
          return t4[x2.symbols.arraySingle] = true, { value: t4 };
        }
        return { errors: r3("array.base") };
      }
      if (t3.$_getRule("items") || t3.$_terms.externals)
        return { value: e3.slice() };
    }, rules: { has: { method(e3) {
      e3 = this.$_compile(e3, { appendPath: true });
      const t3 = this.$_addRule({ name: "has", args: { schema: e3 } });
      return t3.$_mutateRegister(e3), t3;
    }, validate(t3, { state: r3, prefs: n3, error: e3 }, { schema: i3 }) {
      var a2 = [t3, ...r3.ancestors];
      for (let e4 = 0; e4 < t3.length; ++e4) {
        const o3 = r3.localize([...r3.path, e4], a2, i3);
        if (i3.$_match(t3[e4], o3, n3))
          return t3;
      }
      const o2 = i3._flags.label;
      return o2 ? e3("array.hasKnown", { patternLabel: o2 }) : e3("array.hasUnknown", null);
    }, multi: true }, items: { method(...t3) {
      x2.verifyFlat(t3, "items");
      const r3 = this.$_addRule("items");
      for (let e3 = 0; e3 < t3.length; ++e3) {
        var n3 = x2.tryWithPath(() => this.$_compile(t3[e3]), e3, { append: true });
        r3.$_terms.items.push(n3);
      }
      return r3.$_mutateRebuild();
    }, validate(a2, { schema: o2, error: s2, state: l2, prefs: c2, errorsArray: e3 }) {
      const u2 = o2.$_terms._requireds.slice(), h2 = o2.$_terms.ordered.slice(), d2 = [...o2.$_terms._inclusions, ...u2], p3 = !a2[x2.symbols.arraySingle];
      delete a2[x2.symbols.arraySingle];
      const f3 = e3();
      let m3 = a2.length;
      for (let i3 = 0; i3 < m3; ++i3) {
        const x3 = a2[i3];
        let r3 = false, n3 = false;
        var g2 = p3 ? i3 : new Number(i3), v2 = [...l2.path, g2];
        if (o2._flags.sparse || x3 !== void 0) {
          var y = [a2, ...l2.ancestors];
          for (const a3 of o2.$_terms._exclusions)
            if (a3.$_match(x3, l2.localize(v2, y, a3), c2, { presence: "ignore" })) {
              if (f3.push(s2("array.excludes", { pos: i3, value: x3 }, l2.localize(v2))), c2.abortEarly)
                return f3;
              r3 = true, h2.shift();
              break;
            }
          if (!r3) {
            if (o2.$_terms.ordered.length) {
              if (h2.length) {
                const u3 = h2.shift(), d3 = u3.$_validate(x3, l2.localize(v2, y, u3), c2);
                if (d3.errors) {
                  if (f3.push(...d3.errors), c2.abortEarly)
                    return f3;
                } else if (u3._flags.result === "strip")
                  w2.fastSplice(a2, i3), --i3, --m3;
                else {
                  if (!o2._flags.sparse && d3.value === void 0) {
                    if (f3.push(s2("array.sparse", { key: g2, path: v2, pos: i3, value: void 0 }, l2.localize(v2))), c2.abortEarly)
                      return f3;
                    continue;
                  }
                  a2[i3] = d3.value;
                }
                continue;
              }
              if (!o2.$_terms.items.length) {
                if (f3.push(s2("array.orderedLength", { pos: i3, limit: o2.$_terms.ordered.length })), c2.abortEarly)
                  return f3;
                break;
              }
            }
            const b2 = [];
            let t3 = u2.length;
            for (let e4 = 0; e4 < t3; ++e4) {
              const d3 = l2.localize(v2, y, u2[e4]);
              d3.snapshot();
              const p4 = u2[e4].$_validate(x3, d3, c2);
              if (!(b2[e4] = p4).errors) {
                if (a2[i3] = p4.value, n3 = true, w2.fastSplice(u2, e4), --e4, --t3, !o2._flags.sparse && p4.value === void 0 && (f3.push(s2("array.sparse", { key: g2, path: v2, pos: i3, value: void 0 }, l2.localize(v2))), c2.abortEarly))
                  return f3;
                break;
              }
              d3.restore();
            }
            if (!n3) {
              var _2 = c2.stripUnknown && !!c2.stripUnknown.arrays || false;
              t3 = d2.length;
              for (const h3 of d2) {
                let e4;
                const p4 = u2.indexOf(h3);
                if (p4 !== -1)
                  e4 = b2[p4];
                else {
                  const u3 = l2.localize(v2, y, h3);
                  if (u3.snapshot(), e4 = h3.$_validate(x3, u3, c2), !e4.errors) {
                    h3._flags.result === "strip" ? (w2.fastSplice(a2, i3), --i3, --m3) : o2._flags.sparse || e4.value !== void 0 ? a2[i3] = e4.value : (f3.push(s2("array.sparse", { key: g2, path: v2, pos: i3, value: void 0 }, l2.localize(v2))), r3 = true), n3 = true;
                    break;
                  }
                  u3.restore();
                }
                if (t3 === 1) {
                  if (_2) {
                    w2.fastSplice(a2, i3), --i3, --m3, n3 = true;
                    break;
                  }
                  if (f3.push(...e4.errors), c2.abortEarly)
                    return f3;
                  r3 = true;
                  break;
                }
              }
              if (!r3 && (o2.$_terms._inclusions.length || o2.$_terms._requireds.length) && !n3) {
                if (_2)
                  w2.fastSplice(a2, i3), --i3, --m3;
                else if (f3.push(s2("array.includes", { pos: i3, value: x3 }, l2.localize(v2))), c2.abortEarly)
                  return f3;
              }
            }
          }
        } else {
          if (f3.push(s2("array.sparse", { key: g2, path: v2, pos: i3, value: void 0 }, l2.localize(v2))), c2.abortEarly)
            return f3;
          h2.shift();
        }
      }
      return u2.length && w2.fillMissedErrors(o2, f3, u2, a2, l2, c2), h2.length && (w2.fillOrderedErrors(o2, f3, h2, a2, l2, c2), f3.length || w2.fillDefault(h2, a2, l2, c2)), f3.length ? f3 : a2;
    }, priority: true, manifest: false }, length: { method(e3) {
      return this.$_addRule({ name: "length", args: { limit: e3 }, operator: "=" });
    }, validate: (e3, t3, { limit: r3 }, { name: n3, operator: i3, args: a2 }) => x2.compare(e3.length, r3, i3) ? e3 : t3.error("array." + n3, { limit: a2.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: x2.limit, message: "must be a positive integer" }] }, max: { method(e3) {
      return this.$_addRule({ name: "max", method: "length", args: { limit: e3 }, operator: "<=" });
    } }, min: { method(e3) {
      return this.$_addRule({ name: "min", method: "length", args: { limit: e3 }, operator: ">=" });
    } }, ordered: { method(...t3) {
      x2.verifyFlat(t3, "ordered");
      const r3 = this.$_addRule("items");
      for (let e3 = 0; e3 < t3.length; ++e3) {
        var n3 = x2.tryWithPath(() => this.$_compile(t3[e3]), e3, { append: true });
        w2.validateSingle(n3, r3), r3.$_mutateRegister(n3), r3.$_terms.ordered.push(n3);
      }
      return r3.$_mutateRebuild();
    } }, single: { method(e3) {
      e3 = e3 === void 0 || !!e3;
      return p2(!e3 || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", e3);
    } }, sort: { method(e3 = {}) {
      x2.assertOptions(e3, ["by", "order"]);
      const t3 = { order: e3.order || "ascending" };
      return e3.by && (t3.by = i2.ref(e3.by, { ancestor: 0 }), p2(!t3.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({ name: "sort", args: { options: t3 } });
    }, validate(t3, { error: r3, state: e3, prefs: n3, schema: i3 }, { options: a2 }) {
      var { value: o2, errors: n3 } = w2.sort(i3, t3, a2, e3, n3);
      if (n3)
        return n3;
      for (let e4 = 0; e4 < t3.length; ++e4)
        if (t3[e4] !== o2[e4])
          return r3("array.sort", { order: a2.order, by: a2.by ? a2.by.key : "value" });
      return t3;
    }, convert: true }, sparse: { method(e3) {
      e3 = e3 === void 0 || !!e3;
      return this._flags.sparse === e3 ? this : (e3 ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", e3, { clone: false });
    } }, unique: { method(e3, t3 = {}) {
      p2(!e3 || typeof e3 == "function" || typeof e3 == "string", "comparator must be a function or a string"), x2.assertOptions(t3, ["ignoreUndefined", "separator"]);
      const r3 = { name: "unique", args: { options: t3, comparator: e3 } };
      if (e3)
        if (typeof e3 == "string") {
          const p3 = x2.default(t3.separator, ".");
          r3.path = p3 ? e3.split(p3) : [e3];
        } else
          r3.comparator = e3;
      return this.$_addRule(r3);
    }, validate(t3, { state: r3, error: n3 }, { comparator: i3, options: a2 }, { comparator: o2, path: s2 }) {
      const l2 = { string: Object.create(null), number: Object.create(null), undefined: Object.create(null), boolean: Object.create(null), object: new Map(), function: new Map(), custom: new Map() }, c2 = o2 || f2, u2 = a2.ignoreUndefined;
      for (let e3 = 0; e3 < t3.length; ++e3) {
        const d2 = s2 ? m2(t3[e3], s2) : t3[e3], a3 = o2 ? l2.custom : l2[typeof d2];
        if (p2(a3, "Failed to find unique map container for type", typeof d2), a3 instanceof Map) {
          const p3 = a3.entries();
          for (var h2; !(h2 = p3.next()).done; )
            if (c2(h2.value[0], d2)) {
              const p4 = r3.localize([...r3.path, e3], [t3, ...r3.ancestors]), d3 = { pos: e3, value: t3[e3], dupePos: h2.value[1], dupeValue: t3[h2.value[1]] };
              return s2 && (d3.path = i3), n3("array.unique", d3, p4);
            }
          a3.set(d2, e3);
        } else {
          if ((!u2 || d2 !== void 0) && a3[d2] !== void 0) {
            const p3 = { pos: e3, value: t3[e3], dupePos: a3[d2], dupeValue: t3[a3[d2]] };
            return s2 && (p3.path = i3), n3("array.unique", p3, r3.localize([...r3.path, e3], [t3, ...r3.ancestors]));
          }
          a3[d2] = e3;
        }
      }
      return t3;
    }, args: ["comparator", "options"], multi: true } }, cast: { set: { from: Array.isArray, to: (e3, t3) => new Set(e3) } }, rebuild(e3) {
      e3.$_terms._inclusions = [], e3.$_terms._exclusions = [], e3.$_terms._requireds = [];
      for (const t3 of e3.$_terms.items)
        w2.validateSingle(t3, e3), (t3._flags.presence === "required" ? e3.$_terms._requireds : t3._flags.presence === "forbidden" ? e3.$_terms._exclusions : e3.$_terms._inclusions).push(t3);
      for (const r3 of e3.$_terms.ordered)
        w2.validateSingle(r3, e3);
    }, manifest: { build: (e3, t3) => (t3.items && (e3 = e3.items(...t3.items)), e3 = t3.ordered ? e3.ordered(...t3.ordered) : e3) }, messages: { "array.base": "{{#label}} must be an array", "array.excludes": "{{#label}} contains an excluded value", "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}", "array.hasUnknown": "{{#label}} does not contain at least one required match", "array.includes": "{{#label}} does not match any of the allowed types", "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)", "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}", "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)", "array.length": "{{#label}} must contain {{#limit}} items", "array.max": "{{#label}} must contain less than or equal to {{#limit}} items", "array.min": "{{#label}} must contain at least {{#limit}} items", "array.orderedLength": "{{#label}} must contain at most {{#limit}} items", "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}", "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types", "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}", "array.sparse": "{{#label}} must not be a sparse array item", "array.unique": "{{#label}} contains a duplicate value" } }), w2.fillMissedErrors = function(e3, t3, r3, n3, i3, a2) {
      const o2 = [];
      let s2 = 0;
      for (const e4 of r3) {
        const t4 = e4._flags.label;
        t4 ? o2.push(t4) : ++s2;
      }
      o2.length ? s2 ? t3.push(e3.$_createError("array.includesRequiredBoth", n3, { knownMisses: o2, unknownMisses: s2 }, i3, a2)) : t3.push(e3.$_createError("array.includesRequiredKnowns", n3, { knownMisses: o2 }, i3, a2)) : t3.push(e3.$_createError("array.includesRequiredUnknowns", n3, { unknownMisses: s2 }, i3, a2));
    }, w2.fillOrderedErrors = function(e3, t3, r3, n3, i3, a2) {
      const o2 = [];
      for (const e4 of r3)
        e4._flags.presence === "required" && o2.push(e4);
      o2.length && w2.fillMissedErrors(e3, t3, o2, n3, i3, a2);
    }, w2.fillDefault = function(t3, r3, n3, i3) {
      const a2 = [];
      let o2 = true;
      for (let e3 = t3.length - 1; 0 <= e3; --e3) {
        const s2 = t3[e3], l2 = [r3, ...n3.ancestors], c2 = s2.$_validate(void 0, n3.localize(n3.path, l2, s2), i3).value;
        if (o2) {
          if (c2 === void 0)
            continue;
          o2 = false;
        }
        a2.unshift(c2);
      }
      a2.length && r3.push(...a2);
    }, w2.fastSplice = function(e3, t3) {
      let r3 = t3;
      for (; r3 < e3.length; )
        e3[r3++] = e3[r3];
      --e3.length;
    }, w2.validateSingle = function(e3, t3) {
      e3.type !== "array" && !e3._flags._arrayItems || (p2(!t3._flags.single, "Cannot specify array item with single rule enabled"), t3.$_setFlag("_arrayItems", true, { clone: false }));
    }, w2.sort = function(i3, a2, o2, s2, l2) {
      const c2 = o2.order === "ascending" ? 1 : -1, u2 = -1 * c2, h2 = c2;
      try {
        return { value: a2.slice().sort((e3, t3) => {
          let r3 = w2.compare(e3, t3, u2, h2);
          if (r3 !== null)
            return r3;
          if (o2.by && (e3 = o2.by.resolve(e3, s2, l2), t3 = o2.by.resolve(t3, s2, l2)), r3 = w2.compare(e3, t3, u2, h2), r3 !== null)
            return r3;
          var n3 = typeof e3;
          if (n3 != typeof t3)
            throw i3.$_createError("array.sort.mismatching", a2, null, s2, l2);
          if (n3 != "number" && n3 != "string")
            throw i3.$_createError("array.sort.unsupported", a2, { type: n3 }, s2, l2);
          return n3 == "number" ? (e3 - t3) * c2 : e3 < t3 ? u2 : h2;
        }) };
      } catch (i4) {
        return { errors: i4 };
      }
    }, w2.compare = function(e3, t3, r3, n3) {
      return e3 === t3 ? 0 : e3 === void 0 ? 1 : t3 === void 0 ? -1 : e3 === null ? n3 : t3 === null ? r3 : null;
    };
  }, 4937: (e2, t2, r2) => {
    const i2 = r2(375), n2 = r2(8068), a2 = r2(8160), o2 = r2(2036), s2 = { isBool: function(e3) {
      return typeof e3 == "boolean";
    } };
    e2.exports = n2.extend({ type: "boolean", flags: { sensitive: { default: false } }, terms: { falsy: { init: null, manifest: "values" }, truthy: { init: null, manifest: "values" } }, coerce(e3, { schema: t3 }) {
      var r3;
      if (typeof e3 != "boolean")
        return { value: e3 = typeof (e3 = typeof e3 == "string" ? (r3 = t3._flags.sensitive ? e3 : e3.toLowerCase()) === "true" || r3 !== "false" && e3 : e3) != "boolean" ? t3.$_terms.truthy && t3.$_terms.truthy.has(e3, null, null, !t3._flags.sensitive) || (!t3.$_terms.falsy || !t3.$_terms.falsy.has(e3, null, null, !t3._flags.sensitive)) && e3 : e3 };
    }, validate(e3, { error: t3 }) {
      if (typeof e3 != "boolean")
        return { value: e3, errors: t3("boolean.base") };
    }, rules: { truthy: { method(...t3) {
      a2.verifyFlat(t3, "truthy");
      const r3 = this.clone();
      r3.$_terms.truthy = r3.$_terms.truthy || new o2();
      for (let e3 = 0; e3 < t3.length; ++e3) {
        var n3 = t3[e3];
        i2(n3 !== void 0, "Cannot call truthy with undefined"), r3.$_terms.truthy.add(n3);
      }
      return r3;
    } }, falsy: { method(...t3) {
      a2.verifyFlat(t3, "falsy");
      const r3 = this.clone();
      r3.$_terms.falsy = r3.$_terms.falsy || new o2();
      for (let e3 = 0; e3 < t3.length; ++e3) {
        var n3 = t3[e3];
        i2(n3 !== void 0, "Cannot call falsy with undefined"), r3.$_terms.falsy.add(n3);
      }
      return r3;
    } }, sensitive: { method(e3 = true) {
      return this.$_setFlag("sensitive", e3);
    } } }, cast: { number: { from: s2.isBool, to: (e3, t3) => e3 ? 1 : 0 }, string: { from: s2.isBool, to: (e3, t3) => e3 ? "true" : "false" } }, manifest: { build: (e3, t3) => (t3.truthy && (e3 = e3.truthy(...t3.truthy)), e3 = t3.falsy ? e3.falsy(...t3.falsy) : e3) }, messages: { "boolean.base": "{{#label}} must be a boolean" } });
  }, 7500: (e2, t2, r2) => {
    const n2 = r2(375), i2 = r2(8068), o2 = r2(8160), a2 = r2(3328), s2 = { isDate: function(e3) {
      return e3 instanceof Date;
    } };
    e2.exports = i2.extend({ type: "date", coerce: { from: ["number", "string"], method: (e3, { schema: t3 }) => ({ value: s2.parse(e3, t3._flags.format) || e3 }) }, validate(e3, { schema: t3, error: r3, prefs: n3 }) {
      if (!(e3 instanceof Date) || isNaN(e3.getTime())) {
        t3 = t3._flags.format;
        return n3.convert && t3 && typeof e3 == "string" ? { value: e3, errors: r3("date.format", { format: t3 }) } : { value: e3, errors: r3("date.base") };
      }
    }, rules: { compare: { method: false, validate(e3, t3, { date: r3 }, { name: n3, operator: i3, args: a3 }) {
      r3 = r3 === "now" ? Date.now() : r3.getTime();
      return o2.compare(e3.getTime(), r3, i3) ? e3 : t3.error("date." + n3, { limit: a3.date, value: e3 });
    }, args: [{ name: "date", ref: true, normalize: (e3) => e3 === "now" ? e3 : s2.parse(e3), assert: (e3) => e3 !== null, message: "must have a valid date format" }] }, format: { method(e3) {
      return n2(["iso", "javascript", "unix"].includes(e3), "Unknown date format", e3), this.$_setFlag("format", e3);
    } }, greater: { method(e3) {
      return this.$_addRule({ name: "greater", method: "compare", args: { date: e3 }, operator: ">" });
    } }, iso: { method() {
      return this.format("iso");
    } }, less: { method(e3) {
      return this.$_addRule({ name: "less", method: "compare", args: { date: e3 }, operator: "<" });
    } }, max: { method(e3) {
      return this.$_addRule({ name: "max", method: "compare", args: { date: e3 }, operator: "<=" });
    } }, min: { method(e3) {
      return this.$_addRule({ name: "min", method: "compare", args: { date: e3 }, operator: ">=" });
    } }, timestamp: { method(e3 = "javascript") {
      return n2(["javascript", "unix"].includes(e3), '"type" must be one of "javascript, unix"'), this.format(e3);
    } } }, cast: { number: { from: s2.isDate, to: (e3, t3) => e3.getTime() }, string: { from: s2.isDate, to: (e3, { prefs: t3 }) => a2.date(e3, t3) } }, messages: { "date.base": "{{#label}} must be a valid date", "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format', "date.greater": "{{#label}} must be greater than {{:#limit}}", "date.less": "{{#label}} must be less than {{:#limit}}", "date.max": "{{#label}} must be less than or equal to {{:#limit}}", "date.min": "{{#label}} must be greater than or equal to {{:#limit}}", "date.format.iso": "ISO 8601 date", "date.format.javascript": "timestamp or number of milliseconds", "date.format.unix": "timestamp or number of seconds" } }), s2.parse = function(e3, t3) {
      if (e3 instanceof Date)
        return e3;
      if (typeof e3 != "string" && (isNaN(e3) || !isFinite(e3)))
        return null;
      if (/^\s*$/.test(e3))
        return null;
      if (t3 === "iso")
        return o2.isIsoDate(e3) ? s2.date(e3.toString()) : null;
      var r3 = e3;
      if (typeof e3 == "string" && /^[+-]?\d+(\.\d+)?$/.test(e3) && (e3 = parseFloat(e3)), t3) {
        if (t3 === "javascript")
          return s2.date(+e3);
        if (t3 === "unix")
          return s2.date(1e3 * e3);
        if (typeof r3 == "string")
          return null;
      }
      return s2.date(e3);
    }, s2.date = function(e3) {
      const t3 = new Date(e3);
      return isNaN(t3.getTime()) ? null : t3;
    };
  }, 390: (e2, t2, r2) => {
    const n2 = r2(375), i2 = r2(7824);
    e2.exports = i2.extend({ type: "function", properties: { typeof: "function" }, rules: { arity: { method(e3) {
      return n2(Number.isSafeInteger(e3) && 0 <= e3, "n must be a positive integer"), this.$_addRule({ name: "arity", args: { n: e3 } });
    }, validate: (e3, t3, { n: r3 }) => e3.length === r3 ? e3 : t3.error("function.arity", { n: r3 }) }, class: { method() {
      return this.$_addRule("class");
    }, validate: (e3, t3) => /^\s*class\s/.test(e3.toString()) ? e3 : t3.error("function.class", { value: e3 }) }, minArity: { method(e3) {
      return n2(Number.isSafeInteger(e3) && 0 < e3, "n must be a strict positive integer"), this.$_addRule({ name: "minArity", args: { n: e3 } });
    }, validate: (e3, t3, { n: r3 }) => e3.length >= r3 ? e3 : t3.error("function.minArity", { n: r3 }) }, maxArity: { method(e3) {
      return n2(Number.isSafeInteger(e3) && 0 <= e3, "n must be a positive integer"), this.$_addRule({ name: "maxArity", args: { n: e3 } });
    }, validate: (e3, t3, { n: r3 }) => e3.length <= r3 ? e3 : t3.error("function.maxArity", { n: r3 }) } }, messages: { "function.arity": "{{#label}} must have an arity of {{#n}}", "function.class": "{{#label}} must be a class", "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}", "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}" } });
  }, 7824: (e2, t2, r2) => {
    const i2 = r2(978), l2 = r2(375), n2 = r2(8571), a2 = r2(3652), o2 = r2(8068), v2 = r2(8160), c2 = r2(3292), y = r2(6354), u2 = r2(6133), h2 = r2(3328), f2 = { renameDefaults: { alias: false, multiple: false, override: false } };
    e2.exports = o2.extend({ type: "_keys", properties: { typeof: "object" }, flags: { unknown: { default: false } }, terms: { dependencies: { init: null }, keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } }, patterns: { init: null }, renames: { init: null } }, args: (e3, t3) => e3.keys(t3), validate(e3, { schema: t3, error: r3, state: n3, prefs: i3 }) {
      if (!e3 || typeof e3 !== t3.$_property("typeof") || Array.isArray(e3))
        return { value: e3, errors: r3("object.base", { type: t3.$_property("typeof") }) };
      if (t3.$_terms.renames || t3.$_terms.dependencies || t3.$_terms.keys || t3.$_terms.patterns || t3.$_terms.externals) {
        e3 = f2.clone(e3, i3);
        const o3 = [];
        if (t3.$_terms.renames && !f2.rename(t3, e3, n3, i3, o3))
          return { value: e3, errors: o3 };
        if (!t3.$_terms.keys && !t3.$_terms.patterns && !t3.$_terms.dependencies)
          return { value: e3, errors: o3 };
        const s2 = new Set(Object.keys(e3));
        if (t3.$_terms.keys) {
          const r4 = [e3, ...n3.ancestors];
          for (const l3 of t3.$_terms.keys) {
            const t4 = l3.key, c3 = e3[t4];
            s2.delete(t4);
            var a3 = n3.localize([...n3.path, t4], r4, l3), a3 = l3.schema.$_validate(c3, a3, i3);
            if (a3.errors) {
              if (i3.abortEarly)
                return { value: e3, errors: a3.errors };
              a3.value !== void 0 && (e3[t4] = a3.value), o3.push(...a3.errors);
            } else
              l3.schema._flags.result === "strip" || a3.value === void 0 && c3 !== void 0 ? delete e3[t4] : a3.value !== void 0 && (e3[t4] = a3.value);
          }
        }
        if (s2.size || t3._flags._hasPatternMatch) {
          const r4 = f2.unknown(t3, e3, s2, o3, n3, i3);
          if (r4)
            return r4;
        }
        if (t3.$_terms.dependencies) {
          for (const r4 of t3.$_terms.dependencies)
            if (!r4.key || r4.key.resolve(e3, n3, i3, null, { shadow: false }) !== void 0) {
              const s3 = f2.dependencies[r4.rel](t3, r4, e3, n3, i3);
              if (s3) {
                const r5 = t3.$_createError(s3.code, e3, s3.context, n3, i3);
                if (i3.abortEarly)
                  return { value: e3, errors: r5 };
                o3.push(r5);
              }
            }
        }
        return { value: e3, errors: o3 };
      }
    }, rules: { and: { method(...e3) {
      return v2.verifyFlat(e3, "and"), f2.dependency(this, "and", null, e3);
    } }, append: { method(e3) {
      return e3 == null || Object.keys(e3).length === 0 ? this : this.keys(e3);
    } }, assert: { method(e3, t3, r3) {
      h2.isTemplate(e3) || (e3 = c2.ref(e3)), l2(r3 === void 0 || typeof r3 == "string", "Message must be a string"), t3 = this.$_compile(t3, { appendPath: true });
      const n3 = this.$_addRule({ name: "assert", args: { subject: e3, schema: t3, message: r3 } });
      return n3.$_mutateRegister(e3), n3.$_mutateRegister(t3), n3;
    }, validate(e3, { error: t3, prefs: r3, state: n3 }, { subject: i3, schema: a3, message: o3 }) {
      var s2 = i3.resolve(e3, n3, r3), l3 = u2.isRef(i3) ? i3.absolute(n3) : [];
      return a3.$_match(s2, n3.localize(l3, [e3, ...n3.ancestors], a3), r3) ? e3 : t3("object.assert", { subject: i3, message: o3 });
    }, args: ["subject", "schema", "message"], multi: true }, instance: { method(e3, t3) {
      return l2(typeof e3 == "function", "constructor must be a function"), t3 = t3 || e3.name, this.$_addRule({ name: "instance", args: { constructor: e3, name: t3 } });
    }, validate: (e3, t3, { constructor: r3, name: n3 }) => e3 instanceof r3 ? e3 : t3.error("object.instance", { type: n3, value: e3 }), args: ["constructor", "name"] }, keys: { method(t3) {
      l2(t3 === void 0 || typeof t3 == "object", "Object schema must be a valid object"), l2(!v2.isSchema(t3), "Object schema cannot be a joi schema");
      const e3 = this.clone();
      if (t3)
        if (Object.keys(t3).length) {
          e3.$_terms.keys = e3.$_terms.keys ? e3.$_terms.keys.filter((e4) => !t3.hasOwnProperty(e4.key)) : new f2.Keys();
          for (const r3 in t3)
            v2.tryWithPath(() => e3.$_terms.keys.push({ key: r3, schema: this.$_compile(t3[r3]) }), r3);
        } else
          e3.$_terms.keys = new f2.Keys();
      else
        e3.$_terms.keys = null;
      return e3.$_mutateRebuild();
    } }, length: { method(e3) {
      return this.$_addRule({ name: "length", args: { limit: e3 }, operator: "=" });
    }, validate: (e3, t3, { limit: r3 }, { name: n3, operator: i3, args: a3 }) => v2.compare(Object.keys(e3).length, r3, i3) ? e3 : t3.error("object." + n3, { limit: a3.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: v2.limit, message: "must be a positive integer" }] }, max: { method(e3) {
      return this.$_addRule({ name: "max", method: "length", args: { limit: e3 }, operator: "<=" });
    } }, min: { method(e3) {
      return this.$_addRule({ name: "min", method: "length", args: { limit: e3 }, operator: ">=" });
    } }, nand: { method(...e3) {
      return v2.verifyFlat(e3, "nand"), f2.dependency(this, "nand", null, e3);
    } }, or: { method(...e3) {
      return v2.verifyFlat(e3, "or"), f2.dependency(this, "or", null, e3);
    } }, oxor: { method(...e3) {
      return f2.dependency(this, "oxor", null, e3);
    } }, pattern: { method(e3, t3, r3 = {}) {
      var n3 = e3 instanceof RegExp;
      n3 || (e3 = this.$_compile(e3, { appendPath: true })), l2(t3 !== void 0, "Invalid rule"), v2.assertOptions(r3, ["fallthrough", "matches"]), n3 && l2(!e3.flags.includes("g") && !e3.flags.includes("y"), "pattern should not use global or sticky mode"), t3 = this.$_compile(t3, { appendPath: true });
      const i3 = this.clone();
      i3.$_terms.patterns = i3.$_terms.patterns || [];
      const a3 = { [n3 ? "regex" : "schema"]: e3, rule: t3 };
      return r3.matches && (a3.matches = this.$_compile(r3.matches), a3.matches.type !== "array" && (a3.matches = a3.matches.$_root.array().items(a3.matches)), i3.$_mutateRegister(a3.matches), i3.$_setFlag("_hasPatternMatch", true, { clone: false })), r3.fallthrough && (a3.fallthrough = true), i3.$_terms.patterns.push(a3), i3.$_mutateRegister(t3), i3;
    } }, ref: { method() {
      return this.$_addRule("ref");
    }, validate: (e3, t3) => u2.isRef(e3) ? e3 : t3.error("object.refType", { value: e3 }) }, regex: { method() {
      return this.$_addRule("regex");
    }, validate: (e3, t3) => e3 instanceof RegExp ? e3 : t3.error("object.regex", { value: e3 }) }, rename: { method(e3, t3, r3 = {}) {
      l2(typeof e3 == "string" || e3 instanceof RegExp, "Rename missing the from argument"), l2(typeof t3 == "string" || t3 instanceof h2, "Invalid rename to argument"), l2(t3 !== e3, "Cannot rename key to same name:", e3), v2.assertOptions(r3, ["alias", "ignoreUndefined", "override", "multiple"]);
      const n3 = this.clone();
      n3.$_terms.renames = n3.$_terms.renames || [];
      for (const t4 of n3.$_terms.renames)
        l2(t4.from !== e3, "Cannot rename the same key multiple times");
      return t3 instanceof h2 && n3.$_mutateRegister(t3), n3.$_terms.renames.push({ from: e3, to: t3, options: i2(f2.renameDefaults, r3) }), n3;
    } }, schema: { method(e3 = "any") {
      return this.$_addRule({ name: "schema", args: { type: e3 } });
    }, validate: (e3, t3, { type: r3 }) => !v2.isSchema(e3) || r3 !== "any" && e3.type !== r3 ? t3.error("object.schema", { type: r3 }) : e3 }, unknown: { method(e3) {
      return this.$_setFlag("unknown", e3 !== false);
    } }, with: { method(e3, t3, r3 = {}) {
      return f2.dependency(this, "with", e3, t3, r3);
    } }, without: { method(e3, t3, r3 = {}) {
      return f2.dependency(this, "without", e3, t3, r3);
    } }, xor: { method(...e3) {
      return v2.verifyFlat(e3, "xor"), f2.dependency(this, "xor", null, e3);
    } } }, overrides: { default(e3, t3) {
      return e3 === void 0 && (e3 = v2.symbols.deepDefault), this.$_parent("default", e3, t3);
    } }, rebuild(e3) {
      if (e3.$_terms.keys) {
        const t3 = new a2.Sorter();
        for (const r3 of e3.$_terms.keys)
          v2.tryWithPath(() => t3.add(r3, { after: r3.schema.$_rootReferences(), group: r3.key }), r3.key);
        e3.$_terms.keys = new f2.Keys(...t3.nodes);
      }
    }, manifest: { build(e3, t3) {
      if (t3.keys && (e3 = e3.keys(t3.keys)), t3.dependencies)
        for (var { rel: r3, key: n3 = null, peers: i3, options: a3 } of t3.dependencies)
          e3 = f2.dependency(e3, r3, n3, i3, a3);
      if (t3.patterns)
        for (var { regex: o3, schema: s2, rule: l3, fallthrough: c3, matches: u3 } of t3.patterns)
          e3 = e3.pattern(o3 || s2, l3, { fallthrough: c3, matches: u3 });
      if (t3.renames)
        for (var { from: h3, to: d2, options: p2 } of t3.renames)
          e3 = e3.rename(h3, d2, p2);
      return e3;
    } }, messages: { "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}", "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}', "object.base": "{{#label}} must be of type {{#type}}", "object.instance": "{{#label}} must be an instance of {{:#type}}", "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}', "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}', "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}', "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}", "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}", "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}", "object.pattern.match": "{{#label}} keys failed to match pattern requirements", "object.refType": "{{#label}} must be a Joi reference", "object.regex": "{{#label}} must be a RegExp object", "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}", "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists", "object.schema": "{{#label}} must be a Joi schema of {{#type}} type", "object.unknown": "{{#label}} is not allowed", "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}", "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}", "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}" } }), f2.clone = function(t3, e3) {
      if (typeof t3 == "object") {
        if (e3.nonEnumerables)
          return n2(t3, { shallow: true });
        const r4 = Object.create(Object.getPrototypeOf(t3));
        return Object.assign(r4, t3), r4;
      }
      const r3 = function(...e4) {
        return t3.apply(this, e4);
      };
      return r3.prototype = n2(t3.prototype), Object.defineProperty(r3, "name", { value: t3.name, writable: false }), Object.defineProperty(r3, "length", { value: t3.length, writable: false }), Object.assign(r3, t3), r3;
    }, f2.dependency = function(e3, t3, r3, n3, i3) {
      l2(r3 === null || typeof r3 == "string", t3, "key must be a strings"), i3 = i3 || (1 < n3.length && typeof n3[n3.length - 1] == "object" ? n3.pop() : {}), v2.assertOptions(i3, ["separator"]), n3 = [].concat(n3);
      const a3 = v2.default(i3.separator, "."), o3 = [];
      for (const e4 of n3)
        l2(typeof e4 == "string", t3, "peers must be strings"), o3.push(c2.ref(e4, { separator: a3, ancestor: 0, prefix: false }));
      r3 !== null && (r3 = c2.ref(r3, { separator: a3, ancestor: 0, prefix: false }));
      const s2 = e3.clone();
      return s2.$_terms.dependencies = s2.$_terms.dependencies || [], s2.$_terms.dependencies.push(new f2.Dependency(t3, r3, o3, n3)), s2;
    }, f2.dependencies = { and(e3, t3, r3, n3, i3) {
      const a3 = [], o3 = [], s2 = t3.peers.length;
      for (const e4 of t3.peers)
        (e4.resolve(r3, n3, i3, null, { shadow: false }) === void 0 ? a3 : o3).push(e4.key);
      if (a3.length !== s2 && o3.length !== s2)
        return { code: "object.and", context: { present: o3, presentWithLabels: f2.keysToLabels(e3, o3), missing: a3, missingWithLabels: f2.keysToLabels(e3, a3) } };
    }, nand(e3, t3, r3, n3, i3) {
      const a3 = [];
      for (const e4 of t3.peers)
        e4.resolve(r3, n3, i3, null, { shadow: false }) !== void 0 && a3.push(e4.key);
      if (a3.length === t3.peers.length) {
        var o3 = t3.paths[0], t3 = t3.paths.slice(1);
        return { code: "object.nand", context: { main: o3, mainWithLabel: f2.keysToLabels(e3, o3), peers: t3, peersWithLabels: f2.keysToLabels(e3, t3) } };
      }
    }, or(e3, t3, r3, n3, i3) {
      for (const e4 of t3.peers)
        if (e4.resolve(r3, n3, i3, null, { shadow: false }) !== void 0)
          return;
      return { code: "object.missing", context: { peers: t3.paths, peersWithLabels: f2.keysToLabels(e3, t3.paths) } };
    }, oxor(e3, t3, r3, n3, i3) {
      const a3 = [];
      for (const e4 of t3.peers)
        e4.resolve(r3, n3, i3, null, { shadow: false }) !== void 0 && a3.push(e4.key);
      if (a3.length && a3.length !== 1) {
        const o3 = { peers: t3.paths, peersWithLabels: f2.keysToLabels(e3, t3.paths) };
        return o3.present = a3, o3.presentWithLabels = f2.keysToLabels(e3, a3), { code: "object.oxor", context: o3 };
      }
    }, with(e3, t3, r3, n3, i3) {
      for (const a3 of t3.peers)
        if (a3.resolve(r3, n3, i3, null, { shadow: false }) === void 0)
          return { code: "object.with", context: { main: t3.key.key, mainWithLabel: f2.keysToLabels(e3, t3.key.key), peer: a3.key, peerWithLabel: f2.keysToLabels(e3, a3.key) } };
    }, without(e3, t3, r3, n3, i3) {
      for (const a3 of t3.peers)
        if (a3.resolve(r3, n3, i3, null, { shadow: false }) !== void 0)
          return { code: "object.without", context: { main: t3.key.key, mainWithLabel: f2.keysToLabels(e3, t3.key.key), peer: a3.key, peerWithLabel: f2.keysToLabels(e3, a3.key) } };
    }, xor(e3, t3, r3, n3, i3) {
      const a3 = [];
      for (const e4 of t3.peers)
        e4.resolve(r3, n3, i3, null, { shadow: false }) !== void 0 && a3.push(e4.key);
      if (a3.length !== 1) {
        const o3 = { peers: t3.paths, peersWithLabels: f2.keysToLabels(e3, t3.paths) };
        return a3.length === 0 ? { code: "object.missing", context: o3 } : (o3.present = a3, o3.presentWithLabels = f2.keysToLabels(e3, a3), { code: "object.xor", context: o3 });
      }
    } }, f2.keysToLabels = function(t3, e3) {
      return Array.isArray(e3) ? e3.map((e4) => t3.$_mapLabels(e4)) : t3.$_mapLabels(e3);
    }, f2.rename = function(t3, r3, n3, i3, a3) {
      const o3 = {};
      for (const l3 of t3.$_terms.renames) {
        const e3 = [], c3 = typeof l3.from != "string";
        if (c3) {
          for (const t4 in r3)
            if ((r3[t4] !== void 0 || !l3.options.ignoreUndefined) && t4 !== l3.to) {
              const n4 = l3.from.exec(t4);
              n4 && e3.push({ from: t4, to: l3.to, match: n4 });
            }
        } else
          !Object.prototype.hasOwnProperty.call(r3, l3.from) || r3[l3.from] === void 0 && l3.options.ignoreUndefined || e3.push(l3);
        for (const u3 of e3) {
          var s2 = u3.from;
          let e4 = u3.to;
          if (e4 instanceof h2 && (e4 = e4.render(r3, n3, i3, u3.match)), s2 !== e4) {
            if (!l3.options.multiple && o3[e4] && (a3.push(t3.$_createError("object.rename.multiple", r3, { from: s2, to: e4, pattern: c3 }, n3, i3)), i3.abortEarly))
              return false;
            if (Object.prototype.hasOwnProperty.call(r3, e4) && !l3.options.override && !o3[e4] && (a3.push(t3.$_createError("object.rename.override", r3, { from: s2, to: e4, pattern: c3 }, n3, i3)), i3.abortEarly))
              return false;
            r3[s2] === void 0 ? delete r3[e4] : r3[e4] = r3[s2], o3[e4] = true, l3.options.alias || delete r3[s2];
          }
        }
      }
      return true;
    }, f2.unknown = function(r3, n3, i3, a3, o3, s2) {
      if (r3.$_terms.patterns) {
        let t3 = false;
        const u3 = r3.$_terms.patterns.map((e3) => {
          if (e3.matches)
            return t3 = true, [];
        }), v3 = [n3, ...o3.ancestors];
        for (const h3 of i3) {
          const d2 = n3[h3], y2 = [...o3.path, h3];
          for (let e3 = 0; e3 < r3.$_terms.patterns.length; ++e3) {
            const p2 = r3.$_terms.patterns[e3];
            if (p2.regex) {
              const r4 = p2.regex.test(h3);
              if (o3.mainstay.tracer.debug(o3, "rule", "pattern.".concat(e3), r4 ? "pass" : "error"), !r4)
                continue;
            } else if (!p2.schema.$_match(h3, o3.nest(p2.schema, "pattern.".concat(e3)), s2))
              continue;
            i3.delete(h3);
            var l3 = o3.localize(y2, v3, { schema: p2.rule, key: h3 }), l3 = p2.rule.$_validate(d2, l3, s2);
            if (l3.errors) {
              if (s2.abortEarly)
                return { value: n3, errors: l3.errors };
              a3.push(...l3.errors);
            }
            if (p2.matches && u3[e3].push(h3), n3[h3] = l3.value, !p2.fallthrough)
              break;
          }
        }
        if (t3)
          for (let e3 = 0; e3 < u3.length; ++e3) {
            var c3 = u3[e3];
            if (c3) {
              const f3 = r3.$_terms.patterns[e3].matches, m2 = o3.localize(o3.path, v3, f3), g2 = f3.$_validate(c3, m2, s2);
              if (g2.errors) {
                const i4 = y.details(g2.errors, { override: false });
                i4.matches = c3;
                c3 = r3.$_createError("object.pattern.match", n3, i4, o3, s2);
                if (s2.abortEarly)
                  return { value: n3, errors: c3 };
                a3.push(c3);
              }
            }
          }
      }
      if (i3.size && (r3.$_terms.keys || r3.$_terms.patterns)) {
        if (s2.stripUnknown && !r3._flags.unknown || s2.skipFunctions) {
          const r4 = !(!s2.stripUnknown || s2.stripUnknown !== true && !s2.stripUnknown.objects);
          for (const a4 of i3)
            r4 ? (delete n3[a4], i3.delete(a4)) : typeof n3[a4] == "function" && i3.delete(a4);
        }
        if (!v2.default(r3._flags.unknown, s2.allowUnknown))
          for (const e3 of i3) {
            const i4 = o3.localize([...o3.path, e3], []), t3 = r3.$_createError("object.unknown", n3[e3], { child: e3 }, i4, s2, { flags: false });
            if (s2.abortEarly)
              return { value: n3, errors: t3 };
            a3.push(t3);
          }
      }
    }, f2.Dependency = class {
      constructor(e3, t3, r3, n3) {
        this.rel = e3, this.key = t3, this.peers = r3, this.paths = n3;
      }
      describe() {
        const e3 = { rel: this.rel, peers: this.paths };
        return this.key !== null && (e3.key = this.key.key), this.peers[0].separator !== "." && (e3.options = { separator: this.peers[0].separator }), e3;
      }
    }, f2.Keys = class extends Array {
      concat(e3) {
        const t3 = this.slice(), r3 = new Map();
        for (let e4 = 0; e4 < t3.length; ++e4)
          r3.set(t3[e4].key, e4);
        for (const n3 of e3) {
          const e4 = n3.key, i3 = r3.get(e4);
          i3 !== void 0 ? t3[i3] = { key: e4, schema: t3[i3].schema.concat(n3.schema) } : t3.push(n3);
        }
        return t3;
      }
    };
  }, 8785: (e2, t2, r2) => {
    const o2 = r2(375), n2 = r2(8068), i2 = r2(8160), a2 = r2(3292), s2 = r2(6354), l2 = {};
    e2.exports = n2.extend({ type: "link", properties: { schemaChain: true }, terms: { link: { init: null, manifest: "single", register: false } }, args: (e3, t3) => e3.ref(t3), validate(e3, { schema: t3, state: r3, prefs: n3 }) {
      o2(t3.$_terms.link, "Uninitialized link schema");
      const i3 = l2.generate(t3, e3, r3, n3), a3 = t3.$_terms.link[0].ref;
      return i3.$_validate(e3, r3.nest(i3, "link:".concat(a3.display, ":").concat(i3.type)), n3);
    }, generate: (e3, t3, r3, n3) => l2.generate(e3, t3, r3, n3), rules: { ref: { method(e3) {
      o2(!this.$_terms.link, "Cannot reinitialize schema"), e3 = a2.ref(e3), o2(e3.type === "value" || e3.type === "local", "Invalid reference type:", e3.type), o2(e3.type === "local" || e3.ancestor === "root" || 0 < e3.ancestor, "Link cannot reference itself");
      const t3 = this.clone();
      return t3.$_terms.link = [{ ref: e3 }], t3;
    } }, relative: { method(e3 = true) {
      return this.$_setFlag("relative", e3);
    } } }, overrides: { concat(e3) {
      o2(this.$_terms.link, "Uninitialized link schema"), o2(i2.isSchema(e3), "Invalid schema object"), o2(e3.type !== "link", "Cannot merge type link with another link");
      const t3 = this.clone();
      return t3.$_terms.whens || (t3.$_terms.whens = []), t3.$_terms.whens.push({ concat: e3 }), t3.$_mutateRebuild();
    } }, manifest: { build: (e3, t3) => (o2(t3.link, "Invalid link description missing link"), e3.ref(t3.link)) } }), l2.generate = function(e3, t3, r3, n3) {
      let i3 = r3.mainstay.links.get(e3);
      if (i3)
        return i3._generate(t3, r3, n3).schema;
      const a3 = e3.$_terms.link[0].ref, { perspective: o3, path: s3 } = l2.perspective(a3, r3);
      l2.assert(o3, "which is outside of schema boundaries", a3, e3, r3, n3);
      try {
        i3 = s3.length ? o3.$_reach(s3) : o3;
      } catch (t4) {
        l2.assert(false, "to non-existing schema", a3, e3, r3, n3);
      }
      return l2.assert(i3.type !== "link", "which is another link", a3, e3, r3, n3), e3._flags.relative || r3.mainstay.links.set(e3, i3), i3._generate(t3, r3, n3).schema;
    }, l2.perspective = function(e3, t3) {
      if (e3.type !== "local")
        return e3.ancestor === "root" ? { perspective: t3.schemas[t3.schemas.length - 1].schema, path: e3.path } : { perspective: t3.schemas[e3.ancestor] && t3.schemas[e3.ancestor].schema, path: e3.path };
      for (var { schema: r3, key: n3 } of t3.schemas) {
        if ((r3._flags.id || n3) === e3.path[0])
          return { perspective: r3, path: e3.path.slice(1) };
        if (r3.$_terms.shared) {
          for (const t4 of r3.$_terms.shared)
            if (t4._flags.id === e3.path[0])
              return { perspective: t4, path: e3.path.slice(1) };
        }
      }
      return { perspective: null, path: null };
    }, l2.assert = function(e3, t3, r3, n3, i3, a3) {
      e3 || o2(false, '"'.concat(s2.label(n3._flags, i3, a3), '" contains link reference "').concat(r3.display, '" ').concat(t3));
    };
  }, 3832: (e2, t2, r2) => {
    const n2 = r2(375), i2 = r2(8068), o2 = r2(8160), a2 = { numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i, precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/ };
    e2.exports = i2.extend({ type: "number", flags: { unsafe: { default: false } }, coerce: { from: "string", method(e3, { schema: t3, error: r3 }) {
      var n3 = e3.match(a2.numberRx);
      if (n3) {
        e3 = e3.trim();
        const i3 = { value: parseFloat(e3) };
        if (i3.value === 0 && (i3.value = 0), !t3._flags.unsafe)
          if (e3.match(/e/i)) {
            if (a2.normalizeExponent("".concat(i3.value / Math.pow(10, n3[1]), "e").concat(n3[1])) !== a2.normalizeExponent(e3))
              return i3.errors = r3("number.unsafe"), i3;
          } else {
            const t4 = i3.value.toString();
            if (t4.match(/e/i))
              return i3;
            if (t4 !== a2.normalizeDecimal(e3))
              return i3.errors = r3("number.unsafe"), i3;
          }
        return i3;
      }
    } }, validate(e3, { schema: t3, error: r3, prefs: n3 }) {
      if (e3 === 1 / 0 || e3 === -1 / 0)
        return { value: e3, errors: r3("number.infinity") };
      if (!o2.isNumber(e3))
        return { value: e3, errors: r3("number.base") };
      const i3 = { value: e3 };
      if (n3.convert) {
        const e4 = t3.$_getRule("precision");
        if (e4) {
          const t4 = Math.pow(10, e4.args.limit);
          i3.value = Math.round(i3.value * t4) / t4;
        }
      }
      return i3.value === 0 && (i3.value = 0), !t3._flags.unsafe && (e3 > Number.MAX_SAFE_INTEGER || e3 < Number.MIN_SAFE_INTEGER) && (i3.errors = r3("number.unsafe")), i3;
    }, rules: { compare: { method: false, validate: (e3, t3, { limit: r3 }, { name: n3, operator: i3, args: a3 }) => o2.compare(e3, r3, i3) ? e3 : t3.error("number." + n3, { limit: a3.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: o2.isNumber, message: "must be a number" }] }, greater: { method(e3) {
      return this.$_addRule({ name: "greater", method: "compare", args: { limit: e3 }, operator: ">" });
    } }, integer: { method() {
      return this.$_addRule("integer");
    }, validate: (e3, t3) => Math.trunc(e3) - e3 == 0 ? e3 : t3.error("number.integer") }, less: { method(e3) {
      return this.$_addRule({ name: "less", method: "compare", args: { limit: e3 }, operator: "<" });
    } }, max: { method(e3) {
      return this.$_addRule({ name: "max", method: "compare", args: { limit: e3 }, operator: "<=" });
    } }, min: { method(e3) {
      return this.$_addRule({ name: "min", method: "compare", args: { limit: e3 }, operator: ">=" });
    } }, multiple: { method(e3) {
      return this.$_addRule({ name: "multiple", args: { base: e3 } });
    }, validate: (e3, t3, { base: r3 }, n3) => e3 % r3 == 0 ? e3 : t3.error("number.multiple", { multiple: n3.args.base, value: e3 }), args: [{ name: "base", ref: true, assert: (e3) => typeof e3 == "number" && isFinite(e3) && 0 < e3, message: "must be a positive number" }], multi: true }, negative: { method() {
      return this.sign("negative");
    } }, port: { method() {
      return this.$_addRule("port");
    }, validate: (e3, t3) => Number.isSafeInteger(e3) && 0 <= e3 && e3 <= 65535 ? e3 : t3.error("number.port") }, positive: { method() {
      return this.sign("positive");
    } }, precision: { method(e3) {
      return n2(Number.isSafeInteger(e3), "limit must be an integer"), this.$_addRule({ name: "precision", args: { limit: e3 } });
    }, validate(e3, t3, { limit: r3 }) {
      var n3 = e3.toString().match(a2.precisionRx);
      return Math.max((n3[1] ? n3[1].length : 0) - (n3[2] ? parseInt(n3[2], 10) : 0), 0) <= r3 ? e3 : t3.error("number.precision", { limit: r3, value: e3 });
    }, convert: true }, sign: { method(e3) {
      return n2(["negative", "positive"].includes(e3), "Invalid sign", e3), this.$_addRule({ name: "sign", args: { sign: e3 } });
    }, validate: (e3, t3, { sign: r3 }) => r3 === "negative" && e3 < 0 || r3 === "positive" && 0 < e3 ? e3 : t3.error("number.".concat(r3)) }, unsafe: { method(e3 = true) {
      return n2(typeof e3 == "boolean", "enabled must be a boolean"), this.$_setFlag("unsafe", e3);
    } } }, cast: { string: { from: (e3) => typeof e3 == "number", to: (e3, t3) => e3.toString() } }, messages: { "number.base": "{{#label}} must be a number", "number.greater": "{{#label}} must be greater than {{#limit}}", "number.infinity": "{{#label}} cannot be infinity", "number.integer": "{{#label}} must be an integer", "number.less": "{{#label}} must be less than {{#limit}}", "number.max": "{{#label}} must be less than or equal to {{#limit}}", "number.min": "{{#label}} must be greater than or equal to {{#limit}}", "number.multiple": "{{#label}} must be a multiple of {{#multiple}}", "number.negative": "{{#label}} must be a negative number", "number.port": "{{#label}} must be a valid port", "number.positive": "{{#label}} must be a positive number", "number.precision": "{{#label}} must have no more than {{#limit}} decimal places", "number.unsafe": "{{#label}} must be a safe number" } }), a2.normalizeExponent = function(e3) {
      return e3.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
    }, a2.normalizeDecimal = function(e3) {
      return (e3 = (e3 = e3.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && e3.endsWith("0") ? e3.replace(/0+$/, "") : e3) === "-0" ? "0" : e3;
    };
  }, 8966: (e2, t2, r2) => {
    const n2 = r2(7824);
    e2.exports = n2.extend({ type: "object", cast: { map: { from: (e3) => e3 && typeof e3 == "object", to: (e3, t3) => new Map(Object.entries(e3)) } } });
  }, 7417: (e2, t2, r2) => {
    function a2(t3, e3) {
      var r3, n3 = Object.keys(t3);
      return Object.getOwnPropertySymbols && (r3 = Object.getOwnPropertySymbols(t3), e3 && (r3 = r3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), n3.push.apply(n3, r3)), n3;
    }
    function n2(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? a2(Object(i3), true).forEach(function(e4) {
          var t3, r3;
          t3 = n3, e4 = i3[r3 = e4], r3 in t3 ? Object.defineProperty(t3, r3, { value: e4, enumerable: true, configurable: true, writable: true }) : t3[r3] = e4;
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n3, Object.getOwnPropertyDescriptors(i3)) : a2(Object(i3)).forEach(function(e4) {
          Object.defineProperty(n3, e4, Object.getOwnPropertyDescriptor(i3, e4));
        });
      }
      return n3;
    }
    const o2 = r2(375), s2 = r2(5380), l2 = r2(1745), i2 = r2(9959), c2 = r2(6064), u2 = r2(9926), h2 = r2(5752), d2 = r2(8068), p2 = r2(8160), f2 = { tlds: u2 instanceof Set && { tlds: { allow: u2, deny: null } }, base64Regex: { true: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ }, false: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/ } }, dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/, hexRegex: /^[a-f0-9]+$/i, ipRegex: i2.regex().regex, isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/, guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" }, guidVersions: { uuidv1: "1", uuidv2: "2", uuidv3: "3", uuidv4: "4", uuidv5: "5" }, guidSeparators: new Set([void 0, true, false, "-", ":"]), normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"] };
    e2.exports = d2.extend({ type: "string", flags: { insensitive: { default: false }, truncate: { default: false } }, terms: { replacements: { init: null } }, coerce: { from: "string", method(t3, { schema: r3, state: n3, prefs: i3 }) {
      const a3 = r3.$_getRule("normalize");
      a3 && (t3 = t3.normalize(a3.args.form));
      var e3 = r3.$_getRule("case");
      e3 && (t3 = e3.args.direction === "upper" ? t3.toLocaleUpperCase() : t3.toLocaleLowerCase());
      e3 = r3.$_getRule("trim");
      if (e3 && e3.args.enabled && (t3 = t3.trim()), r3.$_terms.replacements)
        for (const n4 of r3.$_terms.replacements)
          t3 = t3.replace(n4.pattern, n4.replacement);
      e3 = r3.$_getRule("hex");
      if (e3 && e3.args.options.byteAligned && t3.length % 2 != 0 && (t3 = "0".concat(t3)), r3.$_getRule("isoDate")) {
        const r4 = f2.isoDate(t3);
        r4 && (t3 = r4);
      }
      if (r3._flags.truncate) {
        const a4 = r3.$_getRule("max");
        if (a4) {
          let e4 = a4.args.limit;
          if (p2.isResolvable(e4) && (e4 = e4.resolve(t3, n3, i3), !p2.limit(e4)))
            return { value: t3, errors: r3.$_createError("any.ref", e4, { ref: a4.args.limit, arg: "limit", reason: "must be a positive integer" }, n3, i3) };
          t3 = t3.slice(0, e4);
        }
      }
      return { value: t3 };
    } }, validate: (e3, { error: t3 }) => typeof e3 != "string" ? { value: e3, errors: t3("string.base") } : e3 === "" ? { value: e3, errors: t3("string.empty") } : void 0, rules: { alphanum: { method() {
      return this.$_addRule("alphanum");
    }, validate: (e3, t3) => /^[a-zA-Z0-9]+$/.test(e3) ? e3 : t3.error("string.alphanum") }, base64: { method(e3 = {}) {
      return p2.assertOptions(e3, ["paddingRequired", "urlSafe"]), e3 = n2({ urlSafe: false, paddingRequired: true }, e3), o2(typeof e3.paddingRequired == "boolean", "paddingRequired must be boolean"), o2(typeof e3.urlSafe == "boolean", "urlSafe must be boolean"), this.$_addRule({ name: "base64", args: { options: e3 } });
    }, validate: (e3, t3, { options: r3 }) => f2.base64Regex[r3.paddingRequired][r3.urlSafe].test(e3) ? e3 : t3.error("string.base64") }, case: { method(e3) {
      return o2(["lower", "upper"].includes(e3), "Invalid case:", e3), this.$_addRule({ name: "case", args: { direction: e3 } });
    }, validate: (e3, t3, { direction: r3 }) => r3 === "lower" && e3 === e3.toLocaleLowerCase() || r3 === "upper" && e3 === e3.toLocaleUpperCase() ? e3 : t3.error("string.".concat(r3, "case")), convert: true }, creditCard: { method() {
      return this.$_addRule("creditCard");
    }, validate(e3, t3) {
      let r3 = e3.length, n3 = 0, i3 = 1;
      for (; r3--; ) {
        const t4 = e3.charAt(r3) * i3;
        n3 += t4 - 9 * (9 < t4), i3 ^= 3;
      }
      return 0 < n3 && n3 % 10 == 0 ? e3 : t3.error("string.creditCard");
    } }, dataUri: { method(e3 = {}) {
      return p2.assertOptions(e3, ["paddingRequired"]), e3 = n2({ paddingRequired: true }, e3), o2(typeof e3.paddingRequired == "boolean", "paddingRequired must be boolean"), this.$_addRule({ name: "dataUri", args: { options: e3 } });
    }, validate(e3, t3, { options: r3 }) {
      var n3 = e3.match(f2.dataUriRegex);
      if (n3) {
        if (!n3[2])
          return e3;
        if (n3[2] !== "base64")
          return e3;
        if (f2.base64Regex[r3.paddingRequired].false.test(n3[3]))
          return e3;
      }
      return t3.error("string.dataUri");
    } }, domain: { method(e3) {
      e3 && p2.assertOptions(e3, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
      var t3 = f2.addressOptions(e3);
      return this.$_addRule({ name: "domain", args: { options: e3 }, address: t3 });
    }, validate: (e3, t3, r3, { address: n3 }) => s2.isValid(e3, n3) ? e3 : t3.error("string.domain") }, email: { method(e3 = {}) {
      p2.assertOptions(e3, ["allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), o2(e3.multiple === void 0 || typeof e3.multiple == "boolean", "multiple option must be an boolean");
      var t3 = f2.addressOptions(e3), r3 = new RegExp("\\s*[".concat(e3.separator ? c2(e3.separator) : ",", "]\\s*"));
      return this.$_addRule({ name: "email", args: { options: e3 }, regex: r3, address: t3 });
    }, validate(e3, t3, { options: r3 }, { regex: n3, address: i3 }) {
      const a3 = r3.multiple ? e3.split(n3) : [e3], o3 = [];
      for (const e4 of a3)
        l2.isValid(e4, i3) || o3.push(e4);
      return o3.length ? t3.error("string.email", { value: e3, invalids: o3 }) : e3;
    } }, guid: { alias: "uuid", method(e3 = {}) {
      p2.assertOptions(e3, ["version", "separator"]);
      let t3 = "";
      if (e3.version) {
        const n4 = [].concat(e3.version);
        o2(1 <= n4.length, "version must have at least 1 valid version specified");
        const i4 = new Set();
        for (let e4 = 0; e4 < n4.length; ++e4) {
          const a3 = n4[e4];
          o2(typeof a3 == "string", "version at position " + e4 + " must be a string");
          var r3 = f2.guidVersions[a3.toLowerCase()];
          o2(r3, "version at position " + e4 + " must be one of " + Object.keys(f2.guidVersions).join(", ")), o2(!i4.has(r3), "version at position " + e4 + " must not be a duplicate"), t3 += r3, i4.add(r3);
        }
      }
      o2(f2.guidSeparators.has(e3.separator), 'separator must be one of true, false, "-", or ":"');
      const n3 = e3.separator === void 0 ? "[:-]?" : e3.separator === true ? "[:-]" : e3.separator === false ? "[]?" : "\\".concat(e3.separator), i3 = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}(".concat(n3, ")[0-9A-F]{4}\\2?[").concat(t3 || "0-9A-F", "][0-9A-F]{3}\\2?[").concat(t3 ? "89AB" : "0-9A-F", "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"), "i");
      return this.$_addRule({ name: "guid", args: { options: e3 }, regex: i3 });
    }, validate(e3, t3, r3, { regex: n3 }) {
      n3 = n3.exec(e3);
      return !n3 || f2.guidBrackets[n3[1]] !== n3[n3.length - 1] ? t3.error("string.guid") : e3;
    } }, hex: { method(e3 = {}) {
      return p2.assertOptions(e3, ["byteAligned"]), e3 = n2({ byteAligned: false }, e3), o2(typeof e3.byteAligned == "boolean", "byteAligned must be boolean"), this.$_addRule({ name: "hex", args: { options: e3 } });
    }, validate: (e3, t3, { options: r3 }) => f2.hexRegex.test(e3) ? r3.byteAligned && e3.length % 2 != 0 ? t3.error("string.hexAlign") : e3 : t3.error("string.hex") }, hostname: { method() {
      return this.$_addRule("hostname");
    }, validate: (e3, t3) => s2.isValid(e3, { minDomainSegments: 1 }) || f2.ipRegex.test(e3) ? e3 : t3.error("string.hostname") }, insensitive: { method() {
      return this.$_setFlag("insensitive", true);
    } }, ip: { method(e3 = {}) {
      p2.assertOptions(e3, ["cidr", "version"]);
      var { cidr: t3, versions: r3, regex: n3 } = i2.regex(e3), r3 = e3.version ? r3 : void 0;
      return this.$_addRule({ name: "ip", args: { options: { cidr: t3, version: r3 } }, regex: n3 });
    }, validate: (e3, t3, { options: r3 }, { regex: n3 }) => n3.test(e3) ? e3 : r3.version ? t3.error("string.ipVersion", { value: e3, cidr: r3.cidr, version: r3.version }) : t3.error("string.ip", { value: e3, cidr: r3.cidr }) }, isoDate: { method() {
      return this.$_addRule("isoDate");
    }, validate: (e3, { error: t3 }) => f2.isoDate(e3) ? e3 : t3("string.isoDate") }, isoDuration: { method() {
      return this.$_addRule("isoDuration");
    }, validate: (e3, t3) => f2.isoDurationRegex.test(e3) ? e3 : t3.error("string.isoDuration") }, length: { method(e3, t3) {
      return f2.length(this, "length", e3, "=", t3);
    }, validate(e3, t3, { limit: r3, encoding: n3 }, { name: i3, operator: a3, args: o3 }) {
      var s3 = !n3 && e3.length;
      return p2.compare(s3, r3, a3) ? e3 : t3.error("string." + i3, { limit: o3.limit, value: e3, encoding: n3 });
    }, args: [{ name: "limit", ref: true, assert: p2.limit, message: "must be a positive integer" }, "encoding"] }, lowercase: { method() {
      return this.case("lower");
    } }, max: { method(e3, t3) {
      return f2.length(this, "max", e3, "<=", t3);
    }, args: ["limit", "encoding"] }, min: { method(e3, t3) {
      return f2.length(this, "min", e3, ">=", t3);
    }, args: ["limit", "encoding"] }, normalize: { method(e3 = "NFC") {
      return o2(f2.normalizationForms.includes(e3), "normalization form must be one of " + f2.normalizationForms.join(", ")), this.$_addRule({ name: "normalize", args: { form: e3 } });
    }, validate: (e3, { error: t3 }, { form: r3 }) => e3 === e3.normalize(r3) ? e3 : t3("string.normalize", { value: e3, form: r3 }), convert: true }, pattern: { alias: "regex", method(e3, t3 = {}) {
      o2(e3 instanceof RegExp, "regex must be a RegExp"), o2(!e3.flags.includes("g") && !e3.flags.includes("y"), "regex should not use global or sticky mode"), typeof t3 == "string" && (t3 = { name: t3 }), p2.assertOptions(t3, ["invert", "name"]);
      var r3 = ["string.pattern", t3.invert ? ".invert" : "", t3.name ? ".name" : ".base"].join("");
      return this.$_addRule({ name: "pattern", args: { regex: e3, options: t3 }, errorCode: r3 });
    }, validate: (e3, t3, { regex: r3, options: n3 }, { errorCode: i3 }) => r3.test(e3) ^ n3.invert ? e3 : t3.error(i3, { name: n3.name, regex: r3, value: e3 }), args: ["regex", "options"], multi: true }, replace: { method(e3, t3) {
      typeof e3 == "string" && (e3 = new RegExp(c2(e3), "g")), o2(e3 instanceof RegExp, "pattern must be a RegExp"), o2(typeof t3 == "string", "replacement must be a String");
      const r3 = this.clone();
      return r3.$_terms.replacements || (r3.$_terms.replacements = []), r3.$_terms.replacements.push({ pattern: e3, replacement: t3 }), r3;
    } }, token: { method() {
      return this.$_addRule("token");
    }, validate: (e3, t3) => /^\w+$/.test(e3) ? e3 : t3.error("string.token") }, trim: { method(e3 = true) {
      return o2(typeof e3 == "boolean", "enabled must be a boolean"), this.$_addRule({ name: "trim", args: { enabled: e3 } });
    }, validate: (e3, t3, { enabled: r3 }) => r3 && e3 !== e3.trim() ? t3.error("string.trim") : e3, convert: true }, truncate: { method(e3 = true) {
      return o2(typeof e3 == "boolean", "enabled must be a boolean"), this.$_setFlag("truncate", e3);
    } }, uppercase: { method() {
      return this.case("upper");
    } }, uri: { method(e3 = {}) {
      p2.assertOptions(e3, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]), e3.domain && p2.assertOptions(e3.domain, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
      var { regex: t3, scheme: r3 } = h2.regex(e3), n3 = e3.domain ? f2.addressOptions(e3.domain) : null;
      return this.$_addRule({ name: "uri", args: { options: e3 }, regex: t3, domain: n3, scheme: r3 });
    }, validate(e3, t3, { options: r3 }, { regex: n3, domain: i3, scheme: a3 }) {
      if (["http:/", "https:/"].includes(e3))
        return t3.error("string.uri");
      n3 = n3.exec(e3);
      if (n3) {
        const o3 = n3[1] || n3[2];
        return !i3 || r3.allowRelative && !o3 || s2.isValid(o3, i3) ? e3 : t3.error("string.domain", { value: o3 });
      }
      return r3.relativeOnly ? t3.error("string.uriRelativeOnly") : r3.scheme ? t3.error("string.uriCustomScheme", { scheme: a3, value: e3 }) : t3.error("string.uri");
    } } }, manifest: { build(e3, t3) {
      if (t3.replacements)
        for (var { pattern: r3, replacement: n3 } of t3.replacements)
          e3 = e3.replace(r3, n3);
      return e3;
    } }, messages: { "string.alphanum": "{{#label}} must only contain alpha-numeric characters", "string.base": "{{#label}} must be a string", "string.base64": "{{#label}} must be a valid base64 string", "string.creditCard": "{{#label}} must be a credit card", "string.dataUri": "{{#label}} must be a valid dataUri string", "string.domain": "{{#label}} must contain a valid domain name", "string.email": "{{#label}} must be a valid email", "string.empty": "{{#label}} is not allowed to be empty", "string.guid": "{{#label}} must be a valid GUID", "string.hex": "{{#label}} must only contain hexadecimal characters", "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned", "string.hostname": "{{#label}} must be a valid hostname", "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR", "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR", "string.isoDate": "{{#label}} must be in iso format", "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration", "string.length": "{{#label}} length must be {{#limit}} characters long", "string.lowercase": "{{#label}} must only contain lowercase characters", "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long", "string.min": "{{#label}} length must be at least {{#limit}} characters long", "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form", "string.token": "{{#label}} must only contain alpha-numeric and underscore characters", "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}", "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern", "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}", "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern", "string.trim": "{{#label}} must not have leading or trailing whitespace", "string.uri": "{{#label}} must be a valid uri", "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern", "string.uriRelativeOnly": "{{#label}} must be a valid relative uri", "string.uppercase": "{{#label}} must only contain uppercase characters" } }), f2.addressOptions = function(e3) {
      if (!e3)
        return e3;
      if (o2(e3.minDomainSegments === void 0 || Number.isSafeInteger(e3.minDomainSegments) && 0 < e3.minDomainSegments, "minDomainSegments must be a positive integer"), o2(e3.maxDomainSegments === void 0 || Number.isSafeInteger(e3.maxDomainSegments) && 0 < e3.maxDomainSegments, "maxDomainSegments must be a positive integer"), e3.tlds === false)
        return e3;
      if (e3.tlds === true || e3.tlds === void 0)
        return o2(f2.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, f2.tlds);
      o2(typeof e3.tlds == "object", "tlds must be true, false, or an object");
      var t3 = e3.tlds.deny;
      if (t3)
        return Array.isArray(t3) && (e3 = Object.assign({}, e3, { tlds: { deny: new Set(t3) } })), o2(e3.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), o2(!e3.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), f2.validateTlds(e3.tlds.deny, "tlds.deny"), e3;
      t3 = e3.tlds.allow;
      return t3 ? t3 === true ? (o2(f2.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, f2.tlds)) : (Array.isArray(t3) && (e3 = Object.assign({}, e3, { tlds: { allow: new Set(t3) } })), o2(e3.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), f2.validateTlds(e3.tlds.allow, "tlds.allow"), e3) : e3;
    }, f2.validateTlds = function(e3, t3) {
      for (const r3 of e3)
        o2(s2.isValid(r3, { minDomainSegments: 1, maxDomainSegments: 1 }), "".concat(t3, " must contain valid top level domain names"));
    }, f2.isoDate = function(e3) {
      if (!p2.isIsoDate(e3))
        return null;
      /.*T.*[+-]\d\d$/.test(e3) && (e3 += "00");
      const t3 = new Date(e3);
      return isNaN(t3.getTime()) ? null : t3.toISOString();
    }, f2.length = function(e3, t3, r3, n3, i3) {
      return o2(!i3 || false, "Invalid encoding:", i3), e3.$_addRule({ name: t3, method: "length", args: { limit: r3, encoding: i3 }, operator: n3 });
    };
  }, 8826: (e2, t2, r2) => {
    const a2 = r2(375), n2 = r2(8068), i2 = {};
    i2.Map = class extends Map {
      slice() {
        return new i2.Map(this);
      }
    }, e2.exports = n2.extend({ type: "symbol", terms: { map: { init: new i2.Map() } }, coerce: { method(e3, { schema: t3, error: r3 }) {
      var n3 = t3.$_terms.map.get(e3);
      return n3 && (e3 = n3), t3._flags.only && typeof e3 != "symbol" ? { value: e3, errors: r3("symbol.map", { map: t3.$_terms.map }) } : { value: e3 };
    } }, validate(e3, { error: t3 }) {
      if (typeof e3 != "symbol")
        return { value: e3, errors: t3("symbol.base") };
    }, rules: { map: { method(e3) {
      e3 && !e3[Symbol.iterator] && typeof e3 == "object" && (e3 = Object.entries(e3)), a2(e3 && e3[Symbol.iterator], "Iterable must be an iterable or object");
      const t3 = this.clone(), r3 = [];
      for (const n3 of e3) {
        a2(n3 && n3[Symbol.iterator], "Entry must be an iterable");
        const [e4, i3] = n3;
        a2(typeof e4 != "object" && typeof e4 != "function" && typeof e4 != "symbol", "Key must not be of type object, function, or Symbol"), a2(typeof i3 == "symbol", "Value must be a Symbol"), t3.$_terms.map.set(e4, i3), r3.push(i3);
      }
      return t3.valid(...r3);
    } } }, manifest: { build: (e3, t3) => e3 = t3.map ? e3.map(t3.map) : e3 }, messages: { "symbol.base": "{{#label}} must be a symbol", "symbol.map": "{{#label}} must be one of {{#map}}" } });
  }, 8863: (e2, o2, t2) => {
    const s2 = t2(375), l2 = t2(8571), r2 = t2(738), c2 = t2(9621), p2 = t2(8160), u2 = t2(6354), h2 = t2(493), f2 = { result: Symbol("result") };
    o2.entry = function(e3, t3, r3) {
      let n2 = p2.defaults;
      r3 && (s2(r3.warnings === void 0, "Cannot override warnings preference in synchronous validation"), s2(r3.artifacts === void 0, "Cannot override artifacts preference in synchronous validation"), n2 = p2.preferences(p2.defaults, r3));
      t3 = f2.entry(e3, t3, n2);
      s2(!t3.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const i2 = { value: t3.value };
      return t3.error && (i2.error = t3.error), t3.mainstay.warnings.length && (i2.warning = u2.details(t3.mainstay.warnings)), t3.mainstay.debug && (i2.debug = t3.mainstay.debug), t3.mainstay.artifacts && (i2.artifacts = t3.mainstay.artifacts), i2;
    }, o2.entryAsync = function(i2, a2, o3) {
      return __async(this, null, function* () {
        let s3 = p2.defaults;
        o3 && (s3 = p2.preferences(p2.defaults, o3));
        const l3 = f2.entry(i2, a2, s3), e3 = l3.mainstay;
        if (l3.error)
          throw e3.debug && (l3.error.debug = e3.debug), l3.error;
        if (e3.externals.length) {
          let n2 = l3.value;
          for (const { method: a3, path: s4, label: l4 } of e3.externals) {
            let e4, t4, r3 = n2;
            s4.length && (e4 = s4[s4.length - 1], t4 = c2(n2, s4.slice(0, -1)), r3 = t4[e4]);
            try {
              const s5 = yield a3(r3, { prefs: o3 });
              if (s5 === void 0 || s5 === r3)
                continue;
              t4 ? t4[e4] = s5 : n2 = s5;
            } catch (i3) {
              throw i3.message += " (".concat(l4, ")"), i3;
            }
          }
          l3.value = n2;
        }
        if (!s3.warnings && !s3.debug && !s3.artifacts)
          return l3.value;
        const t3 = { value: l3.value };
        return e3.warnings.length && (t3.warning = u2.details(e3.warnings)), e3.debug && (t3.debug = e3.debug), e3.artifacts && (t3.artifacts = e3.artifacts), t3;
      });
    }, f2.entry = function(e3, t3, r3) {
      var { tracer: n2, cleanup: i2 } = f2.tracer(t3, r3), a2 = { externals: [], warnings: [], tracer: n2, debug: r3.debug ? [] : null, links: t3._ids._schemaChain ? new Map() : null }, n2 = t3._ids._schemaChain ? [{ schema: t3 }] : null, n2 = new h2([], [], { mainstay: a2, schemas: n2 }), n2 = o2.validate(e3, t3, n2, r3);
      i2 && t3.$_root.untrace();
      r3 = u2.process(n2.errors, e3, r3);
      return { value: n2.value, error: r3, mainstay: a2 };
    }, f2.tracer = function(e3, t3) {
      return e3.$_root._tracer ? { tracer: e3.$_root._tracer._register(e3) } : t3.debug ? (s2(e3.$_root.trace, "Debug mode not supported"), { tracer: e3.$_root.trace()._register(e3), cleanup: true }) : { tracer: f2.ignore };
    }, o2.validate = function(n2, i2, a2, o3, e3 = {}) {
      if ((i2 = i2.$_terms.whens ? i2._generate(n2, a2, o3).schema : i2)._preferences && (o3 = f2.prefs(i2, o3)), i2._cache && o3.cache) {
        const o4 = i2._cache.get(n2);
        if (a2.mainstay.tracer.debug(a2, "validate", "cached", !!o4), o4)
          return o4;
      }
      const s3 = (e4, t4, r4) => i2.$_createError(e4, n2, t4, r4 || a2, o3), t3 = { original: n2, prefs: o3, schema: i2, state: a2, error: s3, errorsArray: f2.errorsArray, warn: (e4, t4, r4) => a2.mainstay.warnings.push(s3(e4, t4, r4)), message: (e4, t4) => i2.$_createError("custom", n2, t4, a2, o3, { messages: e4 }) };
      a2.mainstay.tracer.entry(i2, a2);
      const r3 = i2._definition;
      if (r3.prepare && n2 !== void 0 && o3.convert) {
        const i3 = r3.prepare(n2, t3);
        if (i3) {
          if (a2.mainstay.tracer.value(a2, "prepare", n2, i3.value), i3.errors)
            return f2.finalize(i3.value, [].concat(i3.errors), t3);
          n2 = i3.value;
        }
      }
      if (r3.coerce && n2 !== void 0 && o3.convert && (!r3.coerce.from || r3.coerce.from.includes(typeof n2))) {
        const i3 = r3.coerce.method(n2, t3);
        if (i3) {
          if (a2.mainstay.tracer.value(a2, "coerced", n2, i3.value), i3.errors)
            return f2.finalize(i3.value, [].concat(i3.errors), t3);
          n2 = i3.value;
        }
      }
      const l3 = i2._flags.empty;
      l3 && l3.$_match(f2.trim(n2, i2), a2.nest(l3), p2.defaults) && (a2.mainstay.tracer.value(a2, "empty", n2, void 0), n2 = void 0);
      e3 = e3.presence || i2._flags.presence || (i2._flags._endedSwitch ? null : o3.presence);
      if (n2 === void 0) {
        if (e3 === "forbidden")
          return f2.finalize(n2, null, t3);
        if (e3 === "required")
          return f2.finalize(n2, [i2.$_createError("any.required", n2, null, a2, o3)], t3);
        if (e3 === "optional") {
          if (i2._flags.default !== p2.symbols.deepDefault)
            return f2.finalize(n2, null, t3);
          a2.mainstay.tracer.value(a2, "default", n2, {}), n2 = {};
        }
      } else if (e3 === "forbidden")
        return f2.finalize(n2, [i2.$_createError("any.unknown", n2, null, a2, o3)], t3);
      const c3 = [];
      if (i2._valids) {
        const u3 = i2._valids.get(n2, a2, o3, i2._flags.insensitive);
        if (u3)
          return o3.convert && (a2.mainstay.tracer.value(a2, "valids", n2, u3.value), n2 = u3.value), a2.mainstay.tracer.filter(i2, a2, "valid", u3), f2.finalize(n2, null, t3);
        if (i2._flags.only) {
          const u4 = i2.$_createError("any.only", n2, { valids: i2._valids.values({ display: true }) }, a2, o3);
          if (o3.abortEarly)
            return f2.finalize(n2, [u4], t3);
          c3.push(u4);
        }
      }
      if (i2._invalids) {
        const u3 = i2._invalids.get(n2, a2, o3, i2._flags.insensitive);
        if (u3) {
          a2.mainstay.tracer.filter(i2, a2, "invalid", u3);
          const s4 = i2.$_createError("any.invalid", n2, { invalids: i2._invalids.values({ display: true }) }, a2, o3);
          if (o3.abortEarly)
            return f2.finalize(n2, [s4], t3);
          c3.push(s4);
        }
      }
      if (r3.validate) {
        const i3 = r3.validate(n2, t3);
        if (i3 && (a2.mainstay.tracer.value(a2, "base", n2, i3.value), n2 = i3.value, i3.errors)) {
          if (!Array.isArray(i3.errors))
            return c3.push(i3.errors), f2.finalize(n2, c3, t3);
          if (i3.errors.length)
            return c3.push(...i3.errors), f2.finalize(n2, c3, t3);
        }
      }
      return i2._rules.length ? f2.rules(n2, c3, t3) : f2.finalize(n2, c3, t3);
    }, f2.rules = function(r3, n2, i2) {
      const { schema: a2, state: o3, prefs: s3 } = i2;
      for (const c3 of a2._rules) {
        const u3 = a2._definition.rules[c3.method];
        if (u3.convert && s3.convert)
          o3.mainstay.tracer.log(a2, o3, "rule", c3.name, "full");
        else {
          let e3, t3 = c3.args;
          if (c3._resolve.length) {
            t3 = Object.assign({}, t3);
            for (const n3 of c3._resolve) {
              const i3 = u3.argsByName.get(n3), h3 = t3[n3].resolve(r3, o3, s3), f3 = i3.normalize ? i3.normalize(h3) : h3, d2 = p2.validateArg(f3, null, i3);
              if (d2) {
                e3 = a2.$_createError("any.ref", h3, { arg: n3, ref: t3[n3], reason: d2 }, o3, s3);
                break;
              }
              t3[n3] = f3;
            }
          }
          e3 = e3 || u3.validate(r3, i2, t3, c3);
          var l3 = f2.rule(e3, c3);
          if (l3.errors)
            if (o3.mainstay.tracer.log(a2, o3, "rule", c3.name, "error"), c3.warn)
              o3.mainstay.warnings.push(...l3.errors);
            else {
              if (s3.abortEarly)
                return f2.finalize(r3, l3.errors, i2);
              n2.push(...l3.errors);
            }
          else
            o3.mainstay.tracer.log(a2, o3, "rule", c3.name, "pass"), o3.mainstay.tracer.value(o3, "rule", r3, l3.value, c3.name), r3 = l3.value;
        }
      }
      return f2.finalize(r3, n2, i2);
    }, f2.rule = function(e3, t3) {
      return e3 instanceof u2.Report ? (f2.error(e3, t3), { errors: [e3], value: null }) : Array.isArray(e3) && e3[p2.symbols.errors] ? (e3.forEach((e4) => f2.error(e4, t3)), { errors: e3, value: null }) : { errors: null, value: e3 };
    }, f2.error = function(e3, t3) {
      return t3.message && e3._setTemplate(t3.message), e3;
    }, f2.finalize = function(e3, t3, r3) {
      const { schema: n2, state: i2, prefs: a2 } = r3;
      if ((t3 = t3 || []).length) {
        const s3 = f2.default("failover", void 0, t3, r3);
        s3 !== void 0 && (i2.mainstay.tracer.value(i2, "failover", e3, s3), e3 = s3, t3 = []);
      }
      if (t3.length && n2._flags.error)
        if (typeof n2._flags.error == "function") {
          t3 = n2._flags.error(t3);
          for (const e4 of t3 = !Array.isArray(t3) ? [t3] : t3)
            s2(e4 instanceof Error || e4 instanceof u2.Report, "error() must return an Error object");
        } else
          t3 = [n2._flags.error];
      if (e3 === void 0) {
        const s3 = f2.default("default", e3, t3, r3);
        i2.mainstay.tracer.value(i2, "default", e3, s3), e3 = s3;
      }
      if (n2._flags.cast && e3 !== void 0) {
        const t4 = n2._definition.cast[n2._flags.cast];
        if (t4.from(e3)) {
          const s3 = t4.to(e3, r3);
          i2.mainstay.tracer.value(i2, "cast", e3, s3, n2._flags.cast), e3 = s3;
        }
      }
      if (n2.$_terms.externals && a2.externals && a2._externals !== false)
        for (const { method: e4 } of n2.$_terms.externals)
          i2.mainstay.externals.push({ method: e4, path: i2.path, label: u2.label(n2._flags, i2, a2) });
      const o3 = { value: e3, errors: t3.length ? t3 : null };
      return n2._flags.result && (o3.value = n2._flags.result === "strip" ? void 0 : r3.original, i2.mainstay.tracer.value(i2, n2._flags.result, e3, o3.value), i2.shadow(e3, n2._flags.result)), n2._cache && a2.cache !== false && !n2._refs.length && n2._cache.set(r3.original, o3), e3 === void 0 || o3.errors || n2._flags.artifact === void 0 || (i2.mainstay.artifacts = i2.mainstay.artifacts || new Map(), i2.mainstay.artifacts.has(n2._flags.artifact) || i2.mainstay.artifacts.set(n2._flags.artifact, []), i2.mainstay.artifacts.get(n2._flags.artifact).push(i2.path)), o3;
    }, f2.prefs = function(e3, t3) {
      var r3 = t3 === p2.defaults;
      return r3 && e3._preferences[p2.symbols.prefs] ? e3._preferences[p2.symbols.prefs] : (t3 = p2.preferences(t3, e3._preferences), r3 && (e3._preferences[p2.symbols.prefs] = t3), t3);
    }, f2.default = function(e3, t3, r3, n2) {
      const { schema: i2, state: a2, prefs: o3 } = n2, s3 = i2._flags[e3];
      if (o3.noDefaults || s3 === void 0)
        return t3;
      if (a2.mainstay.tracer.log(i2, a2, "rule", e3, "full"), !s3)
        return s3;
      if (typeof s3 == "function") {
        const t4 = s3.length ? [l2(a2.ancestors[0]), n2] : [];
        try {
          return s3(...t4);
        } catch (t5) {
          return void r3.push(i2.$_createError("any.".concat(e3), null, { error: t5 }, a2, o3));
        }
      }
      return typeof s3 != "object" ? s3 : s3[p2.symbols.literal] ? s3.literal : p2.isResolvable(s3) ? s3.resolve(t3, a2, o3) : l2(s3);
    }, f2.trim = function(e3, t3) {
      if (typeof e3 != "string")
        return e3;
      t3 = t3.$_getRule("trim");
      return t3 && t3.args.enabled ? e3.trim() : e3;
    }, f2.ignore = { active: false, debug: r2, entry: r2, filter: r2, log: r2, resolve: r2, value: r2 }, f2.errorsArray = function() {
      const e3 = [];
      return e3[p2.symbols.errors] = true, e3;
    };
  }, 2036: (e2, t2, r2) => {
    const n2 = r2(375), o2 = r2(9474), i2 = r2(8160), a2 = {};
    e2.exports = a2.Values = class {
      constructor(e3, t3) {
        this._values = new Set(e3), this._refs = new Set(t3), this._lowercase = a2.lowercases(e3), this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(e3, t3) {
        i2.isResolvable(e3) ? this._refs.has(e3) || (this._refs.add(e3), t3 && t3.register(e3)) : this.has(e3, null, null, false) || (this._values.add(e3), typeof e3 == "string" && this._lowercase.set(e3.toLowerCase(), e3));
      }
      static merge(e3, t3, r3) {
        if (e3 = e3 || new a2.Values(), t3) {
          if (t3._override)
            return t3.clone();
          for (const r4 of [...t3._values, ...t3._refs])
            e3.add(r4);
        }
        if (r3)
          for (const t4 of [...r3._values, ...r3._refs])
            e3.remove(t4);
        return e3.length ? e3 : null;
      }
      remove(e3) {
        i2.isResolvable(e3) ? this._refs.delete(e3) : (this._values.delete(e3), typeof e3 == "string" && this._lowercase.delete(e3.toLowerCase()));
      }
      has(e3, t3, r3, n3) {
        return !!this.get(e3, t3, r3, n3);
      }
      get(e3, t3, r3, n3) {
        if (!this.length)
          return false;
        if (this._values.has(e3))
          return { value: e3 };
        if (typeof e3 == "string" && e3 && n3) {
          const t4 = this._lowercase.get(e3.toLowerCase());
          if (t4)
            return { value: t4 };
        }
        if (!this._refs.size && typeof e3 != "object")
          return false;
        if (typeof e3 == "object") {
          for (const t4 of this._values)
            if (o2(t4, e3))
              return { value: t4 };
        }
        if (t3)
          for (const a3 of this._refs) {
            var i3 = a3.resolve(e3, t3, r3, null, { in: true });
            if (i3 !== void 0) {
              for (const t4 of a3.in && typeof i3 == "object" ? Array.isArray(i3) ? i3 : Object.keys(i3) : [i3])
                if (typeof t4 == typeof e3) {
                  if (n3 && e3 && typeof e3 == "string") {
                    if (t4.toLowerCase() === e3.toLowerCase())
                      return { value: t4, ref: a3 };
                  } else if (o2(t4, e3))
                    return { value: t4, ref: a3 };
                }
            }
          }
        return false;
      }
      override() {
        this._override = true;
      }
      values(e3) {
        if (e3 && e3.display) {
          const e4 = [];
          for (const t3 of [...this._values, ...this._refs])
            t3 !== void 0 && e4.push(t3);
          return e4;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const e3 = new a2.Values(this._values, this._refs);
        return e3._override = this._override, e3;
      }
      concat(e3) {
        n2(!e3._override, "Cannot concat override set of values");
        const t3 = new a2.Values([...this._values, ...e3._values], [...this._refs, ...e3._refs]);
        return t3._override = this._override, t3;
      }
      describe() {
        const e3 = [];
        this._override && e3.push({ override: true });
        for (const t3 of this._values.values())
          e3.push(t3 && typeof t3 == "object" ? { value: t3 } : t3);
        for (const r3 of this._refs.values())
          e3.push(r3.describe());
        return e3;
      }
    }, a2.Values.prototype[i2.symbols.values] = true, a2.Values.prototype.slice = a2.Values.prototype.clone, a2.lowercases = function(e3) {
      const t3 = new Map();
      if (e3)
        for (const r3 of e3)
          typeof r3 == "string" && t3.set(r3.toLowerCase(), r3);
      return t3;
    };
  }, 978: (e2, t2, r2) => {
    const l2 = r2(375), c2 = r2(8571), u2 = r2(1687), h2 = r2(9621), d2 = {};
    e2.exports = function(e3, t3, r3 = {}) {
      if (l2(e3 && typeof e3 == "object", "Invalid defaults value: must be an object"), l2(!t3 || t3 === true || typeof t3 == "object", "Invalid source value: must be true, falsy or an object"), l2(typeof r3 == "object", "Invalid options: must be an object"), !t3)
        return null;
      if (r3.shallow)
        return d2.applyToDefaultsWithShallow(e3, t3, r3);
      e3 = c2(e3);
      if (t3 === true)
        return e3;
      r3 = r3.nullOverride !== void 0 && r3.nullOverride;
      return u2(e3, t3, { nullOverride: r3, mergeArrays: false });
    }, d2.applyToDefaultsWithShallow = function(e3, t3, r3) {
      var n2, i2 = r3.shallow;
      l2(Array.isArray(i2), "Invalid keys");
      const a2 = new Map(), o2 = t3 === true ? null : new Set();
      for (n2 of i2) {
        n2 = Array.isArray(n2) ? n2 : n2.split(".");
        const l3 = h2(e3, n2);
        l3 && typeof l3 == "object" ? a2.set(l3, o2 && h2(t3, n2) || l3) : o2 && o2.add(n2);
      }
      var s2 = c2(e3, {}, a2);
      if (!o2)
        return s2;
      for (const e4 of o2)
        d2.reachCopy(s2, t3, e4);
      r3 = r3.nullOverride !== void 0 && r3.nullOverride;
      return u2(s2, t3, { nullOverride: r3, mergeArrays: false });
    }, d2.reachCopy = function(e3, t3, r3) {
      for (const e4 of r3) {
        if (!(e4 in t3))
          return;
        const r4 = t3[e4];
        if (typeof r4 != "object" || r4 === null)
          return;
        t3 = r4;
      }
      var n2 = t3;
      let i2 = e3;
      for (let e4 = 0; e4 < r3.length - 1; ++e4) {
        const t4 = r3[e4];
        typeof i2[t4] != "object" && (i2[t4] = {}), i2 = i2[t4];
      }
      i2[r3[r3.length - 1]] = n2;
    };
  }, 375: (e2, t2, r2) => {
    const n2 = r2(7916);
    e2.exports = function(e3, ...t3) {
      if (!e3) {
        if (t3.length === 1 && t3[0] instanceof Error)
          throw t3[0];
        throw new n2(t3);
      }
    };
  }, 8571: (e2, t2, r2) => {
    const i2 = r2(9621), s2 = r2(4277), l2 = r2(7043), c2 = { needsProtoHack: new Set([s2.set, s2.map, s2.weakSet, s2.weakMap]) };
    e2.exports = c2.clone = function(e3, t3 = {}, r3 = null) {
      if (typeof e3 != "object" || e3 === null)
        return e3;
      let n2 = c2.clone, i3 = r3;
      if (t3.shallow) {
        if (t3.shallow !== true)
          return c2.cloneWithShallow(e3, t3);
        n2 = (e4) => e4;
      } else if (i3) {
        const t4 = i3.get(e3);
        if (t4)
          return t4;
      } else
        i3 = new Map();
      var a2 = s2.getInternalProto(e3);
      if (a2 === s2.buffer)
        return false;
      if (a2 === s2.date)
        return new Date(e3.getTime());
      if (a2 === s2.regex)
        return new RegExp(e3);
      const o2 = c2.base(e3, a2, t3);
      if (o2 === e3)
        return e3;
      if (i3 && i3.set(e3, o2), a2 === s2.set)
        for (const r4 of e3)
          o2.add(n2(r4, t3, i3));
      else if (a2 === s2.map)
        for (const [r4, s3] of e3)
          o2.set(r4, n2(s3, t3, i3));
      for (const r4 of l2.keys(e3, t3))
        if (r4 !== "__proto__")
          if (a2 !== s2.array || r4 !== "length") {
            const l3 = Object.getOwnPropertyDescriptor(e3, r4);
            l3 ? l3.get || l3.set ? Object.defineProperty(o2, r4, l3) : l3.enumerable ? o2[r4] = n2(e3[r4], t3, i3) : Object.defineProperty(o2, r4, { enumerable: false, writable: true, configurable: true, value: n2(e3[r4], t3, i3) }) : Object.defineProperty(o2, r4, { enumerable: true, writable: true, configurable: true, value: n2(e3[r4], t3, i3) });
          } else
            o2.length = e3.length;
      return o2;
    }, c2.cloneWithShallow = function(e3, t3) {
      const r3 = t3.shallow;
      (t3 = Object.assign({}, t3)).shallow = false;
      const n2 = new Map();
      for (const t4 of r3) {
        const r4 = i2(e3, t4);
        typeof r4 != "object" && typeof r4 != "function" || n2.set(r4, r4);
      }
      return c2.clone(e3, t3, n2);
    }, c2.base = function(e3, t3, r3) {
      if (r3.prototype === false)
        return c2.needsProtoHack.has(t3) ? new t3.constructor() : t3 === s2.array ? [] : {};
      const n2 = Object.getPrototypeOf(e3);
      if (n2 && n2.isImmutable)
        return e3;
      if (t3 === s2.array) {
        const e4 = [];
        return n2 !== t3 && Object.setPrototypeOf(e4, n2), e4;
      }
      if (c2.needsProtoHack.has(t3)) {
        const e4 = new n2.constructor();
        return n2 !== t3 && Object.setPrototypeOf(e4, n2), e4;
      }
      return Object.create(n2);
    };
  }, 9474: (e2, t2, r2) => {
    const p2 = r2(4277), f2 = { mismatched: null };
    e2.exports = function(e3, t3, r3) {
      return r3 = Object.assign({ prototype: true }, r3), !!f2.isDeepEqual(e3, t3, r3, []);
    }, f2.isDeepEqual = function(t3, r3, e3, n2) {
      if (t3 === r3)
        return t3 !== 0 || 1 / t3 == 1 / r3;
      var i2 = typeof t3;
      if (i2 != typeof r3)
        return false;
      if (t3 === null || r3 === null)
        return false;
      if (i2 == "function") {
        if (!e3.deepFunction || t3.toString() !== r3.toString())
          return false;
      } else if (i2 != "object")
        return t3 != t3 && r3 != r3;
      i2 = f2.getSharedType(t3, r3, !!e3.prototype);
      switch (i2) {
        case p2.buffer:
          return false;
        case p2.promise:
          return t3 === r3;
        case p2.regex:
          return t3.toString() === r3.toString();
        case f2.mismatched:
          return false;
      }
      for (let e4 = n2.length - 1; 0 <= e4; --e4)
        if (n2[e4].isSame(t3, r3))
          return true;
      n2.push(new f2.SeenEntry(t3, r3));
      try {
        return !!f2.isDeepEqualObj(i2, t3, r3, e3, n2);
      } finally {
        n2.pop();
      }
    }, f2.getSharedType = function(e3, t3, r3) {
      if (r3)
        return Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3) ? f2.mismatched : p2.getInternalProto(e3);
      e3 = p2.getInternalProto(e3);
      return e3 !== p2.getInternalProto(t3) ? f2.mismatched : e3;
    }, f2.valueOf = function(e3) {
      const t3 = e3.valueOf;
      if (t3 === void 0)
        return e3;
      try {
        return t3.call(e3);
      } catch (e4) {
        return e4;
      }
    }, f2.hasOwnEnumerableProperty = function(e3, t3) {
      return Object.prototype.propertyIsEnumerable.call(e3, t3);
    }, f2.isSetSimpleEqual = function(e3, t3) {
      for (const r3 of Set.prototype.values.call(e3))
        if (!Set.prototype.has.call(t3, r3))
          return false;
      return true;
    }, f2.isDeepEqualObj = function(e3, t3, r3, n2, i2) {
      const { isDeepEqual: a2, valueOf: o2, hasOwnEnumerableProperty: s2 } = f2, { keys: l2, getOwnPropertySymbols: c2 } = Object;
      if (e3 === p2.array) {
        if (!n2.part) {
          if (t3.length !== r3.length)
            return false;
          for (let e4 = 0; e4 < t3.length; ++e4)
            if (!a2(t3[e4], r3[e4], n2, i2))
              return false;
          return true;
        }
        for (const d2 of t3)
          for (const t4 of r3)
            if (a2(d2, t4, n2, i2))
              return true;
      } else if (e3 === p2.set) {
        if (t3.size !== r3.size)
          return false;
        if (!f2.isSetSimpleEqual(t3, r3)) {
          const d2 = new Set(Set.prototype.values.call(r3));
          for (const r4 of Set.prototype.values.call(t3))
            if (!d2.delete(r4)) {
              let e4 = false;
              for (const p3 of d2)
                if (a2(r4, p3, n2, i2)) {
                  d2.delete(p3), e4 = true;
                  break;
                }
              if (!e4)
                return false;
            }
        }
      } else if (e3 === p2.map) {
        if (t3.size !== r3.size)
          return false;
        for (const [d2, p3] of Map.prototype.entries.call(t3)) {
          if (p3 === void 0 && !Map.prototype.has.call(r3, d2))
            return false;
          if (!a2(p3, Map.prototype.get.call(r3, d2), n2, i2))
            return false;
        }
      } else if (e3 === p2.error && (t3.name !== r3.name || t3.message !== r3.message))
        return false;
      var u2 = o2(t3), e3 = o2(r3);
      if ((t3 !== u2 || r3 !== e3) && !a2(u2, e3, n2, i2))
        return false;
      e3 = l2(t3);
      if (!n2.part && e3.length !== l2(r3).length && !n2.skip)
        return false;
      let h2 = 0;
      for (const d2 of e3)
        if (n2.skip && n2.skip.includes(d2))
          r3[d2] === void 0 && ++h2;
        else {
          if (!s2(r3, d2))
            return false;
          if (!a2(t3[d2], r3[d2], n2, i2))
            return false;
        }
      if (!n2.part && e3.length - h2 !== l2(r3).length)
        return false;
      if (n2.symbols !== false) {
        const d2 = c2(t3), p3 = new Set(c2(r3));
        for (const f3 of d2) {
          if (!n2.skip || !n2.skip.includes(f3)) {
            if (s2(t3, f3)) {
              if (!s2(r3, f3))
                return false;
              if (!a2(t3[f3], r3[f3], n2, i2))
                return false;
            } else if (s2(r3, f3))
              return false;
          }
          p3.delete(f3);
        }
        for (const d3 of p3)
          if (s2(r3, d3))
            return false;
      }
      return true;
    }, f2.SeenEntry = class {
      constructor(e3, t3) {
        this.obj = e3, this.ref = t3;
      }
      isSame(e3, t3) {
        return this.obj === e3 && this.ref === t3;
      }
    };
  }, 7916: (e2, t2, r2) => {
    const n2 = r2(8761);
    e2.exports = class extends Error {
      constructor(e3) {
        super(e3.filter((e4) => e4 !== "").map((e4) => typeof e4 == "string" ? e4 : e4 instanceof Error ? e4.message : n2(e4)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, t2.assert);
      }
    };
  }, 5277: (e2) => {
    const i2 = {};
    e2.exports = function(t2) {
      if (!t2)
        return "";
      let r2 = "";
      for (let e3 = 0; e3 < t2.length; ++e3) {
        var n2 = t2.charCodeAt(e3);
        i2.isSafe(n2) ? r2 += t2[e3] : r2 += i2.escapeHtmlChar(n2);
      }
      return r2;
    }, i2.escapeHtmlChar = function(e3) {
      var t2 = i2.namedHtml[e3];
      if (t2 !== void 0)
        return t2;
      if (256 <= e3)
        return "&#" + e3 + ";";
      e3 = e3.toString(16).padStart(2, "0");
      return "&#x".concat(e3, ";");
    }, i2.isSafe = function(e3) {
      return i2.safeCharCodes[e3] !== void 0;
    }, i2.namedHtml = { 38: "&amp;", 60: "&lt;", 62: "&gt;", 34: "&quot;", 160: "&nbsp;", 162: "&cent;", 163: "&pound;", 164: "&curren;", 169: "&copy;", 174: "&reg;" }, i2.safeCharCodes = function() {
      const t2 = {};
      for (let e3 = 32; e3 < 123; ++e3)
        (97 <= e3 || 65 <= e3 && e3 <= 90 || 48 <= e3 && e3 <= 57 || e3 === 32 || e3 === 46 || e3 === 44 || e3 === 45 || e3 === 58 || e3 === 95) && (t2[e3] = null);
      return t2;
    }();
  }, 6064: (e2) => {
    e2.exports = function(e3) {
      return e3.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }, 738: (e2) => {
    e2.exports = function() {
    };
  }, 1687: (e2, t2, r2) => {
    const o2 = r2(375), s2 = r2(8571), l2 = r2(7043), c2 = {};
    e2.exports = c2.merge = function(t3, r3, n2) {
      if (o2(t3 && typeof t3 == "object", "Invalid target value: must be an object"), o2(r3 == null || typeof r3 == "object", "Invalid source value: must be null, undefined, or an object"), !r3)
        return t3;
      if (n2 = Object.assign({ nullOverride: true, mergeArrays: true }, n2), Array.isArray(r3)) {
        o2(Array.isArray(t3), "Cannot merge array onto an object"), n2.mergeArrays || (t3.length = 0);
        for (let e3 = 0; e3 < r3.length; ++e3)
          t3.push(s2(r3[e3], { symbols: n2.symbols }));
        return t3;
      }
      var i2, a2 = l2.keys(r3, n2);
      for (let e3 = 0; e3 < a2.length; ++e3) {
        const l3 = a2[e3];
        l3 !== "__proto__" && Object.prototype.propertyIsEnumerable.call(r3, l3) && ((i2 = r3[l3]) && typeof i2 == "object" ? t3[l3] !== i2 && (!t3[l3] || typeof t3[l3] != "object" || Array.isArray(t3[l3]) !== Array.isArray(i2) || i2 instanceof Date || i2 instanceof RegExp ? t3[l3] = s2(i2, { symbols: n2.symbols }) : c2.merge(t3[l3], i2, n2)) : i2 == null && !n2.nullOverride || (t3[l3] = i2));
      }
      return t3;
    };
  }, 9621: (e2, t2, r2) => {
    const l2 = r2(375), c2 = {};
    e2.exports = function(r3, n2, i2) {
      if (n2 === false || n2 == null)
        return r3;
      typeof (i2 = i2 || {}) == "string" && (i2 = { separator: i2 });
      var e3 = Array.isArray(n2);
      l2(!e3 || !i2.separator, "Separator option no valid for array-based chain");
      var a2 = e3 ? n2 : n2.split(i2.separator || ".");
      let o2 = r3;
      for (let t3 = 0; t3 < a2.length; ++t3) {
        let e4 = a2[t3];
        var s2 = i2.iterables && c2.iterables(o2);
        if (Array.isArray(o2) || s2 === "set") {
          const r4 = Number(e4);
          Number.isInteger(r4) && (e4 = r4 < 0 ? o2.length + r4 : r4);
        }
        if (!o2 || typeof o2 == "function" && i2.functions === false || !s2 && o2[e4] === void 0) {
          l2(!i2.strict || t3 + 1 === a2.length, "Missing segment", e4, "in reach path ", n2), l2(typeof o2 == "object" || i2.functions === true || typeof o2 != "function", "Invalid segment", e4, "in reach path ", n2), o2 = i2.default;
          break;
        }
        o2 = s2 ? s2 === "set" ? [...o2][e4] : o2.get(e4) : o2[e4];
      }
      return o2;
    }, c2.iterables = function(e3) {
      return e3 instanceof Set ? "set" : e3 instanceof Map ? "map" : void 0;
    };
  }, 8761: (e2) => {
    e2.exports = function(...e3) {
      try {
        return JSON.stringify.apply(null, e3);
      } catch (e4) {
        return "[Cannot display object: " + e4.message + "]";
      }
    };
  }, 4277: (e2, t2) => {
    const r2 = {};
    t2 = e2.exports = { array: Array.prototype, buffer: false, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, r2.typeMap = new Map([["[object Error]", t2.error], ["[object Map]", t2.map], ["[object Promise]", t2.promise], ["[object Set]", t2.set], ["[object WeakMap]", t2.weakMap], ["[object WeakSet]", t2.weakSet]]), t2.getInternalProto = function(e3) {
      if (Array.isArray(e3))
        return t2.array;
      if (e3 instanceof Date)
        return t2.date;
      if (e3 instanceof RegExp)
        return t2.regex;
      if (e3 instanceof Error)
        return t2.error;
      e3 = Object.prototype.toString.call(e3);
      return r2.typeMap.get(e3) || t2.generic;
    };
  }, 7043: (e2, t2) => {
    t2.keys = function(e3, t3 = {}) {
      return t3.symbols !== false ? Reflect.ownKeys(e3) : Object.getOwnPropertyNames(e3);
    };
  }, 3652: (e2, t2, r2) => {
    const o2 = r2(375), n2 = {};
    t2.Sorter = class {
      constructor() {
        this._items = [], this.nodes = [];
      }
      add(e3, t3) {
        const r3 = [].concat((t3 = t3 || {}).before || []), n3 = [].concat(t3.after || []), i2 = t3.group || "?", a2 = t3.sort || 0;
        o2(!r3.includes(i2), "Item cannot come before itself: ".concat(i2)), o2(!r3.includes("?"), "Item cannot come before unassociated items"), o2(!n3.includes(i2), "Item cannot come after itself: ".concat(i2)), o2(!n3.includes("?"), "Item cannot come after unassociated items");
        for (const t4 of e3 = !Array.isArray(e3) ? [e3] : e3) {
          const e4 = { seq: this._items.length, sort: a2, before: r3, after: n3, group: i2, node: t4 };
          this._items.push(e4);
        }
        if (!t3.manual) {
          const e4 = this._sort();
          o2(e4, "item", i2 !== "?" ? "added into group ".concat(i2) : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(e3) {
        for (const t4 of e3 = !Array.isArray(e3) ? [e3] : e3)
          if (t4)
            for (const e4 of t4._items)
              this._items.push(Object.assign({}, e4));
        this._items.sort(n2.mergeSort);
        for (let e4 = 0; e4 < this._items.length; ++e4)
          this._items[e4].seq = e4;
        const t3 = this._sort();
        return o2(t3, "merge created a dependencies error"), this.nodes;
      }
      sort() {
        var e3 = this._sort();
        return o2(e3, "sort created a dependencies error"), this.nodes;
      }
      _sort() {
        const e3 = {}, t3 = Object.create(null), n3 = Object.create(null);
        for (const i3 of this._items) {
          const a3 = i3.seq, r4 = i3.group;
          n3[r4] = n3[r4] || [], n3[r4].push(a3), e3[a3] = i3.before;
          for (const e4 of i3.after)
            t3[e4] = t3[e4] || [], t3[e4].push(a3);
        }
        for (const t4 in e3) {
          const i3 = [];
          for (const a3 in e3[t4]) {
            const r4 = e3[t4][a3];
            n3[r4] = n3[r4] || [], i3.push(...n3[r4]);
          }
          e3[t4] = i3;
        }
        for (const i3 in t3)
          if (n3[i3])
            for (const a3 of n3[i3])
              e3[a3].push(...t3[i3]);
        const i2 = {};
        for (const t4 in e3) {
          const n4 = e3[t4];
          for (const e4 of n4)
            i2[e4] = i2[e4] || [], i2[e4].push(t4);
        }
        const a2 = {}, r3 = [];
        for (let t4 = 0; t4 < this._items.length; ++t4) {
          let e4 = t4;
          if (i2[t4]) {
            e4 = null;
            for (let r4 = 0; r4 < this._items.length; ++r4)
              if (a2[r4] !== true) {
                i2[r4] || (i2[r4] = []);
                const n4 = i2[r4].length;
                let t5 = 0;
                for (let e5 = 0; e5 < n4; ++e5)
                  a2[i2[r4][e5]] && ++t5;
                if (t5 === n4) {
                  e4 = r4;
                  break;
                }
              }
          }
          e4 !== null && (a2[e4] = true, r3.push(e4));
        }
        if (r3.length !== this._items.length)
          return false;
        const o3 = {};
        for (const e4 of this._items)
          o3[e4.seq] = e4;
        this._items = [], this.nodes = [];
        for (const e4 of r3) {
          const t4 = o3[e4];
          this.nodes.push(t4.node), this._items.push(t4);
        }
        return true;
      }
    }, n2.mergeSort = (e3, t3) => e3.sort === t3.sort ? 0 : e3.sort < t3.sort ? -1 : 1;
  }, 5380: (e2, r2, t2) => {
    const n2 = t2(443), a2 = t2(2178), o2 = { minDomainSegments: 2, nonAsciiRx: /[^\x00-\x7f]/, domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/, tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, URL: n2.URL || URL };
    r2.analyze = function(e3, t3 = {}) {
      if (typeof e3 != "string")
        throw new Error("Invalid input: domain must be a string");
      if (!e3)
        return a2.code("DOMAIN_NON_EMPTY_STRING");
      if (256 < e3.length)
        return a2.code("DOMAIN_TOO_LONG");
      if (o2.nonAsciiRx.test(e3)) {
        if (t3.allowUnicode === false)
          return a2.code("DOMAIN_INVALID_UNICODE_CHARS");
        e3 = e3.normalize("NFC");
      }
      if (o2.domainControlRx.test(e3))
        return a2.code("DOMAIN_INVALID_CHARS");
      e3 = o2.punycode(e3);
      const r3 = t3.minDomainSegments || o2.minDomainSegments, n3 = e3.split(".");
      if (n3.length < r3)
        return a2.code("DOMAIN_SEGMENTS_COUNT");
      if (t3.maxDomainSegments && n3.length > t3.maxDomainSegments)
        return a2.code("DOMAIN_SEGMENTS_COUNT_MAX");
      const i2 = t3.tlds;
      if (i2) {
        const e4 = n3[n3.length - 1].toLowerCase();
        if (i2.deny && i2.deny.has(e4) || i2.allow && !i2.allow.has(e4))
          return a2.code("DOMAIN_FORBIDDEN_TLDS");
      }
      for (let e4 = 0; e4 < n3.length; ++e4) {
        const t4 = n3[e4];
        if (!t4.length)
          return a2.code("DOMAIN_EMPTY_SEGMENT");
        if (63 < t4.length)
          return a2.code("DOMAIN_LONG_SEGMENT");
        if (e4 < n3.length - 1) {
          if (!o2.domainSegmentRx.test(t4))
            return a2.code("DOMAIN_INVALID_CHARS");
        } else if (!o2.tldSegmentRx.test(t4))
          return a2.code("DOMAIN_INVALID_TLDS_CHARS");
      }
      return null;
    }, r2.isValid = function(e3, t3) {
      return !r2.analyze(e3, t3);
    }, o2.punycode = function(t3) {
      try {
        return new o2.URL("http://".concat(t3)).host;
      } catch (e3) {
        return t3;
      }
    };
  }, 1745: (e2, t2, r2) => {
    const n2 = r2(9848), a2 = r2(5380), o2 = r2(2178), s2 = { nonAsciiRx: /[^\x00-\x7f]/, encoder: new (n2.TextEncoder || TextEncoder)() };
    t2.analyze = function(e3, t3) {
      return s2.email(e3, t3);
    }, t2.isValid = function(e3, t3) {
      return !s2.email(e3, t3);
    }, s2.email = function(e3, t3 = {}) {
      if (typeof e3 != "string")
        throw new Error("Invalid input: email must be a string");
      if (!e3)
        return o2.code("EMPTY_STRING");
      var r3 = !s2.nonAsciiRx.test(e3);
      if (!r3) {
        if (t3.allowUnicode === false)
          return o2.code("FORBIDDEN_UNICODE");
        e3 = e3.normalize("NFC");
      }
      var n3 = e3.split("@");
      if (n3.length !== 2)
        return 2 < n3.length ? o2.code("MULTIPLE_AT_CHAR") : o2.code("MISSING_AT_CHAR");
      var [i2, n3] = n3;
      if (!i2)
        return o2.code("EMPTY_LOCAL");
      if (!t3.ignoreLength) {
        if (254 < e3.length)
          return o2.code("ADDRESS_TOO_LONG");
        if (64 < s2.encoder.encode(i2).length)
          return o2.code("LOCAL_TOO_LONG");
      }
      return s2.local(i2, r3) || a2.analyze(n3, t3);
    }, s2.local = function(e3, t3) {
      e3 = e3.split(".");
      for (const r3 of e3) {
        if (!r3.length)
          return o2.code("EMPTY_LOCAL_SEGMENT");
        if (t3) {
          if (!s2.atextRx.test(r3))
            return o2.code("INVALID_LOCAL_CHARS");
        } else
          for (const t4 of r3)
            if (!s2.atextRx.test(t4)) {
              const r4 = s2.binary(t4);
              if (!s2.atomRx.test(r4))
                return o2.code("INVALID_LOCAL_CHARS");
            }
      }
    }, s2.binary = function(e3) {
      return Array.from(s2.encoder.encode(e3)).map((e4) => String.fromCharCode(e4)).join("");
    }, s2.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, s2.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));
  }, 2178: (e2, t2) => {
    t2.codes = { EMPTY_STRING: "Address must be a non-empty string", FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters", MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character", MISSING_AT_CHAR: "Address must contain one @ character", EMPTY_LOCAL: "Address local part cannot be empty", ADDRESS_TOO_LONG: "Address too long", LOCAL_TOO_LONG: "Address local part too long", EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment", INVALID_LOCAL_CHARS: "Address local part contains invalid character", DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string", DOMAIN_TOO_LONG: "Domain too long", DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters", DOMAIN_INVALID_CHARS: "Domain contains invalid character", DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character", DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments", DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments", DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD", DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment", DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long" }, t2.code = function(e3) {
      return { code: e3, error: t2.codes[e3] };
    };
  }, 9959: (e2, t2, r2) => {
    const o2 = r2(375), s2 = r2(5752);
    t2.regex = function(e3 = {}) {
      o2(e3.cidr === void 0 || typeof e3.cidr == "string", "options.cidr must be a string");
      const r3 = e3.cidr ? e3.cidr.toLowerCase() : "optional";
      o2(["required", "optional", "forbidden"].includes(r3), "options.cidr must be one of required, optional, forbidden"), o2(e3.version === void 0 || typeof e3.version == "string" || Array.isArray(e3.version), "options.version must be a string or an array of string");
      let t3 = e3.version || ["ipv4", "ipv6", "ipvfuture"];
      Array.isArray(t3) || (t3 = [t3]), o2(1 <= t3.length, "options.version must have at least 1 version specified");
      for (let e4 = 0; e4 < t3.length; ++e4)
        o2(typeof t3[e4] == "string", "options.version must only contain strings"), t3[e4] = t3[e4].toLowerCase(), o2(["ipv4", "ipv6", "ipvfuture"].includes(t3[e4]), "options.version contains unknown version " + t3[e4] + " - must be one of ipv4, ipv6, ipvfuture");
      t3 = Array.from(new Set(t3));
      const n2 = t3.map((e4) => {
        if (r3 === "forbidden")
          return s2.ip[e4];
        var t4 = "\\/".concat(e4 === "ipv4" ? s2.ip.v4Cidr : s2.ip.v6Cidr);
        return r3 === "required" ? "".concat(s2.ip[e4]).concat(t4) : "".concat(s2.ip[e4], "(?:").concat(t4, ")?");
      }), i2 = "(?:".concat(n2.join("|"), ")"), a2 = new RegExp("^".concat(i2, "$"));
      return { cidr: r3, versions: t3, regex: a2, raw: i2 };
    };
  }, 5752: (e2, t2, r2) => {
    const o2 = r2(375), s2 = r2(6064), l2 = { generate: function() {
      const e3 = {}, t3 = "!\\$&'\\(\\)\\*\\+,;=", r3 = "\\w-\\.~%\\dA-Fa-f" + t3 + ":@", n2 = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      e3.ipv4address = "(?:" + n2 + "\\.){3}" + n2;
      var i2 = "[\\dA-Fa-f]{1,4}", a2 = "(?:" + i2 + ":" + i2 + "|" + e3.ipv4address + ")", o3 = "(?:" + i2 + ":){6}" + a2, s3 = "::(?:" + i2 + ":){5}" + a2, l3 = "(?:" + i2 + ")?::(?:" + i2 + ":){4}" + a2, c2 = "(?:(?:" + i2 + ":){0,1}" + i2 + ")?::(?:" + i2 + ":){3}" + a2, u2 = "(?:(?:" + i2 + ":){0,2}" + i2 + ")?::(?:" + i2 + ":){2}" + a2, h2 = "(?:(?:" + i2 + ":){0,3}" + i2 + ")?::" + i2 + ":" + a2, a2 = "(?:(?:" + i2 + ":){0,4}" + i2 + ")?::" + a2;
      e3.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", e3.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", e3.ipv6address = "(?:" + o3 + "|" + s3 + "|" + l3 + "|" + c2 + "|" + u2 + "|" + h2 + "|" + a2 + "|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)", e3.ipvFuture = "v[\\dA-Fa-f]+\\.[\\w-\\.~" + t3 + ":]+", e3.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", e3.schemeRegex = new RegExp(e3.scheme);
      s3 = "[\\w-\\.~%\\dA-Fa-f" + t3 + ":]*", l3 = "(?:\\[(?:" + e3.ipv6address + "|" + e3.ipvFuture + ")\\]|" + e3.ipv4address + "|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})", c2 = "(?:" + s3 + "@)?" + l3 + "(?::\\d*)?", u2 = "(?:" + s3 + "@)?(" + l3 + ")(?::\\d*)?", h2 = "[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]+", a2 = "(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*", s3 = "\\/(?:" + h2 + a2 + ")?", l3 = h2 + a2, h2 = "[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+" + a2;
      return e3.hierPart = "(?:(?:\\/\\/" + c2 + a2 + ")|" + s3 + "|" + l3 + "|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))", e3.hierPartCapture = "(?:(?:\\/\\/" + u2 + a2 + ")|" + s3 + "|" + l3 + ")", e3.relativeRef = "(?:(?:\\/\\/" + c2 + a2 + ")|" + s3 + "|" + h2 + "|)", e3.relativeRefCapture = "(?:(?:\\/\\/" + u2 + a2 + ")|" + s3 + "|" + h2 + "|)", e3.query = "[" + r3 + "\\/\\?]*(?=#|$)", e3.queryWithSquareBrackets = "[" + r3 + "\\[\\]\\/\\?]*(?=#|$)", e3.fragment = "[" + r3 + "\\/\\?]*", e3;
    } };
    l2.rfc3986 = l2.generate(), t2.ip = { v4Cidr: l2.rfc3986.ipv4Cidr, v6Cidr: l2.rfc3986.ipv6Cidr, ipv4: l2.rfc3986.ipv4address, ipv6: l2.rfc3986.ipv6address, ipvfuture: l2.rfc3986.ipvFuture }, l2.createRegex = function(e3) {
      const t3 = l2.rfc3986, r3 = "(?:\\?" + (e3.allowQuerySquareBrackets ? t3.queryWithSquareBrackets : t3.query) + ")?(?:#" + t3.fragment + ")?", n2 = e3.domain ? t3.relativeRefCapture : t3.relativeRef;
      if (e3.relativeOnly)
        return l2.wrap(n2 + r3);
      let i2 = "";
      if (e3.scheme) {
        o2(e3.scheme instanceof RegExp || typeof e3.scheme == "string" || Array.isArray(e3.scheme), "scheme must be a RegExp, String, or Array");
        const r4 = [].concat(e3.scheme);
        o2(1 <= r4.length, "scheme must have at least 1 scheme specified");
        const l3 = [];
        for (let e4 = 0; e4 < r4.length; ++e4) {
          const n3 = r4[e4];
          o2(n3 instanceof RegExp || typeof n3 == "string", "scheme at position " + e4 + " must be a RegExp or String"), n3 instanceof RegExp ? l3.push(n3.source.toString()) : (o2(t3.schemeRegex.test(n3), "scheme at position " + e4 + " must be a valid scheme"), l3.push(s2(n3)));
        }
        i2 = l3.join("|");
      }
      var a2 = "(?:" + (i2 ? "(?:" + i2 + ")" : t3.scheme) + ":" + (e3.domain ? t3.hierPartCapture : t3.hierPart) + ")", a2 = e3.allowRelative ? "(?:" + a2 + "|" + n2 + ")" : a2;
      return l2.wrap(a2 + r3, i2);
    }, l2.wrap = function(e3, t3) {
      return { raw: e3 = "(?=.)(?!https?:/$)".concat(e3), regex: new RegExp("^".concat(e3, "$")), scheme: t3 };
    }, l2.uriRegex = l2.createRegex({}), t2.regex = function(e3 = {}) {
      return e3.scheme || e3.allowRelative || e3.relativeOnly || e3.allowQuerySquareBrackets || e3.domain ? l2.createRegex(e3) : l2.uriRegex;
    };
  }, 1447: (e2, s2) => {
    const l2 = { operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"], operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"], operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]], operatorsPrefix: ["!", "n"], literals: { '"': '"', "`": "`", "'": "'", "[": "]" }, numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/, tokenRx: /^[\w\$\#\.\@\:\{\}]+$/, symbol: Symbol("formula"), settings: Symbol("settings") };
    s2.Parser = class {
      constructor(e3, t2 = {}) {
        if (!t2[l2.settings] && t2.constants)
          for (const e4 in t2.constants) {
            const l3 = t2.constants[e4];
            if (l3 !== null && !["boolean", "number", "string"].includes(typeof l3))
              throw new Error("Formula constant ".concat(e4, " contains invalid ").concat(typeof l3, " value type"));
          }
        this.settings = t2[l2.settings] ? t2 : Object.assign({ [l2.settings]: true, constants: {}, functions: {} }, t2), this.single = null, this._parts = null, this._parse(e3);
      }
      _parse(e3) {
        let r2 = [], n2 = "", i2 = 0, a2 = false;
        var t2 = (e4) => {
          if (i2)
            throw new Error("Formula missing closing parenthesis");
          const t3 = r2.length ? r2[r2.length - 1] : null;
          if (a2 || n2 || e4) {
            if (t3 && t3.type === "reference" && e4 === ")")
              return t3.type = "function", t3.value = this._subFormula(n2, t3.value), void (n2 = "");
            if (e4 === ")") {
              const e5 = new s2.Parser(n2, this.settings);
              r2.push({ type: "segment", value: e5 });
            } else if (a2) {
              if (a2 === "]")
                return r2.push({ type: "reference", value: n2 }), void (n2 = "");
              r2.push({ type: "literal", value: n2 });
            } else if (l2.operatorCharacters.includes(n2))
              t3 && t3.type === "operator" && l2.operators.includes(t3.value + n2) ? t3.value += n2 : r2.push({ type: "operator", value: n2 });
            else if (n2.match(l2.numberRx))
              r2.push({ type: "constant", value: parseFloat(n2) });
            else if (this.settings.constants[n2] !== void 0)
              r2.push({ type: "constant", value: this.settings.constants[n2] });
            else {
              if (!n2.match(l2.tokenRx))
                throw new Error("Formula contains invalid token: ".concat(n2));
              r2.push({ type: "reference", value: n2 });
            }
            n2 = "";
          }
        };
        for (const s3 of e3)
          a2 ? s3 === a2 ? (t2(), a2 = false) : n2 += s3 : i2 ? s3 === "(" ? (n2 += s3, ++i2) : s3 === ")" ? (--i2, i2 ? n2 += s3 : t2(s3)) : n2 += s3 : s3 in l2.literals ? a2 = l2.literals[s3] : s3 === "(" ? (t2(), ++i2) : l2.operatorCharacters.includes(s3) ? (t2(), n2 = s3, t2()) : s3 !== " " ? n2 += s3 : t2();
        t2(), r2 = r2.map((e4, t3) => e4.type !== "operator" || e4.value !== "-" || t3 && r2[t3 - 1].type !== "operator" ? e4 : { type: "operator", value: "n" });
        let o2 = false;
        for (const e4 of r2) {
          if (e4.type === "operator") {
            if (l2.operatorsPrefix.includes(e4.value))
              continue;
            if (!o2)
              throw new Error("Formula contains an operator in invalid position");
            if (!l2.operators.includes(e4.value))
              throw new Error("Formula contains an unknown operator ".concat(e4.value));
          } else if (o2)
            throw new Error("Formula missing expected operator");
          o2 = !o2;
        }
        if (!o2)
          throw new Error("Formula contains invalid trailing operator");
        r2.length === 1 && ["reference", "literal", "constant"].includes(r2[0].type) && (this.single = { type: r2[0].type === "reference" ? "reference" : "value", value: r2[0].value }), this._parts = r2.map((e4) => {
          if (e4.type === "operator")
            return l2.operatorsPrefix.includes(e4.value) ? e4 : e4.value;
          if (e4.type !== "reference")
            return e4.value;
          if (this.settings.tokenRx && !this.settings.tokenRx.test(e4.value))
            throw new Error("Formula contains invalid reference ".concat(e4.value));
          return (this.settings.reference ? this.settings : l2).reference(e4.value);
        });
      }
      _subFormula(i2, e3) {
        const n2 = this.settings.functions[e3];
        if (typeof n2 != "function")
          throw new Error("Formula contains unknown function ".concat(e3));
        let a2 = [];
        if (i2) {
          let t2 = "", r2 = 0, n3 = false;
          var o2 = () => {
            if (!t2)
              throw new Error("Formula contains function ".concat(e3, " with invalid arguments ").concat(i2));
            a2.push(t2), t2 = "";
          };
          for (let e4 = 0; e4 < i2.length; ++e4) {
            const a3 = i2[e4];
            n3 ? (t2 += a3, a3 === n3 && (n3 = false)) : a3 in l2.literals && !r2 ? (t2 += a3, n3 = l2.literals[a3]) : a3 !== "," || r2 ? (t2 += a3, a3 === "(" ? ++r2 : a3 === ")" && --r2) : o2();
          }
          o2();
        }
        return a2 = a2.map((e4) => new s2.Parser(e4, this.settings)), function(e4) {
          const t2 = [];
          for (const r2 of a2)
            t2.push(r2.evaluate(e4));
          return n2.call(e4, ...t2);
        };
      }
      evaluate(a2) {
        const o2 = this._parts.slice();
        for (let e3 = o2.length - 2; 0 <= e3; --e3) {
          var t2, r2 = o2[e3];
          r2 && r2.type === "operator" && (t2 = o2[e3 + 1], o2.splice(e3 + 1, 1), t2 = l2.evaluate(t2, a2), o2[e3] = l2.single(r2.value, t2));
        }
        return l2.operatorsOrder.forEach((t3) => {
          for (let e3 = 1; e3 < o2.length - 1; )
            if (t3.includes(o2[e3])) {
              const t4 = o2[e3], n2 = l2.evaluate(o2[e3 - 1], a2), i2 = l2.evaluate(o2[e3 + 1], a2);
              o2.splice(e3, 2);
              var r3 = l2.calculate(t4, n2, i2);
              o2[e3 - 1] = r3 === 0 ? 0 : r3;
            } else
              e3 += 2;
        }), l2.evaluate(o2[0], a2);
      }
    }, s2.Parser.prototype[l2.symbol] = true, l2.reference = function(t2) {
      return function(e3) {
        return e3 && e3[t2] !== void 0 ? e3[t2] : null;
      };
    }, l2.evaluate = function(e3, t2) {
      return e3 === null ? null : typeof e3 == "function" ? e3(t2) : e3[l2.symbol] ? e3.evaluate(t2) : e3;
    }, l2.single = function(e3, t2) {
      if (e3 === "!")
        return !t2;
      t2 = -t2;
      return t2 == 0 ? 0 : t2;
    }, l2.calculate = function(e3, t2, r2) {
      if (e3 === "??")
        return l2.exists(t2) ? t2 : r2;
      if (typeof t2 == "string" || typeof r2 == "string") {
        if (e3 === "+")
          return (t2 = l2.exists(t2) ? t2 : "") + (l2.exists(r2) ? r2 : "");
      } else
        switch (e3) {
          case "^":
            return Math.pow(t2, r2);
          case "*":
            return t2 * r2;
          case "/":
            return t2 / r2;
          case "%":
            return t2 % r2;
          case "+":
            return t2 + r2;
          case "-":
            return t2 - r2;
        }
      switch (e3) {
        case "<":
          return t2 < r2;
        case "<=":
          return t2 <= r2;
        case ">":
          return r2 < t2;
        case ">=":
          return r2 <= t2;
        case "==":
          return t2 === r2;
        case "!=":
          return t2 !== r2;
        case "&&":
          return t2 && r2;
        case "||":
          return t2 || r2;
      }
      return null;
    }, l2.exists = function(e3) {
      return e3 != null;
    };
  }, 9926: () => {
  }, 5688: () => {
  }, 9708: () => {
  }, 1152: () => {
  }, 443: () => {
  }, 9848: () => {
  } }, DMa = {}, function e2(t2) {
    var r2 = DMa[t2];
    if (r2 !== void 0)
      return r2.exports;
    r2 = DMa[t2] = { exports: {} };
    return CMa[t2](r2, r2.exports, e2), r2.exports;
  }(5107));
  var __joi = joiBrowser_min.exports;
  function wrap$1(e2, t2) {
    typeof t2 == "string" && (t2 = document.createElement(t2));
    const r2 = e2.parentNode;
    var n2 = e2.nextSibling;
    return n2 ? r2.insertBefore(t2, n2) : r2.appendChild(t2), t2.appendChild(e2);
  }
  function insertAfter(e2, t2) {
    var r2 = t2.nextSibling;
    return r2 ? t2.parentNode.insertBefore(e2, r2) : t2.parentNode.appendChild(e2), e2;
  }
  var __css$3 = ".s-form-validate.s-form-validate--error[s-form-validate-error-container] > *:first-child {\n            margin-bottom: 0 !important;\n        }\n    .s-form-validate .s-form-validate__error-message {\n        text-align: end;\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n        overflow: hidden;\n        max-height: 0;\n        line-height: 1;\n        margin: 0;\n        -webkit-animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n                animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n    }\n    @-webkit-keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n    @keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n";
  class SFormValidateFeature extends SFeature {
    constructor(e2, t2, r2) {
      var n2;
      Object.keys((n2 = SComponent.getDefaultProps(e2)) === null || n2 === void 0 ? void 0 : n2.customValidations).forEach((e3) => {
        SFormValidateFeatureInterface.definition[e3] || (SFormValidateFeatureInterface.definition[e3] = { type: "String|Boolean" });
      }), super(e2, t2, __deepMerge$7({ componentUtils: { interface: SFormValidateFeatureInterface, style: __css$3 } }, r2 != null ? r2 : {})), this._validationType = "string", this._isValidating = false, this.componentUtils.exposeApi({ validate: this.validate }, this);
    }
    mount() {
      this._$field = this.node;
      var e2 = this.node.querySelector("input,textarea,select");
      e2 && (this._$field = e2), this.props.type && (this.props.type === "text" ? this._validationType = "string" : this._validationType = this.props.type), this.props.on.forEach((e3) => {
        var t2;
        e3 === "enter" ? this._$field.addEventListener("keyup", (e4) => {
          e4.keyCode === 13 && this.validate(e4);
        }) : e3 === "reset" ? (t2 = this._$field.form) !== null && t2 !== void 0 && t2.addEventListener(e3, (e4) => {
          setTimeout(() => {
            this.validate(e4);
          });
        }) : e3 === "submit" ? (t2 = this._$field.form) !== null && t2 !== void 0 && t2.addEventListener(e3, (e4) => {
          this.validate(e4);
        }) : this.node.addEventListener(e3, (e4) => {
          this.validate(e4);
        });
      });
      let r2 = __joi[this._validationType](), n2 = false;
      Object.keys(this.props).forEach((t2) => {
        if (!n2)
          if (this.props.customValidations[t2])
            n2 = true, r2 = r2.custom(this.props.customValidations[t2], t2);
          else {
            var e3 = this.props[t2];
            if (e3 === true && typeof r2[t2] == "function") {
              let e4 = t2 !== "email" && t2 !== "domain" ? {} : { tlds: false };
              r2 = r2[t2](e4);
            } else
              typeof r2[t2] == "function" && (r2 = r2[t2](autoCast$1(e3)));
          }
      }), this._schema = r2;
    }
    validate(t2) {
      var e2;
      if (((e2 = t2 == null ? void 0 : t2.currentTarget) === null || e2 === void 0 ? void 0 : e2.tagName.toLowerCase()) === "form" && t2.type !== "reset" && t2.preventDefault(), !this._isValidating) {
        this._isValidating = true, setTimeout(() => {
          this._isValidating = false;
        });
        let e3;
        e3 = this._$field.type === "checkbox" ? this._validateCheckbox() : this._$field.type === "range" ? this._validateRange() : this._$field.tagName.toLowerCase() === "select" ? this._validateSelect() : this._schema.validate(this._$field.value, __deepMerge$7({ errors: { label: false, language: this.props.language } }, this.props.joiOptions)), t2.type === "reset" && (e3 = {}), this._applyResult(e3, t2);
      }
    }
    _validateCheckbox() {
      var e2 = Array.from(this.node.querySelectorAll('input[type="checkbox"]:checked')).map((e3) => e3.value);
      let t2 = __joi.array();
      return this.props.min && (t2 = t2.min(this.props.min)), this.props.max && (t2 = t2.max(this.props.max)), t2.validate(e2, __deepMerge$7({ errors: { label: false, language: this.props.language } }, this.props.joiOptions));
    }
    _validateRange() {
      var e2 = parseFloat(this._$field.value);
      let t2 = __joi.number();
      return this.props.min && (t2 = t2.min(this.props.min)), this.props.max && (t2 = t2.max(this.props.max)), t2.validate(e2, __deepMerge$7({ errors: { label: false, language: this.props.language } }, this.props.joiOptions));
    }
    _validateSelect() {
      var e2 = Array.from(this._$field.querySelectorAll("option")).filter((e3) => e3.selected).map((e3) => e3.value);
      let t2 = __joi.array();
      return this.props.min && (t2 = t2.min(this.props.min)), this.props.max && (t2 = t2.max(this.props.max)), t2.validate(e2, __deepMerge$7({ errors: { label: false, language: this.props.language } }, this.props.joiOptions));
    }
    _applyResult(t2, e2) {
      var r2;
      if (t2.error) {
        var n2 = getComputedStyle(this.node).marginBottom;
        let e3 = (r2 = (i2 = this.node.parentNode) === null || i2 === void 0 ? void 0 : i2.hasAttribute) !== null && r2 !== void 0 && r2.call(i2, "s-form-validate-error-container") ? this.node.parentNode : void 0;
        if (!e3 && this.props.wrap && (e3 = document.createElement("div"), e3.setAttribute("s-form-validate-error-container", "true"), e3.classList.remove(...this.props.validClass.split(" ")), e3.classList.add(...this.props.errorClass.split(" ")), wrap$1(this.node, e3)), this.props.wrap || this.node.classList.add(...this.props.errorClass.split(" ")), this.node.classList.remove(...this.props.validClass.split(" ")), this.props.displayError) {
          var i2 = !(e3 === null || e3 === void 0 || !e3.querySelector("p[s-form-validate-error-message]"));
          const a2 = i2 ? e3 === null || e3 === void 0 ? void 0 : e3.querySelector("p[s-form-validate-error-message]") : document.createElement("p");
          i2 ? a2.innerHTML = t2.error.message : (a2.setAttribute("s-form-validate-error-message", "true"), a2.setAttribute("class", this.props.errorMessageClass), a2.innerHTML = t2.error.message, a2.style.marginBottom = n2, e3 ? e3.appendChild(a2) : insertAfter(a2, this.node));
        }
      } else if (!t2.error)
        if (e2.type !== "reset" ? this.node.classList.add(...this.props.validClass.split(" ")) : this.node.classList.remove(...this.props.validClass.split(" ")), this.props.wrap) {
          const o2 = this.node.parentNode;
          o2.hasAttribute("s-form-validate-error-container") && (insertAfter(this.node, o2), o2 !== null && o2 !== void 0 && o2.remove());
        } else {
          const s2 = this.node.nextSibling;
          s2 !== null && s2 !== void 0 && s2.hasAttribute("s-form-validate-error-message") && s2 !== null && s2 !== void 0 && s2.remove();
        }
    }
  }
  function define$a(e2 = {}, t2 = "s-form-validate") {
    SFeature.defineFeature(t2, SFormValidateFeature, e2);
  }
  class SSugarFeatureInterface extends SInterface {
    static get _definition() {
      return { scrolled: { description: 'Specify if you want the "scrolled" class to be applied on the "body" element when the page has been scrolled', type: "Boolean", default: true }, scrolledDelta: { description: "Specify after how many scroll the scrolled class will be applied", type: "Number", default: 10 }, vhvar: { description: 'Specify if you want the "--vh" css variable to be computed and available', type: "Boolean", default: true } };
    }
  }
  class SSugarFeature extends SFeature {
    constructor(e2, t2, r2) {
      super(e2, t2, __deepMerge$7({ componentUtils: { interface: SSugarFeatureInterface }, feature: {} }, r2 != null ? r2 : {}));
    }
    mount() {
      this.componentUtils.props.scrolled && this._scrolled(), this.componentUtils.props.vhvar && this._vhvar();
    }
    _scrolled() {
      document.addEventListener("scroll", (e2) => {
        window.scrollY >= this.componentUtils.props.scrolledDelta ? document.body.classList.add("scrolled") : document.body.classList.remove("scrolled");
      });
    }
    _vhvar() {
      let e2 = 0.01 * window.innerHeight;
      document.documentElement.style.setProperty("--vh", e2 + "px"), window.addEventListener("resize", () => {
        e2 = 0.01 * window.innerHeight, document.documentElement.style.setProperty("--vh", e2 + "px");
      });
    }
  }
  function define$9(e2 = {}, t2 = "s-sugar") {
    SFeature.defineFeature(t2, SSugarFeature, e2);
  }
  class SParallaxFeatureInterface extends SInterface {
    static get _definition() {
      return { amount: { description: "Specify the amount of parallax you want to apply", type: "Number", default: 1 }, amountX: { description: "Specify the amount of parallax you want for the x axis. This will be applied on top of the global amount", type: "Number", default: 1 }, amountY: { description: "Specify the amount of parallax you want for the y axis. This will be applied on top of the global amount", type: "Number", default: 1 }, amountTranslateX: { description: "Specify the amount of parallax you want for the translate x axis. This will be applied on top of the global amount", type: "Number", default: 1 }, amountTranslateY: { description: "Specify the amount of parallax you want for the translate y axis. This will be applied on top of the global amount", type: "Number", default: 1 }, amountRotateX: { description: "Specify the amount of parallax you want for the rotate x axis. This will be applied on top of the global amount", type: "Number", default: 1 }, amountRotateY: { description: "Specify the amount of parallax you want for the rotate y axis. This will be applied on top of the global amount", type: "Number", default: 1 } };
    }
  }
  function format(e2) {
    if (e2 && e2.constructor === Array) {
      var t2 = e2.filter(function(e3) {
        return typeof e3 == "number";
      }).filter(function(e3) {
        return !isNaN(e3);
      });
      if (e2.length === 6 && t2.length === 6) {
        var r2 = identity();
        return r2[0] = t2[0], r2[1] = t2[1], r2[4] = t2[2], r2[5] = t2[3], r2[12] = t2[4], r2[13] = t2[5], r2;
      }
      if (e2.length === 16 && t2.length === 16)
        return e2;
    }
    throw new TypeError("Expected a `number[]` with length 6 or 16.");
  }
  function fromString(e2) {
    if (typeof e2 == "string") {
      var t2 = e2.match(/matrix(3d)?\(([^)]+)\)/);
      if (t2)
        return format(t2[2].split(",").map(parseFloat));
      if (e2 === "none" || e2 === "")
        return identity();
    }
    throw new TypeError("Expected a string containing `matrix()` or `matrix3d()");
  }
  function identity() {
    for (var e2 = [], t2 = 0; t2 < 16; t2++)
      t2 % 5 == 0 ? e2.push(1) : e2.push(0);
    return e2;
  }
  function multiply(e2, t2) {
    for (var r2 = format(e2), n2 = format(t2), i2 = [], a2 = 0; a2 < 4; a2++)
      for (var o2 = [r2[a2], r2[a2 + 4], r2[a2 + 8], r2[a2 + 12]], s2 = 0; s2 < 4; s2++) {
        var l2 = 4 * s2, c2 = [n2[l2], n2[1 + l2], n2[2 + l2], n2[3 + l2]];
        i2[a2 + l2] = o2[0] * c2[0] + o2[1] * c2[1] + o2[2] * c2[2] + o2[3] * c2[3];
      }
    return i2;
  }
  function rotateX(e2) {
    var t2 = Math.PI / 180 * e2, e2 = identity();
    return e2[5] = e2[10] = Math.cos(t2), e2[6] = e2[9] = Math.sin(t2), e2[9] *= -1, e2;
  }
  function rotateY(e2) {
    var t2 = Math.PI / 180 * e2, e2 = identity();
    return e2[0] = e2[10] = Math.cos(t2), e2[2] = e2[8] = Math.sin(t2), e2[2] *= -1, e2;
  }
  function toString$1(e2) {
    return "matrix3d(" + format(e2).join(", ") + ")";
  }
  function translateX(e2) {
    var t2 = identity();
    return t2[12] = e2, t2;
  }
  function translateY(e2) {
    var t2 = identity();
    return t2[13] = e2, t2;
  }
  class SParallaxFeature extends SFeature {
    constructor(e2, t2, r2) {
      super(e2, t2, __deepMerge$7({ componentUtils: { interface: SParallaxFeatureInterface }, feature: {} }, r2 != null ? r2 : {}));
      r2 = window.getComputedStyle(this.node).transform;
      this._originalTransform = r2;
    }
    mount() {
      document.addEventListener("mousemove", (e2) => {
        this.componentUtils.isInViewport() && (e2 = this._getPositionPercentages(e2), this._setLayerTransform(e2));
      });
    }
    _setLayerTransform(e2) {
      var t2 = 0.9 * e2.x, r2 = 0.9 * e2.y, n2 = 2 * e2.x, i2 = 2 * e2.y, e2 = (e2 = this.props.amount) !== null && e2 !== void 0 ? e2 : "1";
      const a2 = fromString(this._originalTransform);
      t2 = t2 * parseFloat(e2) * parseFloat(this.props.amountY) * parseFloat(this.props.amountRotateY), r2 = r2 * parseFloat(e2) * parseFloat(this.props.amountX) * parseFloat(this.props.amountRotateX), n2 = n2 * parseFloat(e2) * parseFloat(this.props.amountX) * parseFloat(this.props.amountTranslateX), e2 = i2 * parseFloat(e2) * parseFloat(this.props.amountY) * parseFloat(this.props.amountTranslateY);
      const o2 = translateX(n2), s2 = translateY(e2), l2 = rotateX(r2), c2 = rotateY(t2);
      t2 = [a2, o2, s2, l2, c2].reduce(multiply);
      this.node.style.transform = toString$1(t2);
    }
    _getPositionPercentages(e2) {
      var t2, r2 = 0.5 * document.documentElement.clientWidth, n2 = 0.5 * document.documentElement.clientHeight;
      return { x: 100 / r2 * (((t2 = (t2 = e2.touches) === null || t2 === void 0 ? void 0 : t2[0].clientX) !== null && t2 !== void 0 ? t2 : e2.pageX) - r2), y: 100 / n2 * (((r2 = (r2 = e2.touches) === null || r2 === void 0 ? void 0 : r2[0].clientY) !== null && r2 !== void 0 ? r2 : e2.pageY) - document.documentElement.scrollTop - n2) };
    }
  }
  function define$8(e2 = {}, t2 = "s-parallax") {
    SFeature.defineFeature(t2, SParallaxFeature, e2);
  }
  class SRangeComponentInterface extends SInterface {
  }
  SRangeComponentInterface.definition = { name: { type: "String", description: 'Specify the name to assign to the internal input[type="range"]' }, value: { type: "String", description: "Specify the initial range value" }, min: { type: "Number", description: "Specify the minimal value or the range", default: 0 }, max: { type: "Number", description: "Specify the maximal value of the range", default: 100 }, step: { type: "Number", description: "Specify the steps between each values" }, target: { type: "String", description: "Specify a css selector of any HTMLElement or HTMLInputElement in which to inject the value when the range is updated" }, tooltip: { type: "Boolean", description: "Specify if you want to display the value inside a tooltip on top of the thumb", default: false } };
  var __css$2 = "s-range {\n    display: block;\n    width: 100%;\n}\n\n    s-range:not([mounted]) > * {\n        display: none;\n    }\n.s-range {\n    display: flex;\n    width: 100%;\n}\n\n.s-range__input {\n    flex-grow: 1;\n}\n\n.s-range__tooltip {\n    transition: none;\n}\n\ns-range[default-style] {\n}\n";
  function plainObject$2(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$2(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$2(a2[e4]) && plainObject$2(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  var __awaiter$8 = function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SRange extends SLitComponent {
    static get properties() {
      return SLitComponent.properties({}, SRangeComponentInterface);
    }
    static get styles() {
      return r$2`
            ${o$3(`
                ${__css$2}
            `)}
        `;
    }
    constructor() {
      super(__deepMerge$2({ litComponent: { shadowDom: false }, componentUtils: { interface: SRangeComponentInterface } }));
    }
    firstUpdated() {
      return __awaiter$8(this, void 0, void 0, function* () {
        this._$input = this.querySelector("input"), this._$tooltip = this.querySelector(".s-range__tooltip"), this._$input.addEventListener("input", (e2) => {
          this._handleTooltip(), this._handleTarget();
        }), this.props.target && (this._$targets = Array.from(document.querySelectorAll(this.props.target))), this._handleTooltip(), this._handleTarget();
      });
    }
    _handleTarget() {
      this._$targets && this._$targets.forEach((e2) => {
        e2.innerHTML = this._$input.value, e2.value = this._$input.value;
      });
    }
    _handleTooltip() {
      var e2, t2, r2;
      this._$tooltip && (e2 = this._$input.value, r2 = this._$input.min || 0, t2 = this._$input.max || 100, r2 = Number(100 * (e2 - r2) / (t2 - r2)), this._$tooltip.style.left = `calc(${r2}% + (${8 - 0.15 * r2}px))`, this._$tooltip.innerHTML = e2);
    }
    render() {
      return p`
            <div class="${this.componentUtils.className("", "s-tooltip-container")}">
                <input
                    class="${this.componentUtils.className("__input", "s-range")}"
                    type="range"
                    name="${this.name}"
                    value="${this.value}"
                    min="${this.min}"
                    max="${this.max}"
                    step="${this.step}"
                />
                ${this.props.tooltip ? p` <div class="${this.componentUtils.className("__tooltip", "s-tooltip")}"></div> ` : ""}
            </div>
        `;
    }
  }
  function define$7(e2 = {}, t2 = "s-range") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SRange);
  }
  function plainObject$1(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge$1(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject$1(a2[e4]) && plainObject$1(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  const standardProperty = (t2, r2) => r2.kind !== "method" || !r2.descriptor || "value" in r2.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: r2.key, initializer() {
    typeof r2.initializer == "function" && (this[r2.key] = r2.initializer.call(this));
  }, finisher(e2) {
    e2.createProperty(r2.key, t2);
  } } : __spreadProps(__spreadValues({}, r2), { finisher(e2) {
    e2.createProperty(r2.key, t2);
  } }), legacyProperty = (e2, t2, r2) => {
    t2.constructor.createProperty(r2, e2);
  };
  function property(r2) {
    return (e2, t2) => t2 !== void 0 ? legacyProperty(r2, e2, t2) : standardProperty(r2, e2);
  }
  class SSidePanelComponentInterface extends SInterface {
  }
  SSidePanelComponentInterface.definition = { side: { type: "String", values: ["top", "left", "bottom", "right"], default: "left" }, active: { type: "Boolean", default: false }, overlay: { type: "Boolean", default: false }, triggerer: { type: "String" }, closeOn: { type: { type: "Array<String>", splitChars: [","] }, values: ["click", "escape"], default: ["click", "escape"] } };
  var isff$1 = typeof navigator != "undefined" && 0 < navigator.userAgent.toLowerCase().indexOf("firefox");
  function addEvent$1(e2, t2, r2) {
    e2.addEventListener ? e2.addEventListener(t2, r2, false) : e2.attachEvent && e2.attachEvent("on".concat(t2), function() {
      r2(window.event);
    });
  }
  function getMods$1(e2, t2) {
    for (var r2 = t2.slice(0, t2.length - 1), n2 = 0; n2 < r2.length; n2++)
      r2[n2] = e2[r2[n2].toLowerCase()];
    return r2;
  }
  function getKeys$1(e2) {
    for (var t2 = (e2 = (e2 = typeof e2 != "string" ? "" : e2).replace(/\s/g, "")).split(","), r2 = t2.lastIndexOf(""); 0 <= r2; )
      t2[r2 - 1] += ",", t2.splice(r2, 1), r2 = t2.lastIndexOf("");
    return t2;
  }
  function compareArray$1(e2, t2) {
    for (var r2 = e2.length >= t2.length ? e2 : t2, n2 = e2.length >= t2.length ? t2 : e2, i2 = true, a2 = 0; a2 < r2.length; a2++)
      n2.indexOf(r2[a2]) === -1 && (i2 = false);
    return i2;
  }
  for (var _keyMap$1 = { backspace: 8, tab: 9, clear: 12, enter: 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, "\u21EA": 20, ",": 188, ".": 190, "/": 191, "`": 192, "-": isff$1 ? 173 : 189, "=": isff$1 ? 61 : 187, ";": isff$1 ? 59 : 186, "'": 222, "[": 219, "]": 221, "\\": 220 }, _modifier$1 = { "\u21E7": 16, shift: 16, "\u2325": 18, alt: 18, option: 18, "\u2303": 17, ctrl: 17, control: 17, "\u2318": 91, cmd: 91, command: 91 }, modifierMap$1 = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, _mods$1 = { 16: false, 18: false, 17: false, 91: false }, _handlers$1 = {}, k$1 = 1; k$1 < 20; k$1++)
    _keyMap$1["f".concat(k$1)] = 111 + k$1;
  var _downKeys$1 = [], _scope$1 = "all", elementHasBindEvent$1 = [], code$1 = function(e2) {
    return _keyMap$1[e2.toLowerCase()] || _modifier$1[e2.toLowerCase()] || e2.toUpperCase().charCodeAt(0);
  };
  function setScope$1(e2) {
    _scope$1 = e2 || "all";
  }
  function getScope$1() {
    return _scope$1 || "all";
  }
  function getPressedKeyCodes$1() {
    return _downKeys$1.slice(0);
  }
  function filter$1(e2) {
    var t2 = e2.target || e2.srcElement, r2 = t2.tagName, e2 = true;
    return e2 = t2.isContentEditable || !(r2 !== "INPUT" && r2 !== "TEXTAREA" && r2 !== "SELECT" || t2.readOnly) ? false : e2;
  }
  function isPressed$1(e2) {
    return typeof e2 == "string" && (e2 = code$1(e2)), _downKeys$1.indexOf(e2) !== -1;
  }
  function deleteScope$1(e2, t2) {
    var r2, n2, i2;
    for (i2 in e2 = e2 || getScope$1(), _handlers$1)
      if (Object.prototype.hasOwnProperty.call(_handlers$1, i2))
        for (r2 = _handlers$1[i2], n2 = 0; n2 < r2.length; )
          r2[n2].scope === e2 ? r2.splice(n2, 1) : n2++;
    getScope$1() === e2 && setScope$1(t2 || "all");
  }
  function clearModifier$1(e2) {
    var t2 = e2.keyCode || e2.which || e2.charCode, r2 = _downKeys$1.indexOf(t2);
    if (0 <= r2 && _downKeys$1.splice(r2, 1), e2.key && e2.key.toLowerCase() === "meta" && _downKeys$1.splice(0, _downKeys$1.length), (t2 = t2 === 93 || t2 === 224 ? 91 : t2) in _mods$1)
      for (var n2 in _mods$1[t2] = false, _modifier$1)
        _modifier$1[n2] === t2 && (hotkeys$1[n2] = false);
  }
  function unbind$1(e2) {
    if (e2) {
      if (Array.isArray(e2))
        e2.forEach(function(e3) {
          e3.key && eachUnbind$1(e3);
        });
      else if (typeof e2 == "object")
        e2.key && eachUnbind$1(e2);
      else if (typeof e2 == "string") {
        for (var t2 = arguments.length, r2 = new Array(1 < t2 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
          r2[n2 - 1] = arguments[n2];
        var i2 = r2[0], a2 = r2[1];
        typeof i2 == "function" && (a2 = i2, i2 = ""), eachUnbind$1({ key: e2, scope: i2, method: a2, splitKey: "+" });
      }
    } else
      Object.keys(_handlers$1).forEach(function(e3) {
        return delete _handlers$1[e3];
      });
  }
  var eachUnbind$1 = function(e2) {
    var t2 = e2.key, i2 = e2.scope, a2 = e2.method, e2 = e2.splitKey, o2 = e2 === void 0 ? "+" : e2;
    getKeys$1(t2).forEach(function(e3) {
      var t3, r2 = e3.split(o2), n2 = r2.length, e3 = r2[n2 - 1], e3 = e3 === "*" ? "*" : code$1(e3);
      _handlers$1[e3] && (i2 = i2 || getScope$1(), t3 = 1 < n2 ? getMods$1(_modifier$1, r2) : [], _handlers$1[e3] = _handlers$1[e3].map(function(e4) {
        return a2 && e4.method !== a2 || e4.scope !== i2 || !compareArray$1(e4.mods, t3) ? e4 : {};
      }));
    });
  };
  function eventHandler$1(e2, t2, r2) {
    var n2;
    if (t2.scope === r2 || t2.scope === "all") {
      for (var i2 in n2 = 0 < t2.mods.length, _mods$1)
        Object.prototype.hasOwnProperty.call(_mods$1, i2) && (!_mods$1[i2] && -1 < t2.mods.indexOf(+i2) || _mods$1[i2] && t2.mods.indexOf(+i2) === -1) && (n2 = false);
      (t2.mods.length !== 0 || _mods$1[16] || _mods$1[18] || _mods$1[17] || _mods$1[91]) && !n2 && t2.shortcut !== "*" || t2.method(e2, t2) === false && (e2.preventDefault ? e2.preventDefault() : e2.returnValue = false, e2.stopPropagation && e2.stopPropagation(), e2.cancelBubble && (e2.cancelBubble = true));
    }
  }
  function dispatch$1(r2) {
    var e2 = _handlers$1["*"], t2 = r2.keyCode || r2.which || r2.charCode;
    if (hotkeys$1.filter.call(this, r2)) {
      if (_downKeys$1.indexOf(t2 = t2 === 93 || t2 === 224 ? 91 : t2) === -1 && t2 !== 229 && _downKeys$1.push(t2), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(e3) {
        var t3 = modifierMap$1[e3];
        r2[e3] && _downKeys$1.indexOf(t3) === -1 ? _downKeys$1.push(t3) : !r2[e3] && -1 < _downKeys$1.indexOf(t3) ? _downKeys$1.splice(_downKeys$1.indexOf(t3), 1) : e3 === "metaKey" && r2[e3] && _downKeys$1.length === 3 && (r2.ctrlKey || r2.shiftKey || r2.altKey || (_downKeys$1 = _downKeys$1.slice(_downKeys$1.indexOf(t3))));
      }), t2 in _mods$1) {
        for (var n2 in _mods$1[t2] = true, _modifier$1)
          _modifier$1[n2] === t2 && (hotkeys$1[n2] = true);
        if (!e2)
          return;
      }
      for (var i2 in _mods$1)
        Object.prototype.hasOwnProperty.call(_mods$1, i2) && (_mods$1[i2] = r2[modifierMap$1[i2]]);
      r2.getModifierState && (!r2.altKey || r2.ctrlKey) && r2.getModifierState("AltGraph") && (_downKeys$1.indexOf(17) === -1 && _downKeys$1.push(17), _downKeys$1.indexOf(18) === -1 && _downKeys$1.push(18), _mods$1[17] = true, _mods$1[18] = true);
      var a2 = getScope$1();
      if (e2)
        for (var o2 = 0; o2 < e2.length; o2++)
          e2[o2].scope === a2 && (r2.type === "keydown" && e2[o2].keydown || r2.type === "keyup" && e2[o2].keyup) && eventHandler$1(r2, e2[o2], a2);
      if (t2 in _handlers$1) {
        for (var s2 = 0; s2 < _handlers$1[t2].length; s2++)
          if ((r2.type === "keydown" && _handlers$1[t2][s2].keydown || r2.type === "keyup" && _handlers$1[t2][s2].keyup) && _handlers$1[t2][s2].key) {
            for (var l2 = _handlers$1[t2][s2], c2 = l2.splitKey, u2 = l2.key.split(c2), h2 = [], d2 = 0; d2 < u2.length; d2++)
              h2.push(code$1(u2[d2]));
            h2.sort().join("") === _downKeys$1.sort().join("") && eventHandler$1(r2, l2, a2);
          }
      }
    }
  }
  function isElementBind$1(e2) {
    return -1 < elementHasBindEvent$1.indexOf(e2);
  }
  function hotkeys$1(e2, t2, r2) {
    _downKeys$1 = [];
    var n2 = getKeys$1(e2), i2 = [], a2 = "all", o2 = document, s2 = 0, l2 = false, c2 = true, u2 = "+";
    for (r2 === void 0 && typeof t2 == "function" && (r2 = t2), Object.prototype.toString.call(t2) === "[object Object]" && (t2.scope && (a2 = t2.scope), t2.element && (o2 = t2.element), t2.keyup && (l2 = t2.keyup), t2.keydown !== void 0 && (c2 = t2.keydown), typeof t2.splitKey == "string" && (u2 = t2.splitKey)), typeof t2 == "string" && (a2 = t2); s2 < n2.length; s2++)
      i2 = [], 1 < (e2 = n2[s2].split(u2)).length && (i2 = getMods$1(_modifier$1, e2)), (e2 = (e2 = e2[e2.length - 1]) === "*" ? "*" : code$1(e2)) in _handlers$1 || (_handlers$1[e2] = []), _handlers$1[e2].push({ keyup: l2, keydown: c2, scope: a2, mods: i2, shortcut: n2[s2], method: r2, key: n2[s2], splitKey: u2 });
    o2 !== void 0 && !isElementBind$1(o2) && window && (elementHasBindEvent$1.push(o2), addEvent$1(o2, "keydown", function(e3) {
      dispatch$1(e3);
    }), addEvent$1(window, "focus", function() {
      _downKeys$1 = [];
    }), addEvent$1(o2, "keyup", function(e3) {
      dispatch$1(e3), clearModifier$1(e3);
    }));
  }
  var _api$1 = { setScope: setScope$1, getScope: getScope$1, deleteScope: deleteScope$1, getPressedKeyCodes: getPressedKeyCodes$1, isPressed: isPressed$1, filter: filter$1, unbind: unbind$1 }, a$1, _hotkeys$1;
  for (a$1 in _api$1)
    Object.prototype.hasOwnProperty.call(_api$1, a$1) && (hotkeys$1[a$1] = _api$1[a$1]);
  typeof window != "undefined" && (_hotkeys$1 = window.hotkeys, hotkeys$1.noConflict = function(e2) {
    return e2 && window.hotkeys === hotkeys$1 && (window.hotkeys = _hotkeys$1), hotkeys$1;
  }, window.hotkeys = hotkeys$1);
  var hotkeys_common$1 = hotkeys$1;
  function hotkey$1(e2, i2 = {}) {
    return new SPromise(({ emit: r2, cancel: n2 }) => {
      i2 = Object.assign({ element: null, keyup: false, keydown: true, once: false, splitKey: "+" }, i2), hotkeys_common$1(e2, i2, (e3, t2) => {
        r2("press", e3), i2.once && n2();
      });
    }, { id: "hotkey" }).on("finally", () => {
      hotkeys_common$1.unbind(e2);
    });
  }
  hotkeys_common$1.filter = function() {
    return true;
  };
  var __css$1 = "s-side-panel {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 9999;\n    pointer-events: none;\n}\n\n    s-side-panel[active] {\n        pointer-events: all;\n    }\n\n    s-side-panel:not([mounted]) > * {\n        display: none;\n    }\n\n.s-side-panel__overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n    width: 100%;\n    height: 100%;\n}\n\n[default-style] .s-side-panel__overlay {\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-lightness-offset, 0)) * 1%),var(--s-theme-color-main-a, 0.3));\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n        opacity: 0;\n    }\n\n[default-style][active] .s-side-panel__overlay {\n        opacity: 1;\n    }\n\n.s-side-panel__container {\n    display: none;\n    position: absolute;\n    z-index: 1;\n}\n\n[mounted] .s-side-panel__container {\n        display: block;\n    }\n\n[default-style] .s-side-panel__container {\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n[side='left'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        height: 100%;\n        transform: translateX(-100%);\n    }\n\n[side='top'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(-100%);\n    }\n\n[side='right'] .s-side-panel__container {\n        right: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        transform: translateX(100%);\n    }\n\n[side='bottom'] .s-side-panel__container {\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(100%);\n    }\n\n[active] .s-side-panel__container {\n        transform: translateX(0) translateY(0);\n    }\n\n.s-side-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n.s-side-panel[active] {\n        pointer-events: all;\n    }\n", __decorate$1 = function(e2, t2, r2, n2) {
    var i2, a2 = arguments.length, o2 = a2 < 3 ? t2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var s2 = e2.length - 1; 0 <= s2; s2--)
        (i2 = e2[s2]) && (o2 = (a2 < 3 ? i2(o2) : 3 < a2 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return 3 < a2 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class SSidePanel extends SLitComponent {
    constructor() {
      if (super(__deepMerge$1({ litComponent: { shadowDom: false }, componentUtils: { interface: SSidePanelComponentInterface } })), this.props.closeOn.indexOf("click") !== -1 && this.addEventListener("click", (e2) => {
        this._$container.contains(e2.target) || this.constructor._activePanels.slice(-1)[0] === this && (this.constructor._activePanels.pop(), this.active = false);
      }), this.props.closeOn.indexOf("escape") !== -1 && hotkey$1("escape").on("press", () => {
        this.constructor._activePanels.slice(-1)[0] === this && (this.constructor._activePanels.pop(), this.active = false);
      }), this._$nodes = Array.from(this.children), this.props.triggerer) {
        const e2 = Array.from(document.querySelectorAll(this.props.triggerer));
        e2.forEach((e3) => {
          e3.addEventListener("click", (e4) => {
            this.open();
          });
        });
      }
    }
    static get properties() {
      return SLitComponent.properties({}, SSidePanelComponentInterface);
    }
    static get styles() {
      return r$2`
            ${o$3(__css$1)}
        `;
    }
    set active(e2) {
      (this._active = e2) && this.constructor._activePanels.indexOf(this) === -1 && this.constructor._activePanels.push(this), e2 ? this.setAttribute("active", true) : this.removeAttribute("active"), this.requestUpdate();
    }
    get active() {
      return this._active;
    }
    firstUpdated() {
      this._$container = this.querySelector(".s-side-panel__container"), this._$nodes.forEach((e2) => {
        var t2;
        (t2 = this._$container) !== null && t2 !== void 0 && t2.appendChild(e2);
      });
    }
    open() {
      this.active = true;
    }
    close() {
      this.active = false;
    }
    render() {
      return p`
            ${this.overlay ? p` <div class="${this.componentUtils.className("__overlay")}"></div> ` : ""}
            <div class="${this.componentUtils.className("__container")}"></div>
        `;
    }
  }
  function define$6(e2 = {}, t2 = "s-side-panel") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SSidePanel);
  }
  function linksStateAttributes(e2 = {}) {
    function t2(e3) {
      e3.getAttribute("href") === document.location.pathname ? e3.setAttribute("actual", true) : e3.getAttribute("href").startsWith(document.location.pathname) ? (e3.removeAttribute("actual"), e3.setAttribute("actual-child", true)) : (e3.removeAttribute("actual"), e3.removeAttribute("actual-child"));
    }
    e2 = __deepMerge$7({}, e2), querySelectorLive("[href]", (e3) => {
      t2(e3);
    }), window.addEventListener("locationchange", () => {
      Array.from(document.querySelectorAll("[href]")).forEach((e3) => {
        t2(e3);
      });
    });
  }
  SSidePanel._activePanels = [], __decorate$1([property()], SSidePanel.prototype, "overlay", void 0);
  var requiresPort = function(e2, t2) {
    if (t2 = t2.split(":")[0], !(e2 = +e2))
      return false;
    switch (t2) {
      case "http":
      case "ws":
        return e2 !== 80;
      case "https":
      case "wss":
        return e2 !== 443;
      case "ftp":
        return e2 !== 21;
      case "gopher":
        return e2 !== 70;
      case "file":
        return false;
    }
    return e2 !== 0;
  }, querystringify$1 = {}, has = Object.prototype.hasOwnProperty, undef;
  function decode(e2) {
    try {
      return decodeURIComponent(e2.replace(/\+/g, " "));
    } catch (e3) {
      return null;
    }
  }
  function encode(e2) {
    try {
      return encodeURIComponent(e2);
    } catch (e3) {
      return null;
    }
  }
  function querystring(e2) {
    for (var t2 = /([^=?#&]+)=?([^&]*)/g, r2 = {}; i2 = t2.exec(e2); ) {
      var n2 = decode(i2[1]), i2 = decode(i2[2]);
      n2 === null || i2 === null || n2 in r2 || (r2[n2] = i2);
    }
    return r2;
  }
  function querystringify(e2, t2) {
    var r2, n2, i2 = [];
    for (n2 in typeof (t2 = t2 || "") != "string" && (t2 = "?"), e2)
      has.call(e2, n2) && ((r2 = e2[n2]) || r2 !== null && r2 !== undef && !isNaN(r2) || (r2 = ""), n2 = encode(n2), r2 = encode(r2), n2 !== null && r2 !== null && i2.push(n2 + "=" + r2));
    return i2.length ? t2 + i2.join("&") : "";
  }
  querystringify$1.stringify = querystringify, querystringify$1.parse = querystring;
  var required = requiresPort, qs = querystringify$1, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/, whitespace = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]", left = new RegExp("^" + whitespace + "+");
  function trimLeft(e2) {
    return (e2 || "").toString().replace(left, "");
  }
  var rules = [["#", "hash"], ["?", "query"], function(e2, t2) {
    return isSpecial(t2.protocol) ? e2.replace(/\\/g, "/") : e2;
  }, ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d+)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]], ignore = { hash: 1, query: 1 };
  function lolcation(e2) {
    var t2, r2 = typeof window != "undefined" ? window : commonjsGlobal !== void 0 ? commonjsGlobal : typeof self != "undefined" ? self : {}, r2 = r2.location || {}, n2 = {}, r2 = typeof (e2 = e2 || r2);
    if (e2.protocol === "blob:")
      n2 = new Url(unescape(e2.pathname), {});
    else if (r2 == "string")
      for (t2 in n2 = new Url(e2, {}), ignore)
        delete n2[t2];
    else if (r2 == "object") {
      for (t2 in e2)
        t2 in ignore || (n2[t2] = e2[t2]);
      n2.slashes === void 0 && (n2.slashes = slashes.test(e2.href));
    }
    return n2;
  }
  function isSpecial(e2) {
    return e2 === "file:" || e2 === "ftp:" || e2 === "http:" || e2 === "https:" || e2 === "ws:" || e2 === "wss:";
  }
  function extractProtocol(e2, t2) {
    e2 = trimLeft(e2), t2 = t2 || {};
    var r2, n2 = protocolre.exec(e2), i2 = n2[1] ? n2[1].toLowerCase() : "", a2 = !!n2[2], o2 = !!n2[3], e2 = 0;
    return a2 ? e2 = o2 ? (r2 = n2[2] + n2[3] + n2[4], n2[2].length + n2[3].length) : (r2 = n2[2] + n2[4], n2[2].length) : o2 ? (r2 = n2[3] + n2[4], e2 = n2[3].length) : r2 = n2[4], i2 === "file:" ? 2 <= e2 && (r2 = r2.slice(2)) : isSpecial(i2) ? r2 = n2[4] : i2 ? a2 && (r2 = r2.slice(2)) : 2 <= e2 && isSpecial(t2.protocol) && (r2 = n2[4]), { protocol: i2, slashes: a2 || isSpecial(i2), slashesCount: e2, rest: r2 };
  }
  function resolve(e2, t2) {
    if (e2 === "")
      return t2;
    for (var r2 = (t2 || "/").split("/").slice(0, -1).concat(e2.split("/")), n2 = r2.length, e2 = r2[n2 - 1], i2 = false, a2 = 0; n2--; )
      r2[n2] === "." ? r2.splice(n2, 1) : r2[n2] === ".." ? (r2.splice(n2, 1), a2++) : a2 && (n2 === 0 && (i2 = true), r2.splice(n2, 1), a2--);
    return i2 && r2.unshift(""), e2 !== "." && e2 !== ".." || r2.push(""), r2.join("/");
  }
  function Url(e2, t2, r2) {
    if (e2 = trimLeft(e2), !(this instanceof Url))
      return new Url(e2, t2, r2);
    var n2, i2, a2, o2, s2, l2 = rules.slice(), c2 = typeof t2, u2 = this, h2 = 0;
    for (c2 != "object" && c2 != "string" && (r2 = t2, t2 = null), r2 && typeof r2 != "function" && (r2 = qs.parse), n2 = !(c2 = extractProtocol(e2 || "", t2 = lolcation(t2))).protocol && !c2.slashes, u2.slashes = c2.slashes || n2 && t2.slashes, u2.protocol = c2.protocol || t2.protocol || "", e2 = c2.rest, (c2.protocol === "file:" && (c2.slashesCount !== 2 || windowsDriveLetter.test(e2)) || !c2.slashes && (c2.protocol || c2.slashesCount < 2 || !isSpecial(u2.protocol))) && (l2[3] = [/(.*)/, "pathname"]); h2 < l2.length; h2++)
      typeof (a2 = l2[h2]) != "function" ? (i2 = a2[0], s2 = a2[1], i2 != i2 ? u2[s2] = e2 : typeof i2 == "string" ? ~(o2 = e2.indexOf(i2)) && (e2 = typeof a2[2] == "number" ? (u2[s2] = e2.slice(0, o2), e2.slice(o2 + a2[2])) : (u2[s2] = e2.slice(o2), e2.slice(0, o2))) : (o2 = i2.exec(e2)) && (u2[s2] = o2[1], e2 = e2.slice(0, o2.index)), u2[s2] = u2[s2] || n2 && a2[3] && t2[s2] || "", a2[4] && (u2[s2] = u2[s2].toLowerCase())) : e2 = a2(e2, u2);
    r2 && (u2.query = r2(u2.query)), n2 && t2.slashes && u2.pathname.charAt(0) !== "/" && (u2.pathname !== "" || t2.pathname !== "") && (u2.pathname = resolve(u2.pathname, t2.pathname)), u2.pathname.charAt(0) !== "/" && isSpecial(u2.protocol) && (u2.pathname = "/" + u2.pathname), required(u2.port, u2.protocol) || (u2.host = u2.hostname, u2.port = ""), u2.username = u2.password = "", u2.auth && (a2 = u2.auth.split(":"), u2.username = a2[0] || "", u2.password = a2[1] || ""), u2.origin = u2.protocol !== "file:" && isSpecial(u2.protocol) && u2.host ? u2.protocol + "//" + u2.host : "null", u2.href = u2.toString();
  }
  function set(e2, t2, r2) {
    var n2, i2 = this;
    switch (e2) {
      case "query":
        typeof t2 == "string" && t2.length && (t2 = (r2 || qs.parse)(t2)), i2[e2] = t2;
        break;
      case "port":
        i2[e2] = t2, required(t2, i2.protocol) ? t2 && (i2.host = i2.hostname + ":" + t2) : (i2.host = i2.hostname, i2[e2] = "");
        break;
      case "hostname":
        i2[e2] = t2, i2.port && (t2 += ":" + i2.port), i2.host = t2;
        break;
      case "host":
        i2[e2] = t2, /:\d+$/.test(t2) ? (t2 = t2.split(":"), i2.port = t2.pop(), i2.hostname = t2.join(":")) : (i2.hostname = t2, i2.port = "");
        break;
      case "protocol":
        i2.protocol = t2.toLowerCase(), i2.slashes = !r2;
        break;
      case "pathname":
      case "hash":
        t2 ? (n2 = e2 === "pathname" ? "/" : "#", i2[e2] = t2.charAt(0) !== n2 ? n2 + t2 : t2) : i2[e2] = t2;
        break;
      default:
        i2[e2] = t2;
    }
    for (var a2 = 0; a2 < rules.length; a2++) {
      var o2 = rules[a2];
      o2[4] && (i2[o2[1]] = i2[o2[1]].toLowerCase());
    }
    return i2.origin = i2.protocol !== "file:" && isSpecial(i2.protocol) && i2.host ? i2.protocol + "//" + i2.host : "null", i2.href = i2.toString(), i2;
  }
  function toString(e2) {
    e2 && typeof e2 == "function" || (e2 = qs.stringify);
    var t2 = this, r2 = t2.protocol;
    r2 && r2.charAt(r2.length - 1) !== ":" && (r2 += ":");
    r2 += t2.slashes || isSpecial(t2.protocol) ? "//" : "";
    return t2.username && (r2 += t2.username, t2.password && (r2 += ":" + t2.password), r2 += "@"), r2 += t2.host + t2.pathname, (e2 = typeof t2.query == "object" ? e2(t2.query) : t2.query) && (r2 += e2.charAt(0) !== "?" ? "?" + e2 : e2), t2.hash && (r2 += t2.hash), r2;
  }
  Url.prototype = { set, toString }, Url.extractProtocol = extractProtocol, Url.location = lolcation, Url.trimLeft = trimLeft, Url.qs = qs;
  var urlParse = Url;
  function ease(e2) {
    return e2 < 0.5 ? 2 * e2 * e2 : (4 - 2 * e2) * e2 - 1;
  }
  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  let isUserScrolling = false, userScrollingTimeout, isScrollingHappening = false;
  function scrollTo(l2, c2 = {}) {
    return new Promise((e2, t2) => {
      c2 = Object.assign({ duration: 500, easing: ease, offset: 0, align: "top", onFinish: null }, c2);
      var r2 = document.documentElement, n2 = window.innerHeight, i2 = r2.scrollHeight - n2, a2 = window.pageYOffset;
      isScrollingHappening = true;
      let o2 = a2;
      r2 = isNaN(l2) ? l2.getBoundingClientRect() : 0;
      c2.align === "center" ? (o2 += r2.top + r2.height / 2, o2 -= n2 / 2, o2 -= c2.offset) : c2.align === "bottom" ? (o2 += r2.bottom, o2 -= n2, o2 += c2.offset) : (o2 += r2.top, o2 -= c2.offset), o2 = Math.max(Math.min(i2, o2), 0);
      i2 = o2 - a2;
      const s2 = { targetY: o2, deltaY: i2, duration: c2.duration, easing: c2.easing, onFinish() {
        c2.onFinish && c2.onFinish(), e2();
      }, startTime: Date.now(), lastY: a2, step: scrollTo.step };
      requestAnimationFrame$1(s2.step.bind(s2));
    });
  }
  function smoothScrollOnAnchorLinks(i2 = {}) {
    i2 = __deepMerge$7({ scroll: {}, checkPathNames: true }, i2), querySelectorLive('a:not([is])[href*="#"]', (n2) => {
      n2.addEventListener("click", (e2) => {
        var t2 = urlParse(n2.getAttribute("href")), r2 = urlParse();
        t2.hash && t2.hash !== "#" && (i2.checkPathNames && r2.pathname !== t2.pathname || (r2 = document.querySelector(t2.hash)) && (e2.preventDefault(), history.pushState({}, null, t2.hash), scrollTo(r2, i2.scroll)));
      });
    });
  }
  function scrollToLocationHash(e2 = {}) {
    e2 = __deepMerge$7({ scroll: {} }, e2);
    var t2 = document.location.hash;
    if (t2) {
      t2 = document.querySelector(t2);
      return t2 ? ("scrollRestoration" in history && (history.scrollRestoration = "manual"), scrollTo(t2, e2.scroll)) : void 0;
    }
  }
  function smoothScrollOnPageLoad(e2 = {}) {
    scrollToLocationHash(e2 = __deepMerge$7({ scroll: {} }, e2));
  }
  function smoothScrollOnHashChange(t2 = {}) {
    t2 = __deepMerge$7({ scroll: {} }, t2), window.addEventListener("hashchange", (e2) => {
      scrollToLocationHash(t2);
    });
  }
  function smoothScroll(e2 = {}) {
    smoothScrollOnPageLoad(e2 = __deepMerge$7({ scroll: {} }, e2)), smoothScrollOnAnchorLinks(e2), smoothScrollOnHashChange(e2);
  }
  function expandPleasantCssClassname(e2) {
    const i2 = [], t2 = e2.split(/\s+/);
    let a2 = "";
    return t2.forEach((t3) => {
      if (t3.slice(0, 1) != "@") {
        const e3 = t3.split(":");
        if (e3.length === 1) {
          let e4 = t3;
          a2 !== "" && (e4 = t3 + a2), i2.push(e4);
        } else {
          const n2 = e3[0];
          let r2 = n2;
          a2 !== "" && (r2 = n2 + a2), i2.push(r2), e3.forEach((e4, t4) => {
            0 < t4 && (r2 = n2 + "--" + e4, a2 !== "" && (r2 += a2), i2.push(r2));
          });
        }
      } else
        a2 = t3.replace("@", "___");
    }), i2.join(" ");
  }
  function expandPleasantCssClassnamesLive(e2) {
    querySelectorLive('[class*=":"]:not(code [class*=":"]):not(template [class*=":"]),[class*="@"]:not(code [class*="@"]):not(template [class*="@"])', (e3) => {
      var t2 = expandPleasantCssClassname(e3.getAttribute("class"));
      e3.setAttribute("class", t2);
    }, { rootNode: (e2 = Object.assign({ rootNode: document }, e2)) == null ? void 0 : e2.rootNode, once: false });
  }
  document.addEventListener("mousewheel", (e2) => {
    isScrollingHappening && (isUserScrolling = true, clearTimeout(userScrollingTimeout), userScrollingTimeout = setTimeout(() => {
      isUserScrolling = false;
    }, 200));
  }), scrollTo.step = function() {
    if (this.lastY !== window.pageYOffset && this.onFinish)
      return isScrollingHappening = false, void this.onFinish();
    var e2 = Math.min((Date.now() - this.startTime) / this.duration, 1), t2 = this.targetY - (1 - this.easing(e2)) * this.deltaY;
    window.scrollTo(window.scrollX, t2), e2 === 1 || isUserScrolling ? (isScrollingHappening = false, this.onFinish && this.onFinish()) : (this.lastY = window.pageYOffset, requestAnimationFrame$1(this.step.bind(this)));
  };
  const REVISION = "134", CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, KeepStencilOp = 7680, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, GLSL3 = "300 es";
  class EventDispatcher {
    addEventListener(e2, t2) {
      this._listeners === void 0 && (this._listeners = {});
      const r2 = this._listeners;
      r2[e2] === void 0 && (r2[e2] = []), r2[e2].indexOf(t2) === -1 && r2[e2].push(t2);
    }
    hasEventListener(e2, t2) {
      if (this._listeners === void 0)
        return false;
      const r2 = this._listeners;
      return r2[e2] !== void 0 && r2[e2].indexOf(t2) !== -1;
    }
    removeEventListener(e2, t2) {
      if (this._listeners !== void 0) {
        const r2 = this._listeners[e2];
        r2 === void 0 || (t2 = r2.indexOf(t2)) !== -1 && r2.splice(t2, 1);
      }
    }
    dispatchEvent(r2) {
      if (this._listeners !== void 0) {
        const e2 = this._listeners[r2.type];
        if (e2 !== void 0) {
          r2.target = this;
          const n2 = e2.slice(0);
          for (let e3 = 0, t2 = n2.length; e3 < t2; e3++)
            n2[e3].call(this, r2);
          r2.target = null;
        }
      }
    }
  }
  const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI, _lut = [];
  for (let i2 = 0; i2 < 256; i2++)
    _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
  const hasRandomUUID = typeof crypto != "undefined" && "randomUUID" in crypto;
  function generateUUID() {
    if (hasRandomUUID)
      return crypto.randomUUID().toUpperCase();
    var e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
    const i2 = _lut[255 & e2] + _lut[e2 >> 8 & 255] + _lut[e2 >> 16 & 255] + _lut[e2 >> 24 & 255] + "-" + _lut[255 & t2] + _lut[t2 >> 8 & 255] + "-" + _lut[t2 >> 16 & 15 | 64] + _lut[t2 >> 24 & 255] + "-" + _lut[63 & r2 | 128] + _lut[r2 >> 8 & 255] + "-" + _lut[r2 >> 16 & 255] + _lut[r2 >> 24 & 255] + _lut[255 & n2] + _lut[n2 >> 8 & 255] + _lut[n2 >> 16 & 255] + _lut[n2 >> 24 & 255];
    return i2.toUpperCase();
  }
  function clamp(e2, t2, r2) {
    return Math.max(t2, Math.min(r2, e2));
  }
  function euclideanModulo(e2, t2) {
    return (e2 % t2 + t2) % t2;
  }
  function lerp(e2, t2, r2) {
    return (1 - r2) * e2 + r2 * t2;
  }
  function isPowerOfTwo(e2) {
    return (e2 & e2 - 1) == 0 && e2 !== 0;
  }
  function floorPowerOfTwo(e2) {
    return Math.pow(2, Math.floor(Math.log(e2) / Math.LN2));
  }
  class Vector2 {
    constructor(e2 = 0, t2 = 0) {
      this.x = e2, this.y = t2;
    }
    get width() {
      return this.x;
    }
    set width(e2) {
      this.x = e2;
    }
    get height() {
      return this.y;
    }
    set height(e2) {
      this.y = e2;
    }
    set(e2, t2) {
      return this.x = e2, this.y = t2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this;
    }
    add(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this);
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this;
    }
    sub(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this);
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this;
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    applyMatrix3(e2) {
      var t2 = this.x, r2 = this.y, e2 = e2.elements;
      return this.x = e2[0] * t2 + e2[3] * r2 + e2[6], this.y = e2[1] * t2 + e2[4] * r2 + e2[7], this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
    }
    clampLength(e2, t2) {
      var r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y;
    }
    cross(e2) {
      return this.x * e2.y - this.y * e2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      var t2 = this.x - e2.x, e2 = this.y - e2.y;
      return t2 * t2 + e2 * e2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
    }
    fromBufferAttribute(e2, t2, r2) {
      return r2 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this;
    }
    rotateAround(e2, t2) {
      var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = this.x - e2.x, t2 = this.y - e2.y;
      return this.x = i2 * r2 - t2 * n2 + e2.x, this.y = i2 * n2 + t2 * r2 + e2.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  Vector2.prototype.isVector2 = true;
  class Matrix3 {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(e2, t2, r2, n2, i2, a2, o2, s2, l2) {
      const c2 = this.elements;
      return c2[0] = e2, c2[1] = n2, c2[2] = o2, c2[3] = t2, c2[4] = i2, c2[5] = s2, c2[6] = r2, c2[7] = a2, c2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e2) {
      const t2 = this.elements;
      e2 = e2.elements;
      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], this;
    }
    extractBasis(e2, t2, r2) {
      return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), r2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e2) {
      e2 = e2.elements;
      return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      var r2 = e2.elements, n2 = t2.elements;
      const i2 = this.elements;
      var a2 = r2[0], o2 = r2[3], s2 = r2[6], l2 = r2[1], c2 = r2[4], u2 = r2[7], h2 = r2[2], d2 = r2[5], p2 = r2[8], f2 = n2[0], m2 = n2[3], g2 = n2[6], v2 = n2[1], y = n2[4], e2 = n2[7], t2 = n2[2], r2 = n2[5], n2 = n2[8];
      return i2[0] = a2 * f2 + o2 * v2 + s2 * t2, i2[3] = a2 * m2 + o2 * y + s2 * r2, i2[6] = a2 * g2 + o2 * e2 + s2 * n2, i2[1] = l2 * f2 + c2 * v2 + u2 * t2, i2[4] = l2 * m2 + c2 * y + u2 * r2, i2[7] = l2 * g2 + c2 * e2 + u2 * n2, i2[2] = h2 * f2 + d2 * v2 + p2 * t2, i2[5] = h2 * m2 + d2 * y + p2 * r2, i2[8] = h2 * g2 + d2 * e2 + p2 * n2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
    }
    determinant() {
      var e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], e2 = e2[8];
      return t2 * a2 * e2 - t2 * o2 * l2 - r2 * i2 * e2 + r2 * o2 * s2 + n2 * i2 * l2 - n2 * a2 * s2;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = c2 * a2 - o2 * l2, h2 = o2 * s2 - c2 * i2, d2 = l2 * i2 - a2 * s2, p2 = t2 * u2 + r2 * h2 + n2 * d2;
      if (p2 == 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var f2 = 1 / p2;
      return e2[0] = u2 * f2, e2[1] = (n2 * l2 - c2 * r2) * f2, e2[2] = (o2 * r2 - n2 * a2) * f2, e2[3] = h2 * f2, e2[4] = (c2 * t2 - n2 * s2) * f2, e2[5] = (n2 * i2 - o2 * t2) * f2, e2[6] = d2 * f2, e2[7] = (r2 * s2 - l2 * t2) * f2, e2[8] = (a2 * t2 - r2 * i2) * f2, this;
    }
    transpose() {
      var e2;
      const t2 = this.elements;
      return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
    }
    getNormalMatrix(e2) {
      return this.setFromMatrix4(e2).invert().transpose();
    }
    transposeIntoArray(e2) {
      var t2 = this.elements;
      return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
    }
    setUvTransform(e2, t2, r2, n2, i2, a2, o2) {
      var s2 = Math.cos(i2), i2 = Math.sin(i2);
      return this.set(r2 * s2, r2 * i2, -r2 * (s2 * a2 + i2 * o2) + a2 + e2, -n2 * i2, n2 * s2, -n2 * (-i2 * a2 + s2 * o2) + o2 + t2, 0, 0, 1), this;
    }
    scale(e2, t2) {
      const r2 = this.elements;
      return r2[0] *= e2, r2[3] *= e2, r2[6] *= e2, r2[1] *= t2, r2[4] *= t2, r2[7] *= t2, this;
    }
    rotate(e2) {
      var t2 = Math.cos(e2), r2 = Math.sin(e2);
      const n2 = this.elements;
      var i2 = n2[0], a2 = n2[3], o2 = n2[6], s2 = n2[1], l2 = n2[4], e2 = n2[7];
      return n2[0] = t2 * i2 + r2 * s2, n2[3] = t2 * a2 + r2 * l2, n2[6] = t2 * o2 + r2 * e2, n2[1] = -r2 * i2 + t2 * s2, n2[4] = -r2 * a2 + t2 * l2, n2[7] = -r2 * o2 + t2 * e2, this;
    }
    translate(e2, t2) {
      const r2 = this.elements;
      return r2[0] += e2 * r2[2], r2[3] += e2 * r2[5], r2[6] += e2 * r2[8], r2[1] += t2 * r2[2], r2[4] += t2 * r2[5], r2[7] += t2 * r2[8], this;
    }
    equals(e2) {
      var t2 = this.elements, r2 = e2.elements;
      for (let e3 = 0; e3 < 9; e3++)
        if (t2[e3] !== r2[e3])
          return false;
      return true;
    }
    fromArray(t2, r2 = 0) {
      for (let e2 = 0; e2 < 9; e2++)
        this.elements[e2] = t2[e2 + r2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      var r2 = this.elements;
      return e2[t2] = r2[0], e2[t2 + 1] = r2[1], e2[t2 + 2] = r2[2], e2[t2 + 3] = r2[3], e2[t2 + 4] = r2[4], e2[t2 + 5] = r2[5], e2[t2 + 6] = r2[6], e2[t2 + 7] = r2[7], e2[t2 + 8] = r2[8], e2;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  function arrayMax(r2) {
    if (r2.length === 0)
      return -1 / 0;
    let n2 = r2[0];
    for (let e2 = 1, t2 = r2.length; e2 < t2; ++e2)
      r2[e2] > n2 && (n2 = r2[e2]);
    return n2;
  }
  function createElementNS(e2) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e2);
  }
  function hashString(r2, e2 = 0) {
    let n2 = 3735928559 ^ e2, i2 = 1103547991 ^ e2;
    for (let e3 = 0, t2; e3 < r2.length; e3++)
      t2 = r2.charCodeAt(e3), n2 = Math.imul(n2 ^ t2, 2654435761), i2 = Math.imul(i2 ^ t2, 1597334677);
    return n2 = Math.imul(n2 ^ n2 >>> 16, 2246822507) ^ Math.imul(i2 ^ i2 >>> 13, 3266489909), i2 = Math.imul(i2 ^ i2 >>> 16, 2246822507) ^ Math.imul(n2 ^ n2 >>> 13, 3266489909), 4294967296 * (2097151 & i2) + (n2 >>> 0);
  }
  Matrix3.prototype.isMatrix3 = true;
  let _canvas;
  class ImageUtils {
    static getDataURL(e2) {
      if (/^data:/i.test(e2.src))
        return e2.src;
      if (typeof HTMLCanvasElement == "undefined")
        return e2.src;
      let t2;
      if (e2 instanceof HTMLCanvasElement)
        t2 = e2;
      else {
        _canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = e2.width, _canvas.height = e2.height;
        const r2 = _canvas.getContext("2d");
        e2 instanceof ImageData ? r2.putImageData(e2, 0, 0) : r2.drawImage(e2, 0, 0, e2.width, e2.height), t2 = _canvas;
      }
      return 2048 < t2.width || 2048 < t2.height ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e2), t2.toDataURL("image/jpeg", 0.6)) : t2.toDataURL("image/png");
    }
  }
  let textureId = 0;
  class Texture extends EventDispatcher {
    constructor(e2 = Texture.DEFAULT_IMAGE, t2 = Texture.DEFAULT_MAPPING, r2 = ClampToEdgeWrapping, n2 = ClampToEdgeWrapping, i2 = LinearFilter, a2 = LinearMipmapLinearFilter, o2 = RGBAFormat, s2 = UnsignedByteType, l2 = 1, c2 = LinearEncoding) {
      super(), Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = generateUUID(), this.name = "", this.image = e2, this.mipmaps = [], this.mapping = t2, this.wrapS = r2, this.wrapT = n2, this.magFilter = i2, this.minFilter = a2, this.anisotropy = l2, this.format = o2, this.internalFormat = null, this.type = s2, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Matrix3(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.name = e2.name, this.image = e2.image, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.encoding = e2.encoding, this.userData = JSON.parse(JSON.stringify(e2.userData)), this;
    }
    toJSON(e2) {
      var t2 = e2 === void 0 || typeof e2 == "string";
      if (!t2 && e2.textures[this.uuid] !== void 0)
        return e2.textures[this.uuid];
      const r2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      if (this.image !== void 0) {
        const n2 = this.image;
        if (n2.uuid === void 0 && (n2.uuid = generateUUID()), !t2 && e2.images[n2.uuid] === void 0) {
          let r3;
          if (Array.isArray(n2)) {
            r3 = [];
            for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
              n2[e3].isDataTexture ? r3.push(serializeImage(n2[e3].image)) : r3.push(serializeImage(n2[e3]));
          } else
            r3 = serializeImage(n2);
          e2.images[n2.uuid] = { uuid: n2.uuid, url: r3 };
        }
        r2.image = n2.uuid;
      }
      return JSON.stringify(this.userData) !== "{}" && (r2.userData = this.userData), t2 || (e2.textures[this.uuid] = r2), r2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e2) {
      if (this.mapping !== UVMapping)
        return e2;
      if (e2.applyMatrix3(this.matrix), e2.x < 0 || 1 < e2.x)
        switch (this.wrapS) {
          case RepeatWrapping:
            e2.x = e2.x - Math.floor(e2.x);
            break;
          case ClampToEdgeWrapping:
            e2.x = e2.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            Math.abs(Math.floor(e2.x) % 2) === 1 ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
        }
      if (e2.y < 0 || 1 < e2.y)
        switch (this.wrapT) {
          case RepeatWrapping:
            e2.y = e2.y - Math.floor(e2.y);
            break;
          case ClampToEdgeWrapping:
            e2.y = e2.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            Math.abs(Math.floor(e2.y) % 2) === 1 ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
        }
      return this.flipY && (e2.y = 1 - e2.y), e2;
    }
    set needsUpdate(e2) {
      e2 === true && this.version++;
    }
  }
  function serializeImage(e2) {
    return typeof HTMLImageElement != "undefined" && e2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e2 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e2 instanceof ImageBitmap ? ImageUtils.getDataURL(e2) : e2.data ? { data: Array.prototype.slice.call(e2.data), width: e2.width, height: e2.height, type: e2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = UVMapping, Texture.prototype.isTexture = true;
  class Vector4 {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = 1) {
      this.x = e2, this.y = t2, this.z = r2, this.w = n2;
    }
    get width() {
      return this.z;
    }
    set width(e2) {
      this.z = e2;
    }
    get height() {
      return this.w;
    }
    set height(e2) {
      this.w = e2;
    }
    set(e2, t2, r2, n2) {
      return this.x = e2, this.y = t2, this.z = r2, this.w = n2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this.w = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setW(e2) {
      return this.w = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        case 3:
          this.w = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = e2.w !== void 0 ? e2.w : 1, this;
    }
    add(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this.w += e2.w, this);
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this.w += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this.w = e2.w + t2.w, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this.w += e2.w * t2, this;
    }
    sub(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this.w -= e2.w, this);
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this.w -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this.w = e2.w - t2.w, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this.w *= e2.w, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2, this;
    }
    applyMatrix4(e2) {
      var t2 = this.x, r2 = this.y, n2 = this.z, i2 = this.w, e2 = e2.elements;
      return this.x = e2[0] * t2 + e2[4] * r2 + e2[8] * n2 + e2[12] * i2, this.y = e2[1] * t2 + e2[5] * r2 + e2[9] * n2 + e2[13] * i2, this.z = e2[2] * t2 + e2[6] * r2 + e2[10] * n2 + e2[14] * i2, this.w = e2[3] * t2 + e2[7] * r2 + e2[11] * n2 + e2[15] * i2, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    setAxisAngleFromQuaternion(e2) {
      this.w = 2 * Math.acos(e2.w);
      var t2 = Math.sqrt(1 - e2.w * e2.w);
      return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e2.x / t2, this.y = e2.y / t2, this.z = e2.z / t2), this;
    }
    setAxisAngleFromRotationMatrix(e2) {
      let t2, r2, n2, i2;
      var a2 = e2.elements, o2 = a2[0], s2 = a2[4], l2 = a2[8], c2 = a2[1], u2 = a2[5], h2 = a2[9], d2 = a2[2], p2 = a2[6], f2 = a2[10];
      if (Math.abs(s2 - c2) < 0.01 && Math.abs(l2 - d2) < 0.01 && Math.abs(h2 - p2) < 0.01) {
        if (Math.abs(s2 + c2) < 0.1 && Math.abs(l2 + d2) < 0.1 && Math.abs(h2 + p2) < 0.1 && Math.abs(o2 + u2 + f2 - 3) < 0.1)
          return this.set(1, 0, 0, 0), this;
        t2 = Math.PI;
        var m2 = (o2 + 1) / 2, g2 = (u2 + 1) / 2, v2 = (f2 + 1) / 2, y = (s2 + c2) / 4, e2 = (l2 + d2) / 4, a2 = (h2 + p2) / 4;
        return g2 < m2 && v2 < m2 ? i2 = m2 < 0.01 ? (r2 = 0, n2 = 0.707106781) : (r2 = Math.sqrt(m2), n2 = y / r2, e2 / r2) : v2 < g2 ? i2 = g2 < 0.01 ? (r2 = 0.707106781, n2 = 0, 0.707106781) : (n2 = Math.sqrt(g2), r2 = y / n2, a2 / n2) : v2 < 0.01 ? (r2 = 0.707106781, n2 = 0.707106781, i2 = 0) : (i2 = Math.sqrt(v2), r2 = e2 / i2, n2 = a2 / i2), this.set(r2, n2, i2, t2), this;
      }
      let _2 = Math.sqrt((p2 - h2) * (p2 - h2) + (l2 - d2) * (l2 - d2) + (c2 - s2) * (c2 - s2));
      return Math.abs(_2) < 1e-3 && (_2 = 1), this.x = (p2 - h2) / _2, this.y = (l2 - d2) / _2, this.z = (c2 - s2) / _2, this.w = Math.acos((o2 + u2 + f2 - 1) / 2), this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this.w = Math.min(this.w, e2.w), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this.w = Math.max(this.w, e2.w), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this.w = Math.max(e2.w, Math.min(t2.w, this.w)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this.w = Math.max(e2, Math.min(t2, this.w)), this;
    }
    clampLength(e2, t2) {
      var r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z + this.w * e2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this.w += (e2.w - this.w) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this.z = e2.z + (t2.z - e2.z) * r2, this.w = e2.w + (t2.w - e2.w) * r2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z && e2.w === this.w;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this.w = e2[t2 + 3], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2[t2 + 3] = this.w, e2;
    }
    fromBufferAttribute(e2, t2, r2) {
      return r2 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this.w = e2.getW(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  Vector4.prototype.isVector4 = true;
  class WebGLRenderTarget extends EventDispatcher {
    constructor(e2, t2, r2 = {}) {
      super(), this.width = e2, this.height = t2, this.depth = 1, this.scissor = new Vector4(0, 0, e2, t2), this.scissorTest = false, this.viewport = new Vector4(0, 0, e2, t2), this.texture = new Texture(void 0, r2.mapping, r2.wrapS, r2.wrapT, r2.magFilter, r2.minFilter, r2.format, r2.type, r2.anisotropy, r2.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = { width: e2, height: t2, depth: 1 }, this.texture.generateMipmaps = r2.generateMipmaps !== void 0 && r2.generateMipmaps, this.texture.internalFormat = r2.internalFormat !== void 0 ? r2.internalFormat : null, this.texture.minFilter = r2.minFilter !== void 0 ? r2.minFilter : LinearFilter, this.depthBuffer = r2.depthBuffer === void 0 || r2.depthBuffer, this.stencilBuffer = r2.stencilBuffer !== void 0 && r2.stencilBuffer, this.depthTexture = r2.depthTexture !== void 0 ? r2.depthTexture : null;
    }
    setTexture(e2) {
      e2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e2;
    }
    setSize(e2, t2, r2 = 1) {
      this.width === e2 && this.height === t2 && this.depth === r2 || (this.width = e2, this.height = t2, this.depth = r2, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = r2, this.dispose()), this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.copy(e2.viewport), this.texture = e2.texture.clone(), this.texture.image = __spreadValues({}, this.texture.image), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, this.depthTexture = e2.depthTexture, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
  class WebGLMultipleRenderTargets extends WebGLRenderTarget {
    constructor(e2, t2, r2) {
      super(e2, t2);
      const n2 = this.texture;
      this.texture = [];
      for (let e3 = 0; e3 < r2; e3++)
        this.texture[e3] = n2.clone();
    }
    setSize(r2, n2, i2 = 1) {
      if (this.width !== r2 || this.height !== n2 || this.depth !== i2) {
        this.width = r2, this.height = n2, this.depth = i2;
        for (let e2 = 0, t2 = this.texture.length; e2 < t2; e2++)
          this.texture[e2].image.width = r2, this.texture[e2].image.height = n2, this.texture[e2].image.depth = i2;
        this.dispose();
      }
      return this.viewport.set(0, 0, r2, n2), this.scissor.set(0, 0, r2, n2), this;
    }
    copy(r2) {
      this.dispose(), this.width = r2.width, this.height = r2.height, this.depth = r2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = r2.depthBuffer, this.stencilBuffer = r2.stencilBuffer, this.depthTexture = r2.depthTexture;
      for (let e2 = this.texture.length = 0, t2 = r2.texture.length; e2 < t2; e2++)
        this.texture[e2] = r2.texture[e2].clone();
      return this;
    }
  }
  WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
  class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
    constructor(e2, t2, r2) {
      super(e2, t2, r2), this.samples = 4;
    }
    copy(e2) {
      return super.copy.call(this, e2), this.samples = e2.samples, this;
    }
  }
  WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
  class Quaternion {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = 1) {
      this._x = e2, this._y = t2, this._z = r2, this._w = n2;
    }
    static slerp(e2, t2, r2, n2) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), r2.slerpQuaternions(e2, t2, n2);
    }
    static slerpFlat(e2, t2, r2, n2, i2, a2, o2) {
      let s2 = r2[n2 + 0], l2 = r2[n2 + 1], c2 = r2[n2 + 2], u2 = r2[n2 + 3];
      var h2 = i2[a2 + 0], d2 = i2[a2 + 1], p2 = i2[a2 + 2], r2 = i2[a2 + 3];
      if (o2 === 0)
        return e2[t2 + 0] = s2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, void (e2[t2 + 3] = u2);
      if (o2 === 1)
        return e2[t2 + 0] = h2, e2[t2 + 1] = d2, e2[t2 + 2] = p2, void (e2[t2 + 3] = r2);
      if (u2 !== r2 || s2 !== h2 || l2 !== d2 || c2 !== p2) {
        let e3 = 1 - o2;
        n2 = s2 * h2 + l2 * d2 + c2 * p2 + u2 * r2, i2 = 0 <= n2 ? 1 : -1, a2 = 1 - n2 * n2;
        a2 > Number.EPSILON && (a2 = Math.sqrt(a2), n2 = Math.atan2(a2, n2 * i2), e3 = Math.sin(e3 * n2) / a2, o2 = Math.sin(o2 * n2) / a2);
        i2 = o2 * i2;
        s2 = s2 * e3 + h2 * i2, l2 = l2 * e3 + d2 * i2, c2 = c2 * e3 + p2 * i2, u2 = u2 * e3 + r2 * i2, e3 === 1 - o2 && (o2 = 1 / Math.sqrt(s2 * s2 + l2 * l2 + c2 * c2 + u2 * u2), s2 *= o2, l2 *= o2, c2 *= o2, u2 *= o2);
      }
      e2[t2] = s2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, e2[t2 + 3] = u2;
    }
    static multiplyQuaternionsFlat(e2, t2, r2, n2, i2, a2) {
      var o2 = r2[n2], s2 = r2[n2 + 1], l2 = r2[n2 + 2], c2 = r2[n2 + 3], u2 = i2[a2], r2 = i2[a2 + 1], n2 = i2[a2 + 2], a2 = i2[a2 + 3];
      return e2[t2] = o2 * a2 + c2 * u2 + s2 * n2 - l2 * r2, e2[t2 + 1] = s2 * a2 + c2 * r2 + l2 * u2 - o2 * n2, e2[t2 + 2] = l2 * a2 + c2 * n2 + o2 * r2 - s2 * u2, e2[t2 + 3] = c2 * a2 - o2 * u2 - s2 * r2 - l2 * n2, e2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e2) {
      this._w = e2, this._onChangeCallback();
    }
    set(e2, t2, r2, n2) {
      return this._x = e2, this._y = t2, this._z = r2, this._w = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e2) {
      return this._x = e2.x, this._y = e2.y, this._z = e2.z, this._w = e2.w, this._onChangeCallback(), this;
    }
    setFromEuler(e2, t2) {
      if (!e2 || !e2.isEuler)
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      var r2 = e2._x, n2 = e2._y, i2 = e2._z, a2 = e2._order;
      const o2 = Math.cos, s2 = Math.sin;
      var l2 = o2(r2 / 2), c2 = o2(n2 / 2), u2 = o2(i2 / 2), h2 = s2(r2 / 2), d2 = s2(n2 / 2), p2 = s2(i2 / 2);
      switch (a2) {
        case "XYZ":
          this._x = h2 * c2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - h2 * c2 * p2, this._z = l2 * c2 * p2 + h2 * d2 * u2, this._w = l2 * c2 * u2 - h2 * d2 * p2;
          break;
        case "YXZ":
          this._x = h2 * c2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - h2 * c2 * p2, this._z = l2 * c2 * p2 - h2 * d2 * u2, this._w = l2 * c2 * u2 + h2 * d2 * p2;
          break;
        case "ZXY":
          this._x = h2 * c2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + h2 * c2 * p2, this._z = l2 * c2 * p2 + h2 * d2 * u2, this._w = l2 * c2 * u2 - h2 * d2 * p2;
          break;
        case "ZYX":
          this._x = h2 * c2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + h2 * c2 * p2, this._z = l2 * c2 * p2 - h2 * d2 * u2, this._w = l2 * c2 * u2 + h2 * d2 * p2;
          break;
        case "YZX":
          this._x = h2 * c2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 + h2 * c2 * p2, this._z = l2 * c2 * p2 - h2 * d2 * u2, this._w = l2 * c2 * u2 - h2 * d2 * p2;
          break;
        case "XZY":
          this._x = h2 * c2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 - h2 * c2 * p2, this._z = l2 * c2 * p2 + h2 * d2 * u2, this._w = l2 * c2 * u2 + h2 * d2 * p2;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a2);
      }
      return t2 !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e2, t2) {
      var r2 = t2 / 2, t2 = Math.sin(r2);
      return this._x = e2.x * t2, this._y = e2.y * t2, this._z = e2.z * t2, this._w = Math.cos(r2), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2) {
      var t2, r2 = e2.elements, n2 = r2[0], i2 = r2[4], a2 = r2[8], o2 = r2[1], s2 = r2[5], l2 = r2[9], c2 = r2[2], u2 = r2[6], e2 = r2[10], r2 = n2 + s2 + e2;
      return 0 < r2 ? (r2 = 0.5 / Math.sqrt(r2 + 1), this._w = 0.25 / r2, this._x = (u2 - l2) * r2, this._y = (a2 - c2) * r2, this._z = (o2 - i2) * r2) : s2 < n2 && e2 < n2 ? (t2 = 2 * Math.sqrt(1 + n2 - s2 - e2), this._w = (u2 - l2) / t2, this._x = 0.25 * t2, this._y = (i2 + o2) / t2, this._z = (a2 + c2) / t2) : e2 < s2 ? (t2 = 2 * Math.sqrt(1 + s2 - n2 - e2), this._w = (a2 - c2) / t2, this._x = (i2 + o2) / t2, this._y = 0.25 * t2, this._z = (l2 + u2) / t2) : (s2 = 2 * Math.sqrt(1 + e2 - n2 - s2), this._w = (o2 - i2) / s2, this._x = (a2 + c2) / s2, this._y = (l2 + u2) / s2, this._z = 0.25 * s2), this._onChangeCallback(), this;
    }
    setFromUnitVectors(e2, t2) {
      let r2 = e2.dot(t2) + 1;
      return r2 < Number.EPSILON ? (r2 = 0, Math.abs(e2.x) > Math.abs(e2.z) ? (this._x = -e2.y, this._y = e2.x, this._z = 0) : (this._x = 0, this._y = -e2.z, this._z = e2.y)) : (this._x = e2.y * t2.z - e2.z * t2.y, this._y = e2.z * t2.x - e2.x * t2.z, this._z = e2.x * t2.y - e2.y * t2.x), this._w = r2, this.normalize();
    }
    angleTo(e2) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(e2), -1, 1)));
    }
    rotateTowards(e2, t2) {
      var r2 = this.angleTo(e2);
      if (r2 === 0)
        return this;
      r2 = Math.min(1, t2 / r2);
      return this.slerp(e2, r2), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e2) {
      return this._x * e2._x + this._y * e2._y + this._z * e2._z + this._w * e2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      var e2 = this.length();
      return e2 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (this._x = this._x * (e2 = 1 / e2), this._y = this._y * e2, this._z = this._z * e2, this._w = this._w * e2), this._onChangeCallback(), this;
    }
    multiply(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e2, t2)) : this.multiplyQuaternions(this, e2);
    }
    premultiply(e2) {
      return this.multiplyQuaternions(e2, this);
    }
    multiplyQuaternions(e2, t2) {
      var r2 = e2._x, n2 = e2._y, i2 = e2._z, a2 = e2._w, o2 = t2._x, s2 = t2._y, e2 = t2._z, t2 = t2._w;
      return this._x = r2 * t2 + a2 * o2 + n2 * e2 - i2 * s2, this._y = n2 * t2 + a2 * s2 + i2 * o2 - r2 * e2, this._z = i2 * t2 + a2 * e2 + r2 * s2 - n2 * o2, this._w = a2 * t2 - r2 * o2 - n2 * s2 - i2 * e2, this._onChangeCallback(), this;
    }
    slerp(e2, t2) {
      if (t2 === 0)
        return this;
      if (t2 === 1)
        return this.copy(e2);
      var r2 = this._x, n2 = this._y, i2 = this._z, a2 = this._w;
      let o2 = a2 * e2._w + r2 * e2._x + n2 * e2._y + i2 * e2._z;
      if (o2 < 0 ? (this._w = -e2._w, this._x = -e2._x, this._y = -e2._y, this._z = -e2._z, o2 = -o2) : this.copy(e2), 1 <= o2)
        return this._w = a2, this._x = r2, this._y = n2, this._z = i2, this;
      var s2 = 1 - o2 * o2;
      if (s2 <= Number.EPSILON) {
        var l2 = 1 - t2;
        return this._w = l2 * a2 + t2 * this._w, this._x = l2 * r2 + t2 * this._x, this._y = l2 * n2 + t2 * this._y, this._z = l2 * i2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      e2 = Math.sqrt(s2), l2 = Math.atan2(e2, o2), s2 = Math.sin((1 - t2) * l2) / e2, e2 = Math.sin(t2 * l2) / e2;
      return this._w = a2 * s2 + this._w * e2, this._x = r2 * s2 + this._x * e2, this._y = n2 * s2 + this._y * e2, this._z = i2 * s2 + this._z * e2, this._onChangeCallback(), this;
    }
    slerpQuaternions(e2, t2, r2) {
      this.copy(e2).slerp(t2, r2);
    }
    random() {
      var e2 = Math.random(), t2 = Math.sqrt(1 - e2), r2 = Math.sqrt(e2), n2 = 2 * Math.PI * Math.random(), e2 = 2 * Math.PI * Math.random();
      return this.set(t2 * Math.cos(n2), r2 * Math.sin(e2), r2 * Math.cos(e2), t2 * Math.sin(n2));
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._w === this._w;
    }
    fromArray(e2, t2 = 0) {
      return this._x = e2[t2], this._y = e2[t2 + 1], this._z = e2[t2 + 2], this._w = e2[t2 + 3], this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._w, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this._x = e2.getX(t2), this._y = e2.getY(t2), this._z = e2.getZ(t2), this._w = e2.getW(t2), this;
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
  }
  Quaternion.prototype.isQuaternion = true;
  class Vector3 {
    constructor(e2 = 0, t2 = 0, r2 = 0) {
      this.x = e2, this.y = t2, this.z = r2;
    }
    set(e2, t2, r2) {
      return r2 === void 0 && (r2 = this.z), this.x = e2, this.y = t2, this.z = r2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    add(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this);
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this;
    }
    sub(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this);
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this;
    }
    multiply(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e2, t2)) : (this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this);
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this;
    }
    multiplyVectors(e2, t2) {
      return this.x = e2.x * t2.x, this.y = e2.y * t2.y, this.z = e2.z * t2.z, this;
    }
    applyEuler(e2) {
      return e2 && e2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_quaternion$4.setFromEuler(e2));
    }
    applyAxisAngle(e2, t2) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e2, t2));
    }
    applyMatrix3(e2) {
      var t2 = this.x, r2 = this.y, n2 = this.z, e2 = e2.elements;
      return this.x = e2[0] * t2 + e2[3] * r2 + e2[6] * n2, this.y = e2[1] * t2 + e2[4] * r2 + e2[7] * n2, this.z = e2[2] * t2 + e2[5] * r2 + e2[8] * n2, this;
    }
    applyNormalMatrix(e2) {
      return this.applyMatrix3(e2).normalize();
    }
    applyMatrix4(e2) {
      var t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.elements, e2 = 1 / (i2[3] * t2 + i2[7] * r2 + i2[11] * n2 + i2[15]);
      return this.x = (i2[0] * t2 + i2[4] * r2 + i2[8] * n2 + i2[12]) * e2, this.y = (i2[1] * t2 + i2[5] * r2 + i2[9] * n2 + i2[13]) * e2, this.z = (i2[2] * t2 + i2[6] * r2 + i2[10] * n2 + i2[14]) * e2, this;
    }
    applyQuaternion(e2) {
      var t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.x, a2 = e2.y, o2 = e2.z, s2 = e2.w, l2 = s2 * t2 + a2 * n2 - o2 * r2, c2 = s2 * r2 + o2 * t2 - i2 * n2, e2 = s2 * n2 + i2 * r2 - a2 * t2, n2 = -i2 * t2 - a2 * r2 - o2 * n2;
      return this.x = l2 * s2 + n2 * -i2 + c2 * -o2 - e2 * -a2, this.y = c2 * s2 + n2 * -a2 + e2 * -i2 - l2 * -o2, this.z = e2 * s2 + n2 * -o2 + l2 * -a2 - c2 * -i2, this;
    }
    project(e2) {
      return this.applyMatrix4(e2.matrixWorldInverse).applyMatrix4(e2.projectionMatrix);
    }
    unproject(e2) {
      return this.applyMatrix4(e2.projectionMatrixInverse).applyMatrix4(e2.matrixWorld);
    }
    transformDirection(e2) {
      var t2 = this.x, r2 = this.y, n2 = this.z, e2 = e2.elements;
      return this.x = e2[0] * t2 + e2[4] * r2 + e2[8] * n2, this.y = e2[1] * t2 + e2[5] * r2 + e2[9] * n2, this.z = e2[2] * t2 + e2[6] * r2 + e2[10] * n2, this.normalize();
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this.z /= e2.z, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this;
    }
    clampLength(e2, t2) {
      var r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this.z = e2.z + (t2.z - e2.z) * r2, this;
    }
    cross(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e2, t2)) : this.crossVectors(this, e2);
    }
    crossVectors(e2, t2) {
      var r2 = e2.x, n2 = e2.y, i2 = e2.z, a2 = t2.x, e2 = t2.y, t2 = t2.z;
      return this.x = n2 * t2 - i2 * e2, this.y = i2 * a2 - r2 * t2, this.z = r2 * e2 - n2 * a2, this;
    }
    projectOnVector(e2) {
      var t2 = e2.lengthSq();
      if (t2 === 0)
        return this.set(0, 0, 0);
      t2 = e2.dot(this) / t2;
      return this.copy(e2).multiplyScalar(t2);
    }
    projectOnPlane(e2) {
      return _vector$c.copy(this).projectOnVector(e2), this.sub(_vector$c);
    }
    reflect(e2) {
      return this.sub(_vector$c.copy(e2).multiplyScalar(2 * this.dot(e2)));
    }
    angleTo(e2) {
      var t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
      if (t2 === 0)
        return Math.PI / 2;
      t2 = this.dot(e2) / t2;
      return Math.acos(clamp(t2, -1, 1));
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      var t2 = this.x - e2.x, r2 = this.y - e2.y, e2 = this.z - e2.z;
      return t2 * t2 + r2 * r2 + e2 * e2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y) + Math.abs(this.z - e2.z);
    }
    setFromSpherical(e2) {
      return this.setFromSphericalCoords(e2.radius, e2.phi, e2.theta);
    }
    setFromSphericalCoords(e2, t2, r2) {
      var n2 = Math.sin(t2) * e2;
      return this.x = n2 * Math.sin(r2), this.y = Math.cos(t2) * e2, this.z = n2 * Math.cos(r2), this;
    }
    setFromCylindrical(e2) {
      return this.setFromCylindricalCoords(e2.radius, e2.theta, e2.y);
    }
    setFromCylindricalCoords(e2, t2, r2) {
      return this.x = e2 * Math.sin(t2), this.y = r2, this.z = e2 * Math.cos(t2), this;
    }
    setFromMatrixPosition(e2) {
      e2 = e2.elements;
      return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
    }
    setFromMatrixScale(e2) {
      var t2 = this.setFromMatrixColumn(e2, 0).length(), r2 = this.setFromMatrixColumn(e2, 1).length(), e2 = this.setFromMatrixColumn(e2, 2).length();
      return this.x = t2, this.y = r2, this.z = e2, this;
    }
    setFromMatrixColumn(e2, t2) {
      return this.fromArray(e2.elements, 4 * t2);
    }
    setFromMatrix3Column(e2, t2) {
      return this.fromArray(e2.elements, 3 * t2);
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2;
    }
    fromBufferAttribute(e2, t2, r2) {
      return r2 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      var e2 = 2 * (Math.random() - 0.5), t2 = Math.random() * Math.PI * 2, r2 = Math.sqrt(1 - __pow(e2, 2));
      return this.x = r2 * Math.cos(t2), this.y = r2 * Math.sin(t2), this.z = e2, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  Vector3.prototype.isVector3 = true;
  const _vector$c = new Vector3(), _quaternion$4 = new Quaternion();
  class Box3 {
    constructor(e2 = new Vector3(1 / 0, 1 / 0, 1 / 0), t2 = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = e2, this.max = t2;
    }
    set(e2, t2) {
      return this.min.copy(e2), this.max.copy(t2), this;
    }
    setFromArray(r2) {
      let n2 = 1 / 0, i2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, l2 = -1 / 0;
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2 += 3) {
        var c2 = r2[e2], u2 = r2[e2 + 1], h2 = r2[e2 + 2];
        c2 < n2 && (n2 = c2), u2 < i2 && (i2 = u2), h2 < a2 && (a2 = h2), c2 > o2 && (o2 = c2), u2 > s2 && (s2 = u2), h2 > l2 && (l2 = h2);
      }
      return this.min.set(n2, i2, a2), this.max.set(o2, s2, l2), this;
    }
    setFromBufferAttribute(r2) {
      let n2 = 1 / 0, i2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, l2 = -1 / 0;
      for (let e2 = 0, t2 = r2.count; e2 < t2; e2++) {
        var c2 = r2.getX(e2), u2 = r2.getY(e2), h2 = r2.getZ(e2);
        c2 < n2 && (n2 = c2), u2 < i2 && (i2 = u2), h2 < a2 && (a2 = h2), c2 > o2 && (o2 = c2), u2 > s2 && (s2 = u2), h2 > l2 && (l2 = h2);
      }
      return this.min.set(n2, i2, a2), this.max.set(o2, s2, l2), this;
    }
    setFromPoints(r2) {
      this.makeEmpty();
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++)
        this.expandByPoint(r2[e2]);
      return this;
    }
    setFromCenterAndSize(e2, t2) {
      t2 = _vector$b.copy(t2).multiplyScalar(0.5);
      return this.min.copy(e2).sub(t2), this.max.copy(e2).add(t2), this;
    }
    setFromObject(e2) {
      return this.makeEmpty(), this.expandByObject(e2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.min.copy(e2.min), this.max.copy(e2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.subVectors(this.max, this.min);
    }
    expandByPoint(e2) {
      return this.min.min(e2), this.max.max(e2), this;
    }
    expandByVector(e2) {
      return this.min.sub(e2), this.max.add(e2), this;
    }
    expandByScalar(e2) {
      return this.min.addScalar(-e2), this.max.addScalar(e2), this;
    }
    expandByObject(e2) {
      e2.updateWorldMatrix(false, false);
      const t2 = e2.geometry;
      t2 !== void 0 && (t2.boundingBox === null && t2.computeBoundingBox(), _box$3.copy(t2.boundingBox), _box$3.applyMatrix4(e2.matrixWorld), this.union(_box$3));
      var r2 = e2.children;
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++)
        this.expandByObject(r2[e3]);
      return this;
    }
    containsPoint(e2) {
      return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y || e2.z < this.min.z || e2.z > this.max.z);
    }
    containsBox(e2) {
      return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y && this.min.z <= e2.min.z && e2.max.z <= this.max.z;
    }
    getParameter(e2, t2) {
      return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y), (e2.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e2) {
      return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y || e2.max.z < this.min.z || e2.min.z > this.max.z);
    }
    intersectsSphere(e2) {
      return this.clampPoint(e2.center, _vector$b), _vector$b.distanceToSquared(e2.center) <= e2.radius * e2.radius;
    }
    intersectsPlane(e2) {
      let t2, r2;
      return r2 = 0 < e2.normal.x ? (t2 = e2.normal.x * this.min.x, e2.normal.x * this.max.x) : (t2 = e2.normal.x * this.max.x, e2.normal.x * this.min.x), 0 < e2.normal.y ? (t2 += e2.normal.y * this.min.y, r2 += e2.normal.y * this.max.y) : (t2 += e2.normal.y * this.max.y, r2 += e2.normal.y * this.min.y), 0 < e2.normal.z ? (t2 += e2.normal.z * this.min.z, r2 += e2.normal.z * this.max.z) : (t2 += e2.normal.z * this.max.z, r2 += e2.normal.z * this.min.z), t2 <= -e2.constant && r2 >= -e2.constant;
    }
    intersectsTriangle(e2) {
      return !this.isEmpty() && (this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(e2.a, _center), _v1$7.subVectors(e2.b, _center), _v2$3.subVectors(e2.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$3, _v1$7), _f2.subVectors(_v0$2, _v2$3), !!satForAxes([0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0], _v0$2, _v1$7, _v2$3, _extents) && (!!satForAxes([1, 0, 0, 0, 1, 0, 0, 0, 1], _v0$2, _v1$7, _v2$3, _extents) && (_triangleNormal.crossVectors(_f0, _f1), satForAxes([_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], _v0$2, _v1$7, _v2$3, _extents))));
    }
    clampPoint(e2, t2) {
      return t2.copy(e2).clamp(this.min, this.max);
    }
    distanceToPoint(e2) {
      const t2 = _vector$b.copy(e2).clamp(this.min, this.max);
      return t2.sub(e2).length();
    }
    getBoundingSphere(e2) {
      return this.getCenter(e2.center), e2.radius = 0.5 * this.getSize(_vector$b).length(), e2;
    }
    intersect(e2) {
      return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e2) {
      return this.min.min(e2.min), this.max.max(e2.max), this;
    }
    applyMatrix4(e2) {
      return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e2), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e2), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e2), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e2), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e2), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e2), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e2), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e2), this.setFromPoints(_points)), this;
    }
    translate(e2) {
      return this.min.add(e2), this.max.add(e2), this;
    }
    equals(e2) {
      return e2.min.equals(this.min) && e2.max.equals(this.max);
    }
  }
  Box3.prototype.isBox3 = true;
  const _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()], _vector$b = new Vector3(), _box$3 = new Box3(), _v0$2 = new Vector3(), _v1$7 = new Vector3(), _v2$3 = new Vector3(), _f0 = new Vector3(), _f1 = new Vector3(), _f2 = new Vector3(), _center = new Vector3(), _extents = new Vector3(), _triangleNormal = new Vector3(), _testAxis = new Vector3();
  function satForAxes(r2, n2, i2, a2, o2) {
    for (let e2 = 0, t2 = r2.length - 3; e2 <= t2; e2 += 3) {
      _testAxis.fromArray(r2, e2);
      var s2 = o2.x * Math.abs(_testAxis.x) + o2.y * Math.abs(_testAxis.y) + o2.z * Math.abs(_testAxis.z), l2 = n2.dot(_testAxis), c2 = i2.dot(_testAxis), u2 = a2.dot(_testAxis);
      if (Math.max(-Math.max(l2, c2, u2), Math.min(l2, c2, u2)) > s2)
        return false;
    }
    return true;
  }
  const _box$2 = new Box3(), _v1$6 = new Vector3(), _toFarthestPoint = new Vector3(), _toPoint = new Vector3();
  class Sphere {
    constructor(e2 = new Vector3(), t2 = -1) {
      this.center = e2, this.radius = t2;
    }
    set(e2, t2) {
      return this.center.copy(e2), this.radius = t2, this;
    }
    setFromPoints(r2, e2) {
      const n2 = this.center;
      e2 !== void 0 ? n2.copy(e2) : _box$2.setFromPoints(r2).getCenter(n2);
      let i2 = 0;
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++)
        i2 = Math.max(i2, n2.distanceToSquared(r2[e3]));
      return this.radius = Math.sqrt(i2), this;
    }
    copy(e2) {
      return this.center.copy(e2.center), this.radius = e2.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e2) {
      return e2.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e2) {
      return e2.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e2) {
      var t2 = this.radius + e2.radius;
      return e2.center.distanceToSquared(this.center) <= t2 * t2;
    }
    intersectsBox(e2) {
      return e2.intersectsSphere(this);
    }
    intersectsPlane(e2) {
      return Math.abs(e2.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e2, t2) {
      var r2 = this.center.distanceToSquared(e2);
      return t2.copy(e2), r2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
    }
    getBoundingBox(e2) {
      return this.isEmpty() ? e2.makeEmpty() : (e2.set(this.center, this.center), e2.expandByScalar(this.radius)), e2;
    }
    applyMatrix4(e2) {
      return this.center.applyMatrix4(e2), this.radius = this.radius * e2.getMaxScaleOnAxis(), this;
    }
    translate(e2) {
      return this.center.add(e2), this;
    }
    expandByPoint(e2) {
      _toPoint.subVectors(e2, this.center);
      var t2 = _toPoint.lengthSq();
      return t2 > this.radius * this.radius && (t2 = 0.5 * ((e2 = Math.sqrt(t2)) - this.radius), this.center.add(_toPoint.multiplyScalar(t2 / e2)), this.radius += t2), this;
    }
    union(e2) {
      return _toFarthestPoint.subVectors(e2.center, this.center).normalize().multiplyScalar(e2.radius), this.expandByPoint(_v1$6.copy(e2.center).add(_toFarthestPoint)), this.expandByPoint(_v1$6.copy(e2.center).sub(_toFarthestPoint)), this;
    }
    equals(e2) {
      return e2.center.equals(this.center) && e2.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const _vector$a = new Vector3(), _segCenter = new Vector3(), _segDir = new Vector3(), _diff = new Vector3(), _edge1 = new Vector3(), _edge2 = new Vector3(), _normal$1 = new Vector3();
  class Ray {
    constructor(e2 = new Vector3(), t2 = new Vector3(0, 0, -1)) {
      this.origin = e2, this.direction = t2;
    }
    set(e2, t2) {
      return this.origin.copy(e2), this.direction.copy(t2), this;
    }
    copy(e2) {
      return this.origin.copy(e2.origin), this.direction.copy(e2.direction), this;
    }
    at(e2, t2) {
      return t2.copy(this.direction).multiplyScalar(e2).add(this.origin);
    }
    lookAt(e2) {
      return this.direction.copy(e2).sub(this.origin).normalize(), this;
    }
    recast(e2) {
      return this.origin.copy(this.at(e2, _vector$a)), this;
    }
    closestPointToPoint(e2, t2) {
      t2.subVectors(e2, this.origin);
      e2 = t2.dot(this.direction);
      return e2 < 0 ? t2.copy(this.origin) : t2.copy(this.direction).multiplyScalar(e2).add(this.origin);
    }
    distanceToPoint(e2) {
      return Math.sqrt(this.distanceSqToPoint(e2));
    }
    distanceSqToPoint(e2) {
      var t2 = _vector$a.subVectors(e2, this.origin).dot(this.direction);
      return t2 < 0 ? this.origin.distanceToSquared(e2) : (_vector$a.copy(this.direction).multiplyScalar(t2).add(this.origin), _vector$a.distanceToSquared(e2));
    }
    distanceSqToSegment(e2, t2, r2, n2) {
      _segCenter.copy(e2).add(t2).multiplyScalar(0.5), _segDir.copy(t2).sub(e2).normalize(), _diff.copy(this.origin).sub(_segCenter);
      var i2 = 0.5 * e2.distanceTo(t2), a2 = -this.direction.dot(_segDir), o2 = _diff.dot(this.direction), s2 = -_diff.dot(_segDir), e2 = _diff.lengthSq(), t2 = Math.abs(1 - a2 * a2);
      let l2, c2, u2, h2;
      return u2 = 0 < t2 ? (l2 = a2 * s2 - o2, c2 = a2 * o2 - s2, h2 = i2 * t2, 0 <= l2 ? c2 >= -h2 ? c2 <= h2 ? (t2 = 1 / t2, l2 *= t2, c2 *= t2, l2 * (l2 + a2 * c2 + 2 * o2) + c2 * (a2 * l2 + c2 + 2 * s2) + e2) : (c2 = i2, l2 = Math.max(0, -(a2 * c2 + o2)), -l2 * l2 + c2 * (c2 + 2 * s2) + e2) : (c2 = -i2, l2 = Math.max(0, -(a2 * c2 + o2)), -l2 * l2 + c2 * (c2 + 2 * s2) + e2) : c2 <= -h2 ? (l2 = Math.max(0, -(-a2 * i2 + o2)), c2 = 0 < l2 ? -i2 : Math.min(Math.max(-i2, -s2), i2), -l2 * l2 + c2 * (c2 + 2 * s2) + e2) : c2 <= h2 ? (l2 = 0, c2 = Math.min(Math.max(-i2, -s2), i2), c2 * (c2 + 2 * s2) + e2) : (l2 = Math.max(0, -(a2 * i2 + o2)), c2 = 0 < l2 ? i2 : Math.min(Math.max(-i2, -s2), i2), -l2 * l2 + c2 * (c2 + 2 * s2) + e2)) : (c2 = 0 < a2 ? -i2 : i2, l2 = Math.max(0, -(a2 * c2 + o2)), -l2 * l2 + c2 * (c2 + 2 * s2) + e2), r2 && r2.copy(this.direction).multiplyScalar(l2).add(this.origin), n2 && n2.copy(_segDir).multiplyScalar(c2).add(_segCenter), u2;
    }
    intersectSphere(e2, t2) {
      _vector$a.subVectors(e2.center, this.origin);
      var r2 = _vector$a.dot(this.direction), n2 = _vector$a.dot(_vector$a) - r2 * r2, e2 = e2.radius * e2.radius;
      if (e2 < n2)
        return null;
      e2 = Math.sqrt(e2 - n2), n2 = r2 - e2, e2 = r2 + e2;
      return n2 < 0 && e2 < 0 ? null : n2 < 0 ? this.at(e2, t2) : this.at(n2, t2);
    }
    intersectsSphere(e2) {
      return this.distanceSqToPoint(e2.center) <= e2.radius * e2.radius;
    }
    distanceToPlane(e2) {
      var t2 = e2.normal.dot(this.direction);
      if (t2 === 0)
        return e2.distanceToPoint(this.origin) === 0 ? 0 : null;
      t2 = -(this.origin.dot(e2.normal) + e2.constant) / t2;
      return 0 <= t2 ? t2 : null;
    }
    intersectPlane(e2, t2) {
      e2 = this.distanceToPlane(e2);
      return e2 === null ? null : this.at(e2, t2);
    }
    intersectsPlane(e2) {
      var t2 = e2.distanceToPoint(this.origin);
      return t2 === 0 || e2.normal.dot(this.direction) * t2 < 0;
    }
    intersectBox(e2, t2) {
      let r2, n2, i2, a2, o2, s2;
      var l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, u2 = 1 / this.direction.z, h2 = this.origin;
      return n2 = 0 <= l2 ? (r2 = (e2.min.x - h2.x) * l2, (e2.max.x - h2.x) * l2) : (r2 = (e2.max.x - h2.x) * l2, (e2.min.x - h2.x) * l2), a2 = 0 <= c2 ? (i2 = (e2.min.y - h2.y) * c2, (e2.max.y - h2.y) * c2) : (i2 = (e2.max.y - h2.y) * c2, (e2.min.y - h2.y) * c2), r2 > a2 || i2 > n2 ? null : ((i2 > r2 || r2 != r2) && (r2 = i2), (a2 < n2 || n2 != n2) && (n2 = a2), s2 = 0 <= u2 ? (o2 = (e2.min.z - h2.z) * u2, (e2.max.z - h2.z) * u2) : (o2 = (e2.max.z - h2.z) * u2, (e2.min.z - h2.z) * u2), r2 > s2 || o2 > n2 ? null : ((o2 > r2 || r2 != r2) && (r2 = o2), (s2 < n2 || n2 != n2) && (n2 = s2), n2 < 0 ? null : this.at(0 <= r2 ? r2 : n2, t2)));
    }
    intersectsBox(e2) {
      return this.intersectBox(e2, _vector$a) !== null;
    }
    intersectTriangle(e2, t2, r2, n2, i2) {
      _edge1.subVectors(t2, e2), _edge2.subVectors(r2, e2), _normal$1.crossVectors(_edge1, _edge2);
      let a2 = this.direction.dot(_normal$1), o2;
      if (0 < a2) {
        if (n2)
          return null;
        o2 = 1;
      } else {
        if (!(a2 < 0))
          return null;
        o2 = -1, a2 = -a2;
      }
      _diff.subVectors(this.origin, e2);
      n2 = o2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (n2 < 0)
        return null;
      e2 = o2 * this.direction.dot(_edge1.cross(_diff));
      if (e2 < 0)
        return null;
      if (n2 + e2 > a2)
        return null;
      e2 = -o2 * _diff.dot(_normal$1);
      return e2 < 0 ? null : this.at(e2 / a2, i2);
    }
    applyMatrix4(e2) {
      return this.origin.applyMatrix4(e2), this.direction.transformDirection(e2), this;
    }
    equals(e2) {
      return e2.origin.equals(this.origin) && e2.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Matrix4 {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(e2, t2, r2, n2, i2, a2, o2, s2, l2, c2, u2, h2, d2, p2, f2, m2) {
      const g2 = this.elements;
      return g2[0] = e2, g2[4] = t2, g2[8] = r2, g2[12] = n2, g2[1] = i2, g2[5] = a2, g2[9] = o2, g2[13] = s2, g2[2] = l2, g2[6] = c2, g2[10] = u2, g2[14] = h2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(e2) {
      const t2 = this.elements;
      e2 = e2.elements;
      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], this;
    }
    copyPosition(e2) {
      const t2 = this.elements, r2 = e2.elements;
      return t2[12] = r2[12], t2[13] = r2[13], t2[14] = r2[14], this;
    }
    setFromMatrix3(e2) {
      e2 = e2.elements;
      return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e2, t2, r2) {
      return e2.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), r2.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e2, t2, r2) {
      return this.set(e2.x, t2.x, r2.x, 0, e2.y, t2.y, r2.y, 0, e2.z, t2.z, r2.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e2) {
      const t2 = this.elements;
      var r2 = e2.elements, n2 = 1 / _v1$5.setFromMatrixColumn(e2, 0).length(), i2 = 1 / _v1$5.setFromMatrixColumn(e2, 1).length(), e2 = 1 / _v1$5.setFromMatrixColumn(e2, 2).length();
      return t2[0] = r2[0] * n2, t2[1] = r2[1] * n2, t2[2] = r2[2] * n2, t2[3] = 0, t2[4] = r2[4] * i2, t2[5] = r2[5] * i2, t2[6] = r2[6] * i2, t2[7] = 0, t2[8] = r2[8] * e2, t2[9] = r2[9] * e2, t2[10] = r2[10] * e2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromEuler(e2) {
      e2 && e2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const t2 = this.elements;
      var r2, n2, i2, a2, o2, s2, l2, c2, u2, h2, d2, p2 = e2.x, f2 = e2.y, m2 = e2.z, g2 = Math.cos(p2), v2 = Math.sin(p2), y = Math.cos(f2), _2 = Math.sin(f2), p2 = Math.cos(m2), f2 = Math.sin(m2);
      return e2.order === "XYZ" ? (r2 = g2 * p2, i2 = g2 * f2, n2 = v2 * p2, m2 = v2 * f2, t2[0] = y * p2, t2[4] = -y * f2, t2[8] = _2, t2[1] = i2 + n2 * _2, t2[5] = r2 - m2 * _2, t2[9] = -v2 * y, t2[2] = m2 - r2 * _2, t2[6] = n2 + i2 * _2, t2[10] = g2 * y) : e2.order === "YXZ" ? (a2 = y * p2, r2 = y * f2, n2 = _2 * p2, i2 = _2 * f2, t2[0] = a2 + i2 * v2, t2[4] = n2 * v2 - r2, t2[8] = g2 * _2, t2[1] = g2 * f2, t2[5] = g2 * p2, t2[9] = -v2, t2[2] = r2 * v2 - n2, t2[6] = i2 + a2 * v2, t2[10] = g2 * y) : e2.order === "ZXY" ? (l2 = y * p2, a2 = y * f2, o2 = _2 * p2, s2 = _2 * f2, t2[0] = l2 - s2 * v2, t2[4] = -g2 * f2, t2[8] = o2 + a2 * v2, t2[1] = a2 + o2 * v2, t2[5] = g2 * p2, t2[9] = s2 - l2 * v2, t2[2] = -g2 * _2, t2[6] = v2, t2[10] = g2 * y) : e2.order === "ZYX" ? (o2 = g2 * p2, s2 = g2 * f2, c2 = v2 * p2, l2 = v2 * f2, t2[0] = y * p2, t2[4] = c2 * _2 - s2, t2[8] = o2 * _2 + l2, t2[1] = y * f2, t2[5] = l2 * _2 + o2, t2[9] = s2 * _2 - c2, t2[2] = -_2, t2[6] = v2 * y, t2[10] = g2 * y) : e2.order === "YZX" ? (h2 = g2 * y, c2 = g2 * _2, u2 = v2 * y, d2 = v2 * _2, t2[0] = y * p2, t2[4] = d2 - h2 * f2, t2[8] = u2 * f2 + c2, t2[1] = f2, t2[5] = g2 * p2, t2[9] = -v2 * p2, t2[2] = -_2 * p2, t2[6] = c2 * f2 + u2, t2[10] = h2 - d2 * f2) : e2.order === "XZY" && (u2 = g2 * y, h2 = g2 * _2, d2 = v2 * y, e2 = v2 * _2, t2[0] = y * p2, t2[4] = -f2, t2[8] = _2 * p2, t2[1] = u2 * f2 + e2, t2[5] = g2 * p2, t2[9] = h2 * f2 - d2, t2[2] = d2 * f2 - h2, t2[6] = v2 * p2, t2[10] = e2 * f2 + u2), t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromQuaternion(e2) {
      return this.compose(_zero, e2, _one);
    }
    lookAt(e2, t2, r2) {
      const n2 = this.elements;
      return _z.subVectors(e2, t2), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(r2, _z), _x.lengthSq() === 0 && (Math.abs(r2.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(r2, _z)), _x.normalize(), _y.crossVectors(_z, _x), n2[0] = _x.x, n2[4] = _y.x, n2[8] = _z.x, n2[1] = _x.y, n2[5] = _y.y, n2[9] = _z.y, n2[2] = _x.z, n2[6] = _y.z, n2[10] = _z.z, this;
    }
    multiply(e2, t2) {
      return t2 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e2, t2)) : this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      var r2 = e2.elements, n2 = t2.elements;
      const i2 = this.elements;
      var a2 = r2[0], o2 = r2[4], s2 = r2[8], l2 = r2[12], c2 = r2[1], u2 = r2[5], h2 = r2[9], d2 = r2[13], p2 = r2[2], f2 = r2[6], m2 = r2[10], g2 = r2[14], v2 = r2[3], y = r2[7], _2 = r2[11], b2 = r2[15], x2 = n2[0], w2 = n2[4], S2 = n2[8], M2 = n2[12], E2 = n2[1], T2 = n2[5], k2 = n2[9], A2 = n2[13], C2 = n2[2], $2 = n2[6], R2 = n2[10], L = n2[14], e2 = n2[3], t2 = n2[7], r2 = n2[11], n2 = n2[15];
      return i2[0] = a2 * x2 + o2 * E2 + s2 * C2 + l2 * e2, i2[4] = a2 * w2 + o2 * T2 + s2 * $2 + l2 * t2, i2[8] = a2 * S2 + o2 * k2 + s2 * R2 + l2 * r2, i2[12] = a2 * M2 + o2 * A2 + s2 * L + l2 * n2, i2[1] = c2 * x2 + u2 * E2 + h2 * C2 + d2 * e2, i2[5] = c2 * w2 + u2 * T2 + h2 * $2 + d2 * t2, i2[9] = c2 * S2 + u2 * k2 + h2 * R2 + d2 * r2, i2[13] = c2 * M2 + u2 * A2 + h2 * L + d2 * n2, i2[2] = p2 * x2 + f2 * E2 + m2 * C2 + g2 * e2, i2[6] = p2 * w2 + f2 * T2 + m2 * $2 + g2 * t2, i2[10] = p2 * S2 + f2 * k2 + m2 * R2 + g2 * r2, i2[14] = p2 * M2 + f2 * A2 + m2 * L + g2 * n2, i2[3] = v2 * x2 + y * E2 + _2 * C2 + b2 * e2, i2[7] = v2 * w2 + y * T2 + _2 * $2 + b2 * t2, i2[11] = v2 * S2 + y * k2 + _2 * R2 + b2 * r2, i2[15] = v2 * M2 + y * A2 + _2 * L + b2 * n2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[4] *= e2, t2[8] *= e2, t2[12] *= e2, t2[1] *= e2, t2[5] *= e2, t2[9] *= e2, t2[13] *= e2, t2[2] *= e2, t2[6] *= e2, t2[10] *= e2, t2[14] *= e2, t2[3] *= e2, t2[7] *= e2, t2[11] *= e2, t2[15] *= e2, this;
    }
    determinant() {
      var e2 = this.elements, t2 = e2[0], r2 = e2[4], n2 = e2[8], i2 = e2[12], a2 = e2[1], o2 = e2[5], s2 = e2[9], l2 = e2[13], c2 = e2[2], u2 = e2[6], h2 = e2[10], d2 = e2[14];
      return e2[3] * (+i2 * s2 * u2 - n2 * l2 * u2 - i2 * o2 * h2 + r2 * l2 * h2 + n2 * o2 * d2 - r2 * s2 * d2) + e2[7] * (+t2 * s2 * d2 - t2 * l2 * h2 + i2 * a2 * h2 - n2 * a2 * d2 + n2 * l2 * c2 - i2 * s2 * c2) + e2[11] * (+t2 * l2 * u2 - t2 * o2 * d2 - i2 * a2 * u2 + r2 * a2 * d2 + i2 * o2 * c2 - r2 * l2 * c2) + e2[15] * (-n2 * o2 * c2 - t2 * s2 * u2 + t2 * o2 * h2 + n2 * a2 * u2 - r2 * a2 * h2 + r2 * s2 * c2);
    }
    transpose() {
      const e2 = this.elements;
      var t2 = e2[1];
      return e2[1] = e2[4], e2[4] = t2, t2 = e2[2], e2[2] = e2[8], e2[8] = t2, t2 = e2[6], e2[6] = e2[9], e2[9] = t2, t2 = e2[3], e2[3] = e2[12], e2[12] = t2, t2 = e2[7], e2[7] = e2[13], e2[13] = t2, t2 = e2[11], e2[11] = e2[14], e2[14] = t2, this;
    }
    setPosition(e2, t2, r2) {
      const n2 = this.elements;
      return e2.isVector3 ? (n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z) : (n2[12] = e2, n2[13] = t2, n2[14] = r2), this;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = e2[9], h2 = e2[10], d2 = e2[11], p2 = e2[12], f2 = e2[13], m2 = e2[14], g2 = e2[15], v2 = u2 * m2 * l2 - f2 * h2 * l2 + f2 * s2 * d2 - o2 * m2 * d2 - u2 * s2 * g2 + o2 * h2 * g2, y = p2 * h2 * l2 - c2 * m2 * l2 - p2 * s2 * d2 + a2 * m2 * d2 + c2 * s2 * g2 - a2 * h2 * g2, _2 = c2 * f2 * l2 - p2 * u2 * l2 + p2 * o2 * d2 - a2 * f2 * d2 - c2 * o2 * g2 + a2 * u2 * g2, b2 = p2 * u2 * s2 - c2 * f2 * s2 - p2 * o2 * h2 + a2 * f2 * h2 + c2 * o2 * m2 - a2 * u2 * m2;
      var x2 = t2 * v2 + r2 * y + n2 * _2 + i2 * b2;
      if (x2 == 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      x2 = 1 / x2;
      return e2[0] = v2 * x2, e2[1] = (f2 * h2 * i2 - u2 * m2 * i2 - f2 * n2 * d2 + r2 * m2 * d2 + u2 * n2 * g2 - r2 * h2 * g2) * x2, e2[2] = (o2 * m2 * i2 - f2 * s2 * i2 + f2 * n2 * l2 - r2 * m2 * l2 - o2 * n2 * g2 + r2 * s2 * g2) * x2, e2[3] = (u2 * s2 * i2 - o2 * h2 * i2 - u2 * n2 * l2 + r2 * h2 * l2 + o2 * n2 * d2 - r2 * s2 * d2) * x2, e2[4] = y * x2, e2[5] = (c2 * m2 * i2 - p2 * h2 * i2 + p2 * n2 * d2 - t2 * m2 * d2 - c2 * n2 * g2 + t2 * h2 * g2) * x2, e2[6] = (p2 * s2 * i2 - a2 * m2 * i2 - p2 * n2 * l2 + t2 * m2 * l2 + a2 * n2 * g2 - t2 * s2 * g2) * x2, e2[7] = (a2 * h2 * i2 - c2 * s2 * i2 + c2 * n2 * l2 - t2 * h2 * l2 - a2 * n2 * d2 + t2 * s2 * d2) * x2, e2[8] = _2 * x2, e2[9] = (p2 * u2 * i2 - c2 * f2 * i2 - p2 * r2 * d2 + t2 * f2 * d2 + c2 * r2 * g2 - t2 * u2 * g2) * x2, e2[10] = (a2 * f2 * i2 - p2 * o2 * i2 + p2 * r2 * l2 - t2 * f2 * l2 - a2 * r2 * g2 + t2 * o2 * g2) * x2, e2[11] = (c2 * o2 * i2 - a2 * u2 * i2 - c2 * r2 * l2 + t2 * u2 * l2 + a2 * r2 * d2 - t2 * o2 * d2) * x2, e2[12] = b2 * x2, e2[13] = (c2 * f2 * n2 - p2 * u2 * n2 + p2 * r2 * h2 - t2 * f2 * h2 - c2 * r2 * m2 + t2 * u2 * m2) * x2, e2[14] = (p2 * o2 * n2 - a2 * f2 * n2 - p2 * r2 * s2 + t2 * f2 * s2 + a2 * r2 * m2 - t2 * o2 * m2) * x2, e2[15] = (a2 * u2 * n2 - c2 * o2 * n2 + c2 * r2 * s2 - t2 * u2 * s2 - a2 * r2 * h2 + t2 * o2 * h2) * x2, this;
    }
    scale(e2) {
      const t2 = this.elements;
      var r2 = e2.x, n2 = e2.y, e2 = e2.z;
      return t2[0] *= r2, t2[4] *= n2, t2[8] *= e2, t2[1] *= r2, t2[5] *= n2, t2[9] *= e2, t2[2] *= r2, t2[6] *= n2, t2[10] *= e2, t2[3] *= r2, t2[7] *= n2, t2[11] *= e2, this;
    }
    getMaxScaleOnAxis() {
      var e2 = this.elements, t2 = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2], r2 = e2[4] * e2[4] + e2[5] * e2[5] + e2[6] * e2[6], e2 = e2[8] * e2[8] + e2[9] * e2[9] + e2[10] * e2[10];
      return Math.sqrt(Math.max(t2, r2, e2));
    }
    makeTranslation(e2, t2, r2) {
      return this.set(1, 0, 0, e2, 0, 1, 0, t2, 0, 0, 1, r2, 0, 0, 0, 1), this;
    }
    makeRotationX(e2) {
      var t2 = Math.cos(e2), e2 = Math.sin(e2);
      return this.set(1, 0, 0, 0, 0, t2, -e2, 0, 0, e2, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e2) {
      var t2 = Math.cos(e2), e2 = Math.sin(e2);
      return this.set(t2, 0, e2, 0, 0, 1, 0, 0, -e2, 0, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e2) {
      var t2 = Math.cos(e2), e2 = Math.sin(e2);
      return this.set(t2, -e2, 0, 0, e2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e2, t2) {
      var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = 1 - r2, a2 = e2.x, o2 = e2.y, s2 = e2.z, t2 = i2 * a2, e2 = i2 * o2;
      return this.set(t2 * a2 + r2, t2 * o2 - n2 * s2, t2 * s2 + n2 * o2, 0, t2 * o2 + n2 * s2, e2 * o2 + r2, e2 * s2 - n2 * a2, 0, t2 * s2 - n2 * o2, e2 * s2 + n2 * a2, i2 * s2 * s2 + r2, 0, 0, 0, 0, 1), this;
    }
    makeScale(e2, t2, r2) {
      return this.set(e2, 0, 0, 0, 0, t2, 0, 0, 0, 0, r2, 0, 0, 0, 0, 1), this;
    }
    makeShear(e2, t2, r2, n2, i2, a2) {
      return this.set(1, r2, i2, 0, e2, 1, a2, 0, t2, n2, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e2, t2, r2) {
      const n2 = this.elements;
      var i2 = t2._x, a2 = t2._y, o2 = t2._z, s2 = t2._w, l2 = i2 + i2, c2 = a2 + a2, u2 = o2 + o2, h2 = i2 * l2, d2 = i2 * c2, p2 = i2 * u2, t2 = a2 * c2, i2 = a2 * u2, a2 = o2 * u2, o2 = s2 * l2, l2 = s2 * c2, c2 = s2 * u2, s2 = r2.x, u2 = r2.y, r2 = r2.z;
      return n2[0] = (1 - (t2 + a2)) * s2, n2[1] = (d2 + c2) * s2, n2[2] = (p2 - l2) * s2, n2[3] = 0, n2[4] = (d2 - c2) * u2, n2[5] = (1 - (h2 + a2)) * u2, n2[6] = (i2 + o2) * u2, n2[7] = 0, n2[8] = (p2 + l2) * r2, n2[9] = (i2 - o2) * r2, n2[10] = (1 - (h2 + t2)) * r2, n2[11] = 0, n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z, n2[15] = 1, this;
    }
    decompose(e2, t2, r2) {
      var n2 = this.elements;
      let i2 = _v1$5.set(n2[0], n2[1], n2[2]).length();
      var a2 = _v1$5.set(n2[4], n2[5], n2[6]).length(), o2 = _v1$5.set(n2[8], n2[9], n2[10]).length();
      this.determinant() < 0 && (i2 = -i2), e2.x = n2[12], e2.y = n2[13], e2.z = n2[14], _m1$2.copy(this);
      var s2 = 1 / i2, e2 = 1 / a2, n2 = 1 / o2;
      return _m1$2.elements[0] *= s2, _m1$2.elements[1] *= s2, _m1$2.elements[2] *= s2, _m1$2.elements[4] *= e2, _m1$2.elements[5] *= e2, _m1$2.elements[6] *= e2, _m1$2.elements[8] *= n2, _m1$2.elements[9] *= n2, _m1$2.elements[10] *= n2, t2.setFromRotationMatrix(_m1$2), r2.x = i2, r2.y = a2, r2.z = o2, this;
    }
    makePerspective(e2, t2, r2, n2, i2, a2) {
      a2 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const o2 = this.elements;
      var s2 = 2 * i2 / (r2 - n2), l2 = (t2 + e2) / (t2 - e2), r2 = (r2 + n2) / (r2 - n2), n2 = -(a2 + i2) / (a2 - i2), a2 = -2 * a2 * i2 / (a2 - i2);
      return o2[0] = 2 * i2 / (t2 - e2), o2[4] = 0, o2[8] = l2, o2[12] = 0, o2[1] = 0, o2[5] = s2, o2[9] = r2, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = n2, o2[14] = a2, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
    }
    makeOrthographic(e2, t2, r2, n2, i2, a2) {
      const o2 = this.elements;
      var s2 = 1 / (t2 - e2), l2 = 1 / (r2 - n2), c2 = 1 / (a2 - i2), e2 = (t2 + e2) * s2, n2 = (r2 + n2) * l2, i2 = (a2 + i2) * c2;
      return o2[0] = 2 * s2, o2[4] = 0, o2[8] = 0, o2[12] = -e2, o2[1] = 0, o2[5] = 2 * l2, o2[9] = 0, o2[13] = -n2, o2[2] = 0, o2[6] = 0, o2[10] = -2 * c2, o2[14] = -i2, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
    }
    equals(e2) {
      var t2 = this.elements, r2 = e2.elements;
      for (let e3 = 0; e3 < 16; e3++)
        if (t2[e3] !== r2[e3])
          return false;
      return true;
    }
    fromArray(t2, r2 = 0) {
      for (let e2 = 0; e2 < 16; e2++)
        this.elements[e2] = t2[e2 + r2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      var r2 = this.elements;
      return e2[t2] = r2[0], e2[t2 + 1] = r2[1], e2[t2 + 2] = r2[2], e2[t2 + 3] = r2[3], e2[t2 + 4] = r2[4], e2[t2 + 5] = r2[5], e2[t2 + 6] = r2[6], e2[t2 + 7] = r2[7], e2[t2 + 8] = r2[8], e2[t2 + 9] = r2[9], e2[t2 + 10] = r2[10], e2[t2 + 11] = r2[11], e2[t2 + 12] = r2[12], e2[t2 + 13] = r2[13], e2[t2 + 14] = r2[14], e2[t2 + 15] = r2[15], e2;
    }
  }
  Matrix4.prototype.isMatrix4 = true;
  const _v1$5 = new Vector3(), _m1$2 = new Matrix4(), _zero = new Vector3(0, 0, 0), _one = new Vector3(1, 1, 1), _x = new Vector3(), _y = new Vector3(), _z = new Vector3(), _matrix$1 = new Matrix4(), _quaternion$3 = new Quaternion();
  class Euler {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = Euler.DefaultOrder) {
      this._x = e2, this._y = t2, this._z = r2, this._order = n2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e2) {
      this._order = e2, this._onChangeCallback();
    }
    set(e2, t2, r2, n2 = this._order) {
      return this._x = e2, this._y = t2, this._z = r2, this._order = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e2) {
      return this._x = e2._x, this._y = e2._y, this._z = e2._z, this._order = e2._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2, t2 = this._order, r2 = true) {
      var e2 = e2.elements, n2 = e2[0], i2 = e2[4], a2 = e2[8], o2 = e2[1], s2 = e2[5], l2 = e2[9], c2 = e2[2], u2 = e2[6], h2 = e2[10];
      switch (t2) {
        case "XYZ":
          this._y = Math.asin(clamp(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-l2, h2), this._z = Math.atan2(-i2, n2)) : (this._x = Math.atan2(u2, s2), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(l2, -1, 1)), Math.abs(l2) < 0.9999999 ? (this._y = Math.atan2(a2, h2), this._z = Math.atan2(o2, s2)) : (this._y = Math.atan2(-c2, n2), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(clamp(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-c2, h2), this._z = Math.atan2(-i2, s2)) : (this._y = 0, this._z = Math.atan2(o2, n2));
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._x = Math.atan2(u2, h2), this._z = Math.atan2(o2, n2)) : (this._x = 0, this._z = Math.atan2(-i2, s2));
          break;
        case "YZX":
          this._z = Math.asin(clamp(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-l2, s2), this._y = Math.atan2(-c2, n2)) : (this._x = 0, this._y = Math.atan2(a2, h2));
          break;
        case "XZY":
          this._z = Math.asin(-clamp(i2, -1, 1)), Math.abs(i2) < 0.9999999 ? (this._x = Math.atan2(u2, s2), this._y = Math.atan2(a2, n2)) : (this._x = Math.atan2(-l2, h2), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
      }
      return this._order = t2, r2 === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(e2, t2, r2) {
      return _matrix$1.makeRotationFromQuaternion(e2), this.setFromRotationMatrix(_matrix$1, t2, r2);
    }
    setFromVector3(e2, t2 = this._order) {
      return this.set(e2.x, e2.y, e2.z, t2);
    }
    reorder(e2) {
      return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e2);
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._order === this._order;
    }
    fromArray(e2) {
      return this._x = e2[0], this._y = e2[1], this._z = e2[2], e2[3] !== void 0 && (this._order = e2[3]), this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._order, e2;
    }
    toVector3(e2) {
      return e2 ? e2.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
  }
  Euler.prototype.isEuler = true, Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class Layers {
    constructor() {
      this.mask = 1;
    }
    set(e2) {
      this.mask = 1 << e2 | 0;
    }
    enable(e2) {
      this.mask |= 1 << e2 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e2) {
      this.mask ^= 1 << e2 | 0;
    }
    disable(e2) {
      this.mask &= ~(1 << e2 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e2) {
      return (this.mask & e2.mask) != 0;
    }
  }
  let _object3DId = 0;
  const _v1$4 = new Vector3(), _q1 = new Quaternion(), _m1$1 = new Matrix4(), _target = new Vector3(), _position$3 = new Vector3(), _scale$2 = new Vector3(), _quaternion$2 = new Quaternion(), _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" };
  class Object3D extends EventDispatcher {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
      var e2 = new Vector3();
      const t2 = new Euler(), r2 = new Quaternion();
      var n2 = new Vector3(1, 1, 1);
      t2._onChange(function() {
        r2.setFromEuler(t2, false);
      }), r2._onChange(function() {
        t2.setFromQuaternion(r2, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e2 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: r2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new Matrix4() }, normalMatrix: { value: new Matrix3() } }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Layers(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(e2) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e2), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e2) {
      return this.quaternion.premultiply(e2), this;
    }
    setRotationFromAxisAngle(e2, t2) {
      this.quaternion.setFromAxisAngle(e2, t2);
    }
    setRotationFromEuler(e2) {
      this.quaternion.setFromEuler(e2, true);
    }
    setRotationFromMatrix(e2) {
      this.quaternion.setFromRotationMatrix(e2);
    }
    setRotationFromQuaternion(e2) {
      this.quaternion.copy(e2);
    }
    rotateOnAxis(e2, t2) {
      return _q1.setFromAxisAngle(e2, t2), this.quaternion.multiply(_q1), this;
    }
    rotateOnWorldAxis(e2, t2) {
      return _q1.setFromAxisAngle(e2, t2), this.quaternion.premultiply(_q1), this;
    }
    rotateX(e2) {
      return this.rotateOnAxis(_xAxis, e2);
    }
    rotateY(e2) {
      return this.rotateOnAxis(_yAxis, e2);
    }
    rotateZ(e2) {
      return this.rotateOnAxis(_zAxis, e2);
    }
    translateOnAxis(e2, t2) {
      return _v1$4.copy(e2).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(t2)), this;
    }
    translateX(e2) {
      return this.translateOnAxis(_xAxis, e2);
    }
    translateY(e2) {
      return this.translateOnAxis(_yAxis, e2);
    }
    translateZ(e2) {
      return this.translateOnAxis(_zAxis, e2);
    }
    localToWorld(e2) {
      return e2.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e2) {
      return e2.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(e2, t2, r2) {
      e2.isVector3 ? _target.copy(e2) : _target.set(e2, t2, r2);
      r2 = this.parent;
      this.updateWorldMatrix(true, false), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), r2 && (_m1$1.extractRotation(r2.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()));
    }
    add(e2) {
      if (1 < arguments.length) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.add(arguments[e3]);
        return this;
      }
      return e2 === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e2) : e2 && e2.isObject3D ? (e2.parent !== null && e2.parent.remove(e2), (e2.parent = this).children.push(e2), e2.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e2), this;
    }
    remove(e2) {
      if (1 < arguments.length) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.remove(arguments[e3]);
        return this;
      }
      var t2 = this.children.indexOf(e2);
      return t2 !== -1 && (e2.parent = null, this.children.splice(t2, 1), e2.dispatchEvent(_removedEvent)), this;
    }
    removeFromParent() {
      const e2 = this.parent;
      return e2 !== null && e2.remove(this), this;
    }
    clear() {
      for (let e2 = 0; e2 < this.children.length; e2++) {
        const t2 = this.children[e2];
        t2.parent = null, t2.dispatchEvent(_removedEvent);
      }
      return this.children.length = 0, this;
    }
    attach(e2) {
      return this.updateWorldMatrix(true, false), _m1$1.copy(this.matrixWorld).invert(), e2.parent !== null && (e2.parent.updateWorldMatrix(true, false), _m1$1.multiply(e2.parent.matrixWorld)), e2.applyMatrix4(_m1$1), this.add(e2), e2.updateWorldMatrix(false, true), this;
    }
    getObjectById(e2) {
      return this.getObjectByProperty("id", e2);
    }
    getObjectByName(e2) {
      return this.getObjectByProperty("name", e2);
    }
    getObjectByProperty(r2, n2) {
      if (this[r2] === n2)
        return this;
      for (let e2 = 0, t2 = this.children.length; e2 < t2; e2++) {
        const a2 = this.children[e2];
        var i2 = a2.getObjectByProperty(r2, n2);
        if (i2 !== void 0)
          return i2;
      }
    }
    getWorldPosition(e2) {
      return this.updateWorldMatrix(true, false), e2.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_position$3, e2, _scale$2), e2;
    }
    getWorldScale(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_position$3, _quaternion$2, e2), e2;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      var t2 = this.matrixWorld.elements;
      return e2.set(t2[8], t2[9], t2[10]).normalize();
    }
    raycast() {
    }
    traverse(r2) {
      r2(this);
      const n2 = this.children;
      for (let e2 = 0, t2 = n2.length; e2 < t2; e2++)
        n2[e2].traverse(r2);
    }
    traverseVisible(r2) {
      if (this.visible !== false) {
        r2(this);
        const n2 = this.children;
        for (let e2 = 0, t2 = n2.length; e2 < t2; e2++)
          n2[e2].traverseVisible(r2);
      }
    }
    traverseAncestors(e2) {
      const t2 = this.parent;
      t2 !== null && (e2(t2), t2.traverseAncestors(e2));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(r2) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || r2) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), r2 = !(this.matrixWorldNeedsUpdate = false));
      const n2 = this.children;
      for (let e2 = 0, t2 = n2.length; e2 < t2; e2++)
        n2[e2].updateMatrixWorld(r2);
    }
    updateWorldMatrix(e2, t2) {
      const r2 = this.parent;
      if (e2 === true && r2 !== null && r2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t2 === true) {
        const n2 = this.children;
        for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
          n2[e3].updateWorldMatrix(false, true);
      }
    }
    toJSON(r2) {
      var e2, t2, n2, i2, a2, o2 = r2 === void 0 || typeof r2 == "string";
      const s2 = {};
      o2 && (r2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, s2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      const l2 = {};
      function c2(e3, t3) {
        return e3[t3.uuid] === void 0 && (e3[t3.uuid] = t3.toJSON(r2)), t3.uuid;
      }
      if (l2.uuid = this.uuid, l2.type = this.type, this.name !== "" && (l2.name = this.name), this.castShadow === true && (l2.castShadow = true), this.receiveShadow === true && (l2.receiveShadow = true), this.visible === false && (l2.visible = false), this.frustumCulled === false && (l2.frustumCulled = false), this.renderOrder !== 0 && (l2.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (l2.userData = this.userData), l2.layers = this.layers.mask, l2.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (l2.matrixAutoUpdate = false), this.isInstancedMesh && (l2.type = "InstancedMesh", l2.count = this.count, l2.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (l2.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? l2.background = this.background.toJSON() : this.background.isTexture && (l2.background = this.background.toJSON(r2).uuid)), this.environment && this.environment.isTexture && (l2.environment = this.environment.toJSON(r2).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        l2.geometry = c2(r2.geometries, this.geometry);
        var u2 = this.geometry.parameters;
        if (u2 !== void 0 && u2.shapes !== void 0) {
          var h2 = u2.shapes;
          if (Array.isArray(h2))
            for (let e3 = 0, t3 = h2.length; e3 < t3; e3++) {
              var d2 = h2[e3];
              c2(r2.shapes, d2);
            }
          else
            c2(r2.shapes, h2);
        }
      }
      if (this.isSkinnedMesh && (l2.bindMode = this.bindMode, l2.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (c2(r2.skeletons, this.skeleton), l2.skeleton = this.skeleton.uuid)), this.material !== void 0)
        if (Array.isArray(this.material)) {
          const m2 = [];
          for (let e3 = 0, t3 = this.material.length; e3 < t3; e3++)
            m2.push(c2(r2.materials, this.material[e3]));
          l2.material = m2;
        } else
          l2.material = c2(r2.materials, this.material);
      if (0 < this.children.length) {
        l2.children = [];
        for (let e3 = 0; e3 < this.children.length; e3++)
          l2.children.push(this.children[e3].toJSON(r2).object);
      }
      if (0 < this.animations.length) {
        l2.animations = [];
        for (let e3 = 0; e3 < this.animations.length; e3++) {
          var p2 = this.animations[e3];
          l2.animations.push(c2(r2.animations, p2));
        }
      }
      return o2 && (e2 = f2(r2.geometries), t2 = f2(r2.materials), n2 = f2(r2.textures), i2 = f2(r2.images), a2 = f2(r2.shapes), u2 = f2(r2.skeletons), o2 = f2(r2.animations), 0 < e2.length && (s2.geometries = e2), 0 < t2.length && (s2.materials = t2), 0 < n2.length && (s2.textures = n2), 0 < i2.length && (s2.images = i2), 0 < a2.length && (s2.shapes = a2), 0 < u2.length && (s2.skeletons = u2), 0 < o2.length && (s2.animations = o2)), s2.object = l2, s2;
      function f2(e3) {
        const t3 = [];
        for (const r3 in e3) {
          const n3 = e3[r3];
          delete n3.metadata, t3.push(n3);
        }
        return t3;
      }
    }
    clone(e2) {
      return new this.constructor().copy(this, e2);
    }
    copy(t2, e2 = true) {
      if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), e2 === true)
        for (let e3 = 0; e3 < t2.children.length; e3++) {
          const r2 = t2.children[e3];
          this.add(r2.clone());
        }
      return this;
    }
  }
  Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = true, Object3D.prototype.isObject3D = true;
  const _v0$1 = new Vector3(), _v1$3 = new Vector3(), _v2$2 = new Vector3(), _v3$1 = new Vector3(), _vab = new Vector3(), _vac = new Vector3(), _vbc = new Vector3(), _vap = new Vector3(), _vbp = new Vector3(), _vcp = new Vector3();
  class Triangle {
    constructor(e2 = new Vector3(), t2 = new Vector3(), r2 = new Vector3()) {
      this.a = e2, this.b = t2, this.c = r2;
    }
    static getNormal(e2, t2, r2, n2) {
      n2.subVectors(r2, t2), _v0$1.subVectors(e2, t2), n2.cross(_v0$1);
      t2 = n2.lengthSq();
      return 0 < t2 ? n2.multiplyScalar(1 / Math.sqrt(t2)) : n2.set(0, 0, 0);
    }
    static getBarycoord(e2, t2, r2, n2, i2) {
      _v0$1.subVectors(n2, t2), _v1$3.subVectors(r2, t2), _v2$2.subVectors(e2, t2);
      var a2 = _v0$1.dot(_v0$1), o2 = _v0$1.dot(_v1$3), n2 = _v0$1.dot(_v2$2), r2 = _v1$3.dot(_v1$3), e2 = _v1$3.dot(_v2$2), t2 = a2 * r2 - o2 * o2;
      if (t2 == 0)
        return i2.set(-2, -1, -1);
      t2 = 1 / t2, r2 = (r2 * n2 - o2 * e2) * t2, t2 *= a2 * e2 - o2 * n2;
      return i2.set(1 - r2 - t2, t2, r2);
    }
    static containsPoint(e2, t2, r2, n2) {
      return this.getBarycoord(e2, t2, r2, n2, _v3$1), 0 <= _v3$1.x && 0 <= _v3$1.y && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(e2, t2, r2, n2, i2, a2, o2, s2) {
      return this.getBarycoord(e2, t2, r2, n2, _v3$1), s2.set(0, 0), s2.addScaledVector(i2, _v3$1.x), s2.addScaledVector(a2, _v3$1.y), s2.addScaledVector(o2, _v3$1.z), s2;
    }
    static isFrontFacing(e2, t2, r2, n2) {
      return _v0$1.subVectors(r2, t2), _v1$3.subVectors(e2, t2), _v0$1.cross(_v1$3).dot(n2) < 0;
    }
    set(e2, t2, r2) {
      return this.a.copy(e2), this.b.copy(t2), this.c.copy(r2), this;
    }
    setFromPointsAndIndices(e2, t2, r2, n2) {
      return this.a.copy(e2[t2]), this.b.copy(e2[r2]), this.c.copy(e2[n2]), this;
    }
    setFromAttributeAndIndices(e2, t2, r2, n2) {
      return this.a.fromBufferAttribute(e2, t2), this.b.fromBufferAttribute(e2, r2), this.c.fromBufferAttribute(e2, n2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.a.copy(e2.a), this.b.copy(e2.b), this.c.copy(e2.c), this;
    }
    getArea() {
      return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), 0.5 * _v0$1.cross(_v1$3).length();
    }
    getMidpoint(e2) {
      return e2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e2) {
      return Triangle.getNormal(this.a, this.b, this.c, e2);
    }
    getPlane(e2) {
      return e2.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e2, t2) {
      return Triangle.getBarycoord(e2, this.a, this.b, this.c, t2);
    }
    getUV(e2, t2, r2, n2, i2) {
      return Triangle.getUV(e2, this.a, this.b, this.c, t2, r2, n2, i2);
    }
    containsPoint(e2) {
      return Triangle.containsPoint(e2, this.a, this.b, this.c);
    }
    isFrontFacing(e2) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, e2);
    }
    intersectsBox(e2) {
      return e2.intersectsTriangle(this);
    }
    closestPointToPoint(e2, t2) {
      var r2 = this.a, n2 = this.b, i2 = this.c;
      let a2, o2;
      _vab.subVectors(n2, r2), _vac.subVectors(i2, r2), _vap.subVectors(e2, r2);
      var s2 = _vab.dot(_vap), l2 = _vac.dot(_vap);
      if (s2 <= 0 && l2 <= 0)
        return t2.copy(r2);
      _vbp.subVectors(e2, n2);
      var c2 = _vab.dot(_vbp), u2 = _vac.dot(_vbp);
      if (0 <= c2 && u2 <= c2)
        return t2.copy(n2);
      var h2 = s2 * u2 - c2 * l2;
      if (h2 <= 0 && 0 <= s2 && c2 <= 0)
        return a2 = s2 / (s2 - c2), t2.copy(r2).addScaledVector(_vab, a2);
      _vcp.subVectors(e2, i2);
      var d2 = _vab.dot(_vcp), e2 = _vac.dot(_vcp);
      if (0 <= e2 && d2 <= e2)
        return t2.copy(i2);
      s2 = d2 * l2 - s2 * e2;
      if (s2 <= 0 && 0 <= l2 && e2 <= 0)
        return o2 = l2 / (l2 - e2), t2.copy(r2).addScaledVector(_vac, o2);
      l2 = c2 * e2 - d2 * u2;
      if (l2 <= 0 && 0 <= u2 - c2 && 0 <= d2 - e2)
        return _vbc.subVectors(i2, n2), o2 = (u2 - c2) / (u2 - c2 + (d2 - e2)), t2.copy(n2).addScaledVector(_vbc, o2);
      l2 = 1 / (l2 + s2 + h2);
      return a2 = s2 * l2, o2 = h2 * l2, t2.copy(r2).addScaledVector(_vab, a2).addScaledVector(_vac, o2);
    }
    equals(e2) {
      return e2.a.equals(this.a) && e2.b.equals(this.b) && e2.c.equals(this.c);
    }
  }
  let materialId = 0;
  class Material extends EventDispatcher {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.fog = true, this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = false, this.opacity = 1, this.format = RGBAFormat, this.transparent = false, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e2) {
      0 < this._alphaTest != 0 < e2 && this.version++, this._alphaTest = e2;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e2) {
      if (e2 !== void 0)
        for (const r2 in e2) {
          var t2 = e2[r2];
          if (t2 !== void 0)
            if (r2 !== "shading") {
              const n2 = this[r2];
              n2 !== void 0 ? n2 && n2.isColor ? n2.set(t2) : n2 && n2.isVector3 && t2 && t2.isVector3 ? n2.copy(t2) : this[r2] = t2 : console.warn("THREE." + this.type + ": '" + r2 + "' is not a property of this material.");
            } else
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t2 === FlatShading;
          else
            console.warn("THREE.Material: '" + r2 + "' parameter is undefined.");
        }
    }
    toJSON(e2) {
      var t2 = e2 === void 0 || typeof e2 == "string";
      t2 && (e2 = { textures: {}, images: {} });
      const r2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      function n2(e3) {
        const t3 = [];
        for (const r3 in e3) {
          const n3 = e3[r3];
          delete n3.metadata, t3.push(n3);
        }
        return t3;
      }
      return r2.uuid = this.uuid, r2.type = this.type, this.name !== "" && (r2.name = this.name), this.color && this.color.isColor && (r2.color = this.color.getHex()), this.roughness !== void 0 && (r2.roughness = this.roughness), this.metalness !== void 0 && (r2.metalness = this.metalness), this.sheen !== void 0 && (r2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r2.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r2.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r2.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r2.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r2.shininess = this.shininess), this.clearcoat !== void 0 && (r2.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r2.clearcoatMap = this.clearcoatMap.toJSON(e2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e2).uuid, r2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r2.map = this.map.toJSON(e2).uuid), this.matcap && this.matcap.isTexture && (r2.matcap = this.matcap.toJSON(e2).uuid), this.alphaMap && this.alphaMap.isTexture && (r2.alphaMap = this.alphaMap.toJSON(e2).uuid), this.lightMap && this.lightMap.isTexture && (r2.lightMap = this.lightMap.toJSON(e2).uuid, r2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r2.aoMap = this.aoMap.toJSON(e2).uuid, r2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r2.bumpMap = this.bumpMap.toJSON(e2).uuid, r2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r2.normalMap = this.normalMap.toJSON(e2).uuid, r2.normalMapType = this.normalMapType, r2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r2.displacementMap = this.displacementMap.toJSON(e2).uuid, r2.displacementScale = this.displacementScale, r2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r2.roughnessMap = this.roughnessMap.toJSON(e2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r2.metalnessMap = this.metalnessMap.toJSON(e2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r2.emissiveMap = this.emissiveMap.toJSON(e2).uuid), this.specularMap && this.specularMap.isTexture && (r2.specularMap = this.specularMap.toJSON(e2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r2.specularIntensityMap = this.specularIntensityMap.toJSON(e2).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r2.specularColorMap = this.specularColorMap.toJSON(e2).uuid), this.envMap && this.envMap.isTexture && (r2.envMap = this.envMap.toJSON(e2).uuid, this.combine !== void 0 && (r2.combine = this.combine)), this.envMapIntensity !== void 0 && (r2.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r2.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r2.gradientMap = this.gradientMap.toJSON(e2).uuid), this.transmission !== void 0 && (r2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r2.transmissionMap = this.transmissionMap.toJSON(e2).uuid), this.thickness !== void 0 && (r2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r2.thicknessMap = this.thicknessMap.toJSON(e2).uuid), this.attenuationDistance !== void 0 && (r2.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r2.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r2.size = this.size), this.shadowSide !== null && (r2.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r2.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (r2.blending = this.blending), this.side !== FrontSide && (r2.side = this.side), this.vertexColors && (r2.vertexColors = true), this.opacity < 1 && (r2.opacity = this.opacity), this.format !== RGBAFormat && (r2.format = this.format), this.transparent === true && (r2.transparent = this.transparent), r2.depthFunc = this.depthFunc, r2.depthTest = this.depthTest, r2.depthWrite = this.depthWrite, r2.colorWrite = this.colorWrite, r2.stencilWrite = this.stencilWrite, r2.stencilWriteMask = this.stencilWriteMask, r2.stencilFunc = this.stencilFunc, r2.stencilRef = this.stencilRef, r2.stencilFuncMask = this.stencilFuncMask, r2.stencilFail = this.stencilFail, r2.stencilZFail = this.stencilZFail, r2.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (r2.rotation = this.rotation), this.polygonOffset === true && (r2.polygonOffset = true), this.polygonOffsetFactor !== 0 && (r2.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (r2.linewidth = this.linewidth), this.dashSize !== void 0 && (r2.dashSize = this.dashSize), this.gapSize !== void 0 && (r2.gapSize = this.gapSize), this.scale !== void 0 && (r2.scale = this.scale), this.dithering === true && (r2.dithering = true), 0 < this.alphaTest && (r2.alphaTest = this.alphaTest), this.alphaToCoverage === true && (r2.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (r2.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (r2.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (r2.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r2.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r2.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (r2.flatShading = this.flatShading), this.visible === false && (r2.visible = false), this.toneMapped === false && (r2.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (r2.userData = this.userData), t2 && (t2 = n2(e2.textures), e2 = n2(e2.images), 0 < t2.length && (r2.textures = t2), 0 < e2.length && (r2.images = e2)), r2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.name = e2.name, this.fog = e2.fog, this.blending = e2.blending, this.side = e2.side, this.vertexColors = e2.vertexColors, this.opacity = e2.opacity, this.format = e2.format, this.transparent = e2.transparent, this.blendSrc = e2.blendSrc, this.blendDst = e2.blendDst, this.blendEquation = e2.blendEquation, this.blendSrcAlpha = e2.blendSrcAlpha, this.blendDstAlpha = e2.blendDstAlpha, this.blendEquationAlpha = e2.blendEquationAlpha, this.depthFunc = e2.depthFunc, this.depthTest = e2.depthTest, this.depthWrite = e2.depthWrite, this.stencilWriteMask = e2.stencilWriteMask, this.stencilFunc = e2.stencilFunc, this.stencilRef = e2.stencilRef, this.stencilFuncMask = e2.stencilFuncMask, this.stencilFail = e2.stencilFail, this.stencilZFail = e2.stencilZFail, this.stencilZPass = e2.stencilZPass, this.stencilWrite = e2.stencilWrite;
      const t2 = e2.clippingPlanes;
      let r2 = null;
      if (t2 !== null) {
        var n2 = t2.length;
        r2 = new Array(n2);
        for (let e3 = 0; e3 !== n2; ++e3)
          r2[e3] = t2[e3].clone();
      }
      return this.clippingPlanes = r2, this.clipIntersection = e2.clipIntersection, this.clipShadows = e2.clipShadows, this.shadowSide = e2.shadowSide, this.colorWrite = e2.colorWrite, this.precision = e2.precision, this.polygonOffset = e2.polygonOffset, this.polygonOffsetFactor = e2.polygonOffsetFactor, this.polygonOffsetUnits = e2.polygonOffsetUnits, this.dithering = e2.dithering, this.alphaTest = e2.alphaTest, this.alphaToCoverage = e2.alphaToCoverage, this.premultipliedAlpha = e2.premultipliedAlpha, this.visible = e2.visible, this.toneMapped = e2.toneMapped, this.userData = JSON.parse(JSON.stringify(e2.userData)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e2) {
      e2 === true && this.version++;
    }
  }
  Material.prototype.isMaterial = true;
  const _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(e2, t2, r2) {
    return r2 < 0 && (r2 += 1), 1 < r2 && --r2, r2 < 1 / 6 ? e2 + 6 * (t2 - e2) * r2 : r2 < 0.5 ? t2 : r2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - r2) : e2;
  }
  function SRGBToLinear(e2) {
    return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(e2) {
    return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
  }
  class Color {
    constructor(e2, t2, r2) {
      return t2 === void 0 && r2 === void 0 ? this.set(e2) : this.setRGB(e2, t2, r2);
    }
    set(e2) {
      return e2 && e2.isColor ? this.copy(e2) : typeof e2 == "number" ? this.setHex(e2) : typeof e2 == "string" && this.setStyle(e2), this;
    }
    setScalar(e2) {
      return this.r = e2, this.g = e2, this.b = e2, this;
    }
    setHex(e2) {
      return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, this;
    }
    setRGB(e2, t2, r2) {
      return this.r = e2, this.g = t2, this.b = r2, this;
    }
    setHSL(e2, t2, r2) {
      return e2 = euclideanModulo(e2, 1), t2 = clamp(t2, 0, 1), r2 = clamp(r2, 0, 1), t2 === 0 ? this.r = this.g = this.b = r2 : (this.r = hue2rgb(t2 = 2 * r2 - (r2 = r2 <= 0.5 ? r2 * (1 + t2) : r2 + t2 - r2 * t2), r2, e2 + 1 / 3), this.g = hue2rgb(t2, r2, e2), this.b = hue2rgb(t2, r2, e2 - 1 / 3)), this;
    }
    setStyle(t2) {
      function r2(e2) {
        e2 !== void 0 && parseFloat(e2) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
      }
      let n2;
      if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t2)) {
        let e2;
        var i2 = n2[1], a2 = n2[2];
        switch (i2) {
          case "rgb":
          case "rgba":
            if (e2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a2))
              return this.r = Math.min(255, parseInt(e2[1], 10)) / 255, this.g = Math.min(255, parseInt(e2[2], 10)) / 255, this.b = Math.min(255, parseInt(e2[3], 10)) / 255, r2(e2[4]), this;
            if (e2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a2))
              return this.r = Math.min(100, parseInt(e2[1], 10)) / 100, this.g = Math.min(100, parseInt(e2[2], 10)) / 100, this.b = Math.min(100, parseInt(e2[3], 10)) / 100, r2(e2[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (e2 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a2)) {
              var o2 = parseFloat(e2[1]) / 360, s2 = parseInt(e2[2], 10) / 100, l2 = parseInt(e2[3], 10) / 100;
              return r2(e2[4]), this.setHSL(o2, s2, l2);
            }
        }
      } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
        const e2 = n2[1];
        i2 = e2.length;
        if (i2 === 3)
          return this.r = parseInt(e2.charAt(0) + e2.charAt(0), 16) / 255, this.g = parseInt(e2.charAt(1) + e2.charAt(1), 16) / 255, this.b = parseInt(e2.charAt(2) + e2.charAt(2), 16) / 255, this;
        if (i2 === 6)
          return this.r = parseInt(e2.charAt(0) + e2.charAt(1), 16) / 255, this.g = parseInt(e2.charAt(2) + e2.charAt(3), 16) / 255, this.b = parseInt(e2.charAt(4) + e2.charAt(5), 16) / 255, this;
      }
      return t2 && 0 < t2.length ? this.setColorName(t2) : this;
    }
    setColorName(e2) {
      var t2 = _colorKeywords[e2.toLowerCase()];
      return t2 !== void 0 ? this.setHex(t2) : console.warn("THREE.Color: Unknown color " + e2), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e2) {
      return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
    }
    copyGammaToLinear(e2, t2 = 2) {
      return this.r = Math.pow(e2.r, t2), this.g = Math.pow(e2.g, t2), this.b = Math.pow(e2.b, t2), this;
    }
    copyLinearToGamma(e2, t2 = 2) {
      t2 = 0 < t2 ? 1 / t2 : 1;
      return this.r = Math.pow(e2.r, t2), this.g = Math.pow(e2.g, t2), this.b = Math.pow(e2.b, t2), this;
    }
    convertGammaToLinear(e2) {
      return this.copyGammaToLinear(this, e2), this;
    }
    convertLinearToGamma(e2) {
      return this.copyLinearToGamma(this, e2), this;
    }
    copySRGBToLinear(e2) {
      return this.r = SRGBToLinear(e2.r), this.g = SRGBToLinear(e2.g), this.b = SRGBToLinear(e2.b), this;
    }
    copyLinearToSRGB(e2) {
      return this.r = LinearToSRGB(e2.r), this.g = LinearToSRGB(e2.g), this.b = LinearToSRGB(e2.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(e2) {
      var t2 = this.r, r2 = this.g, n2 = this.b, i2 = Math.max(t2, r2, n2), a2 = Math.min(t2, r2, n2);
      let o2, s2;
      var l2 = (a2 + i2) / 2;
      if (a2 === i2)
        o2 = 0, s2 = 0;
      else {
        var c2 = i2 - a2;
        switch (s2 = l2 <= 0.5 ? c2 / (i2 + a2) : c2 / (2 - i2 - a2), i2) {
          case t2:
            o2 = (r2 - n2) / c2 + (r2 < n2 ? 6 : 0);
            break;
          case r2:
            o2 = (n2 - t2) / c2 + 2;
            break;
          case n2:
            o2 = (t2 - r2) / c2 + 4;
        }
        o2 /= 6;
      }
      return e2.h = o2, e2.s = s2, e2.l = l2, e2;
    }
    getStyle() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    }
    offsetHSL(e2, t2, r2) {
      return this.getHSL(_hslA), _hslA.h += e2, _hslA.s += t2, _hslA.l += r2, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this;
    }
    add(e2) {
      return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
    }
    addColors(e2, t2) {
      return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
    }
    addScalar(e2) {
      return this.r += e2, this.g += e2, this.b += e2, this;
    }
    sub(e2) {
      return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
    }
    multiply(e2) {
      return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
    }
    multiplyScalar(e2) {
      return this.r *= e2, this.g *= e2, this.b *= e2, this;
    }
    lerp(e2, t2) {
      return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
    }
    lerpColors(e2, t2, r2) {
      return this.r = e2.r + (t2.r - e2.r) * r2, this.g = e2.g + (t2.g - e2.g) * r2, this.b = e2.b + (t2.b - e2.b) * r2, this;
    }
    lerpHSL(e2, t2) {
      this.getHSL(_hslA), e2.getHSL(_hslB);
      var r2 = lerp(_hslA.h, _hslB.h, t2), e2 = lerp(_hslA.s, _hslB.s, t2), t2 = lerp(_hslA.l, _hslB.l, t2);
      return this.setHSL(r2, e2, t2), this;
    }
    equals(e2) {
      return e2.r === this.r && e2.g === this.g && e2.b === this.b;
    }
    fromArray(e2, t2 = 0) {
      return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), e2.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
      return this.getHex();
    }
  }
  Color.NAMES = _colorKeywords, Color.prototype.isColor = true, Color.prototype.r = 1, Color.prototype.g = 1, Color.prototype.b = 1;
  class MeshBasicMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this;
    }
  }
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  const _vector$9 = new Vector3(), _vector2$1 = new Vector2();
  class BufferAttribute {
    constructor(e2, t2, r2) {
      if (Array.isArray(e2))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = e2, this.itemSize = t2, this.count = e2 !== void 0 ? e2.length / t2 : 0, this.normalized = r2 === true, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      e2 === true && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.name = e2.name, this.array = new e2.array.constructor(e2.array), this.itemSize = e2.itemSize, this.count = e2.count, this.normalized = e2.normalized, this.usage = e2.usage, this;
    }
    copyAt(r2, n2, i2) {
      r2 *= this.itemSize, i2 *= n2.itemSize;
      for (let e2 = 0, t2 = this.itemSize; e2 < t2; e2++)
        this.array[r2 + e2] = n2.array[i2 + e2];
      return this;
    }
    copyArray(e2) {
      return this.array.set(e2), this;
    }
    copyColorsArray(r2) {
      const n2 = this.array;
      let i2 = 0;
      for (let t2 = 0, e2 = r2.length; t2 < e2; t2++) {
        let e3 = r2[t2];
        e3 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", t2), e3 = new Color()), n2[i2++] = e3.r, n2[i2++] = e3.g, n2[i2++] = e3.b;
      }
      return this;
    }
    copyVector2sArray(r2) {
      const n2 = this.array;
      let i2 = 0;
      for (let t2 = 0, e2 = r2.length; t2 < e2; t2++) {
        let e3 = r2[t2];
        e3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", t2), e3 = new Vector2()), n2[i2++] = e3.x, n2[i2++] = e3.y;
      }
      return this;
    }
    copyVector3sArray(r2) {
      const n2 = this.array;
      let i2 = 0;
      for (let t2 = 0, e2 = r2.length; t2 < e2; t2++) {
        let e3 = r2[t2];
        e3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", t2), e3 = new Vector3()), n2[i2++] = e3.x, n2[i2++] = e3.y, n2[i2++] = e3.z;
      }
      return this;
    }
    copyVector4sArray(r2) {
      const n2 = this.array;
      let i2 = 0;
      for (let t2 = 0, e2 = r2.length; t2 < e2; t2++) {
        let e3 = r2[t2];
        e3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", t2), e3 = new Vector4()), n2[i2++] = e3.x, n2[i2++] = e3.y, n2[i2++] = e3.z, n2[i2++] = e3.w;
      }
      return this;
    }
    applyMatrix3(r2) {
      if (this.itemSize === 2)
        for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
          _vector2$1.fromBufferAttribute(this, e2), _vector2$1.applyMatrix3(r2), this.setXY(e2, _vector2$1.x, _vector2$1.y);
      else if (this.itemSize === 3)
        for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
          _vector$9.fromBufferAttribute(this, e2), _vector$9.applyMatrix3(r2), this.setXYZ(e2, _vector$9.x, _vector$9.y, _vector$9.z);
      return this;
    }
    applyMatrix4(r2) {
      for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
        _vector$9.x = this.getX(e2), _vector$9.y = this.getY(e2), _vector$9.z = this.getZ(e2), _vector$9.applyMatrix4(r2), this.setXYZ(e2, _vector$9.x, _vector$9.y, _vector$9.z);
      return this;
    }
    applyNormalMatrix(r2) {
      for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
        _vector$9.x = this.getX(e2), _vector$9.y = this.getY(e2), _vector$9.z = this.getZ(e2), _vector$9.applyNormalMatrix(r2), this.setXYZ(e2, _vector$9.x, _vector$9.y, _vector$9.z);
      return this;
    }
    transformDirection(r2) {
      for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
        _vector$9.x = this.getX(e2), _vector$9.y = this.getY(e2), _vector$9.z = this.getZ(e2), _vector$9.transformDirection(r2), this.setXYZ(e2, _vector$9.x, _vector$9.y, _vector$9.z);
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    getX(e2) {
      return this.array[e2 * this.itemSize];
    }
    setX(e2, t2) {
      return this.array[e2 * this.itemSize] = t2, this;
    }
    getY(e2) {
      return this.array[e2 * this.itemSize + 1];
    }
    setY(e2, t2) {
      return this.array[e2 * this.itemSize + 1] = t2, this;
    }
    getZ(e2) {
      return this.array[e2 * this.itemSize + 2];
    }
    setZ(e2, t2) {
      return this.array[e2 * this.itemSize + 2] = t2, this;
    }
    getW(e2) {
      return this.array[e2 * this.itemSize + 3];
    }
    setW(e2, t2) {
      return this.array[e2 * this.itemSize + 3] = t2, this;
    }
    setXY(e2, t2, r2) {
      return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this;
    }
    setXYZ(e2, t2, r2, n2) {
      return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this.array[e2 + 2] = n2, this;
    }
    setXYZW(e2, t2, r2, n2, i2) {
      return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this.array[e2 + 2] = n2, this.array[e2 + 3] = i2, this;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      return this.name !== "" && (e2.name = this.name), this.usage !== StaticDrawUsage && (e2.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (e2.updateRange = this.updateRange), e2;
    }
  }
  BufferAttribute.prototype.isBufferAttribute = true;
  class Uint16BufferAttribute extends BufferAttribute {
    constructor(e2, t2, r2) {
      super(new Uint16Array(e2), t2, r2);
    }
  }
  class Uint32BufferAttribute extends BufferAttribute {
    constructor(e2, t2, r2) {
      super(new Uint32Array(e2), t2, r2);
    }
  }
  class Float16BufferAttribute extends BufferAttribute {
    constructor(e2, t2, r2) {
      super(new Uint16Array(e2), t2, r2);
    }
  }
  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
  class Float32BufferAttribute extends BufferAttribute {
    constructor(e2, t2, r2) {
      super(new Float32Array(e2), t2, r2);
    }
  }
  let _id = 0;
  const _m1 = new Matrix4(), _obj = new Object3D(), _offset = new Vector3(), _box$1 = new Box3(), _boxMorphTargets = new Box3(), _vector$8 = new Vector3();
  class BufferGeometry extends EventDispatcher {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: _id++ }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e2) {
      return Array.isArray(e2) ? this.index = new (65535 < arrayMax(e2) ? Uint32BufferAttribute : Uint16BufferAttribute)(e2, 1) : this.index = e2, this;
    }
    getAttribute(e2) {
      return this.attributes[e2];
    }
    setAttribute(e2, t2) {
      return this.attributes[e2] = t2, this;
    }
    deleteAttribute(e2) {
      return delete this.attributes[e2], this;
    }
    hasAttribute(e2) {
      return this.attributes[e2] !== void 0;
    }
    addGroup(e2, t2, r2 = 0) {
      this.groups.push({ start: e2, count: t2, materialIndex: r2 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e2, t2) {
      this.drawRange.start = e2, this.drawRange.count = t2;
    }
    applyMatrix4(e2) {
      const t2 = this.attributes.position;
      t2 !== void 0 && (t2.applyMatrix4(e2), t2.needsUpdate = true);
      const r2 = this.attributes.normal;
      var n2;
      r2 !== void 0 && (n2 = new Matrix3().getNormalMatrix(e2), r2.applyNormalMatrix(n2), r2.needsUpdate = true);
      const i2 = this.attributes.tangent;
      return i2 !== void 0 && (i2.transformDirection(e2), i2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e2) {
      return _m1.makeRotationFromQuaternion(e2), this.applyMatrix4(_m1), this;
    }
    rotateX(e2) {
      return _m1.makeRotationX(e2), this.applyMatrix4(_m1), this;
    }
    rotateY(e2) {
      return _m1.makeRotationY(e2), this.applyMatrix4(_m1), this;
    }
    rotateZ(e2) {
      return _m1.makeRotationZ(e2), this.applyMatrix4(_m1), this;
    }
    translate(e2, t2, r2) {
      return _m1.makeTranslation(e2, t2, r2), this.applyMatrix4(_m1), this;
    }
    scale(e2, t2, r2) {
      return _m1.makeScale(e2, t2, r2), this.applyMatrix4(_m1), this;
    }
    lookAt(e2) {
      return _obj.lookAt(e2), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
    }
    setFromPoints(r2) {
      const n2 = [];
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++) {
        var i2 = r2[e2];
        n2.push(i2.x, i2.y, i2.z || 0);
      }
      return this.setAttribute("position", new Float32BufferAttribute(n2, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Box3());
      var e2 = this.attributes.position, r2 = this.morphAttributes.position;
      if (e2 && e2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0));
      if (e2 !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e2), r2)
          for (let e3 = 0, t2 = r2.length; e3 < t2; e3++) {
            var n2 = r2[e3];
            _box$1.setFromBufferAttribute(n2), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$1.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min), this.boundingBox.expandByPoint(_box$1.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Sphere());
      var n2 = this.attributes.position, i2 = this.morphAttributes.position;
      if (n2 && n2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Vector3(), 1 / 0);
      if (n2) {
        const l2 = this.boundingSphere.center;
        if (_box$1.setFromBufferAttribute(n2), i2)
          for (let e2 = 0, t2 = i2.length; e2 < t2; e2++) {
            var a2 = i2[e2];
            _boxMorphTargets.setFromBufferAttribute(a2), this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min), _box$1.expandByPoint(_vector$8), _vector$8.addVectors(_box$1.max, _boxMorphTargets.max), _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min), _box$1.expandByPoint(_boxMorphTargets.max));
          }
        _box$1.getCenter(l2);
        let r2 = 0;
        for (let e2 = 0, t2 = n2.count; e2 < t2; e2++)
          _vector$8.fromBufferAttribute(n2, e2), r2 = Math.max(r2, l2.distanceToSquared(_vector$8));
        if (i2)
          for (let e2 = 0, t2 = i2.length; e2 < t2; e2++) {
            var o2 = i2[e2], s2 = this.morphTargetsRelative;
            for (let e3 = 0, t3 = o2.count; e3 < t3; e3++)
              _vector$8.fromBufferAttribute(o2, e3), s2 && (_offset.fromBufferAttribute(n2, e3), _vector$8.add(_offset)), r2 = Math.max(r2, l2.distanceToSquared(_vector$8));
          }
        this.boundingSphere.radius = Math.sqrt(r2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      var e2 = this.index, t2 = this.attributes;
      if (e2 !== null && t2.position !== void 0 && t2.normal !== void 0 && t2.uv !== void 0) {
        let c2 = function(e3) {
          T2.fromArray(h2, 3 * e3), k2.copy(T2);
          var t3 = f2[e3];
          M2.copy(t3), M2.sub(T2.multiplyScalar(T2.dot(t3))).normalize(), E2.crossVectors(k2, t3);
          t3 = E2.dot(m2[e3]) < 0 ? -1 : 1;
          p2[4 * e3] = M2.x, p2[4 * e3 + 1] = M2.y, p2[4 * e3 + 2] = M2.z, p2[4 * e3 + 3] = t3;
        };
        var n2 = e2.array;
        const u2 = t2.position.array, h2 = t2.normal.array, d2 = t2.uv.array;
        var i2 = u2.length / 3;
        t2.tangent === void 0 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * i2), 4));
        const p2 = t2.tangent.array, f2 = [], m2 = [];
        for (let e3 = 0; e3 < i2; e3++)
          f2[e3] = new Vector3(), m2[e3] = new Vector3();
        const g2 = new Vector3(), v2 = new Vector3(), y = new Vector3(), _2 = new Vector2(), b2 = new Vector2(), x2 = new Vector2(), w2 = new Vector3(), S2 = new Vector3();
        let r2 = this.groups;
        r2.length === 0 && (r2 = [{ start: 0, count: n2.length }]);
        for (let e3 = 0, t3 = r2.length; e3 < t3; ++e3) {
          var a2 = r2[e3], o2 = a2.start;
          for (let e4 = o2, t4 = o2 + a2.count; e4 < t4; e4 += 3)
            !function(e5, t5, r3) {
              g2.fromArray(u2, 3 * e5), v2.fromArray(u2, 3 * t5), y.fromArray(u2, 3 * r3), _2.fromArray(d2, 2 * e5), b2.fromArray(d2, 2 * t5), x2.fromArray(d2, 2 * r3), v2.sub(g2), y.sub(g2), b2.sub(_2), x2.sub(_2);
              var n3 = 1 / (b2.x * x2.y - x2.x * b2.y);
              isFinite(n3) && (w2.copy(v2).multiplyScalar(x2.y).addScaledVector(y, -b2.y).multiplyScalar(n3), S2.copy(y).multiplyScalar(b2.x).addScaledVector(v2, -x2.x).multiplyScalar(n3), f2[e5].add(w2), f2[t5].add(w2), f2[r3].add(w2), m2[e5].add(S2), m2[t5].add(S2), m2[r3].add(S2));
            }(n2[e4 + 0], n2[e4 + 1], n2[e4 + 2]);
        }
        const M2 = new Vector3(), E2 = new Vector3(), T2 = new Vector3(), k2 = new Vector3();
        for (let e3 = 0, t3 = r2.length; e3 < t3; ++e3) {
          var s2 = r2[e3], l2 = s2.start;
          for (let e4 = l2, t4 = l2 + s2.count; e4 < t4; e4 += 3)
            c2(n2[e4 + 0]), c2(n2[e4 + 1]), c2(n2[e4 + 2]);
        }
      } else
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    }
    computeVertexNormals() {
      const n2 = this.index;
      var i2 = this.getAttribute("position");
      if (i2 !== void 0) {
        let r2 = this.getAttribute("normal");
        if (r2 === void 0)
          r2 = new BufferAttribute(new Float32Array(3 * i2.count), 3), this.setAttribute("normal", r2);
        else
          for (let e2 = 0, t2 = r2.count; e2 < t2; e2++)
            r2.setXYZ(e2, 0, 0, 0);
        const l2 = new Vector3(), c2 = new Vector3(), u2 = new Vector3(), h2 = new Vector3(), d2 = new Vector3(), p2 = new Vector3(), f2 = new Vector3(), m2 = new Vector3();
        if (n2)
          for (let e2 = 0, t2 = n2.count; e2 < t2; e2 += 3) {
            var a2 = n2.getX(e2 + 0), o2 = n2.getX(e2 + 1), s2 = n2.getX(e2 + 2);
            l2.fromBufferAttribute(i2, a2), c2.fromBufferAttribute(i2, o2), u2.fromBufferAttribute(i2, s2), f2.subVectors(u2, c2), m2.subVectors(l2, c2), f2.cross(m2), h2.fromBufferAttribute(r2, a2), d2.fromBufferAttribute(r2, o2), p2.fromBufferAttribute(r2, s2), h2.add(f2), d2.add(f2), p2.add(f2), r2.setXYZ(a2, h2.x, h2.y, h2.z), r2.setXYZ(o2, d2.x, d2.y, d2.z), r2.setXYZ(s2, p2.x, p2.y, p2.z);
          }
        else
          for (let e2 = 0, t2 = i2.count; e2 < t2; e2 += 3)
            l2.fromBufferAttribute(i2, e2 + 0), c2.fromBufferAttribute(i2, e2 + 1), u2.fromBufferAttribute(i2, e2 + 2), f2.subVectors(u2, c2), m2.subVectors(l2, c2), f2.cross(m2), r2.setXYZ(e2 + 0, f2.x, f2.y, f2.z), r2.setXYZ(e2 + 1, f2.x, f2.y, f2.z), r2.setXYZ(e2 + 2, f2.x, f2.y, f2.z);
        this.normalizeNormals(), r2.needsUpdate = true;
      }
    }
    merge(e2, t2) {
      if (e2 && e2.isBufferGeometry) {
        t2 === void 0 && (t2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        var r2 = this.attributes;
        for (const o2 in r2)
          if (e2.attributes[o2] !== void 0) {
            const s2 = r2[o2].array;
            var n2 = e2.attributes[o2], i2 = n2.array, n2 = n2.itemSize * t2, a2 = Math.min(i2.length, s2.length - n2);
            for (let e3 = 0, t3 = n2; e3 < a2; e3++, t3++)
              s2[t3] = i2[e3];
          }
        return this;
      }
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e2);
    }
    normalizeNormals() {
      const r2 = this.attributes.normal;
      for (let e2 = 0, t2 = r2.count; e2 < t2; e2++)
        _vector$8.fromBufferAttribute(r2, e2), _vector$8.normalize(), r2.setXYZ(e2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    toNonIndexed() {
      function r2(r3, n3) {
        const i3 = r3.array;
        var a3 = r3.itemSize, e3 = r3.normalized;
        const o3 = new i3.constructor(n3.length * a3);
        let s3 = 0, l3 = 0;
        for (let e4 = 0, t3 = n3.length; e4 < t3; e4++) {
          s3 = r3.isInterleavedBufferAttribute ? n3[e4] * r3.data.stride + r3.offset : n3[e4] * a3;
          for (let e5 = 0; e5 < a3; e5++)
            o3[l3++] = i3[s3++];
        }
        return new BufferAttribute(o3, a3, e3);
      }
      if (this.index === null)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const n2 = new BufferGeometry();
      var i2 = this.index.array, e2 = this.attributes;
      for (const u2 in e2) {
        var t2 = r2(e2[u2], i2);
        n2.setAttribute(u2, t2);
      }
      var a2 = this.morphAttributes;
      for (const h2 in a2) {
        const d2 = [];
        var o2 = a2[h2];
        for (let e3 = 0, t3 = o2.length; e3 < t3; e3++) {
          var s2 = r2(o2[e3], i2);
          d2.push(s2);
        }
        n2.morphAttributes[h2] = d2;
      }
      n2.morphTargetsRelative = this.morphTargetsRelative;
      var l2 = this.groups;
      for (let e3 = 0, t3 = l2.length; e3 < t3; e3++) {
        var c2 = l2[e3];
        n2.addGroup(c2.start, c2.count, c2.materialIndex);
      }
      return n2;
    }
    toJSON() {
      const r2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (r2.uuid = this.uuid, r2.type = this.type, this.name !== "" && (r2.name = this.name), 0 < Object.keys(this.userData).length && (r2.userData = this.userData), this.parameters !== void 0) {
        var e2 = this.parameters;
        for (const l2 in e2)
          e2[l2] !== void 0 && (r2[l2] = e2[l2]);
        return r2;
      }
      r2.data = { attributes: {} };
      var t2 = this.index;
      t2 !== null && (r2.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
      var n2 = this.attributes;
      for (const c2 in n2) {
        const u2 = n2[c2];
        r2.data.attributes[c2] = u2.toJSON(r2.data);
      }
      const i2 = {};
      let a2 = false;
      for (const h2 in this.morphAttributes) {
        var o2 = this.morphAttributes[h2];
        const d2 = [];
        for (let e3 = 0, t3 = o2.length; e3 < t3; e3++) {
          const p2 = o2[e3];
          d2.push(p2.toJSON(r2.data));
        }
        0 < d2.length && (i2[h2] = d2, a2 = true);
      }
      a2 && (r2.data.morphAttributes = i2, r2.data.morphTargetsRelative = this.morphTargetsRelative);
      t2 = this.groups;
      0 < t2.length && (r2.data.groups = JSON.parse(JSON.stringify(t2)));
      const s2 = this.boundingSphere;
      return s2 !== null && (r2.data.boundingSphere = { center: s2.center.toArray(), radius: s2.radius }), r2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      var r2 = {};
      this.name = e2.name;
      const t2 = e2.index;
      t2 !== null && this.setIndex(t2.clone(r2));
      var n2 = e2.attributes;
      for (const c2 in n2) {
        const u2 = n2[c2];
        this.setAttribute(c2, u2.clone(r2));
      }
      var i2 = e2.morphAttributes;
      for (const h2 in i2) {
        const d2 = [], p2 = i2[h2];
        for (let e3 = 0, t3 = p2.length; e3 < t3; e3++)
          d2.push(p2[e3].clone(r2));
        this.morphAttributes[h2] = d2;
      }
      this.morphTargetsRelative = e2.morphTargetsRelative;
      var a2 = e2.groups;
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        var o2 = a2[e3];
        this.addGroup(o2.start, o2.count, o2.materialIndex);
      }
      const s2 = e2.boundingBox;
      s2 !== null && (this.boundingBox = s2.clone());
      const l2 = e2.boundingSphere;
      return l2 !== null && (this.boundingSphere = l2.clone()), this.drawRange.start = e2.drawRange.start, this.drawRange.count = e2.drawRange.count, this.userData = e2.userData, e2.parameters !== void 0 && (this.parameters = Object.assign({}, e2.parameters)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  BufferGeometry.prototype.isBufferGeometry = true;
  const _inverseMatrix$2 = new Matrix4(), _ray$2 = new Ray(), _sphere$3 = new Sphere(), _vA$1 = new Vector3(), _vB$1 = new Vector3(), _vC$1 = new Vector3(), _tempA = new Vector3(), _tempB = new Vector3(), _tempC = new Vector3(), _morphA = new Vector3(), _morphB = new Vector3(), _morphC = new Vector3(), _uvA$1 = new Vector2(), _uvB$1 = new Vector2(), _uvC$1 = new Vector2(), _intersectionPoint = new Vector3(), _intersectionPointWorld = new Vector3();
  class Mesh extends Object3D {
    constructor(e2 = new BufferGeometry(), t2 = new MeshBasicMaterial()) {
      super(), this.type = "Mesh", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2) {
      return super.copy(e2), e2.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e2.morphTargetInfluences.slice()), e2.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e2.morphTargetDictionary)), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    updateMorphTargets() {
      var e2 = this.geometry;
      if (e2.isBufferGeometry) {
        var t2 = e2.morphAttributes, r2 = Object.keys(t2);
        if (0 < r2.length) {
          var n2 = t2[r2[0]];
          if (n2 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
              var i2 = n2[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i2] = e3;
            }
          }
        }
      } else {
        e2 = e2.morphTargets;
        e2 !== void 0 && 0 < e2.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    raycast(n2, i2) {
      const e2 = this.geometry;
      var a2 = this.material, t2 = this.matrixWorld;
      if (a2 !== void 0 && (e2.boundingSphere === null && e2.computeBoundingSphere(), _sphere$3.copy(e2.boundingSphere), _sphere$3.applyMatrix4(t2), n2.ray.intersectsSphere(_sphere$3) !== false && (_inverseMatrix$2.copy(t2).invert(), _ray$2.copy(n2.ray).applyMatrix4(_inverseMatrix$2), e2.boundingBox === null || _ray$2.intersectsBox(e2.boundingBox) !== false))) {
        let r2;
        if (e2.isBufferGeometry) {
          const C2 = e2.index;
          var o2 = e2.attributes.position, s2 = e2.morphAttributes.position, l2 = e2.morphTargetsRelative, c2 = e2.attributes.uv, u2 = e2.attributes.uv2, h2 = e2.groups, d2 = e2.drawRange;
          if (C2 !== null)
            if (Array.isArray(a2))
              for (let e3 = 0, t3 = h2.length; e3 < t3; e3++) {
                var p2 = h2[e3], f2 = a2[p2.materialIndex];
                for (let e4 = Math.max(p2.start, d2.start), t4 = Math.min(C2.count, Math.min(p2.start + p2.count, d2.start + d2.count)); e4 < t4; e4 += 3) {
                  var m2 = C2.getX(e4), g2 = C2.getX(e4 + 1), v2 = C2.getX(e4 + 2);
                  r2 = checkBufferGeometryIntersection(this, f2, n2, _ray$2, o2, s2, l2, c2, u2, m2, g2, v2), r2 && (r2.faceIndex = Math.floor(e4 / 3), r2.face.materialIndex = p2.materialIndex, i2.push(r2));
                }
              }
            else
              for (let e3 = Math.max(0, d2.start), t3 = Math.min(C2.count, d2.start + d2.count); e3 < t3; e3 += 3) {
                var y = C2.getX(e3), _2 = C2.getX(e3 + 1), b2 = C2.getX(e3 + 2);
                r2 = checkBufferGeometryIntersection(this, a2, n2, _ray$2, o2, s2, l2, c2, u2, y, _2, b2), r2 && (r2.faceIndex = Math.floor(e3 / 3), i2.push(r2));
              }
          else if (o2 !== void 0)
            if (Array.isArray(a2))
              for (let e3 = 0, t3 = h2.length; e3 < t3; e3++) {
                var x2 = h2[e3], w2 = a2[x2.materialIndex];
                for (let e4 = Math.max(x2.start, d2.start), t4 = Math.min(o2.count, Math.min(x2.start + x2.count, d2.start + d2.count)); e4 < t4; e4 += 3) {
                  var S2 = e4, M2 = e4 + 1, E2 = e4 + 2;
                  r2 = checkBufferGeometryIntersection(this, w2, n2, _ray$2, o2, s2, l2, c2, u2, S2, M2, E2), r2 && (r2.faceIndex = Math.floor(e4 / 3), r2.face.materialIndex = x2.materialIndex, i2.push(r2));
                }
              }
            else
              for (let e3 = Math.max(0, d2.start), t3 = Math.min(o2.count, d2.start + d2.count); e3 < t3; e3 += 3) {
                var T2 = e3, k2 = e3 + 1, A2 = e3 + 2;
                r2 = checkBufferGeometryIntersection(this, a2, n2, _ray$2, o2, s2, l2, c2, u2, T2, k2, A2), r2 && (r2.faceIndex = Math.floor(e3 / 3), i2.push(r2));
              }
        } else
          e2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  function checkIntersection(e2, t2, r2, n2, i2, a2, o2, s2) {
    let l2;
    if (l2 = t2.side === BackSide ? n2.intersectTriangle(o2, a2, i2, true, s2) : n2.intersectTriangle(i2, a2, o2, t2.side !== DoubleSide, s2), l2 === null)
      return null;
    _intersectionPointWorld.copy(s2), _intersectionPointWorld.applyMatrix4(e2.matrixWorld);
    s2 = r2.ray.origin.distanceTo(_intersectionPointWorld);
    return s2 < r2.near || s2 > r2.far ? null : { distance: s2, point: _intersectionPointWorld.clone(), object: e2 };
  }
  function checkBufferGeometryIntersection(e2, t2, r2, n2, i2, a2, o2, s2, l2, c2, u2, h2) {
    _vA$1.fromBufferAttribute(i2, c2), _vB$1.fromBufferAttribute(i2, u2), _vC$1.fromBufferAttribute(i2, h2);
    var d2 = e2.morphTargetInfluences;
    if (a2 && d2) {
      _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        var p2 = d2[e3], f2 = a2[e3];
        p2 !== 0 && (_tempA.fromBufferAttribute(f2, c2), _tempB.fromBufferAttribute(f2, u2), _tempC.fromBufferAttribute(f2, h2), o2 ? (_morphA.addScaledVector(_tempA, p2), _morphB.addScaledVector(_tempB, p2), _morphC.addScaledVector(_tempC, p2)) : (_morphA.addScaledVector(_tempA.sub(_vA$1), p2), _morphB.addScaledVector(_tempB.sub(_vB$1), p2), _morphC.addScaledVector(_tempC.sub(_vC$1), p2)));
      }
      _vA$1.add(_morphA), _vB$1.add(_morphB), _vC$1.add(_morphC);
    }
    e2.isSkinnedMesh && (e2.boneTransform(c2, _vA$1), e2.boneTransform(u2, _vB$1), e2.boneTransform(h2, _vC$1));
    const m2 = checkIntersection(e2, t2, r2, n2, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    return m2 && (s2 && (_uvA$1.fromBufferAttribute(s2, c2), _uvB$1.fromBufferAttribute(s2, u2), _uvC$1.fromBufferAttribute(s2, h2), m2.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), l2 && (_uvA$1.fromBufferAttribute(l2, c2), _uvB$1.fromBufferAttribute(l2, u2), _uvC$1.fromBufferAttribute(l2, h2), m2.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), l2 = { a: c2, b: u2, c: h2, normal: new Vector3(), materialIndex: 0 }, Triangle.getNormal(_vA$1, _vB$1, _vC$1, l2.normal), m2.face = l2), m2;
  }
  Mesh.prototype.isMesh = true;
  class BoxGeometry extends BufferGeometry {
    constructor(e2 = 1, t2 = 1, r2 = 1, n2 = 1, i2 = 1, a2 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: e2, height: t2, depth: r2, widthSegments: n2, heightSegments: i2, depthSegments: a2 };
      const k2 = this;
      n2 = Math.floor(n2), i2 = Math.floor(i2), a2 = Math.floor(a2);
      const A2 = [], C2 = [], $2 = [], R2 = [];
      let L = 0, O = 0;
      function o2(r3, n3, i3, a3, o3, e3, t3, s2, l2, c2, u2) {
        var h2 = e3 / l2, d2 = t3 / c2, p2 = e3 / 2, f2 = t3 / 2, m2 = s2 / 2, g2 = l2 + 1, v2 = c2 + 1;
        let y = 0, _2 = 0;
        const b2 = new Vector3();
        for (let t4 = 0; t4 < v2; t4++) {
          var x2 = t4 * d2 - f2;
          for (let e4 = 0; e4 < g2; e4++) {
            var w2 = e4 * h2 - p2;
            b2[r3] = w2 * a3, b2[n3] = x2 * o3, b2[i3] = m2, C2.push(b2.x, b2.y, b2.z), b2[r3] = 0, b2[n3] = 0, b2[i3] = 0 < s2 ? 1 : -1, $2.push(b2.x, b2.y, b2.z), R2.push(e4 / l2), R2.push(1 - t4 / c2), y += 1;
          }
        }
        for (let t4 = 0; t4 < c2; t4++)
          for (let e4 = 0; e4 < l2; e4++) {
            var S2 = L + e4 + g2 * t4, M2 = L + e4 + g2 * (t4 + 1), E2 = L + (e4 + 1) + g2 * (t4 + 1), T2 = L + (e4 + 1) + g2 * t4;
            A2.push(S2, M2, T2), A2.push(M2, E2, T2), _2 += 6;
          }
        k2.addGroup(O, _2, u2), O += _2, L += y;
      }
      o2("z", "y", "x", -1, -1, r2, t2, e2, a2, i2, 0), o2("z", "y", "x", 1, -1, r2, t2, -e2, a2, i2, 1), o2("x", "z", "y", 1, 1, e2, r2, t2, n2, a2, 2), o2("x", "z", "y", 1, -1, e2, r2, -t2, n2, a2, 3), o2("x", "y", "z", 1, -1, e2, t2, r2, n2, i2, 4), o2("x", "y", "z", -1, -1, e2, t2, -r2, n2, i2, 5), this.setIndex(A2), this.setAttribute("position", new Float32BufferAttribute(C2, 3)), this.setAttribute("normal", new Float32BufferAttribute($2, 3)), this.setAttribute("uv", new Float32BufferAttribute(R2, 2));
    }
    static fromJSON(e2) {
      return new BoxGeometry(e2.width, e2.height, e2.depth, e2.widthSegments, e2.heightSegments, e2.depthSegments);
    }
  }
  function cloneUniforms(e2) {
    const t2 = {};
    for (const r2 in e2) {
      t2[r2] = {};
      for (const n2 in e2[r2]) {
        const i2 = e2[r2][n2];
        i2 && (i2.isColor || i2.isMatrix3 || i2.isMatrix4 || i2.isVector2 || i2.isVector3 || i2.isVector4 || i2.isTexture || i2.isQuaternion) ? t2[r2][n2] = i2.clone() : Array.isArray(i2) ? t2[r2][n2] = i2.slice() : t2[r2][n2] = i2;
      }
    }
    return t2;
  }
  function mergeUniforms(t2) {
    const r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = cloneUniforms(t2[e2]);
      for (const i2 in n2)
        r2[i2] = n2[i2];
    }
    return r2;
  }
  const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  class ShaderMaterial extends Material {
    constructor(e2) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e2 !== void 0 && (e2.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e2));
    }
    copy(e2) {
      return super.copy(e2), this.fragmentShader = e2.fragmentShader, this.vertexShader = e2.vertexShader, this.uniforms = cloneUniforms(e2.uniforms), this.defines = Object.assign({}, e2.defines), this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.lights = e2.lights, this.clipping = e2.clipping, this.extensions = Object.assign({}, e2.extensions), this.glslVersion = e2.glslVersion, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      t2.glslVersion = this.glslVersion, t2.uniforms = {};
      for (const n2 in this.uniforms) {
        const i2 = this.uniforms[n2].value;
        i2 && i2.isTexture ? t2.uniforms[n2] = { type: "t", value: i2.toJSON(e2).uuid } : i2 && i2.isColor ? t2.uniforms[n2] = { type: "c", value: i2.getHex() } : i2 && i2.isVector2 ? t2.uniforms[n2] = { type: "v2", value: i2.toArray() } : i2 && i2.isVector3 ? t2.uniforms[n2] = { type: "v3", value: i2.toArray() } : i2 && i2.isVector4 ? t2.uniforms[n2] = { type: "v4", value: i2.toArray() } : i2 && i2.isMatrix3 ? t2.uniforms[n2] = { type: "m3", value: i2.toArray() } : i2 && i2.isMatrix4 ? t2.uniforms[n2] = { type: "m4", value: i2.toArray() } : t2.uniforms[n2] = { value: i2 };
      }
      0 < Object.keys(this.defines).length && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader;
      const r2 = {};
      for (const a2 in this.extensions)
        this.extensions[a2] === true && (r2[a2] = true);
      return 0 < Object.keys(r2).length && (t2.extensions = r2), t2;
    }
  }
  ShaderMaterial.prototype.isShaderMaterial = true;
  class Camera extends Object3D {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.matrixWorldInverse.copy(e2.matrixWorldInverse), this.projectionMatrix.copy(e2.projectionMatrix), this.projectionMatrixInverse.copy(e2.projectionMatrixInverse), this;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      var t2 = this.matrixWorld.elements;
      return e2.set(-t2[8], -t2[9], -t2[10]).normalize();
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e2, t2) {
      super.updateWorldMatrix(e2, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Camera.prototype.isCamera = true;
  class PerspectiveCamera extends Camera {
    constructor(e2 = 50, t2 = 1, r2 = 0.1, n2 = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = e2, this.zoom = 1, this.near = r2, this.far = n2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.fov = e2.fov, this.zoom = e2.zoom, this.near = e2.near, this.far = e2.far, this.focus = e2.focus, this.aspect = e2.aspect, this.view = e2.view === null ? null : Object.assign({}, e2.view), this.filmGauge = e2.filmGauge, this.filmOffset = e2.filmOffset, this;
    }
    setFocalLength(e2) {
      e2 = 0.5 * this.getFilmHeight() / e2;
      this.fov = 2 * RAD2DEG * Math.atan(e2), this.updateProjectionMatrix();
    }
    getFocalLength() {
      var e2 = Math.tan(0.5 * DEG2RAD * this.fov);
      return 0.5 * this.getFilmHeight() / e2;
    }
    getEffectiveFOV() {
      return 2 * RAD2DEG * Math.atan(Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e2, t2, r2, n2, i2, a2) {
      this.aspect = e2 / t2, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = r2, this.view.offsetY = n2, this.view.width = i2, this.view.height = a2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      var e2 = this.near;
      let t2 = e2 * Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom, r2 = 2 * t2, n2 = this.aspect * r2, i2 = -0.5 * n2;
      var a2, o2 = this.view;
      this.view !== null && this.view.enabled && (a2 = o2.fullWidth, s2 = o2.fullHeight, i2 += o2.offsetX * n2 / a2, t2 -= o2.offsetY * r2 / s2, n2 *= o2.width / a2, r2 *= o2.height / s2);
      var s2 = this.filmOffset;
      s2 !== 0 && (i2 += e2 * s2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i2, i2 + n2, t2, t2 - r2, e2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, this.view !== null && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
    }
  }
  PerspectiveCamera.prototype.isPerspectiveCamera = true;
  const fov = 90, aspect = 1;
  class CubeCamera extends Object3D {
    constructor(e2, t2, r2) {
      if (super(), this.type = "CubeCamera", r2.isWebGLCubeRenderTarget === true) {
        this.renderTarget = r2;
        const n2 = new PerspectiveCamera(fov, aspect, e2, t2);
        n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new Vector3(1, 0, 0)), this.add(n2);
        const i2 = new PerspectiveCamera(fov, aspect, e2, t2);
        i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new Vector3(-1, 0, 0)), this.add(i2);
        const a2 = new PerspectiveCamera(fov, aspect, e2, t2);
        a2.layers = this.layers, a2.up.set(0, 0, 1), a2.lookAt(new Vector3(0, 1, 0)), this.add(a2);
        const o2 = new PerspectiveCamera(fov, aspect, e2, t2);
        o2.layers = this.layers, o2.up.set(0, 0, -1), o2.lookAt(new Vector3(0, -1, 0)), this.add(o2);
        const s2 = new PerspectiveCamera(fov, aspect, e2, t2);
        s2.layers = this.layers, s2.up.set(0, -1, 0), s2.lookAt(new Vector3(0, 0, 1)), this.add(s2);
        const l2 = new PerspectiveCamera(fov, aspect, e2, t2);
        l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new Vector3(0, 0, -1)), this.add(l2);
      } else
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    }
    update(e2, t2) {
      this.parent === null && this.updateMatrixWorld();
      const r2 = this.renderTarget;
      var [n2, i2, a2, o2, s2, l2] = this.children, c2 = e2.xr.enabled, u2 = e2.getRenderTarget();
      e2.xr.enabled = false;
      var h2 = r2.texture.generateMipmaps;
      r2.texture.generateMipmaps = false, e2.setRenderTarget(r2, 0), e2.render(t2, n2), e2.setRenderTarget(r2, 1), e2.render(t2, i2), e2.setRenderTarget(r2, 2), e2.render(t2, a2), e2.setRenderTarget(r2, 3), e2.render(t2, o2), e2.setRenderTarget(r2, 4), e2.render(t2, s2), r2.texture.generateMipmaps = h2, e2.setRenderTarget(r2, 5), e2.render(t2, l2), e2.setRenderTarget(u2), e2.xr.enabled = c2;
    }
  }
  class CubeTexture extends Texture {
    constructor(e2, t2, r2, n2, i2, a2, o2, s2, l2, c2) {
      super(e2 = e2 !== void 0 ? e2 : [], t2 = t2 !== void 0 ? t2 : CubeReflectionMapping, r2, n2, i2, a2, o2, s2, l2, c2), this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e2) {
      this.image = e2;
    }
  }
  CubeTexture.prototype.isCubeTexture = true;
  class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(e2, t2, r2) {
      Number.isInteger(t2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t2 = r2), super(e2, e2, t2), t2 = t2 || {}, this.texture = new CubeTexture(void 0, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t2.generateMipmaps !== void 0 && t2.generateMipmaps, this.texture.minFilter = t2.minFilter !== void 0 ? t2.minFilter : LinearFilter, this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(e2, t2) {
      this.texture.type = t2.type, this.texture.format = RGBAFormat, this.texture.encoding = t2.encoding, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
      var r2 = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, n2 = new BoxGeometry(5, 5, 5);
      const i2 = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(r2.uniforms), vertexShader: r2.vertexShader, fragmentShader: r2.fragmentShader, side: BackSide, blending: NoBlending });
      i2.uniforms.tEquirect.value = t2;
      const a2 = new Mesh(n2, i2);
      n2 = t2.minFilter;
      t2.minFilter === LinearMipmapLinearFilter && (t2.minFilter = LinearFilter);
      const o2 = new CubeCamera(1, 10, this);
      return o2.update(e2, a2), t2.minFilter = n2, a2.geometry.dispose(), a2.material.dispose(), this;
    }
    clear(t2, r2, n2, i2) {
      var e2 = t2.getRenderTarget();
      for (let e3 = 0; e3 < 6; e3++)
        t2.setRenderTarget(this, e3), t2.clear(r2, n2, i2);
      t2.setRenderTarget(e2);
    }
  }
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
  const _vector1 = new Vector3(), _vector2 = new Vector3(), _normalMatrix = new Matrix3();
  class Plane {
    constructor(e2 = new Vector3(1, 0, 0), t2 = 0) {
      this.normal = e2, this.constant = t2;
    }
    set(e2, t2) {
      return this.normal.copy(e2), this.constant = t2, this;
    }
    setComponents(e2, t2, r2, n2) {
      return this.normal.set(e2, t2, r2), this.constant = n2, this;
    }
    setFromNormalAndCoplanarPoint(e2, t2) {
      return this.normal.copy(e2), this.constant = -t2.dot(this.normal), this;
    }
    setFromCoplanarPoints(e2, t2, r2) {
      t2 = _vector1.subVectors(r2, t2).cross(_vector2.subVectors(e2, t2)).normalize();
      return this.setFromNormalAndCoplanarPoint(t2, e2), this;
    }
    copy(e2) {
      return this.normal.copy(e2.normal), this.constant = e2.constant, this;
    }
    normalize() {
      var e2 = 1 / this.normal.length();
      return this.normal.multiplyScalar(e2), this.constant *= e2, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e2) {
      return this.normal.dot(e2) + this.constant;
    }
    distanceToSphere(e2) {
      return this.distanceToPoint(e2.center) - e2.radius;
    }
    projectPoint(e2, t2) {
      return t2.copy(this.normal).multiplyScalar(-this.distanceToPoint(e2)).add(e2);
    }
    intersectLine(e2, t2) {
      var r2 = e2.delta(_vector1), n2 = this.normal.dot(r2);
      if (n2 === 0)
        return this.distanceToPoint(e2.start) === 0 ? t2.copy(e2.start) : null;
      n2 = -(e2.start.dot(this.normal) + this.constant) / n2;
      return n2 < 0 || 1 < n2 ? null : t2.copy(r2).multiplyScalar(n2).add(e2.start);
    }
    intersectsLine(e2) {
      var t2 = this.distanceToPoint(e2.start), e2 = this.distanceToPoint(e2.end);
      return t2 < 0 && 0 < e2 || e2 < 0 && 0 < t2;
    }
    intersectsBox(e2) {
      return e2.intersectsPlane(this);
    }
    intersectsSphere(e2) {
      return e2.intersectsPlane(this);
    }
    coplanarPoint(e2) {
      return e2.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e2, t2) {
      t2 = t2 || _normalMatrix.getNormalMatrix(e2);
      const r2 = this.coplanarPoint(_vector1).applyMatrix4(e2);
      t2 = this.normal.applyMatrix3(t2).normalize();
      return this.constant = -r2.dot(t2), this;
    }
    translate(e2) {
      return this.constant -= e2.dot(this.normal), this;
    }
    equals(e2) {
      return e2.normal.equals(this.normal) && e2.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Plane.prototype.isPlane = true;
  const _sphere$2 = new Sphere(), _vector$7 = new Vector3();
  class Frustum {
    constructor(e2 = new Plane(), t2 = new Plane(), r2 = new Plane(), n2 = new Plane(), i2 = new Plane(), a2 = new Plane()) {
      this.planes = [e2, t2, r2, n2, i2, a2];
    }
    set(e2, t2, r2, n2, i2, a2) {
      const o2 = this.planes;
      return o2[0].copy(e2), o2[1].copy(t2), o2[2].copy(r2), o2[3].copy(n2), o2[4].copy(i2), o2[5].copy(a2), this;
    }
    copy(t2) {
      const r2 = this.planes;
      for (let e2 = 0; e2 < 6; e2++)
        r2[e2].copy(t2.planes[e2]);
      return this;
    }
    setFromProjectionMatrix(e2) {
      const t2 = this.planes;
      var r2 = e2.elements, n2 = r2[0], i2 = r2[1], a2 = r2[2], o2 = r2[3], s2 = r2[4], l2 = r2[5], c2 = r2[6], u2 = r2[7], h2 = r2[8], d2 = r2[9], p2 = r2[10], f2 = r2[11], m2 = r2[12], g2 = r2[13], e2 = r2[14], r2 = r2[15];
      return t2[0].setComponents(o2 - n2, u2 - s2, f2 - h2, r2 - m2).normalize(), t2[1].setComponents(o2 + n2, u2 + s2, f2 + h2, r2 + m2).normalize(), t2[2].setComponents(o2 + i2, u2 + l2, f2 + d2, r2 + g2).normalize(), t2[3].setComponents(o2 - i2, u2 - l2, f2 - d2, r2 - g2).normalize(), t2[4].setComponents(o2 - a2, u2 - c2, f2 - p2, r2 - e2).normalize(), t2[5].setComponents(o2 + a2, u2 + c2, f2 + p2, r2 + e2).normalize(), this;
    }
    intersectsObject(e2) {
      const t2 = e2.geometry;
      return t2.boundingSphere === null && t2.computeBoundingSphere(), _sphere$2.copy(t2.boundingSphere).applyMatrix4(e2.matrixWorld), this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(e2) {
      return _sphere$2.center.set(0, 0, 0), _sphere$2.radius = 0.7071067811865476, _sphere$2.applyMatrix4(e2.matrixWorld), this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(e2) {
      const t2 = this.planes;
      var r2 = e2.center, n2 = -e2.radius;
      for (let e3 = 0; e3 < 6; e3++)
        if (t2[e3].distanceToPoint(r2) < n2)
          return false;
      return true;
    }
    intersectsBox(t2) {
      var r2 = this.planes;
      for (let e2 = 0; e2 < 6; e2++) {
        const n2 = r2[e2];
        if (_vector$7.x = (0 < n2.normal.x ? t2.max : t2.min).x, _vector$7.y = (0 < n2.normal.y ? t2.max : t2.min).y, _vector$7.z = (0 < n2.normal.z ? t2.max : t2.min).z, n2.distanceToPoint(_vector$7) < 0)
          return false;
      }
      return true;
    }
    containsPoint(t2) {
      const r2 = this.planes;
      for (let e2 = 0; e2 < 6; e2++)
        if (r2[e2].distanceToPoint(t2) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function WebGLAnimation() {
    let r2 = null, e2 = false, n2 = null, i2 = null;
    function a2(e3, t2) {
      n2(e3, t2), i2 = r2.requestAnimationFrame(a2);
    }
    return { start: function() {
      e2 !== true && n2 !== null && (i2 = r2.requestAnimationFrame(a2), e2 = true);
    }, stop: function() {
      r2.cancelAnimationFrame(i2), e2 = false;
    }, setAnimationLoop: function(e3) {
      n2 = e3;
    }, setContext: function(e3) {
      r2 = e3;
    } };
  }
  function WebGLAttributes(o2, e2) {
    const s2 = e2.isWebGL2, i2 = new WeakMap();
    return { get: function(e3) {
      return e3.isInterleavedBufferAttribute && (e3 = e3.data), i2.get(e3);
    }, remove: function(e3) {
      e3.isInterleavedBufferAttribute && (e3 = e3.data);
      var t2 = i2.get(e3);
      t2 && (o2.deleteBuffer(t2.buffer), i2.delete(e3));
    }, update: function(e3, t2) {
      if (e3.isGLBufferAttribute) {
        var r2 = i2.get(e3);
        (!r2 || r2.version < e3.version) && i2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version });
      } else {
        e3.isInterleavedBufferAttribute && (e3 = e3.data);
        const n2 = i2.get(e3);
        n2 === void 0 ? i2.set(e3, function(e4, t3) {
          var r3 = e4.array, n3 = e4.usage, i3 = o2.createBuffer();
          o2.bindBuffer(t3, i3), o2.bufferData(t3, r3, n3), e4.onUploadCallback();
          let a2 = 5126;
          return r3 instanceof Float32Array ? a2 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? s2 ? a2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a2 = 5123 : r3 instanceof Int16Array ? a2 = 5122 : r3 instanceof Uint32Array ? a2 = 5125 : r3 instanceof Int32Array ? a2 = 5124 : r3 instanceof Int8Array ? a2 = 5120 : (r3 instanceof Uint8Array || r3 instanceof Uint8ClampedArray) && (a2 = 5121), { buffer: i3, type: a2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
        }(e3, t2)) : n2.version < e3.version && (function(e4, t3, r3) {
          const n3 = t3.array, i3 = t3.updateRange;
          o2.bindBuffer(r3, e4), i3.count === -1 ? o2.bufferSubData(r3, 0, n3) : (s2 ? o2.bufferSubData(r3, i3.offset * n3.BYTES_PER_ELEMENT, n3, i3.offset, i3.count) : o2.bufferSubData(r3, i3.offset * n3.BYTES_PER_ELEMENT, n3.subarray(i3.offset, i3.offset + i3.count)), i3.count = -1);
        }(n2.buffer, e3, t2), n2.version = e3.version);
      }
    } };
  }
  class PlaneGeometry extends BufferGeometry {
    constructor(e2 = 1, t2 = 1, r2 = 1, n2 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: e2, height: t2, widthSegments: r2, heightSegments: n2 };
      var i2 = e2 / 2, a2 = t2 / 2, o2 = Math.floor(r2), s2 = Math.floor(n2), l2 = o2 + 1, c2 = s2 + 1, u2 = e2 / o2, h2 = t2 / s2;
      const d2 = [], p2 = [], f2 = [], m2 = [];
      for (let t3 = 0; t3 < c2; t3++) {
        var g2 = t3 * h2 - a2;
        for (let e3 = 0; e3 < l2; e3++) {
          var v2 = e3 * u2 - i2;
          p2.push(v2, -g2, 0), f2.push(0, 0, 1), m2.push(e3 / o2), m2.push(1 - t3 / s2);
        }
      }
      for (let t3 = 0; t3 < s2; t3++)
        for (let e3 = 0; e3 < o2; e3++) {
          var y = e3 + l2 * t3, _2 = e3 + l2 * (t3 + 1), b2 = e3 + 1 + l2 * (t3 + 1), x2 = e3 + 1 + l2 * t3;
          d2.push(y, _2, x2), d2.push(_2, b2, x2);
        }
      this.setIndex(d2), this.setAttribute("position", new Float32BufferAttribute(p2, 3)), this.setAttribute("normal", new Float32BufferAttribute(f2, 3)), this.setAttribute("uv", new Float32BufferAttribute(m2, 2));
    }
    static fromJSON(e2) {
      return new PlaneGeometry(e2.width, e2.height, e2.widthSegments, e2.heightSegments);
    }
  }
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex = "vec3 transformed = vec3( position );", beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", ShaderChunk = { alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_physical_pars_fragment, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, background_vert: vertex$g, background_frag: fragment$g, cube_vert: vertex$f, cube_frag: fragment$f, depth_vert: vertex$e, depth_frag: fragment$e, distanceRGBA_vert: vertex$d, distanceRGBA_frag: fragment$d, equirect_vert: vertex$c, equirect_frag: fragment$c, linedashed_vert: vertex$b, linedashed_frag: fragment$b, meshbasic_vert: vertex$a, meshbasic_frag: fragment$a, meshlambert_vert: vertex$9, meshlambert_frag: fragment$9, meshmatcap_vert: vertex$8, meshmatcap_frag: fragment$8, meshnormal_vert: vertex$7, meshnormal_frag: fragment$7, meshphong_vert: vertex$6, meshphong_frag: fragment$6, meshphysical_vert: vertex$5, meshphysical_frag: fragment$5, meshtoon_vert: vertex$4, meshtoon_frag: fragment$4, points_vert: vertex$3, points_frag: fragment$3, shadow_vert: vertex$2, shadow_frag: fragment$2, sprite_vert: vertex$1, sprite_frag: fragment$1 }, UniformsLib = { common: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Matrix3() }, uv2Transform: { value: new Matrix3() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3() } }, sprite: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, center: { value: new Vector2(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3() } } }, ShaderLib = { basic: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) }, specular: { value: new Color(1118481) }, shininess: { value: 30 } }]), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) } }]), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } }]), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.meshnormal_vert, fragmentShader: ShaderChunk.meshnormal_frag }, sprite: { uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3() }, t2D: { value: null } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, cube: { uniforms: mergeUniforms([UniformsLib.envmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: new Color(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } };
  function WebGLBackground(a2, o2, r2, s2, n2) {
    const l2 = new Color(0);
    let c2 = 0, u2, h2, d2 = null, p2 = 0, f2 = null;
    function m2(e2, t2) {
      r2.buffers.color.setClear(e2.r, e2.g, e2.b, t2, n2);
    }
    return { getClearColor: function() {
      return l2;
    }, setClearColor: function(e2, t2 = 1) {
      l2.set(e2), c2 = t2, m2(l2, c2);
    }, getClearAlpha: function() {
      return c2;
    }, setClearAlpha: function(e2) {
      c2 = e2, m2(l2, c2);
    }, render: function(e2, t2) {
      let r3 = false, n3 = t2.isScene === true ? t2.background : null;
      n3 && n3.isTexture && (n3 = o2.get(n3));
      const i2 = a2.xr;
      (t2 = i2.getSession && i2.getSession()) && t2.environmentBlendMode === "additive" && (n3 = null), n3 === null ? m2(l2, c2) : n3 && n3.isColor && (m2(n3, 1), r3 = true), (a2.autoClear || r3) && a2.clear(a2.autoClearColor, a2.autoClearDepth, a2.autoClearStencil), n3 && (n3.isCubeTexture || n3.mapping === CubeUVReflectionMapping) ? (h2 === void 0 && (h2 = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({ name: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.cube.uniforms), vertexShader: ShaderLib.cube.vertexShader, fragmentShader: ShaderLib.cube.fragmentShader, side: BackSide, depthTest: false, depthWrite: false, fog: false })), h2.geometry.deleteAttribute("normal"), h2.geometry.deleteAttribute("uv"), h2.onBeforeRender = function(e3, t3, r4) {
        this.matrixWorld.copyPosition(r4.matrixWorld);
      }, Object.defineProperty(h2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), s2.update(h2)), h2.material.uniforms.envMap.value = n3, h2.material.uniforms.flipEnvMap.value = n3.isCubeTexture && n3.isRenderTargetTexture === false ? -1 : 1, d2 === n3 && p2 === n3.version && f2 === a2.toneMapping || (h2.material.needsUpdate = true, d2 = n3, p2 = n3.version, f2 = a2.toneMapping), e2.unshift(h2, h2.geometry, h2.material, 0, 0, null)) : n3 && n3.isTexture && (u2 === void 0 && (u2 = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ name: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: false, depthWrite: false, fog: false })), u2.geometry.deleteAttribute("normal"), Object.defineProperty(u2.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), s2.update(u2)), u2.material.uniforms.t2D.value = n3, n3.matrixAutoUpdate === true && n3.updateMatrix(), u2.material.uniforms.uvTransform.value.copy(n3.matrix), d2 === n3 && p2 === n3.version && f2 === a2.toneMapping || (u2.material.needsUpdate = true, d2 = n3, p2 = n3.version, f2 = a2.toneMapping), e2.unshift(u2, u2.geometry, u2.material, 0, 0, null));
    } };
  }
  function WebGLBindingStates(_2, b2, x2, w2) {
    const i2 = _2.getParameter(34921), s2 = w2.isWebGL2 ? null : b2.get("OES_vertex_array_object"), l2 = w2.isWebGL2 || s2 !== null, c2 = {}, e2 = d2(null);
    let u2 = e2;
    function h2(e3) {
      return w2.isWebGL2 ? _2.bindVertexArray(e3) : s2.bindVertexArrayOES(e3);
    }
    function a2(e3) {
      return w2.isWebGL2 ? _2.deleteVertexArray(e3) : s2.deleteVertexArrayOES(e3);
    }
    function d2(e3) {
      const t3 = [], r2 = [], n2 = [];
      for (let e4 = 0; e4 < i2; e4++)
        t3[e4] = 0, r2[e4] = 0, n2[e4] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: r2, attributeDivisors: n2, object: e3, attributes: {}, index: null };
    }
    function S2() {
      const r2 = u2.newAttributes;
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++)
        r2[e3] = 0;
    }
    function M2(e3) {
      E2(e3, 0);
    }
    function E2(e3, t3) {
      const r2 = u2.newAttributes, n2 = u2.enabledAttributes, i3 = u2.attributeDivisors;
      if (r2[e3] = 1, n2[e3] === 0 && (_2.enableVertexAttribArray(e3), n2[e3] = 1), i3[e3] !== t3) {
        const a3 = w2.isWebGL2 ? _2 : b2.get("ANGLE_instanced_arrays");
        a3[w2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e3, t3), i3[e3] = t3;
      }
    }
    function T2() {
      var r2 = u2.newAttributes;
      const n2 = u2.enabledAttributes;
      for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
        n2[e3] !== r2[e3] && (_2.disableVertexAttribArray(e3), n2[e3] = 0);
    }
    function k2(e3, t3, r2, n2, i3, a3) {
      w2.isWebGL2 !== true || r2 !== 5124 && r2 !== 5125 ? _2.vertexAttribPointer(e3, t3, r2, n2, i3, a3) : _2.vertexAttribIPointer(e3, t3, r2, i3, a3);
    }
    function o2() {
      t2(), u2 !== e2 && (u2 = e2, h2(u2.object));
    }
    function t2() {
      e2.geometry = null, e2.program = null, e2.wireframe = false;
    }
    return { setup: function(e3, t3, r2, n2, i3) {
      let a3 = false;
      var o3;
      l2 ? (o3 = function(e4, t4, r3) {
        r3 = r3.wireframe === true;
        let n3 = c2[e4.id];
        n3 === void 0 && (n3 = {}, c2[e4.id] = n3);
        let i4 = n3[t4.id];
        i4 === void 0 && (i4 = {}, n3[t4.id] = i4);
        let a4 = i4[r3];
        a4 === void 0 && (a4 = d2(w2.isWebGL2 ? _2.createVertexArray() : s2.createVertexArrayOES()), i4[r3] = a4);
        return a4;
      }(n2, r2, t3), u2 !== o3 && (u2 = o3, h2(u2.object)), a3 = function(e4, t4) {
        var r3 = u2.attributes, n3 = e4.attributes;
        let i4 = 0;
        for (const s3 in n3) {
          var a4 = r3[s3], o4 = n3[s3];
          if (a4 === void 0)
            return true;
          if (a4.attribute !== o4)
            return true;
          if (a4.data !== o4.data)
            return true;
          i4++;
        }
        return u2.attributesNum !== i4 || u2.index !== t4;
      }(n2, i3), a3 && function(e4, t4) {
        const r3 = {}, n3 = e4.attributes;
        let i4 = 0;
        for (const o4 in n3) {
          var a4 = n3[o4];
          const s3 = {};
          (s3.attribute = a4).data && (s3.data = a4.data), r3[o4] = s3, i4++;
        }
        u2.attributes = r3, u2.attributesNum = i4, u2.index = t4;
      }(n2, i3)) : (o3 = t3.wireframe === true, u2.geometry === n2.id && u2.program === r2.id && u2.wireframe === o3 || (u2.geometry = n2.id, u2.program = r2.id, u2.wireframe = o3, a3 = true)), e3.isInstancedMesh === true && (a3 = true), i3 !== null && x2.update(i3, 34963), a3 && (function(e4, t4, r3, n3) {
        if (w2.isWebGL2 === false && (e4.isInstancedMesh || n3.isInstancedBufferGeometry) && b2.get("ANGLE_instanced_arrays") === null)
          return;
        S2();
        var i4 = n3.attributes, a4 = r3.getAttributes(), o4 = t4.defaultAttributeValues;
        for (const y in a4) {
          var s3 = a4[y];
          if (0 <= s3.location) {
            let t5 = i4[y];
            if (t5 === void 0 && (y === "instanceMatrix" && e4.instanceMatrix && (t5 = e4.instanceMatrix), y === "instanceColor" && e4.instanceColor && (t5 = e4.instanceColor)), t5 !== void 0) {
              var l3 = t5.normalized, c3 = t5.itemSize, u3 = x2.get(t5);
              if (u3 !== void 0) {
                var h3 = u3.buffer, d3 = u3.type, p2 = u3.bytesPerElement;
                if (t5.isInterleavedBufferAttribute) {
                  var f2 = t5.data, m2 = f2.stride, g2 = t5.offset;
                  if (f2 && f2.isInstancedInterleavedBuffer) {
                    for (let e5 = 0; e5 < s3.locationSize; e5++)
                      E2(s3.location + e5, f2.meshPerAttribute);
                    e4.isInstancedMesh !== true && n3._maxInstanceCount === void 0 && (n3._maxInstanceCount = f2.meshPerAttribute * f2.count);
                  } else
                    for (let e5 = 0; e5 < s3.locationSize; e5++)
                      M2(s3.location + e5);
                  _2.bindBuffer(34962, h3);
                  for (let e5 = 0; e5 < s3.locationSize; e5++)
                    k2(s3.location + e5, c3 / s3.locationSize, d3, l3, m2 * p2, (g2 + c3 / s3.locationSize * e5) * p2);
                } else {
                  if (t5.isInstancedBufferAttribute) {
                    for (let e5 = 0; e5 < s3.locationSize; e5++)
                      E2(s3.location + e5, t5.meshPerAttribute);
                    e4.isInstancedMesh !== true && n3._maxInstanceCount === void 0 && (n3._maxInstanceCount = t5.meshPerAttribute * t5.count);
                  } else
                    for (let e5 = 0; e5 < s3.locationSize; e5++)
                      M2(s3.location + e5);
                  _2.bindBuffer(34962, h3);
                  for (let e5 = 0; e5 < s3.locationSize; e5++)
                    k2(s3.location + e5, c3 / s3.locationSize, d3, l3, c3 * p2, c3 / s3.locationSize * e5 * p2);
                }
              }
            } else if (o4 !== void 0) {
              var v2 = o4[y];
              if (v2 !== void 0)
                switch (v2.length) {
                  case 2:
                    _2.vertexAttrib2fv(s3.location, v2);
                    break;
                  case 3:
                    _2.vertexAttrib3fv(s3.location, v2);
                    break;
                  case 4:
                    _2.vertexAttrib4fv(s3.location, v2);
                    break;
                  default:
                    _2.vertexAttrib1fv(s3.location, v2);
                }
            }
          }
        }
        T2();
      }(e3, t3, r2, n2), i3 !== null && _2.bindBuffer(34963, x2.get(i3).buffer));
    }, reset: o2, resetDefaultState: t2, dispose: function() {
      o2();
      for (const e3 in c2) {
        const t3 = c2[e3];
        for (const r2 in t3) {
          const n2 = t3[r2];
          for (const i3 in n2)
            a2(n2[i3].object), delete n2[i3];
          delete t3[r2];
        }
        delete c2[e3];
      }
    }, releaseStatesOfGeometry: function(e3) {
      if (c2[e3.id] !== void 0) {
        const t3 = c2[e3.id];
        for (const r2 in t3) {
          const n2 = t3[r2];
          for (const i3 in n2)
            a2(n2[i3].object), delete n2[i3];
          delete t3[r2];
        }
        delete c2[e3.id];
      }
    }, releaseStatesOfProgram: function(e3) {
      for (const t3 in c2) {
        const r2 = c2[t3];
        if (r2[e3.id] !== void 0) {
          const n2 = r2[e3.id];
          for (const i3 in n2)
            a2(n2[i3].object), delete n2[i3];
          delete r2[e3.id];
        }
      }
    }, initAttributes: S2, enableAttribute: M2, disableUnusedAttributes: T2 };
  }
  function WebGLBufferRenderer(a2, o2, s2, e2) {
    const l2 = e2.isWebGL2;
    let c2;
    this.setMode = function(e3) {
      c2 = e3;
    }, this.render = function(e3, t2) {
      a2.drawArrays(c2, e3, t2), s2.update(t2, c2, 1);
    }, this.renderInstances = function(r2, n2, i2) {
      if (i2 !== 0) {
        let e3, t2;
        if (l2)
          e3 = a2, t2 = "drawArraysInstanced";
        else if (e3 = o2.get("ANGLE_instanced_arrays"), t2 = "drawArraysInstancedANGLE", e3 === null)
          return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        e3[t2](c2, r2, n2, i2), s2.update(n2, c2, i2);
      }
    };
  }
  function WebGLCapabilities(t2, r2, e2) {
    let n2;
    function i2(e3) {
      if (e3 === "highp") {
        if (0 < t2.getShaderPrecisionFormat(35633, 36338).precision && 0 < t2.getShaderPrecisionFormat(35632, 36338).precision)
          return "highp";
        e3 = "mediump";
      }
      return e3 === "mediump" && 0 < t2.getShaderPrecisionFormat(35633, 36337).precision && 0 < t2.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var a2 = typeof WebGL2RenderingContext != "undefined" && t2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && t2 instanceof WebGL2ComputeRenderingContext;
    let o2 = e2.precision !== void 0 ? e2.precision : "highp";
    var s2 = i2(o2);
    s2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", s2, "instead."), o2 = s2);
    var l2 = a2 || r2.has("WEBGL_draw_buffers"), c2 = e2.logarithmicDepthBuffer === true, u2 = t2.getParameter(34930), h2 = t2.getParameter(35660), d2 = t2.getParameter(3379), p2 = t2.getParameter(34076), f2 = t2.getParameter(34921), m2 = t2.getParameter(36347), g2 = t2.getParameter(36348), v2 = t2.getParameter(36349), y = 0 < h2, _2 = a2 || r2.has("OES_texture_float"), s2 = y && _2, e2 = a2 ? t2.getParameter(36183) : 0;
    return { isWebGL2: a2, drawBuffers: l2, getMaxAnisotropy: function() {
      return n2 !== void 0 || (n2 = r2.has("EXT_texture_filter_anisotropic") === true ? (e3 = r2.get("EXT_texture_filter_anisotropic"), t2.getParameter(e3.MAX_TEXTURE_MAX_ANISOTROPY_EXT)) : 0), n2;
      var e3;
    }, getMaxPrecision: i2, precision: o2, logarithmicDepthBuffer: c2, maxTextures: u2, maxVertexTextures: h2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: y, floatFragmentTextures: _2, floatVertexTextures: s2, maxSamples: e2 };
  }
  function WebGLClipping(t2) {
    const s2 = this;
    let c2 = null, u2 = 0, h2 = false, d2 = false;
    const l2 = new Plane(), p2 = new Matrix3(), f2 = { value: null, needsUpdate: false };
    function m2() {
      f2.value !== c2 && (f2.value = c2, f2.needsUpdate = 0 < u2), s2.numPlanes = u2, s2.numIntersection = 0;
    }
    function g2(r2, e2, n2, t3) {
      var i2 = r2 !== null ? r2.length : 0;
      let a2 = null;
      if (i2 !== 0) {
        if (a2 = f2.value, t3 !== true || a2 === null) {
          var t3 = n2 + 4 * i2, o2 = e2.matrixWorldInverse;
          p2.getNormalMatrix(o2), (a2 === null || a2.length < t3) && (a2 = new Float32Array(t3));
          for (let e3 = 0, t4 = n2; e3 !== i2; ++e3, t4 += 4)
            l2.copy(r2[e3]).applyMatrix4(o2, p2), l2.normal.toArray(a2, t4), a2[t4 + 3] = l2.constant;
        }
        f2.value = a2, f2.needsUpdate = true;
      }
      return s2.numPlanes = i2, s2.numIntersection = 0, a2;
    }
    this.uniform = f2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e2, t3, r2) {
      var n2 = e2.length !== 0 || t3 || u2 !== 0 || h2;
      return h2 = t3, c2 = g2(e2, r2, 0), u2 = e2.length, n2;
    }, this.beginShadows = function() {
      d2 = true, g2(null);
    }, this.endShadows = function() {
      d2 = false, m2();
    }, this.setState = function(e2, r2, n2) {
      var i2 = e2.clippingPlanes, a2 = e2.clipIntersection, o2 = e2.clipShadows;
      const s3 = t2.get(e2);
      if (!h2 || i2 === null || i2.length === 0 || d2 && !o2)
        d2 ? g2(null) : m2();
      else {
        var o2 = d2 ? 0 : u2, l3 = 4 * o2;
        let t3 = s3.clippingState || null;
        f2.value = t3, t3 = g2(i2, r2, l3, n2);
        for (let e3 = 0; e3 !== l3; ++e3)
          t3[e3] = c2[e3];
        s3.clippingState = t3, this.numIntersection = a2 ? this.numPlanes : 0, this.numPlanes += o2;
      }
    };
  }
  function WebGLCubeMaps(i2) {
    let a2 = new WeakMap();
    function o2(e2, t2) {
      return t2 === EquirectangularReflectionMapping ? e2.mapping = CubeReflectionMapping : t2 === EquirectangularRefractionMapping && (e2.mapping = CubeRefractionMapping), e2;
    }
    function s2(e2) {
      const t2 = e2.target;
      t2.removeEventListener("dispose", s2);
      const r2 = a2.get(t2);
      r2 !== void 0 && (a2.delete(t2), r2.dispose());
    }
    return { get: function(e2) {
      if (e2 && e2.isTexture && e2.isRenderTargetTexture === false) {
        var t2 = e2.mapping;
        if (t2 === EquirectangularReflectionMapping || t2 === EquirectangularRefractionMapping) {
          if (a2.has(e2))
            return o2(a2.get(e2).texture, e2.mapping);
          var r2 = e2.image;
          if (r2 && 0 < r2.height) {
            t2 = i2.getRenderTarget();
            const n2 = new WebGLCubeRenderTarget(r2.height / 2);
            return n2.fromEquirectangularTexture(i2, e2), a2.set(e2, n2), i2.setRenderTarget(t2), e2.addEventListener("dispose", s2), o2(n2.texture, e2.mapping);
          }
          return null;
        }
      }
      return e2;
    }, dispose: function() {
      a2 = new WeakMap();
    } };
  }
  ShaderLib.physical = { uniforms: mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Vector2(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Color(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 0 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new Vector2() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Color(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularColor: { value: new Color(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag };
  class OrthographicCamera extends Camera {
    constructor(e2 = -1, t2 = 1, r2 = 1, n2 = -1, i2 = 0.1, a2 = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e2, this.right = t2, this.top = r2, this.bottom = n2, this.near = i2, this.far = a2, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.left = e2.left, this.right = e2.right, this.top = e2.top, this.bottom = e2.bottom, this.near = e2.near, this.far = e2.far, this.zoom = e2.zoom, this.view = e2.view === null ? null : Object.assign({}, e2.view), this;
    }
    setViewOffset(e2, t2, r2, n2, i2, a2) {
      this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = r2, this.view.offsetY = n2, this.view.width = i2, this.view.height = a2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      var e2 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), r2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
      let i2 = r2 - e2, a2 = r2 + e2, o2 = n2 + t2, s2 = n2 - t2;
      this.view !== null && this.view.enabled && (n2 = (this.right - this.left) / this.view.fullWidth / this.zoom, t2 = (this.top - this.bottom) / this.view.fullHeight / this.zoom, i2 += n2 * this.view.offsetX, a2 = i2 + n2 * this.view.width, o2 -= t2 * this.view.offsetY, s2 = o2 - t2 * this.view.height), this.projectionMatrix.makeOrthographic(i2, a2, o2, s2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, this.view !== null && (t2.object.view = Object.assign({}, this.view)), t2;
    }
  }
  OrthographicCamera.prototype.isOrthographicCamera = true;
  class RawShaderMaterial extends ShaderMaterial {
    constructor(e2) {
      super(e2), this.type = "RawShaderMaterial";
    }
  }
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  const LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow(2, LOD_MAX), EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = { [LinearEncoding]: 0, [sRGBEncoding]: 1, [RGBEEncoding]: 2, [RGBM7Encoding]: 3, [RGBM16Encoding]: 4, [RGBDEncoding]: 5, [GammaEncoding]: 6 }, _flatCamera = new OrthographicCamera(), { _lodPlanes, _sizeLods, _sigmas } = _createPlanes(), _clearColor = new Color();
  let _oldTarget = null;
  const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
  class PMREMGenerator {
    constructor(e2) {
      this._renderer = e2, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader(MAX_SAMPLES), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e2, t2 = 0, r2 = 0.1, n2 = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      var i2 = this._allocateTargets();
      return this._sceneToCubeUV(e2, r2, n2, i2), 0 < t2 && this._blur(i2, 0, 0, t2), this._applyPMREM(i2), this._cleanup(i2), i2;
    }
    fromEquirectangular(e2) {
      return this._fromTexture(e2);
    }
    fromCubemap(e2) {
      return this._fromTexture(e2);
    }
    compileCubemapShader() {
      this._cubemapShader === null && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader));
    }
    compileEquirectangularShader() {
      this._equirectShader === null && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader));
    }
    dispose() {
      this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
      for (let e2 = 0; e2 < _lodPlanes.length; e2++)
        _lodPlanes[e2].dispose();
    }
    _cleanup(e2) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_oldTarget), e2.scissorTest = false, _setViewport(e2, 0, 0, e2.width, e2.height);
    }
    _fromTexture(e2) {
      _oldTarget = this._renderer.getRenderTarget();
      var t2 = this._allocateTargets(e2);
      return this._textureToCubeUV(e2, t2), this._applyPMREM(t2), this._cleanup(t2), t2;
    }
    _allocateTargets(e2) {
      var t2 = { magFilter: NearestFilter, minFilter: NearestFilter, generateMipmaps: false, type: UnsignedByteType, format: RGBEFormat, encoding: _isLDR(e2) ? e2.encoding : RGBEEncoding, depthBuffer: false };
      const r2 = _createRenderTarget(t2);
      return r2.depthBuffer = !e2, this._pingPongRenderTarget = _createRenderTarget(t2), r2;
    }
    _compileMaterial(e2) {
      e2 = new Mesh(_lodPlanes[0], e2);
      this._renderer.compile(e2, _flatCamera);
    }
    _sceneToCubeUV(t2, e2, r2, n2) {
      const i2 = new PerspectiveCamera(90, 1, e2, r2);
      var a2 = [1, -1, 1, 1, 1, 1], o2 = [1, 1, 1, -1, -1, -1];
      const s2 = this._renderer;
      var l2 = s2.autoClear, c2 = s2.outputEncoding, e2 = s2.toneMapping;
      s2.getClearColor(_clearColor), s2.toneMapping = NoToneMapping, s2.outputEncoding = LinearEncoding, s2.autoClear = false;
      const u2 = new MeshBasicMaterial({ name: "PMREM.Background", side: BackSide, depthWrite: false, depthTest: false }), h2 = new Mesh(new BoxGeometry(), u2);
      let d2 = false;
      r2 = t2.background;
      r2 ? r2.isColor && (u2.color.copy(r2), t2.background = null, d2 = true) : (u2.color.copy(_clearColor), d2 = true);
      for (let e3 = 0; e3 < 6; e3++) {
        var p2 = e3 % 3;
        p2 == 0 ? (i2.up.set(0, a2[e3], 0), i2.lookAt(o2[e3], 0, 0)) : p2 == 1 ? (i2.up.set(0, 0, a2[e3]), i2.lookAt(0, o2[e3], 0)) : (i2.up.set(0, a2[e3], 0), i2.lookAt(0, 0, o2[e3])), _setViewport(n2, p2 * SIZE_MAX, 2 < e3 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX), s2.setRenderTarget(n2), d2 && s2.render(h2, i2), s2.render(t2, i2);
      }
      h2.geometry.dispose(), h2.material.dispose(), s2.toneMapping = e2, s2.outputEncoding = c2, s2.autoClear = l2, t2.background = r2;
    }
    _setEncoding(e2, t2) {
      this._renderer.capabilities.isWebGL2 === true && t2.format === RGBAFormat && t2.type === UnsignedByteType && t2.encoding === sRGBEncoding ? e2.value = ENCODINGS[LinearEncoding] : e2.value = ENCODINGS[t2.encoding];
    }
    _textureToCubeUV(e2, t2) {
      const r2 = this._renderer;
      var n2 = e2.mapping === CubeReflectionMapping || e2.mapping === CubeRefractionMapping;
      n2 ? this._cubemapShader == null && (this._cubemapShader = _getCubemapShader()) : this._equirectShader == null && (this._equirectShader = _getEquirectShader());
      var i2 = n2 ? this._cubemapShader : this._equirectShader, a2 = new Mesh(_lodPlanes[0], i2);
      const o2 = i2.uniforms;
      o2.envMap.value = e2, n2 || o2.texelSize.value.set(1 / e2.image.width, 1 / e2.image.height), this._setEncoding(o2.inputEncoding, e2), this._setEncoding(o2.outputEncoding, t2.texture), _setViewport(t2, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX), r2.setRenderTarget(t2), r2.render(a2, _flatCamera);
    }
    _applyPMREM(t2) {
      const e2 = this._renderer;
      var r2 = e2.autoClear;
      e2.autoClear = false;
      for (let e3 = 1; e3 < TOTAL_LODS; e3++) {
        var n2 = Math.sqrt(_sigmas[e3] * _sigmas[e3] - _sigmas[e3 - 1] * _sigmas[e3 - 1]), i2 = _axisDirections[(e3 - 1) % _axisDirections.length];
        this._blur(t2, e3 - 1, e3, n2, i2);
      }
      e2.autoClear = r2;
    }
    _blur(e2, t2, r2, n2, i2) {
      var a2 = this._pingPongRenderTarget;
      this._halfBlur(e2, a2, t2, r2, n2, "latitudinal", i2), this._halfBlur(a2, e2, r2, r2, n2, "longitudinal", i2);
    }
    _halfBlur(e2, t2, r2, n2, i2, a2, o2) {
      const s2 = this._renderer;
      var l2 = this._blurMaterial;
      a2 !== "latitudinal" && a2 !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      var c2 = new Mesh(_lodPlanes[n2], l2);
      const u2 = l2.uniforms;
      var l2 = _sizeLods[r2] - 1, l2 = isFinite(i2) ? Math.PI / (2 * l2) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), h2 = i2 / l2, d2 = isFinite(i2) ? 1 + Math.floor(3 * h2) : MAX_SAMPLES;
      d2 > MAX_SAMPLES && console.warn(`sigmaRadians, ${i2}, is too large and will clip, as it requested ${d2} samples when the maximum is set to ` + MAX_SAMPLES);
      const p2 = [];
      let f2 = 0;
      for (let e3 = 0; e3 < MAX_SAMPLES; ++e3) {
        const g3 = e3 / h2;
        var m2 = Math.exp(-g3 * g3 / 2);
        p2.push(m2), e3 == 0 ? f2 += m2 : e3 < d2 && (f2 += 2 * m2);
      }
      for (let e3 = 0; e3 < p2.length; e3++)
        p2[e3] = p2[e3] / f2;
      u2.envMap.value = e2.texture, u2.samples.value = d2, u2.weights.value = p2, u2.latitudinal.value = a2 === "latitudinal", o2 && (u2.poleAxis.value = o2), u2.dTheta.value = l2, u2.mipInt.value = LOD_MAX - r2, this._setEncoding(u2.inputEncoding, e2.texture), this._setEncoding(u2.outputEncoding, e2.texture);
      e2 = _sizeLods[n2];
      const g2 = 3 * Math.max(0, SIZE_MAX - 2 * e2);
      n2 = (n2 === 0 ? 0 : 2 * SIZE_MAX) + 2 * e2 * (n2 > LOD_MAX - LOD_MIN ? n2 - LOD_MAX + LOD_MIN : 0);
      _setViewport(t2, g2, n2, 3 * e2, 2 * e2), s2.setRenderTarget(t2), s2.render(c2, _flatCamera);
    }
  }
  function _isLDR(e2) {
    return e2 !== void 0 && e2.type === UnsignedByteType && (e2.encoding === LinearEncoding || e2.encoding === sRGBEncoding || e2.encoding === GammaEncoding);
  }
  function _createPlanes() {
    const r2 = [], n2 = [], i2 = [];
    let a2 = LOD_MAX;
    for (let t2 = 0; t2 < TOTAL_LODS; t2++) {
      var o2 = Math.pow(2, a2);
      n2.push(o2);
      let e2 = 1 / o2;
      t2 > LOD_MAX - LOD_MIN ? e2 = EXTRA_LOD_SIGMA[t2 - LOD_MAX + LOD_MIN - 1] : t2 == 0 && (e2 = 0), i2.push(e2);
      var s2 = 1 / (o2 - 1), o2 = -s2 / 2, s2 = 1 + s2 / 2, l2 = [o2, o2, s2, o2, s2, s2, o2, o2, s2, s2, o2, s2];
      const h2 = new Float32Array(108), d2 = new Float32Array(72), p2 = new Float32Array(36);
      for (let e3 = 0; e3 < 6; e3++) {
        var c2 = e3 % 3 * 2 / 3 - 1, u2 = 2 < e3 ? 0 : -1;
        h2.set([c2, u2, 0, c2 + 2 / 3, u2, 0, c2 + 2 / 3, 1 + u2, 0, c2, u2, 0, c2 + 2 / 3, 1 + u2, 0, c2, 1 + u2, 0], 18 * e3), d2.set(l2, 12 * e3);
        u2 = [e3, e3, e3, e3, e3, e3];
        p2.set(u2, 6 * e3);
      }
      const f2 = new BufferGeometry();
      f2.setAttribute("position", new BufferAttribute(h2, 3)), f2.setAttribute("uv", new BufferAttribute(d2, 2)), f2.setAttribute("faceIndex", new BufferAttribute(p2, 1)), r2.push(f2), a2 > LOD_MIN && a2--;
    }
    return { _lodPlanes: r2, _sizeLods: n2, _sigmas: i2 };
  }
  function _createRenderTarget(e2) {
    const t2 = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, e2);
    return t2.texture.mapping = CubeUVReflectionMapping, t2.texture.name = "PMREM.cubeUv", t2.scissorTest = true, t2;
  }
  function _setViewport(e2, t2, r2, n2, i2) {
    e2.viewport.set(t2, r2, n2, i2), e2.scissor.set(t2, r2, n2, i2);
  }
  function _getBlurShader(e2) {
    var t2 = new Float32Array(e2), r2 = new Vector3(0, 1, 0);
    return new RawShaderMaterial({ name: "SphericalGaussianBlur", defines: { n: e2 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t2 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r2 }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: NoBlending, depthTest: false, depthWrite: false });
  }
  function _getEquirectShader() {
    var e2 = new Vector2(1, 1);
    return new RawShaderMaterial({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: e2 }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: NoBlending, depthTest: false, depthWrite: false });
  }
  function _getCubemapShader() {
    return new RawShaderMaterial({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: NoBlending, depthTest: false, depthWrite: false });
  }
  function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function _getEncodings() {
    return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
  }
  function WebGLCubeUVMaps(i2) {
    let a2 = new WeakMap(), o2 = null;
    function s2(e2) {
      const t2 = e2.target;
      t2.removeEventListener("dispose", s2);
      const r2 = a2.get(t2);
      r2 !== void 0 && (a2.delete(t2), r2.dispose());
    }
    return { get: function(e2) {
      if (e2 && e2.isTexture && e2.isRenderTargetTexture === false) {
        var t2 = e2.mapping, r2 = t2 === EquirectangularReflectionMapping || t2 === EquirectangularRefractionMapping, n2 = t2 === CubeReflectionMapping || t2 === CubeRefractionMapping;
        if (r2 || n2) {
          if (a2.has(e2))
            return a2.get(e2).texture;
          t2 = e2.image;
          if (r2 && t2 && 0 < t2.height || n2 && t2 && function(t3) {
            let r3 = 0;
            for (let e3 = 0; e3 < 6; e3++)
              t3[e3] !== void 0 && r3++;
            return r3 === 6;
          }(t2)) {
            t2 = i2.getRenderTarget();
            o2 === null && (o2 = new PMREMGenerator(i2));
            r2 = r2 ? o2.fromEquirectangular(e2) : o2.fromCubemap(e2);
            return a2.set(e2, r2), i2.setRenderTarget(t2), e2.addEventListener("dispose", s2), r2.texture;
          }
          return null;
        }
      }
      return e2;
    }, dispose: function() {
      a2 = new WeakMap(), o2 !== null && (o2.dispose(), o2 = null);
    } };
  }
  function WebGLExtensions(r2) {
    const n2 = {};
    function i2(e2) {
      if (n2[e2] !== void 0)
        return n2[e2];
      let t2;
      switch (e2) {
        case "WEBGL_depth_texture":
          t2 = r2.getExtension("WEBGL_depth_texture") || r2.getExtension("MOZ_WEBGL_depth_texture") || r2.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          t2 = r2.getExtension("EXT_texture_filter_anisotropic") || r2.getExtension("MOZ_EXT_texture_filter_anisotropic") || r2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          t2 = r2.getExtension("WEBGL_compressed_texture_s3tc") || r2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          t2 = r2.getExtension("WEBGL_compressed_texture_pvrtc") || r2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          t2 = r2.getExtension(e2);
      }
      return n2[e2] = t2, t2;
    }
    return { has: function(e2) {
      return i2(e2) !== null;
    }, init: function(e2) {
      e2.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float");
    }, get: function(e2) {
      var t2 = i2(e2);
      return t2 === null && console.warn("THREE.WebGLRenderer: " + e2 + " extension not supported."), t2;
    } };
  }
  function WebGLGeometries(e2, f2, n2, i2) {
    const a2 = {}, m2 = new WeakMap();
    function o2(e3) {
      const t2 = e3.target;
      t2.index !== null && f2.remove(t2.index);
      for (const r2 in t2.attributes)
        f2.remove(t2.attributes[r2]);
      t2.removeEventListener("dispose", o2), delete a2[t2.id];
      e3 = m2.get(t2);
      e3 && (f2.remove(e3), m2.delete(t2)), i2.releaseStatesOfGeometry(t2), t2.isInstancedBufferGeometry === true && delete t2._maxInstanceCount, n2.memory.geometries--;
    }
    function s2(e3) {
      const r2 = [];
      var t2 = e3.index, n3 = e3.attributes.position;
      let i3 = 0;
      if (t2 !== null) {
        var a3 = t2.array;
        i3 = t2.version;
        for (let e4 = 0, t3 = a3.length; e4 < t3; e4 += 3) {
          var o3 = a3[e4 + 0], s3 = a3[e4 + 1], l2 = a3[e4 + 2];
          r2.push(o3, s3, s3, l2, l2, o3);
        }
      } else {
        var c2 = n3.array;
        i3 = n3.version;
        for (let e4 = 0, t3 = c2.length / 3 - 1; e4 < t3; e4 += 3) {
          var u2 = e4 + 0, h2 = e4 + 1, d2 = e4 + 2;
          r2.push(u2, h2, h2, d2, d2, u2);
        }
      }
      const p2 = new (65535 < arrayMax(r2) ? Uint32BufferAttribute : Uint16BufferAttribute)(r2, 1);
      p2.version = i3;
      c2 = m2.get(e3);
      c2 && f2.remove(c2), m2.set(e3, p2);
    }
    return { get: function(e3, t2) {
      return a2[t2.id] === true || (t2.addEventListener("dispose", o2), a2[t2.id] = true, n2.memory.geometries++), t2;
    }, update: function(e3) {
      var t2 = e3.attributes;
      for (const i3 in t2)
        f2.update(t2[i3], 34962);
      var r2 = e3.morphAttributes;
      for (const a3 in r2) {
        var n3 = r2[a3];
        for (let e4 = 0, t3 = n3.length; e4 < t3; e4++)
          f2.update(n3[e4], 34962);
      }
    }, getWireframeAttribute: function(e3) {
      var t2, r2 = m2.get(e3);
      return (!r2 || (t2 = e3.index) !== null && r2.version < t2.version) && s2(e3), m2.get(e3);
    } };
  }
  function WebGLIndexedBufferRenderer(a2, o2, s2, e2) {
    const l2 = e2.isWebGL2;
    let c2;
    let u2, h2;
    this.setMode = function(e3) {
      c2 = e3;
    }, this.setIndex = function(e3) {
      u2 = e3.type, h2 = e3.bytesPerElement;
    }, this.render = function(e3, t2) {
      a2.drawElements(c2, t2, u2, e3 * h2), s2.update(t2, c2, 1);
    }, this.renderInstances = function(r2, n2, i2) {
      if (i2 !== 0) {
        let e3, t2;
        if (l2)
          e3 = a2, t2 = "drawElementsInstanced";
        else if (e3 = o2.get("ANGLE_instanced_arrays"), t2 = "drawElementsInstancedANGLE", e3 === null)
          return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        e3[t2](c2, n2, u2, r2 * h2, i2), s2.update(n2, c2, i2);
      }
    };
  }
  function WebGLInfo(e2) {
    const n2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: n2, programs: null, autoReset: true, reset: function() {
      n2.frame++, n2.calls = 0, n2.triangles = 0, n2.points = 0, n2.lines = 0;
    }, update: function(e3, t2, r2) {
      switch (n2.calls++, t2) {
        case 4:
          n2.triangles += r2 * (e3 / 3);
          break;
        case 1:
          n2.lines += r2 * (e3 / 2);
          break;
        case 3:
          n2.lines += r2 * (e3 - 1);
          break;
        case 2:
          n2.lines += r2 * e3;
          break;
        case 0:
          n2.points += r2 * e3;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", t2);
      }
    } };
  }
  class DataTexture2DArray extends Texture {
    constructor(e2 = null, t2 = 1, r2 = 1, n2 = 1) {
      super(null), this.image = { data: e2, width: t2, height: r2, depth: n2 }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  function numericalSort(e2, t2) {
    return e2[0] - t2[0];
  }
  function absNumericalSort(e2, t2) {
    return Math.abs(t2[1]) - Math.abs(e2[1]);
  }
  function denormalize(e2, t2) {
    let r2 = 1;
    t2 = (t2.isInterleavedBufferAttribute ? t2.data : t2).array;
    t2 instanceof Int8Array ? r2 = 127 : t2 instanceof Int16Array ? r2 = 32767 : t2 instanceof Int32Array ? r2 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", t2), e2.divideScalar(r2);
  }
  function WebGLMorphtargets(M2, E2, r2) {
    const T2 = {}, k2 = new Float32Array(8), A2 = new WeakMap(), C2 = new Vector3(), $2 = [];
    for (let e2 = 0; e2 < 8; e2++)
      $2[e2] = [e2, 0];
    return { update: function(e2, n2, t2, i2) {
      var a2 = e2.morphTargetInfluences;
      if (E2.isWebGL2 === true) {
        var o2 = n2.morphAttributes.position.length;
        let e3 = A2.get(n2);
        if (e3 === void 0 || e3.count !== o2) {
          e3 !== void 0 && e3.texture.dispose();
          var s2 = n2.morphAttributes.normal !== void 0, l2 = n2.morphAttributes.position, c2 = n2.morphAttributes.normal || [], u2 = s2 == true ? 2 : 1;
          let t4 = n2.attributes.position.count * u2, r3 = 1;
          t4 > E2.maxTextureSize && (r3 = Math.ceil(t4 / E2.maxTextureSize), t4 = E2.maxTextureSize);
          const x2 = new Float32Array(t4 * r3 * 4 * o2), w2 = new DataTexture2DArray(x2, t4, r3, o2);
          w2.format = RGBAFormat, w2.type = FloatType;
          var h2 = 4 * u2;
          for (let e4 = 0; e4 < o2; e4++) {
            var d2 = l2[e4], p2 = c2[e4], f2 = t4 * r3 * 4 * e4;
            for (let e5 = 0; e5 < d2.count; e5++) {
              C2.fromBufferAttribute(d2, e5), d2.normalized === true && denormalize(C2, d2);
              var m2 = e5 * h2;
              x2[f2 + m2] = C2.x, x2[f2 + m2 + 1] = C2.y, x2[f2 + m2 + 2] = C2.z, !(x2[f2 + m2 + 3] = 0) == s2 && (C2.fromBufferAttribute(p2, e5), p2.normalized === true && denormalize(C2, p2), x2[f2 + m2 + 4] = C2.x, x2[f2 + m2 + 5] = C2.y, x2[f2 + m2 + 6] = C2.z, x2[f2 + m2 + 7] = 0);
            }
          }
          e3 = { count: o2, texture: w2, size: new Vector2(t4, r3) }, A2.set(n2, e3);
        }
        let t3 = 0;
        for (let e4 = 0; e4 < a2.length; e4++)
          t3 += a2[e4];
        u2 = n2.morphTargetsRelative ? 1 : 1 - t3;
        i2.getUniforms().setValue(M2, "morphTargetBaseInfluence", u2), i2.getUniforms().setValue(M2, "morphTargetInfluences", a2), i2.getUniforms().setValue(M2, "morphTargetsTexture", e3.texture, r2), i2.getUniforms().setValue(M2, "morphTargetsTextureSize", e3.size);
      } else {
        var g2 = a2 === void 0 ? 0 : a2.length;
        let t3 = T2[n2.id];
        if (t3 === void 0 || t3.length !== g2) {
          t3 = [];
          for (let e3 = 0; e3 < g2; e3++)
            t3[e3] = [e3, 0];
          T2[n2.id] = t3;
        }
        for (let e3 = 0; e3 < g2; e3++) {
          const S2 = t3[e3];
          S2[0] = e3, S2[1] = a2[e3];
        }
        t3.sort(absNumericalSort);
        for (let e3 = 0; e3 < 8; e3++)
          e3 < g2 && t3[e3][1] ? ($2[e3][0] = t3[e3][0], $2[e3][1] = t3[e3][1]) : ($2[e3][0] = Number.MAX_SAFE_INTEGER, $2[e3][1] = 0);
        $2.sort(numericalSort);
        var v2 = n2.morphAttributes.position, y = n2.morphAttributes.normal;
        let r3 = 0;
        for (let e3 = 0; e3 < 8; e3++) {
          var _2 = $2[e3], b2 = _2[0], _2 = _2[1];
          b2 !== Number.MAX_SAFE_INTEGER && _2 ? (v2 && n2.getAttribute("morphTarget" + e3) !== v2[b2] && n2.setAttribute("morphTarget" + e3, v2[b2]), y && n2.getAttribute("morphNormal" + e3) !== y[b2] && n2.setAttribute("morphNormal" + e3, y[b2]), k2[e3] = _2, r3 += _2) : (v2 && n2.hasAttribute("morphTarget" + e3) === true && n2.deleteAttribute("morphTarget" + e3), y && n2.hasAttribute("morphNormal" + e3) === true && n2.deleteAttribute("morphNormal" + e3), k2[e3] = 0);
        }
        u2 = n2.morphTargetsRelative ? 1 : 1 - r3;
        i2.getUniforms().setValue(M2, "morphTargetBaseInfluence", u2), i2.getUniforms().setValue(M2, "morphTargetInfluences", k2);
      }
    } };
  }
  function WebGLObjects(e2, n2, i2, a2) {
    let o2 = new WeakMap();
    function s2(e3) {
      const t2 = e3.target;
      t2.removeEventListener("dispose", s2), i2.remove(t2.instanceMatrix), t2.instanceColor !== null && i2.remove(t2.instanceColor);
    }
    return { update: function(e3) {
      var t2 = a2.render.frame, r2 = e3.geometry, r2 = n2.get(e3, r2);
      return o2.get(r2) !== t2 && (n2.update(r2), o2.set(r2, t2)), e3.isInstancedMesh && (e3.hasEventListener("dispose", s2) === false && e3.addEventListener("dispose", s2), i2.update(e3.instanceMatrix, 34962), e3.instanceColor !== null && i2.update(e3.instanceColor, 34962)), r2;
    }, dispose: function() {
      o2 = new WeakMap();
    } };
  }
  DataTexture2DArray.prototype.isDataTexture2DArray = true;
  class DataTexture3D extends Texture {
    constructor(e2 = null, t2 = 1, r2 = 1, n2 = 1) {
      super(null), this.image = { data: e2, width: t2, height: r2, depth: n2 }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  DataTexture3D.prototype.isDataTexture3D = true;
  const emptyTexture = new Texture(), emptyTexture2dArray = new DataTexture2DArray(), emptyTexture3d = new DataTexture3D(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4);
  function flatten$1(r2, n2, i2) {
    const e2 = r2[0];
    if (e2 <= 0 || 0 < e2)
      return r2;
    var t2 = n2 * i2;
    let a2 = arrayCacheF32[t2];
    if (a2 === void 0 && (a2 = new Float32Array(t2), arrayCacheF32[t2] = a2), n2 !== 0) {
      e2.toArray(a2, 0);
      for (let e3 = 1, t3 = 0; e3 !== n2; ++e3)
        t3 += i2, r2[e3].toArray(a2, t3);
    }
    return a2;
  }
  function arraysEqual(r2, n2) {
    if (r2.length === n2.length) {
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++)
        if (r2[e2] !== n2[e2])
          return;
      return 1;
    }
  }
  function copyArray(r2, n2) {
    for (let e2 = 0, t2 = n2.length; e2 < t2; e2++)
      r2[e2] = n2[e2];
  }
  function allocTexUnits(t2, r2) {
    let n2 = arrayCacheI32[r2];
    n2 === void 0 && (n2 = new Int32Array(r2), arrayCacheI32[r2] = n2);
    for (let e2 = 0; e2 !== r2; ++e2)
      n2[e2] = t2.allocateTextureUnit();
    return n2;
  }
  function setValueV1f(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1f(this.addr, t2), r2[0] = t2);
  }
  function setValueV2f(e2, t2) {
    const r2 = this.cache;
    t2.x !== void 0 ? r2[0] === t2.x && r2[1] === t2.y || (e2.uniform2f(this.addr, t2.x, t2.y), r2[0] = t2.x, r2[1] = t2.y) : arraysEqual(r2, t2) || (e2.uniform2fv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV3f(e2, t2) {
    const r2 = this.cache;
    t2.x !== void 0 ? r2[0] === t2.x && r2[1] === t2.y && r2[2] === t2.z || (e2.uniform3f(this.addr, t2.x, t2.y, t2.z), r2[0] = t2.x, r2[1] = t2.y, r2[2] = t2.z) : t2.r !== void 0 ? r2[0] === t2.r && r2[1] === t2.g && r2[2] === t2.b || (e2.uniform3f(this.addr, t2.r, t2.g, t2.b), r2[0] = t2.r, r2[1] = t2.g, r2[2] = t2.b) : arraysEqual(r2, t2) || (e2.uniform3fv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV4f(e2, t2) {
    const r2 = this.cache;
    t2.x !== void 0 ? r2[0] === t2.x && r2[1] === t2.y && r2[2] === t2.z && r2[3] === t2.w || (e2.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), r2[0] = t2.x, r2[1] = t2.y, r2[2] = t2.z, r2[3] = t2.w) : arraysEqual(r2, t2) || (e2.uniform4fv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueM2(e2, t2) {
    var r2 = this.cache, n2 = t2.elements;
    n2 === void 0 ? arraysEqual(r2, t2) || (e2.uniformMatrix2fv(this.addr, false, t2), copyArray(r2, t2)) : arraysEqual(r2, n2) || (mat2array.set(n2), e2.uniformMatrix2fv(this.addr, false, mat2array), copyArray(r2, n2));
  }
  function setValueM3(e2, t2) {
    var r2 = this.cache, n2 = t2.elements;
    n2 === void 0 ? arraysEqual(r2, t2) || (e2.uniformMatrix3fv(this.addr, false, t2), copyArray(r2, t2)) : arraysEqual(r2, n2) || (mat3array.set(n2), e2.uniformMatrix3fv(this.addr, false, mat3array), copyArray(r2, n2));
  }
  function setValueM4(e2, t2) {
    var r2 = this.cache, n2 = t2.elements;
    n2 === void 0 ? arraysEqual(r2, t2) || (e2.uniformMatrix4fv(this.addr, false, t2), copyArray(r2, t2)) : arraysEqual(r2, n2) || (mat4array.set(n2), e2.uniformMatrix4fv(this.addr, false, mat4array), copyArray(r2, n2));
  }
  function setValueV1i(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1i(this.addr, t2), r2[0] = t2);
  }
  function setValueV2i(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform2iv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV3i(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform3iv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV4i(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform4iv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV1ui(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1ui(this.addr, t2), r2[0] = t2);
  }
  function setValueV2ui(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform2uiv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV3ui(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform3uiv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueV4ui(e2, t2) {
    var r2 = this.cache;
    arraysEqual(r2, t2) || (e2.uniform4uiv(this.addr, t2), copyArray(r2, t2));
  }
  function setValueT1(e2, t2, r2) {
    const n2 = this.cache;
    var i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.safeSetTexture2D(t2 || emptyTexture, i2);
  }
  function setValueT3D1(e2, t2, r2) {
    const n2 = this.cache;
    var i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTexture3D(t2 || emptyTexture3d, i2);
  }
  function setValueT6(e2, t2, r2) {
    const n2 = this.cache;
    var i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.safeSetTextureCube(t2 || emptyCubeTexture, i2);
  }
  function setValueT2DArray1(e2, t2, r2) {
    const n2 = this.cache;
    var i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTexture2DArray(t2 || emptyTexture2dArray, i2);
  }
  function getSingularSetter(e2) {
    switch (e2) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(e2, t2) {
    e2.uniform1fv(this.addr, t2);
  }
  function setValueV2fArray(e2, t2) {
    t2 = flatten$1(t2, this.size, 2);
    e2.uniform2fv(this.addr, t2);
  }
  function setValueV3fArray(e2, t2) {
    t2 = flatten$1(t2, this.size, 3);
    e2.uniform3fv(this.addr, t2);
  }
  function setValueV4fArray(e2, t2) {
    t2 = flatten$1(t2, this.size, 4);
    e2.uniform4fv(this.addr, t2);
  }
  function setValueM2Array(e2, t2) {
    t2 = flatten$1(t2, this.size, 4);
    e2.uniformMatrix2fv(this.addr, false, t2);
  }
  function setValueM3Array(e2, t2) {
    t2 = flatten$1(t2, this.size, 9);
    e2.uniformMatrix3fv(this.addr, false, t2);
  }
  function setValueM4Array(e2, t2) {
    t2 = flatten$1(t2, this.size, 16);
    e2.uniformMatrix4fv(this.addr, false, t2);
  }
  function setValueV1iArray(e2, t2) {
    e2.uniform1iv(this.addr, t2);
  }
  function setValueV2iArray(e2, t2) {
    e2.uniform2iv(this.addr, t2);
  }
  function setValueV3iArray(e2, t2) {
    e2.uniform3iv(this.addr, t2);
  }
  function setValueV4iArray(e2, t2) {
    e2.uniform4iv(this.addr, t2);
  }
  function setValueV1uiArray(e2, t2) {
    e2.uniform1uiv(this.addr, t2);
  }
  function setValueV2uiArray(e2, t2) {
    e2.uniform2uiv(this.addr, t2);
  }
  function setValueV3uiArray(e2, t2) {
    e2.uniform3uiv(this.addr, t2);
  }
  function setValueV4uiArray(e2, t2) {
    e2.uniform4uiv(this.addr, t2);
  }
  function setValueT1Array(e2, t2, r2) {
    var n2 = t2.length, i2 = allocTexUnits(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.safeSetTexture2D(t2[e3] || emptyTexture, i2[e3]);
  }
  function setValueT6Array(e2, t2, r2) {
    var n2 = t2.length, i2 = allocTexUnits(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.safeSetTextureCube(t2[e3] || emptyCubeTexture, i2[e3]);
  }
  function getPureArraySetter(e2) {
    switch (e2) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
    }
  }
  function SingleUniform(e2, t2, r2) {
    this.id = e2, this.addr = r2, this.cache = [], this.setValue = getSingularSetter(t2.type);
  }
  function PureArrayUniform(e2, t2, r2) {
    this.id = e2, this.addr = r2, this.cache = [], this.size = t2.size, this.setValue = getPureArraySetter(t2.type);
  }
  function StructuredUniform(e2) {
    this.id = e2, this.seq = [], this.map = {};
  }
  PureArrayUniform.prototype.updateCache = function(e2) {
    var t2 = this.cache;
    e2 instanceof Float32Array && t2.length !== e2.length && (this.cache = new Float32Array(e2.length)), copyArray(t2, e2);
  }, StructuredUniform.prototype.setValue = function(r2, n2, i2) {
    var a2 = this.seq;
    for (let e2 = 0, t2 = a2.length; e2 !== t2; ++e2) {
      const o2 = a2[e2];
      o2.setValue(r2, n2[o2.id], i2);
    }
  };
  const RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(e2, t2) {
    e2.seq.push(t2), e2.map[t2.id] = t2;
  }
  function parseUniform(e2, r2, n2) {
    var i2 = e2.name, a2 = i2.length;
    for (RePathPart.lastIndex = 0; ; ) {
      var o2 = RePathPart.exec(i2), s2 = RePathPart.lastIndex;
      let t2 = o2[1];
      var l2 = o2[2] === "]", o2 = o2[3];
      if (l2 && (t2 |= 0), o2 === void 0 || o2 === "[" && s2 + 2 === a2) {
        addUniform(n2, new (o2 === void 0 ? SingleUniform : PureArrayUniform)(t2, e2, r2));
        break;
      }
      {
        let e3 = n2.map[t2];
        e3 === void 0 && (e3 = new StructuredUniform(t2), addUniform(n2, e3)), n2 = e3;
      }
    }
  }
  function WebGLUniforms(t2, r2) {
    this.seq = [], this.map = {};
    var n2 = t2.getProgramParameter(r2, 35718);
    for (let e2 = 0; e2 < n2; ++e2) {
      var i2 = t2.getActiveUniform(r2, e2);
      parseUniform(i2, t2.getUniformLocation(r2, i2.name), this);
    }
  }
  function WebGLShader(e2, t2, r2) {
    t2 = e2.createShader(t2);
    return e2.shaderSource(t2, r2), e2.compileShader(t2), t2;
  }
  WebGLUniforms.prototype.setValue = function(e2, t2, r2, n2) {
    const i2 = this.map[t2];
    i2 !== void 0 && i2.setValue(e2, r2, n2);
  }, WebGLUniforms.prototype.setOptional = function(e2, t2, r2) {
    t2 = t2[r2];
    t2 !== void 0 && this.setValue(e2, r2, t2);
  }, WebGLUniforms.upload = function(r2, n2, i2, a2) {
    for (let e2 = 0, t2 = n2.length; e2 !== t2; ++e2) {
      const o2 = n2[e2], s2 = i2[o2.id];
      s2.needsUpdate !== false && o2.setValue(r2, s2.value, a2);
    }
  }, WebGLUniforms.seqWithValue = function(r2, n2) {
    const i2 = [];
    for (let e2 = 0, t2 = r2.length; e2 !== t2; ++e2) {
      var a2 = r2[e2];
      a2.id in n2 && i2.push(a2);
    }
    return i2;
  };
  let programIdCount = 0;
  function addLineNumbers(e2) {
    const t2 = e2.split("\n");
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3] = e3 + 1 + ": " + t2[e3];
    return t2.join("\n");
  }
  function getEncodingComponents(e2) {
    switch (e2) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case LogLuvEncoding:
        return ["LogLuv", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e2), ["Linear", "( value )"];
    }
  }
  function getShaderErrors(e2, t2, r2) {
    var n2 = e2.getShaderParameter(t2, 35713), i2 = e2.getShaderInfoLog(t2).trim();
    return n2 && i2 === "" ? "" : r2.toUpperCase() + "\n\n" + i2 + "\n\n" + addLineNumbers(e2.getShaderSource(t2));
  }
  function getTexelDecodingFunction(e2, t2) {
    t2 = getEncodingComponents(t2);
    return "vec4 " + e2 + "( vec4 value ) { return " + t2[0] + "ToLinear" + t2[1] + "; }";
  }
  function getTexelEncodingFunction(e2, t2) {
    t2 = getEncodingComponents(t2);
    return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + t2[0] + t2[1] + "; }";
  }
  function getToneMappingFunction(e2, t2) {
    let r2;
    switch (t2) {
      case LinearToneMapping:
        r2 = "Linear";
        break;
      case ReinhardToneMapping:
        r2 = "Reinhard";
        break;
      case CineonToneMapping:
        r2 = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        r2 = "ACESFilmic";
        break;
      case CustomToneMapping:
        r2 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), r2 = "Linear";
    }
    return "vec3 " + e2 + "( vec3 color ) { return " + r2 + "ToneMapping( color ); }";
  }
  function generateExtensions(e2) {
    const t2 = [e2.extensionDerivatives || e2.envMapCubeUV || e2.bumpMap || e2.tangentSpaceNormalMap || e2.clearcoatNormalMap || e2.flatShading || e2.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (e2.extensionFragDepth || e2.logarithmicDepthBuffer) && e2.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e2.extensionDrawBuffers && e2.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e2.extensionShaderTextureLOD || e2.envMap || e2.transmission) && e2.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
    return t2.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(e2) {
    const t2 = [];
    for (const n2 in e2) {
      var r2 = e2[n2];
      r2 !== false && t2.push("#define " + n2 + " " + r2);
    }
    return t2.join("\n");
  }
  function fetchAttributeLocations(r2, n2) {
    const i2 = {};
    var e2 = r2.getProgramParameter(n2, 35721);
    for (let t2 = 0; t2 < e2; t2++) {
      var a2 = r2.getActiveAttrib(n2, t2), o2 = a2.name;
      let e3 = 1;
      a2.type === 35674 && (e3 = 2), a2.type === 35675 && (e3 = 3), a2.type === 35676 && (e3 = 4), i2[o2] = { type: a2.type, location: r2.getAttribLocation(n2, o2), locationSize: e3 };
    }
    return i2;
  }
  function filterEmptyLine(e2) {
    return e2 !== "";
  }
  function replaceLightNums(e2, t2) {
    return e2.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
  }
  function replaceClippingPlaneNums(e2, t2) {
    return e2.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
  }
  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(e2) {
    return e2.replace(includePattern, includeReplacer);
  }
  function includeReplacer(e2, t2) {
    var r2 = ShaderChunk[t2];
    if (r2 === void 0)
      throw new Error("Can not resolve #include <" + t2 + ">");
    return resolveIncludes(r2);
  }
  const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(e2) {
    return e2.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(e2, t2, r2, n2) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), loopReplacer(e2, t2, r2, n2);
  }
  function loopReplacer(e2, t2, r2, n2) {
    let i2 = "";
    for (let e3 = parseInt(t2); e3 < parseInt(r2); e3++)
      i2 += n2.replace(/\[\s*i\s*\]/g, "[ " + e3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, e3);
    return i2;
  }
  function generatePrecision(e2) {
    let t2 = "precision " + e2.precision + " float;\nprecision " + e2.precision + " int;";
    return e2.precision === "highp" ? t2 += "\n#define HIGH_PRECISION" : e2.precision === "mediump" ? t2 += "\n#define MEDIUM_PRECISION" : e2.precision === "lowp" && (t2 += "\n#define LOW_PRECISION"), t2;
  }
  function generateShadowMapTypeDefine(e2) {
    let t2 = "SHADOWMAP_TYPE_BASIC";
    return e2.shadowMapType === PCFShadowMap ? t2 = "SHADOWMAP_TYPE_PCF" : e2.shadowMapType === PCFSoftShadowMap ? t2 = "SHADOWMAP_TYPE_PCF_SOFT" : e2.shadowMapType === VSMShadowMap && (t2 = "SHADOWMAP_TYPE_VSM"), t2;
  }
  function generateEnvMapTypeDefine(e2) {
    let t2 = "ENVMAP_TYPE_CUBE";
    if (e2.envMap)
      switch (e2.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          t2 = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          t2 = "ENVMAP_TYPE_CUBE_UV";
      }
    return t2;
  }
  function generateEnvMapModeDefine(e2) {
    let t2 = "ENVMAP_MODE_REFLECTION";
    if (e2.envMap)
      switch (e2.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
          t2 = "ENVMAP_MODE_REFRACTION";
      }
    return t2;
  }
  function generateEnvMapBlendingDefine(e2) {
    let t2 = "ENVMAP_BLENDING_NONE";
    if (e2.envMap)
      switch (e2.combine) {
        case MultiplyOperation:
          t2 = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          t2 = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          t2 = "ENVMAP_BLENDING_ADD";
      }
    return t2;
  }
  function WebGLProgram(r2, e2, t2, n2) {
    const i2 = r2.getContext();
    var a2 = t2.defines, o2 = t2.vertexShader, s2 = t2.fragmentShader, l2 = generateShadowMapTypeDefine(t2), c2 = generateEnvMapTypeDefine(t2), u2 = generateEnvMapModeDefine(t2), h2 = generateEnvMapBlendingDefine(t2), d2 = 0 < r2.gammaFactor ? r2.gammaFactor : 1;
    const p2 = t2.isWebGL2 ? "" : generateExtensions(t2), f2 = generateDefines(a2), m2 = i2.createProgram();
    let g2, v2, y = t2.glslVersion ? "#version " + t2.glslVersion + "\n" : "";
    t2.isRawShaderMaterial ? (g2 = [f2].filter(filterEmptyLine).join("\n"), 0 < g2.length && (g2 += "\n"), v2 = [p2, f2].filter(filterEmptyLine).join("\n"), 0 < v2.length && (v2 += "\n")) : (g2 = [generatePrecision(t2), "#define SHADER_NAME " + t2.shaderName, f2, t2.instancing ? "#define USE_INSTANCING" : "", t2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d2, "#define MAX_BONES " + t2.maxBones, t2.useFog && t2.fog ? "#define USE_FOG" : "", t2.useFog && t2.fogExp2 ? "#define FOG_EXP2" : "", t2.map ? "#define USE_MAP" : "", t2.envMap ? "#define USE_ENVMAP" : "", t2.envMap ? "#define " + u2 : "", t2.lightMap ? "#define USE_LIGHTMAP" : "", t2.aoMap ? "#define USE_AOMAP" : "", t2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t2.bumpMap ? "#define USE_BUMPMAP" : "", t2.normalMap ? "#define USE_NORMALMAP" : "", t2.normalMap && t2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t2.normalMap && t2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t2.displacementMap && t2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t2.specularMap ? "#define USE_SPECULARMAP" : "", t2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t2.metalnessMap ? "#define USE_METALNESSMAP" : "", t2.alphaMap ? "#define USE_ALPHAMAP" : "", t2.transmission ? "#define USE_TRANSMISSION" : "", t2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t2.thicknessMap ? "#define USE_THICKNESSMAP" : "", t2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t2.vertexTangents ? "#define USE_TANGENT" : "", t2.vertexColors ? "#define USE_COLOR" : "", t2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t2.vertexUvs ? "#define USE_UV" : "", t2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t2.flatShading ? "#define FLAT_SHADED" : "", t2.skinning ? "#define USE_SKINNING" : "", t2.useVertexTexture ? "#define BONE_TEXTURE" : "", t2.morphTargets ? "#define USE_MORPHTARGETS" : "", t2.morphNormals && t2.flatShading === false ? "#define USE_MORPHNORMALS" : "", t2.morphTargets && t2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t2.morphTargets && t2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t2.morphTargetsCount : "", t2.doubleSided ? "#define DOUBLE_SIDED" : "", t2.flipSided ? "#define FLIP_SIDED" : "", t2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t2.shadowMapEnabled ? "#define " + l2 : "", t2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t2.logarithmicDepthBuffer && t2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"), v2 = [p2, generatePrecision(t2), "#define SHADER_NAME " + t2.shaderName, f2, "#define GAMMA_FACTOR " + d2, t2.useFog && t2.fog ? "#define USE_FOG" : "", t2.useFog && t2.fogExp2 ? "#define FOG_EXP2" : "", t2.map ? "#define USE_MAP" : "", t2.matcap ? "#define USE_MATCAP" : "", t2.envMap ? "#define USE_ENVMAP" : "", t2.envMap ? "#define " + c2 : "", t2.envMap ? "#define " + u2 : "", t2.envMap ? "#define " + h2 : "", t2.lightMap ? "#define USE_LIGHTMAP" : "", t2.aoMap ? "#define USE_AOMAP" : "", t2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t2.bumpMap ? "#define USE_BUMPMAP" : "", t2.normalMap ? "#define USE_NORMALMAP" : "", t2.normalMap && t2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t2.normalMap && t2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t2.clearcoat ? "#define USE_CLEARCOAT" : "", t2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t2.specularMap ? "#define USE_SPECULARMAP" : "", t2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t2.metalnessMap ? "#define USE_METALNESSMAP" : "", t2.alphaMap ? "#define USE_ALPHAMAP" : "", t2.alphaTest ? "#define USE_ALPHATEST" : "", t2.sheen ? "#define USE_SHEEN" : "", t2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t2.transmission ? "#define USE_TRANSMISSION" : "", t2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t2.thicknessMap ? "#define USE_THICKNESSMAP" : "", t2.vertexTangents ? "#define USE_TANGENT" : "", t2.vertexColors || t2.instancingColor ? "#define USE_COLOR" : "", t2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t2.vertexUvs ? "#define USE_UV" : "", t2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t2.gradientMap ? "#define USE_GRADIENTMAP" : "", t2.flatShading ? "#define FLAT_SHADED" : "", t2.doubleSided ? "#define DOUBLE_SIDED" : "", t2.flipSided ? "#define FLIP_SIDED" : "", t2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t2.shadowMapEnabled ? "#define " + l2 : "", t2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t2.logarithmicDepthBuffer && t2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (t2.extensionShaderTextureLOD || t2.envMap) && t2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t2.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", t2.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", t2.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", t2.toneMapping) : "", t2.dithering ? "#define DITHERING" : "", t2.format === RGBFormat ? "#define OPAQUE" : "", ShaderChunk.encodings_pars_fragment, t2.map ? getTexelDecodingFunction("mapTexelToLinear", t2.mapEncoding) : "", t2.matcap ? getTexelDecodingFunction("matcapTexelToLinear", t2.matcapEncoding) : "", t2.envMap ? getTexelDecodingFunction("envMapTexelToLinear", t2.envMapEncoding) : "", t2.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", t2.emissiveMapEncoding) : "", t2.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", t2.specularColorMapEncoding) : "", t2.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", t2.sheenColorMapEncoding) : "", t2.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", t2.lightMapEncoding) : "", getTexelEncodingFunction("linearToOutputTexel", t2.outputEncoding), t2.depthPacking ? "#define DEPTH_PACKING " + t2.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")), o2 = replaceClippingPlaneNums(replaceLightNums(resolveIncludes(o2), t2), t2), s2 = replaceClippingPlaneNums(replaceLightNums(resolveIncludes(s2), t2), t2), o2 = unrollLoops(o2), s2 = unrollLoops(s2), t2.isWebGL2 && t2.isRawShaderMaterial !== true && (y = "#version 300 es\n", g2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, v2 = ["#define varying in", t2.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;", t2.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v2);
    c2 = y + g2 + o2, u2 = y + v2 + s2, h2 = WebGLShader(i2, 35633, c2), l2 = WebGLShader(i2, 35632, u2);
    if (i2.attachShader(m2, h2), i2.attachShader(m2, l2), t2.index0AttributeName !== void 0 ? i2.bindAttribLocation(m2, 0, t2.index0AttributeName) : t2.morphTargets === true && i2.bindAttribLocation(m2, 0, "position"), i2.linkProgram(m2), r2.debug.checkShaderErrors) {
      o2 = i2.getProgramInfoLog(m2).trim(), s2 = i2.getShaderInfoLog(h2).trim(), c2 = i2.getShaderInfoLog(l2).trim();
      let e3 = true, t3 = true;
      i2.getProgramParameter(m2, 35714) === false ? (e3 = false, u2 = getShaderErrors(i2, h2, "vertex"), r2 = getShaderErrors(i2, l2, "fragment"), console.error("THREE.WebGLProgram: Shader Error " + i2.getError() + " - VALIDATE_STATUS " + i2.getProgramParameter(m2, 35715) + "\n\nProgram Info Log: " + o2 + "\n" + u2 + "\n" + r2)) : o2 !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", o2) : s2 !== "" && c2 !== "" || (t3 = false), t3 && (this.diagnostics = { runnable: e3, programLog: o2, vertexShader: { log: s2, prefix: g2 }, fragmentShader: { log: c2, prefix: v2 } });
    }
    i2.deleteShader(h2), i2.deleteShader(l2);
    let _2;
    this.getUniforms = function() {
      return _2 === void 0 && (_2 = new WebGLUniforms(i2, m2)), _2;
    };
    let b2;
    return this.getAttributes = function() {
      return b2 === void 0 && (b2 = fetchAttributeLocations(i2, m2)), b2;
    }, this.destroy = function() {
      n2.releaseStatesOfProgram(this), i2.deleteProgram(m2), this.program = void 0;
    }, this.name = t2.shaderName, this.id = programIdCount++, this.cacheKey = e2, this.usedTimes = 1, this.program = m2, this.vertexShader = h2, this.fragmentShader = l2, this;
  }
  function WebGLPrograms(p2, f2, m2, g2, v2, t2, y) {
    const a2 = [], _2 = v2.isWebGL2, b2 = v2.logarithmicDepthBuffer, x2 = v2.floatVertexTextures, w2 = v2.maxVertexUniforms, S2 = v2.vertexTextures;
    let M2 = v2.precision;
    const E2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, n2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];
    function T2(e2) {
      let t3;
      return t3 = e2 && e2.isTexture ? e2.encoding : e2 && e2.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e2.texture.encoding) : LinearEncoding, _2 && e2 && e2.isTexture && e2.format === RGBAFormat && e2.type === UnsignedByteType && e2.encoding === sRGBEncoding && (t3 = LinearEncoding), t3;
    }
    return { getParameters: function(e2, t3, r2, n3, i2) {
      var a3 = n3.fog, o2 = e2.isMeshStandardMaterial ? n3.environment : null, s2 = (e2.isMeshStandardMaterial ? m2 : f2).get(e2.envMap || o2), n3 = E2[e2.type], o2 = i2.isSkinnedMesh ? (u2 = (h2 = i2).skeleton.bones, x2 ? 1024 : (h2 = w2, h2 = Math.floor((h2 - 20) / 4), (h2 = Math.min(h2, u2.length)) < u2.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + u2.length + " bones. This GPU supports " + h2 + "."), 0) : h2)) : 0;
      e2.precision !== null && (M2 = v2.getMaxPrecision(e2.precision), M2 !== e2.precision && console.warn("THREE.WebGLProgram.getParameters:", e2.precision, "not supported, using", M2, "instead."));
      let l2, c2;
      c2 = n3 ? (d2 = ShaderLib[n3], l2 = d2.vertexShader, d2.fragmentShader) : (l2 = e2.vertexShader, e2.fragmentShader);
      var u2 = p2.getRenderTarget(), h2 = 0 < e2.alphaTest, d2 = 0 < e2.clearcoat;
      return { isWebGL2: _2, shaderID: n3, shaderName: e2.type, vertexShader: l2, fragmentShader: c2, defines: e2.defines, isRawShaderMaterial: e2.isRawShaderMaterial === true, glslVersion: e2.glslVersion, precision: M2, instancing: i2.isInstancedMesh === true, instancingColor: i2.isInstancedMesh === true && i2.instanceColor !== null, supportsVertexTextures: S2, outputEncoding: u2 !== null ? T2(u2.texture) : p2.outputEncoding, map: !!e2.map, mapEncoding: T2(e2.map), matcap: !!e2.matcap, matcapEncoding: T2(e2.matcap), envMap: !!s2, envMapMode: s2 && s2.mapping, envMapEncoding: T2(s2), envMapCubeUV: !!s2 && (s2.mapping === CubeUVReflectionMapping || s2.mapping === CubeUVRefractionMapping), lightMap: !!e2.lightMap, lightMapEncoding: T2(e2.lightMap), aoMap: !!e2.aoMap, emissiveMap: !!e2.emissiveMap, emissiveMapEncoding: T2(e2.emissiveMap), bumpMap: !!e2.bumpMap, normalMap: !!e2.normalMap, objectSpaceNormalMap: e2.normalMapType === ObjectSpaceNormalMap, tangentSpaceNormalMap: e2.normalMapType === TangentSpaceNormalMap, clearcoat: d2, clearcoatMap: d2 && !!e2.clearcoatMap, clearcoatRoughnessMap: d2 && !!e2.clearcoatRoughnessMap, clearcoatNormalMap: d2 && !!e2.clearcoatNormalMap, displacementMap: !!e2.displacementMap, roughnessMap: !!e2.roughnessMap, metalnessMap: !!e2.metalnessMap, specularMap: !!e2.specularMap, specularIntensityMap: !!e2.specularIntensityMap, specularColorMap: !!e2.specularColorMap, specularColorMapEncoding: T2(e2.specularColorMap), alphaMap: !!e2.alphaMap, alphaTest: h2, gradientMap: !!e2.gradientMap, sheen: 0 < e2.sheen, sheenColorMap: !!e2.sheenColorMap, sheenColorMapEncoding: T2(e2.sheenColorMap), sheenRoughnessMap: !!e2.sheenRoughnessMap, transmission: 0 < e2.transmission, transmissionMap: !!e2.transmissionMap, thicknessMap: !!e2.thicknessMap, combine: e2.combine, vertexTangents: !!e2.normalMap && !!i2.geometry && !!i2.geometry.attributes.tangent, vertexColors: e2.vertexColors, vertexAlphas: e2.vertexColors === true && !!i2.geometry && !!i2.geometry.attributes.color && i2.geometry.attributes.color.itemSize === 4, vertexUvs: !!e2.map || !!e2.bumpMap || !!e2.normalMap || !!e2.specularMap || !!e2.alphaMap || !!e2.emissiveMap || !!e2.roughnessMap || !!e2.metalnessMap || !!e2.clearcoatMap || !!e2.clearcoatRoughnessMap || !!e2.clearcoatNormalMap || !!e2.displacementMap || !!e2.transmissionMap || !!e2.thicknessMap || !!e2.specularIntensityMap || !!e2.specularColorMap || !!e2.sheenColorMap || e2.sheenRoughnessMap, uvsVertexOnly: !(e2.map || e2.bumpMap || e2.normalMap || e2.specularMap || e2.alphaMap || e2.emissiveMap || e2.roughnessMap || e2.metalnessMap || e2.clearcoatNormalMap || 0 < e2.transmission || e2.transmissionMap || e2.thicknessMap || e2.specularIntensityMap || e2.specularColorMap || 0 < !!e2.sheen || e2.sheenColorMap || e2.sheenRoughnessMap || !e2.displacementMap), fog: !!a3, useFog: e2.fog, fogExp2: a3 && a3.isFogExp2, flatShading: !!e2.flatShading, sizeAttenuation: e2.sizeAttenuation, logarithmicDepthBuffer: b2, skinning: i2.isSkinnedMesh === true && 0 < o2, maxBones: o2, useVertexTexture: x2, morphTargets: !!i2.geometry && !!i2.geometry.morphAttributes.position, morphNormals: !!i2.geometry && !!i2.geometry.morphAttributes.normal, morphTargetsCount: i2.geometry && i2.geometry.morphAttributes.position ? i2.geometry.morphAttributes.position.length : 0, numDirLights: t3.directional.length, numPointLights: t3.point.length, numSpotLights: t3.spot.length, numRectAreaLights: t3.rectArea.length, numHemiLights: t3.hemi.length, numDirLightShadows: t3.directionalShadowMap.length, numPointLightShadows: t3.pointShadowMap.length, numSpotLightShadows: t3.spotShadowMap.length, numClippingPlanes: y.numPlanes, numClipIntersection: y.numIntersection, format: e2.format, dithering: e2.dithering, shadowMapEnabled: p2.shadowMap.enabled && 0 < r2.length, shadowMapType: p2.shadowMap.type, toneMapping: e2.toneMapped ? p2.toneMapping : NoToneMapping, physicallyCorrectLights: p2.physicallyCorrectLights, premultipliedAlpha: e2.premultipliedAlpha, doubleSided: e2.side === DoubleSide, flipSided: e2.side === BackSide, depthPacking: e2.depthPacking !== void 0 && e2.depthPacking, index0AttributeName: e2.index0AttributeName, extensionDerivatives: e2.extensions && e2.extensions.derivatives, extensionFragDepth: e2.extensions && e2.extensions.fragDepth, extensionDrawBuffers: e2.extensions && e2.extensions.drawBuffers, extensionShaderTextureLOD: e2.extensions && e2.extensions.shaderTextureLOD, rendererExtensionFragDepth: _2 || g2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: _2 || g2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: _2 || g2.has("EXT_shader_texture_lod"), customProgramCacheKey: e2.customProgramCacheKey() };
    }, getProgramCacheKey: function(t3) {
      const r2 = [];
      if (t3.shaderID ? r2.push(t3.shaderID) : (r2.push(hashString(t3.fragmentShader)), r2.push(hashString(t3.vertexShader))), t3.defines !== void 0)
        for (const e2 in t3.defines)
          r2.push(e2), r2.push(t3.defines[e2]);
      if (t3.isRawShaderMaterial === false) {
        for (let e2 = 0; e2 < n2.length; e2++)
          r2.push(t3[n2[e2]]);
        r2.push(p2.outputEncoding), r2.push(p2.gammaFactor);
      }
      return r2.push(t3.customProgramCacheKey), r2.join();
    }, getUniforms: function(e2) {
      var t3 = E2[e2.type];
      let r2;
      return r2 = t3 ? (t3 = ShaderLib[t3], UniformsUtils.clone(t3.uniforms)) : e2.uniforms, r2;
    }, acquireProgram: function(e2, r2) {
      let n3;
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        var i2 = a2[e3];
        if (i2.cacheKey === r2) {
          n3 = i2, ++n3.usedTimes;
          break;
        }
      }
      return n3 === void 0 && (n3 = new WebGLProgram(p2, r2, e2, t2), a2.push(n3)), n3;
    }, releaseProgram: function(e2) {
      var t3;
      --e2.usedTimes == 0 && (t3 = a2.indexOf(e2), a2[t3] = a2[a2.length - 1], a2.pop(), e2.destroy());
    }, programs: a2 };
  }
  function WebGLProperties() {
    let n2 = new WeakMap();
    return { get: function(e2) {
      let t2 = n2.get(e2);
      return t2 === void 0 && (t2 = {}, n2.set(e2, t2)), t2;
    }, remove: function(e2) {
      n2.delete(e2);
    }, update: function(e2, t2, r2) {
      n2.get(e2)[t2] = r2;
    }, dispose: function() {
      n2 = new WeakMap();
    } };
  }
  function painterSortStable(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.program !== t2.program ? e2.program.id - t2.program.id : e2.material.id !== t2.material.id ? e2.material.id - t2.material.id : e2.z !== t2.z ? e2.z - t2.z : e2.id - t2.id;
  }
  function reversePainterSortStable(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.z !== t2.z ? t2.z - e2.z : e2.id - t2.id;
  }
  function WebGLRenderList(l2) {
    const c2 = [];
    let u2 = 0;
    const o2 = [], s2 = [], h2 = [], d2 = { id: -1 };
    function p2(e2, t2, r2, n2, i2, a2) {
      let o3 = c2[u2];
      var s3 = l2.get(r2);
      return o3 === void 0 ? (o3 = { id: e2.id, object: e2, geometry: t2, material: r2, program: s3.program || d2, groupOrder: n2, renderOrder: e2.renderOrder, z: i2, group: a2 }, c2[u2] = o3) : (o3.id = e2.id, o3.object = e2, o3.geometry = t2, o3.material = r2, o3.program = s3.program || d2, o3.groupOrder = n2, o3.renderOrder = e2.renderOrder, o3.z = i2, o3.group = a2), u2++, o3;
    }
    return { opaque: o2, transmissive: s2, transparent: h2, init: function() {
      u2 = 0, o2.length = 0, s2.length = 0, h2.length = 0;
    }, push: function(e2, t2, r2, n2, i2, a2) {
      a2 = p2(e2, t2, r2, n2, i2, a2), (0 < r2.transmission ? s2 : r2.transparent === true ? h2 : o2).push(a2);
    }, unshift: function(e2, t2, r2, n2, i2, a2) {
      a2 = p2(e2, t2, r2, n2, i2, a2), (0 < r2.transmission ? s2 : r2.transparent === true ? h2 : o2).unshift(a2);
    }, finish: function() {
      for (let e2 = u2, t2 = c2.length; e2 < t2; e2++) {
        const r2 = c2[e2];
        if (r2.id === null)
          break;
        r2.id = null, r2.object = null, r2.geometry = null, r2.material = null, r2.program = null, r2.group = null;
      }
    }, sort: function(e2, t2) {
      1 < o2.length && o2.sort(e2 || painterSortStable), 1 < s2.length && s2.sort(t2 || reversePainterSortStable), 1 < h2.length && h2.sort(t2 || reversePainterSortStable);
    } };
  }
  function WebGLRenderLists(n2) {
    let i2 = new WeakMap();
    return { get: function(e2, t2) {
      let r2;
      return i2.has(e2) === false ? (r2 = new WebGLRenderList(n2), i2.set(e2, [r2])) : t2 >= i2.get(e2).length ? (r2 = new WebGLRenderList(n2), i2.get(e2).push(r2)) : r2 = i2.get(e2)[t2], r2;
    }, dispose: function() {
      i2 = new WeakMap();
    } };
  }
  function UniformsCache() {
    const r2 = {};
    return { get: function(e2) {
      if (r2[e2.id] !== void 0)
        return r2[e2.id];
      let t2;
      switch (e2.type) {
        case "DirectionalLight":
          t2 = { direction: new Vector3(), color: new Color() };
          break;
        case "SpotLight":
          t2 = { position: new Vector3(), direction: new Vector3(), color: new Color(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          t2 = { position: new Vector3(), color: new Color(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t2 = { direction: new Vector3(), skyColor: new Color(), groundColor: new Color() };
          break;
        case "RectAreaLight":
          t2 = { color: new Color(), position: new Vector3(), halfWidth: new Vector3(), halfHeight: new Vector3() };
      }
      return r2[e2.id] = t2, t2;
    } };
  }
  function ShadowUniformsCache() {
    const r2 = {};
    return { get: function(e2) {
      if (r2[e2.id] !== void 0)
        return r2[e2.id];
      let t2;
      switch (e2.type) {
        case "DirectionalLight":
        case "SpotLight":
          t2 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2() };
          break;
        case "PointLight":
          t2 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return r2[e2.id] = t2, t2;
    } };
  }
  let nextVersion = 0;
  function shadowCastingLightsFirst(e2, t2) {
    return (t2.castShadow ? 1 : 0) - (e2.castShadow ? 1 : 0);
  }
  function WebGLLights(C2, $2) {
    const R2 = new UniformsCache(), L = ShadowUniformsCache(), O = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
    for (let e2 = 0; e2 < 9; e2++)
      O.probe.push(new Vector3());
    const m2 = new Vector3(), g2 = new Matrix4(), v2 = new Matrix4();
    return { setup: function(r2, e2) {
      let n2 = 0, i2 = 0, a2 = 0;
      for (let e3 = 0; e3 < 9; e3++)
        O.probe[e3].set(0, 0, 0);
      let o2 = 0, s2 = 0, l2 = 0, c2 = 0, u2 = 0, h2 = 0, d2 = 0, p2 = 0;
      r2.sort(shadowCastingLightsFirst);
      var f2 = e2 !== true ? Math.PI : 1;
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
        var m3 = r2[e3], g3 = m3.color, v3 = m3.intensity, y = m3.distance, _2 = m3.shadow && m3.shadow.map ? m3.shadow.map.texture : null;
        if (m3.isAmbientLight)
          n2 += g3.r * v3 * f2, i2 += g3.g * v3 * f2, a2 += g3.b * v3 * f2;
        else if (m3.isLightProbe)
          for (let e4 = 0; e4 < 9; e4++)
            O.probe[e4].addScaledVector(m3.sh.coefficients[e4], v3);
        else if (m3.isDirectionalLight) {
          const x2 = R2.get(m3);
          if (x2.color.copy(m3.color).multiplyScalar(m3.intensity * f2), m3.castShadow) {
            var b2 = m3.shadow;
            const w2 = L.get(m3);
            w2.shadowBias = b2.bias, w2.shadowNormalBias = b2.normalBias, w2.shadowRadius = b2.radius, w2.shadowMapSize = b2.mapSize, O.directionalShadow[o2] = w2, O.directionalShadowMap[o2] = _2, O.directionalShadowMatrix[o2] = m3.shadow.matrix, h2++;
          }
          O.directional[o2] = x2, o2++;
        } else if (m3.isSpotLight) {
          const S2 = R2.get(m3);
          if (S2.position.setFromMatrixPosition(m3.matrixWorld), S2.color.copy(g3).multiplyScalar(v3 * f2), S2.distance = y, S2.coneCos = Math.cos(m3.angle), S2.penumbraCos = Math.cos(m3.angle * (1 - m3.penumbra)), S2.decay = m3.decay, m3.castShadow) {
            y = m3.shadow;
            const M2 = L.get(m3);
            M2.shadowBias = y.bias, M2.shadowNormalBias = y.normalBias, M2.shadowRadius = y.radius, M2.shadowMapSize = y.mapSize, O.spotShadow[l2] = M2, O.spotShadowMap[l2] = _2, O.spotShadowMatrix[l2] = m3.shadow.matrix, p2++;
          }
          O.spot[l2] = S2, l2++;
        } else if (m3.isRectAreaLight) {
          const E2 = R2.get(m3);
          E2.color.copy(g3).multiplyScalar(v3), E2.halfWidth.set(0.5 * m3.width, 0, 0), E2.halfHeight.set(0, 0.5 * m3.height, 0), O.rectArea[c2] = E2, c2++;
        } else if (m3.isPointLight) {
          const T2 = R2.get(m3);
          if (T2.color.copy(m3.color).multiplyScalar(m3.intensity * f2), T2.distance = m3.distance, T2.decay = m3.decay, m3.castShadow) {
            g3 = m3.shadow;
            const k2 = L.get(m3);
            k2.shadowBias = g3.bias, k2.shadowNormalBias = g3.normalBias, k2.shadowRadius = g3.radius, k2.shadowMapSize = g3.mapSize, k2.shadowCameraNear = g3.camera.near, k2.shadowCameraFar = g3.camera.far, O.pointShadow[s2] = k2, O.pointShadowMap[s2] = _2, O.pointShadowMatrix[s2] = m3.shadow.matrix, d2++;
          }
          O.point[s2] = T2, s2++;
        } else if (m3.isHemisphereLight) {
          const A2 = R2.get(m3);
          A2.skyColor.copy(m3.color).multiplyScalar(v3 * f2), A2.groundColor.copy(m3.groundColor).multiplyScalar(v3 * f2), O.hemi[u2] = A2, u2++;
        }
      }
      0 < c2 && ($2.isWebGL2 || C2.has("OES_texture_float_linear") === true ? (O.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, O.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : C2.has("OES_texture_half_float_linear") === true ? (O.rectAreaLTC1 = UniformsLib.LTC_HALF_1, O.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), O.ambient[0] = n2, O.ambient[1] = i2, O.ambient[2] = a2;
      const t2 = O.hash;
      t2.directionalLength === o2 && t2.pointLength === s2 && t2.spotLength === l2 && t2.rectAreaLength === c2 && t2.hemiLength === u2 && t2.numDirectionalShadows === h2 && t2.numPointShadows === d2 && t2.numSpotShadows === p2 || (O.directional.length = o2, O.spot.length = l2, O.rectArea.length = c2, O.point.length = s2, O.hemi.length = u2, O.directionalShadow.length = h2, O.directionalShadowMap.length = h2, O.pointShadow.length = d2, O.pointShadowMap.length = d2, O.spotShadow.length = p2, O.spotShadowMap.length = p2, O.directionalShadowMatrix.length = h2, O.pointShadowMatrix.length = d2, O.spotShadowMatrix.length = p2, t2.directionalLength = o2, t2.pointLength = s2, t2.spotLength = l2, t2.rectAreaLength = c2, t2.hemiLength = u2, t2.numDirectionalShadows = h2, t2.numPointShadows = d2, t2.numSpotShadows = p2, O.version = nextVersion++);
    }, setupView: function(r2, e2) {
      let n2 = 0, i2 = 0, a2 = 0, o2 = 0, s2 = 0;
      var l2 = e2.matrixWorldInverse;
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++) {
        var c2 = r2[e3];
        if (c2.isDirectionalLight) {
          const u2 = O.directional[n2];
          u2.direction.setFromMatrixPosition(c2.matrixWorld), m2.setFromMatrixPosition(c2.target.matrixWorld), u2.direction.sub(m2), u2.direction.transformDirection(l2), n2++;
        } else if (c2.isSpotLight) {
          const h2 = O.spot[a2];
          h2.position.setFromMatrixPosition(c2.matrixWorld), h2.position.applyMatrix4(l2), h2.direction.setFromMatrixPosition(c2.matrixWorld), m2.setFromMatrixPosition(c2.target.matrixWorld), h2.direction.sub(m2), h2.direction.transformDirection(l2), a2++;
        } else if (c2.isRectAreaLight) {
          const d2 = O.rectArea[o2];
          d2.position.setFromMatrixPosition(c2.matrixWorld), d2.position.applyMatrix4(l2), v2.identity(), g2.copy(c2.matrixWorld), g2.premultiply(l2), v2.extractRotation(g2), d2.halfWidth.set(0.5 * c2.width, 0, 0), d2.halfHeight.set(0, 0.5 * c2.height, 0), d2.halfWidth.applyMatrix4(v2), d2.halfHeight.applyMatrix4(v2), o2++;
        } else if (c2.isPointLight) {
          const p2 = O.point[i2];
          p2.position.setFromMatrixPosition(c2.matrixWorld), p2.position.applyMatrix4(l2), i2++;
        } else if (c2.isHemisphereLight) {
          const f2 = O.hemi[s2];
          f2.direction.setFromMatrixPosition(c2.matrixWorld), f2.direction.transformDirection(l2), f2.direction.normalize(), s2++;
        }
      }
    }, state: O };
  }
  function WebGLRenderState(e2, t2) {
    const r2 = new WebGLLights(e2, t2), n2 = [], i2 = [];
    return { init: function() {
      n2.length = 0, i2.length = 0;
    }, state: { lightsArray: n2, shadowsArray: i2, lights: r2 }, setupLights: function(e3) {
      r2.setup(n2, e3);
    }, setupLightsView: function(e3) {
      r2.setupView(n2, e3);
    }, pushLight: function(e3) {
      n2.push(e3);
    }, pushShadow: function(e3) {
      i2.push(e3);
    } };
  }
  function WebGLRenderStates(n2, i2) {
    let a2 = new WeakMap();
    return { get: function(e2, t2 = 0) {
      let r2;
      return a2.has(e2) === false ? (r2 = new WebGLRenderState(n2, i2), a2.set(e2, [r2])) : t2 >= a2.get(e2).length ? (r2 = new WebGLRenderState(n2, i2), a2.get(e2).push(r2)) : r2 = a2.get(e2)[t2], r2;
    }, dispose: function() {
      a2 = new WeakMap();
    } };
  }
  class MeshDepthMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.depthPacking = e2.depthPacking, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this;
    }
  }
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  class MeshDistanceMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.referencePosition.copy(e2.referencePosition), this.nearDistance = e2.nearDistance, this.farDistance = e2.farDistance, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this;
    }
  }
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(m2, g2, e2) {
    let v2 = new Frustum();
    const p2 = new Vector2(), f2 = new Vector2(), y = new Vector4(), c2 = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), u2 = new MeshDistanceMaterial(), h2 = {}, _2 = e2.maxTextureSize, d2 = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, b2 = new ShaderMaterial({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2() }, radius: { value: 4 } }, vertexShader: vertex, fragmentShader: fragment }), x2 = b2.clone();
    x2.defines.HORIZONTAL_PASS = 1;
    const t2 = new BufferGeometry();
    t2.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const w2 = new Mesh(t2, b2), S2 = this;
    function M2(r2, e3, n2, t3, i2, a2, o2) {
      let s2 = null;
      var l2 = t3.isPointLight === true ? r2.customDistanceMaterial : r2.customDepthMaterial;
      if (s2 = l2 !== void 0 ? l2 : t3.isPointLight === true ? u2 : c2, m2.localClippingEnabled && n2.clipShadows === true && n2.clippingPlanes.length !== 0 || n2.displacementMap && n2.displacementScale !== 0 || n2.alphaMap && 0 < n2.alphaTest) {
        r2 = s2.uuid, l2 = n2.uuid;
        let e4 = h2[r2];
        e4 === void 0 && (e4 = {}, h2[r2] = e4);
        let t4 = e4[l2];
        t4 === void 0 && (t4 = s2.clone(), e4[l2] = t4), s2 = t4;
      }
      return s2.visible = n2.visible, s2.wireframe = n2.wireframe, o2 === VSMShadowMap ? s2.side = n2.shadowSide !== null ? n2.shadowSide : n2.side : s2.side = n2.shadowSide !== null ? n2.shadowSide : d2[n2.side], s2.alphaMap = n2.alphaMap, s2.alphaTest = n2.alphaTest, s2.clipShadows = n2.clipShadows, s2.clippingPlanes = n2.clippingPlanes, s2.clipIntersection = n2.clipIntersection, s2.displacementMap = n2.displacementMap, s2.displacementScale = n2.displacementScale, s2.displacementBias = n2.displacementBias, s2.wireframeLinewidth = n2.wireframeLinewidth, s2.linewidth = n2.linewidth, t3.isPointLight === true && s2.isMeshDistanceMaterial === true && (s2.referencePosition.setFromMatrixPosition(t3.matrixWorld), s2.nearDistance = i2, s2.farDistance = a2), s2;
    }
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = PCFShadowMap, this.render = function(r2, n2, i2) {
      if (S2.enabled !== false && (S2.autoUpdate !== false || S2.needsUpdate !== false) && r2.length !== 0) {
        var e3 = m2.getRenderTarget(), t3 = m2.getActiveCubeFace(), a2 = m2.getActiveMipmapLevel();
        const h3 = m2.state;
        h3.setBlending(NoBlending), h3.buffers.color.setClear(1, 1, 1, 1), h3.buffers.depth.setTest(true), h3.setScissorTest(false);
        for (let e4 = 0, t4 = r2.length; e4 < t4; e4++) {
          var o2 = r2[e4];
          const d3 = o2.shadow;
          if (d3 !== void 0) {
            if (d3.autoUpdate !== false || d3.needsUpdate !== false) {
              p2.copy(d3.mapSize);
              var s2, l2 = d3.getFrameExtents();
              p2.multiply(l2), f2.copy(d3.mapSize), (p2.x > _2 || p2.y > _2) && (p2.x > _2 && (f2.x = Math.floor(_2 / l2.x), p2.x = f2.x * l2.x, d3.mapSize.x = f2.x), p2.y > _2 && (f2.y = Math.floor(_2 / l2.y), p2.y = f2.y * l2.y, d3.mapSize.y = f2.y)), d3.map !== null || d3.isPointLightShadow || this.type !== VSMShadowMap || (s2 = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }, d3.map = new WebGLRenderTarget(p2.x, p2.y, s2), d3.map.texture.name = o2.name + ".shadowMap", d3.mapPass = new WebGLRenderTarget(p2.x, p2.y, s2), d3.camera.updateProjectionMatrix()), d3.map === null && (s2 = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }, d3.map = new WebGLRenderTarget(p2.x, p2.y, s2), d3.map.texture.name = o2.name + ".shadowMap", d3.camera.updateProjectionMatrix()), m2.setRenderTarget(d3.map), m2.clear();
              var c3 = d3.getViewportCount();
              for (let e5 = 0; e5 < c3; e5++) {
                var u3 = d3.getViewport(e5);
                y.set(f2.x * u3.x, f2.y * u3.y, f2.x * u3.z, f2.y * u3.w), h3.viewport(y), d3.updateMatrices(o2, e5), v2 = d3.getFrustum(), function r3(n3, i3, a3, o3, s3) {
                  if (n3.visible === false)
                    return;
                  const e6 = n3.layers.test(i3.layers);
                  if (e6 && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && s3 === VSMShadowMap) && (!n3.frustumCulled || v2.intersectsObject(n3))) {
                    n3.modelViewMatrix.multiplyMatrices(a3.matrixWorldInverse, n3.matrixWorld);
                    const c4 = g2.update(n3), u4 = n3.material;
                    if (Array.isArray(u4)) {
                      const h4 = c4.groups;
                      for (let e7 = 0, t5 = h4.length; e7 < t5; e7++) {
                        const d4 = h4[e7], p3 = u4[d4.materialIndex];
                        if (p3 && p3.visible) {
                          const f3 = M2(n3, c4, p3, o3, a3.near, a3.far, s3);
                          m2.renderBufferDirect(a3, null, c4, f3, n3, d4);
                        }
                      }
                    } else if (u4.visible) {
                      const t5 = M2(n3, c4, u4, o3, a3.near, a3.far, s3);
                      m2.renderBufferDirect(a3, null, c4, t5, n3, null);
                    }
                  }
                  const l3 = n3.children;
                  for (let e7 = 0, t5 = l3.length; e7 < t5; e7++)
                    r3(l3[e7], i3, a3, o3, s3);
                }(n2, i2, d3.camera, o2, this.type);
              }
              d3.isPointLightShadow || this.type !== VSMShadowMap || function(e5, t5) {
                var r3 = g2.update(w2);
                b2.defines.VSM_SAMPLES !== e5.blurSamples && (b2.defines.VSM_SAMPLES = e5.blurSamples, x2.defines.VSM_SAMPLES = e5.blurSamples, b2.needsUpdate = true, x2.needsUpdate = true);
                b2.uniforms.shadow_pass.value = e5.map.texture, b2.uniforms.resolution.value = e5.mapSize, b2.uniforms.radius.value = e5.radius, m2.setRenderTarget(e5.mapPass), m2.clear(), m2.renderBufferDirect(t5, null, r3, b2, w2, null), x2.uniforms.shadow_pass.value = e5.mapPass.texture, x2.uniforms.resolution.value = e5.mapSize, x2.uniforms.radius.value = e5.radius, m2.setRenderTarget(e5.map), m2.clear(), m2.renderBufferDirect(t5, null, r3, x2, w2, null);
              }(d3, i2), d3.needsUpdate = false;
            }
          } else
            console.warn("THREE.WebGLShadowMap:", o2, "has no shadow.");
        }
        S2.needsUpdate = false, m2.setRenderTarget(e3, t3, a2);
      }
    };
  }
  function WebGLState(u2, e2, t2) {
    const r2 = t2.isWebGL2;
    const n2 = new function() {
      let t3 = false;
      const a3 = new Vector4();
      let r3 = null;
      const o3 = new Vector4(0, 0, 0, 0);
      return { setMask: function(e3) {
        r3 === e3 || t3 || (u2.colorMask(e3, e3, e3, e3), r3 = e3);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(e3, t4, r4, n3, i3) {
        i3 === true && (e3 *= n3, t4 *= n3, r4 *= n3), a3.set(e3, t4, r4, n3), o3.equals(a3) === false && (u2.clearColor(e3, t4, r4, n3), o3.copy(a3));
      }, reset: function() {
        t3 = false, r3 = null, o3.set(-1, 0, 0, 0);
      } };
    }(), i2 = new function() {
      let t3 = false, r3 = null, n3 = null, i3 = null;
      return { setTest: function(e3) {
        (e3 ? D : N2)(2929);
      }, setMask: function(e3) {
        r3 === e3 || t3 || (u2.depthMask(e3), r3 = e3);
      }, setFunc: function(e3) {
        if (n3 !== e3) {
          if (e3)
            switch (e3) {
              case NeverDepth:
                u2.depthFunc(512);
                break;
              case AlwaysDepth:
                u2.depthFunc(519);
                break;
              case LessDepth:
                u2.depthFunc(513);
                break;
              case LessEqualDepth:
                u2.depthFunc(515);
                break;
              case EqualDepth:
                u2.depthFunc(514);
                break;
              case GreaterEqualDepth:
                u2.depthFunc(518);
                break;
              case GreaterDepth:
                u2.depthFunc(516);
                break;
              case NotEqualDepth:
                u2.depthFunc(517);
                break;
              default:
                u2.depthFunc(515);
            }
          else
            u2.depthFunc(515);
          n3 = e3;
        }
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(e3) {
        i3 !== e3 && (u2.clearDepth(e3), i3 = e3);
      }, reset: function() {
        t3 = false, r3 = null, n3 = null, i3 = null;
      } };
    }(), a2 = new function() {
      let t3 = false, r3 = null, n3 = null, i3 = null, a3 = null, o3 = null, s3 = null, l3 = null, c3 = null;
      return { setTest: function(e3) {
        t3 || (e3 ? D : N2)(2960);
      }, setMask: function(e3) {
        r3 === e3 || t3 || (u2.stencilMask(e3), r3 = e3);
      }, setFunc: function(e3, t4, r4) {
        n3 === e3 && i3 === t4 && a3 === r4 || (u2.stencilFunc(e3, t4, r4), n3 = e3, i3 = t4, a3 = r4);
      }, setOp: function(e3, t4, r4) {
        o3 === e3 && s3 === t4 && l3 === r4 || (u2.stencilOp(e3, t4, r4), o3 = e3, s3 = t4, l3 = r4);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(e3) {
        c3 !== e3 && (u2.clearStencil(e3), c3 = e3);
      }, reset: function() {
        t3 = false, r3 = null, n3 = null, i3 = null, a3 = null, o3 = null, s3 = null, l3 = null, c3 = null;
      } };
    }();
    let o2 = {}, s2 = null, l2 = {}, c2 = null, h2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, y = null, _2 = false, b2 = null, x2 = null, w2 = null, S2 = null, M2 = null;
    const E2 = u2.getParameter(35661);
    let T2 = false, k2 = 0;
    const A2 = u2.getParameter(7938);
    A2.indexOf("WebGL") !== -1 ? (k2 = parseFloat(/^WebGL (\d)/.exec(A2)[1]), T2 = 1 <= k2) : A2.indexOf("OpenGL ES") !== -1 && (k2 = parseFloat(/^OpenGL ES (\d)/.exec(A2)[1]), T2 = 2 <= k2);
    let C2 = null, $2 = {};
    var R2 = u2.getParameter(3088), t2 = u2.getParameter(2978);
    const L = new Vector4().fromArray(R2), O = new Vector4().fromArray(t2);
    function P2(e3, t3, r3) {
      var n3 = new Uint8Array(4), i3 = u2.createTexture();
      u2.bindTexture(e3, i3), u2.texParameteri(e3, 10241, 9728), u2.texParameteri(e3, 10240, 9728);
      for (let e4 = 0; e4 < r3; e4++)
        u2.texImage2D(t3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, n3);
      return i3;
    }
    const I2 = {};
    function D(e3) {
      o2[e3] !== true && (u2.enable(e3), o2[e3] = true);
    }
    function N2(e3) {
      o2[e3] !== false && (u2.disable(e3), o2[e3] = false);
    }
    I2[3553] = P2(3553, 3553, 1), I2[34067] = P2(34067, 34069, 6), n2.setClear(0, 0, 0, 1), i2.setClear(1), a2.setClear(0), D(2929), i2.setFunc(LessEqualDepth), U(false), V2(CullFaceBack), D(2884), j2(NoBlending);
    const B = { [AddEquation]: 32774, [SubtractEquation]: 32778, [ReverseSubtractEquation]: 32779 };
    r2 ? (B[MinEquation] = 32775, B[MaxEquation] = 32776) : (e2 = e2.get("EXT_blend_minmax")) !== null && (B[MinEquation] = e2.MIN_EXT, B[MaxEquation] = e2.MAX_EXT);
    const F = { [ZeroFactor]: 0, [OneFactor]: 1, [SrcColorFactor]: 768, [SrcAlphaFactor]: 770, [SrcAlphaSaturateFactor]: 776, [DstColorFactor]: 774, [DstAlphaFactor]: 772, [OneMinusSrcColorFactor]: 769, [OneMinusSrcAlphaFactor]: 771, [OneMinusDstColorFactor]: 775, [OneMinusDstAlphaFactor]: 773 };
    function j2(e3, t3, r3, n3, i3, a3, o3, s3) {
      if (e3 !== NoBlending) {
        if (h2 === false && (D(3042), h2 = true), e3 === CustomBlending)
          i3 = i3 || t3, a3 = a3 || r3, o3 = o3 || n3, t3 === p2 && i3 === g2 || (u2.blendEquationSeparate(B[t3], B[i3]), p2 = t3, g2 = i3), r3 === f2 && n3 === m2 && a3 === v2 && o3 === y || (u2.blendFuncSeparate(F[r3], F[n3], F[a3], F[o3]), f2 = r3, m2 = n3, v2 = a3, y = o3), d2 = e3, _2 = null;
        else if (e3 !== d2 || s3 !== _2) {
          if (p2 === AddEquation && g2 === AddEquation || (u2.blendEquation(32774), p2 = AddEquation, g2 = AddEquation), s3)
            switch (e3) {
              case NormalBlending:
                u2.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                u2.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                u2.blendFuncSeparate(0, 0, 769, 771);
                break;
              case MultiplyBlending:
                u2.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e3);
            }
          else
            switch (e3) {
              case NormalBlending:
                u2.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                u2.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                u2.blendFunc(0, 769);
                break;
              case MultiplyBlending:
                u2.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e3);
            }
          f2 = null, m2 = null, v2 = null, y = null, d2 = e3, _2 = s3;
        }
      } else
        h2 === true && (N2(3042), h2 = false);
    }
    function U(e3) {
      b2 !== e3 && (e3 ? u2.frontFace(2304) : u2.frontFace(2305), b2 = e3);
    }
    function V2(e3) {
      e3 !== CullFaceNone ? (D(2884), e3 !== x2 && (e3 === CullFaceBack ? u2.cullFace(1029) : e3 === CullFaceFront ? u2.cullFace(1028) : u2.cullFace(1032))) : N2(2884), x2 = e3;
    }
    function z(e3, t3, r3) {
      e3 ? (D(32823), S2 === t3 && M2 === r3 || (u2.polygonOffset(t3, r3), S2 = t3, M2 = r3)) : N2(32823);
    }
    function H2(e3) {
      e3 === void 0 && (e3 = 33984 + E2 - 1), C2 !== e3 && (u2.activeTexture(e3), C2 = e3);
    }
    return { buffers: { color: n2, depth: i2, stencil: a2 }, enable: D, disable: N2, bindFramebuffer: function(e3, t3) {
      return t3 === null && s2 !== null && (t3 = s2), l2[e3] !== t3 && (u2.bindFramebuffer(e3, t3), l2[e3] = t3, r2 && (e3 === 36009 && (l2[36160] = t3), e3 === 36160 && (l2[36009] = t3)), true);
    }, bindXRFramebuffer: function(e3) {
      e3 !== s2 && (u2.bindFramebuffer(36160, e3), s2 = e3);
    }, useProgram: function(e3) {
      return c2 !== e3 && (u2.useProgram(e3), c2 = e3, true);
    }, setBlending: j2, setMaterial: function(e3, t3) {
      (e3.side === DoubleSide ? N2 : D)(2884);
      let r3 = e3.side === BackSide;
      t3 && (r3 = !r3), U(r3), e3.blending === NormalBlending && e3.transparent === false ? j2(NoBlending) : j2(e3.blending, e3.blendEquation, e3.blendSrc, e3.blendDst, e3.blendEquationAlpha, e3.blendSrcAlpha, e3.blendDstAlpha, e3.premultipliedAlpha), i2.setFunc(e3.depthFunc), i2.setTest(e3.depthTest), i2.setMask(e3.depthWrite), n2.setMask(e3.colorWrite), t3 = e3.stencilWrite, a2.setTest(t3), t3 && (a2.setMask(e3.stencilWriteMask), a2.setFunc(e3.stencilFunc, e3.stencilRef, e3.stencilFuncMask), a2.setOp(e3.stencilFail, e3.stencilZFail, e3.stencilZPass)), z(e3.polygonOffset, e3.polygonOffsetFactor, e3.polygonOffsetUnits), (e3.alphaToCoverage === true ? D : N2)(32926);
    }, setFlipSided: U, setCullFace: V2, setLineWidth: function(e3) {
      e3 !== w2 && (T2 && u2.lineWidth(e3), w2 = e3);
    }, setPolygonOffset: z, setScissorTest: function(e3) {
      (e3 ? D : N2)(3089);
    }, activeTexture: H2, bindTexture: function(e3, t3) {
      C2 === null && H2();
      let r3 = $2[C2];
      r3 === void 0 && (r3 = { type: void 0, texture: void 0 }, $2[C2] = r3), r3.type === e3 && r3.texture === t3 || (u2.bindTexture(e3, t3 || I2[e3]), r3.type = e3, r3.texture = t3);
    }, unbindTexture: function() {
      const e3 = $2[C2];
      e3 !== void 0 && e3.type !== void 0 && (u2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        u2.compressedTexImage2D.apply(u2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage2D: function() {
      try {
        u2.texImage2D.apply(u2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage3D: function() {
      try {
        u2.texImage3D.apply(u2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, scissor: function(e3) {
      L.equals(e3) === false && (u2.scissor(e3.x, e3.y, e3.z, e3.w), L.copy(e3));
    }, viewport: function(e3) {
      O.equals(e3) === false && (u2.viewport(e3.x, e3.y, e3.z, e3.w), O.copy(e3));
    }, reset: function() {
      u2.disable(3042), u2.disable(2884), u2.disable(2929), u2.disable(32823), u2.disable(3089), u2.disable(2960), u2.disable(32926), u2.blendEquation(32774), u2.blendFunc(1, 0), u2.blendFuncSeparate(1, 0, 1, 0), u2.colorMask(true, true, true, true), u2.clearColor(0, 0, 0, 0), u2.depthMask(true), u2.depthFunc(513), u2.clearDepth(1), u2.stencilMask(4294967295), u2.stencilFunc(519, 0, 4294967295), u2.stencilOp(7680, 7680, 7680), u2.clearStencil(0), u2.cullFace(1029), u2.frontFace(2305), u2.polygonOffset(0, 0), u2.activeTexture(33984), u2.bindFramebuffer(36160, null), r2 === true && (u2.bindFramebuffer(36009, null), u2.bindFramebuffer(36008, null)), u2.useProgram(null), u2.lineWidth(1), u2.scissor(0, 0, u2.canvas.width, u2.canvas.height), u2.viewport(0, 0, u2.canvas.width, u2.canvas.height), o2 = {}, C2 = null, $2 = {}, s2 = null, l2 = {}, c2 = null, h2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, y = null, _2 = false, b2 = null, x2 = null, w2 = null, S2 = null, M2 = null, L.set(0, 0, u2.canvas.width, u2.canvas.height), O.set(0, 0, u2.canvas.width, u2.canvas.height), n2.reset(), i2.reset(), a2.reset();
    } };
  }
  function WebGLTextures(m2, a2, g2, v2, y, _2, b2) {
    const x2 = y.isWebGL2, t2 = y.maxTextures, f2 = y.maxCubemapSize, u2 = y.maxTextureSize, r2 = y.maxSamples, o2 = new WeakMap();
    let l2, n2 = false;
    try {
      n2 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (e2) {
    }
    function c2(e2, t3) {
      return n2 ? new OffscreenCanvas(e2, t3) : createElementNS("canvas");
    }
    function w2(e2, t3, r3, n3) {
      let i3 = 1;
      if ((e2.width > n3 || e2.height > n3) && (i3 = n3 / Math.max(e2.width, e2.height)), i3 < 1 || t3 === true) {
        if (typeof HTMLImageElement != "undefined" && e2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e2 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e2 instanceof ImageBitmap) {
          const a3 = t3 ? floorPowerOfTwo : Math.floor;
          n3 = a3(i3 * e2.width), t3 = a3(i3 * e2.height);
          l2 === void 0 && (l2 = c2(n3, t3));
          const o3 = r3 ? c2(n3, t3) : l2;
          o3.width = n3, o3.height = t3;
          const s3 = o3.getContext("2d");
          return s3.drawImage(e2, 0, 0, n3, t3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e2.width + "x" + e2.height + ") to (" + n3 + "x" + t3 + ")."), o3;
        }
        return "data" in e2 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e2.width + "x" + e2.height + ")."), e2;
      }
      return e2;
    }
    function S2(e2) {
      return isPowerOfTwo(e2.width) && isPowerOfTwo(e2.height);
    }
    function M2(e2, t3) {
      return e2.generateMipmaps && t3 && e2.minFilter !== NearestFilter && e2.minFilter !== LinearFilter;
    }
    function E2(e2, t3, r3, n3, i3 = 1) {
      m2.generateMipmap(e2);
      const a3 = v2.get(t3);
      a3.__maxMipLevel = Math.log2(Math.max(r3, n3, i3));
    }
    function T2(e2, t3, r3, n3) {
      if (x2 === false)
        return t3;
      if (e2 !== null) {
        if (m2[e2] !== void 0)
          return m2[e2];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e2 + "'");
      }
      let i3 = t3;
      return t3 === 6403 && (r3 === 5126 && (i3 = 33326), r3 === 5131 && (i3 = 33325), r3 === 5121 && (i3 = 33321)), t3 === 6407 && (r3 === 5126 && (i3 = 34837), r3 === 5131 && (i3 = 34843), r3 === 5121 && (i3 = 32849)), t3 === 6408 && (r3 === 5126 && (i3 = 34836), r3 === 5131 && (i3 = 34842), r3 === 5121 && (i3 = n3 === sRGBEncoding ? 35907 : 32856)), i3 !== 33325 && i3 !== 33326 && i3 !== 34842 && i3 !== 34836 || a2.get("EXT_color_buffer_float"), i3;
    }
    function i2(e2) {
      return e2 === NearestFilter || e2 === NearestMipmapNearestFilter || e2 === NearestMipmapLinearFilter ? 9728 : 9729;
    }
    function s2(e2) {
      const t3 = e2.target;
      var r3;
      t3.removeEventListener("dispose", s2), r3 = t3, (e2 = v2.get(r3)).__webglInit !== void 0 && (m2.deleteTexture(e2.__webglTexture), v2.remove(r3)), t3.isVideoTexture && o2.delete(t3), b2.memory.textures--;
    }
    function k2(e2) {
      const t3 = e2.target;
      t3.removeEventListener("dispose", k2), function(e3) {
        var r3 = e3.texture, t4 = v2.get(e3), n3 = v2.get(r3);
        if (e3) {
          if (n3.__webglTexture !== void 0 && (m2.deleteTexture(n3.__webglTexture), b2.memory.textures--), e3.depthTexture && e3.depthTexture.dispose(), e3.isWebGLCubeRenderTarget)
            for (let e4 = 0; e4 < 6; e4++)
              m2.deleteFramebuffer(t4.__webglFramebuffer[e4]), t4.__webglDepthbuffer && m2.deleteRenderbuffer(t4.__webglDepthbuffer[e4]);
          else
            m2.deleteFramebuffer(t4.__webglFramebuffer), t4.__webglDepthbuffer && m2.deleteRenderbuffer(t4.__webglDepthbuffer), t4.__webglMultisampledFramebuffer && m2.deleteFramebuffer(t4.__webglMultisampledFramebuffer), t4.__webglColorRenderbuffer && m2.deleteRenderbuffer(t4.__webglColorRenderbuffer), t4.__webglDepthRenderbuffer && m2.deleteRenderbuffer(t4.__webglDepthRenderbuffer);
          if (e3.isWebGLMultipleRenderTargets)
            for (let e4 = 0, t5 = r3.length; e4 < t5; e4++) {
              var i3 = v2.get(r3[e4]);
              i3.__webglTexture && (m2.deleteTexture(i3.__webglTexture), b2.memory.textures--), v2.remove(r3[e4]);
            }
          v2.remove(r3), v2.remove(e3);
        }
      }(t3);
    }
    let h2 = 0;
    function d2(e2, t3) {
      var r3, n3 = v2.get(e2);
      if (e2.isVideoTexture && (i3 = e2, r3 = b2.render.frame, o2.get(i3) !== r3 && (o2.set(i3, r3), i3.update())), 0 < e2.version && n3.__version !== e2.version) {
        var i3 = e2.image;
        if (i3 === void 0)
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        else {
          if (i3.complete !== false)
            return void L(n3, e2, t3);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      g2.activeTexture(33984 + t3), g2.bindTexture(3553, n3.__webglTexture);
    }
    function p2(e2, t3) {
      var r3 = v2.get(e2);
      0 < e2.version && r3.__version !== e2.version ? function(e3, n3, t4) {
        if (n3.image.length === 6) {
          R2(e3, n3), g2.activeTexture(33984 + t4), g2.bindTexture(34067, e3.__webglTexture), m2.pixelStorei(37440, n3.flipY), m2.pixelStorei(37441, n3.premultiplyAlpha), m2.pixelStorei(3317, n3.unpackAlignment), m2.pixelStorei(37443, 0);
          var i3 = n3 && (n3.isCompressedTexture || n3.image[0].isCompressedTexture), a3 = n3.image[0] && n3.image[0].isDataTexture;
          const p3 = [];
          for (let e4 = 0; e4 < 6; e4++)
            p3[e4] = i3 || a3 ? a3 ? n3.image[e4].image : n3.image[e4] : w2(n3.image[e4], false, true, f2);
          var o3 = p3[0], t4 = S2(o3) || x2, s3 = _2.convert(n3.format), l3 = _2.convert(n3.type), c3 = T2(n3.internalFormat, s3, l3, n3.encoding);
          $2(34067, n3, t4);
          let r4;
          if (i3) {
            for (let t5 = 0; t5 < 6; t5++) {
              r4 = p3[t5].mipmaps;
              for (let e4 = 0; e4 < r4.length; e4++) {
                var u3 = r4[e4];
                n3.format !== RGBAFormat && n3.format !== RGBFormat ? s3 !== null ? g2.compressedTexImage2D(34069 + t5, e4, c3, u3.width, u3.height, 0, u3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g2.texImage2D(34069 + t5, e4, c3, u3.width, u3.height, 0, s3, l3, u3.data);
              }
            }
            e3.__maxMipLevel = r4.length - 1;
          } else {
            r4 = n3.mipmaps;
            for (let t5 = 0; t5 < 6; t5++)
              if (a3) {
                g2.texImage2D(34069 + t5, 0, c3, p3[t5].width, p3[t5].height, 0, s3, l3, p3[t5].data);
                for (let e4 = 0; e4 < r4.length; e4++) {
                  var h3 = r4[e4].image[t5].image;
                  g2.texImage2D(34069 + t5, e4 + 1, c3, h3.width, h3.height, 0, s3, l3, h3.data);
                }
              } else {
                g2.texImage2D(34069 + t5, 0, c3, s3, l3, p3[t5]);
                for (let e4 = 0; e4 < r4.length; e4++) {
                  var d3 = r4[e4];
                  g2.texImage2D(34069 + t5, e4 + 1, c3, s3, l3, d3.image[t5]);
                }
              }
            e3.__maxMipLevel = r4.length;
          }
          M2(n3, t4) && E2(34067, n3, o3.width, o3.height), e3.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
        }
      }(r3, e2, t3) : (g2.activeTexture(33984 + t3), g2.bindTexture(34067, r3.__webglTexture));
    }
    const A2 = { [RepeatWrapping]: 10497, [ClampToEdgeWrapping]: 33071, [MirroredRepeatWrapping]: 33648 }, C2 = { [NearestFilter]: 9728, [NearestMipmapNearestFilter]: 9984, [NearestMipmapLinearFilter]: 9986, [LinearFilter]: 9729, [LinearMipmapNearestFilter]: 9985, [LinearMipmapLinearFilter]: 9987 };
    function $2(e2, t3, r3) {
      r3 ? (m2.texParameteri(e2, 10242, A2[t3.wrapS]), m2.texParameteri(e2, 10243, A2[t3.wrapT]), e2 !== 32879 && e2 !== 35866 || m2.texParameteri(e2, 32882, A2[t3.wrapR]), m2.texParameteri(e2, 10240, C2[t3.magFilter]), m2.texParameteri(e2, 10241, C2[t3.minFilter])) : (m2.texParameteri(e2, 10242, 33071), m2.texParameteri(e2, 10243, 33071), e2 !== 32879 && e2 !== 35866 || m2.texParameteri(e2, 32882, 33071), t3.wrapS === ClampToEdgeWrapping && t3.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), m2.texParameteri(e2, 10240, i2(t3.magFilter)), m2.texParameteri(e2, 10241, i2(t3.minFilter)), t3.minFilter !== NearestFilter && t3.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), a2.has("EXT_texture_filter_anisotropic") === true && (r3 = a2.get("EXT_texture_filter_anisotropic"), t3.type === FloatType && a2.has("OES_texture_float_linear") === false || x2 === false && t3.type === HalfFloatType && a2.has("OES_texture_half_float_linear") === false || (1 < t3.anisotropy || v2.get(t3).__currentAnisotropy) && (m2.texParameterf(e2, r3.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t3.anisotropy, y.getMaxAnisotropy())), v2.get(t3).__currentAnisotropy = t3.anisotropy));
    }
    function R2(e2, t3) {
      e2.__webglInit === void 0 && (e2.__webglInit = true, t3.addEventListener("dispose", s2), e2.__webglTexture = m2.createTexture(), b2.memory.textures++);
    }
    function L(e2, r3, t3) {
      let n3 = 3553;
      r3.isDataTexture2DArray && (n3 = 35866), r3.isDataTexture3D && (n3 = 32879), R2(e2, r3), g2.activeTexture(33984 + t3), g2.bindTexture(n3, e2.__webglTexture), m2.pixelStorei(37440, r3.flipY), m2.pixelStorei(37441, r3.premultiplyAlpha), m2.pixelStorei(3317, r3.unpackAlignment), m2.pixelStorei(37443, 0);
      var t3 = (i3 = r3, !x2 && (i3.wrapS !== ClampToEdgeWrapping || i3.wrapT !== ClampToEdgeWrapping || i3.minFilter !== NearestFilter && i3.minFilter !== LinearFilter) && S2(r3.image) === false), i3 = w2(r3.image, t3, false, u2), t3 = S2(i3) || x2, a3 = _2.convert(r3.format);
      let o3 = _2.convert(r3.type), s3 = T2(r3.internalFormat, a3, o3, r3.encoding);
      $2(n3, r3, t3);
      let l3;
      var c3 = r3.mipmaps;
      if (r3.isDepthTexture)
        s3 = 6402, x2 ? s3 = r3.type === FloatType ? 36012 : r3.type === UnsignedIntType ? 33190 : r3.type === UnsignedInt248Type ? 35056 : 33189 : r3.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r3.format === DepthFormat && s3 === 6402 && r3.type !== UnsignedShortType && r3.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r3.type = UnsignedShortType, o3 = _2.convert(r3.type)), r3.format === DepthStencilFormat && s3 === 6402 && (s3 = 34041, r3.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r3.type = UnsignedInt248Type, o3 = _2.convert(r3.type))), g2.texImage2D(3553, 0, s3, i3.width, i3.height, 0, a3, o3, null);
      else if (r3.isDataTexture)
        if (0 < c3.length && t3) {
          for (let e3 = 0, t4 = c3.length; e3 < t4; e3++)
            l3 = c3[e3], g2.texImage2D(3553, e3, s3, l3.width, l3.height, 0, a3, o3, l3.data);
          r3.generateMipmaps = false, e2.__maxMipLevel = c3.length - 1;
        } else
          g2.texImage2D(3553, 0, s3, i3.width, i3.height, 0, a3, o3, i3.data), e2.__maxMipLevel = 0;
      else if (r3.isCompressedTexture) {
        for (let e3 = 0, t4 = c3.length; e3 < t4; e3++)
          l3 = c3[e3], r3.format !== RGBAFormat && r3.format !== RGBFormat ? a3 !== null ? g2.compressedTexImage2D(3553, e3, s3, l3.width, l3.height, 0, l3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g2.texImage2D(3553, e3, s3, l3.width, l3.height, 0, a3, o3, l3.data);
        e2.__maxMipLevel = c3.length - 1;
      } else if (r3.isDataTexture2DArray)
        g2.texImage3D(35866, 0, s3, i3.width, i3.height, i3.depth, 0, a3, o3, i3.data), e2.__maxMipLevel = 0;
      else if (r3.isDataTexture3D)
        g2.texImage3D(32879, 0, s3, i3.width, i3.height, i3.depth, 0, a3, o3, i3.data), e2.__maxMipLevel = 0;
      else if (0 < c3.length && t3) {
        for (let e3 = 0, t4 = c3.length; e3 < t4; e3++)
          l3 = c3[e3], g2.texImage2D(3553, e3, s3, a3, o3, l3);
        r3.generateMipmaps = false, e2.__maxMipLevel = c3.length - 1;
      } else
        g2.texImage2D(3553, 0, s3, a3, o3, i3), e2.__maxMipLevel = 0;
      M2(r3, t3) && E2(n3, r3, i3.width, i3.height), e2.__version = r3.version, r3.onUpdate && r3.onUpdate(r3);
    }
    function O(e2, t3, r3, n3, i3) {
      var a3 = _2.convert(r3.format), o3 = _2.convert(r3.type), s3 = T2(r3.internalFormat, a3, o3, r3.encoding);
      i3 === 32879 || i3 === 35866 ? g2.texImage3D(i3, 0, s3, t3.width, t3.height, t3.depth, 0, a3, o3, null) : g2.texImage2D(i3, 0, s3, t3.width, t3.height, 0, a3, o3, null), g2.bindFramebuffer(36160, e2), m2.framebufferTexture2D(36160, n3, i3, v2.get(r3).__webglTexture, 0), g2.bindFramebuffer(36160, null);
    }
    function P2(t3, r3, n3) {
      if (m2.bindRenderbuffer(36161, t3), r3.depthBuffer && !r3.stencilBuffer) {
        let e3 = 33189;
        n3 ? ((i3 = r3.depthTexture) && i3.isDepthTexture && (i3.type === FloatType ? e3 = 36012 : i3.type === UnsignedIntType && (e3 = 33190)), i3 = D(r3), m2.renderbufferStorageMultisample(36161, i3, e3, r3.width, r3.height)) : m2.renderbufferStorage(36161, e3, r3.width, r3.height), m2.framebufferRenderbuffer(36160, 36096, 36161, t3);
      } else {
        var e2, i3;
        r3.depthBuffer && r3.stencilBuffer ? (n3 ? (e2 = D(r3), m2.renderbufferStorageMultisample(36161, e2, 35056, r3.width, r3.height)) : m2.renderbufferStorage(36161, 34041, r3.width, r3.height), m2.framebufferRenderbuffer(36160, 33306, 36161, t3)) : (i3 = r3.isWebGLMultipleRenderTargets === true ? r3.texture[0] : r3.texture, e2 = _2.convert(i3.format), t3 = _2.convert(i3.type), i3 = T2(i3.internalFormat, e2, t3, i3.encoding), n3 ? (n3 = D(r3), m2.renderbufferStorageMultisample(36161, n3, i3, r3.width, r3.height)) : m2.renderbufferStorage(36161, i3, r3.width, r3.height));
      }
      m2.bindRenderbuffer(36161, null);
    }
    function I2(t3) {
      const r3 = v2.get(t3);
      var e2 = t3.isWebGLCubeRenderTarget === true;
      if (t3.depthTexture) {
        if (e2)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(e3, t4) {
          if (t4 && t4.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (g2.bindFramebuffer(36160, e3), !t4.depthTexture || !t4.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          if (v2.get(t4.depthTexture).__webglTexture && t4.depthTexture.image.width === t4.width && t4.depthTexture.image.height === t4.height || (t4.depthTexture.image.width = t4.width, t4.depthTexture.image.height = t4.height, t4.depthTexture.needsUpdate = true), d2(t4.depthTexture, 0), e3 = v2.get(t4.depthTexture).__webglTexture, t4.depthTexture.format === DepthFormat)
            m2.framebufferTexture2D(36160, 36096, 3553, e3, 0);
          else {
            if (t4.depthTexture.format !== DepthStencilFormat)
              throw new Error("Unknown depthTexture format");
            m2.framebufferTexture2D(36160, 33306, 3553, e3, 0);
          }
        }(r3.__webglFramebuffer, t3);
      } else if (e2) {
        r3.__webglDepthbuffer = [];
        for (let e3 = 0; e3 < 6; e3++)
          g2.bindFramebuffer(36160, r3.__webglFramebuffer[e3]), r3.__webglDepthbuffer[e3] = m2.createRenderbuffer(), P2(r3.__webglDepthbuffer[e3], t3, false);
      } else
        g2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = m2.createRenderbuffer(), P2(r3.__webglDepthbuffer, t3, false);
      g2.bindFramebuffer(36160, null);
    }
    function D(e2) {
      return x2 && e2.isWebGLMultisampleRenderTarget ? Math.min(r2, e2.samples) : 0;
    }
    let N2 = false, B = false;
    this.allocateTextureUnit = function() {
      var e2 = h2;
      return e2 >= t2 && console.warn("THREE.WebGLTextures: Trying to use " + e2 + " texture units while this GPU supports only " + t2), h2 += 1, e2;
    }, this.resetTextureUnits = function() {
      h2 = 0;
    }, this.setTexture2D = d2, this.setTexture2DArray = function(e2, t3) {
      var r3 = v2.get(e2);
      0 < e2.version && r3.__version !== e2.version ? L(r3, e2, t3) : (g2.activeTexture(33984 + t3), g2.bindTexture(35866, r3.__webglTexture));
    }, this.setTexture3D = function(e2, t3) {
      var r3 = v2.get(e2);
      0 < e2.version && r3.__version !== e2.version ? L(r3, e2, t3) : (g2.activeTexture(33984 + t3), g2.bindTexture(32879, r3.__webglTexture));
    }, this.setTextureCube = p2, this.setupRenderTarget = function(r3) {
      const t3 = r3.texture, n3 = v2.get(r3), i3 = v2.get(t3);
      r3.addEventListener("dispose", k2), r3.isWebGLMultipleRenderTargets !== true && (i3.__webglTexture = m2.createTexture(), i3.__version = t3.version, b2.memory.textures++);
      var e2, a3 = r3.isWebGLCubeRenderTarget === true, o3 = r3.isWebGLMultipleRenderTargets === true, s3 = r3.isWebGLMultisampleRenderTarget === true, l3 = t3.isDataTexture3D || t3.isDataTexture2DArray, c3 = S2(r3) || x2;
      if (!x2 || t3.format !== RGBFormat || t3.type !== FloatType && t3.type !== HalfFloatType || (t3.format = RGBAFormat, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), a3) {
        n3.__webglFramebuffer = [];
        for (let e3 = 0; e3 < 6; e3++)
          n3.__webglFramebuffer[e3] = m2.createFramebuffer();
      } else if (n3.__webglFramebuffer = m2.createFramebuffer(), o3)
        if (y.drawBuffers) {
          var u3 = r3.texture;
          for (let e3 = 0, t4 = u3.length; e3 < t4; e3++) {
            const f3 = v2.get(u3[e3]);
            f3.__webglTexture === void 0 && (f3.__webglTexture = m2.createTexture(), b2.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      else
        s3 && (x2 ? (n3.__webglMultisampledFramebuffer = m2.createFramebuffer(), n3.__webglColorRenderbuffer = m2.createRenderbuffer(), m2.bindRenderbuffer(36161, n3.__webglColorRenderbuffer), e2 = _2.convert(t3.format), s3 = _2.convert(t3.type), e2 = T2(t3.internalFormat, e2, s3, t3.encoding), s3 = D(r3), m2.renderbufferStorageMultisample(36161, s3, e2, r3.width, r3.height), g2.bindFramebuffer(36160, n3.__webglMultisampledFramebuffer), m2.framebufferRenderbuffer(36160, 36064, 36161, n3.__webglColorRenderbuffer), m2.bindRenderbuffer(36161, null), r3.depthBuffer && (n3.__webglDepthRenderbuffer = m2.createRenderbuffer(), P2(n3.__webglDepthRenderbuffer, r3, true)), g2.bindFramebuffer(36160, null)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."));
      if (a3) {
        g2.bindTexture(34067, i3.__webglTexture), $2(34067, t3, c3);
        for (let e3 = 0; e3 < 6; e3++)
          O(n3.__webglFramebuffer[e3], r3, t3, 36064, 34069 + e3);
        M2(t3, c3) && E2(34067, t3, r3.width, r3.height), g2.unbindTexture();
      } else if (o3) {
        var h3 = r3.texture;
        for (let e3 = 0, t4 = h3.length; e3 < t4; e3++) {
          var d3 = h3[e3], p3 = v2.get(d3);
          g2.bindTexture(3553, p3.__webglTexture), $2(3553, d3, c3), O(n3.__webglFramebuffer, r3, d3, 36064 + e3, 3553), M2(d3, c3) && E2(3553, d3, r3.width, r3.height);
        }
        g2.unbindTexture();
      } else {
        let e3 = 3553;
        l3 && (x2 ? (l3 = t3.isDataTexture3D, e3 = l3 ? 32879 : 35866) : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), g2.bindTexture(e3, i3.__webglTexture), $2(e3, t3, c3), O(n3.__webglFramebuffer, r3, t3, 36064, e3), M2(t3, c3) && E2(e3, t3, r3.width, r3.height, r3.depth), g2.unbindTexture();
      }
      r3.depthBuffer && I2(r3);
    }, this.updateRenderTargetMipmap = function(r3) {
      var n3 = S2(r3) || x2, i3 = r3.isWebGLMultipleRenderTargets === true ? r3.texture : [r3.texture];
      for (let e2 = 0, t3 = i3.length; e2 < t3; e2++) {
        var a3, o3, s3 = i3[e2];
        M2(s3, n3) && (a3 = r3.isWebGLCubeRenderTarget ? 34067 : 3553, o3 = v2.get(s3).__webglTexture, g2.bindTexture(a3, o3), E2(a3, s3, r3.width, r3.height), g2.unbindTexture());
      }
    }, this.updateMultisampleRenderTarget = function(t3) {
      if (t3.isWebGLMultisampleRenderTarget)
        if (x2) {
          var r3 = t3.width, n3 = t3.height;
          let e2 = 16384;
          t3.depthBuffer && (e2 |= 256), t3.stencilBuffer && (e2 |= 1024);
          t3 = v2.get(t3);
          g2.bindFramebuffer(36008, t3.__webglMultisampledFramebuffer), g2.bindFramebuffer(36009, t3.__webglFramebuffer), m2.blitFramebuffer(0, 0, r3, n3, 0, 0, r3, n3, e2, 9728), g2.bindFramebuffer(36008, null), g2.bindFramebuffer(36009, t3.__webglMultisampledFramebuffer);
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    }, this.safeSetTexture2D = function(e2, t3) {
      e2 && e2.isWebGLRenderTarget && (N2 === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N2 = true), e2 = e2.texture), d2(e2, t3);
    }, this.safeSetTextureCube = function(e2, t3) {
      e2 && e2.isWebGLCubeRenderTarget && (B === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = true), e2 = e2.texture), p2(e2, t3);
    };
  }
  function WebGLUtils(e2, r2, t2) {
    const n2 = t2.isWebGL2;
    return { convert: function(e3) {
      let t3;
      if (e3 === UnsignedByteType)
        return 5121;
      if (e3 === UnsignedShort4444Type)
        return 32819;
      if (e3 === UnsignedShort5551Type)
        return 32820;
      if (e3 === UnsignedShort565Type)
        return 33635;
      if (e3 === ByteType)
        return 5120;
      if (e3 === ShortType)
        return 5122;
      if (e3 === UnsignedShortType)
        return 5123;
      if (e3 === IntType)
        return 5124;
      if (e3 === UnsignedIntType)
        return 5125;
      if (e3 === FloatType)
        return 5126;
      if (e3 === HalfFloatType)
        return n2 ? 5131 : (t3 = r2.get("OES_texture_half_float"), t3 !== null ? t3.HALF_FLOAT_OES : null);
      if (e3 === AlphaFormat)
        return 6406;
      if (e3 === RGBFormat)
        return 6407;
      if (e3 === RGBAFormat)
        return 6408;
      if (e3 === LuminanceFormat)
        return 6409;
      if (e3 === LuminanceAlphaFormat)
        return 6410;
      if (e3 === DepthFormat)
        return 6402;
      if (e3 === DepthStencilFormat)
        return 34041;
      if (e3 === RedFormat)
        return 6403;
      if (e3 === RedIntegerFormat)
        return 36244;
      if (e3 === RGFormat)
        return 33319;
      if (e3 === RGIntegerFormat)
        return 33320;
      if (e3 === RGBIntegerFormat)
        return 36248;
      if (e3 === RGBAIntegerFormat)
        return 36249;
      if (e3 === RGB_S3TC_DXT1_Format || e3 === RGBA_S3TC_DXT1_Format || e3 === RGBA_S3TC_DXT3_Format || e3 === RGBA_S3TC_DXT5_Format) {
        if (t3 = r2.get("WEBGL_compressed_texture_s3tc"), t3 === null)
          return null;
        if (e3 === RGB_S3TC_DXT1_Format)
          return t3.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e3 === RGBA_S3TC_DXT1_Format)
          return t3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e3 === RGBA_S3TC_DXT3_Format)
          return t3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e3 === RGBA_S3TC_DXT5_Format)
          return t3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (e3 === RGB_PVRTC_4BPPV1_Format || e3 === RGB_PVRTC_2BPPV1_Format || e3 === RGBA_PVRTC_4BPPV1_Format || e3 === RGBA_PVRTC_2BPPV1_Format) {
        if (t3 = r2.get("WEBGL_compressed_texture_pvrtc"), t3 === null)
          return null;
        if (e3 === RGB_PVRTC_4BPPV1_Format)
          return t3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e3 === RGB_PVRTC_2BPPV1_Format)
          return t3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e3 === RGBA_PVRTC_4BPPV1_Format)
          return t3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e3 === RGBA_PVRTC_2BPPV1_Format)
          return t3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (e3 === RGB_ETC1_Format)
        return t3 = r2.get("WEBGL_compressed_texture_etc1"), t3 !== null ? t3.COMPRESSED_RGB_ETC1_WEBGL : null;
      if ((e3 === RGB_ETC2_Format || e3 === RGBA_ETC2_EAC_Format) && (t3 = r2.get("WEBGL_compressed_texture_etc"), t3 !== null)) {
        if (e3 === RGB_ETC2_Format)
          return t3.COMPRESSED_RGB8_ETC2;
        if (e3 === RGBA_ETC2_EAC_Format)
          return t3.COMPRESSED_RGBA8_ETC2_EAC;
      }
      return e3 === RGBA_ASTC_4x4_Format || e3 === RGBA_ASTC_5x4_Format || e3 === RGBA_ASTC_5x5_Format || e3 === RGBA_ASTC_6x5_Format || e3 === RGBA_ASTC_6x6_Format || e3 === RGBA_ASTC_8x5_Format || e3 === RGBA_ASTC_8x6_Format || e3 === RGBA_ASTC_8x8_Format || e3 === RGBA_ASTC_10x5_Format || e3 === RGBA_ASTC_10x6_Format || e3 === RGBA_ASTC_10x8_Format || e3 === RGBA_ASTC_10x10_Format || e3 === RGBA_ASTC_12x10_Format || e3 === RGBA_ASTC_12x12_Format || e3 === SRGB8_ALPHA8_ASTC_4x4_Format || e3 === SRGB8_ALPHA8_ASTC_5x4_Format || e3 === SRGB8_ALPHA8_ASTC_5x5_Format || e3 === SRGB8_ALPHA8_ASTC_6x5_Format || e3 === SRGB8_ALPHA8_ASTC_6x6_Format || e3 === SRGB8_ALPHA8_ASTC_8x5_Format || e3 === SRGB8_ALPHA8_ASTC_8x6_Format || e3 === SRGB8_ALPHA8_ASTC_8x8_Format || e3 === SRGB8_ALPHA8_ASTC_10x5_Format || e3 === SRGB8_ALPHA8_ASTC_10x6_Format || e3 === SRGB8_ALPHA8_ASTC_10x8_Format || e3 === SRGB8_ALPHA8_ASTC_10x10_Format || e3 === SRGB8_ALPHA8_ASTC_12x10_Format || e3 === SRGB8_ALPHA8_ASTC_12x12_Format ? (t3 = r2.get("WEBGL_compressed_texture_astc"), t3 !== null ? e3 : null) : e3 === RGBA_BPTC_Format ? (t3 = r2.get("EXT_texture_compression_bptc"), t3 !== null ? e3 : null) : e3 === UnsignedInt248Type ? n2 ? 34042 : (t3 = r2.get("WEBGL_depth_texture"), t3 !== null ? t3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    } };
  }
  class ArrayCamera extends PerspectiveCamera {
    constructor(e2 = []) {
      super(), this.cameras = e2;
    }
  }
  ArrayCamera.prototype.isArrayCamera = true;
  class Group extends Object3D {
    constructor() {
      super(), this.type = "Group";
    }
  }
  Group.prototype.isGroup = true;
  const _moveEvent = { type: "move" };
  class WebXRController {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Group(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Vector3()), this._grip;
    }
    dispatchEvent(e2) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e2), this._grip !== null && this._grip.dispatchEvent(e2), this._hand !== null && this._hand.dispatchEvent(e2), this;
    }
    disconnect(e2) {
      return this.dispatchEvent({ type: "disconnected", data: e2 }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(e2, t2, r2) {
      let n2 = null, i2 = null, a2 = null;
      const o2 = this._targetRay, s2 = this._grip, l2 = this._hand;
      if (e2 && t2.session.visibilityState !== "visible-blurred")
        if (o2 !== null && (n2 = t2.getPose(e2.targetRaySpace, r2), n2 !== null && (o2.matrix.fromArray(n2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), n2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(n2.linearVelocity)) : o2.hasLinearVelocity = false, n2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(n2.angularVelocity)) : o2.hasAngularVelocity = false, this.dispatchEvent(_moveEvent))), l2 && e2.hand) {
          a2 = true;
          for (const d2 of e2.hand.values()) {
            var c2 = t2.getJointPose(d2, r2);
            if (l2.joints[d2.jointName] === void 0) {
              const f2 = new Group();
              f2.matrixAutoUpdate = false, f2.visible = false, l2.joints[d2.jointName] = f2, l2.add(f2);
            }
            const p2 = l2.joints[d2.jointName];
            c2 !== null && (p2.matrix.fromArray(c2.transform.matrix), p2.matrix.decompose(p2.position, p2.rotation, p2.scale), p2.jointRadius = c2.radius), p2.visible = c2 !== null;
          }
          const h2 = l2.joints["index-finger-tip"];
          var u2 = l2.joints["thumb-tip"], u2 = h2.position.distanceTo(u2.position);
          l2.inputState.pinching && 0.025 < u2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e2.handedness, target: this })) : !l2.inputState.pinching && u2 <= 0.015 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e2.handedness, target: this }));
        } else
          s2 !== null && e2.gripSpace && (i2 = t2.getPose(e2.gripSpace, r2), i2 !== null && (s2.matrix.fromArray(i2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale), i2.linearVelocity ? (s2.hasLinearVelocity = true, s2.linearVelocity.copy(i2.linearVelocity)) : s2.hasLinearVelocity = false, i2.angularVelocity ? (s2.hasAngularVelocity = true, s2.angularVelocity.copy(i2.angularVelocity)) : s2.hasAngularVelocity = false));
      return o2 !== null && (o2.visible = n2 !== null), s2 !== null && (s2.visible = i2 !== null), l2 !== null && (l2.visible = a2 !== null), this;
    }
  }
  class WebXRManager extends EventDispatcher {
    constructor(e2, u2) {
      super();
      const r2 = this, h2 = e2.state;
      let d2 = null, n2 = 1, p2 = null, i2 = "local-floor", f2 = null, m2 = null, g2 = null, v2 = null, y = null, _2 = false, b2 = null, a2 = null, o2 = null, x2 = null, w2 = null, S2 = null;
      const M2 = [], s2 = new Map(), l2 = new PerspectiveCamera();
      l2.layers.enable(1), l2.viewport = new Vector4();
      const c2 = new PerspectiveCamera();
      c2.layers.enable(2), c2.viewport = new Vector4();
      const E2 = [l2, c2], T2 = new ArrayCamera();
      T2.layers.enable(1), T2.layers.enable(2);
      let k2 = null, A2 = null;
      function C2(e3) {
        const t2 = s2.get(e3.inputSource);
        t2 && t2.dispatchEvent({ type: e3.type, data: e3.inputSource });
      }
      function $2() {
        s2.forEach(function(e3, t2) {
          e3.disconnect(t2);
        }), s2.clear(), k2 = null, A2 = null, h2.bindXRFramebuffer(null), e2.setRenderTarget(e2.getRenderTarget()), g2 && u2.deleteFramebuffer(g2), b2 && u2.deleteFramebuffer(b2), a2 && u2.deleteRenderbuffer(a2), o2 && u2.deleteRenderbuffer(o2), g2 = null, b2 = null, a2 = null, o2 = null, y = null, v2 = null, m2 = null, d2 = null, D.stop(), r2.isPresenting = false, r2.dispatchEvent({ type: "sessionend" });
      }
      function R2(t2) {
        var r3 = d2.inputSources;
        for (let e3 = 0; e3 < M2.length; e3++)
          s2.set(r3[e3], M2[e3]);
        for (let e3 = 0; e3 < t2.removed.length; e3++) {
          var n3 = t2.removed[e3];
          const a3 = s2.get(n3);
          a3 && (a3.dispatchEvent({ type: "disconnected", data: n3 }), s2.delete(n3));
        }
        for (let e3 = 0; e3 < t2.added.length; e3++) {
          var i3 = t2.added[e3];
          const o3 = s2.get(i3);
          o3 && o3.dispatchEvent({ type: "connected", data: i3 });
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(e3) {
        let t2 = M2[e3];
        return t2 === void 0 && (t2 = new WebXRController(), M2[e3] = t2), t2.getTargetRaySpace();
      }, this.getControllerGrip = function(e3) {
        let t2 = M2[e3];
        return t2 === void 0 && (t2 = new WebXRController(), M2[e3] = t2), t2.getGripSpace();
      }, this.getHand = function(e3) {
        let t2 = M2[e3];
        return t2 === void 0 && (t2 = new WebXRController(), M2[e3] = t2), t2.getHandSpace();
      }, this.setFramebufferScaleFactor = function(e3) {
        n2 = e3, r2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(e3) {
        i2 = e3, r2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return p2;
      }, this.getBaseLayer = function() {
        return v2 !== null ? v2 : y;
      }, this.getBinding = function() {
        return m2;
      }, this.getFrame = function() {
        return x2;
      }, this.getSession = function() {
        return d2;
      }, this.setSession = function(t2) {
        return __async(this, null, function* () {
          if (d2 = t2, d2 !== null) {
            d2.addEventListener("select", C2), d2.addEventListener("selectstart", C2), d2.addEventListener("selectend", C2), d2.addEventListener("squeeze", C2), d2.addEventListener("squeezestart", C2), d2.addEventListener("squeezeend", C2), d2.addEventListener("end", $2), d2.addEventListener("inputsourceschange", R2);
            t2 = u2.getContextAttributes();
            if (t2.xrCompatible !== true && (yield u2.makeXRCompatible()), d2.renderState.layers === void 0) {
              var e3 = { antialias: t2.antialias, alpha: t2.alpha, depth: t2.depth, stencil: t2.stencil, framebufferScaleFactor: n2 };
              y = new XRWebGLLayer(d2, u2, e3), d2.updateRenderState({ baseLayer: y });
            } else if (u2 instanceof WebGLRenderingContext) {
              e3 = { antialias: true, alpha: t2.alpha, depth: t2.depth, stencil: t2.stencil, framebufferScaleFactor: n2 };
              y = new XRWebGLLayer(d2, u2, e3), d2.updateRenderState({ layers: [y] });
            } else {
              _2 = t2.antialias;
              let e4 = null;
              t2.depth && (S2 = 256, t2.stencil && (S2 |= 1024), w2 = t2.stencil ? 33306 : 36096, e4 = t2.stencil ? 35056 : 33190);
              t2 = { colorFormat: t2.alpha ? 32856 : 32849, depthFormat: e4, scaleFactor: n2 };
              m2 = new XRWebGLBinding(d2, u2), v2 = m2.createProjectionLayer(t2), g2 = u2.createFramebuffer(), d2.updateRenderState({ layers: [v2] }), _2 && (b2 = u2.createFramebuffer(), a2 = u2.createRenderbuffer(), u2.bindRenderbuffer(36161, a2), u2.renderbufferStorageMultisample(36161, 4, 32856, v2.textureWidth, v2.textureHeight), h2.bindFramebuffer(36160, b2), u2.framebufferRenderbuffer(36160, 36064, 36161, a2), u2.bindRenderbuffer(36161, null), e4 !== null && (o2 = u2.createRenderbuffer(), u2.bindRenderbuffer(36161, o2), u2.renderbufferStorageMultisample(36161, 4, e4, v2.textureWidth, v2.textureHeight), u2.framebufferRenderbuffer(36160, w2, 36161, o2), u2.bindRenderbuffer(36161, null)), h2.bindFramebuffer(36160, null));
            }
            p2 = yield d2.requestReferenceSpace(i2), D.setContext(d2), D.start(), r2.isPresenting = true, r2.dispatchEvent({ type: "sessionstart" });
          }
        });
      };
      const L = new Vector3(), O = new Vector3();
      function P2(e3, t2) {
        t2 === null ? e3.matrixWorld.copy(e3.matrix) : e3.matrixWorld.multiplyMatrices(t2.matrixWorld, e3.matrix), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
      }
      this.updateCamera = function(e3) {
        if (d2 !== null) {
          T2.near = c2.near = l2.near = e3.near, T2.far = c2.far = l2.far = e3.far, k2 === T2.near && A2 === T2.far || (d2.updateRenderState({ depthNear: T2.near, depthFar: T2.far }), k2 = T2.near, A2 = T2.far);
          var t2 = e3.parent, r3 = T2.cameras;
          P2(T2, t2);
          for (let e4 = 0; e4 < r3.length; e4++)
            P2(r3[e4], t2);
          T2.matrixWorld.decompose(T2.position, T2.quaternion, T2.scale), e3.position.copy(T2.position), e3.quaternion.copy(T2.quaternion), e3.scale.copy(T2.scale), e3.matrix.copy(T2.matrix), e3.matrixWorld.copy(T2.matrixWorld);
          const n3 = e3.children;
          for (let e4 = 0, t3 = n3.length; e4 < t3; e4++)
            n3[e4].updateMatrixWorld(true);
          r3.length === 2 ? function(e4, t3, r4) {
            L.setFromMatrixPosition(t3.matrixWorld), O.setFromMatrixPosition(r4.matrixWorld);
            var n4 = L.distanceTo(O), i3 = t3.projectionMatrix.elements, a3 = r4.projectionMatrix.elements, o3 = i3[14] / (i3[10] - 1), s3 = i3[14] / (i3[10] + 1), l3 = (i3[9] + 1) / i3[5], c3 = (i3[9] - 1) / i3[5], u3 = (i3[8] - 1) / i3[0], r4 = (a3[8] + 1) / a3[0], i3 = o3 * u3, a3 = o3 * r4, u3 = (r4 = n4 / (r4 - u3)) * -u3;
            t3.matrixWorld.decompose(e4.position, e4.quaternion, e4.scale), e4.translateX(u3), e4.translateZ(r4), e4.matrixWorld.compose(e4.position, e4.quaternion, e4.scale), e4.matrixWorldInverse.copy(e4.matrixWorld).invert(), o3 += r4, r4 = s3 + r4, e4.projectionMatrix.makePerspective(i3 - u3, n4 - u3 + a3, l3 * s3 / r4 * o3, c3 * s3 / r4 * o3, o3, r4);
          }(T2, l2, c2) : T2.projectionMatrix.copy(l2.projectionMatrix);
        }
      }, this.getCamera = function() {
        return T2;
      }, this.getFoveation = function() {
        return v2 !== null ? v2.fixedFoveation : y !== null ? y.fixedFoveation : void 0;
      }, this.setFoveation = function(e3) {
        v2 !== null && (v2.fixedFoveation = e3), y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = e3);
      };
      let I2 = null;
      const D = new WebGLAnimation();
      D.setAnimationLoop(function(e3, t2) {
        if (f2 = t2.getViewerPose(p2), x2 = t2, f2 !== null) {
          var n3 = f2.views;
          y !== null && h2.bindXRFramebuffer(y.framebuffer);
          let r4 = false;
          n3.length !== T2.cameras.length && (T2.cameras.length = 0, r4 = true);
          for (let t3 = 0; t3 < n3.length; t3++) {
            var i3, a3 = n3[t3];
            let e4 = null;
            e4 = y !== null ? y.getViewport(a3) : (i3 = m2.getViewSubImage(v2, a3), h2.bindXRFramebuffer(g2), i3.depthStencilTexture !== void 0 && u2.framebufferTexture2D(36160, w2, 3553, i3.depthStencilTexture, 0), u2.framebufferTexture2D(36160, 36064, 3553, i3.colorTexture, 0), i3.viewport);
            const l3 = E2[t3];
            l3.matrix.fromArray(a3.transform.matrix), l3.projectionMatrix.fromArray(a3.projectionMatrix), l3.viewport.set(e4.x, e4.y, e4.width, e4.height), t3 === 0 && T2.matrix.copy(l3.matrix), r4 === true && T2.cameras.push(l3);
          }
          _2 && (h2.bindXRFramebuffer(b2), S2 !== null && u2.clear(S2));
        }
        var r3, o3 = d2.inputSources;
        for (let e4 = 0; e4 < M2.length; e4++) {
          const c3 = M2[e4];
          var s3 = o3[e4];
          c3.update(s3, t2, p2);
        }
        I2 && I2(e3, t2), _2 && (r3 = v2.textureWidth, e3 = v2.textureHeight, h2.bindFramebuffer(36008, b2), h2.bindFramebuffer(36009, g2), u2.invalidateFramebuffer(36008, [w2]), u2.invalidateFramebuffer(36009, [w2]), u2.blitFramebuffer(0, 0, r3, e3, 0, 0, r3, e3, 16384, 9728), u2.invalidateFramebuffer(36008, [36064]), h2.bindFramebuffer(36008, null), h2.bindFramebuffer(36009, null), h2.bindFramebuffer(36160, b2)), x2 = null;
      }), this.setAnimationLoop = function(e3) {
        I2 = e3;
      }, this.dispose = function() {
      };
    }
  }
  function WebGLMaterials(a2) {
    function c2(e2, t2) {
      e2.opacity.value = t2.opacity, t2.color && e2.diffuse.value.copy(t2.color), t2.emissive && e2.emissive.value.copy(t2.emissive).multiplyScalar(t2.emissiveIntensity), t2.map && (e2.map.value = t2.map), t2.alphaMap && (e2.alphaMap.value = t2.alphaMap), t2.specularMap && (e2.specularMap.value = t2.specularMap), 0 < t2.alphaTest && (e2.alphaTest.value = t2.alphaTest);
      var r2 = a2.get(t2).envMap;
      r2 && (e2.envMap.value = r2, e2.flipEnvMap.value = r2.isCubeTexture && r2.isRenderTargetTexture === false ? -1 : 1, e2.reflectivity.value = t2.reflectivity, e2.ior.value = t2.ior, e2.refractionRatio.value = t2.refractionRatio, (r2 = a2.get(r2).__maxMipLevel) !== void 0 && (e2.maxMipLevel.value = r2)), t2.lightMap && (e2.lightMap.value = t2.lightMap, e2.lightMapIntensity.value = t2.lightMapIntensity), t2.aoMap && (e2.aoMap.value = t2.aoMap, e2.aoMapIntensity.value = t2.aoMapIntensity);
      let n2;
      t2.map ? n2 = t2.map : t2.specularMap ? n2 = t2.specularMap : t2.displacementMap ? n2 = t2.displacementMap : t2.normalMap ? n2 = t2.normalMap : t2.bumpMap ? n2 = t2.bumpMap : t2.roughnessMap ? n2 = t2.roughnessMap : t2.metalnessMap ? n2 = t2.metalnessMap : t2.alphaMap ? n2 = t2.alphaMap : t2.emissiveMap ? n2 = t2.emissiveMap : t2.clearcoatMap ? n2 = t2.clearcoatMap : t2.clearcoatNormalMap ? n2 = t2.clearcoatNormalMap : t2.clearcoatRoughnessMap ? n2 = t2.clearcoatRoughnessMap : t2.specularIntensityMap ? n2 = t2.specularIntensityMap : t2.specularColorMap ? n2 = t2.specularColorMap : t2.transmissionMap ? n2 = t2.transmissionMap : t2.thicknessMap ? n2 = t2.thicknessMap : t2.sheenColorMap ? n2 = t2.sheenColorMap : t2.sheenRoughnessMap && (n2 = t2.sheenRoughnessMap), n2 !== void 0 && (n2.isWebGLRenderTarget && (n2 = n2.texture), n2.matrixAutoUpdate === true && n2.updateMatrix(), e2.uvTransform.value.copy(n2.matrix));
      let i2;
      t2.aoMap ? i2 = t2.aoMap : t2.lightMap && (i2 = t2.lightMap), i2 !== void 0 && (i2.isWebGLRenderTarget && (i2 = i2.texture), i2.matrixAutoUpdate === true && i2.updateMatrix(), e2.uv2Transform.value.copy(i2.matrix));
    }
    function u2(e2, t2) {
      e2.roughness.value = t2.roughness, e2.metalness.value = t2.metalness, t2.roughnessMap && (e2.roughnessMap.value = t2.roughnessMap), t2.metalnessMap && (e2.metalnessMap.value = t2.metalnessMap), t2.emissiveMap && (e2.emissiveMap.value = t2.emissiveMap), t2.bumpMap && (e2.bumpMap.value = t2.bumpMap, e2.bumpScale.value = t2.bumpScale, t2.side === BackSide && (e2.bumpScale.value *= -1)), t2.normalMap && (e2.normalMap.value = t2.normalMap, e2.normalScale.value.copy(t2.normalScale), t2.side === BackSide && e2.normalScale.value.negate()), t2.displacementMap && (e2.displacementMap.value = t2.displacementMap, e2.displacementScale.value = t2.displacementScale, e2.displacementBias.value = t2.displacementBias), a2.get(t2).envMap && (e2.envMapIntensity.value = t2.envMapIntensity);
    }
    return { refreshFogUniforms: function(e2, t2) {
      e2.fogColor.value.copy(t2.color), t2.isFog ? (e2.fogNear.value = t2.near, e2.fogFar.value = t2.far) : t2.isFogExp2 && (e2.fogDensity.value = t2.density);
    }, refreshMaterialUniforms: function(e2, t2, r2, n2, i2) {
      var a3, o2, s2, l2;
      t2.isMeshBasicMaterial ? c2(e2, t2) : t2.isMeshLambertMaterial ? (c2(e2, t2), s2 = e2, (l2 = t2).emissiveMap && (s2.emissiveMap.value = l2.emissiveMap)) : t2.isMeshToonMaterial ? (c2(e2, t2), function(e3, t3) {
        t3.gradientMap && (e3.gradientMap.value = t3.gradientMap);
        t3.emissiveMap && (e3.emissiveMap.value = t3.emissiveMap);
        t3.bumpMap && (e3.bumpMap.value = t3.bumpMap, e3.bumpScale.value = t3.bumpScale, t3.side === BackSide && (e3.bumpScale.value *= -1));
        t3.normalMap && (e3.normalMap.value = t3.normalMap, e3.normalScale.value.copy(t3.normalScale), t3.side === BackSide && e3.normalScale.value.negate());
        t3.displacementMap && (e3.displacementMap.value = t3.displacementMap, e3.displacementScale.value = t3.displacementScale, e3.displacementBias.value = t3.displacementBias);
      }(e2, t2)) : t2.isMeshPhongMaterial ? (c2(e2, t2), function(e3, t3) {
        e3.specular.value.copy(t3.specular), e3.shininess.value = Math.max(t3.shininess, 1e-4), t3.emissiveMap && (e3.emissiveMap.value = t3.emissiveMap);
        t3.bumpMap && (e3.bumpMap.value = t3.bumpMap, e3.bumpScale.value = t3.bumpScale, t3.side === BackSide && (e3.bumpScale.value *= -1));
        t3.normalMap && (e3.normalMap.value = t3.normalMap, e3.normalScale.value.copy(t3.normalScale), t3.side === BackSide && e3.normalScale.value.negate());
        t3.displacementMap && (e3.displacementMap.value = t3.displacementMap, e3.displacementScale.value = t3.displacementScale, e3.displacementBias.value = t3.displacementBias);
      }(e2, t2)) : t2.isMeshStandardMaterial ? (c2(e2, t2), t2.isMeshPhysicalMaterial ? function(e3, t3, r3) {
        u2(e3, t3), e3.ior.value = t3.ior, 0 < t3.sheen && (e3.sheenColor.value.copy(t3.sheenColor).multiplyScalar(t3.sheen), e3.sheenRoughness.value = t3.sheenRoughness, t3.sheenColorMap && (e3.sheenColorMap.value = t3.sheenColorMap), t3.sheenRoughnessMap && (e3.sheenRoughnessMap.value = t3.sheenRoughnessMap));
        0 < t3.clearcoat && (e3.clearcoat.value = t3.clearcoat, e3.clearcoatRoughness.value = t3.clearcoatRoughness, t3.clearcoatMap && (e3.clearcoatMap.value = t3.clearcoatMap), t3.clearcoatRoughnessMap && (e3.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap), t3.clearcoatNormalMap && (e3.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), e3.clearcoatNormalMap.value = t3.clearcoatNormalMap, t3.side === BackSide && e3.clearcoatNormalScale.value.negate()));
        0 < t3.transmission && (e3.transmission.value = t3.transmission, e3.transmissionSamplerMap.value = r3.texture, e3.transmissionSamplerSize.value.set(r3.width, r3.height), t3.transmissionMap && (e3.transmissionMap.value = t3.transmissionMap), e3.thickness.value = t3.thickness, t3.thicknessMap && (e3.thicknessMap.value = t3.thicknessMap), e3.attenuationDistance.value = t3.attenuationDistance, e3.attenuationColor.value.copy(t3.attenuationColor));
        e3.specularIntensity.value = t3.specularIntensity, e3.specularColor.value.copy(t3.specularColor), t3.specularIntensityMap && (e3.specularIntensityMap.value = t3.specularIntensityMap);
        t3.specularColorMap && (e3.specularColorMap.value = t3.specularColorMap);
      }(e2, t2, i2) : u2(e2, t2)) : t2.isMeshMatcapMaterial ? (c2(e2, t2), function(e3, t3) {
        t3.matcap && (e3.matcap.value = t3.matcap);
        t3.bumpMap && (e3.bumpMap.value = t3.bumpMap, e3.bumpScale.value = t3.bumpScale, t3.side === BackSide && (e3.bumpScale.value *= -1));
        t3.normalMap && (e3.normalMap.value = t3.normalMap, e3.normalScale.value.copy(t3.normalScale), t3.side === BackSide && e3.normalScale.value.negate());
        t3.displacementMap && (e3.displacementMap.value = t3.displacementMap, e3.displacementScale.value = t3.displacementScale, e3.displacementBias.value = t3.displacementBias);
      }(e2, t2)) : t2.isMeshDepthMaterial ? (c2(e2, t2), a3 = e2, (o2 = t2).displacementMap && (a3.displacementMap.value = o2.displacementMap, a3.displacementScale.value = o2.displacementScale, a3.displacementBias.value = o2.displacementBias)) : t2.isMeshDistanceMaterial ? (c2(e2, t2), function(e3, t3) {
        t3.displacementMap && (e3.displacementMap.value = t3.displacementMap, e3.displacementScale.value = t3.displacementScale, e3.displacementBias.value = t3.displacementBias);
        e3.referencePosition.value.copy(t3.referencePosition), e3.nearDistance.value = t3.nearDistance, e3.farDistance.value = t3.farDistance;
      }(e2, t2)) : t2.isMeshNormalMaterial ? (c2(e2, t2), function(e3, t3) {
        t3.bumpMap && (e3.bumpMap.value = t3.bumpMap, e3.bumpScale.value = t3.bumpScale, t3.side === BackSide && (e3.bumpScale.value *= -1));
        t3.normalMap && (e3.normalMap.value = t3.normalMap, e3.normalScale.value.copy(t3.normalScale), t3.side === BackSide && e3.normalScale.value.negate());
        t3.displacementMap && (e3.displacementMap.value = t3.displacementMap, e3.displacementScale.value = t3.displacementScale, e3.displacementBias.value = t3.displacementBias);
      }(e2, t2)) : t2.isLineBasicMaterial ? (a3 = t2, (o2 = e2).diffuse.value.copy(a3.color), o2.opacity.value = a3.opacity, t2.isLineDashedMaterial && (o2 = t2, (a3 = e2).dashSize.value = o2.dashSize, a3.totalSize.value = o2.dashSize + o2.gapSize, a3.scale.value = o2.scale)) : t2.isPointsMaterial ? function(e3, t3, r3, n3) {
        e3.diffuse.value.copy(t3.color), e3.opacity.value = t3.opacity, e3.size.value = t3.size * r3, e3.scale.value = 0.5 * n3, t3.map && (e3.map.value = t3.map);
        t3.alphaMap && (e3.alphaMap.value = t3.alphaMap);
        0 < t3.alphaTest && (e3.alphaTest.value = t3.alphaTest);
        let i3;
        t3.map ? i3 = t3.map : t3.alphaMap && (i3 = t3.alphaMap);
        i3 !== void 0 && (i3.matrixAutoUpdate === true && i3.updateMatrix(), e3.uvTransform.value.copy(i3.matrix));
      }(e2, t2, r2, n2) : t2.isSpriteMaterial ? function(e3, t3) {
        e3.diffuse.value.copy(t3.color), e3.opacity.value = t3.opacity, e3.rotation.value = t3.rotation, t3.map && (e3.map.value = t3.map);
        t3.alphaMap && (e3.alphaMap.value = t3.alphaMap);
        0 < t3.alphaTest && (e3.alphaTest.value = t3.alphaTest);
        let r3;
        t3.map ? r3 = t3.map : t3.alphaMap && (r3 = t3.alphaMap);
        r3 !== void 0 && (r3.matrixAutoUpdate === true && r3.updateMatrix(), e3.uvTransform.value.copy(r3.matrix));
      }(e2, t2) : t2.isShadowMaterial ? (e2.color.value.copy(t2.color), e2.opacity.value = t2.opacity) : t2.isShaderMaterial && (t2.uniformsNeedUpdate = false);
    } };
  }
  function createCanvasElement() {
    const e2 = createElementNS("canvas");
    return e2.style.display = "block", e2;
  }
  function WebGLRenderer(e2 = {}) {
    const i2 = e2.canvas !== void 0 ? e2.canvas : createCanvasElement(), t2 = e2.context !== void 0 ? e2.context : null, r2 = e2.alpha !== void 0 && e2.alpha, n2 = e2.depth === void 0 || e2.depth, a2 = e2.stencil === void 0 || e2.stencil, o2 = e2.antialias !== void 0 && e2.antialias, s2 = e2.premultipliedAlpha === void 0 || e2.premultipliedAlpha, l2 = e2.preserveDrawingBuffer !== void 0 && e2.preserveDrawingBuffer, c2 = e2.powerPreference !== void 0 ? e2.powerPreference : "default", u2 = e2.failIfMajorPerformanceCaveat !== void 0 && e2.failIfMajorPerformanceCaveat;
    let f2 = null, T2 = null;
    const h2 = [], d2 = [];
    this.domElement = i2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = false, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1;
    const k2 = this;
    let p2 = false, m2 = 0, g2 = 0, A2 = null, C2 = -1, $2 = null;
    const v2 = new Vector4(), y = new Vector4();
    let _2 = null, b2 = i2.width, R2 = i2.height, L = 1, x2 = null, w2 = null;
    const S2 = new Vector4(0, 0, b2, R2), M2 = new Vector4(0, 0, b2, R2);
    let E2 = false;
    const O = [], P2 = new Frustum();
    let I2 = false, D = false, N2 = null;
    const B = new Matrix4(), F = new Vector3(), j2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function U() {
      return A2 === null ? L : 1;
    }
    let V2 = t2;
    function z(t3, r3) {
      for (let e3 = 0; e3 < t3.length; e3++) {
        var n3 = t3[e3], n3 = i2.getContext(n3, r3);
        if (n3 !== null)
          return n3;
      }
      return null;
    }
    try {
      var H2 = { alpha: r2, depth: n2, stencil: a2, antialias: o2, premultipliedAlpha: s2, preserveDrawingBuffer: l2, powerPreference: c2, failIfMajorPerformanceCaveat: u2 };
      if (i2.addEventListener("webglcontextlost", ge, false), i2.addEventListener("webglcontextrestored", ve, false), V2 === null) {
        const ke = ["webgl2", "webgl", "experimental-webgl"];
        if (k2.isWebGL1Renderer === true && ke.shift(), V2 = z(ke, H2), V2 === null)
          throw z(ke) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      V2.getShaderPrecisionFormat === void 0 && (V2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (e3) {
      throw console.error("THREE.WebGLRenderer: " + e3.message), e3;
    }
    let G, W, q, Y, X, Z, K, J, Q, ee, te, re, ne, ie, ae, oe, se, le, ce, ue, he, de, pe;
    function fe() {
      G = new WebGLExtensions(V2), W = new WebGLCapabilities(V2, G, e2), G.init(W), de = new WebGLUtils(V2, G, W), q = new WebGLState(V2, G, W), O[0] = 1029, Y = new WebGLInfo(V2), X = new WebGLProperties(), Z = new WebGLTextures(V2, G, q, X, W, de, Y), K = new WebGLCubeMaps(k2), J = new WebGLCubeUVMaps(k2), Q = new WebGLAttributes(V2, W), pe = new WebGLBindingStates(V2, G, Q, W), ee = new WebGLGeometries(V2, Q, Y, pe), te = new WebGLObjects(V2, ee, Q, Y), ce = new WebGLMorphtargets(V2, W, Z), oe = new WebGLClipping(X), re = new WebGLPrograms(k2, K, J, G, W, pe, oe), ne = new WebGLMaterials(X), ie = new WebGLRenderLists(X), ae = new WebGLRenderStates(G, W), le = new WebGLBackground(k2, K, q, te, s2), se = new WebGLShadowMap(k2, te, W), ue = new WebGLBufferRenderer(V2, G, Y, W), he = new WebGLIndexedBufferRenderer(V2, G, Y, W), Y.programs = re.programs, k2.capabilities = W, k2.extensions = G, k2.properties = X, k2.renderLists = ie, k2.shadowMap = se, k2.state = q, k2.info = Y;
    }
    fe();
    const me = new WebXRManager(k2, V2);
    function ge(e3) {
      e3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), p2 = true;
    }
    function ve() {
      console.log("THREE.WebGLRenderer: Context Restored."), p2 = false;
      var e3 = Y.autoReset, t3 = se.enabled, r3 = se.autoUpdate, n3 = se.needsUpdate, i3 = se.type;
      fe(), Y.autoReset = e3, se.enabled = t3, se.autoUpdate = r3, se.needsUpdate = n3, se.type = i3;
    }
    function ye(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", ye), function(e4) {
        const t4 = X.get(e4).programs;
        t4 !== void 0 && t4.forEach(function(e5) {
          re.releaseProgram(e5);
        });
      }(e3 = t3), X.remove(e3);
    }
    this.xr = me, this.getContext = function() {
      return V2;
    }, this.getContextAttributes = function() {
      return V2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const e3 = G.get("WEBGL_lose_context");
      e3 && e3.loseContext();
    }, this.forceContextRestore = function() {
      const e3 = G.get("WEBGL_lose_context");
      e3 && e3.restoreContext();
    }, this.getPixelRatio = function() {
      return L;
    }, this.setPixelRatio = function(e3) {
      e3 !== void 0 && (L = e3, this.setSize(b2, R2, false));
    }, this.getSize = function(e3) {
      return e3.set(b2, R2);
    }, this.setSize = function(e3, t3, r3) {
      me.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (b2 = e3, R2 = t3, i2.width = Math.floor(e3 * L), i2.height = Math.floor(t3 * L), r3 !== false && (i2.style.width = e3 + "px", i2.style.height = t3 + "px"), this.setViewport(0, 0, e3, t3));
    }, this.getDrawingBufferSize = function(e3) {
      return e3.set(b2 * L, R2 * L).floor();
    }, this.setDrawingBufferSize = function(e3, t3, r3) {
      b2 = e3, R2 = t3, L = r3, i2.width = Math.floor(e3 * r3), i2.height = Math.floor(t3 * r3), this.setViewport(0, 0, e3, t3);
    }, this.getCurrentViewport = function(e3) {
      return e3.copy(v2);
    }, this.getViewport = function(e3) {
      return e3.copy(S2);
    }, this.setViewport = function(e3, t3, r3, n3) {
      e3.isVector4 ? S2.set(e3.x, e3.y, e3.z, e3.w) : S2.set(e3, t3, r3, n3), q.viewport(v2.copy(S2).multiplyScalar(L).floor());
    }, this.getScissor = function(e3) {
      return e3.copy(M2);
    }, this.setScissor = function(e3, t3, r3, n3) {
      e3.isVector4 ? M2.set(e3.x, e3.y, e3.z, e3.w) : M2.set(e3, t3, r3, n3), q.scissor(y.copy(M2).multiplyScalar(L).floor());
    }, this.getScissorTest = function() {
      return E2;
    }, this.setScissorTest = function(e3) {
      q.setScissorTest(E2 = e3);
    }, this.setOpaqueSort = function(e3) {
      x2 = e3;
    }, this.setTransparentSort = function(e3) {
      w2 = e3;
    }, this.getClearColor = function(e3) {
      return e3.copy(le.getClearColor());
    }, this.setClearColor = function() {
      le.setClearColor.apply(le, arguments);
    }, this.getClearAlpha = function() {
      return le.getClearAlpha();
    }, this.setClearAlpha = function() {
      le.setClearAlpha.apply(le, arguments);
    }, this.clear = function(e3, t3, r3) {
      let n3 = 0;
      e3 !== void 0 && !e3 || (n3 |= 16384), t3 !== void 0 && !t3 || (n3 |= 256), r3 !== void 0 && !r3 || (n3 |= 1024), V2.clear(n3);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      i2.removeEventListener("webglcontextlost", ge, false), i2.removeEventListener("webglcontextrestored", ve, false), ie.dispose(), ae.dispose(), X.dispose(), K.dispose(), J.dispose(), te.dispose(), pe.dispose(), me.dispose(), me.removeEventListener("sessionstart", be), me.removeEventListener("sessionend", xe), N2 && (N2.dispose(), N2 = null), we.stop();
    }, this.renderBufferDirect = function(e3, t3, r3, n3, i3, a3) {
      t3 === null && (t3 = j2);
      var o3 = i3.isMesh && i3.matrixWorld.determinant() < 0, s3 = function(e4, t4, r4, n4, i4) {
        t4.isScene !== true && (t4 = j2);
        Z.resetTextureUnits();
        const a4 = t4.fog, o4 = n4.isMeshStandardMaterial ? t4.environment : null, s4 = A2 === null ? k2.outputEncoding : A2.texture.encoding, l4 = (n4.isMeshStandardMaterial ? J : K).get(n4.envMap || o4), c4 = n4.vertexColors === true && !!r4.attributes.color && r4.attributes.color.itemSize === 4, u4 = !!n4.normalMap && !!r4.attributes.tangent, h4 = !!r4.morphAttributes.position, d3 = !!r4.morphAttributes.normal, p3 = r4.morphAttributes.position ? r4.morphAttributes.position.length : 0, f3 = X.get(n4), m3 = T2.state.lights;
        {
          var g3;
          I2 === true && (D !== true && e4 === $2 || (g3 = e4 === $2 && n4.id === C2, oe.setState(n4, e4, g3)));
        }
        let v3 = false;
        n4.version === f3.__version ? (f3.needsLights && f3.lightsStateVersion !== m3.state.version || f3.outputEncoding !== s4 || i4.isInstancedMesh && f3.instancing === false || !i4.isInstancedMesh && f3.instancing === true || i4.isSkinnedMesh && f3.skinning === false || !i4.isSkinnedMesh && f3.skinning === true || f3.envMap !== l4 || n4.fog && f3.fog !== a4 || f3.numClippingPlanes !== void 0 && (f3.numClippingPlanes !== oe.numPlanes || f3.numIntersection !== oe.numIntersection) || f3.vertexAlphas !== c4 || f3.vertexTangents !== u4 || f3.morphTargets !== h4 || f3.morphNormals !== d3 || W.isWebGL2 === true && f3.morphTargetsCount !== p3) && (v3 = true) : (v3 = true, f3.__version = n4.version);
        let y2 = f3.currentProgram;
        v3 === true && (y2 = Ee(n4, t4, i4));
        let _3 = false, b3 = false, x3 = false;
        const w3 = y2.getUniforms(), S3 = f3.uniforms;
        q.useProgram(y2.program) && (_3 = true, b3 = true, x3 = true);
        n4.id !== C2 && (C2 = n4.id, b3 = true);
        if (_3 || $2 !== e4) {
          if (w3.setValue(V2, "projectionMatrix", e4.projectionMatrix), W.logarithmicDepthBuffer && w3.setValue(V2, "logDepthBufFC", 2 / (Math.log(e4.far + 1) / Math.LN2)), $2 !== e4 && ($2 = e4, b3 = true, x3 = true), n4.isShaderMaterial || n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshStandardMaterial || n4.envMap) {
            const M3 = w3.map.cameraPosition;
            M3 !== void 0 && M3.setValue(V2, F.setFromMatrixPosition(e4.matrixWorld));
          }
          (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial) && w3.setValue(V2, "isOrthographic", e4.isOrthographicCamera === true), (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial || n4.isShadowMaterial || i4.isSkinnedMesh) && w3.setValue(V2, "viewMatrix", e4.matrixWorldInverse);
        }
        if (i4.isSkinnedMesh) {
          w3.setOptional(V2, i4, "bindMatrix"), w3.setOptional(V2, i4, "bindMatrixInverse");
          const E3 = i4.skeleton;
          E3 && (W.floatVertexTextures ? (E3.boneTexture === null && E3.computeBoneTexture(), w3.setValue(V2, "boneTexture", E3.boneTexture, Z), w3.setValue(V2, "boneTextureSize", E3.boneTextureSize)) : w3.setOptional(V2, E3, "boneMatrices"));
        }
        !r4 || r4.morphAttributes.position === void 0 && r4.morphAttributes.normal === void 0 || ce.update(i4, r4, n4, y2);
        !b3 && f3.receiveShadow === i4.receiveShadow || (f3.receiveShadow = i4.receiveShadow, w3.setValue(V2, "receiveShadow", i4.receiveShadow));
        b3 && (w3.setValue(V2, "toneMappingExposure", k2.toneMappingExposure), f3.needsLights && function(e5, t5) {
          e5.ambientLightColor.needsUpdate = t5, e5.lightProbe.needsUpdate = t5, e5.directionalLights.needsUpdate = t5, e5.directionalLightShadows.needsUpdate = t5, e5.pointLights.needsUpdate = t5, e5.pointLightShadows.needsUpdate = t5, e5.spotLights.needsUpdate = t5, e5.spotLightShadows.needsUpdate = t5, e5.rectAreaLights.needsUpdate = t5, e5.hemisphereLights.needsUpdate = t5;
        }(S3, x3), a4 && n4.fog && ne.refreshFogUniforms(S3, a4), ne.refreshMaterialUniforms(S3, n4, L, R2, N2), WebGLUniforms.upload(V2, f3.uniformsList, S3, Z));
        n4.isShaderMaterial && n4.uniformsNeedUpdate === true && (WebGLUniforms.upload(V2, f3.uniformsList, S3, Z), n4.uniformsNeedUpdate = false);
        n4.isSpriteMaterial && w3.setValue(V2, "center", i4.center);
        return w3.setValue(V2, "modelViewMatrix", i4.modelViewMatrix), w3.setValue(V2, "normalMatrix", i4.normalMatrix), w3.setValue(V2, "modelMatrix", i4.matrixWorld), y2;
      }(e3, t3, r3, n3, i3);
      q.setMaterial(n3, o3);
      let l3 = r3.index;
      e3 = r3.attributes.position;
      if (l3 === null) {
        if (e3 === void 0 || e3.count === 0)
          return;
      } else if (l3.count === 0)
        return;
      let c3 = 1;
      n3.wireframe === true && (l3 = ee.getWireframeAttribute(r3), c3 = 2), pe.setup(i3, n3, s3, r3, l3);
      let u3 = ue;
      l3 !== null && (h3 = Q.get(l3), u3 = he, u3.setIndex(h3));
      var t3 = (l3 !== null ? l3 : e3).count, o3 = r3.drawRange.start * c3, s3 = r3.drawRange.count * c3, h3 = a3 !== null ? a3.start * c3 : 0, e3 = a3 !== null ? a3.count * c3 : 1 / 0, a3 = Math.max(o3, h3), e3 = Math.min(t3, o3 + s3, h3 + e3) - 1, e3 = Math.max(0, e3 - a3 + 1);
      if (e3 !== 0) {
        if (i3.isMesh)
          n3.wireframe === true ? (q.setLineWidth(n3.wireframeLinewidth * U()), u3.setMode(1)) : u3.setMode(4);
        else if (i3.isLine) {
          let e4 = n3.linewidth;
          e4 === void 0 && (e4 = 1), q.setLineWidth(e4 * U()), i3.isLineSegments ? u3.setMode(1) : i3.isLineLoop ? u3.setMode(2) : u3.setMode(3);
        } else
          i3.isPoints ? u3.setMode(0) : i3.isSprite && u3.setMode(4);
        i3.isInstancedMesh ? u3.renderInstances(a3, e3, i3.count) : r3.isInstancedBufferGeometry ? (r3 = Math.min(r3.instanceCount, r3._maxInstanceCount), u3.renderInstances(a3, e3, r3)) : u3.render(a3, e3);
      }
    }, this.compile = function(n3, t3) {
      T2 = ae.get(n3), T2.init(), d2.push(T2), n3.traverseVisible(function(e3) {
        e3.isLight && e3.layers.test(t3.layers) && (T2.pushLight(e3), e3.castShadow && T2.pushShadow(e3));
      }), T2.setupLights(k2.physicallyCorrectLights), n3.traverse(function(t4) {
        var r3 = t4.material;
        if (r3)
          if (Array.isArray(r3))
            for (let e3 = 0; e3 < r3.length; e3++)
              Ee(r3[e3], n3, t4);
          else
            Ee(r3, n3, t4);
      }), d2.pop(), T2 = null;
    };
    let _e = null;
    function be() {
      we.stop();
    }
    function xe() {
      we.start();
    }
    const we = new WebGLAnimation();
    function Se(e3, t3, r3, n3) {
      var i3 = e3.opaque, a3 = e3.transmissive, e3 = e3.transparent;
      T2.setupLightsView(r3), 0 < a3.length && function(e4, t4, r4) {
        if (N2 === null) {
          const a4 = o2 === true && W.isWebGL2 === true ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
          N2 = new a4(1024, 1024, { generateMipmaps: true, type: de.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType, minFilter: LinearMipmapLinearFilter, magFilter: NearestFilter, wrapS: ClampToEdgeWrapping, wrapT: ClampToEdgeWrapping });
        }
        var n4 = k2.getRenderTarget();
        k2.setRenderTarget(N2), k2.clear();
        var i4 = k2.toneMapping;
        k2.toneMapping = NoToneMapping, Me(e4, t4, r4), k2.toneMapping = i4, Z.updateMultisampleRenderTarget(N2), Z.updateRenderTargetMipmap(N2), k2.setRenderTarget(n4);
      }(i3, t3, r3), n3 && q.viewport(v2.copy(n3)), 0 < i3.length && Me(i3, t3, r3), 0 < a3.length && Me(a3, t3, r3), 0 < e3.length && Me(e3, t3, r3);
    }
    function Me(r3, n3, i3) {
      var a3 = n3.isScene === true ? n3.overrideMaterial : null;
      for (let e3 = 0, t3 = r3.length; e3 < t3; e3++) {
        var o3 = r3[e3];
        const c3 = o3.object;
        var s3 = o3.geometry, l3 = a3 === null ? o3.material : a3, o3 = o3.group;
        c3.layers.test(i3.layers) && function(e4, t4, r4, n4, i4, a4) {
          e4.onBeforeRender(k2, t4, r4, n4, i4, a4), e4.modelViewMatrix.multiplyMatrices(r4.matrixWorldInverse, e4.matrixWorld), e4.normalMatrix.getNormalMatrix(e4.modelViewMatrix), i4.onBeforeRender(k2, t4, r4, n4, e4, a4), i4.transparent === true && i4.side === DoubleSide ? (i4.side = BackSide, i4.needsUpdate = true, k2.renderBufferDirect(r4, t4, n4, i4, e4, a4), i4.side = FrontSide, i4.needsUpdate = true, k2.renderBufferDirect(r4, t4, n4, i4, e4, a4), i4.side = DoubleSide) : k2.renderBufferDirect(r4, t4, n4, i4, e4, a4);
          e4.onAfterRender(k2, t4, r4, n4, i4, a4);
        }(c3, n3, i3, s3, l3, o3);
      }
    }
    function Ee(e3, t3, r3) {
      t3.isScene !== true && (t3 = j2);
      const n3 = X.get(e3);
      var i3 = T2.state.lights, a3 = T2.state.shadowsArray, o3 = i3.state.version;
      const s3 = re.getParameters(e3, i3.state, a3, t3, r3);
      a3 = re.getProgramCacheKey(s3);
      let l3 = n3.programs;
      n3.environment = e3.isMeshStandardMaterial ? t3.environment : null, n3.fog = t3.fog, n3.envMap = (e3.isMeshStandardMaterial ? J : K).get(e3.envMap || n3.environment), l3 === void 0 && (e3.addEventListener("dispose", ye), l3 = new Map(), n3.programs = l3);
      let c3 = l3.get(a3);
      if (c3 !== void 0) {
        if (n3.currentProgram === c3 && n3.lightsStateVersion === o3)
          return Te(e3, s3), c3;
      } else
        s3.uniforms = re.getUniforms(e3), e3.onBuild(r3, s3, k2), e3.onBeforeCompile(s3, k2), c3 = re.acquireProgram(s3, a3), l3.set(a3, c3), n3.uniforms = s3.uniforms;
      const u3 = n3.uniforms;
      (e3.isShaderMaterial || e3.isRawShaderMaterial) && e3.clipping !== true || (u3.clippingPlanes = oe.uniform), Te(e3, s3), n3.needsLights = (e3 = e3).isMeshLambertMaterial || e3.isMeshToonMaterial || e3.isMeshPhongMaterial || e3.isMeshStandardMaterial || e3.isShadowMaterial || e3.isShaderMaterial && e3.lights === true, n3.lightsStateVersion = o3, n3.needsLights && (u3.ambientLightColor.value = i3.state.ambient, u3.lightProbe.value = i3.state.probe, u3.directionalLights.value = i3.state.directional, u3.directionalLightShadows.value = i3.state.directionalShadow, u3.spotLights.value = i3.state.spot, u3.spotLightShadows.value = i3.state.spotShadow, u3.rectAreaLights.value = i3.state.rectArea, u3.ltc_1.value = i3.state.rectAreaLTC1, u3.ltc_2.value = i3.state.rectAreaLTC2, u3.pointLights.value = i3.state.point, u3.pointLightShadows.value = i3.state.pointShadow, u3.hemisphereLights.value = i3.state.hemi, u3.directionalShadowMap.value = i3.state.directionalShadowMap, u3.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, u3.spotShadowMap.value = i3.state.spotShadowMap, u3.spotShadowMatrix.value = i3.state.spotShadowMatrix, u3.pointShadowMap.value = i3.state.pointShadowMap, u3.pointShadowMatrix.value = i3.state.pointShadowMatrix);
      i3 = c3.getUniforms(), i3 = WebGLUniforms.seqWithValue(i3.seq, u3);
      return n3.currentProgram = c3, n3.uniformsList = i3, c3;
    }
    function Te(e3, t3) {
      const r3 = X.get(e3);
      r3.outputEncoding = t3.outputEncoding, r3.instancing = t3.instancing, r3.skinning = t3.skinning, r3.morphTargets = t3.morphTargets, r3.morphNormals = t3.morphNormals, r3.morphTargetsCount = t3.morphTargetsCount, r3.numClippingPlanes = t3.numClippingPlanes, r3.numIntersection = t3.numClipIntersection, r3.vertexAlphas = t3.vertexAlphas, r3.vertexTangents = t3.vertexTangents;
    }
    we.setAnimationLoop(function(e3) {
      _e && _e(e3);
    }), typeof window != "undefined" && we.setContext(window), this.setAnimationLoop = function(e3) {
      _e = e3, me.setAnimationLoop(e3), e3 === null ? we.stop() : we.start();
    }, me.addEventListener("sessionstart", be), me.addEventListener("sessionend", xe), this.render = function(r3, e3) {
      if (e3 === void 0 || e3.isCamera === true) {
        if (p2 !== true) {
          r3.autoUpdate === true && r3.updateMatrixWorld(), e3.parent === null && e3.updateMatrixWorld(), me.enabled === true && me.isPresenting === true && (me.cameraAutoUpdate === true && me.updateCamera(e3), e3 = me.getCamera()), r3.isScene === true && r3.onBeforeRender(k2, r3, e3, A2), T2 = ae.get(r3, d2.length), T2.init(), d2.push(T2), B.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), P2.setFromProjectionMatrix(B), D = this.localClippingEnabled, I2 = oe.init(this.clippingPlanes, D, e3), f2 = ie.get(r3, h2.length), f2.init(), h2.push(f2), function r4(n4, i4, a3, o3) {
            if (n4.visible === false)
              return;
            const e4 = n4.layers.test(i4.layers);
            if (e4) {
              if (n4.isGroup)
                a3 = n4.renderOrder;
              else if (n4.isLOD)
                n4.autoUpdate === true && n4.update(i4);
              else if (n4.isLight)
                T2.pushLight(n4), n4.castShadow && T2.pushShadow(n4);
              else if (n4.isSprite) {
                if (!n4.frustumCulled || P2.intersectsSprite(n4)) {
                  o3 && F.setFromMatrixPosition(n4.matrixWorld).applyMatrix4(B);
                  const t4 = te.update(n4), l3 = n4.material;
                  l3.visible && f2.push(n4, t4, l3, a3, F.z, null);
                }
              } else if ((n4.isMesh || n4.isLine || n4.isPoints) && (n4.isSkinnedMesh && n4.skeleton.frame !== Y.render.frame && (n4.skeleton.update(), n4.skeleton.frame = Y.render.frame), !n4.frustumCulled || P2.intersectsObject(n4))) {
                o3 && F.setFromMatrixPosition(n4.matrixWorld).applyMatrix4(B);
                const c3 = te.update(n4), u3 = n4.material;
                if (Array.isArray(u3)) {
                  const h3 = c3.groups;
                  for (let e5 = 0, t4 = h3.length; e5 < t4; e5++) {
                    const d3 = h3[e5], p3 = u3[d3.materialIndex];
                    p3 && p3.visible && f2.push(n4, c3, p3, a3, F.z, d3);
                  }
                } else
                  u3.visible && f2.push(n4, c3, u3, a3, F.z, null);
              }
            }
            const s3 = n4.children;
            for (let e5 = 0, t4 = s3.length; e5 < t4; e5++)
              r4(s3[e5], i4, a3, o3);
          }(r3, e3, 0, k2.sortObjects), f2.finish(), k2.sortObjects === true && f2.sort(x2, w2), I2 === true && oe.beginShadows();
          var t3 = T2.state.shadowsArray;
          if (se.render(t3, r3, e3), I2 === true && oe.endShadows(), this.info.autoReset === true && this.info.reset(), le.render(f2, r3), T2.setupLights(k2.physicallyCorrectLights), e3.isArrayCamera) {
            var n3 = e3.cameras;
            for (let e4 = 0, t4 = n3.length; e4 < t4; e4++) {
              var i3 = n3[e4];
              Se(f2, r3, i3, i3.viewport);
            }
          } else
            Se(f2, r3, e3);
          A2 !== null && (Z.updateMultisampleRenderTarget(A2), Z.updateRenderTargetMipmap(A2)), r3.isScene === true && r3.onAfterRender(k2, r3, e3), q.buffers.depth.setTest(true), q.buffers.depth.setMask(true), q.buffers.color.setMask(true), q.setPolygonOffset(false), pe.resetDefaultState(), C2 = -1, $2 = null, d2.pop(), T2 = 0 < d2.length ? d2[d2.length - 1] : null, h2.pop(), f2 = 0 < h2.length ? h2[h2.length - 1] : null;
        }
      } else
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    }, this.getActiveCubeFace = function() {
      return m2;
    }, this.getActiveMipmapLevel = function() {
      return g2;
    }, this.getRenderTarget = function() {
      return A2;
    }, this.setRenderTarget = function(t3, e3 = 0, r3 = 0) {
      A2 = t3, m2 = e3, g2 = r3, t3 && X.get(t3).__webglFramebuffer === void 0 && Z.setupRenderTarget(t3);
      let n3 = null, i3 = false, a3 = false;
      var o3;
      if (_2 = t3 ? (((o3 = t3.texture).isDataTexture3D || o3.isDataTexture2DArray) && (a3 = true), o3 = X.get(t3).__webglFramebuffer, t3.isWebGLCubeRenderTarget ? (n3 = o3[e3], i3 = true) : n3 = t3.isWebGLMultisampleRenderTarget ? X.get(t3).__webglMultisampledFramebuffer : o3, v2.copy(t3.viewport), y.copy(t3.scissor), t3.scissorTest) : (v2.copy(S2).multiplyScalar(L).floor(), y.copy(M2).multiplyScalar(L).floor(), E2), q.bindFramebuffer(36160, n3) && W.drawBuffers) {
        let e4 = false;
        if (t3)
          if (t3.isWebGLMultipleRenderTargets) {
            const Z2 = t3.texture;
            if (O.length !== Z2.length || O[0] !== 36064) {
              for (let e5 = 0, t4 = Z2.length; e5 < t4; e5++)
                O[e5] = 36064 + e5;
              O.length = Z2.length, e4 = true;
            }
          } else
            O.length === 1 && O[0] === 36064 || (O[0] = 36064, O.length = 1, e4 = true);
        else
          O.length === 1 && O[0] === 1029 || (O[0] = 1029, O.length = 1, e4 = true);
        e4 && (W.isWebGL2 ? V2.drawBuffers(O) : G.get("WEBGL_draw_buffers").drawBuffersWEBGL(O));
      }
      q.viewport(v2), q.scissor(y), q.setScissorTest(_2), i3 ? (o3 = X.get(t3.texture), V2.framebufferTexture2D(36160, 36064, 34069 + e3, o3.__webglTexture, r3)) : a3 && (t3 = X.get(t3.texture), e3 = e3 || 0, V2.framebufferTextureLayer(36160, 36064, t3.__webglTexture, r3 || 0, e3)), C2 = -1;
    }, this.readRenderTargetPixels = function(t3, r3, n3, i3, a3, o3, s3) {
      if (t3 && t3.isWebGLRenderTarget) {
        let e3 = X.get(t3).__webglFramebuffer;
        if (t3.isWebGLCubeRenderTarget && s3 !== void 0 && (e3 = e3[s3]), e3) {
          q.bindFramebuffer(36160, e3);
          try {
            var l3 = t3.texture, c3 = l3.format, u3 = l3.type;
            if (c3 !== RGBAFormat && de.convert(c3) !== V2.getParameter(35739))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            var h3 = u3 === HalfFloatType && (G.has("EXT_color_buffer_half_float") || W.isWebGL2 && G.has("EXT_color_buffer_float"));
            if (!(u3 === UnsignedByteType || de.convert(u3) === V2.getParameter(35738) || u3 === FloatType && (W.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || h3))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            V2.checkFramebufferStatus(36160) === 36053 ? 0 <= r3 && r3 <= t3.width - i3 && 0 <= n3 && n3 <= t3.height - a3 && V2.readPixels(r3, n3, i3, a3, de.convert(c3), de.convert(u3), o3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          } finally {
            const e4 = A2 !== null ? X.get(A2).__webglFramebuffer : null;
            q.bindFramebuffer(36160, e4);
          }
        }
      } else
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    }, this.copyFramebufferToTexture = function(e3, t3, r3 = 0) {
      var n3 = Math.pow(2, -r3), i3 = Math.floor(t3.image.width * n3), n3 = Math.floor(t3.image.height * n3);
      let a3 = de.convert(t3.format);
      W.isWebGL2 && (a3 === 6407 && (a3 = 32849), a3 === 6408 && (a3 = 32856)), Z.setTexture2D(t3, 0), V2.copyTexImage2D(3553, r3, a3, e3.x, e3.y, i3, n3, 0), q.unbindTexture();
    }, this.copyTextureToTexture = function(e3, t3, r3, n3 = 0) {
      var i3 = t3.image.width, a3 = t3.image.height, o3 = de.convert(r3.format), s3 = de.convert(r3.type);
      Z.setTexture2D(r3, 0), V2.pixelStorei(37440, r3.flipY), V2.pixelStorei(37441, r3.premultiplyAlpha), V2.pixelStorei(3317, r3.unpackAlignment), t3.isDataTexture ? V2.texSubImage2D(3553, n3, e3.x, e3.y, i3, a3, o3, s3, t3.image.data) : t3.isCompressedTexture ? V2.compressedTexSubImage2D(3553, n3, e3.x, e3.y, t3.mipmaps[0].width, t3.mipmaps[0].height, o3, t3.mipmaps[0].data) : V2.texSubImage2D(3553, n3, e3.x, e3.y, o3, s3, t3.image), n3 === 0 && r3.generateMipmaps && V2.generateMipmap(3553), q.unbindTexture();
    }, this.copyTextureToTexture3D = function(t3, r3, n3, i3, a3 = 0) {
      if (k2.isWebGL1Renderer)
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      else {
        var o3 = t3.max.x - t3.min.x + 1, s3 = t3.max.y - t3.min.y + 1, l3 = t3.max.z - t3.min.z + 1, c3 = de.convert(i3.format), u3 = de.convert(i3.type);
        let e3;
        if (i3.isDataTexture3D)
          Z.setTexture3D(i3, 0), e3 = 32879;
        else {
          if (!i3.isDataTexture2DArray)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          Z.setTexture2DArray(i3, 0), e3 = 35866;
        }
        V2.pixelStorei(37440, i3.flipY), V2.pixelStorei(37441, i3.premultiplyAlpha), V2.pixelStorei(3317, i3.unpackAlignment);
        var h3 = V2.getParameter(3314), d3 = V2.getParameter(32878), p3 = V2.getParameter(3316), f3 = V2.getParameter(3315), m3 = V2.getParameter(32877), g3 = n3.isCompressedTexture ? n3.mipmaps[0] : n3.image;
        V2.pixelStorei(3314, g3.width), V2.pixelStorei(32878, g3.height), V2.pixelStorei(3316, t3.min.x), V2.pixelStorei(3315, t3.min.y), V2.pixelStorei(32877, t3.min.z), n3.isDataTexture || n3.isDataTexture3D ? V2.texSubImage3D(e3, a3, r3.x, r3.y, r3.z, o3, s3, l3, c3, u3, g3.data) : n3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), V2.compressedTexSubImage3D(e3, a3, r3.x, r3.y, r3.z, o3, s3, l3, c3, g3.data)) : V2.texSubImage3D(e3, a3, r3.x, r3.y, r3.z, o3, s3, l3, c3, u3, g3), V2.pixelStorei(3314, h3), V2.pixelStorei(32878, d3), V2.pixelStorei(3316, p3), V2.pixelStorei(3315, f3), V2.pixelStorei(32877, m3), a3 === 0 && i3.generateMipmaps && V2.generateMipmap(e3), q.unbindTexture();
      }
    }, this.initTexture = function(e3) {
      Z.setTexture2D(e3, 0), q.unbindTexture();
    }, this.resetState = function() {
      m2 = 0, g2 = 0, A2 = null, q.reset(), pe.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  WebGLRenderer.prototype.isWebGLRenderer = true;
  class WebGL1Renderer extends WebGLRenderer {
  }
  WebGL1Renderer.prototype.isWebGL1Renderer = true;
  class Scene extends Object3D {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(e2, t2) {
      return super.copy(e2, t2), e2.background !== null && (this.background = e2.background.clone()), e2.environment !== null && (this.environment = e2.environment.clone()), e2.fog !== null && (this.fog = e2.fog.clone()), e2.overrideMaterial !== null && (this.overrideMaterial = e2.overrideMaterial.clone()), this.autoUpdate = e2.autoUpdate, this.matrixAutoUpdate = e2.matrixAutoUpdate, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return this.fog !== null && (t2.object.fog = this.fog.toJSON()), t2;
    }
  }
  Scene.prototype.isScene = true;
  class InterleavedBuffer {
    constructor(e2, t2) {
      this.array = e2, this.stride = t2, this.count = e2 !== void 0 ? e2.length / t2 : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = generateUUID();
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      e2 === true && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.array = new e2.array.constructor(e2.array), this.count = e2.count, this.stride = e2.stride, this.usage = e2.usage, this;
    }
    copyAt(r2, n2, i2) {
      r2 *= this.stride, i2 *= n2.stride;
      for (let e2 = 0, t2 = this.stride; e2 < t2; e2++)
        this.array[r2 + e2] = n2.array[i2 + e2];
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    clone(e2) {
      e2.arrayBuffers === void 0 && (e2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), e2.arrayBuffers[this.array.buffer._uuid] === void 0 && (e2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      e2 = new this.array.constructor(e2.arrayBuffers[this.array.buffer._uuid]);
      const t2 = new this.constructor(e2, this.stride);
      return t2.setUsage(this.usage), t2;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    toJSON(e2) {
      return e2.arrayBuffers === void 0 && (e2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), e2.arrayBuffers[this.array.buffer._uuid] === void 0 && (e2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  }
  InterleavedBuffer.prototype.isInterleavedBuffer = true;
  const _vector$6 = new Vector3();
  class InterleavedBufferAttribute {
    constructor(e2, t2, r2, n2 = false) {
      this.name = "", this.data = e2, this.itemSize = t2, this.offset = r2, this.normalized = n2 === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e2) {
      this.data.needsUpdate = e2;
    }
    applyMatrix4(r2) {
      for (let e2 = 0, t2 = this.data.count; e2 < t2; e2++)
        _vector$6.x = this.getX(e2), _vector$6.y = this.getY(e2), _vector$6.z = this.getZ(e2), _vector$6.applyMatrix4(r2), this.setXYZ(e2, _vector$6.x, _vector$6.y, _vector$6.z);
      return this;
    }
    applyNormalMatrix(r2) {
      for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
        _vector$6.x = this.getX(e2), _vector$6.y = this.getY(e2), _vector$6.z = this.getZ(e2), _vector$6.applyNormalMatrix(r2), this.setXYZ(e2, _vector$6.x, _vector$6.y, _vector$6.z);
      return this;
    }
    transformDirection(r2) {
      for (let e2 = 0, t2 = this.count; e2 < t2; e2++)
        _vector$6.x = this.getX(e2), _vector$6.y = this.getY(e2), _vector$6.z = this.getZ(e2), _vector$6.transformDirection(r2), this.setXYZ(e2, _vector$6.x, _vector$6.y, _vector$6.z);
      return this;
    }
    setX(e2, t2) {
      return this.data.array[e2 * this.data.stride + this.offset] = t2, this;
    }
    setY(e2, t2) {
      return this.data.array[e2 * this.data.stride + this.offset + 1] = t2, this;
    }
    setZ(e2, t2) {
      return this.data.array[e2 * this.data.stride + this.offset + 2] = t2, this;
    }
    setW(e2, t2) {
      return this.data.array[e2 * this.data.stride + this.offset + 3] = t2, this;
    }
    getX(e2) {
      return this.data.array[e2 * this.data.stride + this.offset];
    }
    getY(e2) {
      return this.data.array[e2 * this.data.stride + this.offset + 1];
    }
    getZ(e2) {
      return this.data.array[e2 * this.data.stride + this.offset + 2];
    }
    getW(e2) {
      return this.data.array[e2 * this.data.stride + this.offset + 3];
    }
    setXY(e2, t2, r2) {
      return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this;
    }
    setXYZ(e2, t2, r2, n2) {
      return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this.data.array[e2 + 2] = n2, this;
    }
    setXYZW(e2, t2, r2, n2, i2) {
      return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this.data.array[e2 + 2] = n2, this.data.array[e2 + 3] = i2, this;
    }
    clone(e2) {
      if (e2 !== void 0)
        return e2.interleavedBuffers === void 0 && (e2.interleavedBuffers = {}), e2.interleavedBuffers[this.data.uuid] === void 0 && (e2.interleavedBuffers[this.data.uuid] = this.data.clone(e2)), new InterleavedBufferAttribute(e2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const r2 = [];
        for (let e3 = 0; e3 < this.count; e3++) {
          var t2 = e3 * this.data.stride + this.offset;
          for (let e4 = 0; e4 < this.itemSize; e4++)
            r2.push(this.data.array[t2 + e4]);
        }
        return new BufferAttribute(new this.array.constructor(r2), this.itemSize, this.normalized);
      }
    }
    toJSON(e2) {
      if (e2 !== void 0)
        return e2.interleavedBuffers === void 0 && (e2.interleavedBuffers = {}), e2.interleavedBuffers[this.data.uuid] === void 0 && (e2.interleavedBuffers[this.data.uuid] = this.data.toJSON(e2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
      {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const r2 = [];
        for (let e3 = 0; e3 < this.count; e3++) {
          var t2 = e3 * this.data.stride + this.offset;
          for (let e4 = 0; e4 < this.itemSize; e4++)
            r2.push(this.data.array[t2 + e4]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: r2, normalized: this.normalized };
      }
    }
  }
  InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
  class SpriteMaterial extends Material {
    constructor(e2) {
      super(), this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.rotation = e2.rotation, this.sizeAttenuation = e2.sizeAttenuation, this;
    }
  }
  SpriteMaterial.prototype.isSpriteMaterial = true;
  let _geometry$2;
  const _intersectPoint = new Vector3(), _worldScale = new Vector3(), _mvPosition = new Vector3(), _alignedPosition = new Vector2(), _rotatedPosition = new Vector2(), _viewWorldMatrix = new Matrix4(), _vA$2 = new Vector3(), _vB$2 = new Vector3(), _vC$2 = new Vector3(), _uvA = new Vector2(), _uvB = new Vector2(), _uvC = new Vector2();
  class Sprite extends Object3D {
    constructor(e2) {
      var t2;
      super(), this.type = "Sprite", _geometry$2 === void 0 && (_geometry$2 = new BufferGeometry(), t2 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), t2 = new InterleavedBuffer(t2, 5), _geometry$2.setIndex([0, 1, 2, 0, 2, 3]), _geometry$2.setAttribute("position", new InterleavedBufferAttribute(t2, 3, 0, false)), _geometry$2.setAttribute("uv", new InterleavedBufferAttribute(t2, 2, 3, false))), this.geometry = _geometry$2, this.material = e2 !== void 0 ? e2 : new SpriteMaterial(), this.center = new Vector2(0.5, 0.5);
    }
    raycast(e2, t2) {
      e2.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e2.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e2.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && _worldScale.multiplyScalar(-_mvPosition.z);
      var r2 = this.material.rotation;
      let n2, i2;
      r2 !== 0 && (i2 = Math.cos(r2), n2 = Math.sin(r2));
      r2 = this.center;
      transformVertex(_vA$2.set(-0.5, -0.5, 0), _mvPosition, r2, _worldScale, n2, i2), transformVertex(_vB$2.set(0.5, -0.5, 0), _mvPosition, r2, _worldScale, n2, i2), transformVertex(_vC$2.set(0.5, 0.5, 0), _mvPosition, r2, _worldScale, n2, i2), _uvA.set(0, 0), _uvB.set(1, 0), _uvC.set(1, 1), e2.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, false, _intersectPoint) === null && (transformVertex(_vB$2.set(-0.5, 0.5, 0), _mvPosition, r2, _worldScale, n2, i2), _uvB.set(0, 1), e2.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, false, _intersectPoint) === null) || ((r2 = e2.ray.origin.distanceTo(_intersectPoint)) < e2.near || r2 > e2.far || t2.push({ distance: r2, point: _intersectPoint.clone(), uv: Triangle.getUV(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC, new Vector2()), face: null, object: this }));
    }
    copy(e2) {
      return super.copy(e2), e2.center !== void 0 && this.center.copy(e2.center), this.material = e2.material, this;
    }
  }
  function transformVertex(e2, t2, r2, n2, i2, a2) {
    _alignedPosition.subVectors(e2, r2).addScalar(0.5).multiply(n2), i2 !== void 0 ? (_rotatedPosition.x = a2 * _alignedPosition.x - i2 * _alignedPosition.y, _rotatedPosition.y = i2 * _alignedPosition.x + a2 * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), e2.copy(t2), e2.x += _rotatedPosition.x, e2.y += _rotatedPosition.y, e2.applyMatrix4(_viewWorldMatrix);
  }
  Sprite.prototype.isSprite = true;
  const _basePosition = new Vector3(), _skinIndex = new Vector4(), _skinWeight = new Vector4(), _vector$5 = new Vector3(), _matrix = new Matrix4();
  class SkinnedMesh extends Mesh {
    constructor(e2, t2) {
      super(e2, t2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
    }
    copy(e2) {
      return super.copy(e2), this.bindMode = e2.bindMode, this.bindMatrix.copy(e2.bindMatrix), this.bindMatrixInverse.copy(e2.bindMatrixInverse), this.skeleton = e2.skeleton, this;
    }
    bind(e2, t2) {
      this.skeleton = e2, t2 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const r2 = new Vector4(), n2 = this.geometry.attributes.skinWeight;
      for (let e2 = 0, t2 = n2.count; e2 < t2; e2++) {
        r2.x = n2.getX(e2), r2.y = n2.getY(e2), r2.z = n2.getZ(e2), r2.w = n2.getW(e2);
        var i2 = 1 / r2.manhattanLength();
        i2 != 1 / 0 ? r2.multiplyScalar(i2) : r2.set(1, 0, 0, 0), n2.setXYZW(e2, r2.x, r2.y, r2.z, r2.w);
      }
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(e2, t2) {
      var r2 = this.skeleton, n2 = this.geometry;
      _skinIndex.fromBufferAttribute(n2.attributes.skinIndex, e2), _skinWeight.fromBufferAttribute(n2.attributes.skinWeight, e2), _basePosition.copy(t2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
      for (let e3 = 0; e3 < 4; e3++) {
        var i2, a2 = _skinWeight.getComponent(e3);
        a2 !== 0 && (i2 = _skinIndex.getComponent(e3), _matrix.multiplyMatrices(r2.bones[i2].matrixWorld, r2.boneInverses[i2]), t2.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), a2));
      }
      return t2.applyMatrix4(this.bindMatrixInverse);
    }
  }
  SkinnedMesh.prototype.isSkinnedMesh = true;
  class Bone extends Object3D {
    constructor() {
      super(), this.type = "Bone";
    }
  }
  Bone.prototype.isBone = true;
  class DataTexture extends Texture {
    constructor(e2 = null, t2 = 1, r2 = 1, n2, i2, a2, o2, s2, l2 = NearestFilter, c2 = NearestFilter, u2, h2) {
      super(null, a2, o2, s2, l2, c2, n2, i2, u2, h2), this.image = { data: e2, width: t2, height: r2 }, this.magFilter = l2, this.minFilter = c2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  DataTexture.prototype.isDataTexture = true;
  class InstancedBufferAttribute extends BufferAttribute {
    constructor(e2, t2, r2, n2 = 1) {
      typeof r2 == "number" && (n2 = r2, r2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e2, t2, r2), this.meshPerAttribute = n2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.meshPerAttribute = this.meshPerAttribute, e2.isInstancedBufferAttribute = true, e2;
    }
  }
  InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
  const _instanceLocalMatrix = new Matrix4(), _instanceWorldMatrix = new Matrix4(), _instanceIntersects = [], _mesh = new Mesh();
  class InstancedMesh extends Mesh {
    constructor(e2, t2, r2) {
      super(e2, t2), this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(16 * r2), 16), this.instanceColor = null, this.count = r2, this.frustumCulled = false;
    }
    copy(e2) {
      return super.copy(e2), this.instanceMatrix.copy(e2.instanceMatrix), e2.instanceColor !== null && (this.instanceColor = e2.instanceColor.clone()), this.count = e2.count, this;
    }
    getColorAt(e2, t2) {
      t2.fromArray(this.instanceColor.array, 3 * e2);
    }
    getMatrixAt(e2, t2) {
      t2.fromArray(this.instanceMatrix.array, 16 * e2);
    }
    raycast(e2, n2) {
      var t2 = this.matrixWorld, i2 = this.count;
      if (_mesh.geometry = this.geometry, _mesh.material = this.material, _mesh.material !== void 0)
        for (let r2 = 0; r2 < i2; r2++) {
          this.getMatrixAt(r2, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(t2, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast(e2, _instanceIntersects);
          for (let e3 = 0, t3 = _instanceIntersects.length; e3 < t3; e3++) {
            const a2 = _instanceIntersects[e3];
            a2.instanceId = r2, a2.object = this, n2.push(a2);
          }
          _instanceIntersects.length = 0;
        }
    }
    setColorAt(e2, t2) {
      this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(3 * this.instanceMatrix.count), 3)), t2.toArray(this.instanceColor.array, 3 * e2);
    }
    setMatrixAt(e2, t2) {
      t2.toArray(this.instanceMatrix.array, 16 * e2);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  InstancedMesh.prototype.isInstancedMesh = true;
  class LineBasicMaterial extends Material {
    constructor(e2) {
      super(), this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.linewidth = e2.linewidth, this.linecap = e2.linecap, this.linejoin = e2.linejoin, this;
    }
  }
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  const _start$1 = new Vector3(), _end$1 = new Vector3(), _inverseMatrix$1 = new Matrix4(), _ray$1 = new Ray(), _sphere$1 = new Sphere();
  class Line extends Object3D {
    constructor(e2 = new BufferGeometry(), t2 = new LineBasicMaterial()) {
      super(), this.type = "Line", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2) {
      return super.copy(e2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (e2.isBufferGeometry)
        if (e2.index === null) {
          var r2 = e2.attributes.position;
          const n2 = [0];
          for (let e3 = 1, t2 = r2.count; e3 < t2; e3++)
            _start$1.fromBufferAttribute(r2, e3 - 1), _end$1.fromBufferAttribute(r2, e3), n2[e3] = n2[e3 - 1], n2[e3] += _start$1.distanceTo(_end$1);
          e2.setAttribute("lineDistance", new Float32BufferAttribute(n2, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        e2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
    raycast(r2, n2) {
      const e2 = this.geometry;
      var t2 = this.matrixWorld, i2 = r2.params.Line.threshold, a2 = e2.drawRange;
      if (e2.boundingSphere === null && e2.computeBoundingSphere(), _sphere$1.copy(e2.boundingSphere), _sphere$1.applyMatrix4(t2), _sphere$1.radius += i2, r2.ray.intersectsSphere(_sphere$1) !== false) {
        _inverseMatrix$1.copy(t2).invert(), _ray$1.copy(r2.ray).applyMatrix4(_inverseMatrix$1);
        var i2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = i2 * i2;
        const d2 = new Vector3(), p2 = new Vector3(), f2 = new Vector3(), m2 = new Vector3();
        var s2 = this.isLineSegments ? 2 : 1;
        if (e2.isBufferGeometry) {
          const g2 = e2.index;
          var l2, c2 = e2.attributes.position;
          if (g2 !== null)
            for (let e3 = Math.max(0, a2.start), t3 = Math.min(g2.count, a2.start + a2.count) - 1; e3 < t3; e3 += s2) {
              var u2 = g2.getX(e3), h2 = g2.getX(e3 + 1);
              d2.fromBufferAttribute(c2, u2), p2.fromBufferAttribute(c2, h2), o2 < _ray$1.distanceSqToSegment(d2, p2, m2, f2) || (m2.applyMatrix4(this.matrixWorld), (h2 = r2.ray.origin.distanceTo(m2)) < r2.near || h2 > r2.far || n2.push({ distance: h2, point: f2.clone().applyMatrix4(this.matrixWorld), index: e3, face: null, faceIndex: null, object: this }));
            }
          else
            for (let e3 = Math.max(0, a2.start), t3 = Math.min(c2.count, a2.start + a2.count) - 1; e3 < t3; e3 += s2)
              d2.fromBufferAttribute(c2, e3), p2.fromBufferAttribute(c2, e3 + 1), o2 < _ray$1.distanceSqToSegment(d2, p2, m2, f2) || (m2.applyMatrix4(this.matrixWorld), (l2 = r2.ray.origin.distanceTo(m2)) < r2.near || l2 > r2.far || n2.push({ distance: l2, point: f2.clone().applyMatrix4(this.matrixWorld), index: e3, face: null, faceIndex: null, object: this }));
        } else
          e2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      var e2 = this.geometry;
      if (e2.isBufferGeometry) {
        var t2 = e2.morphAttributes, r2 = Object.keys(t2);
        if (0 < r2.length) {
          var n2 = t2[r2[0]];
          if (n2 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
              var i2 = n2[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i2] = e3;
            }
          }
        }
      } else {
        e2 = e2.morphTargets;
        e2 !== void 0 && 0 < e2.length && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  Line.prototype.isLine = true;
  const _start = new Vector3(), _end = new Vector3();
  class LineSegments extends Line {
    constructor(e2, t2) {
      super(e2, t2), this.type = "LineSegments";
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (e2.isBufferGeometry)
        if (e2.index === null) {
          var r2 = e2.attributes.position;
          const n2 = [];
          for (let e3 = 0, t2 = r2.count; e3 < t2; e3 += 2)
            _start.fromBufferAttribute(r2, e3), _end.fromBufferAttribute(r2, e3 + 1), n2[e3] = e3 === 0 ? 0 : n2[e3 - 1], n2[e3 + 1] = n2[e3] + _start.distanceTo(_end);
          e2.setAttribute("lineDistance", new Float32BufferAttribute(n2, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        e2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  }
  LineSegments.prototype.isLineSegments = true;
  class LineLoop extends Line {
    constructor(e2, t2) {
      super(e2, t2), this.type = "LineLoop";
    }
  }
  LineLoop.prototype.isLineLoop = true;
  class PointsMaterial extends Material {
    constructor(e2) {
      super(), this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.size = e2.size, this.sizeAttenuation = e2.sizeAttenuation, this;
    }
  }
  PointsMaterial.prototype.isPointsMaterial = true;
  const _inverseMatrix = new Matrix4(), _ray = new Ray(), _sphere = new Sphere(), _position$2 = new Vector3();
  class Points extends Object3D {
    constructor(e2 = new BufferGeometry(), t2 = new PointsMaterial()) {
      super(), this.type = "Points", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2) {
      return super.copy(e2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    raycast(r2, n2) {
      const e2 = this.geometry;
      var i2 = this.matrixWorld, t2 = r2.params.Points.threshold, a2 = e2.drawRange;
      if (e2.boundingSphere === null && e2.computeBoundingSphere(), _sphere.copy(e2.boundingSphere), _sphere.applyMatrix4(i2), _sphere.radius += t2, r2.ray.intersectsSphere(_sphere) !== false) {
        _inverseMatrix.copy(i2).invert(), _ray.copy(r2.ray).applyMatrix4(_inverseMatrix);
        var t2 = t2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = t2 * t2;
        if (e2.isBufferGeometry) {
          const c2 = e2.index;
          var s2 = e2.attributes.position;
          if (c2 !== null)
            for (let e3 = Math.max(0, a2.start), t3 = Math.min(c2.count, a2.start + a2.count); e3 < t3; e3++) {
              var l2 = c2.getX(e3);
              _position$2.fromBufferAttribute(s2, l2), testPoint(_position$2, l2, o2, i2, r2, n2, this);
            }
          else
            for (let e3 = Math.max(0, a2.start), t3 = Math.min(s2.count, a2.start + a2.count); e3 < t3; e3++)
              _position$2.fromBufferAttribute(s2, e3), testPoint(_position$2, e3, o2, i2, r2, n2, this);
        } else
          console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      var e2 = this.geometry;
      if (e2.isBufferGeometry) {
        var t2 = e2.morphAttributes, r2 = Object.keys(t2);
        if (0 < r2.length) {
          var n2 = t2[r2[0]];
          if (n2 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
              var i2 = n2[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i2] = e3;
            }
          }
        }
      } else {
        e2 = e2.morphTargets;
        e2 !== void 0 && 0 < e2.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  function testPoint(e2, t2, r2, n2, i2, a2, o2) {
    var s2 = _ray.distanceSqToPoint(e2);
    if (s2 < r2) {
      const l2 = new Vector3();
      _ray.closestPointToPoint(e2, l2), l2.applyMatrix4(n2);
      n2 = i2.ray.origin.distanceTo(l2);
      n2 < i2.near || n2 > i2.far || a2.push({ distance: n2, distanceToRay: Math.sqrt(s2), point: l2, index: t2, face: null, object: o2 });
    }
  }
  Points.prototype.isPoints = true;
  class VideoTexture extends Texture {
    constructor(t2, e2, r2, n2, i2, a2, o2, s2, l2) {
      super(t2, e2, r2, n2, i2, a2, o2, s2, l2), this.format = o2 !== void 0 ? o2 : RGBFormat, this.minFilter = a2 !== void 0 ? a2 : LinearFilter, this.magFilter = i2 !== void 0 ? i2 : LinearFilter, this.generateMipmaps = false;
      const c2 = this;
      "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
        c2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      var e2 = this.image;
      "requestVideoFrameCallback" in e2 == false && e2.readyState >= e2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  VideoTexture.prototype.isVideoTexture = true;
  class CompressedTexture extends Texture {
    constructor(e2, t2, r2, n2, i2, a2, o2, s2, l2, c2, u2, h2) {
      super(null, a2, o2, s2, l2, c2, n2, i2, u2, h2), this.image = { width: t2, height: r2 }, this.mipmaps = e2, this.flipY = false, this.generateMipmaps = false;
    }
  }
  CompressedTexture.prototype.isCompressedTexture = true;
  class CanvasTexture extends Texture {
    constructor(e2, t2, r2, n2, i2, a2, o2, s2, l2) {
      super(e2, t2, r2, n2, i2, a2, o2, s2, l2), this.needsUpdate = true;
    }
  }
  CanvasTexture.prototype.isCanvasTexture = true;
  class DepthTexture extends Texture {
    constructor(e2, t2, r2, n2, i2, a2, o2, s2, l2, c2) {
      if ((c2 = c2 !== void 0 ? c2 : DepthFormat) !== DepthFormat && c2 !== DepthStencilFormat)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      super(null, n2, i2, a2, o2, s2, c2, r2 = (r2 = r2 === void 0 && c2 === DepthFormat ? UnsignedShortType : r2) === void 0 && c2 === DepthStencilFormat ? UnsignedInt248Type : r2, l2), this.image = { width: e2, height: t2 }, this.magFilter = o2 !== void 0 ? o2 : NearestFilter, this.minFilter = s2 !== void 0 ? s2 : NearestFilter, this.flipY = false, this.generateMipmaps = false;
    }
  }
  DepthTexture.prototype.isDepthTexture = true, new Vector3(), new Vector3(), new Vector3(), new Triangle();
  class Curve {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e2, t2) {
      e2 = this.getUtoTmapping(e2);
      return this.getPoint(e2, t2);
    }
    getPoints(t2 = 5) {
      const r2 = [];
      for (let e2 = 0; e2 <= t2; e2++)
        r2.push(this.getPoint(e2 / t2));
      return r2;
    }
    getSpacedPoints(t2 = 5) {
      const r2 = [];
      for (let e2 = 0; e2 <= t2; e2++)
        r2.push(this.getPointAt(e2 / t2));
      return r2;
    }
    getLength() {
      var e2 = this.getLengths();
      return e2[e2.length - 1];
    }
    getLengths(t2 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const r2 = [];
      let n2, i2 = this.getPoint(0), a2 = 0;
      r2.push(0);
      for (let e2 = 1; e2 <= t2; e2++)
        n2 = this.getPoint(e2 / t2), a2 += n2.distanceTo(i2), r2.push(a2), i2 = n2;
      return this.cacheArcLengths = r2, r2;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e2, t2) {
      var r2 = this.getLengths();
      let n2 = 0;
      var i2 = r2.length;
      let a2;
      a2 = t2 || e2 * r2[i2 - 1];
      let o2 = 0, s2 = i2 - 1, l2;
      for (; o2 <= s2; )
        if (n2 = Math.floor(o2 + (s2 - o2) / 2), (l2 = r2[n2] - a2) < 0)
          o2 = n2 + 1;
        else {
          if (!(0 < l2)) {
            s2 = n2;
            break;
          }
          s2 = n2 - 1;
        }
      if (n2 = s2, r2[n2] === a2)
        return n2 / (i2 - 1);
      t2 = r2[n2], e2 = r2[n2 + 1], t2 = (a2 - t2) / (e2 - t2);
      return (n2 + t2) / (i2 - 1);
    }
    getTangent(e2, t2) {
      let r2 = e2 - 1e-4, n2 = e2 + 1e-4;
      r2 < 0 && (r2 = 0), 1 < n2 && (n2 = 1);
      var i2 = this.getPoint(r2), e2 = this.getPoint(n2);
      const a2 = t2 || new (i2.isVector2 ? Vector2 : Vector3)();
      return a2.copy(e2).sub(i2).normalize(), a2;
    }
    getTangentAt(e2, t2) {
      e2 = this.getUtoTmapping(e2);
      return this.getTangent(e2, t2);
    }
    computeFrenetFrames(r2, e2) {
      const t2 = new Vector3(), n2 = [], i2 = [], a2 = [], o2 = new Vector3(), s2 = new Matrix4();
      for (let e3 = 0; e3 <= r2; e3++) {
        var l2 = e3 / r2;
        n2[e3] = this.getTangentAt(l2, new Vector3());
      }
      i2[0] = new Vector3(), a2[0] = new Vector3();
      let c2 = Number.MAX_VALUE;
      var u2, h2 = Math.abs(n2[0].x), d2 = Math.abs(n2[0].y), p2 = Math.abs(n2[0].z);
      h2 <= c2 && (c2 = h2, t2.set(1, 0, 0)), d2 <= c2 && (c2 = d2, t2.set(0, 1, 0)), p2 <= c2 && t2.set(0, 0, 1), o2.crossVectors(n2[0], t2).normalize(), i2[0].crossVectors(n2[0], o2), a2[0].crossVectors(n2[0], i2[0]);
      for (let e3 = 1; e3 <= r2; e3++)
        i2[e3] = i2[e3 - 1].clone(), a2[e3] = a2[e3 - 1].clone(), o2.crossVectors(n2[e3 - 1], n2[e3]), o2.length() > Number.EPSILON && (o2.normalize(), u2 = Math.acos(clamp(n2[e3 - 1].dot(n2[e3]), -1, 1)), i2[e3].applyMatrix4(s2.makeRotationAxis(o2, u2))), a2[e3].crossVectors(n2[e3], i2[e3]);
      if (e2 === true) {
        let t3 = Math.acos(clamp(i2[0].dot(i2[r2]), -1, 1));
        t3 /= r2, 0 < n2[0].dot(o2.crossVectors(i2[0], i2[r2])) && (t3 = -t3);
        for (let e3 = 1; e3 <= r2; e3++)
          i2[e3].applyMatrix4(s2.makeRotationAxis(n2[e3], t3 * e3)), a2[e3].crossVectors(n2[e3], i2[e3]);
      }
      return { tangents: n2, normals: i2, binormals: a2 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return e2.arcLengthDivisions = this.arcLengthDivisions, e2.type = this.type, e2;
    }
    fromJSON(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
  }
  class EllipseCurve extends Curve {
    constructor(e2 = 0, t2 = 0, r2 = 1, n2 = 1, i2 = 0, a2 = 2 * Math.PI, o2 = false, s2 = 0) {
      super(), this.type = "EllipseCurve", this.aX = e2, this.aY = t2, this.xRadius = r2, this.yRadius = n2, this.aStartAngle = i2, this.aEndAngle = a2, this.aClockwise = o2, this.aRotation = s2;
    }
    getPoint(e2, t2) {
      const r2 = t2 || new Vector2();
      var n2 = 2 * Math.PI;
      let i2 = this.aEndAngle - this.aStartAngle;
      for (var a2 = Math.abs(i2) < Number.EPSILON; i2 < 0; )
        i2 += n2;
      for (; i2 > n2; )
        i2 -= n2;
      i2 < Number.EPSILON && (i2 = a2 ? 0 : n2), this.aClockwise !== true || a2 || (i2 === n2 ? i2 = -n2 : i2 -= n2);
      var o2 = this.aStartAngle + e2 * i2;
      let s2 = this.aX + this.xRadius * Math.cos(o2), l2 = this.aY + this.yRadius * Math.sin(o2);
      return this.aRotation !== 0 && (t2 = Math.cos(this.aRotation), a2 = Math.sin(this.aRotation), e2 = s2 - this.aX, o2 = l2 - this.aY, s2 = e2 * t2 - o2 * a2 + this.aX, l2 = e2 * a2 + o2 * t2 + this.aY), r2.set(s2, l2);
    }
    copy(e2) {
      return super.copy(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.aX = this.aX, e2.aY = this.aY, e2.xRadius = this.xRadius, e2.yRadius = this.yRadius, e2.aStartAngle = this.aStartAngle, e2.aEndAngle = this.aEndAngle, e2.aClockwise = this.aClockwise, e2.aRotation = this.aRotation, e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
  }
  EllipseCurve.prototype.isEllipseCurve = true;
  class ArcCurve extends EllipseCurve {
    constructor(e2, t2, r2, n2, i2, a2) {
      super(e2, t2, r2, r2, n2, i2, a2), this.type = "ArcCurve";
    }
  }
  function CubicPoly() {
    let i2 = 0, a2 = 0, o2 = 0, s2 = 0;
    function l2(e2, t2, r2, n2) {
      i2 = e2, a2 = r2, o2 = -3 * e2 + 3 * t2 - 2 * r2 - n2, s2 = 2 * e2 - 2 * t2 + r2 + n2;
    }
    return { initCatmullRom: function(e2, t2, r2, n2, i3) {
      l2(t2, r2, i3 * (r2 - e2), i3 * (n2 - t2));
    }, initNonuniformCatmullRom: function(e2, t2, r2, n2, i3, a3, o3) {
      i3 = (t2 - e2) / i3 - (r2 - e2) / (i3 + a3) + (r2 - t2) / a3, o3 = (r2 - t2) / a3 - (n2 - t2) / (a3 + o3) + (n2 - r2) / o3;
      l2(t2, r2, i3 *= a3, o3 *= a3);
    }, calc: function(e2) {
      var t2 = e2 * e2, r2 = t2 * e2;
      return i2 + a2 * e2 + o2 * t2 + s2 * r2;
    } };
  }
  ArcCurve.prototype.isArcCurve = true;
  const tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
  class CatmullRomCurve3 extends Curve {
    constructor(e2 = [], t2 = false, r2 = "centripetal", n2 = 0.5) {
      super(), this.type = "CatmullRomCurve3", this.points = e2, this.closed = t2, this.curveType = r2, this.tension = n2;
    }
    getPoint(e2, n2 = new Vector3()) {
      const t2 = n2;
      var r2 = this.points, n2 = r2.length, e2 = (n2 - (this.closed ? 0 : 1)) * e2;
      let i2 = Math.floor(e2), a2 = e2 - i2;
      this.closed ? i2 += 0 < i2 ? 0 : (Math.floor(Math.abs(i2) / n2) + 1) * n2 : a2 === 0 && i2 === n2 - 1 && (i2 = n2 - 2, a2 = 1);
      let o2, s2;
      o2 = this.closed || 0 < i2 ? r2[(i2 - 1) % n2] : (tmp.subVectors(r2[0], r2[1]).add(r2[0]), tmp);
      const l2 = r2[i2 % n2], c2 = r2[(i2 + 1) % n2];
      if (s2 = this.closed || i2 + 2 < n2 ? r2[(i2 + 2) % n2] : (tmp.subVectors(r2[n2 - 1], r2[n2 - 2]).add(r2[n2 - 1]), tmp), this.curveType === "centripetal" || this.curveType === "chordal") {
        n2 = this.curveType === "chordal" ? 0.5 : 0.25;
        let e3 = Math.pow(o2.distanceToSquared(l2), n2), t3 = Math.pow(l2.distanceToSquared(c2), n2), r3 = Math.pow(c2.distanceToSquared(s2), n2);
        t3 < 1e-4 && (t3 = 1), e3 < 1e-4 && (e3 = t3), r3 < 1e-4 && (r3 = t3), px.initNonuniformCatmullRom(o2.x, l2.x, c2.x, s2.x, e3, t3, r3), py.initNonuniformCatmullRom(o2.y, l2.y, c2.y, s2.y, e3, t3, r3), pz.initNonuniformCatmullRom(o2.z, l2.z, c2.z, s2.z, e3, t3, r3);
      } else
        this.curveType === "catmullrom" && (px.initCatmullRom(o2.x, l2.x, c2.x, s2.x, this.tension), py.initCatmullRom(o2.y, l2.y, c2.y, s2.y, this.tension), pz.initCatmullRom(o2.z, l2.z, c2.z, s2.z, this.tension));
      return t2.set(px.calc(a2), py.calc(a2), pz.calc(a2)), t2;
    }
    copy(r2) {
      super.copy(r2), this.points = [];
      for (let e2 = 0, t2 = r2.points.length; e2 < t2; e2++) {
        const n2 = r2.points[e2];
        this.points.push(n2.clone());
      }
      return this.closed = r2.closed, this.curveType = r2.curveType, this.tension = r2.tension, this;
    }
    toJSON() {
      const r2 = super.toJSON();
      r2.points = [];
      for (let e2 = 0, t2 = this.points.length; e2 < t2; e2++) {
        const n2 = this.points[e2];
        r2.points.push(n2.toArray());
      }
      return r2.closed = this.closed, r2.curveType = this.curveType, r2.tension = this.tension, r2;
    }
    fromJSON(r2) {
      super.fromJSON(r2), this.points = [];
      for (let e2 = 0, t2 = r2.points.length; e2 < t2; e2++) {
        var n2 = r2.points[e2];
        this.points.push(new Vector3().fromArray(n2));
      }
      return this.closed = r2.closed, this.curveType = r2.curveType, this.tension = r2.tension, this;
    }
  }
  function CatmullRom(e2, t2, r2, n2, i2) {
    var a2 = 0.5 * (n2 - t2), t2 = 0.5 * (i2 - r2), i2 = e2 * e2;
    return (2 * r2 - 2 * n2 + a2 + t2) * (e2 * i2) + (-3 * r2 + 3 * n2 - 2 * a2 - t2) * i2 + a2 * e2 + r2;
  }
  function QuadraticBezierP0(e2, t2) {
    e2 = 1 - e2;
    return e2 * e2 * t2;
  }
  function QuadraticBezierP1(e2, t2) {
    return 2 * (1 - e2) * e2 * t2;
  }
  function QuadraticBezierP2(e2, t2) {
    return e2 * e2 * t2;
  }
  function QuadraticBezier(e2, t2, r2, n2) {
    return QuadraticBezierP0(e2, t2) + QuadraticBezierP1(e2, r2) + QuadraticBezierP2(e2, n2);
  }
  function CubicBezierP0(e2, t2) {
    e2 = 1 - e2;
    return e2 * e2 * e2 * t2;
  }
  function CubicBezierP1(e2, t2) {
    var r2 = 1 - e2;
    return 3 * r2 * r2 * e2 * t2;
  }
  function CubicBezierP2(e2, t2) {
    return 3 * (1 - e2) * e2 * e2 * t2;
  }
  function CubicBezierP3(e2, t2) {
    return e2 * e2 * e2 * t2;
  }
  function CubicBezier(e2, t2, r2, n2, i2) {
    return CubicBezierP0(e2, t2) + CubicBezierP1(e2, r2) + CubicBezierP2(e2, n2) + CubicBezierP3(e2, i2);
  }
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  class CubicBezierCurve extends Curve {
    constructor(e2 = new Vector2(), t2 = new Vector2(), r2 = new Vector2(), n2 = new Vector2()) {
      super(), this.type = "CubicBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = r2, this.v3 = n2;
    }
    getPoint(e2, t2 = new Vector2()) {
      const r2 = t2;
      var n2 = this.v0, i2 = this.v1, a2 = this.v2, t2 = this.v3;
      return r2.set(CubicBezier(e2, n2.x, i2.x, a2.x, t2.x), CubicBezier(e2, n2.y, i2.y, a2.y, t2.y)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  class CubicBezierCurve3 extends Curve {
    constructor(e2 = new Vector3(), t2 = new Vector3(), r2 = new Vector3(), n2 = new Vector3()) {
      super(), this.type = "CubicBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = r2, this.v3 = n2;
    }
    getPoint(e2, t2 = new Vector3()) {
      const r2 = t2;
      var n2 = this.v0, i2 = this.v1, a2 = this.v2, t2 = this.v3;
      return r2.set(CubicBezier(e2, n2.x, i2.x, a2.x, t2.x), CubicBezier(e2, n2.y, i2.y, a2.y, t2.y), CubicBezier(e2, n2.z, i2.z, a2.z, t2.z)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  class LineCurve extends Curve {
    constructor(e2 = new Vector2(), t2 = new Vector2()) {
      super(), this.type = "LineCurve", this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new Vector2()) {
      const r2 = t2;
      return e2 === 1 ? r2.copy(this.v2) : (r2.copy(this.v2).sub(this.v1), r2.multiplyScalar(e2).add(this.v1)), r2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    getTangent(e2, t2) {
      const r2 = t2 || new Vector2();
      return r2.copy(this.v2).sub(this.v1).normalize(), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  LineCurve.prototype.isLineCurve = true;
  class LineCurve3 extends Curve {
    constructor(e2 = new Vector3(), t2 = new Vector3()) {
      super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new Vector3()) {
      const r2 = t2;
      return e2 === 1 ? r2.copy(this.v2) : (r2.copy(this.v2).sub(this.v1), r2.multiplyScalar(e2).add(this.v1)), r2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class QuadraticBezierCurve extends Curve {
    constructor(e2 = new Vector2(), t2 = new Vector2(), r2 = new Vector2()) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = r2;
    }
    getPoint(e2, t2 = new Vector2()) {
      const r2 = t2;
      var n2 = this.v0, i2 = this.v1, t2 = this.v2;
      return r2.set(QuadraticBezier(e2, n2.x, i2.x, t2.x), QuadraticBezier(e2, n2.y, i2.y, t2.y)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  class QuadraticBezierCurve3 extends Curve {
    constructor(e2 = new Vector3(), t2 = new Vector3(), r2 = new Vector3()) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = r2;
    }
    getPoint(e2, t2 = new Vector3()) {
      const r2 = t2;
      var n2 = this.v0, i2 = this.v1, t2 = this.v2;
      return r2.set(QuadraticBezier(e2, n2.x, i2.x, t2.x), QuadraticBezier(e2, n2.y, i2.y, t2.y), QuadraticBezier(e2, n2.z, i2.z, t2.z)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  class SplineCurve extends Curve {
    constructor(e2 = []) {
      super(), this.type = "SplineCurve", this.points = e2;
    }
    getPoint(e2, t2 = new Vector2()) {
      const r2 = t2;
      var n2 = this.points, i2 = (n2.length - 1) * e2, a2 = Math.floor(i2), o2 = i2 - a2, t2 = n2[a2 === 0 ? a2 : a2 - 1], e2 = n2[a2], i2 = n2[a2 > n2.length - 2 ? n2.length - 1 : a2 + 1], a2 = n2[a2 > n2.length - 3 ? n2.length - 1 : a2 + 2];
      return r2.set(CatmullRom(o2, t2.x, e2.x, i2.x, a2.x), CatmullRom(o2, t2.y, e2.y, i2.y, a2.y)), r2;
    }
    copy(r2) {
      super.copy(r2), this.points = [];
      for (let e2 = 0, t2 = r2.points.length; e2 < t2; e2++) {
        const n2 = r2.points[e2];
        this.points.push(n2.clone());
      }
      return this;
    }
    toJSON() {
      const r2 = super.toJSON();
      r2.points = [];
      for (let e2 = 0, t2 = this.points.length; e2 < t2; e2++) {
        const n2 = this.points[e2];
        r2.points.push(n2.toArray());
      }
      return r2;
    }
    fromJSON(r2) {
      super.fromJSON(r2), this.points = [];
      for (let e2 = 0, t2 = r2.points.length; e2 < t2; e2++) {
        var n2 = r2.points[e2];
        this.points.push(new Vector2().fromArray(n2));
      }
      return this;
    }
  }
  SplineCurve.prototype.isSplineCurve = true;
  var Curves = Object.freeze({ __proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve });
  class CurvePath extends Curve {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e2) {
      this.curves.push(e2);
    }
    closePath() {
      const e2 = this.curves[0].getPoint(0);
      var t2 = this.curves[this.curves.length - 1].getPoint(1);
      e2.equals(t2) || this.curves.push(new LineCurve(t2, e2));
    }
    getPoint(e2, t2) {
      var r2 = e2 * this.getLength(), n2 = this.getCurveLengths();
      let i2 = 0;
      for (; i2 < n2.length; ) {
        if (n2[i2] >= r2) {
          var a2 = n2[i2] - r2;
          const s2 = this.curves[i2];
          var o2 = s2.getLength();
          return s2.getPointAt(o2 === 0 ? 0 : 1 - a2 / o2, t2);
        }
        i2++;
      }
      return null;
    }
    getLength() {
      var e2 = this.getCurveLengths();
      return e2[e2.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const r2 = [];
      let n2 = 0;
      for (let e2 = 0, t2 = this.curves.length; e2 < t2; e2++)
        n2 += this.curves[e2].getLength(), r2.push(n2);
      return this.cacheLengths = r2, r2;
    }
    getSpacedPoints(t2 = 40) {
      const r2 = [];
      for (let e2 = 0; e2 <= t2; e2++)
        r2.push(this.getPoint(e2 / t2));
      return this.autoClose && r2.push(r2[0]), r2;
    }
    getPoints(r2 = 12) {
      const n2 = [];
      let i2;
      for (let e2 = 0, t2 = this.curves; e2 < t2.length; e2++) {
        const l2 = t2[e2];
        var a2 = l2 && l2.isEllipseCurve ? 2 * r2 : l2 && (l2.isLineCurve || l2.isLineCurve3) ? 1 : l2 && l2.isSplineCurve ? r2 * l2.points.length : r2, o2 = l2.getPoints(a2);
        for (let e3 = 0; e3 < o2.length; e3++) {
          var s2 = o2[e3];
          i2 && i2.equals(s2) || (n2.push(s2), i2 = s2);
        }
      }
      return this.autoClose && 1 < n2.length && !n2[n2.length - 1].equals(n2[0]) && n2.push(n2[0]), n2;
    }
    copy(r2) {
      super.copy(r2), this.curves = [];
      for (let e2 = 0, t2 = r2.curves.length; e2 < t2; e2++) {
        const n2 = r2.curves[e2];
        this.curves.push(n2.clone());
      }
      return this.autoClose = r2.autoClose, this;
    }
    toJSON() {
      const r2 = super.toJSON();
      r2.autoClose = this.autoClose, r2.curves = [];
      for (let e2 = 0, t2 = this.curves.length; e2 < t2; e2++) {
        const n2 = this.curves[e2];
        r2.curves.push(n2.toJSON());
      }
      return r2;
    }
    fromJSON(r2) {
      super.fromJSON(r2), this.autoClose = r2.autoClose, this.curves = [];
      for (let e2 = 0, t2 = r2.curves.length; e2 < t2; e2++) {
        var n2 = r2.curves[e2];
        this.curves.push(new Curves[n2.type]().fromJSON(n2));
      }
      return this;
    }
  }
  class Path extends CurvePath {
    constructor(e2) {
      super(), this.type = "Path", this.currentPoint = new Vector2(), e2 && this.setFromPoints(e2);
    }
    setFromPoints(r2) {
      this.moveTo(r2[0].x, r2[0].y);
      for (let e2 = 1, t2 = r2.length; e2 < t2; e2++)
        this.lineTo(r2[e2].x, r2[e2].y);
      return this;
    }
    moveTo(e2, t2) {
      return this.currentPoint.set(e2, t2), this;
    }
    lineTo(e2, t2) {
      var r2 = new LineCurve(this.currentPoint.clone(), new Vector2(e2, t2));
      return this.curves.push(r2), this.currentPoint.set(e2, t2), this;
    }
    quadraticCurveTo(e2, t2, r2, n2) {
      t2 = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(e2, t2), new Vector2(r2, n2));
      return this.curves.push(t2), this.currentPoint.set(r2, n2), this;
    }
    bezierCurveTo(e2, t2, r2, n2, i2, a2) {
      n2 = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(e2, t2), new Vector2(r2, n2), new Vector2(i2, a2));
      return this.curves.push(n2), this.currentPoint.set(i2, a2), this;
    }
    splineThru(e2) {
      var t2 = [this.currentPoint.clone()].concat(e2), t2 = new SplineCurve(t2);
      return this.curves.push(t2), this.currentPoint.copy(e2[e2.length - 1]), this;
    }
    arc(e2, t2, r2, n2, i2, a2) {
      var o2 = this.currentPoint.x, s2 = this.currentPoint.y;
      return this.absarc(e2 + o2, t2 + s2, r2, n2, i2, a2), this;
    }
    absarc(e2, t2, r2, n2, i2, a2) {
      return this.absellipse(e2, t2, r2, r2, n2, i2, a2), this;
    }
    ellipse(e2, t2, r2, n2, i2, a2, o2, s2) {
      var l2 = this.currentPoint.x, c2 = this.currentPoint.y;
      return this.absellipse(e2 + l2, t2 + c2, r2, n2, i2, a2, o2, s2), this;
    }
    absellipse(e2, t2, r2, n2, i2, a2, o2, s2) {
      const l2 = new EllipseCurve(e2, t2, r2, n2, i2, a2, o2, s2);
      if (0 < this.curves.length) {
        const c2 = l2.getPoint(0);
        c2.equals(this.currentPoint) || this.lineTo(c2.x, c2.y);
      }
      this.curves.push(l2);
      s2 = l2.getPoint(1);
      return this.currentPoint.copy(s2), this;
    }
    copy(e2) {
      return super.copy(e2), this.currentPoint.copy(e2.currentPoint), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.currentPoint = this.currentPoint.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.currentPoint.fromArray(e2.currentPoint), this;
    }
  }
  class Shape extends Path {
    constructor(e2) {
      super(e2), this.uuid = generateUUID(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(r2) {
      const n2 = [];
      for (let e2 = 0, t2 = this.holes.length; e2 < t2; e2++)
        n2[e2] = this.holes[e2].getPoints(r2);
      return n2;
    }
    extractPoints(e2) {
      return { shape: this.getPoints(e2), holes: this.getPointsHoles(e2) };
    }
    copy(r2) {
      super.copy(r2), this.holes = [];
      for (let e2 = 0, t2 = r2.holes.length; e2 < t2; e2++) {
        const n2 = r2.holes[e2];
        this.holes.push(n2.clone());
      }
      return this;
    }
    toJSON() {
      const r2 = super.toJSON();
      r2.uuid = this.uuid, r2.holes = [];
      for (let e2 = 0, t2 = this.holes.length; e2 < t2; e2++) {
        const n2 = this.holes[e2];
        r2.holes.push(n2.toJSON());
      }
      return r2;
    }
    fromJSON(r2) {
      super.fromJSON(r2), this.uuid = r2.uuid, this.holes = [];
      for (let e2 = 0, t2 = r2.holes.length; e2 < t2; e2++) {
        var n2 = r2.holes[e2];
        this.holes.push(new Path().fromJSON(n2));
      }
      return this;
    }
  }
  const Earcut = { triangulate: function(t2, e2, r2 = 2) {
    var n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
    let a2 = linkedList(t2, 0, i2, r2, true);
    var o2 = [];
    if (!a2 || a2.next === a2.prev)
      return o2;
    let s2, l2, c2, u2, h2, d2, p2;
    if (n2 && (a2 = eliminateHoles(t2, e2, a2, r2)), t2.length > 80 * r2) {
      s2 = c2 = t2[0], l2 = u2 = t2[1];
      for (let e3 = r2; e3 < i2; e3 += r2)
        h2 = t2[e3], d2 = t2[e3 + 1], h2 < s2 && (s2 = h2), d2 < l2 && (l2 = d2), h2 > c2 && (c2 = h2), d2 > u2 && (u2 = d2);
      p2 = Math.max(c2 - s2, u2 - l2), p2 = p2 !== 0 ? 1 / p2 : 0;
    }
    return earcutLinked(a2, o2, r2, s2, l2, p2), o2;
  } };
  function linkedList(e2, t2, r2, n2, i2) {
    let a2, o2;
    if (i2 === 0 < signedArea(e2, t2, r2, n2))
      for (a2 = t2; a2 < r2; a2 += n2)
        o2 = insertNode(a2, e2[a2], e2[a2 + 1], o2);
    else
      for (a2 = r2 - n2; a2 >= t2; a2 -= n2)
        o2 = insertNode(a2, e2[a2], e2[a2 + 1], o2);
    return o2 && equals(o2, o2.next) && (removeNode(o2), o2 = o2.next), o2;
  }
  function filterPoints(e2, t2) {
    if (!e2)
      return e2;
    t2 = t2 || e2;
    let r2 = e2, n2;
    do {
      if (n2 = false, r2.steiner || !equals(r2, r2.next) && area(r2.prev, r2, r2.next) !== 0)
        r2 = r2.next;
      else {
        if (removeNode(r2), r2 = t2 = r2.prev, r2 === r2.next)
          break;
        n2 = true;
      }
    } while (n2 || r2 !== t2);
    return t2;
  }
  function earcutLinked(n2, i2, a2, o2, s2, l2, c2) {
    if (n2) {
      !c2 && l2 && indexCurve(n2, o2, s2, l2);
      let e2 = n2, t2, r2;
      for (; n2.prev !== n2.next; )
        if (t2 = n2.prev, r2 = n2.next, l2 ? isEarHashed(n2, o2, s2, l2) : isEar(n2))
          i2.push(t2.i / a2), i2.push(n2.i / a2), i2.push(r2.i / a2), removeNode(n2), n2 = r2.next, e2 = r2.next;
        else if ((n2 = r2) === e2) {
          c2 ? c2 === 1 ? earcutLinked(n2 = cureLocalIntersections(filterPoints(n2), i2, a2), i2, a2, o2, s2, l2, 2) : c2 === 2 && splitEarcut(n2, i2, a2, o2, s2, l2) : earcutLinked(filterPoints(n2), i2, a2, o2, s2, l2, 1);
          break;
        }
    }
  }
  function isEar(t2) {
    var r2 = t2.prev, n2 = t2, i2 = t2.next;
    if (!(0 <= area(r2, n2, i2))) {
      let e2 = t2.next.next;
      for (; e2 !== t2.prev; ) {
        if (pointInTriangle(r2.x, r2.y, n2.x, n2.y, i2.x, i2.y, e2.x, e2.y) && 0 <= area(e2.prev, e2, e2.next))
          return;
        e2 = e2.next;
      }
      return 1;
    }
  }
  function isEarHashed(r2, n2, i2, a2) {
    var o2 = r2.prev, s2 = r2, l2 = r2.next;
    if (!(0 <= area(o2, s2, l2))) {
      var c2 = (o2.x < s2.x ? o2.x < l2.x ? o2 : l2 : s2.x < l2.x ? s2 : l2).x, u2 = (o2.y < s2.y ? o2.y < l2.y ? o2 : l2 : s2.y < l2.y ? s2 : l2).y, h2 = (o2.x > s2.x ? o2.x > l2.x ? o2 : l2 : s2.x > l2.x ? s2 : l2).x, d2 = (o2.y > s2.y ? o2.y > l2.y ? o2 : l2 : s2.y > l2.y ? s2 : l2).y, p2 = zOrder(c2, u2, n2, i2, a2), f2 = zOrder(h2, d2, n2, i2, a2);
      let e2 = r2.prevZ, t2 = r2.nextZ;
      for (; e2 && e2.z >= p2 && t2 && t2.z <= f2; ) {
        if (e2 !== r2.prev && e2 !== r2.next && pointInTriangle(o2.x, o2.y, s2.x, s2.y, l2.x, l2.y, e2.x, e2.y) && 0 <= area(e2.prev, e2, e2.next))
          return;
        if (e2 = e2.prevZ, t2 !== r2.prev && t2 !== r2.next && pointInTriangle(o2.x, o2.y, s2.x, s2.y, l2.x, l2.y, t2.x, t2.y) && 0 <= area(t2.prev, t2, t2.next))
          return;
        t2 = t2.nextZ;
      }
      for (; e2 && e2.z >= p2; ) {
        if (e2 !== r2.prev && e2 !== r2.next && pointInTriangle(o2.x, o2.y, s2.x, s2.y, l2.x, l2.y, e2.x, e2.y) && 0 <= area(e2.prev, e2, e2.next))
          return;
        e2 = e2.prevZ;
      }
      for (; t2 && t2.z <= f2; ) {
        if (t2 !== r2.prev && t2 !== r2.next && pointInTriangle(o2.x, o2.y, s2.x, s2.y, l2.x, l2.y, t2.x, t2.y) && 0 <= area(t2.prev, t2, t2.next))
          return;
        t2 = t2.nextZ;
      }
      return 1;
    }
  }
  function cureLocalIntersections(e2, t2, r2) {
    let n2 = e2;
    do {
      var i2 = n2.prev, a2 = n2.next.next;
      !equals(i2, a2) && intersects(i2, n2, n2.next, a2) && locallyInside(i2, a2) && locallyInside(a2, i2) && (t2.push(i2.i / r2), t2.push(n2.i / r2), t2.push(a2.i / r2), removeNode(n2), removeNode(n2.next), n2 = e2 = a2), n2 = n2.next;
    } while (n2 !== e2);
    return filterPoints(n2);
  }
  function splitEarcut(e2, t2, r2, n2, i2, a2) {
    let o2 = e2;
    do {
      let e3 = o2.next.next;
      for (; e3 !== o2.prev; ) {
        if (o2.i !== e3.i && isValidDiagonal(o2, e3)) {
          var s2 = splitPolygon(o2, e3);
          return o2 = filterPoints(o2, o2.next), s2 = filterPoints(s2, s2.next), earcutLinked(o2, t2, r2, n2, i2, a2), void earcutLinked(s2, t2, r2, n2, i2, a2);
        }
        e3 = e3.next;
      }
    } while (o2 = o2.next, o2 !== e2);
  }
  function eliminateHoles(e2, t2, r2, n2) {
    const i2 = [];
    let a2, o2, s2, l2, c2;
    for (a2 = 0, o2 = t2.length; a2 < o2; a2++)
      s2 = t2[a2] * n2, l2 = a2 < o2 - 1 ? t2[a2 + 1] * n2 : e2.length, c2 = linkedList(e2, s2, l2, n2, false), c2 === c2.next && (c2.steiner = true), i2.push(getLeftmost(c2));
    for (i2.sort(compareX), a2 = 0; a2 < i2.length; a2++)
      eliminateHole(i2[a2], r2), r2 = filterPoints(r2, r2.next);
    return r2;
  }
  function compareX(e2, t2) {
    return e2.x - t2.x;
  }
  function eliminateHole(e2, t2) {
    (t2 = findHoleBridge(e2, t2)) && (e2 = splitPolygon(t2, e2), filterPoints(t2, t2.next), filterPoints(e2, e2.next));
  }
  function findHoleBridge(e2, t2) {
    let r2 = t2;
    var n2 = e2.x, i2 = e2.y;
    let a2 = -1 / 0, o2;
    do {
      if (i2 <= r2.y && i2 >= r2.next.y && r2.next.y !== r2.y) {
        var s2 = r2.x + (i2 - r2.y) * (r2.next.x - r2.x) / (r2.next.y - r2.y);
        if (s2 <= n2 && s2 > a2) {
          if ((a2 = s2) === n2) {
            if (i2 === r2.y)
              return r2;
            if (i2 === r2.next.y)
              return r2.next;
          }
          o2 = r2.x < r2.next.x ? r2 : r2.next;
        }
      }
    } while (r2 = r2.next, r2 !== t2);
    if (!o2)
      return null;
    if (n2 === a2)
      return o2;
    var l2 = o2, c2 = o2.x, u2 = o2.y;
    let h2 = 1 / 0, d2;
    for (r2 = o2; n2 >= r2.x && r2.x >= c2 && n2 !== r2.x && pointInTriangle(i2 < u2 ? n2 : a2, i2, c2, u2, i2 < u2 ? a2 : n2, i2, r2.x, r2.y) && (d2 = Math.abs(i2 - r2.y) / (n2 - r2.x), locallyInside(r2, e2) && (d2 < h2 || d2 === h2 && (r2.x > o2.x || r2.x === o2.x && sectorContainsSector(o2, r2))) && (o2 = r2, h2 = d2)), r2 = r2.next, r2 !== l2; )
      ;
    return o2;
  }
  function sectorContainsSector(e2, t2) {
    return area(e2.prev, e2, t2.prev) < 0 && area(t2.next, e2, e2.next) < 0;
  }
  function indexCurve(e2, t2, r2, n2) {
    let i2 = e2;
    for (; i2.z === null && (i2.z = zOrder(i2.x, i2.y, t2, r2, n2)), i2.prevZ = i2.prev, i2.nextZ = i2.next, i2 = i2.next, i2 !== e2; )
      ;
    i2.prevZ.nextZ = null, i2.prevZ = null, sortLinked(i2);
  }
  function sortLinked(e2) {
    let t2, r2, n2, i2, a2, o2, s2, l2, c2 = 1;
    do {
      for (r2 = e2, e2 = null, a2 = null, o2 = 0; r2; ) {
        for (o2++, n2 = r2, s2 = 0, t2 = 0; t2 < c2 && (s2++, n2 = n2.nextZ, n2); t2++)
          ;
        for (l2 = c2; 0 < s2 || 0 < l2 && n2; )
          s2 !== 0 && (l2 === 0 || !n2 || r2.z <= n2.z) ? (i2 = r2, r2 = r2.nextZ, s2--) : (i2 = n2, n2 = n2.nextZ, l2--), a2 ? a2.nextZ = i2 : e2 = i2, i2.prevZ = a2, a2 = i2;
        r2 = n2;
      }
    } while (a2.nextZ = null, c2 *= 2, 1 < o2);
    return e2;
  }
  function zOrder(e2, t2, r2, n2, i2) {
    return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - r2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - n2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
  }
  function getLeftmost(e2) {
    let t2 = e2, r2 = e2;
    for (; (t2.x < r2.x || t2.x === r2.x && t2.y < r2.y) && (r2 = t2), t2 = t2.next, t2 !== e2; )
      ;
    return r2;
  }
  function pointInTriangle(e2, t2, r2, n2, i2, a2, o2, s2) {
    return 0 <= (i2 - o2) * (t2 - s2) - (e2 - o2) * (a2 - s2) && 0 <= (e2 - o2) * (n2 - s2) - (r2 - o2) * (t2 - s2) && 0 <= (r2 - o2) * (a2 - s2) - (i2 - o2) * (n2 - s2);
  }
  function isValidDiagonal(e2, t2) {
    return e2.next.i !== t2.i && e2.prev.i !== t2.i && !intersectsPolygon(e2, t2) && (locallyInside(e2, t2) && locallyInside(t2, e2) && middleInside(e2, t2) && (area(e2.prev, e2, t2.prev) || area(e2, t2.prev, t2)) || equals(e2, t2) && 0 < area(e2.prev, e2, e2.next) && 0 < area(t2.prev, t2, t2.next));
  }
  function area(e2, t2, r2) {
    return (t2.y - e2.y) * (r2.x - t2.x) - (t2.x - e2.x) * (r2.y - t2.y);
  }
  function equals(e2, t2) {
    return e2.x === t2.x && e2.y === t2.y;
  }
  function intersects(e2, t2, r2, n2) {
    var i2 = sign(area(e2, t2, r2)), a2 = sign(area(e2, t2, n2)), o2 = sign(area(r2, n2, e2)), s2 = sign(area(r2, n2, t2));
    return i2 !== a2 && o2 !== s2 || (i2 === 0 && onSegment(e2, r2, t2) || (a2 === 0 && onSegment(e2, n2, t2) || (o2 === 0 && onSegment(r2, e2, n2) || !(s2 !== 0 || !onSegment(r2, t2, n2)))));
  }
  function onSegment(e2, t2, r2) {
    return t2.x <= Math.max(e2.x, r2.x) && t2.x >= Math.min(e2.x, r2.x) && t2.y <= Math.max(e2.y, r2.y) && t2.y >= Math.min(e2.y, r2.y);
  }
  function sign(e2) {
    return 0 < e2 ? 1 : e2 < 0 ? -1 : 0;
  }
  function intersectsPolygon(e2, t2) {
    let r2 = e2;
    do {
      if (r2.i !== e2.i && r2.next.i !== e2.i && r2.i !== t2.i && r2.next.i !== t2.i && intersects(r2, r2.next, e2, t2))
        return 1;
    } while (r2 = r2.next, r2 !== e2);
  }
  function locallyInside(e2, t2) {
    return area(e2.prev, e2, e2.next) < 0 ? 0 <= area(e2, t2, e2.next) && 0 <= area(e2, e2.prev, t2) : area(e2, t2, e2.prev) < 0 || area(e2, e2.next, t2) < 0;
  }
  function middleInside(e2, t2) {
    let r2 = e2, n2 = false;
    for (var i2 = (e2.x + t2.x) / 2, a2 = (e2.y + t2.y) / 2; r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next, r2 !== e2; )
      ;
    return n2;
  }
  function splitPolygon(e2, t2) {
    const r2 = new Node$1(e2.i, e2.x, e2.y), n2 = new Node$1(t2.i, t2.x, t2.y), i2 = e2.next, a2 = t2.prev;
    return (e2.next = t2).prev = e2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
  }
  function insertNode(e2, t2, r2, n2) {
    const i2 = new Node$1(e2, t2, r2);
    return n2 ? (i2.next = n2.next, (i2.prev = n2).next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
  }
  function removeNode(e2) {
    e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
  }
  function Node$1(e2, t2, r2) {
    this.i = e2, this.x = t2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function signedArea(r2, n2, i2, a2) {
    let o2 = 0;
    for (let e2 = n2, t2 = i2 - a2; e2 < i2; e2 += a2)
      o2 += (r2[t2] - r2[e2]) * (r2[e2 + 1] + r2[t2 + 1]), t2 = e2;
    return o2;
  }
  class ShapeUtils {
    static area(r2) {
      var n2 = r2.length;
      let i2 = 0;
      for (let e2 = n2 - 1, t2 = 0; t2 < n2; e2 = t2++)
        i2 += r2[e2].x * r2[t2].y - r2[t2].x * r2[e2].y;
      return 0.5 * i2;
    }
    static isClockWise(e2) {
      return ShapeUtils.area(e2) < 0;
    }
    static triangulateShape(e2, t2) {
      var r2 = [];
      const n2 = [], i2 = [];
      removeDupEndPts(e2), addContour(r2, e2);
      let a2 = e2.length;
      t2.forEach(removeDupEndPts);
      for (let e3 = 0; e3 < t2.length; e3++)
        n2.push(a2), a2 += t2[e3].length, addContour(r2, t2[e3]);
      const o2 = Earcut.triangulate(r2, n2);
      for (let e3 = 0; e3 < o2.length; e3 += 3)
        i2.push(o2.slice(e3, e3 + 3));
      return i2;
    }
  }
  function removeDupEndPts(e2) {
    var t2 = e2.length;
    2 < t2 && e2[t2 - 1].equals(e2[0]) && e2.pop();
  }
  function addContour(t2, r2) {
    for (let e2 = 0; e2 < r2.length; e2++)
      t2.push(r2[e2].x), t2.push(r2[e2].y);
  }
  class ExtrudeGeometry extends BufferGeometry {
    constructor(r2 = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), J = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: r2, options: J }, r2 = Array.isArray(r2) ? r2 : [r2];
      const Q = this, ee = [], te = [];
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++)
        !function(e3) {
          const n2 = [], t3 = J.curveSegments !== void 0 ? J.curveSegments : 12, s2 = J.steps !== void 0 ? J.steps : 1;
          let r3 = J.depth !== void 0 ? J.depth : 1, o2 = J.bevelEnabled === void 0 || J.bevelEnabled, i2 = J.bevelThickness !== void 0 ? J.bevelThickness : 0.2, a2 = J.bevelSize !== void 0 ? J.bevelSize : i2 - 0.1, l2 = J.bevelOffset !== void 0 ? J.bevelOffset : 0, c2 = J.bevelSegments !== void 0 ? J.bevelSegments : 3;
          const u2 = J.extrudePath, h2 = J.UVGenerator !== void 0 ? J.UVGenerator : WorldUVGenerator;
          J.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), r3 = J.amount);
          let d2, p2 = false, f2, m2, g2, v2;
          u2 && (d2 = u2.getSpacedPoints(s2), p2 = true, o2 = false, f2 = u2.computeFrenetFrames(s2, false), m2 = new Vector3(), g2 = new Vector3(), v2 = new Vector3());
          o2 || (c2 = 0, i2 = 0, a2 = 0, l2 = 0);
          e3 = e3.extractPoints(t3);
          let y = e3.shape;
          const _2 = e3.holes, b2 = !ShapeUtils.isClockWise(y);
          if (b2) {
            y = y.reverse();
            for (let e4 = 0, t4 = _2.length; e4 < t4; e4++) {
              const K = _2[e4];
              ShapeUtils.isClockWise(K) && (_2[e4] = K.reverse());
            }
          }
          const x2 = ShapeUtils.triangulateShape(y, _2), w2 = y;
          for (let e4 = 0, t4 = _2.length; e4 < t4; e4++) {
            var S2 = _2[e4];
            y = y.concat(S2);
          }
          function M2(e4, t4, r4) {
            return t4 || console.error("THREE.ExtrudeGeometry: vec does not exist"), t4.clone().multiplyScalar(r4).add(e4);
          }
          const E2 = y.length, T2 = x2.length;
          function k2(e4, t4, r4) {
            let n3, i3, a3;
            var o3 = e4.x - t4.x, s3 = e4.y - t4.y, l3 = r4.x - e4.x, c3 = r4.y - e4.y, u3 = o3 * o3 + s3 * s3;
            if (Math.abs(o3 * c3 - s3 * l3) > Number.EPSILON) {
              var h3 = Math.sqrt(u3), d3 = Math.sqrt(l3 * l3 + c3 * c3), p3 = t4.x - s3 / h3, h3 = t4.y + o3 / h3, d3 = ((r4.x - c3 / d3 - p3) * c3 - (r4.y + l3 / d3 - h3) * l3) / (o3 * c3 - s3 * l3);
              n3 = p3 + o3 * d3 - e4.x, i3 = h3 + s3 * d3 - e4.y;
              e4 = n3 * n3 + i3 * i3;
              if (e4 <= 2)
                return new Vector2(n3, i3);
              a3 = Math.sqrt(e4 / 2);
            } else {
              let e5 = false;
              o3 > Number.EPSILON ? l3 > Number.EPSILON && (e5 = true) : o3 < -Number.EPSILON ? l3 < -Number.EPSILON && (e5 = true) : Math.sign(s3) === Math.sign(c3) && (e5 = true), a3 = e5 ? (n3 = -s3, i3 = o3, Math.sqrt(u3)) : (n3 = o3, i3 = s3, Math.sqrt(u3 / 2));
            }
            return new Vector2(n3 / a3, i3 / a3);
          }
          const A2 = [];
          for (let e4 = 0, t4 = w2.length, r4 = t4 - 1, n3 = e4 + 1; e4 < t4; e4++, r4++, n3++)
            r4 === t4 && (r4 = 0), n3 === t4 && (n3 = 0), A2[e4] = k2(w2[e4], w2[r4], w2[n3]);
          const C2 = [];
          let $2, R2 = A2.concat();
          for (let e4 = 0, t4 = _2.length; e4 < t4; e4++) {
            var L = _2[e4];
            $2 = [];
            for (let e5 = 0, t5 = L.length, r4 = t5 - 1, n3 = e5 + 1; e5 < t5; e5++, r4++, n3++)
              r4 === t5 && (r4 = 0), n3 === t5 && (n3 = 0), $2[e5] = k2(L[e5], L[r4], L[n3]);
            C2.push($2), R2 = R2.concat($2);
          }
          for (let e4 = 0; e4 < c2; e4++) {
            var O = e4 / c2, P2 = i2 * Math.cos(O * Math.PI / 2);
            const B2 = a2 * Math.sin(O * Math.PI / 2) + l2;
            for (let e5 = 0, t4 = w2.length; e5 < t4; e5++) {
              var I2 = M2(w2[e5], A2[e5], B2);
              q(I2.x, I2.y, -P2);
            }
            for (let e5 = 0, t4 = _2.length; e5 < t4; e5++) {
              var D = _2[e5];
              $2 = C2[e5];
              for (let e6 = 0, t5 = D.length; e6 < t5; e6++) {
                var N2 = M2(D[e6], $2[e6], B2);
                q(N2.x, N2.y, -P2);
              }
            }
          }
          const B = a2 + l2;
          for (let e4 = 0; e4 < E2; e4++) {
            var F = o2 ? M2(y[e4], R2[e4], B) : y[e4];
            p2 ? (g2.copy(f2.normals[0]).multiplyScalar(F.x), m2.copy(f2.binormals[0]).multiplyScalar(F.y), v2.copy(d2[0]).add(g2).add(m2), q(v2.x, v2.y, v2.z)) : q(F.x, F.y, 0);
          }
          for (let t4 = 1; t4 <= s2; t4++)
            for (let e4 = 0; e4 < E2; e4++) {
              var j2 = o2 ? M2(y[e4], R2[e4], B) : y[e4];
              p2 ? (g2.copy(f2.normals[t4]).multiplyScalar(j2.x), m2.copy(f2.binormals[t4]).multiplyScalar(j2.y), v2.copy(d2[t4]).add(g2).add(m2), q(v2.x, v2.y, v2.z)) : q(j2.x, j2.y, r3 / s2 * t4);
            }
          for (let e4 = c2 - 1; 0 <= e4; e4--) {
            var U = e4 / c2, V2 = i2 * Math.cos(U * Math.PI / 2);
            const B2 = a2 * Math.sin(U * Math.PI / 2) + l2;
            for (let e5 = 0, t4 = w2.length; e5 < t4; e5++) {
              var z = M2(w2[e5], A2[e5], B2);
              q(z.x, z.y, r3 + V2);
            }
            for (let e5 = 0, t4 = _2.length; e5 < t4; e5++) {
              var H2 = _2[e5];
              $2 = C2[e5];
              for (let e6 = 0, t5 = H2.length; e6 < t5; e6++) {
                var G = M2(H2[e6], $2[e6], B2);
                p2 ? q(G.x, G.y + d2[s2 - 1].y, d2[s2 - 1].x + V2) : q(G.x, G.y, r3 + V2);
              }
            }
          }
          function W(e4, n3) {
            let t4 = e4.length;
            for (; 0 <= --t4; ) {
              var i3 = t4;
              let r4 = t4 - 1;
              r4 < 0 && (r4 = e4.length - 1);
              for (let e5 = 0, t5 = s2 + 2 * c2; e5 < t5; e5++) {
                var a3 = E2 * e5, o3 = E2 * (e5 + 1);
                !function(e6, t6, r5, n4) {
                  X(e6), X(t6), X(n4), X(t6), X(r5), X(n4);
                  n4 = ee.length / 3, n4 = h2.generateSideWallUV(Q, ee, n4 - 6, n4 - 3, n4 - 2, n4 - 1);
                  Z(n4[0]), Z(n4[1]), Z(n4[3]), Z(n4[1]), Z(n4[2]), Z(n4[3]);
                }(n3 + i3 + a3, n3 + r4 + a3, n3 + r4 + o3, n3 + i3 + o3);
              }
            }
          }
          function q(e4, t4, r4) {
            n2.push(e4), n2.push(t4), n2.push(r4);
          }
          function Y(e4, t4, r4) {
            X(e4), X(t4), X(r4);
            r4 = ee.length / 3, r4 = h2.generateTopUV(Q, ee, r4 - 3, r4 - 2, r4 - 1);
            Z(r4[0]), Z(r4[1]), Z(r4[2]);
          }
          function X(e4) {
            ee.push(n2[3 * e4 + 0]), ee.push(n2[3 * e4 + 1]), ee.push(n2[3 * e4 + 2]);
          }
          function Z(e4) {
            te.push(e4.x), te.push(e4.y);
          }
          (function() {
            var e4, t4 = ee.length / 3;
            if (o2) {
              let t5 = 0 * E2;
              for (let e5 = 0; e5 < T2; e5++) {
                var r4 = x2[e5];
                Y(r4[2] + t5, r4[1] + t5, r4[0] + t5);
              }
              e4 = s2 + 2 * c2, t5 = E2 * e4;
              for (let e5 = 0; e5 < T2; e5++) {
                var n3 = x2[e5];
                Y(n3[0] + t5, n3[1] + t5, n3[2] + t5);
              }
            } else {
              for (let e5 = 0; e5 < T2; e5++) {
                var i3 = x2[e5];
                Y(i3[2], i3[1], i3[0]);
              }
              for (let e5 = 0; e5 < T2; e5++) {
                var a3 = x2[e5];
                Y(a3[0] + E2 * s2, a3[1] + E2 * s2, a3[2] + E2 * s2);
              }
            }
            Q.addGroup(t4, ee.length / 3 - t4, 0);
          })(), function() {
            var e4 = ee.length / 3;
            let r4 = 0;
            W(w2, r4), r4 += w2.length;
            for (let e5 = 0, t4 = _2.length; e5 < t4; e5++) {
              var n3 = _2[e5];
              W(n3, r4), r4 += n3.length;
            }
            Q.addGroup(e4, ee.length / 3 - e4, 1);
          }();
        }(r2[e2]);
      this.setAttribute("position", new Float32BufferAttribute(ee, 3)), this.setAttribute("uv", new Float32BufferAttribute(te, 2)), this.computeVertexNormals();
    }
    toJSON() {
      var e2 = super.toJSON();
      return toJSON$1(this.parameters.shapes, this.parameters.options, e2);
    }
    static fromJSON(r2, n2) {
      const i2 = [];
      for (let e3 = 0, t2 = r2.shapes.length; e3 < t2; e3++) {
        var a2 = n2[r2.shapes[e3]];
        i2.push(a2);
      }
      var e2 = r2.options.extrudePath;
      return e2 !== void 0 && (r2.options.extrudePath = new Curves[e2.type]().fromJSON(e2)), new ExtrudeGeometry(i2, r2.options);
    }
  }
  const WorldUVGenerator = { generateTopUV: function(e2, t2, r2, n2, i2) {
    var a2 = t2[3 * r2], o2 = t2[3 * r2 + 1], s2 = t2[3 * n2], r2 = t2[3 * n2 + 1], n2 = t2[3 * i2], i2 = t2[3 * i2 + 1];
    return [new Vector2(a2, o2), new Vector2(s2, r2), new Vector2(n2, i2)];
  }, generateSideWallUV: function(e2, t2, r2, n2, i2, a2) {
    var o2 = t2[3 * r2], s2 = t2[3 * r2 + 1], l2 = t2[3 * r2 + 2], c2 = t2[3 * n2], u2 = t2[3 * n2 + 1], h2 = t2[3 * n2 + 2], d2 = t2[3 * i2], p2 = t2[3 * i2 + 1], r2 = t2[3 * i2 + 2], n2 = t2[3 * a2], i2 = t2[3 * a2 + 1], a2 = t2[3 * a2 + 2];
    return Math.abs(s2 - u2) < Math.abs(o2 - c2) ? [new Vector2(o2, 1 - l2), new Vector2(c2, 1 - h2), new Vector2(d2, 1 - r2), new Vector2(n2, 1 - a2)] : [new Vector2(s2, 1 - l2), new Vector2(u2, 1 - h2), new Vector2(p2, 1 - r2), new Vector2(i2, 1 - a2)];
  } };
  function toJSON$1(r2, e2, n2) {
    if (n2.shapes = [], Array.isArray(r2))
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++) {
        var i2 = r2[e3];
        n2.shapes.push(i2.uuid);
      }
    else
      n2.shapes.push(r2.uuid);
    return e2.extrudePath !== void 0 && (n2.options.extrudePath = e2.extrudePath.toJSON()), n2;
  }
  class ShapeGeometry extends BufferGeometry {
    constructor(t2 = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), d2 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: t2, curveSegments: d2 };
      const p2 = [], f2 = [], m2 = [], g2 = [];
      let r2 = 0, v2 = 0;
      if (Array.isArray(t2) === false)
        n2(t2);
      else
        for (let e2 = 0; e2 < t2.length; e2++)
          n2(t2[e2]), this.addGroup(r2, v2, e2), r2 += v2, v2 = 0;
      function n2(e2) {
        var r3 = f2.length / 3, e2 = e2.extractPoints(d2);
        let n3 = e2.shape;
        const i2 = e2.holes;
        ShapeUtils.isClockWise(n3) === false && (n3 = n3.reverse());
        for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
          const h2 = i2[e3];
          ShapeUtils.isClockWise(h2) === true && (i2[e3] = h2.reverse());
        }
        var a2 = ShapeUtils.triangulateShape(n3, i2);
        for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
          var o2 = i2[e3];
          n3 = n3.concat(o2);
        }
        for (let e3 = 0, t3 = n3.length; e3 < t3; e3++) {
          var s2 = n3[e3];
          f2.push(s2.x, s2.y, 0), m2.push(0, 0, 1), g2.push(s2.x, s2.y);
        }
        for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
          var l2 = a2[e3], c2 = l2[0] + r3, u2 = l2[1] + r3, l2 = l2[2] + r3;
          p2.push(c2, u2, l2), v2 += 3;
        }
      }
      this.setIndex(p2), this.setAttribute("position", new Float32BufferAttribute(f2, 3)), this.setAttribute("normal", new Float32BufferAttribute(m2, 3)), this.setAttribute("uv", new Float32BufferAttribute(g2, 2));
    }
    toJSON() {
      var e2 = super.toJSON();
      return toJSON(this.parameters.shapes, e2);
    }
    static fromJSON(r2, n2) {
      const i2 = [];
      for (let e2 = 0, t2 = r2.shapes.length; e2 < t2; e2++) {
        var a2 = n2[r2.shapes[e2]];
        i2.push(a2);
      }
      return new ShapeGeometry(i2, r2.curveSegments);
    }
  }
  function toJSON(r2, n2) {
    if (n2.shapes = [], Array.isArray(r2))
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++) {
        var i2 = r2[e2];
        n2.shapes.push(i2.uuid);
      }
    else
      n2.shapes.push(r2.uuid);
    return n2;
  }
  class SphereGeometry extends BufferGeometry {
    constructor(r2 = 1, n2 = 32, i2 = 16, a2 = 0, o2 = 2 * Math.PI, s2 = 0, l2 = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = { radius: r2, widthSegments: n2, heightSegments: i2, phiStart: a2, phiLength: o2, thetaStart: s2, thetaLength: l2 }, n2 = Math.max(3, Math.floor(n2)), i2 = Math.max(2, Math.floor(i2));
      var c2 = Math.min(s2 + l2, Math.PI);
      let u2 = 0;
      const h2 = [], d2 = new Vector3(), p2 = new Vector3(), f2 = [], m2 = [], g2 = [], v2 = [];
      for (let e2 = 0; e2 <= i2; e2++) {
        const M2 = [];
        var y = e2 / i2;
        let t2 = 0;
        e2 == 0 && s2 == 0 ? t2 = 0.5 / n2 : e2 == i2 && c2 == Math.PI && (t2 = -0.5 / n2);
        for (let e3 = 0; e3 <= n2; e3++) {
          var _2 = e3 / n2;
          d2.x = -r2 * Math.cos(a2 + _2 * o2) * Math.sin(s2 + y * l2), d2.y = r2 * Math.cos(s2 + y * l2), d2.z = r2 * Math.sin(a2 + _2 * o2) * Math.sin(s2 + y * l2), m2.push(d2.x, d2.y, d2.z), p2.copy(d2).normalize(), g2.push(p2.x, p2.y, p2.z), v2.push(_2 + t2, 1 - y), M2.push(u2++);
        }
        h2.push(M2);
      }
      for (let t2 = 0; t2 < i2; t2++)
        for (let e2 = 0; e2 < n2; e2++) {
          var b2 = h2[t2][e2 + 1], x2 = h2[t2][e2], w2 = h2[t2 + 1][e2], S2 = h2[t2 + 1][e2 + 1];
          (t2 !== 0 || 0 < s2) && f2.push(b2, x2, S2), (t2 !== i2 - 1 || c2 < Math.PI) && f2.push(x2, w2, S2);
        }
      this.setIndex(f2), this.setAttribute("position", new Float32BufferAttribute(m2, 3)), this.setAttribute("normal", new Float32BufferAttribute(g2, 3)), this.setAttribute("uv", new Float32BufferAttribute(v2, 2));
    }
    static fromJSON(e2) {
      return new SphereGeometry(e2.radius, e2.widthSegments, e2.heightSegments, e2.phiStart, e2.phiLength, e2.thetaStart, e2.thetaLength);
    }
  }
  class ShadowMaterial extends Material {
    constructor(e2) {
      super(), this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this;
    }
  }
  ShadowMaterial.prototype.isShadowMaterial = true;
  class MeshStandardMaterial extends Material {
    constructor(e2) {
      super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "" }, this.color.copy(e2.color), this.roughness = e2.roughness, this.metalness = e2.metalness, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.roughnessMap = e2.roughnessMap, this.metalnessMap = e2.metalnessMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.envMapIntensity = e2.envMapIntensity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this;
    }
  }
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  class MeshPhysicalMaterial extends MeshStandardMaterial {
    constructor(e2) {
      super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      }, set: function(e3) {
        this.ior = (1 + 0.4 * e3) / (1 - 0.4 * e3);
      } }), this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e2);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e2) {
      0 < this._sheen != 0 < e2 && this.version++, this._sheen = e2;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e2) {
      0 < this._clearcoat != 0 < e2 && this.version++, this._clearcoat = e2;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e2) {
      0 < this._transmission != 0 < e2 && this.version++, this._transmission = e2;
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e2.clearcoat, this.clearcoatMap = e2.clearcoatMap, this.clearcoatRoughness = e2.clearcoatRoughness, this.clearcoatRoughnessMap = e2.clearcoatRoughnessMap, this.clearcoatNormalMap = e2.clearcoatNormalMap, this.clearcoatNormalScale.copy(e2.clearcoatNormalScale), this.ior = e2.ior, this.sheen = e2.sheen, this.sheenColor.copy(e2.sheenColor), this.sheenColorMap = e2.sheenColorMap, this.sheenRoughness = e2.sheenRoughness, this.sheenRoughnessMap = e2.sheenRoughnessMap, this.transmission = e2.transmission, this.transmissionMap = e2.transmissionMap, this.thickness = e2.thickness, this.thicknessMap = e2.thicknessMap, this.attenuationDistance = e2.attenuationDistance, this.attenuationColor.copy(e2.attenuationColor), this.specularIntensity = e2.specularIntensity, this.specularIntensityMap = e2.specularIntensityMap, this.specularColor.copy(e2.specularColor), this.specularColorMap = e2.specularColorMap, this;
    }
  }
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  class MeshPhongMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.specular.copy(e2.specular), this.shininess = e2.shininess, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this;
    }
  }
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  class MeshToonMaterial extends Material {
    constructor(e2) {
      super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.gradientMap = e2.gradientMap, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this;
    }
  }
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  class MeshNormalMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.flatShading = e2.flatShading, this;
    }
  }
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  class MeshLambertMaterial extends Material {
    constructor(e2) {
      super(), this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this;
    }
  }
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  class MeshMatcapMaterial extends Material {
    constructor(e2) {
      super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { MATCAP: "" }, this.color.copy(e2.color), this.matcap = e2.matcap, this.map = e2.map, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.flatShading = e2.flatShading, this;
    }
  }
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  class LineDashedMaterial extends LineBasicMaterial {
    constructor(e2) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.scale = e2.scale, this.dashSize = e2.dashSize, this.gapSize = e2.gapSize, this;
    }
  }
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  const AnimationUtils = { arraySlice: function(e2, t2, r2) {
    return AnimationUtils.isTypedArray(e2) ? new e2.constructor(e2.subarray(t2, r2 !== void 0 ? r2 : e2.length)) : e2.slice(t2, r2);
  }, convertArray: function(e2, t2, r2) {
    return !e2 || !r2 && e2.constructor === t2 ? e2 : typeof t2.BYTES_PER_ELEMENT == "number" ? new t2(e2) : Array.prototype.slice.call(e2);
  }, isTypedArray: function(e2) {
    return ArrayBuffer.isView(e2) && !(e2 instanceof DataView);
  }, getKeyframeOrder: function(r2) {
    var t2 = r2.length;
    const n2 = new Array(t2);
    for (let e2 = 0; e2 !== t2; ++e2)
      n2[e2] = e2;
    return n2.sort(function(e2, t3) {
      return r2[e2] - r2[t3];
    }), n2;
  }, sortedArray: function(r2, n2, i2) {
    var a2 = r2.length;
    const o2 = new r2.constructor(a2);
    for (let e2 = 0, t2 = 0; t2 !== a2; ++e2) {
      var s2 = i2[e2] * n2;
      for (let e3 = 0; e3 !== n2; ++e3)
        o2[t2++] = r2[s2 + e3];
    }
    return o2;
  }, flattenJSON: function(t2, r2, n2, i2) {
    let a2 = 1, o2 = t2[0];
    for (; o2 !== void 0 && o2[i2] === void 0; )
      o2 = t2[a2++];
    if (o2 !== void 0) {
      let e2 = o2[i2];
      if (e2 !== void 0)
        if (Array.isArray(e2))
          for (; e2 = o2[i2], e2 !== void 0 && (r2.push(o2.time), n2.push.apply(n2, e2)), o2 = t2[a2++], o2 !== void 0; )
            ;
        else if (e2.toArray !== void 0)
          for (; e2 = o2[i2], e2 !== void 0 && (r2.push(o2.time), e2.toArray(n2, n2.length)), o2 = t2[a2++], o2 !== void 0; )
            ;
        else
          for (; e2 = o2[i2], e2 !== void 0 && (r2.push(o2.time), n2.push(e2)), o2 = t2[a2++], o2 !== void 0; )
            ;
    }
  }, subclip: function(e2, t2, r2, n2, i2 = 30) {
    const a2 = e2.clone();
    a2.name = t2;
    const o2 = [];
    for (let e3 = 0; e3 < a2.tracks.length; ++e3) {
      const u2 = a2.tracks[e3];
      var s2 = u2.getValueSize();
      const h2 = [], d2 = [];
      for (let t3 = 0; t3 < u2.times.length; ++t3) {
        var l2 = u2.times[t3] * i2;
        if (!(l2 < r2 || n2 <= l2)) {
          h2.push(u2.times[t3]);
          for (let e4 = 0; e4 < s2; ++e4)
            d2.push(u2.values[t3 * s2 + e4]);
        }
      }
      h2.length !== 0 && (u2.times = AnimationUtils.convertArray(h2, u2.times.constructor), u2.values = AnimationUtils.convertArray(d2, u2.values.constructor), o2.push(u2));
    }
    a2.tracks = o2;
    let c2 = 1 / 0;
    for (let e3 = 0; e3 < a2.tracks.length; ++e3)
      c2 > a2.tracks[e3].times[0] && (c2 = a2.tracks[e3].times[0]);
    for (let e3 = 0; e3 < a2.tracks.length; ++e3)
      a2.tracks[e3].shift(-1 * c2);
    return a2.resetDuration(), a2;
  }, makeClipAdditive: function(t2, e2 = 0, r2 = t2, n2 = 30) {
    var i2 = r2.tracks.length, a2 = e2 / (n2 = n2 <= 0 ? 30 : n2);
    for (let e3 = 0; e3 < i2; ++e3) {
      const m2 = r2.tracks[e3], g2 = m2.ValueTypeName;
      if (g2 !== "bool" && g2 !== "string") {
        const v2 = t2.tracks.find(function(e4) {
          return e4.name === m2.name && e4.ValueTypeName === g2;
        });
        if (v2 !== void 0) {
          let e4 = 0;
          var o2 = m2.getValueSize();
          m2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (e4 = o2 / 3);
          let t3 = 0;
          var s2 = v2.getValueSize();
          v2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (t3 = s2 / 3);
          var l2 = m2.times.length - 1;
          let r3;
          if (a2 <= m2.times[0]) {
            var c2 = e4, u2 = o2 - e4;
            r3 = AnimationUtils.arraySlice(m2.values, c2, u2);
          } else if (a2 >= m2.times[l2]) {
            var l2 = l2 * o2 + e4, h2 = l2 + o2 - e4;
            r3 = AnimationUtils.arraySlice(m2.values, l2, h2);
          } else {
            const y = m2.createInterpolant();
            h2 = e4, o2 = o2 - e4;
            y.evaluate(a2), r3 = AnimationUtils.arraySlice(y.resultBuffer, h2, o2);
          }
          if (g2 === "quaternion") {
            const _2 = new Quaternion().fromArray(r3).normalize().conjugate();
            _2.toArray(r3);
          }
          var d2 = v2.times.length;
          for (let e5 = 0; e5 < d2; ++e5) {
            var p2 = e5 * s2 + t3;
            if (g2 === "quaternion")
              Quaternion.multiplyQuaternionsFlat(v2.values, p2, r3, 0, v2.values, p2);
            else {
              var f2 = s2 - 2 * t3;
              for (let e6 = 0; e6 < f2; ++e6)
                v2.values[p2 + e6] -= r3[e6];
            }
          }
        }
      }
    }
    return t2.blendMode = AdditiveAnimationBlendMode, t2;
  } };
  class Interpolant {
    constructor(e2, t2, r2, n2) {
      this.parameterPositions = e2, this._cachedIndex = 0, this.resultBuffer = n2 !== void 0 ? n2 : new t2.constructor(r2), this.sampleValues = t2, this.valueSize = r2, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t2) {
      var r2 = this.parameterPositions;
      let n2 = this._cachedIndex, i2 = r2[n2], a2 = r2[n2 - 1];
      e: {
        t: {
          let e2;
          r: {
            n:
              if (!(t2 < i2)) {
                for (var o2 = n2 + 2; ; ) {
                  if (i2 === void 0) {
                    if (t2 < a2)
                      break n;
                    return n2 = r2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, t2, a2);
                  }
                  if (n2 === o2)
                    break;
                  if (a2 = i2, i2 = r2[++n2], t2 < i2)
                    break t;
                }
                e2 = r2.length;
                break r;
              }
            if (t2 >= a2)
              break e;
            var s2 = r2[1];
            t2 < s2 && (n2 = 2, a2 = s2);
            for (var l2 = n2 - 2; ; ) {
              if (a2 === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
              if (n2 === l2)
                break;
              if (i2 = a2, a2 = r2[--n2 - 1], t2 >= a2)
                break t;
            }
            e2 = n2, n2 = 0;
          }
          for (; n2 < e2; ) {
            var c2 = n2 + e2 >>> 1;
            t2 < r2[c2] ? e2 = c2 : n2 = 1 + c2;
          }
          if (i2 = r2[n2], a2 = r2[n2 - 1], a2 === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
          if (i2 === void 0)
            return n2 = r2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, a2, t2);
        }
        this._cachedIndex = n2, this.intervalChanged_(n2, a2, i2);
      }
      return this.interpolate_(n2, a2, t2, i2);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e2) {
      const t2 = this.resultBuffer, r2 = this.sampleValues, n2 = this.valueSize, i2 = e2 * n2;
      for (let e3 = 0; e3 !== n2; ++e3)
        t2[e3] = r2[i2 + e3];
      return t2;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_, Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
  class CubicInterpolant extends Interpolant {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
    }
    intervalChanged_(e2, t2, r2) {
      var n2 = this.parameterPositions;
      let i2 = e2 - 2, a2 = e2 + 1, o2 = n2[i2], s2 = n2[a2];
      if (o2 === void 0)
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            i2 = e2, o2 = 2 * t2 - r2;
            break;
          case WrapAroundEnding:
            i2 = n2.length - 2, o2 = t2 + n2[i2] - n2[i2 + 1];
            break;
          default:
            i2 = e2, o2 = r2;
        }
      if (s2 === void 0)
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            a2 = e2, s2 = 2 * r2 - t2;
            break;
          case WrapAroundEnding:
            a2 = 1, s2 = r2 + n2[1] - n2[0];
            break;
          default:
            a2 = e2 - 1, s2 = t2;
        }
      var l2 = 0.5 * (r2 - t2), c2 = this.valueSize;
      this._weightPrev = l2 / (t2 - o2), this._weightNext = l2 / (s2 - r2), this._offsetPrev = i2 * c2, this._offsetNext = a2 * c2;
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e2 * o2, l2 = s2 - o2, c2 = this._offsetPrev, u2 = this._offsetNext, h2 = this._weightPrev, d2 = this._weightNext, p2 = (r2 - t2) / (n2 - t2), f2 = p2 * p2, m2 = f2 * p2;
      var g2 = -h2 * m2 + 2 * h2 * f2 - h2 * p2, v2 = (1 + h2) * m2 + (-1.5 - 2 * h2) * f2 + (-0.5 + h2) * p2 + 1, y = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, _2 = d2 * m2 - d2 * f2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = g2 * a2[c2 + e3] + v2 * a2[l2 + e3] + y * a2[s2 + e3] + _2 * a2[u2 + e3];
      return i2;
    }
  }
  class LinearInterpolant extends Interpolant {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e2 * o2, l2 = s2 - o2, c2 = (r2 - t2) / (n2 - t2), u2 = 1 - c2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = a2[l2 + e3] * u2 + a2[s2 + e3] * c2;
      return i2;
    }
  }
  class DiscreteInterpolant extends Interpolant {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2) {
      return this.copySampleValue_(e2 - 1);
    }
  }
  class KeyframeTrack {
    constructor(e2, t2, r2, n2) {
      if (e2 === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t2 === void 0 || t2.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e2);
      this.name = e2, this.times = AnimationUtils.convertArray(t2, this.TimeBufferType), this.values = AnimationUtils.convertArray(r2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
    }
    static toJSON(e2) {
      const t2 = e2.constructor;
      let r2;
      var n2;
      return t2.toJSON !== this.toJSON ? r2 = t2.toJSON(e2) : (r2 = { name: e2.name, times: AnimationUtils.convertArray(e2.times, Array), values: AnimationUtils.convertArray(e2.values, Array) }, (n2 = e2.getInterpolation()) !== e2.DefaultInterpolation && (r2.interpolation = n2)), r2.type = e2.ValueTypeName, r2;
    }
    InterpolantFactoryMethodDiscrete(e2) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodLinear(e2) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodSmooth(e2) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), e2);
    }
    setInterpolation(e2) {
      let t2;
      switch (e2) {
        case InterpolateDiscrete:
          t2 = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          t2 = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          t2 = this.InterpolantFactoryMethodSmooth;
      }
      if (t2 !== void 0)
        return this.createInterpolant = t2, this;
      var r2 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (e2 === this.DefaultInterpolation)
          throw new Error(r2);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", r2), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(r2) {
      if (r2 !== 0) {
        const n2 = this.times;
        for (let e2 = 0, t2 = n2.length; e2 !== t2; ++e2)
          n2[e2] += r2;
      }
      return this;
    }
    scale(r2) {
      if (r2 !== 1) {
        const n2 = this.times;
        for (let e2 = 0, t2 = n2.length; e2 !== t2; ++e2)
          n2[e2] *= r2;
      }
      return this;
    }
    trim(e2, t2) {
      var r2, n2 = this.times, i2 = n2.length;
      let a2 = 0, o2 = i2 - 1;
      for (; a2 !== i2 && n2[a2] < e2; )
        ++a2;
      for (; o2 !== -1 && n2[o2] > t2; )
        --o2;
      return ++o2, a2 === 0 && o2 === i2 || (a2 >= o2 && (o2 = Math.max(o2, 1), a2 = o2 - 1), r2 = this.getValueSize(), this.times = AnimationUtils.arraySlice(n2, a2, o2), this.values = AnimationUtils.arraySlice(this.values, a2 * r2, o2 * r2)), this;
    }
    validate() {
      let r2 = true;
      var e2 = this.getValueSize();
      e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), r2 = false);
      var t2 = this.times, n2 = this.values, i2 = t2.length;
      i2 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), r2 = false);
      let a2 = null;
      for (let e3 = 0; e3 !== i2; e3++) {
        var o2 = t2[e3];
        if (typeof o2 == "number" && isNaN(o2)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, o2), r2 = false;
          break;
        }
        if (a2 !== null && a2 > o2) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, o2, a2), r2 = false;
          break;
        }
        a2 = o2;
      }
      if (n2 !== void 0 && AnimationUtils.isTypedArray(n2))
        for (let e3 = 0, t3 = n2.length; e3 !== t3; ++e3) {
          var s2 = n2[e3];
          if (isNaN(s2)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, s2), r2 = false;
            break;
          }
        }
      return r2;
    }
    optimize() {
      const r2 = AnimationUtils.arraySlice(this.times), n2 = AnimationUtils.arraySlice(this.values), i2 = this.getValueSize(), a2 = this.getInterpolation() === InterpolateSmooth, o2 = r2.length - 1;
      let s2 = 1;
      for (let e2 = 1; e2 < o2; ++e2) {
        let t2 = false;
        var l2 = r2[e2];
        if (l2 !== r2[e2 + 1] && (e2 !== 1 || l2 !== r2[0]))
          if (a2)
            t2 = true;
          else {
            var c2 = e2 * i2, u2 = c2 - i2, h2 = c2 + i2;
            for (let e3 = 0; e3 !== i2; ++e3) {
              var d2 = n2[c2 + e3];
              if (d2 !== n2[u2 + e3] || d2 !== n2[h2 + e3]) {
                t2 = true;
                break;
              }
            }
          }
        if (t2) {
          if (e2 !== s2) {
            r2[s2] = r2[e2];
            var p2 = e2 * i2, f2 = s2 * i2;
            for (let e3 = 0; e3 !== i2; ++e3)
              n2[f2 + e3] = n2[p2 + e3];
          }
          ++s2;
        }
      }
      if (0 < o2) {
        r2[s2] = r2[o2];
        for (let e2 = o2 * i2, t2 = s2 * i2, r3 = 0; r3 !== i2; ++r3)
          n2[t2 + r3] = n2[e2 + r3];
        ++s2;
      }
      return s2 !== r2.length ? (this.times = AnimationUtils.arraySlice(r2, 0, s2), this.values = AnimationUtils.arraySlice(n2, 0, s2 * i2)) : (this.times = r2, this.values = n2), this;
    }
    clone() {
      var e2 = AnimationUtils.arraySlice(this.times, 0), t2 = AnimationUtils.arraySlice(this.values, 0);
      const r2 = this.constructor, n2 = new r2(this.name, e2, t2);
      return n2.createInterpolant = this.createInterpolant, n2;
    }
  }
  KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  class BooleanKeyframeTrack extends KeyframeTrack {
  }
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  class ColorKeyframeTrack extends KeyframeTrack {
  }
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  class NumberKeyframeTrack extends KeyframeTrack {
  }
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  class QuaternionLinearInterpolant extends Interpolant {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2, t2, r2, n2) {
      var i2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = (r2 - t2) / (n2 - t2);
      let l2 = e2 * o2;
      for (var c2 = l2 + o2; l2 !== c2; l2 += 4)
        Quaternion.slerpFlat(i2, 0, a2, l2 - o2, a2, l2, s2);
      return i2;
    }
  }
  class QuaternionKeyframeTrack extends KeyframeTrack {
    InterpolantFactoryMethodLinear(e2) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e2);
    }
  }
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  class StringKeyframeTrack extends KeyframeTrack {
  }
  StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  class VectorKeyframeTrack extends KeyframeTrack {
  }
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  class AnimationClip {
    constructor(e2, t2 = -1, r2, n2 = NormalAnimationBlendMode) {
      this.name = e2, this.tracks = r2, this.duration = t2, this.blendMode = n2, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration();
    }
    static parse(e2) {
      const r2 = [], n2 = e2.tracks, i2 = 1 / (e2.fps || 1);
      for (let e3 = 0, t3 = n2.length; e3 !== t3; ++e3)
        r2.push(parseKeyframeTrack(n2[e3]).scale(i2));
      const t2 = new this(e2.name, e2.duration, r2, e2.blendMode);
      return t2.uuid = e2.uuid, t2;
    }
    static toJSON(e2) {
      const r2 = [], n2 = e2.tracks;
      e2 = { name: e2.name, duration: e2.duration, tracks: r2, uuid: e2.uuid, blendMode: e2.blendMode };
      for (let e3 = 0, t2 = n2.length; e3 !== t2; ++e3)
        r2.push(KeyframeTrack.toJSON(n2[e3]));
      return e2;
    }
    static CreateFromMorphTargetSequence(e2, n2, i2, a2) {
      var o2 = n2.length;
      const s2 = [];
      for (let r2 = 0; r2 < o2; r2++) {
        let e3 = [], t2 = [];
        e3.push((r2 + o2 - 1) % o2, r2, (r2 + 1) % o2), t2.push(0, 1, 0);
        var l2 = AnimationUtils.getKeyframeOrder(e3);
        e3 = AnimationUtils.sortedArray(e3, 1, l2), t2 = AnimationUtils.sortedArray(t2, 1, l2), a2 || e3[0] !== 0 || (e3.push(o2), t2.push(t2[0])), s2.push(new NumberKeyframeTrack(".morphTargetInfluences[" + n2[r2].name + "]", e3, t2).scale(1 / i2));
      }
      return new this(e2, -1, s2);
    }
    static findByName(e2, t2) {
      let r2 = e2;
      Array.isArray(e2) || (r2 = e2.geometry && e2.geometry.animations || e2.animations);
      for (let e3 = 0; e3 < r2.length; e3++)
        if (r2[e3].name === t2)
          return r2[e3];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(r2, e2, t2) {
      const n2 = {};
      var i2 = /^([\w-]*?)([\d]+)$/;
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
        const s2 = r2[e3];
        var a2 = s2.name.match(i2);
        if (a2 && 1 < a2.length) {
          a2 = a2[1];
          let e4 = n2[a2];
          e4 || (n2[a2] = e4 = []), e4.push(s2);
        }
      }
      const o2 = [];
      for (const l2 in n2)
        o2.push(this.CreateFromMorphTargetSequence(l2, n2[l2], e2, t2));
      return o2;
    }
    static parseAnimation(e2, t2) {
      if (!e2)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      function r2(e3, t3, r3, n3, i3) {
        var a3, o3;
        r3.length !== 0 && (a3 = [], o3 = [], AnimationUtils.flattenJSON(r3, a3, o3, n3), a3.length !== 0 && i3.push(new e3(t3, a3, o3)));
      }
      const n2 = [];
      var i2 = e2.name || "default", a2 = e2.fps || 30, o2 = e2.blendMode;
      let s2 = e2.length || -1;
      var l2 = e2.hierarchy || [];
      for (let e3 = 0; e3 < l2.length; e3++) {
        var c2 = l2[e3].keys;
        if (c2 && c2.length !== 0)
          if (c2[0].morphTargets) {
            const d2 = {};
            let t3;
            for (t3 = 0; t3 < c2.length; t3++)
              if (c2[t3].morphTargets)
                for (let e4 = 0; e4 < c2[t3].morphTargets.length; e4++)
                  d2[c2[t3].morphTargets[e4]] = -1;
            for (const p2 in d2) {
              const f2 = [], m2 = [];
              for (let e4 = 0; e4 !== c2[t3].morphTargets.length; ++e4) {
                var u2 = c2[t3];
                f2.push(u2.time), m2.push(u2.morphTarget === p2 ? 1 : 0);
              }
              n2.push(new NumberKeyframeTrack(".morphTargetInfluence[" + p2 + "]", f2, m2));
            }
            s2 = d2.length * (a2 || 1);
          } else {
            var h2 = ".bones[" + t2[e3].name + "]";
            r2(VectorKeyframeTrack, h2 + ".position", c2, "pos", n2), r2(QuaternionKeyframeTrack, h2 + ".quaternion", c2, "rot", n2), r2(VectorKeyframeTrack, h2 + ".scale", c2, "scl", n2);
          }
      }
      return n2.length === 0 ? null : new this(i2, s2, n2, o2);
    }
    resetDuration() {
      let r2 = 0;
      for (let e2 = 0, t2 = this.tracks.length; e2 !== t2; ++e2) {
        var n2 = this.tracks[e2];
        r2 = Math.max(r2, n2.times[n2.times.length - 1]);
      }
      return this.duration = r2, this;
    }
    trim() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].trim(0, this.duration);
      return this;
    }
    validate() {
      let t2 = true;
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        t2 = t2 && this.tracks[e2].validate();
      return t2;
    }
    optimize() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].optimize();
      return this;
    }
    clone() {
      const t2 = [];
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        t2.push(this.tracks[e2].clone());
      return new this.constructor(this.name, this.duration, t2, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function getTrackTypeForValueTypeName(e2) {
    switch (e2.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e2);
  }
  function parseKeyframeTrack(e2) {
    if (e2.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t2 = getTrackTypeForValueTypeName(e2.type);
    var r2, n2;
    return e2.times === void 0 && (r2 = [], n2 = [], AnimationUtils.flattenJSON(e2.keys, r2, n2, "value"), e2.times = r2, e2.values = n2), t2.parse !== void 0 ? t2.parse(e2) : new t2(e2.name, e2.times, e2.values, e2.interpolation);
  }
  const Cache = { enabled: false, files: {}, add: function(e2, t2) {
    this.enabled !== false && (this.files[e2] = t2);
  }, get: function(e2) {
    if (this.enabled !== false)
      return this.files[e2];
  }, remove: function(e2) {
    delete this.files[e2];
  }, clear: function() {
    this.files = {};
  } };
  class LoadingManager {
    constructor(e2, t2, r2) {
      const n2 = this;
      let i2 = false, a2 = 0, o2 = 0, s2 = void 0;
      const l2 = [];
      this.onStart = void 0, this.onLoad = e2, this.onProgress = t2, this.onError = r2, this.itemStart = function(e3) {
        o2++, i2 === false && n2.onStart !== void 0 && n2.onStart(e3, a2, o2), i2 = true;
      }, this.itemEnd = function(e3) {
        a2++, n2.onProgress !== void 0 && n2.onProgress(e3, a2, o2), a2 === o2 && (i2 = false, n2.onLoad !== void 0 && n2.onLoad());
      }, this.itemError = function(e3) {
        n2.onError !== void 0 && n2.onError(e3);
      }, this.resolveURL = function(e3) {
        return s2 ? s2(e3) : e3;
      }, this.setURLModifier = function(e3) {
        return s2 = e3, this;
      }, this.addHandler = function(e3, t3) {
        return l2.push(e3, t3), this;
      }, this.removeHandler = function(e3) {
        e3 = l2.indexOf(e3);
        return e3 !== -1 && l2.splice(e3, 2), this;
      }, this.getHandler = function(r3) {
        for (let e3 = 0, t3 = l2.length; e3 < t3; e3 += 2) {
          const i3 = l2[e3];
          var n3 = l2[e3 + 1];
          if (i3.global && (i3.lastIndex = 0), i3.test(r3))
            return n3;
        }
        return null;
      };
    }
  }
  const DefaultLoadingManager = new LoadingManager();
  class Loader {
    constructor(e2) {
      this.manager = e2 !== void 0 ? e2 : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(r2, n2) {
      const i2 = this;
      return new Promise(function(e2, t2) {
        i2.load(r2, e2, n2, t2);
      });
    }
    parse() {
    }
    setCrossOrigin(e2) {
      return this.crossOrigin = e2, this;
    }
    setWithCredentials(e2) {
      return this.withCredentials = e2, this;
    }
    setPath(e2) {
      return this.path = e2, this;
    }
    setResourcePath(e2) {
      return this.resourcePath = e2, this;
    }
    setRequestHeader(e2) {
      return this.requestHeader = e2, this;
    }
  }
  const loading = {};
  class FileLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(a2, e2, t2, r2) {
      a2 === void 0 && (a2 = ""), this.path !== void 0 && (a2 = this.path + a2), a2 = this.manager.resolveURL(a2);
      const n2 = Cache.get(a2);
      if (n2 !== void 0)
        return this.manager.itemStart(a2), setTimeout(() => {
          e2 && e2(n2), this.manager.itemEnd(a2);
        }, 0), n2;
      var i2;
      loading[a2] === void 0 ? (loading[a2] = [], loading[a2].push({ onLoad: e2, onProgress: t2, onError: r2 }), i2 = new Request(a2, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), fetch(i2).then((e3) => {
        if (e3.status !== 200 && e3.status !== 0)
          throw Error(`fetch for "${e3.url}" responded with ${e3.status}: ` + e3.statusText);
        {
          e3.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
          const s2 = loading[a2], t3 = e3.body.getReader();
          e3 = e3.headers.get("Content-Length");
          const l2 = e3 ? parseInt(e3) : 0, c2 = l2 !== 0;
          let o2 = 0;
          return new ReadableStream({ start(a3) {
            !function i3() {
              t3.read().then(({ done: e4, value: t4 }) => {
                if (e4)
                  a3.close();
                else {
                  o2 += t4.byteLength;
                  const r3 = new ProgressEvent("progress", { lengthComputable: c2, loaded: o2, total: l2 });
                  for (let e5 = 0, t5 = s2.length; e5 < t5; e5++) {
                    const n3 = s2[e5];
                    n3.onProgress && n3.onProgress(r3);
                  }
                  a3.enqueue(t4), i3();
                }
              });
            }();
          } });
        }
      }).then((e3) => {
        const t3 = new Response(e3);
        switch (this.responseType) {
          case "arraybuffer":
            return t3.arrayBuffer();
          case "blob":
            return t3.blob();
          case "document":
            return t3.text().then((e4) => {
              const t4 = new DOMParser();
              return t4.parseFromString(e4, this.mimeType);
            });
          case "json":
            return t3.json();
          default:
            return t3.text();
        }
      }).then((r3) => {
        Cache.add(a2, r3);
        var n3 = loading[a2];
        delete loading[a2];
        for (let e3 = 0, t3 = n3.length; e3 < t3; e3++) {
          const i3 = n3[e3];
          i3.onLoad && i3.onLoad(r3);
        }
        this.manager.itemEnd(a2);
      }).catch((r3) => {
        var n3 = loading[a2];
        delete loading[a2];
        for (let e3 = 0, t3 = n3.length; e3 < t3; e3++) {
          const i3 = n3[e3];
          i3.onError && i3.onError(r3);
        }
        this.manager.itemError(a2), this.manager.itemEnd(a2);
      }), this.manager.itemStart(a2)) : loading[a2].push({ onLoad: e2, onProgress: t2, onError: r2 });
    }
    setResponseType(e2) {
      return this.responseType = e2, this;
    }
    setMimeType(e2) {
      return this.mimeType = e2, this;
    }
  }
  class ImageLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(t2, e2, r2, n2) {
      this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
      const i2 = this, a2 = Cache.get(t2);
      if (a2 !== void 0)
        return i2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(a2), i2.manager.itemEnd(t2);
        }, 0), a2;
      const o2 = createElementNS("img");
      function s2() {
        c2(), Cache.add(t2, this), e2 && e2(this), i2.manager.itemEnd(t2);
      }
      function l2(e3) {
        c2(), n2 && n2(e3), i2.manager.itemError(t2), i2.manager.itemEnd(t2);
      }
      function c2() {
        o2.removeEventListener("load", s2, false), o2.removeEventListener("error", l2, false);
      }
      return o2.addEventListener("load", s2, false), o2.addEventListener("error", l2, false), t2.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o2.crossOrigin = this.crossOrigin), i2.manager.itemStart(t2), o2.src = t2, o2;
    }
  }
  class CubeTextureLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(r2, n2, e2, i2) {
      const a2 = new CubeTexture(), o2 = new ImageLoader(this.manager);
      o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path);
      let s2 = 0;
      for (let e3 = 0; e3 < r2.length; ++e3)
        !function(t2) {
          o2.load(r2[t2], function(e4) {
            a2.images[t2] = e4, s2++, s2 === 6 && (a2.needsUpdate = true, n2 && n2(a2));
          }, void 0, i2);
        }(e3);
      return a2;
    }
  }
  class DataTextureLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, a2 = new DataTexture(), o2 = new FileLoader(this.manager);
      return o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setPath(this.path), o2.setWithCredentials(i2.withCredentials), o2.load(e2, function(e3) {
        e3 = i2.parse(e3);
        e3 && (e3.image !== void 0 ? a2.image = e3.image : e3.data !== void 0 && (a2.image.width = e3.width, a2.image.height = e3.height, a2.image.data = e3.data), a2.wrapS = e3.wrapS !== void 0 ? e3.wrapS : ClampToEdgeWrapping, a2.wrapT = e3.wrapT !== void 0 ? e3.wrapT : ClampToEdgeWrapping, a2.magFilter = e3.magFilter !== void 0 ? e3.magFilter : LinearFilter, a2.minFilter = e3.minFilter !== void 0 ? e3.minFilter : LinearFilter, a2.anisotropy = e3.anisotropy !== void 0 ? e3.anisotropy : 1, e3.encoding !== void 0 && (a2.encoding = e3.encoding), e3.flipY !== void 0 && (a2.flipY = e3.flipY), e3.format !== void 0 && (a2.format = e3.format), e3.type !== void 0 && (a2.type = e3.type), e3.mipmaps !== void 0 && (a2.mipmaps = e3.mipmaps, a2.minFilter = LinearMipmapLinearFilter), e3.mipmapCount === 1 && (a2.minFilter = LinearFilter), e3.generateMipmaps !== void 0 && (a2.generateMipmaps = e3.generateMipmaps), a2.needsUpdate = true, t2 && t2(a2, e3));
      }, r2, n2), a2;
    }
  }
  class TextureLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = new Texture(), a2 = new ImageLoader(this.manager);
      return a2.setCrossOrigin(this.crossOrigin), a2.setPath(this.path), a2.load(e2, function(e3) {
        i2.image = e3, i2.needsUpdate = true, t2 !== void 0 && t2(i2);
      }, r2, n2), i2;
    }
  }
  class Light extends Object3D {
    constructor(e2, t2 = 1) {
      super(), this.type = "Light", this.color = new Color(e2), this.intensity = t2;
    }
    dispose() {
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.intensity = e2.intensity, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, this.groundColor !== void 0 && (t2.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t2.object.distance = this.distance), this.angle !== void 0 && (t2.object.angle = this.angle), this.decay !== void 0 && (t2.object.decay = this.decay), this.penumbra !== void 0 && (t2.object.penumbra = this.penumbra), this.shadow !== void 0 && (t2.object.shadow = this.shadow.toJSON()), t2;
    }
  }
  Light.prototype.isLight = true;
  class HemisphereLight extends Light {
    constructor(e2, t2, r2) {
      super(e2, r2), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(t2);
    }
    copy(e2) {
      return Light.prototype.copy.call(this, e2), this.groundColor.copy(e2.groundColor), this;
    }
  }
  HemisphereLight.prototype.isHemisphereLight = true;
  const _projScreenMatrix$1 = new Matrix4(), _lightPositionWorld$1 = new Vector3(), _lookTarget$1 = new Vector3();
  class LightShadow {
    constructor(e2) {
      this.camera = e2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e2) {
      const t2 = this.camera, r2 = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(e2.matrixWorld), t2.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(e2.target.matrixWorld), t2.lookAt(_lookTarget$1), t2.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), r2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), r2.multiply(t2.projectionMatrix), r2.multiply(t2.matrixWorldInverse);
    }
    getViewport(e2) {
      return this._viewports[e2];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e2) {
      return this.camera = e2.camera.clone(), this.bias = e2.bias, this.radius = e2.radius, this.mapSize.copy(e2.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e2 = {};
      return this.bias !== 0 && (e2.bias = this.bias), this.normalBias !== 0 && (e2.normalBias = this.normalBias), this.radius !== 1 && (e2.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (e2.mapSize = this.mapSize.toArray()), e2.camera = this.camera.toJSON(false).object, delete e2.camera.matrix, e2;
    }
  }
  class SpotLightShadow extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(50, 1, 0.5, 500)), this.focus = 1;
    }
    updateMatrices(e2) {
      const t2 = this.camera;
      var r2 = 2 * RAD2DEG * e2.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, i2 = e2.distance || t2.far;
      r2 === t2.fov && n2 === t2.aspect && i2 === t2.far || (t2.fov = r2, t2.aspect = n2, t2.far = i2, t2.updateProjectionMatrix()), super.updateMatrices(e2);
    }
    copy(e2) {
      return super.copy(e2), this.focus = e2.focus, this;
    }
  }
  SpotLightShadow.prototype.isSpotLightShadow = true;
  class SpotLight extends Light {
    constructor(e2, t2, r2 = 0, n2 = Math.PI / 3, i2 = 0, a2 = 1) {
      super(e2, t2), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.distance = r2, this.angle = n2, this.penumbra = i2, this.decay = a2, this.shadow = new SpotLightShadow();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2) {
      return super.copy(e2), this.distance = e2.distance, this.angle = e2.angle, this.penumbra = e2.penumbra, this.decay = e2.decay, this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  SpotLight.prototype.isSpotLight = true;
  const _projScreenMatrix = new Matrix4(), _lightPositionWorld = new Vector3(), _lookTarget = new Vector3();
  class PointLightShadow extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
    }
    updateMatrices(e2, t2 = 0) {
      const r2 = this.camera, n2 = this.matrix;
      var i2 = e2.distance || r2.far;
      i2 !== r2.far && (r2.far = i2, r2.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(e2.matrixWorld), r2.position.copy(_lightPositionWorld), _lookTarget.copy(r2.position), _lookTarget.add(this._cubeDirections[t2]), r2.up.copy(this._cubeUps[t2]), r2.lookAt(_lookTarget), r2.updateMatrixWorld(), n2.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(r2.projectionMatrix, r2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  }
  PointLightShadow.prototype.isPointLightShadow = true;
  class PointLight extends Light {
    constructor(e2, t2, r2 = 0, n2 = 1) {
      super(e2, t2), this.type = "PointLight", this.distance = r2, this.decay = n2, this.shadow = new PointLightShadow();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2) {
      return super.copy(e2), this.distance = e2.distance, this.decay = e2.decay, this.shadow = e2.shadow.clone(), this;
    }
  }
  PointLight.prototype.isPointLight = true;
  class DirectionalLightShadow extends LightShadow {
    constructor() {
      super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
  }
  DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
  class DirectionalLight extends Light {
    constructor(e2, t2) {
      super(e2, t2), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2) {
      return super.copy(e2), this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  DirectionalLight.prototype.isDirectionalLight = true;
  class AmbientLight extends Light {
    constructor(e2, t2) {
      super(e2, t2), this.type = "AmbientLight";
    }
  }
  AmbientLight.prototype.isAmbientLight = true;
  class RectAreaLight extends Light {
    constructor(e2, t2, r2 = 10, n2 = 10) {
      super(e2, t2), this.type = "RectAreaLight", this.width = r2, this.height = n2;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (this.width * this.height * Math.PI);
    }
    copy(e2) {
      return super.copy(e2), this.width = e2.width, this.height = e2.height, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.width = this.width, t2.object.height = this.height, t2;
    }
  }
  RectAreaLight.prototype.isRectAreaLight = true;
  class SphericalHarmonics3 {
    constructor() {
      this.coefficients = [];
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients.push(new Vector3());
    }
    set(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].copy(t2[e2]);
      return this;
    }
    zero() {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].set(0, 0, 0);
      return this;
    }
    getAt(e2, t2) {
      var r2 = e2.x, n2 = e2.y, i2 = e2.z, e2 = this.coefficients;
      return t2.copy(e2[0]).multiplyScalar(0.282095), t2.addScaledVector(e2[1], 0.488603 * n2), t2.addScaledVector(e2[2], 0.488603 * i2), t2.addScaledVector(e2[3], 0.488603 * r2), t2.addScaledVector(e2[4], r2 * n2 * 1.092548), t2.addScaledVector(e2[5], n2 * i2 * 1.092548), t2.addScaledVector(e2[6], 0.315392 * (3 * i2 * i2 - 1)), t2.addScaledVector(e2[7], r2 * i2 * 1.092548), t2.addScaledVector(e2[8], 0.546274 * (r2 * r2 - n2 * n2)), t2;
    }
    getIrradianceAt(e2, t2) {
      var r2 = e2.x, n2 = e2.y, i2 = e2.z, e2 = this.coefficients;
      return t2.copy(e2[0]).multiplyScalar(0.886227), t2.addScaledVector(e2[1], 1.023328 * n2), t2.addScaledVector(e2[2], 1.023328 * i2), t2.addScaledVector(e2[3], 1.023328 * r2), t2.addScaledVector(e2[4], 0.858086 * r2 * n2), t2.addScaledVector(e2[5], 0.858086 * n2 * i2), t2.addScaledVector(e2[6], 0.743125 * i2 * i2 - 0.247708), t2.addScaledVector(e2[7], 0.858086 * r2 * i2), t2.addScaledVector(e2[8], 0.429043 * (r2 * r2 - n2 * n2)), t2;
    }
    add(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].add(t2.coefficients[e2]);
      return this;
    }
    addScaledSH(t2, r2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].addScaledVector(t2.coefficients[e2], r2);
      return this;
    }
    scale(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].multiplyScalar(t2);
      return this;
    }
    lerp(t2, r2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].lerp(t2.coefficients[e2], r2);
      return this;
    }
    equals(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        if (!this.coefficients[e2].equals(t2.coefficients[e2]))
          return false;
      return true;
    }
    copy(e2) {
      return this.set(e2.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t2, r2 = 0) {
      const n2 = this.coefficients;
      for (let e2 = 0; e2 < 9; e2++)
        n2[e2].fromArray(t2, r2 + 3 * e2);
      return this;
    }
    toArray(t2 = [], r2 = 0) {
      const n2 = this.coefficients;
      for (let e2 = 0; e2 < 9; e2++)
        n2[e2].toArray(t2, r2 + 3 * e2);
      return t2;
    }
    static getBasisAt(e2, t2) {
      var r2 = e2.x, n2 = e2.y, e2 = e2.z;
      t2[0] = 0.282095, t2[1] = 0.488603 * n2, t2[2] = 0.488603 * e2, t2[3] = 0.488603 * r2, t2[4] = 1.092548 * r2 * n2, t2[5] = 1.092548 * n2 * e2, t2[6] = 0.315392 * (3 * e2 * e2 - 1), t2[7] = 1.092548 * r2 * e2, t2[8] = 0.546274 * (r2 * r2 - n2 * n2);
    }
  }
  SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
  class LightProbe extends Light {
    constructor(e2 = new SphericalHarmonics3(), t2 = 1) {
      super(void 0, t2), this.sh = e2;
    }
    copy(e2) {
      return super.copy(e2), this.sh.copy(e2.sh), this;
    }
    fromJSON(e2) {
      return this.intensity = e2.intensity, this.sh.fromArray(e2.sh), this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.sh = this.sh.toArray(), t2;
    }
  }
  LightProbe.prototype.isLightProbe = true;
  class LoaderUtils {
    static decodeText(r2) {
      if (typeof TextDecoder != "undefined")
        return new TextDecoder().decode(r2);
      let n2 = "";
      for (let e2 = 0, t2 = r2.length; e2 < t2; e2++)
        n2 += String.fromCharCode(r2[e2]);
      try {
        return decodeURIComponent(escape(n2));
      } catch (e2) {
        return n2;
      }
    }
    static extractUrlBase(e2) {
      var t2 = e2.lastIndexOf("/");
      return t2 === -1 ? "./" : e2.substr(0, t2 + 1);
    }
    static resolveURL(e2, t2) {
      return typeof e2 != "string" || e2 === "" ? "" : (/^https?:\/\//i.test(t2) && /^\//.test(e2) && (t2 = t2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e2) || /^data:.*,.*$/i.test(e2) || /^blob:.*$/i.test(e2) ? e2 : t2 + e2);
    }
  }
  class InstancedBufferGeometry extends BufferGeometry {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e2) {
      return super.copy(e2), this.instanceCount = e2.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e2 = super.toJSON(this);
      return e2.instanceCount = this.instanceCount, e2.isInstancedBufferGeometry = true, e2;
    }
  }
  InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
  class ImageBitmapLoader extends Loader {
    constructor(e2) {
      super(e2), typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(e2) {
      return this.options = e2, this;
    }
    load(t2, r2, e2, n2) {
      t2 === void 0 && (t2 = ""), this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
      const i2 = this, a2 = Cache.get(t2);
      if (a2 !== void 0)
        return i2.manager.itemStart(t2), setTimeout(function() {
          r2 && r2(a2), i2.manager.itemEnd(t2);
        }, 0), a2;
      const o2 = {};
      o2.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o2.headers = this.requestHeader, fetch(t2, o2).then(function(e3) {
        return e3.blob();
      }).then(function(e3) {
        return createImageBitmap(e3, Object.assign(i2.options, { colorSpaceConversion: "none" }));
      }).then(function(e3) {
        Cache.add(t2, e3), r2 && r2(e3), i2.manager.itemEnd(t2);
      }).catch(function(e3) {
        n2 && n2(e3), i2.manager.itemError(t2), i2.manager.itemEnd(t2);
      }), i2.manager.itemStart(t2);
    }
  }
  ImageBitmapLoader.prototype.isImageBitmapLoader = true;
  let _context;
  const AudioContext = { getContext: function() {
    return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
  }, setContext: function(e2) {
    _context = e2;
  } };
  class AudioLoader extends Loader {
    constructor(e2) {
      super(e2);
    }
    load(n2, i2, e2, a2) {
      const o2 = this, t2 = new FileLoader(this.manager);
      t2.setResponseType("arraybuffer"), t2.setPath(this.path), t2.setRequestHeader(this.requestHeader), t2.setWithCredentials(this.withCredentials), t2.load(n2, function(e3) {
        try {
          var t3 = e3.slice(0);
          const r2 = AudioContext.getContext();
          r2.decodeAudioData(t3, function(e4) {
            i2(e4);
          });
        } catch (e4) {
          a2 ? a2(e4) : console.error(e4), o2.manager.itemError(n2);
        }
      }, e2, a2);
    }
  }
  class HemisphereLightProbe extends LightProbe {
    constructor(e2, t2, r2 = 1) {
      super(void 0, r2);
      var n2 = new Color().set(e2), r2 = new Color().set(t2), e2 = new Vector3(n2.r, n2.g, n2.b), t2 = new Vector3(r2.r, r2.g, r2.b), n2 = Math.sqrt(Math.PI), r2 = n2 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(e2).add(t2).multiplyScalar(n2), this.sh.coefficients[1].copy(e2).sub(t2).multiplyScalar(r2);
    }
  }
  HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
  class AmbientLightProbe extends LightProbe {
    constructor(e2, t2 = 1) {
      super(void 0, t2);
      e2 = new Color().set(e2);
      this.sh.coefficients[0].set(e2.r, e2.g, e2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }
  AmbientLightProbe.prototype.isAmbientLightProbe = true;
  class Clock {
    constructor(e2 = true) {
      this.autoStart = e2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e2 = 0;
      return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (t2 = now(), e2 = (t2 - this.oldTime) / 1e3, this.oldTime = t2, this.elapsedTime += e2), e2);
      var t2;
    }
  }
  function now() {
    return (typeof performance == "undefined" ? Date : performance).now();
  }
  class Audio extends Object3D {
    constructor(e2) {
      super(), this.type = "Audio", this.listener = e2, this.context = e2.context, this.gain = this.context.createGain(), this.gain.connect(e2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e2, this.connect(), this;
    }
    setMediaElementSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e2), this.connect(), this;
    }
    setMediaStreamSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e2), this.connect(), this;
    }
    setBuffer(e2) {
      return this.buffer = e2, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e2 = 0) {
      if (this.isPlaying !== true) {
        if (this.hasPlaybackControl !== false) {
          this._startedAt = this.context.currentTime + e2;
          const t2 = this.context.createBufferSource();
          return t2.buffer = this.buffer, t2.loop = this.loop, t2.loopStart = this.loopStart, t2.loopEnd = this.loopEnd, t2.onended = this.onEnded.bind(this), t2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        console.warn("THREE.Audio: this Audio has no playback control.");
      } else
        console.warn("THREE.Audio: Audio is already playing.");
    }
    pause() {
      if (this.hasPlaybackControl !== false)
        return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (this.hasPlaybackControl !== false)
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].connect(this.filters[e2]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].disconnect(this.filters[e2]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e2) {
      return e2 = e2 || [], this._connected === true ? (this.disconnect(), this.filters = e2.slice(), this.connect()) : this.filters = e2.slice(), this;
    }
    setDetune(e2) {
      if (this.detune = e2, this.source.detune !== void 0)
        return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e2) {
      return this.setFilters(e2 ? [e2] : []);
    }
    setPlaybackRate(e2) {
      if (this.hasPlaybackControl !== false)
        return this.playbackRate = e2, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(e2) {
      if (this.hasPlaybackControl !== false)
        return this.loop = e2, this.isPlaying === true && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(e2) {
      return this.loopStart = e2, this;
    }
    setLoopEnd(e2) {
      return this.loopEnd = e2, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e2) {
      return this.gain.gain.setTargetAtTime(e2, this.context.currentTime, 0.01), this;
    }
  }
  class PropertyMixer {
    constructor(e2, t2, r2) {
      this.binding = e2, this.valueSize = r2;
      let n2, i2, a2;
      switch (t2) {
        case "quaternion":
          n2 = this._slerp, i2 = this._slerpAdditive, a2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * r2), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          n2 = this._select, i2 = this._select, a2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * r2);
          break;
        default:
          n2 = this._lerp, i2 = this._lerpAdditive, a2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * r2);
      }
      this._mixBufferRegion = n2, this._mixBufferRegionAdditive = i2, this._setIdentity = a2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e2, t2) {
      const r2 = this.buffer, n2 = this.valueSize, i2 = e2 * n2 + n2;
      let a2 = this.cumulativeWeight;
      if (a2 === 0) {
        for (let e3 = 0; e3 !== n2; ++e3)
          r2[i2 + e3] = r2[e3];
        a2 = t2;
      } else {
        a2 += t2;
        t2 = t2 / a2;
        this._mixBufferRegion(r2, i2, 0, t2, n2);
      }
      this.cumulativeWeight = a2;
    }
    accumulateAdditive(e2) {
      var t2 = this.buffer, r2 = this.valueSize, n2 = r2 * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t2, n2, 0, e2, r2), this.cumulativeWeightAdditive += e2;
    }
    apply(e2) {
      const r2 = this.valueSize, n2 = this.buffer, i2 = e2 * r2 + r2, t2 = this.cumulativeWeight, a2 = this.cumulativeWeightAdditive, o2 = this.binding;
      this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, t2 < 1 && (e2 = r2 * this._origIndex, this._mixBufferRegion(n2, i2, e2, 1 - t2, r2)), 0 < a2 && this._mixBufferRegionAdditive(n2, i2, this._addIndex * r2, 1, r2);
      for (let e3 = r2, t3 = r2 + r2; e3 !== t3; ++e3)
        if (n2[e3] !== n2[e3 + r2]) {
          o2.setValue(n2, i2);
          break;
        }
    }
    saveOriginalState() {
      const e2 = this.binding, r2 = this.buffer, n2 = this.valueSize, i2 = n2 * this._origIndex;
      e2.getValue(r2, i2);
      for (let e3 = n2, t2 = i2; e3 !== t2; ++e3)
        r2[e3] = r2[i2 + e3 % n2];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      var e2 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, e2);
    }
    _setAdditiveIdentityNumeric() {
      var t2 = this._addIndex * this.valueSize, r2 = t2 + this.valueSize;
      for (let e2 = t2; e2 < r2; e2++)
        this.buffer[e2] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      var t2 = this._origIndex * this.valueSize, r2 = this._addIndex * this.valueSize;
      for (let e2 = 0; e2 < this.valueSize; e2++)
        this.buffer[r2 + e2] = this.buffer[t2 + e2];
    }
    _select(t2, r2, n2, e2, i2) {
      if (0.5 <= e2)
        for (let e3 = 0; e3 !== i2; ++e3)
          t2[r2 + e3] = t2[n2 + e3];
    }
    _slerp(e2, t2, r2, n2) {
      Quaternion.slerpFlat(e2, t2, e2, t2, e2, r2, n2);
    }
    _slerpAdditive(e2, t2, r2, n2, i2) {
      i2 = this._workIndex * i2;
      Quaternion.multiplyQuaternionsFlat(e2, i2, e2, t2, e2, r2), Quaternion.slerpFlat(e2, t2, e2, t2, e2, i2, n2);
    }
    _lerp(t2, r2, n2, i2, a2) {
      var o2 = 1 - i2;
      for (let e2 = 0; e2 !== a2; ++e2) {
        var s2 = r2 + e2;
        t2[s2] = t2[s2] * o2 + t2[n2 + e2] * i2;
      }
    }
    _lerpAdditive(t2, r2, n2, i2, a2) {
      for (let e2 = 0; e2 !== a2; ++e2) {
        var o2 = r2 + e2;
        t2[o2] = t2[o2] + t2[n2 + e2] * i2;
      }
    }
  }
  const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"), _supportedObjectNames = ["material", "materials", "bones"];
  class Composite {
    constructor(e2, t2, r2) {
      r2 = r2 || PropertyBinding.parseTrackName(t2);
      this._targetGroup = e2, this._bindings = e2.subscribe_(t2, r2);
    }
    getValue(e2, t2) {
      this.bind();
      const r2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[r2];
      n2 !== void 0 && n2.getValue(e2, t2);
    }
    setValue(r2, n2) {
      const i2 = this._bindings;
      for (let e2 = this._targetGroup.nCachedObjects_, t2 = i2.length; e2 !== t2; ++e2)
        i2[e2].setValue(r2, n2);
    }
    bind() {
      const r2 = this._bindings;
      for (let e2 = this._targetGroup.nCachedObjects_, t2 = r2.length; e2 !== t2; ++e2)
        r2[e2].bind();
    }
    unbind() {
      const r2 = this._bindings;
      for (let e2 = this._targetGroup.nCachedObjects_, t2 = r2.length; e2 !== t2; ++e2)
        r2[e2].unbind();
    }
  }
  class PropertyBinding {
    constructor(e2, t2, r2) {
      this.path = t2, this.parsedPath = r2 || PropertyBinding.parseTrackName(t2), this.node = PropertyBinding.findNode(e2, this.parsedPath.nodeName) || e2, this.rootNode = e2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e2, t2, r2) {
      return new (e2 && e2.isAnimationObjectGroup ? PropertyBinding.Composite : PropertyBinding)(e2, t2, r2);
    }
    static sanitizeNodeName(e2) {
      return e2.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(e2) {
      var t2 = _trackRe.exec(e2);
      if (!t2)
        throw new Error("PropertyBinding: Cannot parse trackName: " + e2);
      const r2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] };
      var n2 = r2.nodeName && r2.nodeName.lastIndexOf(".");
      if (n2 !== void 0 && n2 !== -1 && (t2 = r2.nodeName.substring(n2 + 1), _supportedObjectNames.indexOf(t2) !== -1 && (r2.nodeName = r2.nodeName.substring(0, n2), r2.objectName = t2)), r2.propertyName === null || r2.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e2);
      return r2;
    }
    static findNode(e2, n2) {
      if (!n2 || n2 === "" || n2 === "." || n2 === -1 || n2 === e2.name || n2 === e2.uuid)
        return e2;
      if (e2.skeleton) {
        var t2 = e2.skeleton.getBoneByName(n2);
        if (t2 !== void 0)
          return t2;
      }
      if (e2.children) {
        const i2 = function(t3) {
          for (let e3 = 0; e3 < t3.length; e3++) {
            var r2 = t3[e3];
            if (r2.name === n2 || r2.uuid === n2)
              return r2;
            r2 = i2(r2.children);
            if (r2)
              return r2;
          }
          return null;
        };
        e2 = i2(e2.children);
        if (e2)
          return e2;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e2, t2) {
      e2[t2] = this.targetObject[this.propertyName];
    }
    _getValue_array(r2, n2) {
      var i2 = this.resolvedProperty;
      for (let e2 = 0, t2 = i2.length; e2 !== t2; ++e2)
        r2[n2++] = i2[e2];
    }
    _getValue_arrayElement(e2, t2) {
      e2[t2] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e2, t2) {
      this.resolvedProperty.toArray(e2, t2);
    }
    _setValue_direct(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2];
    }
    _setValue_direct_setNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(r2, n2) {
      const i2 = this.resolvedProperty;
      for (let e2 = 0, t2 = i2.length; e2 !== t2; ++e2)
        i2[e2] = r2[n2++];
    }
    _setValue_array_setNeedsUpdate(r2, n2) {
      const i2 = this.resolvedProperty;
      for (let e2 = 0, t2 = i2.length; e2 !== t2; ++e2)
        i2[e2] = r2[n2++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(r2, n2) {
      const i2 = this.resolvedProperty;
      for (let e2 = 0, t2 = i2.length; e2 !== t2; ++e2)
        i2[e2] = r2[n2++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2];
    }
    _setValue_arrayElement_setNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2);
    }
    _setValue_fromArray_setNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e2, t2) {
      this.bind(), this.getValue(e2, t2);
    }
    _setValue_unbound(e2, t2) {
      this.bind(), this.setValue(e2, t2);
    }
    bind() {
      let r2 = this.node;
      var e2 = this.parsedPath, n2 = e2.objectName, i2 = e2.propertyName;
      let a2 = e2.propertyIndex;
      if (r2 || (r2 = PropertyBinding.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = r2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, r2) {
        if (n2) {
          let t2 = e2.objectIndex;
          switch (n2) {
            case "materials":
              if (!r2.material)
                return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!r2.material.materials)
                return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              r2 = r2.material.materials;
              break;
            case "bones":
              if (!r2.skeleton)
                return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              r2 = r2.skeleton.bones;
              for (let e3 = 0; e3 < r2.length; e3++)
                if (r2[e3].name === t2) {
                  t2 = e3;
                  break;
                }
              break;
            default:
              if (r2[n2] === void 0)
                return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              r2 = r2[n2];
          }
          if (t2 !== void 0) {
            if (r2[t2] === void 0)
              return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, r2);
            r2 = r2[t2];
          }
        }
        var o2 = r2[i2];
        if (o2 !== void 0) {
          let e3 = this.Versioning.None;
          this.targetObject = r2, r2.needsUpdate !== void 0 ? e3 = this.Versioning.NeedsUpdate : r2.matrixWorldNeedsUpdate !== void 0 && (e3 = this.Versioning.MatrixWorldNeedsUpdate);
          let t2 = this.BindingType.Direct;
          if (a2 !== void 0) {
            if (i2 === "morphTargetInfluences") {
              if (!r2.geometry)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (!r2.geometry.isBufferGeometry)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              if (!r2.geometry.morphAttributes)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              r2.morphTargetDictionary[a2] !== void 0 && (a2 = r2.morphTargetDictionary[a2]);
            }
            t2 = this.BindingType.ArrayElement, this.resolvedProperty = o2, this.propertyIndex = a2;
          } else
            o2.fromArray !== void 0 && o2.toArray !== void 0 ? (t2 = this.BindingType.HasFromToArray, this.resolvedProperty = o2) : Array.isArray(o2) ? (t2 = this.BindingType.EntireArray, this.resolvedProperty = o2) : this.propertyName = i2;
          this.getValue = this.GetterByBindingType[t2], this.setValue = this.SetterByBindingTypeAndVersioning[t2][e3];
        } else {
          e2 = e2.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + e2 + "." + i2 + " but it wasn't found.", r2);
        }
      } else
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  PropertyBinding.Composite = Composite, PropertyBinding.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, PropertyBinding.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class AnimationAction {
    constructor(e2, t2, r2 = null, n2 = t2.blendMode) {
      this._mixer = e2, this._clip = t2, this._localRoot = r2, this.blendMode = n2;
      const i2 = t2.tracks, a2 = i2.length, o2 = new Array(a2);
      var s2 = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
      for (let e3 = 0; e3 !== a2; ++e3) {
        const l2 = i2[e3].createInterpolant(null);
        o2[e3] = l2, l2.settings = s2;
      }
      this._interpolantSettings = s2, this._interpolants = o2, this._propertyBindings = new Array(a2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e2) {
      return this._startTime = e2, this;
    }
    setLoop(e2, t2) {
      return this.loop = e2, this.repetitions = t2, this;
    }
    setEffectiveWeight(e2) {
      return this.weight = e2, this._effectiveWeight = this.enabled ? e2 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e2) {
      return this._scheduleFading(e2, 0, 1);
    }
    fadeOut(e2) {
      return this._scheduleFading(e2, 1, 0);
    }
    crossFadeFrom(e2, t2, r2) {
      var n2, i2;
      return e2.fadeOut(t2), this.fadeIn(t2), r2 && (r2 = (n2 = this._clip.duration) / (i2 = e2._clip.duration), e2.warp(1, i2 / n2, t2), this.warp(r2, 1, t2)), this;
    }
    crossFadeTo(e2, t2, r2) {
      return e2.crossFadeFrom(this, t2, r2);
    }
    stopFading() {
      var e2 = this._weightInterpolant;
      return e2 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    setEffectiveTimeScale(e2) {
      return this.timeScale = e2, this._effectiveTimeScale = this.paused ? 0 : e2, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e2) {
      return this.timeScale = this._clip.duration / e2, this.stopWarping();
    }
    syncWith(e2) {
      return this.time = e2.time, this.timeScale = e2.timeScale, this.stopWarping();
    }
    halt(e2) {
      return this.warp(this._effectiveTimeScale, 0, e2);
    }
    warp(e2, t2, r2) {
      const n2 = this._mixer, i2 = n2.time, a2 = this.timeScale;
      let o2 = this._timeScaleInterpolant;
      o2 === null && (o2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = o2);
      const s2 = o2.parameterPositions, l2 = o2.sampleValues;
      return s2[0] = i2, s2[1] = i2 + r2, l2[0] = e2 / a2, l2[1] = t2 / a2, this;
    }
    stopWarping() {
      var e2 = this._timeScaleInterpolant;
      return e2 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e2, t2, r2, n2) {
      if (this.enabled) {
        var i2 = this._startTime;
        if (i2 !== null) {
          i2 = (e2 - i2) * r2;
          if (i2 < 0 || r2 === 0)
            return;
          this._startTime = null, t2 = r2 * i2;
        }
        t2 *= this._updateTimeScale(e2);
        var a2 = this._updateTime(t2), o2 = this._updateWeight(e2);
        if (0 < o2) {
          const s2 = this._interpolants, l2 = this._propertyBindings;
          if (this.blendMode === AdditiveAnimationBlendMode)
            for (let e3 = 0, t3 = s2.length; e3 !== t3; ++e3)
              s2[e3].evaluate(a2), l2[e3].accumulateAdditive(o2);
          else {
            NormalAnimationBlendMode;
            for (let e3 = 0, t3 = s2.length; e3 !== t3; ++e3)
              s2[e3].evaluate(a2), l2[e3].accumulate(n2, o2);
          }
        }
      } else
        this._updateWeight(e2);
    }
    _updateWeight(e2) {
      let t2 = 0;
      if (this.enabled) {
        t2 = this.weight;
        const n2 = this._weightInterpolant;
        var r2;
        n2 !== null && (r2 = n2.evaluate(e2)[0], t2 *= r2, e2 > n2.parameterPositions[1] && (this.stopFading(), r2 === 0 && (this.enabled = false)));
      }
      return this._effectiveWeight = t2, t2;
    }
    _updateTimeScale(e2) {
      let t2 = 0;
      if (!this.paused) {
        t2 = this.timeScale;
        const n2 = this._timeScaleInterpolant;
        var r2;
        n2 !== null && (r2 = n2.evaluate(e2)[0], t2 *= r2, e2 > n2.parameterPositions[1] && (this.stopWarping(), t2 === 0 ? this.paused = true : this.timeScale = t2));
      }
      return this._effectiveTimeScale = t2, t2;
    }
    _updateTime(e2) {
      var t2 = this._clip.duration, r2 = this.loop;
      let n2 = this.time + e2, i2 = this._loopCount;
      var a2, o2 = r2 === LoopPingPong;
      if (e2 === 0)
        return i2 !== -1 && o2 && (1 & i2) == 1 ? t2 - n2 : n2;
      if (r2 === LoopOnce) {
        i2 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (n2 >= t2)
            n2 = t2;
          else {
            if (!(n2 < 0)) {
              this.time = n2;
              break e;
            }
            n2 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 < 0 ? -1 : 1 });
        }
      } else if (i2 === -1 && (0 <= e2 ? (i2 = 0, this._setEndings(true, this.repetitions === 0, o2)) : this._setEndings(this.repetitions === 0, true, o2)), n2 >= t2 || n2 < 0 ? (a2 = Math.floor(n2 / t2), n2 -= t2 * a2, i2 += Math.abs(a2), (r2 = this.repetitions - i2) <= 0 ? (this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = 0 < e2 ? t2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < e2 ? 1 : -1 })) : (r2 == 1 ? this._setEndings(r2 = e2 < 0, !r2, o2) : this._setEndings(false, false, o2), this._loopCount = i2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a2 }))) : this.time = n2, o2 && (1 & i2) == 1)
        return t2 - n2;
      return n2;
    }
    _setEndings(e2, t2, r2) {
      const n2 = this._interpolantSettings;
      r2 ? (n2.endingStart = ZeroSlopeEnding, n2.endingEnd = ZeroSlopeEnding) : (n2.endingStart = e2 ? this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding, n2.endingEnd = t2 ? this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding);
    }
    _scheduleFading(e2, t2, r2) {
      const n2 = this._mixer, i2 = n2.time;
      let a2 = this._weightInterpolant;
      a2 === null && (a2 = n2._lendControlInterpolant(), this._weightInterpolant = a2);
      const o2 = a2.parameterPositions, s2 = a2.sampleValues;
      return o2[0] = i2, s2[0] = t2, o2[1] = i2 + e2, s2[1] = r2, this;
    }
  }
  class AnimationMixer extends EventDispatcher {
    constructor(e2) {
      super(), this._root = e2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e2, r2) {
      const n2 = e2._localRoot || this._root, i2 = e2._clip.tracks, a2 = i2.length, o2 = e2._propertyBindings, s2 = e2._interpolants, l2 = n2.uuid, t2 = this._bindingsByRootAndName;
      let c2 = t2[l2];
      c2 === void 0 && (c2 = {}, t2[l2] = c2);
      for (let t3 = 0; t3 !== a2; ++t3) {
        const h2 = i2[t3], d2 = h2.name;
        let e3 = c2[d2];
        if (e3 !== void 0)
          o2[t3] = e3;
        else {
          if (e3 = o2[t3], e3 !== void 0) {
            e3._cacheIndex === null && (++e3.referenceCount, this._addInactiveBinding(e3, l2, d2));
            continue;
          }
          var u2 = r2 && r2._propertyBindings[t3].binding.parsedPath;
          e3 = new PropertyMixer(PropertyBinding.create(n2, d2, u2), h2.ValueTypeName, h2.getValueSize()), ++e3.referenceCount, this._addInactiveBinding(e3, l2, d2), o2[t3] = e3;
        }
        s2[t3].resultBuffer = e3.buffer;
      }
    }
    _activateAction(e2) {
      if (!this._isActiveAction(e2)) {
        var t2, r2, n2;
        e2._cacheIndex === null && (t2 = (e2._localRoot || this._root).uuid, r2 = e2._clip.uuid, n2 = this._actionsByClip[r2], this._bindAction(e2, n2 && n2.knownActions[0]), this._addInactiveAction(e2, r2, t2));
        var i2 = e2._propertyBindings;
        for (let e3 = 0, t3 = i2.length; e3 !== t3; ++e3) {
          const a2 = i2[e3];
          a2.useCount++ == 0 && (this._lendBinding(a2), a2.saveOriginalState());
        }
        this._lendAction(e2);
      }
    }
    _deactivateAction(e2) {
      if (this._isActiveAction(e2)) {
        var r2 = e2._propertyBindings;
        for (let e3 = 0, t2 = r2.length; e3 !== t2; ++e3) {
          const n2 = r2[e3];
          --n2.useCount == 0 && (n2.restoreOriginalState(), this._takeBackBinding(n2));
        }
        this._takeBackAction(e2);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e2 = this;
      this.stats = { actions: { get total() {
        return e2._actions.length;
      }, get inUse() {
        return e2._nActiveActions;
      } }, bindings: { get total() {
        return e2._bindings.length;
      }, get inUse() {
        return e2._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return e2._controlInterpolants.length;
      }, get inUse() {
        return e2._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(e2) {
      e2 = e2._cacheIndex;
      return e2 !== null && e2 < this._nActiveActions;
    }
    _addInactiveAction(e2, t2, r2) {
      const n2 = this._actions, i2 = this._actionsByClip;
      let a2 = i2[t2];
      if (a2 === void 0)
        a2 = { knownActions: [e2], actionByRoot: {} }, e2._byClipCacheIndex = 0, i2[t2] = a2;
      else {
        const o2 = a2.knownActions;
        e2._byClipCacheIndex = o2.length, o2.push(e2);
      }
      e2._cacheIndex = n2.length, n2.push(e2), a2.actionByRoot[r2] = e2;
    }
    _removeInactiveAction(e2) {
      const t2 = this._actions, r2 = t2[t2.length - 1], n2 = e2._cacheIndex;
      r2._cacheIndex = n2, t2[n2] = r2, t2.pop(), e2._cacheIndex = null;
      const i2 = e2._clip.uuid, a2 = this._actionsByClip, o2 = a2[i2], s2 = o2.knownActions, l2 = s2[s2.length - 1], c2 = e2._byClipCacheIndex;
      l2._byClipCacheIndex = c2, s2[c2] = l2, s2.pop(), e2._byClipCacheIndex = null;
      const u2 = o2.actionByRoot, h2 = (e2._localRoot || this._root).uuid;
      delete u2[h2], s2.length === 0 && delete a2[i2], this._removeInactiveBindingsForAction(e2);
    }
    _removeInactiveBindingsForAction(e2) {
      var r2 = e2._propertyBindings;
      for (let e3 = 0, t2 = r2.length; e3 !== t2; ++e3) {
        const n2 = r2[e3];
        --n2.referenceCount == 0 && this._removeInactiveBinding(n2);
      }
    }
    _lendAction(e2) {
      const t2 = this._actions, r2 = e2._cacheIndex, n2 = this._nActiveActions++, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _takeBackAction(e2) {
      const t2 = this._actions, r2 = e2._cacheIndex, n2 = --this._nActiveActions, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _addInactiveBinding(e2, t2, r2) {
      const n2 = this._bindingsByRootAndName, i2 = this._bindings;
      let a2 = n2[t2];
      a2 === void 0 && (a2 = {}, n2[t2] = a2), (a2[r2] = e2)._cacheIndex = i2.length, i2.push(e2);
    }
    _removeInactiveBinding(e2) {
      const t2 = this._bindings, r2 = e2.binding, n2 = r2.rootNode.uuid, i2 = r2.path, a2 = this._bindingsByRootAndName, o2 = a2[n2], s2 = t2[t2.length - 1], l2 = e2._cacheIndex;
      s2._cacheIndex = l2, t2[l2] = s2, t2.pop(), delete o2[i2], Object.keys(o2).length === 0 && delete a2[n2];
    }
    _lendBinding(e2) {
      const t2 = this._bindings, r2 = e2._cacheIndex, n2 = this._nActiveBindings++, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _takeBackBinding(e2) {
      const t2 = this._bindings, r2 = e2._cacheIndex, n2 = --this._nActiveBindings, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _lendControlInterpolant() {
      const e2 = this._controlInterpolants, t2 = this._nActiveControlInterpolants++;
      let r2 = e2[t2];
      return r2 === void 0 && (r2 = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), r2.__cacheIndex = t2, e2[t2] = r2), r2;
    }
    _takeBackControlInterpolant(e2) {
      const t2 = this._controlInterpolants, r2 = e2.__cacheIndex, n2 = --this._nActiveControlInterpolants, i2 = t2[n2];
      e2.__cacheIndex = n2, t2[n2] = e2, i2.__cacheIndex = r2, t2[r2] = i2;
    }
    clipAction(e2, t2, r2) {
      var n2 = t2 || this._root, i2 = n2.uuid;
      let a2 = typeof e2 == "string" ? AnimationClip.findByName(n2, e2) : e2;
      var o2 = a2 !== null ? a2.uuid : e2, n2 = this._actionsByClip[o2];
      let s2 = null;
      if (r2 === void 0 && (r2 = a2 !== null ? a2.blendMode : NormalAnimationBlendMode), n2 !== void 0) {
        e2 = n2.actionByRoot[i2];
        if (e2 !== void 0 && e2.blendMode === r2)
          return e2;
        s2 = n2.knownActions[0], a2 === null && (a2 = s2._clip);
      }
      if (a2 === null)
        return null;
      r2 = new AnimationAction(this, a2, t2, r2);
      return this._bindAction(r2, s2), this._addInactiveAction(r2, o2, i2), r2;
    }
    existingAction(e2, t2) {
      var r2 = t2 || this._root, t2 = r2.uuid, r2 = typeof e2 == "string" ? AnimationClip.findByName(r2, e2) : e2, e2 = r2 ? r2.uuid : e2, e2 = this._actionsByClip[e2];
      return e2 !== void 0 && e2.actionByRoot[t2] || null;
    }
    stopAllAction() {
      const t2 = this._actions, r2 = this._nActiveActions;
      for (let e2 = r2 - 1; 0 <= e2; --e2)
        t2[e2].stop();
      return this;
    }
    update(t2) {
      t2 *= this.timeScale;
      var r2 = this._actions, n2 = this._nActiveActions, i2 = this.time += t2, a2 = Math.sign(t2), o2 = this._accuIndex ^= 1;
      for (let e2 = 0; e2 !== n2; ++e2) {
        const c2 = r2[e2];
        c2._update(i2, t2, a2, o2);
      }
      const s2 = this._bindings, l2 = this._nActiveBindings;
      for (let e2 = 0; e2 !== l2; ++e2)
        s2[e2].apply(o2);
      return this;
    }
    setTime(e2) {
      for (let e3 = this.time = 0; e3 < this._actions.length; e3++)
        this._actions[e3].time = 0;
      return this.update(e2);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e2) {
      const r2 = this._actions, t2 = e2.uuid, n2 = this._actionsByClip, i2 = n2[t2];
      if (i2 !== void 0) {
        var a2 = i2.knownActions;
        for (let e3 = 0, t3 = a2.length; e3 !== t3; ++e3) {
          const o2 = a2[e3];
          this._deactivateAction(o2);
          const s2 = o2._cacheIndex, l2 = r2[r2.length - 1];
          o2._cacheIndex = null, o2._byClipCacheIndex = null, l2._cacheIndex = s2, r2[s2] = l2, r2.pop(), this._removeInactiveBindingsForAction(o2);
        }
        delete n2[t2];
      }
    }
    uncacheRoot(e2) {
      var t2 = e2.uuid, r2 = this._actionsByClip;
      for (const a2 in r2) {
        var n2 = r2[a2].actionByRoot[t2];
        n2 !== void 0 && (this._deactivateAction(n2), this._removeInactiveAction(n2));
      }
      var i2 = this._bindingsByRootAndName[t2];
      if (i2 !== void 0)
        for (const o2 in i2) {
          const s2 = i2[o2];
          s2.restoreOriginalState(), this._removeInactiveBinding(s2);
        }
    }
    uncacheAction(e2, t2) {
      t2 = this.existingAction(e2, t2);
      t2 !== null && (this._deactivateAction(t2), this._removeInactiveAction(t2));
    }
  }
  AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  class InstancedInterleavedBuffer extends InterleavedBuffer {
    constructor(e2, t2, r2 = 1) {
      super(e2, t2), this.meshPerAttribute = r2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    clone(e2) {
      const t2 = super.clone(e2);
      return t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.isInstancedInterleavedBuffer = true, t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
  }
  InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
  const _vector$2 = new Vector3(), _boneMatrix = new Matrix4(), _matrixWorldInv = new Matrix4();
  class SkeletonHelper extends LineSegments {
    constructor(e2) {
      var t2 = getBoneList(e2);
      const r2 = new BufferGeometry(), n2 = [], i2 = [];
      var a2 = new Color(0, 0, 1), o2 = new Color(0, 1, 0);
      for (let e3 = 0; e3 < t2.length; e3++) {
        var s2 = t2[e3];
        s2.parent && s2.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), i2.push(a2.r, a2.g, a2.b), i2.push(o2.r, o2.g, o2.b));
      }
      r2.setAttribute("position", new Float32BufferAttribute(n2, 3)), r2.setAttribute("color", new Float32BufferAttribute(i2, 3));
      var l2 = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
      super(r2, l2), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = e2, this.bones = t2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(e2) {
      var r2 = this.bones;
      const t2 = this.geometry, n2 = t2.getAttribute("position");
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (let e3 = 0, t3 = 0; e3 < r2.length; e3++) {
        var i2 = r2[e3];
        i2.parent && i2.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, i2.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), n2.setXYZ(t3, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, i2.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), n2.setXYZ(t3 + 1, _vector$2.x, _vector$2.y, _vector$2.z), t3 += 2);
      }
      t2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e2);
    }
  }
  function getBoneList(t2) {
    const r2 = [];
    t2 && t2.isBone && r2.push(t2);
    for (let e2 = 0; e2 < t2.children.length; e2++)
      r2.push.apply(r2, getBoneList(t2.children[e2]));
    return r2;
  }
  class GridHelper extends LineSegments {
    constructor(e2 = 10, n2 = 10, i2 = 4473924, a2 = 8947848) {
      i2 = new Color(i2), a2 = new Color(a2);
      var o2 = n2 / 2, s2 = e2 / n2, l2 = e2 / 2;
      const c2 = [], u2 = [];
      for (let e3 = 0, t3 = 0, r2 = -l2; e3 <= n2; e3++, r2 += s2) {
        c2.push(-l2, 0, r2, l2, 0, r2), c2.push(r2, 0, -l2, r2, 0, l2);
        const h2 = e3 === o2 ? i2 : a2;
        h2.toArray(u2, t3), t3 += 3, h2.toArray(u2, t3), t3 += 3, h2.toArray(u2, t3), t3 += 3, h2.toArray(u2, t3), t3 += 3;
      }
      const t2 = new BufferGeometry();
      t2.setAttribute("position", new Float32BufferAttribute(c2, 3)), t2.setAttribute("color", new Float32BufferAttribute(u2, 3));
      e2 = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(t2, e2), this.type = "GridHelper";
    }
  }
  const _vector = new Vector3(), _camera$1 = new Camera();
  class CameraHelper extends LineSegments {
    constructor(e2) {
      const t2 = new BufferGeometry();
      var r2 = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
      const n2 = [], i2 = [], a2 = {};
      var o2 = new Color(16755200), s2 = new Color(16711680), l2 = new Color(43775), c2 = new Color(16777215), u2 = new Color(3355443);
      function h2(e3, t3, r3) {
        d2(e3, r3), d2(t3, r3);
      }
      function d2(e3, t3) {
        n2.push(0, 0, 0), i2.push(t3.r, t3.g, t3.b), a2[e3] === void 0 && (a2[e3] = []), a2[e3].push(n2.length / 3 - 1);
      }
      h2("n1", "n2", o2), h2("n2", "n4", o2), h2("n4", "n3", o2), h2("n3", "n1", o2), h2("f1", "f2", o2), h2("f2", "f4", o2), h2("f4", "f3", o2), h2("f3", "f1", o2), h2("n1", "f1", o2), h2("n2", "f2", o2), h2("n3", "f3", o2), h2("n4", "f4", o2), h2("p", "n1", s2), h2("p", "n2", s2), h2("p", "n3", s2), h2("p", "n4", s2), h2("u1", "u2", l2), h2("u2", "u3", l2), h2("u3", "u1", l2), h2("c", "t", c2), h2("p", "c", u2), h2("cn1", "cn2", u2), h2("cn3", "cn4", u2), h2("cf1", "cf2", u2), h2("cf3", "cf4", u2), t2.setAttribute("position", new Float32BufferAttribute(n2, 3)), t2.setAttribute("color", new Float32BufferAttribute(i2, 3)), super(t2, r2), this.type = "CameraHelper", this.camera = e2, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a2, this.update();
    }
    update() {
      const e2 = this.geometry;
      var t2 = this.pointMap;
      _camera$1.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t2, e2, _camera$1, 0, 0, -1), setPoint("t", t2, e2, _camera$1, 0, 0, 1), setPoint("n1", t2, e2, _camera$1, -1, -1, -1), setPoint("n2", t2, e2, _camera$1, 1, -1, -1), setPoint("n3", t2, e2, _camera$1, -1, 1, -1), setPoint("n4", t2, e2, _camera$1, 1, 1, -1), setPoint("f1", t2, e2, _camera$1, -1, -1, 1), setPoint("f2", t2, e2, _camera$1, 1, -1, 1), setPoint("f3", t2, e2, _camera$1, -1, 1, 1), setPoint("f4", t2, e2, _camera$1, 1, 1, 1), setPoint("u1", t2, e2, _camera$1, 0.7, 1.1, -1), setPoint("u2", t2, e2, _camera$1, -0.7, 1.1, -1), setPoint("u3", t2, e2, _camera$1, 0, 2, -1), setPoint("cf1", t2, e2, _camera$1, -1, 0, 1), setPoint("cf2", t2, e2, _camera$1, 1, 0, 1), setPoint("cf3", t2, e2, _camera$1, 0, -1, 1), setPoint("cf4", t2, e2, _camera$1, 0, 1, 1), setPoint("cn1", t2, e2, _camera$1, -1, 0, -1), setPoint("cn2", t2, e2, _camera$1, 1, 0, -1), setPoint("cn3", t2, e2, _camera$1, 0, -1, -1), setPoint("cn4", t2, e2, _camera$1, 0, 1, -1), e2.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function setPoint(e2, t2, r2, n2, i2, a2, o2) {
    _vector.set(i2, a2, o2).unproject(n2);
    var s2 = t2[e2];
    if (s2 !== void 0) {
      const l2 = r2.getAttribute("position");
      for (let e3 = 0, t3 = s2.length; e3 < t3; e3++)
        l2.setXYZ(s2[e3], _vector.x, _vector.y, _vector.z);
    }
  }
  const _floatView = new Float32Array(1), _int32View = new Int32Array(_floatView.buffer);
  class DataUtils {
    static toHalfFloat(e2) {
      65504 < e2 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), e2 = 65504), _floatView[0] = e2;
      var t2 = _int32View[0];
      let r2 = t2 >> 16 & 32768, n2 = t2 >> 12 & 2047;
      e2 = t2 >> 23 & 255;
      return e2 < 103 || (142 < e2 ? (r2 |= 31744, r2 |= (e2 == 255 ? 0 : 1) && 8388607 & t2) : e2 < 113 ? (n2 |= 2048, r2 |= (n2 >> 114 - e2) + (n2 >> 113 - e2 & 1)) : (r2 |= e2 - 112 << 10 | n2 >> 1, r2 += 1 & n2)), r2;
    }
  }
  Curve.create = function(e2, t2) {
    return console.log("THREE.Curve.create() has been deprecated"), e2.prototype = Object.create(Curve.prototype), (e2.prototype.constructor = e2).prototype.getPoint = t2, e2;
  }, Path.prototype.fromPoints = function(e2) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e2);
  }, GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  }, SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  }, Loader.prototype.extractUrlBase = function(e2) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(e2);
  }, Loader.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } }, Box3.prototype.center = function(e2) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e2);
  }, Box3.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, Box3.prototype.isIntersectionBox = function(e2) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e2);
  }, Box3.prototype.isIntersectionSphere = function(e2) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e2);
  }, Box3.prototype.size = function(e2) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e2);
  }, Sphere.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, Frustum.prototype.setFromMatrix = function(e2) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e2);
  }, Matrix3.prototype.flattenToArrayOffset = function(e2, t2) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e2, t2);
  }, Matrix3.prototype.multiplyVector3 = function(e2) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e2.applyMatrix3(this);
  }, Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, Matrix3.prototype.applyToBufferAttribute = function(e2) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e2.applyMatrix3(this);
  }, Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }, Matrix3.prototype.getInverse = function(e2) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e2).invert();
  }, Matrix4.prototype.extractPosition = function(e2) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e2);
  }, Matrix4.prototype.flattenToArrayOffset = function(e2, t2) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e2, t2);
  }, Matrix4.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Vector3().setFromMatrixColumn(this, 3);
  }, Matrix4.prototype.setRotationFromQuaternion = function(e2) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e2);
  }, Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, Matrix4.prototype.multiplyVector3 = function(e2) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
  }, Matrix4.prototype.multiplyVector4 = function(e2) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
  }, Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, Matrix4.prototype.rotateAxis = function(e2) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e2.transformDirection(this);
  }, Matrix4.prototype.crossVector = function(e2) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
  }, Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, Matrix4.prototype.applyToBufferAttribute = function(e2) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
  }, Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, Matrix4.prototype.makeFrustum = function(e2, t2, r2, n2, i2, a2) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e2, t2, n2, r2, i2, a2);
  }, Matrix4.prototype.getInverse = function(e2) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e2).invert();
  }, Plane.prototype.isIntersectionLine = function(e2) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e2);
  }, Quaternion.prototype.multiplyVector3 = function(e2) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e2.applyQuaternion(this);
  }, Quaternion.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }, Ray.prototype.isIntersectionBox = function(e2) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e2);
  }, Ray.prototype.isIntersectionPlane = function(e2) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e2);
  }, Ray.prototype.isIntersectionSphere = function(e2) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e2);
  }, Triangle.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  }, Triangle.prototype.barycoordFromPoint = function(e2, t2) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e2, t2);
  }, Triangle.prototype.midpoint = function(e2) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e2);
  }, Triangle.prototypenormal = function(e2) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e2);
  }, Triangle.prototype.plane = function(e2) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e2);
  }, Triangle.barycoordFromPoint = function(e2, t2, r2, n2, i2) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(e2, t2, r2, n2, i2);
  }, Triangle.normal = function(e2, t2, r2, n2) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(e2, t2, r2, n2);
  }, Shape.prototype.extractAllPoints = function(e2) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e2);
  }, Shape.prototype.extrude = function(e2) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, e2);
  }, Shape.prototype.makeGeometry = function(e2) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, e2);
  }, Vector2.prototype.fromAttribute = function(e2, t2, r2) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, r2);
  }, Vector2.prototype.distanceToManhattan = function(e2) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e2);
  }, Vector2.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, Vector3.prototype.getPositionFromMatrix = function(e2) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e2);
  }, Vector3.prototype.getScaleFromMatrix = function(e2) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e2);
  }, Vector3.prototype.getColumnFromMatrix = function(e2, t2) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t2, e2);
  }, Vector3.prototype.applyProjection = function(e2) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e2);
  }, Vector3.prototype.fromAttribute = function(e2, t2, r2) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, r2);
  }, Vector3.prototype.distanceToManhattan = function(e2) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e2);
  }, Vector3.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, Vector4.prototype.fromAttribute = function(e2, t2, r2) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, r2);
  }, Vector4.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, Object3D.prototype.getChildByName = function(e2) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e2);
  }, Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, Object3D.prototype.translate = function(e2, t2) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t2, e2);
  }, Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, Object3D.prototype.applyMatrix = function(e2) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e2);
  }, Object.defineProperties(Object3D.prototype, { eulerOrder: { get: function() {
    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
  }, set: function(e2) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e2;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } }), Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }, Object.defineProperties(Mesh.prototype, { drawMode: { get: function() {
    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), TrianglesDrawMode;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } }), SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }, PerspectiveCamera.prototype.setLens = function(e2, t2) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), t2 !== void 0 && (this.filmGauge = t2), this.setFocalLength(e2);
  }, Object.defineProperties(Light.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e2;
  } }, shadowCameraLeft: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e2;
  } }, shadowCameraRight: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e2;
  } }, shadowCameraTop: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e2;
  } }, shadowCameraBottom: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e2;
  } }, shadowCameraNear: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e2;
  } }, shadowCameraFar: { set: function(e2) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e2;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(e2) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e2;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(e2) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e2;
  } }, shadowMapHeight: { set: function(e2) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e2;
  } } }), Object.defineProperties(BufferAttribute.prototype, { length: { get: function() {
    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
  } }, dynamic: { get: function() {
    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(DynamicDrawUsage);
  } } }), BufferAttribute.prototype.setDynamic = function(e2) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(e2 === true ? DynamicDrawUsage : StaticDrawUsage), this;
  }, BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, BufferGeometry.prototype.addIndex = function(e2) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e2);
  }, BufferGeometry.prototype.addAttribute = function(e2, t2) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t2 && t2.isBufferAttribute || t2 && t2.isInterleavedBufferAttribute ? e2 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t2), this) : this.setAttribute(e2, t2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e2, new BufferAttribute(t2, arguments[2])));
  }, BufferGeometry.prototype.addDrawCall = function(e2, t2, r2) {
    r2 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e2, t2);
  }, BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  }, BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, BufferGeometry.prototype.removeAttribute = function(e2) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e2);
  }, BufferGeometry.prototype.applyMatrix = function(e2) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e2);
  }, Object.defineProperties(BufferGeometry.prototype, { drawcalls: { get: function() {
    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
  } }, offsets: { get: function() {
    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
  } } }), InterleavedBuffer.prototype.setDynamic = function(e2) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(e2 === true ? DynamicDrawUsage : StaticDrawUsage), this;
  }, InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  }, ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  }, ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  }, Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }, Object.defineProperties(Material.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(e2) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e2 === FlatShading;
  } }, stencilMask: { get: function() {
    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
  }, set: function(e2) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e2;
  } }, vertexTangents: { get: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  }, set: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  } } }), Object.defineProperties(ShaderMaterial.prototype, { derivatives: { get: function() {
    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
  }, set: function(e2) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e2;
  } } }), WebGLRenderer.prototype.clearTarget = function(e2, t2, r2, n2) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e2), this.clear(t2, r2, n2);
  }, WebGLRenderer.prototype.animate = function(e2) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e2);
  }, WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  }, WebGLRenderer.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  }, WebGLRenderer.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  }, WebGLRenderer.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  }, WebGLRenderer.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  }, WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  }, WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  }, WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, WebGLRenderer.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  }, WebGLRenderer.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  }, WebGLRenderer.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  }, WebGLRenderer.prototype.enableScissorTest = function(e2) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e2);
  }, WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }, WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  }, WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  }, WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  }, WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }, WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }, Object.defineProperties(WebGLRenderer.prototype, { shadowMapEnabled: { get: function() {
    return this.shadowMap.enabled;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e2;
  } }, shadowMapType: { get: function() {
    return this.shadowMap.type;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e2;
  } }, shadowMapCullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  } }, context: { get: function() {
    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
  } }, vr: { get: function() {
    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
  } }, gammaInput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  } }, gammaOutput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = e2 === true ? sRGBEncoding : LinearEncoding;
  } }, toneMappingWhitePoint: { get: function() {
    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
  } } }), Object.defineProperties(WebGLShadowMap.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  } }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } }), Object.defineProperties(WebGLRenderTarget.prototype, { wrapS: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e2;
  } }, wrapT: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e2;
  } }, magFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e2;
  } }, minFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e2;
  } }, anisotropy: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e2;
  } }, offset: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e2;
  } }, repeat: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e2;
  } }, format: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e2;
  } }, type: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e2;
  } }, generateMipmaps: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
  }, set: function(e2) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e2;
  } } }), Audio.prototype.load = function(e2) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const t2 = this, r2 = new AudioLoader();
    return r2.load(e2, function(e3) {
      t2.setBuffer(e3);
    }), this;
  }, CubeCamera.prototype.updateCubeMap = function(e2, t2) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e2, t2);
  }, CubeCamera.prototype.clear = function(e2, t2, r2, n2) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e2, t2, r2, n2);
  }, ImageUtils.crossOrigin = void 0, ImageUtils.loadTexture = function(e2, t2, r2, n2) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const i2 = new TextureLoader();
    i2.setCrossOrigin(this.crossOrigin);
    const a2 = i2.load(e2, r2, void 0, n2);
    return t2 && (a2.mapping = t2), a2;
  }, ImageUtils.loadTextureCube = function(e2, t2, r2, n2) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const i2 = new CubeTextureLoader();
    i2.setCrossOrigin(this.crossOrigin);
    const a2 = i2.load(e2, r2, void 0, n2);
    return t2 && (a2.mapping = t2), a2;
  }, ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
  var CopyShader = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}` };
  class Pass {
    constructor() {
      this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
    }
    setSize() {
    }
    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
  }
  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), _geometry$1 = new BufferGeometry();
  _geometry$1.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), _geometry$1.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  class FullScreenQuad {
    constructor(e2) {
      this._mesh = new Mesh(_geometry$1, e2);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(e2) {
      e2.render(this._mesh, _camera);
    }
    get material() {
      return this._mesh.material;
    }
    set material(e2) {
      this._mesh.material = e2;
    }
  }
  class ShaderPass extends Pass {
    constructor(e2, t2) {
      super(), this.textureID = t2 !== void 0 ? t2 : "tDiffuse", e2 instanceof ShaderMaterial ? (this.uniforms = e2.uniforms, this.material = e2) : e2 && (this.uniforms = UniformsUtils.clone(e2.uniforms), this.material = new ShaderMaterial({ defines: Object.assign({}, e2.defines), uniforms: this.uniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader })), this.fsQuad = new FullScreenQuad(this.material);
    }
    render(e2, t2, r2) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r2.texture), this.fsQuad.material = this.material, this.renderToScreen ? e2.setRenderTarget(null) : (e2.setRenderTarget(t2), this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil)), this.fsQuad.render(e2);
    }
  }
  class MaskPass extends Pass {
    constructor(e2, t2) {
      super(), this.scene = e2, this.camera = t2, this.clear = true, this.needsSwap = false, this.inverse = false;
    }
    render(e2, t2, r2) {
      var n2 = e2.getContext();
      const i2 = e2.state;
      i2.buffers.color.setMask(false), i2.buffers.depth.setMask(false), i2.buffers.color.setLocked(true), i2.buffers.depth.setLocked(true);
      let a2, o2;
      o2 = this.inverse ? (a2 = 0, 1) : (a2 = 1, 0), i2.buffers.stencil.setTest(true), i2.buffers.stencil.setOp(n2.REPLACE, n2.REPLACE, n2.REPLACE), i2.buffers.stencil.setFunc(n2.ALWAYS, a2, 4294967295), i2.buffers.stencil.setClear(o2), i2.buffers.stencil.setLocked(true), e2.setRenderTarget(r2), this.clear && e2.clear(), e2.render(this.scene, this.camera), e2.setRenderTarget(t2), this.clear && e2.clear(), e2.render(this.scene, this.camera), i2.buffers.color.setLocked(false), i2.buffers.depth.setLocked(false), i2.buffers.stencil.setLocked(false), i2.buffers.stencil.setFunc(n2.EQUAL, 1, 4294967295), i2.buffers.stencil.setOp(n2.KEEP, n2.KEEP, n2.KEEP), i2.buffers.stencil.setLocked(true);
    }
  }
  class ClearMaskPass extends Pass {
    constructor() {
      super(), this.needsSwap = false;
    }
    render(e2) {
      e2.state.buffers.stencil.setLocked(false), e2.state.buffers.stencil.setTest(false);
    }
  }
  class EffectComposer {
    constructor(e2, t2) {
      var r2, n2;
      this.renderer = e2, t2 === void 0 ? (r2 = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }, n2 = e2.getSize(new Vector2()), this._pixelRatio = e2.getPixelRatio(), this._width = n2.width, this._height = n2.height, (t2 = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, r2)).texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = t2.width, this._height = t2.height), this.renderTarget1 = t2, this.renderTarget2 = t2.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], CopyShader === void 0 && console.error("THREE.EffectComposer relies on CopyShader"), ShaderPass === void 0 && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new ShaderPass(CopyShader), this.clock = new Clock();
    }
    swapBuffers() {
      var e2 = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e2;
    }
    addPass(e2) {
      this.passes.push(e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(e2, t2) {
      this.passes.splice(t2, 0, e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(e2) {
      e2 = this.passes.indexOf(e2);
      e2 !== -1 && this.passes.splice(e2, 1);
    }
    isLastEnabledPass(t2) {
      for (let e2 = t2 + 1; e2 < this.passes.length; e2++)
        if (this.passes[e2].enabled)
          return false;
      return true;
    }
    render(r2) {
      r2 === void 0 && (r2 = this.clock.getDelta());
      var e2 = this.renderer.getRenderTarget();
      let n2 = false;
      for (let e3 = 0, t2 = this.passes.length; e3 < t2; e3++) {
        const a2 = this.passes[e3];
        if (a2.enabled !== false) {
          if (a2.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e3), a2.render(this.renderer, this.writeBuffer, this.readBuffer, r2, n2), a2.needsSwap) {
            if (n2) {
              var i2 = this.renderer.getContext();
              const o2 = this.renderer.state.buffers.stencil;
              o2.setFunc(i2.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, r2), o2.setFunc(i2.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          MaskPass !== void 0 && (a2 instanceof MaskPass ? n2 = true : a2 instanceof ClearMaskPass && (n2 = false));
        }
      }
      this.renderer.setRenderTarget(e2);
    }
    reset(e2) {
      var t2;
      e2 === void 0 && (t2 = this.renderer.getSize(new Vector2()), this._pixelRatio = this.renderer.getPixelRatio(), this._width = t2.width, this._height = t2.height, (e2 = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)), this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e2, this.renderTarget2 = e2.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }
    setSize(e2, t2) {
      this._width = e2, this._height = t2;
      var r2 = this._width * this._pixelRatio, n2 = this._height * this._pixelRatio;
      this.renderTarget1.setSize(r2, n2), this.renderTarget2.setSize(r2, n2);
      for (let e3 = 0; e3 < this.passes.length; e3++)
        this.passes[e3].setSize(r2, n2);
    }
    setPixelRatio(e2) {
      this._pixelRatio = e2, this.setSize(this._width, this._height);
    }
  }
  new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const _geometry = new BufferGeometry();
  _geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), _geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  class RenderPass extends Pass {
    constructor(e2, t2, r2, n2, i2) {
      super(), this.scene = e2, this.camera = t2, this.overrideMaterial = r2, this.clearColor = n2, this.clearAlpha = i2 !== void 0 ? i2 : 0, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
    }
    render(e2, t2, r2) {
      var n2 = e2.autoClear;
      e2.autoClear = false;
      let i2, a2;
      this.overrideMaterial !== void 0 && (a2 = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e2.getClearColor(this._oldClearColor), i2 = e2.getClearAlpha(), e2.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e2.clearDepth(), e2.setRenderTarget(this.renderToScreen ? null : r2), this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), e2.render(this.scene, this.camera), this.clearColor && e2.setClearColor(this._oldClearColor, i2), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = a2), e2.autoClear = n2;
    }
  }
  const LuminosityHighPassShader = { shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new Color(0) }, defaultOpacity: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}` };
  class TransparentBackgroundFixedUnrealBloomPass extends Pass {
    constructor(e2, t2, r2, n2) {
      super(), this.strength = t2 !== void 0 ? t2 : 1, this.radius = r2, this.threshold = n2, this.resolution = e2 !== void 0 ? new Vector2(e2.x, e2.y) : new Vector2(256, 256), this.clearColor = new Color(0, 0, 0);
      var i2 = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
      this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
      let a2 = Math.round(this.resolution.x / 2), o2 = Math.round(this.resolution.y / 2);
      this.renderTargetBright = new WebGLRenderTarget(a2, o2, i2), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
      for (let e3 = 0; e3 < this.nMips; e3++) {
        const l2 = new WebGLRenderTarget(a2, o2, i2);
        l2.texture.name = "UnrealBloomPass.h" + e3, l2.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(l2);
        const c2 = new WebGLRenderTarget(a2, o2, i2);
        c2.texture.name = "UnrealBloomPass.v" + e3, c2.texture.generateMipmaps = false, this.renderTargetsVertical.push(c2), a2 = Math.round(a2 / 2), o2 = Math.round(o2 / 2);
      }
      LuminosityHighPassShader === void 0 && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
      e2 = LuminosityHighPassShader;
      this.highPassUniforms = UniformsUtils.clone(e2.uniforms), this.highPassUniforms.luminosityThreshold.value = n2, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new ShaderMaterial({ uniforms: this.highPassUniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader, defines: {} }), this.separableBlurMaterials = [];
      var s2 = [3, 5, 7, 9, 11];
      a2 = Math.round(this.resolution.x / 2), o2 = Math.round(this.resolution.y / 2);
      for (let e3 = 0; e3 < this.nMips; e3++)
        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(s2[e3])), this.separableBlurMaterials[e3].uniforms.texSize.value = new Vector2(a2, o2), a2 = Math.round(a2 / 2), o2 = Math.round(o2 / 2);
      this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t2, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.needsUpdate = true;
      this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2], this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, CopyShader === void 0 && console.error("THREE.UnrealBloomPass relies on CopyShader");
      t2 = CopyShader;
      this.copyUniforms = UniformsUtils.clone(t2.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: t2.vertexShader, fragmentShader: t2.fragmentShader, blending: AdditiveBlending, depthTest: false, depthWrite: false, transparent: true }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new Color(), this.oldClearAlpha = 1, this.basic = new MeshBasicMaterial(), this.fsQuad = new FullScreenQuad(null);
    }
    dispose() {
      for (let e2 = 0; e2 < this.renderTargetsHorizontal.length; e2++)
        this.renderTargetsHorizontal[e2].dispose();
      for (let e2 = 0; e2 < this.renderTargetsVertical.length; e2++)
        this.renderTargetsVertical[e2].dispose();
      this.renderTargetBright.dispose();
    }
    setSize(e2, t2) {
      let r2 = Math.round(e2 / 2), n2 = Math.round(t2 / 2);
      this.renderTargetBright.setSize(r2, n2);
      for (let e3 = 0; e3 < this.nMips; e3++)
        this.renderTargetsHorizontal[e3].setSize(r2, n2), this.renderTargetsVertical[e3].setSize(r2, n2), this.separableBlurMaterials[e3].uniforms.texSize.value = new Vector2(r2, n2), r2 = Math.round(r2 / 2), n2 = Math.round(n2 / 2);
    }
    render(t2, e2, r2, n2, i2) {
      t2.getClearColor(this._oldClearColor), this.oldClearAlpha = t2.getClearAlpha();
      var a2 = t2.autoClear;
      t2.autoClear = false, t2.setClearColor(this.clearColor, 0), i2 && t2.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = r2.texture, t2.setRenderTarget(null), t2.clear(), this.fsQuad.render(t2)), this.highPassUniforms.tDiffuse.value = r2.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t2.setRenderTarget(this.renderTargetBright), t2.clear(), this.fsQuad.render(t2);
      let o2 = this.renderTargetBright;
      for (let e3 = 0; e3 < this.nMips; e3++)
        this.fsQuad.material = this.separableBlurMaterials[e3], this.separableBlurMaterials[e3].uniforms.colorTexture.value = o2.texture, this.separableBlurMaterials[e3].uniforms.direction.value = TransparentBackgroundFixedUnrealBloomPass.BlurDirectionX, t2.setRenderTarget(this.renderTargetsHorizontal[e3]), t2.clear(), this.fsQuad.render(t2), this.separableBlurMaterials[e3].uniforms.colorTexture.value = this.renderTargetsHorizontal[e3].texture, this.separableBlurMaterials[e3].uniforms.direction.value = TransparentBackgroundFixedUnrealBloomPass.BlurDirectionY, t2.setRenderTarget(this.renderTargetsVertical[e3]), t2.clear(), this.fsQuad.render(t2), o2 = this.renderTargetsVertical[e3];
      this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t2.setRenderTarget(this.renderTargetsHorizontal[0]), t2.clear(), this.fsQuad.render(t2), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i2 && t2.state.buffers.stencil.setTest(true), this.renderToScreen ? t2.setRenderTarget(null) : t2.setRenderTarget(r2), this.fsQuad.render(t2), t2.setClearColor(this._oldClearColor, this.oldClearAlpha), t2.autoClear = a2;
    }
    getSeperableBlurMaterial(e2) {
      return new ShaderMaterial({ defines: { KERNEL_RADIUS: e2, SIGMA: e2 }, uniforms: { colorTexture: { value: null }, texSize: { value: new Vector2(0.5, 0.5) }, direction: { value: new Vector2(0.5, 0.5) } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
          vec2 invSize = 1.0 / texSize;          float fSigma = float(SIGMA);          float weightSum = gaussianPdf(0.0, fSigma);          float alphaSum = 0.0;          vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;          for( int i = 1; i < KERNEL_RADIUS; i ++ ) {            float x = float(i);            float w = gaussianPdf(x, fSigma);            vec2 uvOffset = direction * invSize * x;            vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);            vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);            diffuseSum += (sample1.rgb + sample2.rgb) * w;            alphaSum += (sample1.a + sample2.a) * w;            weightSum += 2.0 * w;          }          gl_FragColor = vec4(diffuseSum/weightSum, alphaSum/weightSum);
        }` });
    }
    getCompositeMaterial(e2) {
      return new ShaderMaterial({ defines: { NUM_MIPS: e2 }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}` });
    }
  }
  function __perlin() {
    var e2 = {};
    function t2(e3, t3, r2) {
      this.x = e3, this.y = t3, this.z = r2;
    }
    t2.prototype.dot2 = function(e3, t3) {
      return this.x * e3 + this.y * t3;
    }, t2.prototype.dot3 = function(e3, t3, r2) {
      return this.x * e3 + this.y * t3 + this.z * r2;
    };
    var n2 = [new t2(1, 1, 0), new t2(-1, 1, 0), new t2(1, -1, 0), new t2(-1, -1, 0), new t2(1, 0, 1), new t2(-1, 0, 1), new t2(1, 0, -1), new t2(-1, 0, -1), new t2(0, 1, 1), new t2(0, -1, 1), new t2(0, 1, -1), new t2(0, -1, -1)], i2 = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], w2 = new Array(512), S2 = new Array(512);
    e2.seed = function(e3) {
      0 < e3 && e3 < 1 && (e3 *= 65536), (e3 = Math.floor(e3)) < 256 && (e3 |= e3 << 8);
      for (var t3 = 0; t3 < 256; t3++) {
        var r2 = 1 & t3 ? i2[t3] ^ 255 & e3 : i2[t3] ^ e3 >> 8 & 255;
        w2[t3] = w2[t3 + 256] = r2, S2[t3] = S2[t3 + 256] = n2[r2 % 12];
      }
    }, e2.seed(0);
    var d2 = 0.5 * (Math.sqrt(3) - 1), p2 = (3 - Math.sqrt(3)) / 6;
    function f2(e3) {
      return e3 * e3 * e3 * (e3 * (6 * e3 - 15) + 10);
    }
    function m2(e3, t3, r2) {
      return (1 - r2) * e3 + r2 * t3;
    }
    return e2.simplex2 = function(e3, t3) {
      var r2 = (e3 + t3) * d2, n3 = Math.floor(e3 + r2), i3 = Math.floor(t3 + r2), a2 = (n3 + i3) * p2, o2 = e3 - n3 + a2, s2 = t3 - i3 + a2, l2 = s2 < o2 ? (h2 = 1, 0) : (h2 = 0, 1), c2 = o2 - h2 + p2, u2 = s2 - l2 + p2, r2 = o2 - 1 + 2 * p2, e3 = s2 - 1 + 2 * p2, t3 = S2[(n3 &= 255) + w2[i3 &= 255]], a2 = S2[n3 + h2 + w2[i3 + l2]], h2 = S2[1 + n3 + w2[1 + i3]], l2 = 0.5 - o2 * o2 - s2 * s2, n3 = 0.5 - c2 * c2 - u2 * u2, i3 = 0.5 - r2 * r2 - e3 * e3;
      return 70 * ((l2 < 0 ? 0 : (l2 *= l2) * l2 * t3.dot2(o2, s2)) + (n3 < 0 ? 0 : (n3 *= n3) * n3 * a2.dot2(c2, u2)) + (i3 < 0 ? 0 : (i3 *= i3) * i3 * h2.dot2(r2, e3)));
    }, e2.simplex3 = function(e3, t3, r2) {
      var n3, i3, a2 = (e3 + t3 + r2) * (1 / 3), o2 = Math.floor(e3 + a2), s2 = Math.floor(t3 + a2), l2 = Math.floor(r2 + a2), c2 = (o2 + s2 + l2) * (1 / 6), u2 = e3 - o2 + c2, h2 = t3 - s2 + c2, d3 = r2 - l2 + c2, p3 = h2 <= u2 ? d3 <= h2 ? (x2 = b2 = n3 = 1, _2 = i3 = 0) : b2 = d3 <= u2 ? (x2 = _2 = i3 = 0, n3 = 1) : (x2 = i3 = n3 = 0, _2 = 1) : h2 < d3 ? (b2 = i3 = n3 = 0, x2 = _2 = 1) : u2 < d3 ? (b2 = _2 = n3 = 0, x2 = i3 = 1) : (x2 = b2 = i3 = 1, _2 = n3 = 0), f3 = u2 - n3 + 1 / 6, m3 = h2 - i3 + 1 / 6, g2 = d3 - _2 + 1 / 6, v2 = u2 - b2 + 1 / 6 * 2, y = h2 - x2 + 1 / 6 * 2, a2 = d3 - p3 + 1 / 6 * 2, e3 = u2 - 1 + 0.5, t3 = h2 - 1 + 0.5, r2 = d3 - 1 + 0.5, c2 = S2[(o2 &= 255) + w2[(s2 &= 255) + w2[l2 &= 255]]], _2 = S2[o2 + n3 + w2[s2 + i3 + w2[l2 + _2]]], b2 = S2[o2 + b2 + w2[s2 + x2 + w2[l2 + p3]]], x2 = S2[1 + o2 + w2[1 + s2 + w2[1 + l2]]], p3 = 0.6 - u2 * u2 - h2 * h2 - d3 * d3, o2 = 0.6 - f3 * f3 - m3 * m3 - g2 * g2, s2 = 0.6 - v2 * v2 - y * y - a2 * a2, l2 = 0.6 - e3 * e3 - t3 * t3 - r2 * r2;
      return 32 * ((p3 < 0 ? 0 : (p3 *= p3) * p3 * c2.dot3(u2, h2, d3)) + (o2 < 0 ? 0 : (o2 *= o2) * o2 * _2.dot3(f3, m3, g2)) + (s2 < 0 ? 0 : (s2 *= s2) * s2 * b2.dot3(v2, y, a2)) + (l2 < 0 ? 0 : (l2 *= l2) * l2 * x2.dot3(e3, t3, r2)));
    }, e2.perlin2 = function(e3, t3) {
      var r2 = Math.floor(e3), n3 = Math.floor(t3);
      e3 -= r2, t3 -= n3;
      var i3 = S2[(r2 &= 255) + w2[n3 &= 255]].dot2(e3, t3), a2 = S2[r2 + w2[1 + n3]].dot2(e3, t3 - 1), o2 = S2[1 + r2 + w2[n3]].dot2(e3 - 1, t3), n3 = S2[1 + r2 + w2[1 + n3]].dot2(e3 - 1, t3 - 1), e3 = f2(e3);
      return m2(m2(i3, o2, e3), m2(a2, n3, e3), f2(t3));
    }, e2.perlin3 = function(e3, t3, r2) {
      var n3 = Math.floor(e3), i3 = Math.floor(t3), a2 = Math.floor(r2);
      e3 -= n3, t3 -= i3, r2 -= a2;
      var o2 = S2[(n3 &= 255) + w2[(i3 &= 255) + w2[a2 &= 255]]].dot3(e3, t3, r2), s2 = S2[n3 + w2[i3 + w2[1 + a2]]].dot3(e3, t3, r2 - 1), l2 = S2[n3 + w2[1 + i3 + w2[a2]]].dot3(e3, t3 - 1, r2), c2 = S2[n3 + w2[1 + i3 + w2[1 + a2]]].dot3(e3, t3 - 1, r2 - 1), u2 = S2[1 + n3 + w2[i3 + w2[a2]]].dot3(e3 - 1, t3, r2), h2 = S2[1 + n3 + w2[i3 + w2[1 + a2]]].dot3(e3 - 1, t3, r2 - 1), d3 = S2[1 + n3 + w2[1 + i3 + w2[a2]]].dot3(e3 - 1, t3 - 1, r2), a2 = S2[1 + n3 + w2[1 + i3 + w2[1 + a2]]].dot3(e3 - 1, t3 - 1, r2 - 1), e3 = f2(e3), t3 = f2(t3), r2 = f2(r2);
      return m2(m2(m2(o2, u2, e3), m2(s2, h2, e3), r2), m2(m2(l2, d3, e3), m2(c2, a2, e3), r2), t3);
    }, e2;
  }
  TransparentBackgroundFixedUnrealBloomPass.BlurDirectionX = new Vector2(1, 0), TransparentBackgroundFixedUnrealBloomPass.BlurDirectionY = new Vector2(0, 1);
  class RGBELoader extends DataTextureLoader {
    constructor(e2) {
      super(e2), this.type = HalfFloatType;
    }
    parse(i2) {
      const r2 = -1, m2 = 1, n2 = 2, g2 = 3, v2 = 4, y = function(e3, t2) {
        switch (e3) {
          case m2:
            console.error("THREE.RGBELoader Read Error: " + (t2 || ""));
            break;
          case n2:
            console.error("THREE.RGBELoader Write Error: " + (t2 || ""));
            break;
          case g2:
            console.error("THREE.RGBELoader Bad File Format: " + (t2 || ""));
            break;
          default:
          case v2:
            console.error("THREE.RGBELoader: Error: " + (t2 || ""));
        }
        return r2;
      }, l2 = 1, c2 = 2, u2 = 4, h2 = "\n", d2 = function(e3, t2, r3) {
        t2 = t2 || 1024;
        let n3 = e3.pos, i3 = -1, a3 = 0, o3 = "", s3 = String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n3, n3 + 128)));
        for (; (i3 = s3.indexOf(h2)) < 0 && a3 < t2 && n3 < e3.byteLength; )
          o3 += s3, a3 += s3.length, n3 += 128, s3 += String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n3, n3 + 128)));
        return -1 < i3 && (r3 !== false && (e3.pos += a3 + i3 + 1), o3 + s3.slice(0, i3));
      };
      const e2 = new Uint8Array(i2);
      e2.pos = 0;
      var a2, o2, s2, p2, f2, _2, b2, x2, w2, S2, M2 = function(e3) {
        const t2 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, n3 = /^\s*FORMAT=(\S+)\s*$/, i3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, a3 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
        let o3, s3;
        if (e3.pos >= e3.byteLength || !(o3 = d2(e3)))
          return y(m2, "no header found");
        if (!(s3 = o3.match(/^#\?(\S+)/)))
          return y(g2, "bad initial token");
        for (a3.valid |= l2, a3.programtype = s3[1], a3.string += o3 + "\n"; ; ) {
          if (o3 = d2(e3), o3 === false)
            break;
          if (a3.string += o3 + "\n", o3.charAt(0) !== "#") {
            if ((s3 = o3.match(t2)) && (a3.gamma = parseFloat(s3[1], 10)), (s3 = o3.match(r3)) && (a3.exposure = parseFloat(s3[1], 10)), (s3 = o3.match(n3)) && (a3.valid |= c2, a3.format = s3[1]), (s3 = o3.match(i3)) && (a3.valid |= u2, a3.height = parseInt(s3[1], 10), a3.width = parseInt(s3[2], 10)), a3.valid & c2 && a3.valid & u2)
              break;
          } else
            a3.comments += o3 + "\n";
        }
        return a3.valid & c2 ? a3.valid & u2 ? a3 : y(g2, "missing image size specifier") : y(g2, "missing format specifier");
      }(e2);
      if (r2 !== M2) {
        var E2 = M2.width, i2 = M2.height, T2 = function(e3, t2, r3) {
          var n3 = t2;
          if (n3 < 8 || 32767 < n3 || e3[0] !== 2 || e3[1] !== 2 || 128 & e3[2])
            return new Uint8Array(e3);
          if (n3 !== (e3[2] << 8 | e3[3]))
            return y(g2, "wrong scanline width");
          const i3 = new Uint8Array(4 * t2 * r3);
          if (!i3.length)
            return y(v2, "unable to allocate buffer space");
          let a3 = 0, o3 = 0;
          var s3 = 4 * n3;
          const l3 = new Uint8Array(4), c3 = new Uint8Array(s3);
          let u3 = r3;
          for (; 0 < u3 && o3 < e3.byteLength; ) {
            if (o3 + 4 > e3.byteLength)
              return y(m2);
            if (l3[0] = e3[o3++], l3[1] = e3[o3++], l3[2] = e3[o3++], l3[3] = e3[o3++], l3[0] != 2 || l3[1] != 2 || (l3[2] << 8 | l3[3]) != n3)
              return y(g2, "bad rgbe scanline format");
            let t3 = 0, r4;
            for (; t3 < s3 && o3 < e3.byteLength; ) {
              r4 = e3[o3++];
              var h3 = 128 < r4;
              if (h3 && (r4 -= 128), r4 === 0 || t3 + r4 > s3)
                return y(g2, "bad scanline data");
              if (h3) {
                var d3 = e3[o3++];
                for (let e4 = 0; e4 < r4; e4++)
                  c3[t3++] = d3;
              } else
                c3.set(e3.subarray(o3, o3 + r4), t3), t3 += r4, o3 += r4;
            }
            var p3 = n3;
            for (let e4 = 0; e4 < p3; e4++) {
              var f3 = 0;
              i3[a3] = c3[e4 + 0], f3 += n3, i3[a3 + 1] = c3[e4 + f3], f3 += n3, i3[a3 + 2] = c3[e4 + f3], f3 += n3, i3[a3 + 3] = c3[e4 + f3], a3 += 4;
            }
            u3--;
          }
          return i3;
        }(e2.subarray(e2.pos), E2, i2);
        if (r2 !== T2) {
          let e3, t2, r3, n3;
          switch (this.type) {
            case UnsignedByteType:
              e3 = T2, t2 = RGBEFormat, r3 = UnsignedByteType;
              break;
            case FloatType:
              n3 = T2.length / 4;
              var k2 = new Float32Array(3 * n3);
              for (let e4 = 0; e4 < n3; e4++)
                _2 = T2, b2 = 4 * e4, x2 = k2, w2 = 3 * e4, S2 = void 0, S2 = _2[b2 + 3], S2 = Math.pow(2, S2 - 128) / 255, x2[w2 + 0] = _2[b2 + 0] * S2, x2[w2 + 1] = _2[b2 + 1] * S2, x2[w2 + 2] = _2[b2 + 2] * S2;
              e3 = k2, t2 = RGBFormat, r3 = FloatType;
              break;
            case HalfFloatType:
              n3 = T2.length / 4;
              var A2 = new Uint16Array(3 * n3);
              for (let e4 = 0; e4 < n3; e4++)
                a2 = T2, o2 = 4 * e4, s2 = A2, p2 = 3 * e4, f2 = void 0, f2 = a2[o2 + 3], f2 = Math.pow(2, f2 - 128) / 255, s2[p2 + 0] = DataUtils.toHalfFloat(Math.min(a2[o2 + 0] * f2, 65504)), s2[p2 + 1] = DataUtils.toHalfFloat(Math.min(a2[o2 + 1] * f2, 65504)), s2[p2 + 2] = DataUtils.toHalfFloat(Math.min(a2[o2 + 2] * f2, 65504));
              e3 = A2, t2 = RGBFormat, r3 = HalfFloatType;
              break;
            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }
          return { width: E2, height: i2, data: e3, header: M2.string, gamma: M2.gamma, exposure: M2.exposure, format: t2, type: r3 };
        }
      }
      return null;
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
    load(e2, r2, t2, n2) {
      return super.load(e2, function(e3, t3) {
        switch (e3.type) {
          case UnsignedByteType:
            e3.encoding = RGBEEncoding, e3.minFilter = NearestFilter, e3.magFilter = NearestFilter, e3.generateMipmaps = false, e3.flipY = true;
            break;
          case FloatType:
          case HalfFloatType:
            e3.encoding = LinearEncoding, e3.minFilter = LinearFilter, e3.magFilter = LinearFilter, e3.generateMipmaps = false, e3.flipY = true;
        }
        r2 && r2(e3, t3);
      }, t2, n2);
    }
  }
  const _object_pattern = /^[og]\s*(.+)?/, _material_library_pattern = /^mtllib /, _material_use_pattern = /^usemtl /, _map_use_pattern = /^usemap /, _vA = new Vector3(), _vB = new Vector3(), _vC = new Vector3(), _ab = new Vector3(), _cb = new Vector3();
  function ParserState() {
    const e2 = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e3, t2) {
      if (this.object && this.object.fromDeclaration === false)
        return this.object.name = e3, void (this.object.fromDeclaration = t2 !== false);
      const r2 = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(true), this.object = { name: e3 || "", fromDeclaration: t2 !== false, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: false }, materials: [], smooth: true, startMaterial: function(e4, t3) {
        var r3 = this._finalize(false);
        r3 && (r3.inherited || r3.groupCount <= 0) && this.materials.splice(r3.index, 1);
        r3 = { index: this.materials.length, name: e4 || "", mtllib: Array.isArray(t3) && 0 < t3.length ? t3[t3.length - 1] : "", smooth: (r3 !== void 0 ? r3 : this).smooth, groupStart: r3 !== void 0 ? r3.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: false, clone: function(e5) {
          const t4 = { index: typeof e5 == "number" ? e5 : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: false };
          return t4.clone = this.clone.bind(t4), t4;
        } };
        return this.materials.push(r3), r3;
      }, currentMaterial: function() {
        if (0 < this.materials.length)
          return this.materials[this.materials.length - 1];
      }, _finalize: function(e4) {
        const t3 = this.currentMaterial();
        if (t3 && t3.groupEnd === -1 && (t3.groupEnd = this.geometry.vertices.length / 3, t3.groupCount = t3.groupEnd - t3.groupStart, t3.inherited = false), e4 && 1 < this.materials.length)
          for (let e5 = this.materials.length - 1; 0 <= e5; e5--)
            this.materials[e5].groupCount <= 0 && this.materials.splice(e5, 1);
        return e4 && this.materials.length === 0 && this.materials.push({ name: "", smooth: this.smooth }), t3;
      } }, r2 && r2.name && typeof r2.clone == "function") {
        const n2 = r2.clone(0);
        n2.inherited = true, this.object.materials.push(n2);
      }
      this.objects.push(this.object);
    }, finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(true);
    }, parseVertexIndex: function(e3, t2) {
      e3 = parseInt(e3, 10);
      return 3 * (0 <= e3 ? e3 - 1 : e3 + t2 / 3);
    }, parseNormalIndex: function(e3, t2) {
      e3 = parseInt(e3, 10);
      return 3 * (0 <= e3 ? e3 - 1 : e3 + t2 / 3);
    }, parseUVIndex: function(e3, t2) {
      e3 = parseInt(e3, 10);
      return 2 * (0 <= e3 ? e3 - 1 : e3 + t2 / 2);
    }, addVertex: function(e3, t2, r2) {
      var n2 = this.vertices;
      const i2 = this.object.geometry.vertices;
      i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addVertexPoint: function(e3) {
      var t2 = this.vertices;
      const r2 = this.object.geometry.vertices;
      r2.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addVertexLine: function(e3) {
      var t2 = this.vertices;
      const r2 = this.object.geometry.vertices;
      r2.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addNormal: function(e3, t2, r2) {
      var n2 = this.normals;
      const i2 = this.object.geometry.normals;
      i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addFaceNormal: function(e3, t2, r2) {
      var n2 = this.vertices;
      const i2 = this.object.geometry.normals;
      _vA.fromArray(n2, e3), _vB.fromArray(n2, t2), _vC.fromArray(n2, r2), _cb.subVectors(_vC, _vB), _ab.subVectors(_vA, _vB), _cb.cross(_ab), _cb.normalize(), i2.push(_cb.x, _cb.y, _cb.z), i2.push(_cb.x, _cb.y, _cb.z), i2.push(_cb.x, _cb.y, _cb.z);
    }, addColor: function(e3, t2, r2) {
      var n2 = this.colors;
      const i2 = this.object.geometry.colors;
      n2[e3] !== void 0 && i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), n2[t2] !== void 0 && i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), n2[r2] !== void 0 && i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addUV: function(e3, t2, r2) {
      var n2 = this.uvs;
      const i2 = this.object.geometry.uvs;
      i2.push(n2[e3 + 0], n2[e3 + 1]), i2.push(n2[t2 + 0], n2[t2 + 1]), i2.push(n2[r2 + 0], n2[r2 + 1]);
    }, addDefaultUV: function() {
      const e3 = this.object.geometry.uvs;
      e3.push(0, 0), e3.push(0, 0), e3.push(0, 0);
    }, addUVLine: function(e3) {
      var t2 = this.uvs;
      const r2 = this.object.geometry.uvs;
      r2.push(t2[e3 + 0], t2[e3 + 1]);
    }, addFace: function(e3, t2, r2, n2, i2, a2, o2, s2, l2) {
      var c2, u2 = this.vertices.length;
      let h2 = this.parseVertexIndex(e3, u2), d2 = this.parseVertexIndex(t2, u2), p2 = this.parseVertexIndex(r2, u2);
      this.addVertex(h2, d2, p2), this.addColor(h2, d2, p2), o2 !== void 0 && o2 !== "" ? (c2 = this.normals.length, h2 = this.parseNormalIndex(o2, c2), d2 = this.parseNormalIndex(s2, c2), p2 = this.parseNormalIndex(l2, c2), this.addNormal(h2, d2, p2)) : this.addFaceNormal(h2, d2, p2), n2 !== void 0 && n2 !== "" ? (c2 = this.uvs.length, h2 = this.parseUVIndex(n2, c2), d2 = this.parseUVIndex(i2, c2), p2 = this.parseUVIndex(a2, c2), this.addUV(h2, d2, p2), this.object.geometry.hasUVIndices = true) : this.addDefaultUV();
    }, addPointGeometry: function(r2) {
      this.object.geometry.type = "Points";
      var n2 = this.vertices.length;
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++) {
        var i2 = this.parseVertexIndex(r2[e3], n2);
        this.addVertexPoint(i2), this.addColor(i2);
      }
    }, addLineGeometry: function(r2, n2) {
      this.object.geometry.type = "Line";
      var i2 = this.vertices.length, a2 = this.uvs.length;
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++)
        this.addVertexLine(this.parseVertexIndex(r2[e3], i2));
      for (let e3 = 0, t2 = n2.length; e3 < t2; e3++)
        this.addUVLine(this.parseUVIndex(n2[e3], a2));
    } };
    return e2.startObject("", false), e2;
  }
  class OBJLoader extends Loader {
    constructor(e2) {
      super(e2), this.materials = null;
    }
    load(t2, r2, e2, n2) {
      const i2 = this, a2 = new FileLoader(this.manager);
      a2.setPath(this.path), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(t2, function(e3) {
        try {
          r2(i2.parse(e3));
        } catch (e4) {
          n2 ? n2(e4) : console.error(e4), i2.manager.itemError(t2);
        }
      }, e2, n2);
    }
    setMaterials(e2) {
      return this.materials = e2, this;
    }
    parse(e2) {
      const n2 = new ParserState();
      var r2 = (e2 = (e2 = e2.indexOf("\r\n") !== -1 ? e2.replace(/\r\n/g, "\n") : e2).indexOf("\\\n") !== -1 ? e2.replace(/\\\n/g, "") : e2).split("\n");
      let i2 = "", a2;
      let o2 = [];
      var s2 = typeof "".trimLeft == "function";
      for (let e3 = 0, t2 = r2.length; e3 < t2; e3++)
        if (i2 = r2[e3], i2 = s2 ? i2.trimLeft() : i2.trim(), i2.length !== 0 && (a2 = i2.charAt(0)) !== "#")
          if (a2 === "v") {
            var l2 = i2.split(/\s+/);
            switch (l2[0]) {
              case "v":
                n2.vertices.push(parseFloat(l2[1]), parseFloat(l2[2]), parseFloat(l2[3])), 7 <= l2.length ? n2.colors.push(parseFloat(l2[4]), parseFloat(l2[5]), parseFloat(l2[6])) : n2.colors.push(void 0, void 0, void 0);
                break;
              case "vn":
                n2.normals.push(parseFloat(l2[1]), parseFloat(l2[2]), parseFloat(l2[3]));
                break;
              case "vt":
                n2.uvs.push(parseFloat(l2[1]), parseFloat(l2[2]));
            }
          } else if (a2 === "f") {
            const T2 = i2.substr(1).trim();
            var c2, u2 = T2.split(/\s+/);
            const k2 = [];
            for (let e4 = 0, t3 = u2.length; e4 < t3; e4++) {
              const A2 = u2[e4];
              0 < A2.length && (c2 = A2.split("/"), k2.push(c2));
            }
            var h2 = k2[0];
            for (let e4 = 1, t3 = k2.length - 1; e4 < t3; e4++) {
              var d2 = k2[e4], p2 = k2[e4 + 1];
              n2.addFace(h2[0], d2[0], p2[0], h2[1], d2[1], p2[1], h2[2], d2[2], p2[2]);
            }
          } else if (a2 === "l") {
            const C2 = i2.substring(1).trim().split(" ");
            let r3 = [];
            const $2 = [];
            if (i2.indexOf("/") === -1)
              r3 = C2;
            else
              for (let e4 = 0, t3 = C2.length; e4 < t3; e4++) {
                var f2 = C2[e4].split("/");
                f2[0] !== "" && r3.push(f2[0]), f2[1] !== "" && $2.push(f2[1]);
              }
            n2.addLineGeometry(r3, $2);
          } else if (a2 === "p") {
            const R2 = i2.substr(1).trim();
            var m2 = R2.split(" ");
            n2.addPointGeometry(m2);
          } else if ((o2 = _object_pattern.exec(i2)) !== null) {
            var g2 = (" " + o2[0].substr(1).trim()).substr(1);
            n2.startObject(g2);
          } else if (_material_use_pattern.test(i2))
            n2.object.startMaterial(i2.substring(7).trim(), n2.materialLibraries);
          else if (_material_library_pattern.test(i2))
            n2.materialLibraries.push(i2.substring(7).trim());
          else if (_map_use_pattern.test(i2))
            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          else if (a2 === "s") {
            o2 = i2.split(" "), 1 < o2.length ? (g2 = o2[1].trim().toLowerCase(), n2.object.smooth = g2 !== "0" && g2 !== "off") : n2.object.smooth = true;
            const L = n2.object.currentMaterial();
            L && (L.smooth = n2.object.smooth);
          } else
            i2 !== "\0" && console.warn('THREE.OBJLoader: Unexpected line: "' + i2 + '"');
      n2.finalize();
      const v2 = new Group();
      if (v2.materialLibraries = [].concat(n2.materialLibraries), !(n2.objects.length === 1 && n2.objects[0].geometry.vertices.length === 0) == true)
        for (let e3 = 0, t2 = n2.objects.length; e3 < t2; e3++) {
          var y = n2.objects[e3], _2 = y.geometry, b2 = y.materials, x2 = _2.type === "Line", w2 = _2.type === "Points";
          let r3 = false;
          if (_2.vertices.length !== 0) {
            const O = new BufferGeometry();
            O.setAttribute("position", new Float32BufferAttribute(_2.vertices, 3)), 0 < _2.normals.length && O.setAttribute("normal", new Float32BufferAttribute(_2.normals, 3)), 0 < _2.colors.length && (r3 = true, O.setAttribute("color", new Float32BufferAttribute(_2.colors, 3))), _2.hasUVIndices === true && O.setAttribute("uv", new Float32BufferAttribute(_2.uvs, 2));
            const P2 = [];
            for (let t3 = 0, e5 = b2.length; t3 < e5; t3++) {
              var S2 = b2[t3], M2 = S2.name + "_" + S2.smooth + "_" + r3;
              let e6 = n2.materials[M2];
              if (this.materials !== null)
                if (e6 = this.materials.create(S2.name), !x2 || !e6 || e6 instanceof LineBasicMaterial) {
                  if (w2 && e6 && !(e6 instanceof PointsMaterial)) {
                    const I2 = new PointsMaterial({ size: 10, sizeAttenuation: false });
                    Material.prototype.copy.call(I2, e6), I2.color.copy(e6.color), I2.map = e6.map, e6 = I2;
                  }
                } else {
                  const D = new LineBasicMaterial();
                  Material.prototype.copy.call(D, e6), D.color.copy(e6.color), e6 = D;
                }
              e6 === void 0 && (e6 = x2 ? new LineBasicMaterial() : w2 ? new PointsMaterial({ size: 1, sizeAttenuation: false }) : new MeshPhongMaterial(), e6.name = S2.name, e6.flatShading = !S2.smooth, e6.vertexColors = r3, n2.materials[M2] = e6), P2.push(e6);
            }
            let e4;
            if (1 < P2.length) {
              for (let e5 = 0, t3 = b2.length; e5 < t3; e5++) {
                var E2 = b2[e5];
                O.addGroup(E2.groupStart, E2.groupCount, e5);
              }
              e4 = new (x2 ? LineSegments : w2 ? Points : Mesh)(O, P2);
            } else
              e4 = new (x2 ? LineSegments : w2 ? Points : Mesh)(O, P2[0]);
            e4.name = y.name, v2.add(e4);
          }
        }
      else if (0 < n2.vertices.length) {
        const t2 = new PointsMaterial({ size: 1, sizeAttenuation: false }), N2 = new BufferGeometry();
        N2.setAttribute("position", new Float32BufferAttribute(n2.vertices, 3)), 0 < n2.colors.length && n2.colors[0] !== void 0 && (N2.setAttribute("color", new Float32BufferAttribute(n2.colors, 3)), t2.vertexColors = true);
        e2 = new Points(N2, t2);
        v2.add(e2);
      }
      return v2;
    }
  }
  var __awaiter$7 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class CKBlob extends SLitComponent {
    constructor() {
      var e2;
      super({ litComponent: { shadowDom: false } }), this._grains = [], this._icons = [], this._iconsGroups = [], this._start = Date.now(), this._perlin = __perlin(), this._isDark = (e2 = document.body.getAttribute("class")) === null || e2 === void 0 ? void 0 : e2.toString().includes("-dark"), this._postprocessing = {};
    }
    firstUpdated() {
      return __awaiter$7(this, void 0, void 0, function* () {
        this._scene = new Scene(), this._camera = new PerspectiveCamera(30, this.offsetWidth / this.offsetHeight, 1, 1e4), this._camera.position.z = 50, this.ENTIRE_SCENE = 0, this.BLOOM_SCENE = 1, this._materialsByObj = {}, this._darkMaterial = new MeshBasicMaterial({ color: "black" });
        var e2 = this.offsetWidth || 1, t2 = this.offsetHeight || 1, r2 = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, alpha: true, antialias: true };
        this._renderTarget = new WebGLRenderTarget(e2, t2, r2), this._renderer = new WebGLRenderer(Object.assign({}, r2)), this._renderer.setSize(this.offsetWidth, this.offsetHeight), this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.setRenderTarget(this._renderTarget), this.querySelector(".ck-blob").appendChild(this._renderer.domElement), this._envMap = yield this.loadEnvMap();
        let n2;
        n2 = this._isDark ? new PointLight(16777215, 0.5) : new PointLight(16777215, 2), n2.position.set(8, 8, -10);
        const i2 = new DirectionalLight(16763927, 0.1, 100);
        i2.position.set(0, 40, 0);
        e2 = yield this.createSphere();
        yield this.addGrains();
        t2 = new PlaneGeometry(20, 20, 32, 32), r2 = new ShadowMaterial({ opacity: 0.1 });
        const a2 = new Mesh(t2, r2);
        a2.position.set(0, -12, 0), a2.rotation.x = Math.PI / 2 * -1, r2 = (this._isDark, new AmbientLight(16777215, 0.3)), new CameraHelper(i2.shadow.camera);
        const o2 = this.createPointsSphere(this._isDark ? 16777215 : 0, 0, 0.1);
        o2.scale.set(9, 9, 9), this._pointSpheres = [o2], this._isDark && this._scene.add(n2), this._scene.add(i2), this._scene.add(r2), this._scene.add(e2), this.initPostprocessing(), this.addControls(), setInterval(() => {
          this._scene.updateMatrixWorld(), this._grains.forEach((r3) => {
            if (r3.trail || (r3.trail = []), r3.trail.length >= r3.trailLength) {
              const i3 = r3.trail.shift();
              i3.geometry.dispose(), i3.material.dispose(), this._scene.remove(i3._light), this._scene.remove(i3);
            }
            r3.trail.forEach((e4, t4) => {
              t4 = 0.15 / r3.trailLength * t4;
              e4.scale.set(t4, t4, t4);
            });
            var e3 = new MeshStandardMaterial({ color: 4014142, emissive: 2434854, emissiveIntensity: 1 }), t3 = new SphereGeometry(1, 4, 4);
            const n3 = new Mesh(t3, e3);
            n3.scale.set(0.2, 0.2, 0.2), r3.trail.push(n3), n3.layers.toggle(this.BLOOM_SCENE), this._scene.add(n3), n3.position.copy(new Vector3().setFromMatrixPosition(r3.localGroup.matrixWorld));
          });
        }, 50), this.animate();
      });
    }
    initPostprocessing() {
      this._bloomLayer = new Layers(), this._bloomLayer.set(this.BLOOM_SCENE);
      const e2 = 1.5, t2 = 0, r2 = 0, n2 = new TransparentBackgroundFixedUnrealBloomPass(new Vector2(this.offsetWidth, this.offsetHeight), 1.5, 0.4, 0.85);
      n2.threshold = t2, n2.strength = e2, n2.radius = r2;
      var i2 = new RenderPass(this._scene, this._camera);
      const a2 = new EffectComposer(this._renderer);
      a2.renderToScreen = false, a2.addPass(i2), a2.addPass(n2);
      const o2 = new ShaderPass(new ShaderMaterial({ uniforms: { baseTexture: { value: null }, bloomTexture: { value: a2.renderTarget2.texture } }, vertexShader: `
                    varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
                `, fragmentShader: `
                uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}
            `, defines: {} }), "baseTexture");
      o2.needsSwap = true;
      const s2 = new EffectComposer(this._renderer);
      s2.addPass(i2), s2.addPass(o2), this._bloomComposer = a2, this._finalComposer = s2;
    }
    addControls() {
      this._controls = new OrbitControls_js.OrbitControls(this._camera, this._renderer.domElement), this._controls.autoRotate = true, this._controls.autoRotateSpeed = 4, this._controls.enableZoom = false, this._controls.update();
    }
    addGrains() {
      return __awaiter$7(this, void 0, void 0, function* () {
        const r2 = yield this.loadCoffeeGrain();
        this._grains = [];
        var n2 = [yield this.createGrainMaterial(SSugarConfig.get("serve.img.url") + "/3d/coffeeGrain/grain-yellow.jpg"), yield this.createGrainMaterial(SSugarConfig.get("serve.img.url") + "/3d/coffeeGrain/grain-purple.jpg")], i2 = [16431875, 16431875, 5308927];
        for (let e2 = 0; e2 < 12; e2++) {
          let t2 = n2[0], e3 = i2[0];
          0.5 < Math.random() && (t2 = n2[1], e3 = i2[1]);
          const s2 = r2.clone();
          s2.position.set(0, -0.6, -0.5), s2.rotation.x = Math.PI / 2, s2.rotation.y = Math.PI, s2.scale.set(0.02, 0.02, 0.02);
          var a2 = 0.2 + Math.random() - 0.2;
          s2.traverse(function(e4) {
            e4 instanceof Mesh && (e4.material = t2);
          });
          const l2 = new Group();
          l2.scale.set(a2, a2, a2), l2.add(s2);
          const c2 = new Group();
          c2.add(l2);
          var o2 = 3e-3 + Math.random() / 100 / 2, o2 = { grain: s2, group: c2, scale: a2, speed: o2, color: e3, trailLength: 15 + Math.round(20 * Math.random()), localGroup: l2, trail: [] };
          c2.rotation.set(360 * Math.random(), 360 * Math.random(), 360 * Math.random()), l2.position.x = 7 + 4 * Math.random(), this._grains.push(o2), this._scene.add(c2);
        }
      });
    }
    createSphere() {
      return __awaiter$7(this, void 0, void 0, function* () {
        let e2, t2;
        t2 = (e2 = this._isDark ? yield this.loadTexture(SSugarConfig.get("serve.img.url") + "/3d/ck-texture.jpg") : yield this.loadTexture(SSugarConfig.get("serve.img.url") + "/3d/ck-texture-light.jpg"), { metalness: 0, roughness: 0.6, color: 16777215 });
        var r2 = Object.assign(Object.assign({}, t2), { map: e2, envMap: this._envMap.texture }), n2 = new MeshStandardMaterial(r2), r2 = new SphereGeometry(1, 64, 64);
        return this._sphere = new Mesh(r2, n2), this._sphere.scale.set(4, 4, 4), this._sphere;
      });
    }
    createIconSphere(i2) {
      return __awaiter$7(this, void 0, void 0, function* () {
        var e2 = { clearcoat: 0.1, clearcoatRoughness: 0, metalness: 0, roughness: 0.5, color: 16777215, map: yield this.loadTexture(i2), envMap: this._envMap.texture }, t2 = new MeshPhysicalMaterial(e2), e2 = new SphereGeometry(1, 32, 32);
        const r2 = new Mesh(e2, t2);
        t2 = 0.3 + 0.5 * Math.random();
        r2.scale.set(t2, t2, t2), r2.position.x = 6;
        const n2 = new Group();
        return n2.add(r2), this._icons.push(r2), this._iconsGroups.push(n2), n2;
      });
    }
    createPointsSphere(e2, t2 = 0, r2 = 1) {
      for (var n2 = this._sphere.geometry.attributes.position.count, i2 = new Float32Array(+n2), a2 = 0; a2 < n2; a2++)
        i2[a2] = t2 / (this._isDark ? 2 : 5) + Math.random() * r2 / (this._isDark ? 2 : 5);
      var o2 = new MeshBasicMaterial({ color: this._isDark ? 16777215 : 0 }), s2 = new SphereGeometry(1, 32, 32);
      const l2 = new Mesh(s2, o2);
      l2.geometry.setAttribute("alpha", new BufferAttribute(i2, 1));
      e2 = new ShaderMaterial({ uniforms: { color: { value: new Color(e2) } }, vertexShader: `attribute float alpha;
    varying float vAlpha;

    void main() {
      vAlpha = alpha;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      gl_PointSize = 2.0;
      gl_Position = projectionMatrix * mvPosition;
    }`, fragmentShader: `uniform vec3 color;
    varying float vAlpha;

    void main() {
      gl_FragColor = vec4( color, vAlpha );
    }`, transparent: true });
      const c2 = new Points(l2.geometry, e2);
      return c2._object = l2, c2;
    }
    loadTexture(e2) {
      return new Promise((t2) => {
        new TextureLoader().load(e2, (e3) => {
          t2(e3);
        });
      });
    }
    renderBloom(e2) {
      e2 === true ? (this._scene.traverse(this.darkenNonBloomed.bind(this)), this._bloomComposer.render(), this._scene.traverse(this.restoreMaterial.bind(this))) : (this._camera.layers.set(this.BLOOM_SCENE), this._bloomComposer.render(), this._camera.layers.set(this.ENTIRE_SCENE));
    }
    darkenNonBloomed(e2) {
      e2.isMesh && this._bloomLayer.test(e2.layers) === false && (this._materialsByObj[e2.uuid] = e2.material, e2.material = this._darkMaterial);
    }
    restoreMaterial(e2) {
      this._materialsByObj[e2.uuid] && (e2.material = this._materialsByObj[e2.uuid], delete this._materialsByObj[e2.uuid]);
    }
    createGrainMaterial(r2) {
      return new Promise((t2) => __awaiter$7(this, void 0, void 0, function* () {
        var e2 = yield this.loadTexture(r2), e2 = new MeshStandardMaterial({ metalness: 0, roughness: 1, color: 16777215, map: e2, envMap: this._envMap.texture });
        t2(e2);
      }));
    }
    loadCoffeeGrain() {
      return new Promise((t2) => {
        new OBJLoader().load(SSugarConfig.get("serve.img.url") + "/3d/coffeeGrain/coffeeGrain.obj", (e2) => {
          e2.scale.set(0.01, 0.01, 0.01), e2.position.set(0, 0, 0), t2(e2);
        });
      });
    }
    updateGeometryOf(e2, t2 = 0.6, r2 = 5e-4) {
      e2._object && (e2 = e2._object);
      for (var n2 = performance.now() * r2, i2 = e2.geometry.attributes.position.array, a2 = 0; a2 < i2.length; a2 += 3) {
        const o2 = new Vector3(i2[a2], i2[a2 + 1], i2[a2 + 2]);
        o2.normalize().multiplyScalar(1 + 0.3 * this._perlin.perlin3(o2.x * t2 + n2, o2.y * t2, o2.z * t2)), i2[a2] = o2.x, i2[a2 + 1] = o2.y, i2[a2 + 2] = o2.z;
      }
      e2.geometry.computeVertexNormals(), e2.geometry.normalsNeedUpdate = true, e2.geometry.verticesNeedUpdate = true;
    }
    loadEnvMap() {
      return new Promise((t2) => {
        let r2 = new PMREMGenerator(this._renderer);
        new RGBELoader().setPath(SSugarConfig.get("serve.img.url") + "/3d/").load("HDRI_STUDIO_vol2_030.hdr", function(e2) {
          e2 = r2.fromCubemap(e2);
          t2(e2);
        });
      });
    }
    animate() {
      var e2, t2;
      this.componentUtils.isInViewport() ? (this.updateGeometryOf(this._sphere, 1.4), this._sphere.rotation.y += 3e-3, this._grains.forEach((e3) => {
        e3.group.rotation.x += e3.speed, e3.group.rotation.y += e3.speed, e3.group.rotation.z += e3.speed, e3.localGroup.lastPositions || (e3.localGroup.lastPositions = []);
        var t3 = new Vector3(), r2 = new Vector3();
        10 < e3.localGroup.lastPositions.length && (e3.localGroup.getWorldPosition(r2), r2 = e3.localGroup.lastPositions.shift(), e3.localGroup.lookAt(r2.x, r2.y, r2.z)), e3.localGroup.getWorldPosition(t3), e3.localGroup.lastPositions.push(t3);
      }), requestAnimationFrame(this.animate.bind(this)), (t2 = (e2 = this._controls) === null || e2 === void 0 ? void 0 : e2.update) !== null && t2 !== void 0 && t2.call(e2), this.renderBloom(true), this._finalComposer.render()) : setTimeout(() => {
        this.animate();
      }, 100);
    }
    render() {
      return p`
            <div class="ck-blob">
                <canvas class="blob-perlin"></canvas>
            </div>
        `;
    }
  }
  function define$5(e2 = {}, t2 = "ck-blob") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, CKBlob);
  }
  var __awaiter$6 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  function getState() {
    var e2;
    return JSON.parse((e2 = window.localStorage.getItem("coffeekrakenio")) !== null && e2 !== void 0 ? e2 : "{}");
  }
  function setState(e2) {
    e2 = __deepMerge$7(getState(), e2);
    window.localStorage.setItem("coffeekrakenio", JSON.stringify(e2));
  }
  let _docmap, _docmapPromise;
  function loadDocmap() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (_docmap)
        return _docmap;
      if (_docmapPromise)
        return (yield _docmapPromise).data;
      const e2 = new SRequest({ url: "/docmap.json", method: "GET" });
      var t2 = e2.send();
      return _docmapPromise = t2, _docmap = (yield t2).data, _docmap;
    });
  }
  var __awaiter$5 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  }, _a, _b, _c, _d;
  class CKDiscover extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false } });
    }
    firstUpdated() {
      return __awaiter$5(this, void 0, void 0, function* () {
        this._docmap = yield loadDocmap(), this.grabItem();
      });
    }
    grabItem() {
      return __awaiter$5(this, void 0, void 0, function* () {
        this.item = void 0, this.requestUpdate(), yield wait$2();
        var e2 = filter$2(this._docmap.map, (e3, t3) => !!t3.platform && (t3.platform[0].name === this.props.platform && !!t3.example)), t2 = Object.keys(e2).length, r2 = Object.keys(e2), t2 = Math.floor(Math.random() * t2);
        this.item = e2[r2[t2]], this.requestUpdate();
      });
    }
    render() {
      return p`
            <div class="ck-discover">
                ${this.item ? p`
                          <h1 class="s-typo:h3 s-mbe:30">
                              ${this.item.async ? p`
                                        <span
                                            class="s-badge:outline s-color:accent"
                                            >Async</span
                                        >&nbsp;
                                    ` : ""}
                              ${this.item.name}
                              <a
                                  @click="${this.grabItem}"
                                  class="s-btn s-radius:100 s-align:abs-top-right s-color:accent s-float:right"
                              >
                                  <i class="s-icon:refresh"></i>
                              </a>
                          </h1>
                          <p class="s-typo:p s-mbe:30">
                              ${this.item.description}
                          </p>
                          <s-code-example>
                              <textarea
                                  lang="${this.props.platform === "ts" || this.props.platform === "node" ? "js" : this.props.platform}"
                              >
                                ${this.item.example[0].code}
                              </textarea
                              >
                          </s-code-example>
                          <div
                              class="s-until:sibling:mounted s-code-example-loader"
                          >
                              <i class="s-loader:spinner s-color:accent"></i>
                              &nbsp;
                              <p class="s-typo:p s-display:inline-block">
                                  Loading code example. Please wait...
                              </p>
                          </div>
                      ` : p`<div class="s-code-example-loader">
                          <i class="s-loader:spinner s-color:accent"></i>
                          &nbsp;
                          <p class="s-typo:p s-display:inline-block">
                              Loading code example. Please wait...
                          </p>
                      </div>`}
            </div>
        `;
    }
  }
  function define$4(e2 = {}, t2 = "ck-discover") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, CKDiscover);
  }
  let issueWarning;
  (_a = globalThis.litIssuedWarnings) !== null && _a !== void 0 || (globalThis.litIssuedWarnings = new Set()), issueWarning = (e2, t2) => {
    t2 += e2 ? ` See https://lit.dev/msg/${e2} for more information.` : "", globalThis.litIssuedWarnings.has(t2) || (console.warn(t2), globalThis.litIssuedWarnings.add(t2));
  }, issueWarning("dev-mode", "Lit is in dev mode. Not recommended for production!");
  const wrap = (_b = window.ShadyDOM) !== null && _b !== void 0 && _b.inUse && ((_c = window.ShadyDOM) === null || _c === void 0 ? void 0 : _c.noPatch) === true ? window.ShadyDOM.wrap : (e2) => e2, trustedTypes = globalThis.trustedTypes, policy = trustedTypes ? trustedTypes.createPolicy("lit-html", { createHTML: (e2) => e2 }) : void 0, identityFunction = (e2) => e2, noopSanitizer = (e2, t2, r2) => identityFunction, createSanitizer = (e2, t2, r2) => sanitizerFactoryInternal(), boundAttributeSuffix = "$lit$", marker = `lit$${String(Math.random()).slice(9)}$`, markerMatch = "?" + marker, nodeMarker = `<${markerMatch}>`, d = document, createMarker = (e2 = "") => d.createComment(e2), isPrimitive = (e2) => e2 === null || typeof e2 != "object" && typeof e2 != "function", isArray = Array.isArray, isIterable = (e2) => {
    return isArray(e2) || typeof (e2 === null || e2 === void 0 ? void 0 : e2[Symbol.iterator]) == "function";
  }, SPACE_CHAR = `[ 	
\f\r]`, ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`, NAME_CHAR = `[^\\s"'>=/]`, textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, COMMENT_START = 1, TAG_NAME = 2, DYNAMIC_TAG_NAME = 3, commentEndRegex = /-->/g, comment2EndRegex = />/g, tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g"), ENTIRE_MATCH = 0, ATTRIBUTE_NAME = 1, SPACES_AND_EQUALS = 2, QUOTE_CHAR = 3, singleQuoteAttrEndRegex = /'/g, doubleQuoteAttrEndRegex = /"/g, rawTextElement = /^(?:script|style|textarea)$/i, SVG_RESULT = 2, ATTRIBUTE_PART = 1, CHILD_PART = 2, PROPERTY_PART = 3, BOOLEAN_ATTRIBUTE_PART = 4, EVENT_PART = 5, ELEMENT_PART = 6, COMMENT_PART = 7, noChange = Symbol.for("lit-noChange"), nothing = Symbol.for("lit-nothing"), templateCache = new WeakMap(), walker = d.createTreeWalker(d, 129, null, false);
  let sanitizerFactoryInternal = noopSanitizer;
  const getTemplateHtml = (i2, e2) => {
    var a2, t2 = i2.length - 1;
    const o2 = [];
    let s2 = e2 === SVG_RESULT ? "<svg>" : "", l2, c2 = textEndRegex;
    for (let n2 = 0; n2 < t2; n2++) {
      const h2 = i2[n2];
      let e3 = -1, t3, r2 = 0;
      for (; r2 < h2.length && (c2.lastIndex = r2, (a2 = c2.exec(h2)) !== null); )
        if (r2 = c2.lastIndex, c2 === textEndRegex) {
          if (a2[COMMENT_START] === "!--")
            c2 = commentEndRegex;
          else if (a2[COMMENT_START] !== void 0)
            c2 = comment2EndRegex;
          else if (a2[TAG_NAME] !== void 0)
            rawTextElement.test(a2[TAG_NAME]) && (l2 = new RegExp("</" + a2[TAG_NAME], "g")), c2 = tagEndRegex;
          else if (a2[DYNAMIC_TAG_NAME] !== void 0)
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
        } else
          c2 === tagEndRegex ? a2[ENTIRE_MATCH] === ">" ? (c2 = l2 !== null && l2 !== void 0 ? l2 : textEndRegex, e3 = -1) : a2[ATTRIBUTE_NAME] === void 0 ? e3 = -2 : (e3 = c2.lastIndex - a2[SPACES_AND_EQUALS].length, t3 = a2[ATTRIBUTE_NAME], c2 = a2[QUOTE_CHAR] === void 0 ? tagEndRegex : a2[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex) : c2 === doubleQuoteAttrEndRegex || c2 === singleQuoteAttrEndRegex ? c2 = tagEndRegex : c2 === commentEndRegex || c2 === comment2EndRegex ? c2 = textEndRegex : (c2 = tagEndRegex, l2 = void 0);
      console.assert(e3 === -1 || c2 === tagEndRegex || c2 === singleQuoteAttrEndRegex || c2 === doubleQuoteAttrEndRegex, "unexpected parse state B");
      var u2 = c2 === tagEndRegex && i2[n2 + 1].startsWith("/>") ? " " : "";
      s2 += c2 === textEndRegex ? h2 + nodeMarker : 0 <= e3 ? (o2.push(t3), h2.slice(0, e3) + boundAttributeSuffix + h2.slice(e3) + marker + u2) : h2 + marker + (e3 === -2 ? (o2.push(void 0), n2) : u2);
    }
    e2 = s2 + (i2[t2] || "<?>") + (e2 === SVG_RESULT ? "</svg>" : "");
    return [policy !== void 0 ? policy.createHTML(e2) : e2, o2];
  };
  class Template {
    constructor({ strings: e2, _$litType$: t2 }, r2) {
      this.parts = [];
      let n2, i2 = 0, a2 = 0;
      var o2 = e2.length - 1;
      const s2 = this.parts;
      var [e2, l2] = getTemplateHtml(e2, t2);
      if (this.el = Template.createElement(e2, r2), walker.currentNode = this.el.content, t2 === SVG_RESULT) {
        const f2 = this.el.content, m2 = f2.firstChild;
        m2.remove(), f2.append(...m2.childNodes);
      }
      for (; (n2 = walker.nextNode()) !== null && s2.length < o2; ) {
        if (n2.nodeType === 1) {
          var c2 = n2.localName;
          if (/^(?:textarea|template)$/i.test(c2) && n2.innerHTML.includes(marker)) {
            var u2 = `Expressions are not supported inside \`${c2}\` elements. See https://lit.dev/msg/expression-in-${c2} for more information.`;
            if (c2 === "template")
              throw new Error(u2);
            issueWarning("", u2);
          }
          if (n2.hasAttributes()) {
            const g2 = [];
            for (const v2 of n2.getAttributeNames())
              if (v2.endsWith(boundAttributeSuffix) || v2.startsWith(marker)) {
                const y = l2[a2++];
                if (g2.push(v2), y !== void 0) {
                  const _2 = n2.getAttribute(y.toLowerCase() + boundAttributeSuffix);
                  var h2 = _2.split(marker), d2 = /([.?@])?(.*)/.exec(y);
                  s2.push({ type: ATTRIBUTE_PART, index: i2, name: d2[2], strings: h2, ctor: d2[1] === "." ? PropertyPart : d2[1] === "?" ? BooleanAttributePart : d2[1] === "@" ? EventPart : AttributePart });
                } else
                  s2.push({ type: ELEMENT_PART, index: i2 });
              }
            for (const b2 of g2)
              n2.removeAttribute(b2);
          }
          if (rawTextElement.test(n2.tagName)) {
            const x2 = n2.textContent.split(marker);
            var p2 = x2.length - 1;
            if (0 < p2) {
              n2.textContent = trustedTypes ? trustedTypes.emptyScript : "";
              for (let e3 = 0; e3 < p2; e3++)
                n2.append(x2[e3], createMarker()), walker.nextNode(), s2.push({ type: CHILD_PART, index: ++i2 });
              n2.append(x2[p2], createMarker());
            }
          }
        } else if (n2.nodeType === 8)
          if (n2.data === markerMatch)
            s2.push({ type: CHILD_PART, index: i2 });
          else {
            let e3 = -1;
            for (; (e3 = n2.data.indexOf(marker, e3 + 1)) !== -1; )
              s2.push({ type: COMMENT_PART, index: i2 }), e3 += marker.length - 1;
          }
        i2++;
      }
    }
    static createElement(e2, t2) {
      const r2 = d.createElement("template");
      return r2.innerHTML = e2, r2;
    }
  }
  function resolveDirective(e2, t2, r2 = e2, n2) {
    var i2;
    if (t2 === noChange)
      return t2;
    let a2 = n2 !== void 0 ? (i2 = r2.__directives) === null || i2 === void 0 ? void 0 : i2[n2] : r2.__directive;
    const o2 = isPrimitive(t2) ? void 0 : t2._$litDirective$;
    return (a2 === null || a2 === void 0 ? void 0 : a2.constructor) !== o2 && ((i2 = a2 === null || a2 === void 0 ? void 0 : a2._$notifyDirectiveConnectionChanged) !== null && i2 !== void 0 && i2.call(a2, false), o2 === void 0 ? a2 = void 0 : (a2 = new o2(e2), a2._$initialize(e2, r2, n2)), n2 !== void 0 ? ((i2 = r2.__directives) !== null && i2 !== void 0 ? i2 : r2.__directives = [])[n2] = a2 : r2.__directive = a2), t2 = a2 !== void 0 ? resolveDirective(e2, a2._$resolve(e2, t2.values), a2, n2) : t2;
  }
  class TemplateInstance {
    constructor(e2, t2) {
      this._parts = [], this._$disconnectableChildren = void 0, this._$template = e2, this._$parent = t2;
    }
    get parentNode() {
      return this._$parent.parentNode;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(t2) {
      var e2, { el: { content: r2 }, parts: n2 } = this._$template, r2 = ((e2 = t2 == null ? void 0 : t2.creationScope) !== null && e2 !== void 0 ? e2 : d).importNode(r2, true);
      walker.currentNode = r2;
      let i2 = walker.nextNode(), a2 = 0, o2 = 0, s2 = n2[0];
      for (; s2 !== void 0; ) {
        if (a2 === s2.index) {
          let e3;
          s2.type === CHILD_PART ? e3 = new ChildPart(i2, i2.nextSibling, this, t2) : s2.type === ATTRIBUTE_PART ? e3 = new s2.ctor(i2, s2.name, s2.strings, this, t2) : s2.type === ELEMENT_PART && (e3 = new ElementPart(i2, this, t2)), this._parts.push(e3), s2 = n2[++o2];
        }
        a2 !== (s2 === null || s2 === void 0 ? void 0 : s2.index) && (i2 = walker.nextNode(), a2++);
      }
      return r2;
    }
    _update(e2) {
      let t2 = 0;
      for (const r2 of this._parts)
        r2 !== void 0 && (r2.strings !== void 0 ? (r2._$setValue(e2, r2, t2), t2 += r2.strings.length - 2) : r2._$setValue(e2[t2])), t2++;
    }
  }
  class ChildPart {
    constructor(e2, t2, r2, n2) {
      this.type = CHILD_PART, this._$committedValue = nothing, this._$disconnectableChildren = void 0, this._$startNode = e2, this._$endNode = t2, this._$parent = r2, this.options = n2, this.__isConnected = (n2 = n2 == null ? void 0 : n2.isConnected) === null || n2 === void 0 || n2, this._textSanitizer = void 0;
    }
    get _$isConnected() {
      var e2;
      return (e2 = (e2 = this._$parent) === null || e2 === void 0 ? void 0 : e2._$isConnected) !== null && e2 !== void 0 ? e2 : this.__isConnected;
    }
    get parentNode() {
      let e2 = wrap(this._$startNode).parentNode;
      var t2 = this._$parent;
      return t2 !== void 0 && e2.nodeType === 11 && (e2 = t2.parentNode), e2;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(e2, t2 = this) {
      if (this.parentNode === null)
        throw new Error("This `ChildPart` has no `parentNode` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's `innerHTML` or `textContent` can do this.");
      e2 = resolveDirective(this, e2, t2), isPrimitive(e2) ? e2 === nothing || e2 == null || e2 === "" ? (this._$committedValue !== nothing && this._$clear(), this._$committedValue = nothing) : e2 !== this._$committedValue && e2 !== noChange && this._commitText(e2) : e2._$litType$ !== void 0 ? this._commitTemplateResult(e2) : e2.nodeType !== void 0 ? this._commitNode(e2) : isIterable(e2) ? this._commitIterable(e2) : this._commitText(e2);
    }
    _insert(e2, t2 = this._$endNode) {
      return wrap(wrap(this._$startNode).parentNode).insertBefore(e2, t2);
    }
    _commitNode(e2) {
      if (this._$committedValue !== e2) {
        if (this._$clear(), sanitizerFactoryInternal !== noopSanitizer) {
          var t2 = (t2 = this._$startNode.parentNode) === null || t2 === void 0 ? void 0 : t2.nodeName;
          if (t2 === "STYLE" || t2 === "SCRIPT") {
            let e3 = "Forbidden";
            throw e3 = t2 === "STYLE" ? "Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css`...` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets." : "Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.", new Error(e3);
          }
        }
        this._$committedValue = this._insert(e2);
      }
    }
    _commitText(e2) {
      if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
        const t2 = wrap(this._$startNode).nextSibling;
        this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer()), e2 = this._textSanitizer(e2), t2.data = e2;
      } else {
        const r2 = document.createTextNode("");
        this._commitNode(r2), this._textSanitizer === void 0 && (this._textSanitizer = createSanitizer()), e2 = this._textSanitizer(e2), r2.data = e2;
      }
      this._$committedValue = e2;
    }
    _commitTemplateResult(e2) {
      const { values: t2, _$litType$: r2 } = e2;
      var n2 = typeof r2 == "number" ? this._$getTemplate(e2) : (r2.el === void 0 && (r2.el = Template.createElement(r2.h, this.options)), r2);
      if (((e2 = this._$committedValue) === null || e2 === void 0 ? void 0 : e2._$template) === n2)
        this._$committedValue._update(t2);
      else {
        const i2 = new TemplateInstance(n2, this);
        n2 = i2._clone(this.options);
        i2._update(t2), this._commitNode(n2), this._$committedValue = i2;
      }
    }
    _$getTemplate(e2) {
      let t2 = templateCache.get(e2.strings);
      return t2 === void 0 && templateCache.set(e2.strings, t2 = new Template(e2)), t2;
    }
    _commitIterable(e2) {
      isArray(this._$committedValue) || (this._$committedValue = [], this._$clear());
      const t2 = this._$committedValue;
      let r2 = 0, n2;
      for (const i2 of e2)
        r2 === t2.length ? t2.push(n2 = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)) : n2 = t2[r2], n2._$setValue(i2), r2++;
      r2 < t2.length && (this._$clear(n2 && wrap(n2._$endNode).nextSibling, r2), t2.length = r2);
    }
    _$clear(e2 = wrap(this._$startNode).nextSibling, t2) {
      var r2;
      for ((r2 = this._$notifyConnectionChanged) !== null && r2 !== void 0 && r2.call(this, false, true, t2); e2 && e2 !== this._$endNode; ) {
        var n2 = wrap(e2).nextSibling;
        wrap(e2).remove(), e2 = n2;
      }
    }
    setConnected(e2) {
      var t2;
      if (this._$parent !== void 0)
        throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
      this.__isConnected = e2, (t2 = this._$notifyConnectionChanged) !== null && t2 !== void 0 && t2.call(this, e2);
    }
  }
  class AttributePart {
    constructor(e2, t2, r2, n2, i2) {
      this.type = ATTRIBUTE_PART, this._$committedValue = nothing, this._$disconnectableChildren = void 0, this.element = e2, this.name = t2, this._$parent = n2, this.options = i2, 2 < r2.length || r2[0] !== "" || r2[1] !== "" ? (this._$committedValue = new Array(r2.length - 1).fill(new String()), this.strings = r2) : this._$committedValue = nothing, this._sanitizer = void 0;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(r2, n2 = this, i2, e2) {
      var a2 = this.strings;
      let o2 = false;
      if (a2 === void 0)
        r2 = resolveDirective(this, r2, n2, 0), o2 = !isPrimitive(r2) || r2 !== this._$committedValue && r2 !== noChange, o2 && (this._$committedValue = r2);
      else {
        var s2 = r2;
        r2 = a2[0];
        let e3, t2;
        for (e3 = 0; e3 < a2.length - 1; e3++)
          t2 = resolveDirective(this, s2[i2 + e3], n2, e3), t2 === noChange && (t2 = this._$committedValue[e3]), o2 = o2 || (!isPrimitive(t2) || t2 !== this._$committedValue[e3]), t2 === nothing ? r2 = nothing : r2 !== nothing && (r2 += (t2 !== null && t2 !== void 0 ? t2 : "") + a2[e3 + 1]), this._$committedValue[e3] = t2;
      }
      o2 && !e2 && this._commitValue(r2);
    }
    _commitValue(e2) {
      e2 === nothing ? wrap(this.element).removeAttribute(this.name) : (this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal(this.element, this.name)), e2 = this._sanitizer(e2 != null ? e2 : ""), wrap(this.element).setAttribute(this.name, e2 != null ? e2 : ""));
    }
  }
  class PropertyPart extends AttributePart {
    constructor() {
      super(...arguments), this.type = PROPERTY_PART;
    }
    _commitValue(e2) {
      this._sanitizer === void 0 && (this._sanitizer = sanitizerFactoryInternal(this.element, this.name)), e2 = this._sanitizer(e2), this.element[this.name] = e2 === nothing ? void 0 : e2;
    }
  }
  class BooleanAttributePart extends AttributePart {
    constructor() {
      super(...arguments), this.type = BOOLEAN_ATTRIBUTE_PART;
    }
    _commitValue(e2) {
      e2 && e2 !== nothing ? wrap(this.element).setAttribute(this.name, "") : wrap(this.element).removeAttribute(this.name);
    }
  }
  class EventPart extends AttributePart {
    constructor(e2, t2, r2, n2, i2) {
      if (super(e2, t2, r2, n2, i2), this.type = EVENT_PART, this.strings !== void 0)
        throw new Error(`A \`<${e2.localName}>\` has a \`@${t2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
    _$setValue(e2, t2 = this) {
      var r2, n2;
      (e2 = (n2 = resolveDirective(this, e2, t2, 0)) !== null && n2 !== void 0 ? n2 : nothing) !== noChange && (r2 = this._$committedValue, t2 = e2 === nothing && r2 !== nothing || e2.capture !== r2.capture || e2.once !== r2.once || e2.passive !== r2.passive, n2 = e2 !== nothing && (r2 === nothing || t2), t2 && this.element.removeEventListener(this.name, this, r2), n2 && this.element.addEventListener(this.name, this, e2), this._$committedValue = e2);
    }
    handleEvent(e2) {
      var t2;
      typeof this._$committedValue == "function" ? this._$committedValue.call((t2 = (t2 = this.options) === null || t2 === void 0 ? void 0 : t2.host) !== null && t2 !== void 0 ? t2 : this.element, e2) : this._$committedValue.handleEvent(e2);
    }
  }
  class ElementPart {
    constructor(e2, t2, r2) {
      this.element = e2, this.type = ELEMENT_PART, this._$disconnectableChildren = void 0, this._$parent = t2, this.options = r2;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(e2) {
      resolveDirective(this, e2);
    }
  }
  const polyfillSupport = window.litHtmlPolyfillSupportDevMode;
  polyfillSupport !== null && polyfillSupport !== void 0 && polyfillSupport(Template, ChildPart), ((_d = globalThis.litHtmlVersions) !== null && _d !== void 0 ? _d : globalThis.litHtmlVersions = []).push("2.0.1"), 1 < globalThis.litHtmlVersions.length && issueWarning("multiple-versions", "Multiple versions of Lit loaded. Loading multiple versions is not recommended.");
  const PartType = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, directive = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
  class Directive {
    constructor(e2) {
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$initialize(e2, t2, r2) {
      this.__part = e2, this._$parent = t2, this.__attributeIndex = r2;
    }
    _$resolve(e2, t2) {
      return this.update(e2, t2);
    }
    update(e2, t2) {
      return this.render(...t2);
    }
  }
  const HTML_RESULT = 1;
  class UnsafeHTMLDirective extends Directive {
    constructor(e2) {
      if (super(e2), this._value = nothing, e2.type !== PartType.CHILD)
        throw new Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(e2) {
      if (e2 === nothing || e2 == null)
        return this._templateResult = void 0, this._value = e2;
      if (e2 === noChange)
        return e2;
      if (typeof e2 != "string")
        throw new Error(this.constructor.directiveName + "() called with a non-string value");
      if (e2 === this._value)
        return this._templateResult;
      const t2 = [this._value = e2];
      return t2.raw = t2, this._templateResult = { _$litType$: this.constructor.resultType, strings: t2, values: [] };
    }
  }
  UnsafeHTMLDirective.directiveName = "unsafeHTML", UnsafeHTMLDirective.resultType = HTML_RESULT;
  const unsafeHTML = directive(UnsafeHTMLDirective);
  class SHighlightJsComponentInterface extends SInterface {
    static get _definition() {
      return { items: { description: 'Specify an array of items to use in your filtrable list. Can be a JSON string, a function that take an object with the "value" property and must return an array of items to use', type: "String|Function" }, value: { description: "Specify the attribute in your items to use as a value. Can be also a function that will be called with an object containing the selected item and must return the string you want to use as value", type: "String", default: "value" }, label: { description: "Specify the attribute in your items to use as a label. Can be also a function that will be called with an object containing the selected item and must return the string you want to use as label", type: "String|Function", default: "value" }, emptyText: { description: 'Specify the text to use for the default "empty" (no result) state', type: "String", default: "No item to display" }, loadingText: { description: 'Specify the text to use for the default "loading" state', type: "String", default: "Loading please wait..." }, filtrable: { description: 'Specify all the properties of your "item" to use as source for the filtrable process', type: { type: "Array<String>", splitChars: [","] }, default: [] }, templates: { description: 'Specify either an object with properties like "item", "empty" and "loading", or a function returning the good template depending on tne "type" argument property', type: "Object|Function" }, closeTimeout: { description: "Specify the duration before closing the list when having selected an item", type: "Number", default: 100 }, interactive: { description: "Specify if your items in the list are interactive or not to let the user click and interact with them", type: "Boolean", default: false }, notSelectable: { description: "Specify if you want the items to be not selectable", type: "Boolean", default: false }, maxItems: { description: "Specify the maximum number of items to display at first in the list", type: "Number", default: 25 } };
    }
  }
  function plainObject(e2) {
    return e2 && (typeof e2 == "object" && ((!e2.constructor || e2.constructor.name === "Object") && (Object.prototype.toString.call(e2) === "[object Object]" && e2 === Object(e2))));
  }
  function __deepMerge(...t2) {
    let r2 = {};
    for (let e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2];
      r2 = function r3(n3, i2) {
        const a2 = {};
        if (!n3 && i2)
          return i2;
        if (!i2 && n3)
          return n3;
        if (!n3 && !i2)
          return {};
        const e3 = Object.getOwnPropertyNames(n3);
        e3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(n3, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : a2[e4] = n3[e4];
        });
        const t3 = Object.getOwnPropertyNames(i2);
        return t3.forEach((e4) => {
          var t4 = Object.getOwnPropertyDescriptor(i2, e4);
          t4.set || t4.get ? Object.defineProperty(a2, e4, t4) : plainObject(a2[e4]) && plainObject(i2[e4]) ? a2[e4] = r3(a2[e4], i2[e4]) : a2[e4] = i2[e4];
        }), a2;
      }(r2, n2);
    }
    return r2;
  }
  function clone(e2, t2 = {}) {
    return ((t2 = Object.assign({ deep: false }, t2)).deep ? __deepClone : __clone)(e2);
  }
  function scrollTop() {
    return window.pageYOffset || document.scrollTop || document.body.scrollTop;
  }
  function offset(e2) {
    var t2 = e2.getBoundingClientRect(), r2 = document.body, n2 = document.documentElement, i2 = window.pageYOffset || n2.scrollTop || r2.scrollTop, a2 = window.pageXOffset || n2.scrollLeft || r2.scrollLeft, e2 = n2.clientTop || r2.clientTop || 0, r2 = n2.clientLeft || r2.clientLeft || 0, e2 = t2.top + i2 - e2, r2 = t2.left + a2 - r2;
    return { top: Math.round(e2), left: Math.round(r2) };
  }
  function fromElementTopToViewportBottom(e2) {
    var t2 = offset(e2), e2 = scrollTop();
    return window.innerHeight - t2.top + e2;
  }
  function camelize(e2) {
    let t2 = "";
    return t2 = e2.replace(/(?:^|[_-\s])(\w)/g, function(e3, t3) {
      return t3 ? t3.toUpperCase() : "";
    }), t2 = t2.substr(0, 1).toLowerCase() + t2.slice(1), t2.trim();
  }
  function autoCast(string) {
    if (typeof string != "string")
      return string;
    if (string.substr(0, 1) === "'" && string.substr(-1) === "'")
      return string.substr(1, string.length - 2);
    const presumedNumber = parseFloat(string);
    if (!isNaN(presumedNumber) && presumedNumber.toString() === string)
      return presumedNumber;
    if (window[string])
      return string;
    try {
      const obj = eval(`(${string})`);
      return obj;
    } catch (e2) {
      return string;
    }
  }
  function getStyleProperty(e2, t2) {
    setTimeout(() => {
      e2._sComputedStyle = null;
    });
    var r2 = e2._sComputedStyle || window.getComputedStyle(e2);
    e2._sComputedStyle = r2;
    var n2 = ["", "webkit-", "moz-", "ms-", "o-", "khtml-"];
    for (let e3 = 0; e3 < n2.length; e3++) {
      const i2 = r2[camelize("" + n2[e3] + t2)];
      if (i2 && i2.trim() !== "")
        return autoCast(i2);
    }
    return null;
  }
  function fromElementTopToViewportTop(e2) {
    var t2 = offset(e2), e2 = scrollTop();
    return t2.top - e2;
  }
  var isff = typeof navigator != "undefined" && 0 < navigator.userAgent.toLowerCase().indexOf("firefox");
  function addEvent(e2, t2, r2) {
    e2.addEventListener ? e2.addEventListener(t2, r2, false) : e2.attachEvent && e2.attachEvent("on".concat(t2), function() {
      r2(window.event);
    });
  }
  function getMods(e2, t2) {
    for (var r2 = t2.slice(0, t2.length - 1), n2 = 0; n2 < r2.length; n2++)
      r2[n2] = e2[r2[n2].toLowerCase()];
    return r2;
  }
  function getKeys(e2) {
    for (var t2 = (e2 = (e2 = typeof e2 != "string" ? "" : e2).replace(/\s/g, "")).split(","), r2 = t2.lastIndexOf(""); 0 <= r2; )
      t2[r2 - 1] += ",", t2.splice(r2, 1), r2 = t2.lastIndexOf("");
    return t2;
  }
  function compareArray(e2, t2) {
    for (var r2 = e2.length >= t2.length ? e2 : t2, n2 = e2.length >= t2.length ? t2 : e2, i2 = true, a2 = 0; a2 < r2.length; a2++)
      n2.indexOf(r2[a2]) === -1 && (i2 = false);
    return i2;
  }
  for (var _keyMap = { backspace: 8, tab: 9, clear: 12, enter: 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, "\u21EA": 20, ",": 188, ".": 190, "/": 191, "`": 192, "-": isff ? 173 : 189, "=": isff ? 61 : 187, ";": isff ? 59 : 186, "'": 222, "[": 219, "]": 221, "\\": 220 }, _modifier = { "\u21E7": 16, shift: 16, "\u2325": 18, alt: 18, option: 18, "\u2303": 17, ctrl: 17, control: 17, "\u2318": 91, cmd: 91, command: 91 }, modifierMap = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, _mods = { 16: false, 18: false, 17: false, 91: false }, _handlers = {}, k = 1; k < 20; k++)
    _keyMap["f".concat(k)] = 111 + k;
  var _downKeys = [], _scope = "all", elementHasBindEvent = [], code = function(e2) {
    return _keyMap[e2.toLowerCase()] || _modifier[e2.toLowerCase()] || e2.toUpperCase().charCodeAt(0);
  };
  function setScope(e2) {
    _scope = e2 || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function filter(e2) {
    var t2 = e2.target || e2.srcElement, r2 = t2.tagName, e2 = true;
    return e2 = t2.isContentEditable || !(r2 !== "INPUT" && r2 !== "TEXTAREA" && r2 !== "SELECT" || t2.readOnly) ? false : e2;
  }
  function isPressed(e2) {
    return typeof e2 == "string" && (e2 = code(e2)), _downKeys.indexOf(e2) !== -1;
  }
  function deleteScope(e2, t2) {
    var r2, n2, i2;
    for (i2 in e2 = e2 || getScope(), _handlers)
      if (Object.prototype.hasOwnProperty.call(_handlers, i2))
        for (r2 = _handlers[i2], n2 = 0; n2 < r2.length; )
          r2[n2].scope === e2 ? r2.splice(n2, 1) : n2++;
    getScope() === e2 && setScope(t2 || "all");
  }
  function clearModifier(e2) {
    var t2 = e2.keyCode || e2.which || e2.charCode, r2 = _downKeys.indexOf(t2);
    if (0 <= r2 && _downKeys.splice(r2, 1), e2.key && e2.key.toLowerCase() === "meta" && _downKeys.splice(0, _downKeys.length), (t2 = t2 === 93 || t2 === 224 ? 91 : t2) in _mods)
      for (var n2 in _mods[t2] = false, _modifier)
        _modifier[n2] === t2 && (hotkeys[n2] = false);
  }
  function unbind(e2) {
    if (e2) {
      if (Array.isArray(e2))
        e2.forEach(function(e3) {
          e3.key && eachUnbind(e3);
        });
      else if (typeof e2 == "object")
        e2.key && eachUnbind(e2);
      else if (typeof e2 == "string") {
        for (var t2 = arguments.length, r2 = new Array(1 < t2 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
          r2[n2 - 1] = arguments[n2];
        var i2 = r2[0], a2 = r2[1];
        typeof i2 == "function" && (a2 = i2, i2 = ""), eachUnbind({ key: e2, scope: i2, method: a2, splitKey: "+" });
      }
    } else
      Object.keys(_handlers).forEach(function(e3) {
        return delete _handlers[e3];
      });
  }
  var eachUnbind = function(e2) {
    var t2 = e2.key, i2 = e2.scope, a2 = e2.method, e2 = e2.splitKey, o2 = e2 === void 0 ? "+" : e2;
    getKeys(t2).forEach(function(e3) {
      var t3, r2 = e3.split(o2), n2 = r2.length, e3 = r2[n2 - 1], e3 = e3 === "*" ? "*" : code(e3);
      _handlers[e3] && (i2 = i2 || getScope(), t3 = 1 < n2 ? getMods(_modifier, r2) : [], _handlers[e3] = _handlers[e3].map(function(e4) {
        return a2 && e4.method !== a2 || e4.scope !== i2 || !compareArray(e4.mods, t3) ? e4 : {};
      }));
    });
  };
  function eventHandler(e2, t2, r2) {
    var n2;
    if (t2.scope === r2 || t2.scope === "all") {
      for (var i2 in n2 = 0 < t2.mods.length, _mods)
        Object.prototype.hasOwnProperty.call(_mods, i2) && (!_mods[i2] && -1 < t2.mods.indexOf(+i2) || _mods[i2] && t2.mods.indexOf(+i2) === -1) && (n2 = false);
      (t2.mods.length !== 0 || _mods[16] || _mods[18] || _mods[17] || _mods[91]) && !n2 && t2.shortcut !== "*" || t2.method(e2, t2) === false && (e2.preventDefault ? e2.preventDefault() : e2.returnValue = false, e2.stopPropagation && e2.stopPropagation(), e2.cancelBubble && (e2.cancelBubble = true));
    }
  }
  function dispatch(r2) {
    var e2 = _handlers["*"], t2 = r2.keyCode || r2.which || r2.charCode;
    if (hotkeys.filter.call(this, r2)) {
      if (_downKeys.indexOf(t2 = t2 === 93 || t2 === 224 ? 91 : t2) === -1 && t2 !== 229 && _downKeys.push(t2), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(e3) {
        var t3 = modifierMap[e3];
        r2[e3] && _downKeys.indexOf(t3) === -1 ? _downKeys.push(t3) : !r2[e3] && -1 < _downKeys.indexOf(t3) ? _downKeys.splice(_downKeys.indexOf(t3), 1) : e3 === "metaKey" && r2[e3] && _downKeys.length === 3 && (r2.ctrlKey || r2.shiftKey || r2.altKey || (_downKeys = _downKeys.slice(_downKeys.indexOf(t3))));
      }), t2 in _mods) {
        for (var n2 in _mods[t2] = true, _modifier)
          _modifier[n2] === t2 && (hotkeys[n2] = true);
        if (!e2)
          return;
      }
      for (var i2 in _mods)
        Object.prototype.hasOwnProperty.call(_mods, i2) && (_mods[i2] = r2[modifierMap[i2]]);
      r2.getModifierState && (!r2.altKey || r2.ctrlKey) && r2.getModifierState("AltGraph") && (_downKeys.indexOf(17) === -1 && _downKeys.push(17), _downKeys.indexOf(18) === -1 && _downKeys.push(18), _mods[17] = true, _mods[18] = true);
      var a2 = getScope();
      if (e2)
        for (var o2 = 0; o2 < e2.length; o2++)
          e2[o2].scope === a2 && (r2.type === "keydown" && e2[o2].keydown || r2.type === "keyup" && e2[o2].keyup) && eventHandler(r2, e2[o2], a2);
      if (t2 in _handlers) {
        for (var s2 = 0; s2 < _handlers[t2].length; s2++)
          if ((r2.type === "keydown" && _handlers[t2][s2].keydown || r2.type === "keyup" && _handlers[t2][s2].keyup) && _handlers[t2][s2].key) {
            for (var l2 = _handlers[t2][s2], c2 = l2.splitKey, u2 = l2.key.split(c2), h2 = [], d2 = 0; d2 < u2.length; d2++)
              h2.push(code(u2[d2]));
            h2.sort().join("") === _downKeys.sort().join("") && eventHandler(r2, l2, a2);
          }
      }
    }
  }
  function isElementBind(e2) {
    return -1 < elementHasBindEvent.indexOf(e2);
  }
  function hotkeys(e2, t2, r2) {
    _downKeys = [];
    var n2 = getKeys(e2), i2 = [], a2 = "all", o2 = document, s2 = 0, l2 = false, c2 = true, u2 = "+";
    for (r2 === void 0 && typeof t2 == "function" && (r2 = t2), Object.prototype.toString.call(t2) === "[object Object]" && (t2.scope && (a2 = t2.scope), t2.element && (o2 = t2.element), t2.keyup && (l2 = t2.keyup), t2.keydown !== void 0 && (c2 = t2.keydown), typeof t2.splitKey == "string" && (u2 = t2.splitKey)), typeof t2 == "string" && (a2 = t2); s2 < n2.length; s2++)
      i2 = [], 1 < (e2 = n2[s2].split(u2)).length && (i2 = getMods(_modifier, e2)), (e2 = (e2 = e2[e2.length - 1]) === "*" ? "*" : code(e2)) in _handlers || (_handlers[e2] = []), _handlers[e2].push({ keyup: l2, keydown: c2, scope: a2, mods: i2, shortcut: n2[s2], method: r2, key: n2[s2], splitKey: u2 });
    o2 !== void 0 && !isElementBind(o2) && window && (elementHasBindEvent.push(o2), addEvent(o2, "keydown", function(e3) {
      dispatch(e3);
    }), addEvent(window, "focus", function() {
      _downKeys = [];
    }), addEvent(o2, "keyup", function(e3) {
      dispatch(e3), clearModifier(e3);
    }));
  }
  var _api = { setScope, getScope, deleteScope, getPressedKeyCodes, isPressed, filter, unbind }, a, _hotkeys;
  for (a in _api)
    Object.prototype.hasOwnProperty.call(_api, a) && (hotkeys[a] = _api[a]);
  typeof window != "undefined" && (_hotkeys = window.hotkeys, hotkeys.noConflict = function(e2) {
    return e2 && window.hotkeys === hotkeys && (window.hotkeys = _hotkeys), hotkeys;
  }, window.hotkeys = hotkeys);
  var hotkeys_common = hotkeys;
  function hotkey(e2, i2 = {}) {
    return new SPromise(({ emit: r2, cancel: n2 }) => {
      i2 = Object.assign({ element: null, keyup: false, keydown: true, once: false, splitKey: "+" }, i2), hotkeys_common(e2, i2, (e3, t2) => {
        r2("press", e3), i2.once && n2();
      });
    }, { id: "hotkey" }).on("finally", () => {
      hotkeys_common.unbind(e2);
    });
  }
  function stripTags(e2) {
    const t2 = document.createElement("div");
    return t2.innerHTML = e2, t2.textContent || t2.innerText || "";
  }
  function onScrollEnd(i2, a2, e2) {
    const o2 = Object.assign({ offset: 20, once: false, times: -1 }, e2 != null ? e2 : {});
    let s2 = false, l2 = i2, c2 = i2;
    i2 === window.document.body ? (s2 = true, l2 = document, c2 = window.document.body) : i2 === window.document && (s2 = true, i2 = window.document.body, c2 = window.document.body);
    let u2 = true, h2 = 0;
    const d2 = (e3) => {
      let t2, r2, n2;
      t2 = s2 ? (r2 = window.innerHeight, n2 = c2.scrollTop, Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight)) : (r2 = c2.offsetHeight, n2 = c2.scrollTop, c2.scrollHeight), console.log("is", u2), console.log(i2, n2, r2, t2, o2.offset), console.log(n2 + r2, t2 - o2.offset), u2 && n2 + r2 >= t2 - o2.offset ? (a2(), h2++, (o2.once || 0 < o2.times && h2 >= o2.times) && (l2.removeEventListener("scroll", d2), u2 = false)) : c2.offsetHeight + c2.scrollTop < c2.scrollHeight - o2.offset && (u2 = true);
    };
    console.log(l2), l2.addEventListener("scroll", d2);
  }
  hotkeys_common.filter = function() {
    return true;
  };
  var __css = ".s-filtrable-input {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: inline-block;\n    position: relative;\n\n    /* @sugar.scope.lnf {\n        .s-filtrable-input__list {\n            transition: max-height 0.1s ease-in-out;\n        }\n\n        .s-filtrable-input__list-item-highlight {\n            background-color: sugar.color(current);\n        }\n    } */\n}\n\n    .s-filtrable-input .s-filtrable-input__input {\n    }\n\n    .s-filtrable-input .s-filtrable-input__list {\n        position: absolute;\n        top: 100%;\n        left: 0;\n        overflow-x: hidden;\n        overflow-y: auto;\n        opacity: 0;\n        max-width: calc(100vw - 100px);\n        pointer-events: none;\n        margin: 20px 0;\n    }\n\n    .s-filtrable-input:focus-within .s-filtrable-input__list {\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-filtrable-input.s-filtrable-input--top .s-filtrable-input__list {\n            top: auto;\n            bottom: 100%;\n        }\n\n    .s-filtrable-input .s-filtrable-input__input:focus + .s-filtrable-input__list,\n    .s-filtrable-input .s-filtrable-input__list:focus,\n    .s-filtrable-input .s-filtrable-input__list:focus-within {\n        opacity: 1;\n        pointer-events: all !important;\n    }\n\n    .s-filtrable-input .s-filtrable-input__list-item {\n        position: relative;\n        -webkit-user-select: none;\n           -moz-user-select: none;\n            -ms-user-select: none;\n                user-select: none;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item {\n        cursor: pointer;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item * {\n            pointer-events: none;\n        }\n", __awaiter$4 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SFiltrableInput extends SLitComponent {
    constructor() {
      var e2;
      super(__deepMerge({ litComponent: { shadowDom: false }, componentUtils: { interface: SHighlightJsComponentInterface } })), this.state = { baseTemplates: void 0, preselectedItem: void 0, preselectedItemIdx: -1, selectedItemIdx: -1, displayedMaxItems: 0, value: "", isActive: false, isLoading: false, items: [], filteredItems: [] }, this.state.displayedMaxItems = this.props.maxItems, !this.props.items || typeof this.props.items != "string" || (e2 = document.querySelector(this.props.items)) && (this.state.items = JSON.parse(e2.innerHTML), this.requestUpdate()), this.state.baseTemplates = ({ type: e3, item: t2, html: r2 }) => {
        switch (e3) {
          case "item":
            return r2`
                        <div class="${this.componentUtils.className("__item")}">
                            ${unsafeHTML(typeof this.props.label == "function" ? this.props.label({ item: t2 }) : t2[this.props.label])}
                        </div>
                    `;
          case "empty":
            return r2`
                        <div
                            class="${this.componentUtils.className("__empty")}"
                        >
                            ${this.props.emptyText}
                        </div>
                    `;
          case "loading":
            return r2`
                        <div
                            class="${this.componentUtils.className("__loading")}"
                        >
                            ${this.props.loadingText}
                        </div>
                    `;
        }
      };
    }
    static get styles() {
      return r$2`
            ${o$3(__css)}
        `;
    }
    firstUpdated() {
      var e2;
      return __awaiter$4(this, void 0, void 0, function* () {
        this.$input = this.querySelector("input"), this.$input.setAttribute("autocomplete", "off"), this.props.bare || (e2 = this.$input.classList) !== null && e2 !== void 0 && e2.add("s-input"), this.$input.addEventListener("keyup", (e3) => {
          e3 = e3.target.value;
          this.state.value = e3, this.state.displayedMaxItems = this.props.maxItems, this.filterItems();
        }), this.$input.classList.add(this.componentUtils.className("__input")), (this.$container = this).$container.classList.add("s-filtrable-input"), this.$container.classList.add(this.componentUtils.className()), this.$list = this.querySelector("ul"), this.prepend(this.$input), this.filterItems(), document.addEventListener("scroll", () => {
          this._updateListSizeAndPosition();
        }), this.$input.addEventListener("focus", (e3) => {
          this.state.isActive = true, this.filterItems(), this._updateListSizeAndPosition();
        }), this._updateListSizeAndPosition(), onScrollEnd(this.$list, () => {
          var e3;
          this.state.displayedMaxItems = ((e3 = this.state.displayedMaxItems) !== null && e3 !== void 0 ? e3 : 0) + this.props.maxItems, this.filterItems(false);
        }), hotkey("escape").on("press", (e3) => {
          e3.preventDefault(), this.state.isActive && this.close();
        }), hotkey("up").on("press", (e3) => {
          if (e3.preventDefault(), this.state.isActive) {
            this.state.preselectedItemIdx = 0 < this.state.preselectedItemIdx ? this.state.preselectedItemIdx - 1 : 0, this.requestUpdate();
            const t2 = this.$list.children[this.state.preselectedItemIdx];
            t2.focus();
          }
        }), hotkey("down").on("press", (e3) => {
          if (e3.preventDefault(), this.state.isActive) {
            this.state.preselectedItemIdx = this.state.preselectedItemIdx >= this.state.filteredItems.length - 1 ? this.state.filteredItems.length - 1 : this.state.preselectedItemIdx + 1, this.requestUpdate();
            const t2 = this.$list.children[this.state.preselectedItemIdx];
            t2.focus();
          }
        }), hotkey("return").on("press", (e3) => {
          this.state.isActive && this.validateAndClose();
        });
      });
    }
    get selectedItem() {
      if (this.state.selectedItemIdx !== -1)
        return this.state.filteredItems[this.state.selectedItemIdx];
    }
    get preselectedItem() {
      if (this.state.preselectedItemIdx !== -1)
        return this.state.filteredItems[this.state.preselectedItemIdx];
    }
    validate() {
      var e2;
      if (this.state.preselectedItem) {
        if (this.state.preselectedItem) {
          if (typeof this.props.value == "string" && (e2 = this.state.preselectedItem) !== null && e2 !== void 0 && e2[this.props.value])
            this.$input.value = stripTags(this.state.preselectedItem[this.props.value]);
          else if (typeof this.props.value == "function") {
            var t2 = this.props.value({ item: this.state.filteredItems[this.state.preselectedItemIdx] });
            if (typeof t2 != "string")
              throw new Error(`<red>[s-filtrable-input]</red> Sorry but the returned value "<yellow>${t2}</yellow>" has to be a string...`);
            this.$input.value = stripTags(t2);
          }
        }
        this.state.selectedItemIdx = this.state.preselectedItemIdx, this.state.value = this.$input.value, this.requestUpdate();
        t2 = new CustomEvent("select", { bubbles: true, detail: this.selectedItem });
        this.dispatchEvent(t2);
      }
    }
    validateAndClose() {
      this.validate(), setTimeout(() => {
        this.close();
      }, this.props.closeTimeout);
    }
    close() {
      this.$input.focus(), this.$input.blur(), this.state.isActive = false;
    }
    refreshItems() {
      return __awaiter$4(this, void 0, void 0, function* () {
        if (typeof this.props.items == "function") {
          this.state.isLoading = true, this.requestUpdate();
          var e2 = yield this.props.items({ value: this.$input.value });
          if (plainObject(e2))
            this.state.items = Object.values(e2);
          else {
            if (!Array.isArray(e2))
              throw new Error('Sorry but the "items" MUST be an Array...');
            this.state.items = e2;
          }
        }
      });
    }
    filterItems(r2 = true) {
      return __awaiter$4(this, void 0, void 0, function* () {
        r2 && (yield this.refreshItems());
        let e2 = this.state.items, o2 = 0;
        var t2 = e2.map((e3) => clone(e3)).filter((t3) => {
          if (o2 >= this.state.displayedMaxItems)
            return false;
          if (!this.props.filtrable.length)
            return true;
          let r3 = false;
          for (let e3 = 0; e3 < Object.keys(t3).length; e3++) {
            const i2 = Object.keys(t3)[e3], a2 = t3[i2];
            var n2;
            typeof a2 == "string" && this.props.filtrable.indexOf(i2) !== -1 && (n2 = new RegExp(this.state.value.split(" ").join("|"), "gi"), a2.match(n2) && (r3 = true, this.state.value && this.state.value !== "" && (n2 = new RegExp(this.state.value.split(" ").join("|"), "gi"), n2 = a2.replace(n2, (e4) => `<span class="${this.componentUtils.className("__list-item-highlight")} s-highlight"
                                                >${e4}</span>`), t3[i2] = n2)));
          }
          return r3 && o2++, r3;
        });
        this.state.filteredItems = t2, this.state.isLoading = false, this.requestUpdate();
      });
    }
    select(e2) {
      this._setPreselectedItemByIdx(e2);
    }
    selectAndValidate(e2) {
      this._setPreselectedItemByIdx(e2), this.validate();
    }
    selectValidateAndClose(e2) {
      this._setPreselectedItemByIdx(e2), this.validateAndClose();
    }
    _setPreselectedItemByIdx(e2) {
      this.props.notSelectable || (this.state.preselectedItemIdx = e2, this.state.preselectedItem = this.state.items[e2], this.requestUpdate());
    }
    _updateListSizeAndPosition() {
      if (this.state.isActive) {
        var t2 = getStyleProperty(this.$list, "marginTop");
        getStyleProperty(this.$list, "marginLeft"), getStyleProperty(this.$list, "marginRight");
        var r2 = getStyleProperty(this.$list, "marginBottom"), n2 = fromElementTopToViewportTop(this.$input), i2 = fromElementTopToViewportBottom(this.$input) - this.$input.clientHeight;
        let e2;
        e2 = i2 < n2 ? (this.$container.classList.add("s-filtrable-input--top"), this.$list.style.top = "auto", this.$list.style.bottom = `calc(100% - ${r2})`, n2 - parseInt(t2)) : (this.$container.classList.remove("s-filtrable-input--top"), this.$list.style.bottom = "auto", this.$list.style.top = `calc(100% - ${t2})`, i2 - parseInt(r2)), this.$list.style.maxHeight = e2 + "px";
      }
    }
    render() {
      var e2, t2;
      return p`
            <ul
                class="s-filtrable-input__list ${this.componentUtils.className("__list")}"
            >
                ${this.state.isLoading ? p`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-loading ${this.componentUtils.className("__list-item __list-loading")}"
                          >
                              ${(e2 = (e2 = (t2 = this.props).templates) === null || e2 === void 0 ? void 0 : e2.call(t2, { type: "loading", html: p })) !== null && e2 !== void 0 ? e2 : this.state.baseTemplates({ type: "loading", html: p })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length <= 0 ? p`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-no-item  ${this.componentUtils.className("__list-item __list-no-item")}"
                          >
                              ${(t2 = (e2 = (t2 = this.props).templates) === null || e2 === void 0 ? void 0 : e2.call(t2, { type: "empty", html: p })) !== null && t2 !== void 0 ? t2 : this.state.baseTemplates({ type: "empty", html: p })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length ? this.state.filteredItems.map((e3, t3) => {
        var r2, n2;
        return t3 < this.state.displayedMaxItems ? p`
                                    <li
                                        @click=${() => this.selectAndValidate(t3)}
                                        @dblclick=${() => this.selectValidateAndClose(t3)}
                                        @focus=${() => this._setPreselectedItemByIdx(t3)}
                                        style="z-index: ${999999999 - t3}"
                                        tabindex="0"
                                        class="s-filtrable-input__list-item ${this.componentUtils.className("__list-item") + " " + (this.state.selectedItemIdx === t3 ? "active" : "")}"
                                        hoverable
                                    >
                                        ${(n2 = (r2 = (n2 = this.props).templates) === null || r2 === void 0 ? void 0 : r2.call(n2, { type: "item", html: p, unsafeHTML, item: e3, idx: t3 })) !== null && n2 !== void 0 ? n2 : this.state.baseTemplates({ type: "item", html: p, unsafeHTML, item: e3, idx: t3 })}
                                    </li>
                                ` : "";
      }) : ""}
            </ul>
        `;
    }
  }
  function define$3(e2 = {}, t2 = "s-filtrable-input") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, SFiltrableInput);
  }
  var __awaiter$3 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  define$3({ value: "name", label: (e2) => e2.type + " " + e2.namespace, filtrable: ["namespace", "name", "type"], templates: ({ type: e2, item: t2, html: r2, unsafeHTML: n2 }) => {
    if (e2 === "item")
      return r2`
                    <div class="__item">
                        <div class="s-flex s-mbe:10">
                            <h4
                                class="__title s-typo:bold s-tc:accent s-flex-item:grow"
                            >
                                ${n2(t2.name)}
                            </h4>
                            <div>
                                ${t2.platform.map((e3) => r2`
                                        <i
                                            class="s-platform:${e3.name}"
                                        ></i>
                                    `)}
                                &nbsp;
                                <span class="s-badge s-color:main"
                                    >${n2((e2 = t2.type) !== null && e2 !== void 0 ? e2 : "")}</span
                                >
                            </div>
                        </div>
                        <p class="__namespace s-opacity:50 s-font:20 s-mbe:20">
                            ${n2((e2 = t2.namespace) !== null && e2 !== void 0 ? e2 : "")}
                        </p>
                        <p class="__description s-typo:p s-truncate:2">
                            ${n2((t2 = t2.description) !== null && t2 !== void 0 ? t2 : "")}
                        </p>
                    </div>
                `;
  }, items: ({}) => __awaiter$3(void 0, void 0, void 0, function* () {
    function e2() {
      return __awaiter$3(this, void 0, void 0, function* () {
        const e3 = new SRequest({ url: "/docmap.json" }), r2 = yield e3.send(), n2 = [];
        return Object.keys(r2.data.map).forEach((e4) => {
          const t3 = r2.data.map[e4];
          t3.fullNamespace = e4, n2.push(t3);
        }), window.localStorage.setItem("ck-search-items", JSON.stringify(n2)), n2;
      });
    }
    var t2 = window.localStorage.getItem("ck-search-items");
    return t2 ? (e2(), JSON.parse(t2)) : yield e2();
  }) }, "ck-search-input");
  class CKSearch extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false } });
    }
    firstUpdated() {
      this.addEventListener("select", (e2) => {
        var t2 = e2.detail;
        (e2 = t2.menu) !== null && e2 !== void 0 && e2.slug ? t2.package !== window.packageJson.name ? document.location.href = "" + t2.package + t2.menu.slug : document.location.href = t2.menu.slug : document.location.href = "/api/" + t2.fullNamespace;
      });
    }
    render() {
      return p`
            <div class="ck-search">
                <div class="__background"></div>
                <div class="__content s-color:accent">
                    <ck-search-input>
                        <input
                            placeholder="API search..."
                            type="text"
                            name="search"
                            class="s-input s-color:accent s-scale:11"
                        />
                    </ck-search-input>
                </div>
            </div>
        `;
    }
  }
  function define$2(e2 = {}, t2 = "ck-search") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, CKSearch);
  }
  function parseRgba(e2) {
    const t2 = (e2 = e2.toLowerCase()).replace("rgba(", "").replace("rgb(", "").replace(")", "").replace(/\s/g, "");
    e2 = t2.split(",");
    return { r: parseInt(e2[0]), g: parseInt(e2[1]), b: parseInt(e2[2]), a: e2[3] ? parseInt(e2[3]) : 1 };
  }
  function parseHsl(e2) {
    const t2 = (e2 = e2.toLowerCase()).replace("hsla(", "").replace("hsl(", "").replace(")", "").replace(/\s/g, "");
    e2 = t2.split(",");
    return { h: parseFloat(e2[0]), s: parseFloat(e2[1]), l: parseFloat(e2[2]), a: e2[3] ? parseFloat(e2[3]) : 1 };
  }
  function orRegex(e2, t2) {
    return t2 === void 0 && (t2 = "i"), new RegExp(e2.map(function(e3) {
      return e3.source;
    }).join("|"), t2);
  }
  var HEXADECIMAL = /^(([0-9a-f])+([.]([0-9a-f])+)?)$/i, HEX_SHORT_WITHOUT_ALPHA = /^#(?:([0-9a-f]{3}))$/i, HEX_SHORT_WITH_ALPHA = /^#(?:([0-9a-f]{3})([0-9a-f]{1}))$/i, HEX_SHORT = orRegex([HEX_SHORT_WITHOUT_ALPHA, HEX_SHORT_WITH_ALPHA]), HEX_LONG_WITHOUT_ALPHA = /^#(?:([0-9a-f]{6}))$/i, HEX_LONG_WITH_ALPHA = /^#(?:([0-9a-f]{6})([0-9a-f]{2}))$/i, HEX_LONG = orRegex([HEX_LONG_WITHOUT_ALPHA, HEX_LONG_WITH_ALPHA]), HEX_COLOR = orRegex([HEX_SHORT, HEX_LONG]), HEX_ALPHA = /[0-9a-f]{2}$/i, HEX_REGEX = { generic: HEXADECIMAL, shortWithoutAlpha: HEX_SHORT_WITHOUT_ALPHA, shortWithAlpha: HEX_SHORT_WITH_ALPHA, short: HEX_SHORT, longWithoutAlpha: HEX_LONG_WITHOUT_ALPHA, longWithAlpha: HEX_LONG_WITH_ALPHA, long: HEX_LONG, color: HEX_COLOR, alpha: HEX_ALPHA };
  function between(e2, t2) {
    var r2 = Math.min.apply(Math, t2), t2 = Math.max.apply(Math, t2);
    return r2 <= e2 && e2 <= t2;
  }
  function hexadecimalToDecimal(e2) {
    if (!HEX_REGEX.generic.test(e2))
      throw new Error(e2 + " is not a valid hexadecimal string.");
    var t2 = e2.split("."), e2 = t2[0], t2 = t2[1];
    return t2 ? parseInt(e2, 16) + parseInt(t2, 16) / Math.pow(16, t2.length) : parseInt(e2, 16);
  }
  function sameContent(e2, t2) {
    return e2.sort().toString() === t2.sort().toString();
  }
  function applyFnToEachObjValue(e2, r2) {
    var n2 = Object.assign({}, e2);
    return Object.entries(n2).forEach(function(e3) {
      var t2 = e3[0], e3 = e3[1];
      n2[t2] = r2(e3);
    }), n2;
  }
  function isHex(e2) {
    return HEX_REGEX.color.test(e2);
  }
  function isRgb(e2) {
    var t2 = Object.keys(e2);
    if (t2.length !== 3)
      return false;
    if (!sameContent(t2, ["r", "g", "b"]))
      return false;
    function r2(e3) {
      return typeof e3 == "number" && between(e3, [0, 255]);
    }
    var n2 = r2(e2.r), t2 = r2(e2.g), e2 = r2(e2.b);
    return n2 && t2 && e2;
  }
  function isRgba(e2) {
    var t2 = Object.keys(e2);
    if (t2.length === 4 && sameContent(t2, ["r", "g", "b", "a"])) {
      t2 = isRgb({ r: e2.r, g: e2.g, b: e2.b }), e2 = typeof e2.a == "number" && between(e2.a, [0, 1]);
      return t2 && e2;
    }
  }
  function isHsl(e2) {
    var t2 = Object.keys(e2);
    if (t2.length !== 3)
      return false;
    if (!sameContent(t2, ["h", "s", "l"]))
      return false;
    function r2(e3, t3) {
      return typeof e3 == "number" && between(e3, t3);
    }
    var n2 = r2(e2.h, [0, 359]), t2 = r2(e2.s, [0, 100]), e2 = r2(e2.l, [0, 100]);
    return n2 && t2 && e2;
  }
  function isHsla(e2) {
    var t2 = Object.keys(e2);
    if (t2.length === 4 && sameContent(t2, ["h", "s", "l", "a"])) {
      t2 = isHsl({ h: e2.h, s: e2.s, l: e2.l }), e2 = typeof e2.a == "number" && between(e2.a, [0, 1]);
      return t2 && e2;
    }
  }
  var lodash = { exports: {} }, bL1, cL1;
  function notValidHexMessage(e2, t2) {
    return e2 + ": " + t2 + " is not a valid hex color.";
  }
  function notValidRgbMessage(e2, t2) {
    return e2 + ": " + JSON.stringify(t2) + " is not a valid rgb color object.";
  }
  function notValidRgbaMessage(e2, t2) {
    return e2 + ": " + JSON.stringify(t2) + " is not a valid rgba color object.";
  }
  function notValidHslMessage(e2, t2) {
    return e2 + ": " + JSON.stringify(t2) + " is not a valid hsl color object.";
  }
  function notValidHslaMessage(e2, t2) {
    return e2 + ": " + JSON.stringify(t2) + " is not a valid hsla color object.";
  }
  function notValidAlphaValueMessage(e2, t2) {
    return e2 + ": " + t2 + " is not in range [0, 1].";
  }
  function chunkString(e2, t2) {
    return e2.match(new RegExp(".{1," + t2 + "}", "g"));
  }
  function alphaToHex(e2) {
    if (!between(e2, [0, 1]))
      throw new Error(e2 + " is not in the range [0, 1].");
    return Math.round(255 * e2).toString(16).padStart(2, "0").toUpperCase();
  }
  function hexToAlpha(e2, t2) {
    if (t2 === void 0 && (t2 = 2), !HEX_REGEX.alpha.test(e2))
      throw new Error(e2 + " is not a valid hex color.");
    if (e2.length !== 2)
      throw new Error(e2 + " lenght is not 2.");
    e2 = hexadecimalToDecimal(e2);
    return lodash.exports.round(e2 / 255, t2);
  }
  function hexAlphaTo0255(e2) {
    return Math.round(255 * hexToAlpha(e2));
  }
  function number0255ToHex(e2) {
    if (!between(e2, [0, 255]))
      throw new Error(e2 + " must be in [0, 255].");
    return Math.round(e2).toString(16).padStart(2, "0").toUpperCase();
  }
  bL1 = lodash, cL1 = lodash.exports, function() {
    var Ua, Va = "Expected a function", za = "__lodash_hash_undefined__", Ha2 = "__lodash_placeholder__", Ga2 = 9007199254740991, Wa = NaN, qa = 4294967295, Ya = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], Xa = "[object Arguments]", Za = "[object Array]", Ka = "[object Boolean]", Ja = "[object Date]", Qa = "[object Error]", eo = "[object Function]", to2 = "[object GeneratorFunction]", ro = "[object Map]", no = "[object Number]", io = "[object Object]", ao = "[object Promise]", oo = "[object RegExp]", so = "[object Set]", lo = "[object String]", co = "[object Symbol]", uo = "[object WeakMap]", ho = "[object ArrayBuffer]", po = "[object DataView]", fo = "[object Float32Array]", mo = "[object Float64Array]", go = "[object Int8Array]", vo = "[object Int16Array]", yo = "[object Int32Array]", _o = "[object Uint8Array]", bo = "[object Uint8ClampedArray]", xo = "[object Uint16Array]", wo = "[object Uint32Array]", So = /\b__p \+= '';/g, Mo = /\b(__p \+=) '' \+/g, Eo = /(__e\(.*?\)|\b__t\)) \+\n'';/g, To = /&(?:amp|lt|gt|quot|#39);/g, ko = /[&<>"']/g, Ao = RegExp(To.source), Co = RegExp(ko.source), $o = /<%-([\s\S]+?)%>/g, Ro = /<%([\s\S]+?)%>/g, Lo = /<%=([\s\S]+?)%>/g, Oo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Po = /^\w*$/, Io = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Do = /[\\^$.*+?()[\]{}|]/g, No = RegExp(Do.source), Bo = /^\s+/, r2 = /\s/, Fo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, jo = /\{\n\/\* \[wrapped with (.+)\] \*/, Uo = /,? & /, Vo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, zo = /[()=,{}\[\]\/\s]/, Ho = /\\(\\)?/g, Go = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Wo = /\w*$/, qo = /^[-+]0x[0-9a-f]+$/i, Yo = /^0b[01]+$/i, Xo = /^\[object .+?Constructor\]$/, Zo = /^0o[0-7]+$/i, Ko = /^(?:0|[1-9]\d*)$/, Jo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Qo = /($^)/, es = /['\n\r\u2028\u2029\\]/g, e2 = "\\ud800-\\udfff", t2 = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", n2 = "\\u2700-\\u27bf", i2 = "a-z\\xdf-\\xf6\\xf8-\\xff", a2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", o2 = "\\ufe0e\\ufe0f", s2 = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", l2 = "[" + e2 + "]", c2 = "[" + s2 + "]", u2 = "[" + t2 + "]", h2 = "\\d+", d2 = "[" + n2 + "]", p2 = "[" + i2 + "]", f2 = "[^" + e2 + s2 + h2 + n2 + i2 + a2 + "]", m2 = "\\ud83c[\\udffb-\\udfff]", g2 = "[^" + e2 + "]", v2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", y = "[\\ud800-\\udbff][\\udc00-\\udfff]", _2 = "[" + a2 + "]", b2 = "(?:" + p2 + "|" + f2 + ")", s2 = "(?:" + _2 + "|" + f2 + ")", n2 = "(?:['\u2019](?:d|ll|m|re|s|t|ve))?", i2 = "(?:['\u2019](?:D|LL|M|RE|S|T|VE))?", a2 = "(?:" + u2 + "|" + m2 + ")?", f2 = "[" + o2 + "]?", a2 = f2 + a2 + ("(?:\\u200d(?:" + [g2, v2, y].join("|") + ")" + f2 + a2 + ")*"), d2 = "(?:" + [d2, v2, y].join("|") + ")" + a2, l2 = "(?:" + [g2 + u2 + "?", u2, v2, y, l2].join("|") + ")", ts = RegExp("['\u2019]", "g"), rs = RegExp(u2, "g"), x2 = RegExp(m2 + "(?=" + m2 + ")|" + l2 + a2, "g"), ns = RegExp([_2 + "?" + p2 + "+" + n2 + "(?=" + [c2, _2, "$"].join("|") + ")", s2 + "+" + i2 + "(?=" + [c2, _2 + b2, "$"].join("|") + ")", _2 + "?" + b2 + "+" + n2, _2 + "+" + i2, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", h2, d2].join("|"), "g"), w2 = RegExp("[\\u200d" + e2 + t2 + o2 + "]"), is = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, as2 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], os = -1, ss = {};
    ss[fo] = ss[mo] = ss[go] = ss[vo] = ss[yo] = ss[_o] = ss[bo] = ss[xo] = ss[wo] = true, ss[Xa] = ss[Za] = ss[ho] = ss[Ka] = ss[po] = ss[Ja] = ss[Qa] = ss[eo] = ss[ro] = ss[no] = ss[io] = ss[oo] = ss[so] = ss[lo] = ss[uo] = false;
    var ls = {};
    ls[Xa] = ls[Za] = ls[ho] = ls[po] = ls[Ka] = ls[Ja] = ls[fo] = ls[mo] = ls[go] = ls[vo] = ls[yo] = ls[ro] = ls[no] = ls[io] = ls[oo] = ls[so] = ls[lo] = ls[co] = ls[_o] = ls[bo] = ls[xo] = ls[wo] = true, ls[Qa] = ls[eo] = ls[uo] = false;
    var S2 = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, cs = parseFloat, us = parseInt, t2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, o2 = typeof self == "object" && self && self.Object === Object && self, hs = t2 || o2 || Function("return this")(), o2 = cL1 && !cL1.nodeType && cL1, M2 = o2 && bL1 && !bL1.nodeType && bL1, ds = M2 && M2.exports === o2, E2 = ds && t2.process, t2 = function() {
      try {
        var e3 = M2 && M2.require && M2.require("util").types;
        return e3 ? e3 : E2 && E2.binding && E2.binding("util");
      } catch (e4) {
      }
    }(), ps = t2 && t2.isArrayBuffer, fs = t2 && t2.isDate, ms = t2 && t2.isMap, gs = t2 && t2.isRegExp, vs = t2 && t2.isSet, ys = t2 && t2.isTypedArray;
    function _s(e3, t3, r3) {
      switch (r3.length) {
        case 0:
          return e3.call(t3);
        case 1:
          return e3.call(t3, r3[0]);
        case 2:
          return e3.call(t3, r3[0], r3[1]);
        case 3:
          return e3.call(t3, r3[0], r3[1], r3[2]);
      }
      return e3.apply(t3, r3);
    }
    function bs(e3, t3, r3, n3) {
      for (var i3 = -1, a3 = e3 == null ? 0 : e3.length; ++i3 < a3; ) {
        var o3 = e3[i3];
        t3(n3, o3, r3(o3), e3);
      }
      return n3;
    }
    function xs(e3, t3) {
      for (var r3 = -1, n3 = e3 == null ? 0 : e3.length; ++r3 < n3 && t3(e3[r3], r3, e3) !== false; )
        ;
      return e3;
    }
    function ws(e3, t3) {
      for (var r3 = e3 == null ? 0 : e3.length; r3-- && t3(e3[r3], r3, e3) !== false; )
        ;
      return e3;
    }
    function Ss(e3, t3) {
      for (var r3 = -1, n3 = e3 == null ? 0 : e3.length; ++r3 < n3; )
        if (!t3(e3[r3], r3, e3))
          return false;
      return true;
    }
    function Ms(e3, t3) {
      for (var r3 = -1, n3 = e3 == null ? 0 : e3.length, i3 = 0, a3 = []; ++r3 < n3; ) {
        var o3 = e3[r3];
        t3(o3, r3, e3) && (a3[i3++] = o3);
      }
      return a3;
    }
    function Es(e3, t3) {
      return !!(e3 == null ? 0 : e3.length) && -1 < Ps(e3, t3, 0);
    }
    function Ts(e3, t3, r3) {
      for (var n3 = -1, i3 = e3 == null ? 0 : e3.length; ++n3 < i3; )
        if (r3(t3, e3[n3]))
          return true;
      return false;
    }
    function ks(e3, t3) {
      for (var r3 = -1, n3 = e3 == null ? 0 : e3.length, i3 = Array(n3); ++r3 < n3; )
        i3[r3] = t3(e3[r3], r3, e3);
      return i3;
    }
    function As(e3, t3) {
      for (var r3 = -1, n3 = t3.length, i3 = e3.length; ++r3 < n3; )
        e3[i3 + r3] = t3[r3];
      return e3;
    }
    function Cs(e3, t3, r3, n3) {
      var i3 = -1, a3 = e3 == null ? 0 : e3.length;
      for (n3 && a3 && (r3 = e3[++i3]); ++i3 < a3; )
        r3 = t3(r3, e3[i3], i3, e3);
      return r3;
    }
    function $s(e3, t3, r3, n3) {
      var i3 = e3 == null ? 0 : e3.length;
      for (n3 && i3 && (r3 = e3[--i3]); i3--; )
        r3 = t3(r3, e3[i3], i3, e3);
      return r3;
    }
    function Rs(e3, t3) {
      for (var r3 = -1, n3 = e3 == null ? 0 : e3.length; ++r3 < n3; )
        if (t3(e3[r3], r3, e3))
          return true;
      return false;
    }
    var T2 = Bs("length");
    function Ls(e3, n3, t3) {
      var i3;
      return t3(e3, function(e4, t4, r3) {
        if (n3(e4, t4, r3))
          return i3 = t4, false;
      }), i3;
    }
    function Os(e3, t3, r3, n3) {
      for (var i3 = e3.length, a3 = r3 + (n3 ? 1 : -1); n3 ? a3-- : ++a3 < i3; )
        if (t3(e3[a3], a3, e3))
          return a3;
      return -1;
    }
    function Ps(e3, t3, r3) {
      return t3 == t3 ? function(e4, t4, r4) {
        var n3 = r4 - 1, i3 = e4.length;
        for (; ++n3 < i3; )
          if (e4[n3] === t4)
            return n3;
        return -1;
      }(e3, t3, r3) : Os(e3, Ds, r3);
    }
    function Is(e3, t3, r3, n3) {
      for (var i3 = r3 - 1, a3 = e3.length; ++i3 < a3; )
        if (n3(e3[i3], t3))
          return i3;
      return -1;
    }
    function Ds(e3) {
      return e3 != e3;
    }
    function Ns(e3, t3) {
      var r3 = e3 == null ? 0 : e3.length;
      return r3 ? js(e3, t3) / r3 : Wa;
    }
    function Bs(t3) {
      return function(e3) {
        return e3 == null ? Ua : e3[t3];
      };
    }
    function k2(t3) {
      return function(e3) {
        return t3 == null ? Ua : t3[e3];
      };
    }
    function Fs(e3, n3, i3, a3, t3) {
      return t3(e3, function(e4, t4, r3) {
        i3 = a3 ? (a3 = false, e4) : n3(i3, e4, t4, r3);
      }), i3;
    }
    function js(e3, t3) {
      for (var r3, n3 = -1, i3 = e3.length; ++n3 < i3; ) {
        var a3 = t3(e3[n3]);
        a3 !== Ua && (r3 = r3 === Ua ? a3 : r3 + a3);
      }
      return r3;
    }
    function Us(e3, t3) {
      for (var r3 = -1, n3 = Array(e3); ++r3 < e3; )
        n3[r3] = t3(r3);
      return n3;
    }
    function Vs(e3) {
      return e3 && e3.slice(0, il(e3) + 1).replace(Bo, "");
    }
    function zs(t3) {
      return function(e3) {
        return t3(e3);
      };
    }
    function Hs(t3, e3) {
      return ks(e3, function(e4) {
        return t3[e4];
      });
    }
    function Gs(e3, t3) {
      return e3.has(t3);
    }
    function Ws(e3, t3) {
      for (var r3 = -1, n3 = e3.length; ++r3 < n3 && -1 < Ps(t3, e3[r3], 0); )
        ;
      return r3;
    }
    function qs2(e3, t3) {
      for (var r3 = e3.length; r3-- && -1 < Ps(t3, e3[r3], 0); )
        ;
      return r3;
    }
    var Ys = k2({ "\xC0": "A", "\xC1": "A", "\xC2": "A", "\xC3": "A", "\xC4": "A", "\xC5": "A", "\xE0": "a", "\xE1": "a", "\xE2": "a", "\xE3": "a", "\xE4": "a", "\xE5": "a", "\xC7": "C", "\xE7": "c", "\xD0": "D", "\xF0": "d", "\xC8": "E", "\xC9": "E", "\xCA": "E", "\xCB": "E", "\xE8": "e", "\xE9": "e", "\xEA": "e", "\xEB": "e", "\xCC": "I", "\xCD": "I", "\xCE": "I", "\xCF": "I", "\xEC": "i", "\xED": "i", "\xEE": "i", "\xEF": "i", "\xD1": "N", "\xF1": "n", "\xD2": "O", "\xD3": "O", "\xD4": "O", "\xD5": "O", "\xD6": "O", "\xD8": "O", "\xF2": "o", "\xF3": "o", "\xF4": "o", "\xF5": "o", "\xF6": "o", "\xF8": "o", "\xD9": "U", "\xDA": "U", "\xDB": "U", "\xDC": "U", "\xF9": "u", "\xFA": "u", "\xFB": "u", "\xFC": "u", "\xDD": "Y", "\xFD": "y", "\xFF": "y", "\xC6": "Ae", "\xE6": "ae", "\xDE": "Th", "\xFE": "th", "\xDF": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S", "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe", "\u0149": "'n", "\u017F": "s" }), Xs = k2({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
    function Zs(e3) {
      return "\\" + S2[e3];
    }
    function Ks(e3) {
      return w2.test(e3);
    }
    function Js(e3) {
      var r3 = -1, n3 = Array(e3.size);
      return e3.forEach(function(e4, t3) {
        n3[++r3] = [t3, e4];
      }), n3;
    }
    function Qs(t3, r3) {
      return function(e3) {
        return t3(r3(e3));
      };
    }
    function el(e3, t3) {
      for (var r3 = -1, n3 = e3.length, i3 = 0, a3 = []; ++r3 < n3; ) {
        var o3 = e3[r3];
        o3 !== t3 && o3 !== Ha2 || (e3[r3] = Ha2, a3[i3++] = r3);
      }
      return a3;
    }
    function tl(e3) {
      var t3 = -1, r3 = Array(e3.size);
      return e3.forEach(function(e4) {
        r3[++t3] = e4;
      }), r3;
    }
    function rl(e3) {
      return (Ks(e3) ? function(e4) {
        var t3 = x2.lastIndex = 0;
        for (; x2.test(e4); )
          ++t3;
        return t3;
      } : T2)(e3);
    }
    function nl(e3) {
      return Ks(e3) ? e3.match(x2) || [] : e3.split("");
    }
    function il(e3) {
      for (var t3 = e3.length; t3-- && r2.test(e3.charAt(t3)); )
        ;
      return t3;
    }
    var al = k2({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" });
    var ol = function e3(t3) {
      var S3 = (t3 = t3 == null ? hs : ol.defaults(hs.Object(), t3, ol.pick(hs, as2))).Array, r3 = t3.Date, h3 = t3.Error, d3 = t3.Function, i3 = t3.Math, m3 = t3.Object, p3 = t3.RegExp, u3 = t3.String, y2 = t3.TypeError, a3 = S3.prototype, n3 = d3.prototype, f3 = m3.prototype, o3 = t3["__core-js_shared__"], s3 = n3.toString, _3 = f3.hasOwnProperty, l3 = 0, c3 = (La = /[^.]+$/.exec(o3 && o3.keys && o3.keys.IE_PROTO || "")) ? "Symbol(src)_1." + La : "", g3 = f3.toString, v3 = s3.call(m3), b3 = hs._, x3 = p3("^" + s3.call(_3).replace(Do, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), w3 = ds ? t3.Buffer : Ua, M3 = t3.Symbol, E3 = t3.Uint8Array, T3 = w3 ? w3.allocUnsafe : Ua, k3 = Qs(m3.getPrototypeOf, m3), A2 = m3.create, C2 = f3.propertyIsEnumerable, $2 = a3.splice, R2 = M3 ? M3.isConcatSpreadable : Ua, L = M3 ? M3.iterator : Ua, O = M3 ? M3.toStringTag : Ua, P2 = function() {
        try {
          var e4 = Ur(m3, "defineProperty");
          return e4({}, "", {}), e4;
        } catch (e5) {
        }
      }(), I2 = t3.clearTimeout !== hs.clearTimeout && t3.clearTimeout, D = r3 && r3.now !== hs.Date.now && r3.now, N2 = t3.setTimeout !== hs.setTimeout && t3.setTimeout, B = i3.ceil, F = i3.floor, j2 = m3.getOwnPropertySymbols, U = w3 ? w3.isBuffer : Ua, V2 = t3.isFinite, z = a3.join, H2 = Qs(m3.keys, m3), G = i3.max, W = i3.min, q = r3.now, Y = t3.parseInt, X = i3.random, Z = a3.reverse, K = Ur(t3, "DataView"), J = Ur(t3, "Map"), Q = Ur(t3, "Promise"), ee = Ur(t3, "Set"), te = Ur(t3, "WeakMap"), re = Ur(m3, "create"), ne = te && new te(), ie = {}, ae = gn(K), oe = gn(J), se = gn(Q), le = gn(ee), ce = gn(te), ue = M3 ? M3.prototype : Ua, he = ue ? ue.valueOf : Ua, de = ue ? ue.toString : Ua;
      function pe(e4) {
        if (Oi(e4) && !wi(e4) && !(e4 instanceof ye)) {
          if (e4 instanceof ve)
            return e4;
          if (_3.call(e4, "__wrapped__"))
            return vn(e4);
        }
        return new ve(e4);
      }
      var fe = function(e4) {
        if (!Li(e4))
          return {};
        if (A2)
          return A2(e4);
        me.prototype = e4;
        e4 = new me();
        return me.prototype = Ua, e4;
      };
      function me() {
      }
      function ge() {
      }
      function ve(e4, t4) {
        this.__wrapped__ = e4, this.__actions__ = [], this.__chain__ = !!t4, this.__index__ = 0, this.__values__ = Ua;
      }
      function ye(e4) {
        this.__wrapped__ = e4, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = qa, this.__views__ = [];
      }
      function _e(e4) {
        var t4 = -1, r4 = e4 == null ? 0 : e4.length;
        for (this.clear(); ++t4 < r4; ) {
          var n4 = e4[t4];
          this.set(n4[0], n4[1]);
        }
      }
      function be(e4) {
        var t4 = -1, r4 = e4 == null ? 0 : e4.length;
        for (this.clear(); ++t4 < r4; ) {
          var n4 = e4[t4];
          this.set(n4[0], n4[1]);
        }
      }
      function xe(e4) {
        var t4 = -1, r4 = e4 == null ? 0 : e4.length;
        for (this.clear(); ++t4 < r4; ) {
          var n4 = e4[t4];
          this.set(n4[0], n4[1]);
        }
      }
      function we(e4) {
        var t4 = -1, r4 = e4 == null ? 0 : e4.length;
        for (this.__data__ = new xe(); ++t4 < r4; )
          this.add(e4[t4]);
      }
      function Se(e4) {
        e4 = this.__data__ = new be(e4);
        this.size = e4.size;
      }
      function Me(e4, t4) {
        var r4, n4 = wi(e4), i4 = !n4 && xi(e4), a4 = !n4 && !i4 && Ti(e4), o4 = !n4 && !i4 && !a4 && Ui(e4), s4 = n4 || i4 || a4 || o4, l4 = s4 ? Us(e4.length, u3) : [], c4 = l4.length;
        for (r4 in e4)
          !t4 && !_3.call(e4, r4) || s4 && (r4 == "length" || a4 && (r4 == "offset" || r4 == "parent") || o4 && (r4 == "buffer" || r4 == "byteLength" || r4 == "byteOffset") || Yr(r4, c4)) || l4.push(r4);
        return l4;
      }
      function Ee(e4) {
        var t4 = e4.length;
        return t4 ? e4[wt(0, t4 - 1)] : Ua;
      }
      function Te(e4, t4) {
        return hn(nr(e4), Ie(t4, 0, e4.length));
      }
      function ke(e4) {
        return hn(nr(e4));
      }
      function Ae(e4, t4, r4) {
        (r4 === Ua || yi(e4[t4], r4)) && (r4 !== Ua || t4 in e4) || Oe(e4, t4, r4);
      }
      function Ce(e4, t4, r4) {
        var n4 = e4[t4];
        _3.call(e4, t4) && yi(n4, r4) && (r4 !== Ua || t4 in e4) || Oe(e4, t4, r4);
      }
      function $e(e4, t4) {
        for (var r4 = e4.length; r4--; )
          if (yi(e4[r4][0], t4))
            return r4;
        return -1;
      }
      function Re(e4, n4, i4, a4) {
        return je(e4, function(e5, t4, r4) {
          n4(a4, e5, i4(e5), r4);
        }), a4;
      }
      function Le(e4, t4) {
        return e4 && ir(t4, ca(t4), e4);
      }
      function Oe(e4, t4, r4) {
        t4 == "__proto__" && P2 ? P2(e4, t4, { configurable: true, enumerable: true, value: r4, writable: true }) : e4[t4] = r4;
      }
      function Pe(e4, t4) {
        for (var r4 = -1, n4 = t4.length, i4 = S3(n4), a4 = e4 == null; ++r4 < n4; )
          i4[r4] = a4 ? Ua : ia(e4, t4[r4]);
        return i4;
      }
      function Ie(e4, t4, r4) {
        return e4 == e4 && (r4 !== Ua && (e4 = e4 <= r4 ? e4 : r4), t4 !== Ua && (e4 = t4 <= e4 ? e4 : t4)), e4;
      }
      function De(r4, n4, i4, e4, t4, a4) {
        var o4, s4 = 1 & n4, l4 = 2 & n4, c4 = 4 & n4;
        if ((o4 = i4 ? t4 ? i4(r4, e4, t4, a4) : i4(r4) : o4) !== Ua)
          return o4;
        if (!Li(r4))
          return r4;
        var u4, h4, d4 = wi(r4);
        if (d4) {
          if (o4 = function(e5) {
            var t5 = e5.length, r5 = new e5.constructor(t5);
            t5 && typeof e5[0] == "string" && _3.call(e5, "index") && (r5.index = e5.index, r5.input = e5.input);
            return r5;
          }(r4), !s4)
            return nr(r4, o4);
        } else {
          var p4 = Hr(r4), e4 = p4 == eo || p4 == to2;
          if (Ti(r4))
            return Kt(r4, s4);
          if (p4 == io || p4 == Xa || e4 && !t4) {
            if (o4 = l4 || e4 ? {} : Wr(r4), !s4)
              return l4 ? (e4 = u4 = r4, h4 = (h4 = o4) && ir(e4, ua(e4), h4), ir(u4, zr(u4), h4)) : (h4 = Le(o4, u4 = r4), ir(u4, Vr(u4), h4));
          } else {
            if (!ls[p4])
              return t4 ? r4 : {};
            o4 = function(e5, t5, r5) {
              var n5 = e5.constructor;
              switch (t5) {
                case ho:
                  return Jt(e5);
                case Ka:
                case Ja:
                  return new n5(+e5);
                case po:
                  return function(e6, t6) {
                    t6 = t6 ? Jt(e6.buffer) : e6.buffer;
                    return new e6.constructor(t6, e6.byteOffset, e6.byteLength);
                  }(e5, r5);
                case fo:
                case mo:
                case go:
                case vo:
                case yo:
                case _o:
                case bo:
                case xo:
                case wo:
                  return Qt(e5, r5);
                case ro:
                  return new n5();
                case no:
                case lo:
                  return new n5(e5);
                case oo:
                  return function(e6) {
                    var t6 = new e6.constructor(e6.source, Wo.exec(e6));
                    return t6.lastIndex = e6.lastIndex, t6;
                  }(e5);
                case so:
                  return new n5();
                case co:
                  return function(e6) {
                    return he ? m3(he.call(e6)) : {};
                  }(e5);
              }
            }(r4, p4, s4);
          }
        }
        s4 = (a4 = a4 || new Se()).get(r4);
        if (s4)
          return s4;
        a4.set(r4, o4), Bi(r4) ? r4.forEach(function(e5) {
          o4.add(De(e5, n4, i4, e5, r4, a4));
        }) : Pi(r4) && r4.forEach(function(e5, t5) {
          o4.set(t5, De(e5, n4, i4, t5, r4, a4));
        });
        var f4 = d4 ? Ua : (c4 ? l4 ? Pr : Or : l4 ? ua : ca)(r4);
        return xs(f4 || r4, function(e5, t5) {
          f4 && (e5 = r4[t5 = e5]), Ce(o4, t5, De(e5, n4, i4, t5, r4, a4));
        }), o4;
      }
      function Ne(e4, t4, r4) {
        var n4 = r4.length;
        if (e4 == null)
          return !n4;
        for (e4 = m3(e4); n4--; ) {
          var i4 = r4[n4], a4 = t4[i4], o4 = e4[i4];
          if (o4 === Ua && !(i4 in e4) || !a4(o4))
            return false;
        }
        return true;
      }
      function Be(e4, t4, r4) {
        if (typeof e4 != "function")
          throw new y2(Va);
        return sn(function() {
          e4.apply(Ua, r4);
        }, t4);
      }
      function Fe(e4, t4, r4, n4) {
        var i4 = -1, a4 = Es, o4 = true, s4 = e4.length, l4 = [], c4 = t4.length;
        if (!s4)
          return l4;
        r4 && (t4 = ks(t4, zs(r4))), n4 ? (a4 = Ts, o4 = false) : 200 <= t4.length && (a4 = Gs, o4 = false, t4 = new we(t4));
        e:
          for (; ++i4 < s4; ) {
            var u4 = e4[i4], h4 = r4 == null ? u4 : r4(u4), u4 = n4 || u4 !== 0 ? u4 : 0;
            if (o4 && h4 == h4) {
              for (var d4 = c4; d4--; )
                if (t4[d4] === h4)
                  continue e;
              l4.push(u4);
            } else
              a4(t4, h4, n4) || l4.push(u4);
          }
        return l4;
      }
      pe.templateSettings = { escape: $o, evaluate: Ro, interpolate: Lo, variable: "", imports: { _: pe } }, (pe.prototype = ge.prototype).constructor = pe, (ve.prototype = fe(ge.prototype)).constructor = ve, (ye.prototype = fe(ge.prototype)).constructor = ye, _e.prototype.clear = function() {
        this.__data__ = re ? re(null) : {}, this.size = 0;
      }, _e.prototype.delete = function(e4) {
        return e4 = this.has(e4) && delete this.__data__[e4], this.size -= e4 ? 1 : 0, e4;
      }, _e.prototype.get = function(e4) {
        var t4 = this.__data__;
        if (re) {
          var r4 = t4[e4];
          return r4 === za ? Ua : r4;
        }
        return _3.call(t4, e4) ? t4[e4] : Ua;
      }, _e.prototype.has = function(e4) {
        var t4 = this.__data__;
        return re ? t4[e4] !== Ua : _3.call(t4, e4);
      }, _e.prototype.set = function(e4, t4) {
        var r4 = this.__data__;
        return this.size += this.has(e4) ? 0 : 1, r4[e4] = re && t4 === Ua ? za : t4, this;
      }, be.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, be.prototype.delete = function(e4) {
        var t4 = this.__data__;
        return !((e4 = $e(t4, e4)) < 0) && (e4 == t4.length - 1 ? t4.pop() : $2.call(t4, e4, 1), --this.size, true);
      }, be.prototype.get = function(e4) {
        var t4 = this.__data__;
        return (e4 = $e(t4, e4)) < 0 ? Ua : t4[e4][1];
      }, be.prototype.has = function(e4) {
        return -1 < $e(this.__data__, e4);
      }, be.prototype.set = function(e4, t4) {
        var r4 = this.__data__, n4 = $e(r4, e4);
        return n4 < 0 ? (++this.size, r4.push([e4, t4])) : r4[n4][1] = t4, this;
      }, xe.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new _e(), map: new (J || be)(), string: new _e() };
      }, xe.prototype.delete = function(e4) {
        return e4 = Fr(this, e4).delete(e4), this.size -= e4 ? 1 : 0, e4;
      }, xe.prototype.get = function(e4) {
        return Fr(this, e4).get(e4);
      }, xe.prototype.has = function(e4) {
        return Fr(this, e4).has(e4);
      }, xe.prototype.set = function(e4, t4) {
        var r4 = Fr(this, e4), n4 = r4.size;
        return r4.set(e4, t4), this.size += r4.size == n4 ? 0 : 1, this;
      }, we.prototype.add = we.prototype.push = function(e4) {
        return this.__data__.set(e4, za), this;
      }, we.prototype.has = function(e4) {
        return this.__data__.has(e4);
      }, Se.prototype.clear = function() {
        this.__data__ = new be(), this.size = 0;
      }, Se.prototype.delete = function(e4) {
        var t4 = this.__data__, e4 = t4.delete(e4);
        return this.size = t4.size, e4;
      }, Se.prototype.get = function(e4) {
        return this.__data__.get(e4);
      }, Se.prototype.has = function(e4) {
        return this.__data__.has(e4);
      }, Se.prototype.set = function(e4, t4) {
        var r4 = this.__data__;
        if (r4 instanceof be) {
          var n4 = r4.__data__;
          if (!J || n4.length < 199)
            return n4.push([e4, t4]), this.size = ++r4.size, this;
          r4 = this.__data__ = new xe(n4);
        }
        return r4.set(e4, t4), this.size = r4.size, this;
      };
      var je = sr(Ye), Ue = sr(Xe, true);
      function Ve(e4, n4) {
        var i4 = true;
        return je(e4, function(e5, t4, r4) {
          return i4 = !!n4(e5, t4, r4);
        }), i4;
      }
      function ze(e4, t4, r4) {
        for (var n4 = -1, i4 = e4.length; ++n4 < i4; ) {
          var a4, o4, s4 = e4[n4], l4 = t4(s4);
          l4 != null && (a4 === Ua ? l4 == l4 && !ji(l4) : r4(l4, a4)) && (a4 = l4, o4 = s4);
        }
        return o4;
      }
      function He(e4, n4) {
        var i4 = [];
        return je(e4, function(e5, t4, r4) {
          n4(e5, t4, r4) && i4.push(e5);
        }), i4;
      }
      function Ge(e4, t4, r4, n4, i4) {
        var a4 = -1, o4 = e4.length;
        for (r4 = r4 || qr, i4 = i4 || []; ++a4 < o4; ) {
          var s4 = e4[a4];
          0 < t4 && r4(s4) ? 1 < t4 ? Ge(s4, t4 - 1, r4, n4, i4) : As(i4, s4) : n4 || (i4[i4.length] = s4);
        }
        return i4;
      }
      var We = lr(), qe = lr(true);
      function Ye(e4, t4) {
        return e4 && We(e4, t4, ca);
      }
      function Xe(e4, t4) {
        return e4 && qe(e4, t4, ca);
      }
      function Ze(t4, e4) {
        return Ms(e4, function(e5) {
          return Ci(t4[e5]);
        });
      }
      function Ke(e4, t4) {
        for (var r4 = 0, n4 = (t4 = qt(t4, e4)).length; e4 != null && r4 < n4; )
          e4 = e4[mn(t4[r4++])];
        return r4 && r4 == n4 ? e4 : Ua;
      }
      function Je(e4, t4, r4) {
        t4 = t4(e4);
        return wi(e4) ? t4 : As(t4, r4(e4));
      }
      function Qe(e4) {
        return e4 == null ? e4 === Ua ? "[object Undefined]" : "[object Null]" : O && O in m3(e4) ? function(e5) {
          var t4 = _3.call(e5, O), r4 = e5[O];
          try {
            e5[O] = Ua;
            var n4 = true;
          } catch (e6) {
          }
          var i4 = g3.call(e5);
          n4 && (t4 ? e5[O] = r4 : delete e5[O]);
          return i4;
        }(e4) : g3.call(e4);
      }
      function et(e4, t4) {
        return t4 < e4;
      }
      function tt(e4, t4) {
        return e4 != null && _3.call(e4, t4);
      }
      function rt(e4, t4) {
        return e4 != null && t4 in m3(e4);
      }
      function nt(e4, t4, r4) {
        for (var n4 = r4 ? Ts : Es, i4 = e4[0].length, a4 = e4.length, o4 = a4, s4 = S3(a4), l4 = 1 / 0, c4 = []; o4--; ) {
          var u4 = e4[o4];
          o4 && t4 && (u4 = ks(u4, zs(t4))), l4 = W(u4.length, l4), s4[o4] = !r4 && (t4 || 120 <= i4 && 120 <= u4.length) ? new we(o4 && u4) : Ua;
        }
        var u4 = e4[0], h4 = -1, d4 = s4[0];
        e:
          for (; ++h4 < i4 && c4.length < l4; ) {
            var p4 = u4[h4], f4 = t4 ? t4(p4) : p4, p4 = r4 || p4 !== 0 ? p4 : 0;
            if (!(d4 ? Gs(d4, f4) : n4(c4, f4, r4))) {
              for (o4 = a4; --o4; ) {
                var m4 = s4[o4];
                if (!(m4 ? Gs(m4, f4) : n4(e4[o4], f4, r4)))
                  continue e;
              }
              d4 && d4.push(f4), c4.push(p4);
            }
          }
        return c4;
      }
      function it(e4, t4, r4) {
        t4 = (e4 = nn(e4, t4 = qt(t4, e4))) == null ? e4 : e4[mn(An(t4))];
        return t4 == null ? Ua : _s(t4, e4, r4);
      }
      function at(e4) {
        return Oi(e4) && Qe(e4) == Xa;
      }
      function ot(e4, t4, r4, n4, i4) {
        return e4 === t4 || (e4 == null || t4 == null || !Oi(e4) && !Oi(t4) ? e4 != e4 && t4 != t4 : function(e5, t5, r5, n5, i5, a4) {
          var o4 = wi(e5), s4 = wi(t5), l4 = o4 ? Za : Hr(e5), c4 = s4 ? Za : Hr(t5), u4 = (l4 = l4 == Xa ? io : l4) == io, s4 = (c4 = c4 == Xa ? io : c4) == io, c4 = l4 == c4;
          if (c4 && Ti(e5)) {
            if (!Ti(t5))
              return false;
            u4 = !(o4 = true);
          }
          if (c4 && !u4)
            return a4 = a4 || new Se(), o4 || Ui(e5) ? Rr(e5, t5, r5, n5, i5, a4) : function(e6, t6, r6, n6, i6, a5, o5) {
              switch (r6) {
                case po:
                  if (e6.byteLength != t6.byteLength || e6.byteOffset != t6.byteOffset)
                    return false;
                  e6 = e6.buffer, t6 = t6.buffer;
                case ho:
                  return e6.byteLength == t6.byteLength && a5(new E3(e6), new E3(t6)) ? true : false;
                case Ka:
                case Ja:
                case no:
                  return yi(+e6, +t6);
                case Qa:
                  return e6.name == t6.name && e6.message == t6.message;
                case oo:
                case lo:
                  return e6 == t6 + "";
                case ro:
                  var s5 = Js;
                case so:
                  var l5 = 1 & n6;
                  if (s5 = s5 || tl, e6.size != t6.size && !l5)
                    return false;
                  l5 = o5.get(e6);
                  if (l5)
                    return l5 == t6;
                  n6 |= 2, o5.set(e6, t6);
                  s5 = Rr(s5(e6), s5(t6), n6, i6, a5, o5);
                  return o5.delete(e6), s5;
                case co:
                  if (he)
                    return he.call(e6) == he.call(t6);
              }
              return false;
            }(e5, t5, l4, r5, n5, i5, a4);
          if (!(1 & r5)) {
            u4 = u4 && _3.call(e5, "__wrapped__"), s4 = s4 && _3.call(t5, "__wrapped__");
            if (u4 || s4) {
              u4 = u4 ? e5.value() : e5, s4 = s4 ? t5.value() : t5;
              return a4 = a4 || new Se(), i5(u4, s4, r5, n5, a4);
            }
          }
          return c4 && (a4 = a4 || new Se(), function(e6, t6, r6, n6, i6, a5) {
            var o5 = 1 & r6, s5 = Or(e6), l5 = s5.length, c5 = Or(t6).length;
            if (l5 != c5 && !o5)
              return false;
            var u5 = l5;
            for (; u5--; ) {
              var h4 = s5[u5];
              if (!(o5 ? h4 in t6 : _3.call(t6, h4)))
                return false;
            }
            var d4 = a5.get(e6), c5 = a5.get(t6);
            if (d4 && c5)
              return d4 == t6 && c5 == e6;
            var p4 = true;
            a5.set(e6, t6), a5.set(t6, e6);
            var f4 = o5;
            for (; ++u5 < l5; ) {
              h4 = s5[u5];
              var m4, g4 = e6[h4], v5 = t6[h4];
              if (!((m4 = n6 ? o5 ? n6(v5, g4, h4, t6, e6, a5) : n6(g4, v5, h4, e6, t6, a5) : m4) === Ua ? g4 === v5 || i6(g4, v5, r6, n6, a5) : m4)) {
                p4 = false;
                break;
              }
              f4 = f4 || h4 == "constructor";
            }
            p4 && !f4 && (d4 = e6.constructor, c5 = t6.constructor, d4 != c5 && "constructor" in e6 && "constructor" in t6 && !(typeof d4 == "function" && d4 instanceof d4 && typeof c5 == "function" && c5 instanceof c5) && (p4 = false));
            return a5.delete(e6), a5.delete(t6), p4;
          }(e5, t5, r5, n5, i5, a4));
        }(e4, t4, r4, n4, ot, i4));
      }
      function st(e4, t4, r4, n4) {
        var i4 = r4.length, a4 = i4, o4 = !n4;
        if (e4 == null)
          return !a4;
        for (e4 = m3(e4); i4--; ) {
          var s4 = r4[i4];
          if (o4 && s4[2] ? s4[1] !== e4[s4[0]] : !(s4[0] in e4))
            return false;
        }
        for (; ++i4 < a4; ) {
          var l4 = (s4 = r4[i4])[0], c4 = e4[l4], u4 = s4[1];
          if (o4 && s4[2]) {
            if (c4 === Ua && !(l4 in e4))
              return false;
          } else {
            var h4, d4 = new Se();
            if (!((h4 = n4 ? n4(c4, u4, l4, e4, t4, d4) : h4) === Ua ? ot(u4, c4, 3, n4, d4) : h4))
              return false;
          }
        }
        return true;
      }
      function lt(e4) {
        return !(!Li(e4) || (t4 = e4, c3 && c3 in t4)) && (Ci(e4) ? x3 : Xo).test(gn(e4));
        var t4;
      }
      function ct(e4) {
        return typeof e4 == "function" ? e4 : e4 == null ? Oa : typeof e4 == "object" ? wi(e4) ? mt(e4[0], e4[1]) : ft(e4) : Na(e4);
      }
      function ut(e4) {
        if (!Qr(e4))
          return H2(e4);
        var t4, r4 = [];
        for (t4 in m3(e4))
          _3.call(e4, t4) && t4 != "constructor" && r4.push(t4);
        return r4;
      }
      function ht(e4) {
        if (!Li(e4))
          return function(e5) {
            var t5 = [];
            if (e5 != null)
              for (var r5 in m3(e5))
                t5.push(r5);
            return t5;
          }(e4);
        var t4, r4 = Qr(e4), n4 = [];
        for (t4 in e4)
          (t4 != "constructor" || !r4 && _3.call(e4, t4)) && n4.push(t4);
        return n4;
      }
      function dt(e4, t4) {
        return e4 < t4;
      }
      function pt(e4, n4) {
        var i4 = -1, a4 = Mi(e4) ? S3(e4.length) : [];
        return je(e4, function(e5, t4, r4) {
          a4[++i4] = n4(e5, t4, r4);
        }), a4;
      }
      function ft(t4) {
        var r4 = jr(t4);
        return r4.length == 1 && r4[0][2] ? tn(r4[0][0], r4[0][1]) : function(e4) {
          return e4 === t4 || st(e4, t4, r4);
        };
      }
      function mt(r4, n4) {
        return Zr(r4) && en(n4) ? tn(mn(r4), n4) : function(e4) {
          var t4 = ia(e4, r4);
          return t4 === Ua && t4 === n4 ? aa(e4, r4) : ot(n4, t4, 3);
        };
      }
      function gt(m4, g4, v5, y3, _4) {
        m4 !== g4 && We(g4, function(e4, t4) {
          var r4, n4, i4, a4, o4, s4, l4, c4, u4, h4, d4, p4, f4;
          _4 = _4 || new Se(), Li(e4) ? (n4 = g4, a4 = v5, o4 = gt, s4 = y3, l4 = _4, d4 = an(r4 = m4, i4 = t4), p4 = an(n4, i4), (f4 = l4.get(p4)) ? Ae(r4, i4, f4) : (c4 = s4 ? s4(d4, p4, i4 + "", r4, n4, l4) : Ua, (u4 = c4 === Ua) && (h4 = wi(p4), f4 = !h4 && Ti(p4), n4 = !h4 && !f4 && Ui(p4), c4 = p4, h4 || f4 || n4 ? c4 = wi(d4) ? d4 : Ei(d4) ? nr(d4) : f4 ? Kt(p4, !(u4 = false)) : n4 ? Qt(p4, !(u4 = false)) : [] : Di(p4) || xi(p4) ? xi(c4 = d4) ? c4 = Xi(d4) : Li(d4) && !Ci(d4) || (c4 = Wr(p4)) : u4 = false), u4 && (l4.set(p4, c4), o4(c4, p4, a4, s4, l4), l4.delete(p4)), Ae(r4, i4, c4))) : (c4 = y3 ? y3(an(m4, t4), e4, t4 + "", m4, g4, _4) : Ua, Ae(m4, t4, c4 = c4 === Ua ? e4 : c4));
        }, ua);
      }
      function vt(e4, t4) {
        var r4 = e4.length;
        if (r4)
          return Yr(t4 += t4 < 0 ? r4 : 0, r4) ? e4[t4] : Ua;
      }
      function yt(e4, n4, r4) {
        n4 = n4.length ? ks(n4, function(t4) {
          return wi(t4) ? function(e5) {
            return Ke(e5, t4.length === 1 ? t4[0] : t4);
          } : t4;
        }) : [Oa];
        var i4 = -1;
        return n4 = ks(n4, zs(Br())), function(e5, t4) {
          var r5 = e5.length;
          for (e5.sort(t4); r5--; )
            e5[r5] = e5[r5].value;
          return e5;
        }(pt(e4, function(t4, e5, r5) {
          return { criteria: ks(n4, function(e6) {
            return e6(t4);
          }), index: ++i4, value: t4 };
        }), function(e5, t4) {
          return function(e6, t5, r5) {
            var n5 = -1, i5 = e6.criteria, a4 = t5.criteria, o4 = i5.length, s4 = r5.length;
            for (; ++n5 < o4; ) {
              var l4 = er(i5[n5], a4[n5]);
              if (l4) {
                if (s4 <= n5)
                  return l4;
                var c4 = r5[n5];
                return l4 * (c4 == "desc" ? -1 : 1);
              }
            }
            return e6.index - t5.index;
          }(e5, t4, r4);
        });
      }
      function _t(e4, t4, r4) {
        for (var n4 = -1, i4 = t4.length, a4 = {}; ++n4 < i4; ) {
          var o4 = t4[n4], s4 = Ke(e4, o4);
          r4(s4, o4) && kt(a4, qt(o4, e4), s4);
        }
        return a4;
      }
      function bt(e4, t4, r4, n4) {
        var i4 = n4 ? Is : Ps, a4 = -1, o4 = t4.length, s4 = e4;
        for (e4 === t4 && (t4 = nr(t4)), r4 && (s4 = ks(e4, zs(r4))); ++a4 < o4; )
          for (var l4 = 0, c4 = t4[a4], u4 = r4 ? r4(c4) : c4; -1 < (l4 = i4(s4, u4, l4, n4)); )
            s4 !== e4 && $2.call(s4, l4, 1), $2.call(e4, l4, 1);
        return e4;
      }
      function xt(e4, t4) {
        for (var r4 = e4 ? t4.length : 0, n4 = r4 - 1; r4--; ) {
          var i4, a4 = t4[r4];
          r4 != n4 && a4 === i4 || (Yr(i4 = a4) ? $2.call(e4, a4, 1) : Ft(e4, a4));
        }
        return e4;
      }
      function wt(e4, t4) {
        return e4 + F(X() * (t4 - e4 + 1));
      }
      function St(e4, t4) {
        var r4 = "";
        if (!e4 || t4 < 1 || Ga2 < t4)
          return r4;
        for (; t4 % 2 && (r4 += e4), (t4 = F(t4 / 2)) && (e4 += e4), t4; )
          ;
        return r4;
      }
      function Mt(e4, t4) {
        return ln(rn(e4, t4, Oa), e4 + "");
      }
      function Et(e4) {
        return Ee(ya(e4));
      }
      function Tt(e4, t4) {
        e4 = ya(e4);
        return hn(e4, Ie(t4, 0, e4.length));
      }
      function kt(e4, t4, r4, n4) {
        if (!Li(e4))
          return e4;
        for (var i4 = -1, a4 = (t4 = qt(t4, e4)).length, o4 = a4 - 1, s4 = e4; s4 != null && ++i4 < a4; ) {
          var l4, c4 = mn(t4[i4]), u4 = r4;
          if (c4 === "__proto__" || c4 === "constructor" || c4 === "prototype")
            return e4;
          i4 != o4 && (l4 = s4[c4], (u4 = n4 ? n4(l4, c4, s4) : Ua) === Ua && (u4 = Li(l4) ? l4 : Yr(t4[i4 + 1]) ? [] : {})), Ce(s4, c4, u4), s4 = s4[c4];
        }
        return e4;
      }
      var At = ne ? function(e4, t4) {
        return ne.set(e4, t4), e4;
      } : Oa, Ct = P2 ? function(e4, t4) {
        return P2(e4, "toString", { configurable: true, enumerable: false, value: Ra(t4), writable: true });
      } : Oa;
      function $t(e4) {
        return hn(ya(e4));
      }
      function Rt(e4, t4, r4) {
        var n4 = -1, i4 = e4.length;
        (r4 = i4 < r4 ? i4 : r4) < 0 && (r4 += i4), i4 = r4 < (t4 = t4 < 0 ? i4 < -t4 ? 0 : i4 + t4 : t4) ? 0 : r4 - t4 >>> 0, t4 >>>= 0;
        for (var a4 = S3(i4); ++n4 < i4; )
          a4[n4] = e4[n4 + t4];
        return a4;
      }
      function Lt(e4, n4) {
        var i4;
        return je(e4, function(e5, t4, r4) {
          return !(i4 = n4(e5, t4, r4));
        }), !!i4;
      }
      function Ot(e4, t4, r4) {
        var n4 = 0, i4 = e4 == null ? n4 : e4.length;
        if (typeof t4 == "number" && t4 == t4 && i4 <= 2147483647) {
          for (; n4 < i4; ) {
            var a4 = n4 + i4 >>> 1, o4 = e4[a4];
            o4 !== null && !ji(o4) && (r4 ? o4 <= t4 : o4 < t4) ? n4 = 1 + a4 : i4 = a4;
          }
          return i4;
        }
        return Pt(e4, t4, Oa, r4);
      }
      function Pt(e4, t4, r4, n4) {
        var i4 = 0, a4 = e4 == null ? 0 : e4.length;
        if (a4 === 0)
          return 0;
        for (var o4 = (t4 = r4(t4)) != t4, s4 = t4 === null, l4 = ji(t4), c4 = t4 === Ua; i4 < a4; ) {
          var u4 = F((i4 + a4) / 2), h4 = r4(e4[u4]), d4 = h4 !== Ua, p4 = h4 === null, f4 = h4 == h4, m4 = ji(h4), h4 = o4 ? n4 || f4 : c4 ? f4 && (n4 || d4) : s4 ? f4 && d4 && (n4 || !p4) : l4 ? f4 && d4 && !p4 && (n4 || !m4) : !p4 && !m4 && (n4 ? h4 <= t4 : h4 < t4);
          h4 ? i4 = u4 + 1 : a4 = u4;
        }
        return W(a4, 4294967294);
      }
      function It(e4, t4) {
        for (var r4 = -1, n4 = e4.length, i4 = 0, a4 = []; ++r4 < n4; ) {
          var o4, s4 = e4[r4], l4 = t4 ? t4(s4) : s4;
          r4 && yi(l4, o4) || (o4 = l4, a4[i4++] = s4 === 0 ? 0 : s4);
        }
        return a4;
      }
      function Dt(e4) {
        return typeof e4 == "number" ? e4 : ji(e4) ? Wa : +e4;
      }
      function Nt(e4) {
        if (typeof e4 == "string")
          return e4;
        if (wi(e4))
          return ks(e4, Nt) + "";
        if (ji(e4))
          return de ? de.call(e4) : "";
        var t4 = e4 + "";
        return t4 == "0" && 1 / e4 == -1 / 0 ? "-0" : t4;
      }
      function Bt(e4, t4, r4) {
        var n4 = -1, i4 = Es, a4 = e4.length, o4 = true, s4 = [], l4 = s4;
        if (r4)
          o4 = false, i4 = Ts;
        else if (200 <= a4) {
          var c4 = t4 ? null : Er(e4);
          if (c4)
            return tl(c4);
          o4 = false, i4 = Gs, l4 = new we();
        } else
          l4 = t4 ? [] : s4;
        e:
          for (; ++n4 < a4; ) {
            var u4 = e4[n4], h4 = t4 ? t4(u4) : u4, u4 = r4 || u4 !== 0 ? u4 : 0;
            if (o4 && h4 == h4) {
              for (var d4 = l4.length; d4--; )
                if (l4[d4] === h4)
                  continue e;
              t4 && l4.push(h4), s4.push(u4);
            } else
              i4(l4, h4, r4) || (l4 !== s4 && l4.push(h4), s4.push(u4));
          }
        return s4;
      }
      function Ft(e4, t4) {
        return (e4 = nn(e4, t4 = qt(t4, e4))) == null || delete e4[mn(An(t4))];
      }
      function jt(e4, t4, r4, n4) {
        return kt(e4, t4, r4(Ke(e4, t4)), n4);
      }
      function Ut(e4, t4, r4, n4) {
        for (var i4 = e4.length, a4 = n4 ? i4 : -1; (n4 ? a4-- : ++a4 < i4) && t4(e4[a4], a4, e4); )
          ;
        return r4 ? Rt(e4, n4 ? 0 : a4, n4 ? a4 + 1 : i4) : Rt(e4, n4 ? a4 + 1 : 0, n4 ? i4 : a4);
      }
      function Vt(e4, t4) {
        var r4 = e4;
        return Cs(t4, function(e5, t5) {
          return t5.func.apply(t5.thisArg, As([e5], t5.args));
        }, r4 = e4 instanceof ye ? e4.value() : r4);
      }
      function zt(e4, t4, r4) {
        var n4 = e4.length;
        if (n4 < 2)
          return n4 ? Bt(e4[0]) : [];
        for (var i4 = -1, a4 = S3(n4); ++i4 < n4; )
          for (var o4 = e4[i4], s4 = -1; ++s4 < n4; )
            s4 != i4 && (a4[i4] = Fe(a4[i4] || o4, e4[s4], t4, r4));
        return Bt(Ge(a4, 1), t4, r4);
      }
      function Ht(e4, t4, r4) {
        for (var n4 = -1, i4 = e4.length, a4 = t4.length, o4 = {}; ++n4 < i4; ) {
          var s4 = n4 < a4 ? t4[n4] : Ua;
          r4(o4, e4[n4], s4);
        }
        return o4;
      }
      function Gt(e4) {
        return Ei(e4) ? e4 : [];
      }
      function Wt(e4) {
        return typeof e4 == "function" ? e4 : Oa;
      }
      function qt(e4, t4) {
        return wi(e4) ? e4 : Zr(e4, t4) ? [e4] : fn2(Zi(e4));
      }
      var Yt = Mt;
      function Xt(e4, t4, r4) {
        var n4 = e4.length;
        return r4 = r4 === Ua ? n4 : r4, !t4 && n4 <= r4 ? e4 : Rt(e4, t4, r4);
      }
      var Zt = I2 || function(e4) {
        return hs.clearTimeout(e4);
      };
      function Kt(e4, t4) {
        if (t4)
          return e4.slice();
        t4 = e4.length, t4 = T3 ? T3(t4) : new e4.constructor(t4);
        return e4.copy(t4), t4;
      }
      function Jt(e4) {
        var t4 = new e4.constructor(e4.byteLength);
        return new E3(t4).set(new E3(e4)), t4;
      }
      function Qt(e4, t4) {
        t4 = t4 ? Jt(e4.buffer) : e4.buffer;
        return new e4.constructor(t4, e4.byteOffset, e4.length);
      }
      function er(e4, t4) {
        if (e4 !== t4) {
          var r4 = e4 !== Ua, n4 = e4 === null, i4 = e4 == e4, a4 = ji(e4), o4 = t4 !== Ua, s4 = t4 === null, l4 = t4 == t4, c4 = ji(t4);
          if (!s4 && !c4 && !a4 && t4 < e4 || a4 && o4 && l4 && !s4 && !c4 || n4 && o4 && l4 || !r4 && l4 || !i4)
            return 1;
          if (!n4 && !a4 && !c4 && e4 < t4 || c4 && r4 && i4 && !n4 && !a4 || s4 && r4 && i4 || !o4 && i4 || !l4)
            return -1;
        }
        return 0;
      }
      function tr(e4, t4, r4, n4) {
        for (var i4 = -1, a4 = e4.length, o4 = r4.length, s4 = -1, l4 = t4.length, c4 = G(a4 - o4, 0), u4 = S3(l4 + c4), h4 = !n4; ++s4 < l4; )
          u4[s4] = t4[s4];
        for (; ++i4 < o4; )
          (h4 || i4 < a4) && (u4[r4[i4]] = e4[i4]);
        for (; c4--; )
          u4[s4++] = e4[i4++];
        return u4;
      }
      function rr(e4, t4, r4, n4) {
        for (var i4 = -1, a4 = e4.length, o4 = -1, s4 = r4.length, l4 = -1, c4 = t4.length, u4 = G(a4 - s4, 0), h4 = S3(u4 + c4), d4 = !n4; ++i4 < u4; )
          h4[i4] = e4[i4];
        for (var p4 = i4; ++l4 < c4; )
          h4[p4 + l4] = t4[l4];
        for (; ++o4 < s4; )
          (d4 || i4 < a4) && (h4[p4 + r4[o4]] = e4[i4++]);
        return h4;
      }
      function nr(e4, t4) {
        var r4 = -1, n4 = e4.length;
        for (t4 = t4 || S3(n4); ++r4 < n4; )
          t4[r4] = e4[r4];
        return t4;
      }
      function ir(e4, t4, r4, n4) {
        var i4 = !r4;
        r4 = r4 || {};
        for (var a4 = -1, o4 = t4.length; ++a4 < o4; ) {
          var s4 = t4[a4], l4 = n4 ? n4(r4[s4], e4[s4], s4, r4, e4) : Ua;
          (i4 ? Oe : Ce)(r4, s4, l4 = l4 === Ua ? e4[s4] : l4);
        }
        return r4;
      }
      function ar(i4, a4) {
        return function(e4, t4) {
          var r4 = wi(e4) ? bs : Re, n4 = a4 ? a4() : {};
          return r4(e4, i4, Br(t4, 2), n4);
        };
      }
      function or(s4) {
        return Mt(function(e4, t4) {
          var r4 = -1, n4 = t4.length, i4 = 1 < n4 ? t4[n4 - 1] : Ua, a4 = 2 < n4 ? t4[2] : Ua, i4 = 3 < s4.length && typeof i4 == "function" ? (n4--, i4) : Ua;
          for (a4 && Xr(t4[0], t4[1], a4) && (i4 = n4 < 3 ? Ua : i4, n4 = 1), e4 = m3(e4); ++r4 < n4; ) {
            var o4 = t4[r4];
            o4 && s4(e4, o4, r4, i4);
          }
          return e4;
        });
      }
      function sr(a4, o4) {
        return function(e4, t4) {
          if (e4 == null)
            return e4;
          if (!Mi(e4))
            return a4(e4, t4);
          for (var r4 = e4.length, n4 = o4 ? r4 : -1, i4 = m3(e4); (o4 ? n4-- : ++n4 < r4) && t4(i4[n4], n4, i4) !== false; )
            ;
          return e4;
        };
      }
      function lr(l4) {
        return function(e4, t4, r4) {
          for (var n4 = -1, i4 = m3(e4), a4 = r4(e4), o4 = a4.length; o4--; ) {
            var s4 = a4[l4 ? o4 : ++n4];
            if (t4(i4[s4], s4, i4) === false)
              break;
          }
          return e4;
        };
      }
      function cr(n4) {
        return function(e4) {
          var t4 = Ks(e4 = Zi(e4)) ? nl(e4) : Ua, r4 = t4 ? t4[0] : e4.charAt(0), e4 = t4 ? Xt(t4, 1).join("") : e4.slice(1);
          return r4[n4]() + e4;
        };
      }
      function ur(t4) {
        return function(e4) {
          return Cs(Ca(xa(e4).replace(ts, "")), t4, "");
        };
      }
      function hr(n4) {
        return function() {
          var e4 = arguments;
          switch (e4.length) {
            case 0:
              return new n4();
            case 1:
              return new n4(e4[0]);
            case 2:
              return new n4(e4[0], e4[1]);
            case 3:
              return new n4(e4[0], e4[1], e4[2]);
            case 4:
              return new n4(e4[0], e4[1], e4[2], e4[3]);
            case 5:
              return new n4(e4[0], e4[1], e4[2], e4[3], e4[4]);
            case 6:
              return new n4(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]);
            case 7:
              return new n4(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]);
          }
          var t4 = fe(n4.prototype), r4 = n4.apply(t4, e4);
          return Li(r4) ? r4 : t4;
        };
      }
      function dr(a4, o4, s4) {
        var l4 = hr(a4);
        return function e4() {
          for (var t4 = arguments.length, r4 = S3(t4), n4 = t4, i4 = Nr(e4); n4--; )
            r4[n4] = arguments[n4];
          i4 = t4 < 3 && r4[0] !== i4 && r4[t4 - 1] !== i4 ? [] : el(r4, i4);
          return (t4 -= i4.length) < s4 ? Sr(a4, o4, mr, e4.placeholder, Ua, r4, i4, Ua, Ua, s4 - t4) : _s(this && this !== hs && this instanceof e4 ? l4 : a4, this, r4);
        };
      }
      function pr(a4) {
        return function(e4, t4, r4) {
          var n4, i4 = m3(e4);
          Mi(e4) || (n4 = Br(t4, 3), e4 = ca(e4), t4 = function(e5) {
            return n4(i4[e5], e5, i4);
          });
          r4 = a4(e4, t4, r4);
          return -1 < r4 ? i4[n4 ? e4[r4] : r4] : Ua;
        };
      }
      function fr(l4) {
        return Lr(function(i4) {
          var a4 = i4.length, e4 = a4, t4 = ve.prototype.thru;
          for (l4 && i4.reverse(); e4--; ) {
            var r4 = i4[e4];
            if (typeof r4 != "function")
              throw new y2(Va);
            t4 && !s4 && Dr(r4) == "wrapper" && (s4 = new ve([], true));
          }
          for (e4 = s4 ? e4 : a4; ++e4 < a4; )
            var n4 = Dr(r4 = i4[e4]), o4 = n4 == "wrapper" ? Ir(r4) : Ua, s4 = o4 && Kr(o4[0]) && o4[1] == 424 && !o4[4].length && o4[9] == 1 ? s4[Dr(o4[0])].apply(s4, o4[3]) : r4.length == 1 && Kr(r4) ? s4[n4]() : s4.thru(r4);
          return function() {
            var e5 = arguments, t5 = e5[0];
            if (s4 && e5.length == 1 && wi(t5))
              return s4.plant(t5).value();
            for (var r5 = 0, n5 = a4 ? i4[r5].apply(this, e5) : t5; ++r5 < a4; )
              n5 = i4[r5].call(this, n5);
            return n5;
          };
        });
      }
      function mr(s4, l4, c4, u4, h4, d4, p4, f4, m4, g4) {
        var v5 = 128 & l4, y3 = 1 & l4, _4 = 2 & l4, b4 = 24 & l4, x4 = 512 & l4, w4 = _4 ? Ua : hr(s4);
        return function e4() {
          for (var t4, r4 = S3(o4 = arguments.length), n4 = o4; n4--; )
            r4[n4] = arguments[n4];
          if (b4 && (t4 = function(e5, t5) {
            for (var r5 = e5.length, n5 = 0; r5--; )
              e5[r5] === t5 && ++n5;
            return n5;
          }(r4, a4 = Nr(e4))), u4 && (r4 = tr(r4, u4, h4, b4)), d4 && (r4 = rr(r4, d4, p4, b4)), o4 -= t4, b4 && o4 < g4) {
            var i4 = el(r4, a4);
            return Sr(s4, l4, mr, e4.placeholder, c4, r4, i4, f4, m4, g4 - o4);
          }
          var a4 = y3 ? c4 : this, i4 = _4 ? a4[s4] : s4, o4 = r4.length;
          return f4 ? r4 = function(e5, t5) {
            for (var r5 = e5.length, n5 = W(t5.length, r5), i5 = nr(e5); n5--; ) {
              var a5 = t5[n5];
              e5[n5] = Yr(a5, r5) ? i5[a5] : Ua;
            }
            return e5;
          }(r4, f4) : x4 && 1 < o4 && r4.reverse(), v5 && m4 < o4 && (r4.length = m4), (i4 = this && this !== hs && this instanceof e4 ? w4 || hr(i4) : i4).apply(a4, r4);
        };
      }
      function gr(r4, o4) {
        return function(e4, t4) {
          return e4 = e4, n4 = r4, i4 = o4(t4), a4 = {}, Ye(e4, function(e5, t5, r5) {
            n4(a4, i4(e5), t5, r5);
          }), a4;
          var n4, i4, a4;
        };
      }
      function vr(n4, i4) {
        return function(e4, t4) {
          var r4;
          if (e4 === Ua && t4 === Ua)
            return i4;
          if (e4 !== Ua && (r4 = e4), t4 !== Ua) {
            if (r4 === Ua)
              return t4;
            t4 = typeof e4 == "string" || typeof t4 == "string" ? (e4 = Nt(e4), Nt(t4)) : (e4 = Dt(e4), Dt(t4)), r4 = n4(e4, t4);
          }
          return r4;
        };
      }
      function yr(n4) {
        return Lr(function(e4) {
          return e4 = ks(e4, zs(Br())), Mt(function(t4) {
            var r4 = this;
            return n4(e4, function(e5) {
              return _s(e5, r4, t4);
            });
          });
        });
      }
      function _r(e4, t4) {
        var r4 = (t4 = t4 === Ua ? " " : Nt(t4)).length;
        if (r4 < 2)
          return r4 ? St(t4, e4) : t4;
        r4 = St(t4, B(e4 / rl(t4)));
        return Ks(t4) ? Xt(nl(r4), 0, e4).join("") : r4.slice(0, e4);
      }
      function br(s4, e4, l4, c4) {
        var u4 = 1 & e4, h4 = hr(s4);
        return function e5() {
          for (var t4 = -1, r4 = arguments.length, n4 = -1, i4 = c4.length, a4 = S3(i4 + r4), o4 = this && this !== hs && this instanceof e5 ? h4 : s4; ++n4 < i4; )
            a4[n4] = c4[n4];
          for (; r4--; )
            a4[n4++] = arguments[++t4];
          return _s(o4, u4 ? l4 : this, a4);
        };
      }
      function xr(n4) {
        return function(e4, t4, r4) {
          return r4 && typeof r4 != "number" && Xr(e4, t4, r4) && (t4 = r4 = Ua), e4 = Gi(e4), t4 === Ua ? (t4 = e4, e4 = 0) : t4 = Gi(t4), function(e5, t5, r5, n5) {
            for (var i4 = -1, a4 = G(B((t5 - e5) / (r5 || 1)), 0), o4 = S3(a4); a4--; )
              o4[n5 ? a4 : ++i4] = e5, e5 += r5;
            return o4;
          }(e4, t4, r4 = r4 === Ua ? e4 < t4 ? 1 : -1 : Gi(r4), n4);
        };
      }
      function wr(r4) {
        return function(e4, t4) {
          return typeof e4 == "string" && typeof t4 == "string" || (e4 = Yi(e4), t4 = Yi(t4)), r4(e4, t4);
        };
      }
      function Sr(e4, t4, r4, n4, i4, a4, o4, s4, l4, c4) {
        var u4 = 8 & t4;
        t4 |= u4 ? 32 : 64, 4 & (t4 &= ~(u4 ? 64 : 32)) || (t4 &= -4);
        c4 = [e4, t4, i4, u4 ? a4 : Ua, u4 ? o4 : Ua, u4 ? Ua : a4, u4 ? Ua : o4, s4, l4, c4], r4 = r4.apply(Ua, c4);
        return Kr(e4) && on(r4, c4), r4.placeholder = n4, cn(r4, e4, t4);
      }
      function Mr(e4) {
        var n4 = i3[e4];
        return function(e5, t4) {
          if (e5 = Yi(e5), (t4 = t4 == null ? 0 : W(Wi(t4), 292)) && V2(e5)) {
            var r4 = (Zi(e5) + "e").split("e");
            return +((r4 = (Zi(n4(r4[0] + "e" + (+r4[1] + t4))) + "e").split("e"))[0] + "e" + (+r4[1] - t4));
          }
          return n4(e5);
        };
      }
      var Er = ee && 1 / tl(new ee([, -0]))[1] == 1 / 0 ? function(e4) {
        return new ee(e4);
      } : Da;
      function Tr(a4) {
        return function(e4) {
          var t4, r4, n4, i4 = Hr(e4);
          return i4 == ro ? Js(e4) : i4 == so ? (i4 = e4, t4 = -1, r4 = Array(i4.size), i4.forEach(function(e5) {
            r4[++t4] = [e5, e5];
          }), r4) : ks(a4(n4 = e4), function(e5) {
            return [e5, n4[e5]];
          });
        };
      }
      function kr(e4, t4, r4, n4, i4, a4, o4, s4) {
        var l4 = 2 & t4;
        if (!l4 && typeof e4 != "function")
          throw new y2(Va);
        var c4, u4, h4 = n4 ? n4.length : 0;
        h4 || (t4 &= -97, n4 = i4 = Ua), o4 = o4 === Ua ? o4 : G(Wi(o4), 0), s4 = s4 === Ua ? s4 : Wi(s4), h4 -= i4 ? i4.length : 0, 64 & t4 && (c4 = n4, u4 = i4, n4 = i4 = Ua);
        var d4, p4, f4, m4, g4 = l4 ? Ua : Ir(e4), o4 = [e4, t4, r4, n4, i4, c4, u4, a4, o4, s4];
        g4 && function(e5, t5) {
          var r5 = e5[1], n5 = t5[1], i5 = r5 | n5, a5 = i5 < 131, o5 = n5 == 128 && r5 == 8 || n5 == 128 && r5 == 256 && e5[7].length <= t5[8] || n5 == 384 && t5[7].length <= t5[8] && r5 == 8;
          if (!a5 && !o5)
            return;
          1 & n5 && (e5[2] = t5[2], i5 |= 1 & r5 ? 0 : 4);
          r5 = t5[3];
          {
            var s5;
            r5 && (s5 = e5[3], e5[3] = s5 ? tr(s5, r5, t5[4]) : r5, e5[4] = s5 ? el(e5[3], Ha2) : t5[4]);
          }
          (r5 = t5[5]) && (s5 = e5[5], e5[5] = s5 ? rr(s5, r5, t5[6]) : r5, e5[6] = s5 ? el(e5[5], Ha2) : t5[6]);
          (r5 = t5[7]) && (e5[7] = r5);
          128 & n5 && (e5[8] = e5[8] == null ? t5[8] : W(e5[8], t5[8]));
          e5[9] == null && (e5[9] = t5[9]);
          e5[0] = t5[0], e5[1] = i5;
        }(o4, g4), e4 = o4[0], t4 = o4[1], r4 = o4[2], n4 = o4[3], i4 = o4[4], !(s4 = o4[9] = o4[9] === Ua ? l4 ? 0 : e4.length : G(o4[9] - h4, 0)) && 24 & t4 && (t4 &= -25);
        r4 = t4 && t4 != 1 ? t4 == 8 || t4 == 16 ? dr(e4, t4, s4) : t4 != 32 && t4 != 33 || i4.length ? mr.apply(Ua, o4) : br(e4, t4, r4, n4) : (p4 = r4, f4 = 1 & t4, m4 = hr(d4 = e4), function e5() {
          return (this && this !== hs && this instanceof e5 ? m4 : d4).apply(f4 ? p4 : this, arguments);
        });
        return cn((g4 ? At : on)(r4, o4), e4, t4);
      }
      function Ar(e4, t4, r4, n4) {
        return e4 === Ua || yi(e4, f3[r4]) && !_3.call(n4, r4) ? t4 : e4;
      }
      function Cr(e4, t4, r4, n4, i4, a4) {
        return Li(e4) && Li(t4) && (a4.set(t4, e4), gt(e4, t4, Ua, Cr, a4), a4.delete(t4)), e4;
      }
      function $r(e4) {
        return Di(e4) ? Ua : e4;
      }
      function Rr(e4, t4, r4, n4, i4, a4) {
        var o4 = 1 & r4, s4 = e4.length, l4 = t4.length;
        if (s4 != l4 && !(o4 && s4 < l4))
          return false;
        var c4 = a4.get(e4), l4 = a4.get(t4);
        if (c4 && l4)
          return c4 == t4 && l4 == e4;
        var u4 = -1, h4 = true, d4 = 2 & r4 ? new we() : Ua;
        for (a4.set(e4, t4), a4.set(t4, e4); ++u4 < s4; ) {
          var p4, f4 = e4[u4], m4 = t4[u4];
          if ((p4 = n4 ? o4 ? n4(m4, f4, u4, t4, e4, a4) : n4(f4, m4, u4, e4, t4, a4) : p4) !== Ua) {
            if (p4)
              continue;
            h4 = false;
            break;
          }
          if (d4) {
            if (!Rs(t4, function(e5, t5) {
              return !Gs(d4, t5) && (f4 === e5 || i4(f4, e5, r4, n4, a4)) && d4.push(t5);
            })) {
              h4 = false;
              break;
            }
          } else if (f4 !== m4 && !i4(f4, m4, r4, n4, a4)) {
            h4 = false;
            break;
          }
        }
        return a4.delete(e4), a4.delete(t4), h4;
      }
      function Lr(e4) {
        return ln(rn(e4, Ua, Sn), e4 + "");
      }
      function Or(e4) {
        return Je(e4, ca, Vr);
      }
      function Pr(e4) {
        return Je(e4, ua, zr);
      }
      var Ir = ne ? function(e4) {
        return ne.get(e4);
      } : Da;
      function Dr(e4) {
        for (var t4 = e4.name + "", r4 = ie[t4], n4 = _3.call(ie, t4) ? r4.length : 0; n4--; ) {
          var i4 = r4[n4], a4 = i4.func;
          if (a4 == null || a4 == e4)
            return i4.name;
        }
        return t4;
      }
      function Nr(e4) {
        return (_3.call(pe, "placeholder") ? pe : e4).placeholder;
      }
      function Br() {
        var e4 = (e4 = pe.iteratee || Pa) === Pa ? ct : e4;
        return arguments.length ? e4(arguments[0], arguments[1]) : e4;
      }
      function Fr(e4, t4) {
        var r4, n4 = e4.__data__;
        return ((e4 = typeof (r4 = t4)) == "string" || e4 == "number" || e4 == "symbol" || e4 == "boolean" ? r4 !== "__proto__" : r4 === null) ? n4[typeof t4 == "string" ? "string" : "hash"] : n4.map;
      }
      function jr(e4) {
        for (var t4 = ca(e4), r4 = t4.length; r4--; ) {
          var n4 = t4[r4], i4 = e4[n4];
          t4[r4] = [n4, i4, en(i4)];
        }
        return t4;
      }
      function Ur(e4, t4) {
        t4 = t4, t4 = (e4 = e4) == null ? Ua : e4[t4];
        return lt(t4) ? t4 : Ua;
      }
      var Vr = j2 ? function(t4) {
        return t4 == null ? [] : (t4 = m3(t4), Ms(j2(t4), function(e4) {
          return C2.call(t4, e4);
        }));
      } : Ba, zr = j2 ? function(e4) {
        for (var t4 = []; e4; )
          As(t4, Vr(e4)), e4 = k3(e4);
        return t4;
      } : Ba, Hr = Qe;
      function Gr(e4, t4, r4) {
        for (var n4 = -1, i4 = (t4 = qt(t4, e4)).length, a4 = false; ++n4 < i4; ) {
          var o4 = mn(t4[n4]);
          if (!(a4 = e4 != null && r4(e4, o4)))
            break;
          e4 = e4[o4];
        }
        return a4 || ++n4 != i4 ? a4 : !!(i4 = e4 == null ? 0 : e4.length) && Ri(i4) && Yr(o4, i4) && (wi(e4) || xi(e4));
      }
      function Wr(e4) {
        return typeof e4.constructor != "function" || Qr(e4) ? {} : fe(k3(e4));
      }
      function qr(e4) {
        return wi(e4) || xi(e4) || !!(R2 && e4 && e4[R2]);
      }
      function Yr(e4, t4) {
        var r4 = typeof e4;
        return !!(t4 = t4 == null ? Ga2 : t4) && (r4 == "number" || r4 != "symbol" && Ko.test(e4)) && -1 < e4 && e4 % 1 == 0 && e4 < t4;
      }
      function Xr(e4, t4, r4) {
        if (Li(r4)) {
          var n4 = typeof t4;
          return (n4 == "number" ? Mi(r4) && Yr(t4, r4.length) : n4 == "string" && t4 in r4) && yi(r4[t4], e4);
        }
      }
      function Zr(e4, t4) {
        if (!wi(e4)) {
          var r4 = typeof e4;
          return r4 == "number" || r4 == "symbol" || r4 == "boolean" || e4 == null || ji(e4) || (Po.test(e4) || !Oo.test(e4) || t4 != null && e4 in m3(t4));
        }
      }
      function Kr(e4) {
        var t4 = Dr(e4), r4 = pe[t4];
        if (typeof r4 == "function" && t4 in ye.prototype) {
          if (e4 === r4)
            return 1;
          r4 = Ir(r4);
          return r4 && e4 === r4[0];
        }
      }
      (K && Hr(new K(new ArrayBuffer(1))) != po || J && Hr(new J()) != ro || Q && Hr(Q.resolve()) != ao || ee && Hr(new ee()) != so || te && Hr(new te()) != uo) && (Hr = function(e4) {
        var t4 = Qe(e4), e4 = t4 == io ? e4.constructor : Ua, e4 = e4 ? gn(e4) : "";
        if (e4)
          switch (e4) {
            case ae:
              return po;
            case oe:
              return ro;
            case se:
              return ao;
            case le:
              return so;
            case ce:
              return uo;
          }
        return t4;
      });
      var Jr = o3 ? Ci : Fa;
      function Qr(e4) {
        var t4 = e4 && e4.constructor;
        return e4 === (typeof t4 == "function" && t4.prototype || f3);
      }
      function en(e4) {
        return e4 == e4 && !Li(e4);
      }
      function tn(t4, r4) {
        return function(e4) {
          return e4 != null && (e4[t4] === r4 && (r4 !== Ua || t4 in m3(e4)));
        };
      }
      function rn(a4, o4, s4) {
        return o4 = G(o4 === Ua ? a4.length - 1 : o4, 0), function() {
          for (var e4 = arguments, t4 = -1, r4 = G(e4.length - o4, 0), n4 = S3(r4); ++t4 < r4; )
            n4[t4] = e4[o4 + t4];
          for (var t4 = -1, i4 = S3(o4 + 1); ++t4 < o4; )
            i4[t4] = e4[t4];
          return i4[o4] = s4(n4), _s(a4, this, i4);
        };
      }
      function nn(e4, t4) {
        return t4.length < 2 ? e4 : Ke(e4, Rt(t4, 0, -1));
      }
      function an(e4, t4) {
        if ((t4 !== "constructor" || typeof e4[t4] != "function") && t4 != "__proto__")
          return e4[t4];
      }
      var on = un(At), sn = N2 || function(e4, t4) {
        return hs.setTimeout(e4, t4);
      }, ln = un(Ct);
      function cn(e4, t4, r4) {
        var n4, i4, t4 = t4 + "";
        return ln(e4, function(e5, t5) {
          var r5 = t5.length;
          if (!r5)
            return e5;
          var n5 = r5 - 1;
          return t5[n5] = (1 < r5 ? "& " : "") + t5[n5], t5 = t5.join(2 < r5 ? ", " : " "), e5.replace(Fo, "{\n/* [wrapped with " + t5 + "] */\n");
        }(t4, (n4 = (t4 = (t4 = t4).match(jo)) ? t4[1].split(Uo) : [], i4 = r4, xs(Ya, function(e5) {
          var t5 = "_." + e5[0];
          i4 & e5[1] && !Es(n4, t5) && n4.push(t5);
        }), n4.sort())));
      }
      function un(r4) {
        var n4 = 0, i4 = 0;
        return function() {
          var e4 = q(), t4 = 16 - (e4 - i4);
          if (i4 = e4, 0 < t4) {
            if (800 <= ++n4)
              return arguments[0];
          } else
            n4 = 0;
          return r4.apply(Ua, arguments);
        };
      }
      function hn(e4, t4) {
        var r4 = -1, n4 = e4.length, i4 = n4 - 1;
        for (t4 = t4 === Ua ? n4 : t4; ++r4 < t4; ) {
          var a4 = wt(r4, i4), o4 = e4[a4];
          e4[a4] = e4[r4], e4[r4] = o4;
        }
        return e4.length = t4, e4;
      }
      var dn, pn, fn2 = (pn = (dn = di(dn = function(e4) {
        var i4 = [];
        return e4.charCodeAt(0) === 46 && i4.push(""), e4.replace(Io, function(e5, t4, r4, n4) {
          i4.push(r4 ? n4.replace(Ho, "$1") : t4 || e5);
        }), i4;
      }, function(e4) {
        return pn.size === 500 && pn.clear(), e4;
      })).cache, dn);
      function mn(e4) {
        if (typeof e4 == "string" || ji(e4))
          return e4;
        var t4 = e4 + "";
        return t4 == "0" && 1 / e4 == -1 / 0 ? "-0" : t4;
      }
      function gn(e4) {
        if (e4 != null) {
          try {
            return s3.call(e4);
          } catch (e5) {
          }
          try {
            return e4 + "";
          } catch (e5) {
          }
        }
        return "";
      }
      function vn(e4) {
        if (e4 instanceof ye)
          return e4.clone();
        var t4 = new ve(e4.__wrapped__, e4.__chain__);
        return t4.__actions__ = nr(e4.__actions__), t4.__index__ = e4.__index__, t4.__values__ = e4.__values__, t4;
      }
      var yn = Mt(function(e4, t4) {
        return Ei(e4) ? Fe(e4, Ge(t4, 1, Ei, true)) : [];
      }), _n = Mt(function(e4, t4) {
        var r4 = An(t4);
        return Ei(r4) && (r4 = Ua), Ei(e4) ? Fe(e4, Ge(t4, 1, Ei, true), Br(r4, 2)) : [];
      }), bn = Mt(function(e4, t4) {
        var r4 = An(t4);
        return Ei(r4) && (r4 = Ua), Ei(e4) ? Fe(e4, Ge(t4, 1, Ei, true), Ua, r4) : [];
      });
      function xn(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        if (!n4)
          return -1;
        r4 = r4 == null ? 0 : Wi(r4);
        return r4 < 0 && (r4 = G(n4 + r4, 0)), Os(e4, Br(t4, 3), r4);
      }
      function wn(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        if (!n4)
          return -1;
        var i4 = n4 - 1;
        return r4 !== Ua && (i4 = Wi(r4), i4 = r4 < 0 ? G(n4 + i4, 0) : W(i4, n4 - 1)), Os(e4, Br(t4, 3), i4, true);
      }
      function Sn(e4) {
        return (e4 == null ? 0 : e4.length) ? Ge(e4, 1) : [];
      }
      function Mn(e4) {
        return e4 && e4.length ? e4[0] : Ua;
      }
      var En = Mt(function(e4) {
        var t4 = ks(e4, Gt);
        return t4.length && t4[0] === e4[0] ? nt(t4) : [];
      }), Tn = Mt(function(e4) {
        var t4 = An(e4), r4 = ks(e4, Gt);
        return t4 === An(r4) ? t4 = Ua : r4.pop(), r4.length && r4[0] === e4[0] ? nt(r4, Br(t4, 2)) : [];
      }), kn = Mt(function(e4) {
        var t4 = An(e4), r4 = ks(e4, Gt);
        return (t4 = typeof t4 == "function" ? t4 : Ua) && r4.pop(), r4.length && r4[0] === e4[0] ? nt(r4, Ua, t4) : [];
      });
      function An(e4) {
        var t4 = e4 == null ? 0 : e4.length;
        return t4 ? e4[t4 - 1] : Ua;
      }
      var Cn = Mt($n);
      function $n(e4, t4) {
        return e4 && e4.length && t4 && t4.length ? bt(e4, t4) : e4;
      }
      var Rn = Lr(function(e4, t4) {
        var r4 = e4 == null ? 0 : e4.length, n4 = Pe(e4, t4);
        return xt(e4, ks(t4, function(e5) {
          return Yr(e5, r4) ? +e5 : e5;
        }).sort(er)), n4;
      });
      function Ln(e4) {
        return e4 == null ? e4 : Z.call(e4);
      }
      var On = Mt(function(e4) {
        return Bt(Ge(e4, 1, Ei, true));
      }), Pn = Mt(function(e4) {
        var t4 = An(e4);
        return Ei(t4) && (t4 = Ua), Bt(Ge(e4, 1, Ei, true), Br(t4, 2));
      }), In = Mt(function(e4) {
        var t4 = typeof (t4 = An(e4)) == "function" ? t4 : Ua;
        return Bt(Ge(e4, 1, Ei, true), Ua, t4);
      });
      function Dn(t4) {
        if (!t4 || !t4.length)
          return [];
        var r4 = 0;
        return t4 = Ms(t4, function(e4) {
          return Ei(e4) && (r4 = G(e4.length, r4), 1);
        }), Us(r4, function(e4) {
          return ks(t4, Bs(e4));
        });
      }
      function Nn(e4, t4) {
        if (!e4 || !e4.length)
          return [];
        e4 = Dn(e4);
        return t4 == null ? e4 : ks(e4, function(e5) {
          return _s(t4, Ua, e5);
        });
      }
      var Bn = Mt(function(e4, t4) {
        return Ei(e4) ? Fe(e4, t4) : [];
      }), Fn = Mt(function(e4) {
        return zt(Ms(e4, Ei));
      }), jn = Mt(function(e4) {
        var t4 = An(e4);
        return Ei(t4) && (t4 = Ua), zt(Ms(e4, Ei), Br(t4, 2));
      }), Un = Mt(function(e4) {
        var t4 = typeof (t4 = An(e4)) == "function" ? t4 : Ua;
        return zt(Ms(e4, Ei), Ua, t4);
      }), Vn = Mt(Dn);
      var zn = Mt(function(e4) {
        var t4 = e4.length, t4 = typeof (t4 = 1 < t4 ? e4[t4 - 1] : Ua) == "function" ? (e4.pop(), t4) : Ua;
        return Nn(e4, t4);
      });
      function Hn(e4) {
        e4 = pe(e4);
        return e4.__chain__ = true, e4;
      }
      function Gn(e4, t4) {
        return t4(e4);
      }
      var Wn = Lr(function(t4) {
        function e4(e5) {
          return Pe(e5, t4);
        }
        var r4 = t4.length, n4 = r4 ? t4[0] : 0, i4 = this.__wrapped__;
        return !(1 < r4 || this.__actions__.length) && i4 instanceof ye && Yr(n4) ? ((i4 = i4.slice(n4, +n4 + (r4 ? 1 : 0))).__actions__.push({ func: Gn, args: [e4], thisArg: Ua }), new ve(i4, this.__chain__).thru(function(e5) {
          return r4 && !e5.length && e5.push(Ua), e5;
        })) : this.thru(e4);
      });
      var qn = ar(function(e4, t4, r4) {
        _3.call(e4, r4) ? ++e4[r4] : Oe(e4, r4, 1);
      });
      var Yn = pr(xn), Xn = pr(wn);
      function Zn(e4, t4) {
        return (wi(e4) ? xs : je)(e4, Br(t4, 3));
      }
      function Kn(e4, t4) {
        return (wi(e4) ? ws : Ue)(e4, Br(t4, 3));
      }
      var Jn = ar(function(e4, t4, r4) {
        _3.call(e4, r4) ? e4[r4].push(t4) : Oe(e4, r4, [t4]);
      });
      var Qn = Mt(function(e4, t4, r4) {
        var n4 = -1, i4 = typeof t4 == "function", a4 = Mi(e4) ? S3(e4.length) : [];
        return je(e4, function(e5) {
          a4[++n4] = i4 ? _s(t4, e5, r4) : it(e5, t4, r4);
        }), a4;
      }), ei = ar(function(e4, t4, r4) {
        Oe(e4, r4, t4);
      });
      function ti(e4, t4) {
        return (wi(e4) ? ks : pt)(e4, Br(t4, 3));
      }
      var ri = ar(function(e4, t4, r4) {
        e4[r4 ? 0 : 1].push(t4);
      }, function() {
        return [[], []];
      });
      var ni = Mt(function(e4, t4) {
        if (e4 == null)
          return [];
        var r4 = t4.length;
        return 1 < r4 && Xr(e4, t4[0], t4[1]) ? t4 = [] : 2 < r4 && Xr(t4[0], t4[1], t4[2]) && (t4 = [t4[0]]), yt(e4, Ge(t4, 1), []);
      }), ii = D || function() {
        return hs.Date.now();
      };
      function ai(e4, t4, r4) {
        return t4 = r4 ? Ua : t4, t4 = e4 && t4 == null ? e4.length : t4, kr(e4, 128, Ua, Ua, Ua, Ua, t4);
      }
      function oi(e4, t4) {
        var r4;
        if (typeof t4 != "function")
          throw new y2(Va);
        return e4 = Wi(e4), function() {
          return 0 < --e4 && (r4 = t4.apply(this, arguments)), e4 <= 1 && (t4 = Ua), r4;
        };
      }
      var si = Mt(function(e4, t4, r4) {
        var n4, i4 = 1;
        return r4.length && (n4 = el(r4, Nr(si)), i4 |= 32), kr(e4, i4, t4, r4, n4);
      }), li = Mt(function(e4, t4, r4) {
        var n4, i4 = 3;
        return r4.length && (n4 = el(r4, Nr(li)), i4 |= 32), kr(t4, i4, e4, r4, n4);
      });
      function ci(n4, r4, e4) {
        var i4, a4, o4, s4, l4, c4, u4 = 0, h4 = false, d4 = false, t4 = true;
        if (typeof n4 != "function")
          throw new y2(Va);
        function p4(e5) {
          var t5 = i4, r5 = a4;
          return i4 = a4 = Ua, u4 = e5, s4 = n4.apply(r5, t5);
        }
        function f4(e5) {
          var t5 = e5 - c4;
          return c4 === Ua || r4 <= t5 || t5 < 0 || d4 && o4 <= e5 - u4;
        }
        function m4() {
          var e5, t5 = ii();
          if (f4(t5))
            return g4(t5);
          l4 = sn(m4, (t5 = r4 - ((e5 = t5) - c4), d4 ? W(t5, o4 - (e5 - u4)) : t5));
        }
        function g4(e5) {
          return l4 = Ua, t4 && i4 ? p4(e5) : (i4 = a4 = Ua, s4);
        }
        function v5() {
          var e5 = ii(), t5 = f4(e5);
          if (i4 = arguments, a4 = this, c4 = e5, t5) {
            if (l4 === Ua)
              return u4 = t5 = c4, l4 = sn(m4, r4), h4 ? p4(t5) : s4;
            if (d4)
              return Zt(l4), l4 = sn(m4, r4), p4(c4);
          }
          return l4 === Ua && (l4 = sn(m4, r4)), s4;
        }
        return r4 = Yi(r4) || 0, Li(e4) && (h4 = !!e4.leading, d4 = "maxWait" in e4, o4 = d4 ? G(Yi(e4.maxWait) || 0, r4) : o4, t4 = "trailing" in e4 ? !!e4.trailing : t4), v5.cancel = function() {
          l4 !== Ua && Zt(l4), u4 = 0, i4 = c4 = a4 = l4 = Ua;
        }, v5.flush = function() {
          return l4 === Ua ? s4 : g4(ii());
        }, v5;
      }
      var ui = Mt(function(e4, t4) {
        return Be(e4, 1, t4);
      }), hi = Mt(function(e4, t4, r4) {
        return Be(e4, Yi(t4) || 0, r4);
      });
      function di(n4, i4) {
        if (typeof n4 != "function" || i4 != null && typeof i4 != "function")
          throw new y2(Va);
        function a4() {
          var e4 = arguments, t4 = i4 ? i4.apply(this, e4) : e4[0], r4 = a4.cache;
          return r4.has(t4) ? r4.get(t4) : (e4 = n4.apply(this, e4), a4.cache = r4.set(t4, e4) || r4, e4);
        }
        return a4.cache = new (di.Cache || xe)(), a4;
      }
      function pi(t4) {
        if (typeof t4 != "function")
          throw new y2(Va);
        return function() {
          var e4 = arguments;
          switch (e4.length) {
            case 0:
              return !t4.call(this);
            case 1:
              return !t4.call(this, e4[0]);
            case 2:
              return !t4.call(this, e4[0], e4[1]);
            case 3:
              return !t4.call(this, e4[0], e4[1], e4[2]);
          }
          return !t4.apply(this, e4);
        };
      }
      di.Cache = xe;
      var fi = Yt(function(n4, i4) {
        var a4 = (i4 = i4.length == 1 && wi(i4[0]) ? ks(i4[0], zs(Br())) : ks(Ge(i4, 1), zs(Br()))).length;
        return Mt(function(e4) {
          for (var t4 = -1, r4 = W(e4.length, a4); ++t4 < r4; )
            e4[t4] = i4[t4].call(this, e4[t4]);
          return _s(n4, this, e4);
        });
      }), mi = Mt(function(e4, t4) {
        var r4 = el(t4, Nr(mi));
        return kr(e4, 32, Ua, t4, r4);
      }), gi = Mt(function(e4, t4) {
        var r4 = el(t4, Nr(gi));
        return kr(e4, 64, Ua, t4, r4);
      }), vi = Lr(function(e4, t4) {
        return kr(e4, 256, Ua, Ua, Ua, t4);
      });
      function yi(e4, t4) {
        return e4 === t4 || e4 != e4 && t4 != t4;
      }
      var _i = wr(et), bi = wr(function(e4, t4) {
        return t4 <= e4;
      }), xi = at(function() {
        return arguments;
      }()) ? at : function(e4) {
        return Oi(e4) && _3.call(e4, "callee") && !C2.call(e4, "callee");
      }, wi = S3.isArray, Si = ps ? zs(ps) : function(e4) {
        return Oi(e4) && Qe(e4) == ho;
      };
      function Mi(e4) {
        return e4 != null && Ri(e4.length) && !Ci(e4);
      }
      function Ei(e4) {
        return Oi(e4) && Mi(e4);
      }
      var Ti = U || Fa, ki = fs ? zs(fs) : function(e4) {
        return Oi(e4) && Qe(e4) == Ja;
      };
      function Ai(e4) {
        if (!Oi(e4))
          return false;
        var t4 = Qe(e4);
        return t4 == Qa || t4 == "[object DOMException]" || typeof e4.message == "string" && typeof e4.name == "string" && !Di(e4);
      }
      function Ci(e4) {
        if (!Li(e4))
          return false;
        e4 = Qe(e4);
        return e4 == eo || e4 == to2 || e4 == "[object AsyncFunction]" || e4 == "[object Proxy]";
      }
      function $i(e4) {
        return typeof e4 == "number" && e4 == Wi(e4);
      }
      function Ri(e4) {
        return typeof e4 == "number" && -1 < e4 && e4 % 1 == 0 && e4 <= Ga2;
      }
      function Li(e4) {
        var t4 = typeof e4;
        return e4 != null && (t4 == "object" || t4 == "function");
      }
      function Oi(e4) {
        return e4 != null && typeof e4 == "object";
      }
      var Pi = ms ? zs(ms) : function(e4) {
        return Oi(e4) && Hr(e4) == ro;
      };
      function Ii(e4) {
        return typeof e4 == "number" || Oi(e4) && Qe(e4) == no;
      }
      function Di(e4) {
        if (!Oi(e4) || Qe(e4) != io)
          return false;
        e4 = k3(e4);
        if (e4 === null)
          return true;
        e4 = _3.call(e4, "constructor") && e4.constructor;
        return typeof e4 == "function" && e4 instanceof e4 && s3.call(e4) == v3;
      }
      var Ni = gs ? zs(gs) : function(e4) {
        return Oi(e4) && Qe(e4) == oo;
      };
      var Bi = vs ? zs(vs) : function(e4) {
        return Oi(e4) && Hr(e4) == so;
      };
      function Fi(e4) {
        return typeof e4 == "string" || !wi(e4) && Oi(e4) && Qe(e4) == lo;
      }
      function ji(e4) {
        return typeof e4 == "symbol" || Oi(e4) && Qe(e4) == co;
      }
      var Ui = ys ? zs(ys) : function(e4) {
        return Oi(e4) && Ri(e4.length) && !!ss[Qe(e4)];
      };
      var Vi = wr(dt), zi = wr(function(e4, t4) {
        return e4 <= t4;
      });
      function Hi(e4) {
        if (!e4)
          return [];
        if (Mi(e4))
          return (Fi(e4) ? nl : nr)(e4);
        if (L && e4[L])
          return function(e5) {
            for (var t5, r4 = []; !(t5 = e5.next()).done; )
              r4.push(t5.value);
            return r4;
          }(e4[L]());
        var t4 = Hr(e4);
        return (t4 == ro ? Js : t4 == so ? tl : ya)(e4);
      }
      function Gi(e4) {
        return e4 ? (e4 = Yi(e4)) !== 1 / 0 && e4 !== -1 / 0 ? e4 == e4 ? e4 : 0 : 17976931348623157e292 * (e4 < 0 ? -1 : 1) : e4 === 0 ? e4 : 0;
      }
      function Wi(e4) {
        var t4 = Gi(e4), e4 = t4 % 1;
        return t4 == t4 ? e4 ? t4 - e4 : t4 : 0;
      }
      function qi(e4) {
        return e4 ? Ie(Wi(e4), 0, qa) : 0;
      }
      function Yi(e4) {
        if (typeof e4 == "number")
          return e4;
        if (ji(e4))
          return Wa;
        if (typeof (e4 = Li(e4) ? Li(t4 = typeof e4.valueOf == "function" ? e4.valueOf() : e4) ? t4 + "" : t4 : e4) != "string")
          return e4 === 0 ? e4 : +e4;
        e4 = Vs(e4);
        var t4 = Yo.test(e4);
        return t4 || Zo.test(e4) ? us(e4.slice(2), t4 ? 2 : 8) : qo.test(e4) ? Wa : +e4;
      }
      function Xi(e4) {
        return ir(e4, ua(e4));
      }
      function Zi(e4) {
        return e4 == null ? "" : Nt(e4);
      }
      var Ki = or(function(e4, t4) {
        if (Qr(t4) || Mi(t4))
          ir(t4, ca(t4), e4);
        else
          for (var r4 in t4)
            _3.call(t4, r4) && Ce(e4, r4, t4[r4]);
      }), Ji = or(function(e4, t4) {
        ir(t4, ua(t4), e4);
      }), Qi = or(function(e4, t4, r4, n4) {
        ir(t4, ua(t4), e4, n4);
      }), ea = or(function(e4, t4, r4, n4) {
        ir(t4, ca(t4), e4, n4);
      }), ta = Lr(Pe);
      var ra = Mt(function(e4, t4) {
        e4 = m3(e4);
        var r4 = -1, n4 = t4.length, i4 = 2 < n4 ? t4[2] : Ua;
        for (i4 && Xr(t4[0], t4[1], i4) && (n4 = 1); ++r4 < n4; )
          for (var a4 = t4[r4], o4 = ua(a4), s4 = -1, l4 = o4.length; ++s4 < l4; ) {
            var c4 = o4[s4], u4 = e4[c4];
            (u4 === Ua || yi(u4, f3[c4]) && !_3.call(e4, c4)) && (e4[c4] = a4[c4]);
          }
        return e4;
      }), na = Mt(function(e4) {
        return e4.push(Ua, Cr), _s(da, Ua, e4);
      });
      function ia(e4, t4, r4) {
        t4 = e4 == null ? Ua : Ke(e4, t4);
        return t4 === Ua ? r4 : t4;
      }
      function aa(e4, t4) {
        return e4 != null && Gr(e4, t4, rt);
      }
      var oa = gr(function(e4, t4, r4) {
        e4[t4 = t4 != null && typeof t4.toString != "function" ? g3.call(t4) : t4] = r4;
      }, Ra(Oa)), sa = gr(function(e4, t4, r4) {
        t4 != null && typeof t4.toString != "function" && (t4 = g3.call(t4)), _3.call(e4, t4) ? e4[t4].push(r4) : e4[t4] = [r4];
      }, Br), la = Mt(it);
      function ca(e4) {
        return (Mi(e4) ? Me : ut)(e4);
      }
      function ua(e4) {
        return Mi(e4) ? Me(e4, true) : ht(e4);
      }
      var ha = or(function(e4, t4, r4) {
        gt(e4, t4, r4);
      }), da = or(function(e4, t4, r4, n4) {
        gt(e4, t4, r4, n4);
      }), pa = Lr(function(t4, e4) {
        var r4 = {};
        if (t4 == null)
          return r4;
        var n4 = false;
        e4 = ks(e4, function(e5) {
          return e5 = qt(e5, t4), n4 = n4 || 1 < e5.length, e5;
        }), ir(t4, Pr(t4), r4), n4 && (r4 = De(r4, 7, $r));
        for (var i4 = e4.length; i4--; )
          Ft(r4, e4[i4]);
        return r4;
      });
      var fa = Lr(function(e4, t4) {
        return e4 == null ? {} : _t(r4 = e4, t4, function(e5, t5) {
          return aa(r4, t5);
        });
        var r4;
      });
      function ma(e4, r4) {
        if (e4 == null)
          return {};
        var t4 = ks(Pr(e4), function(e5) {
          return [e5];
        });
        return r4 = Br(r4), _t(e4, t4, function(e5, t5) {
          return r4(e5, t5[0]);
        });
      }
      var ga = Tr(ca), va = Tr(ua);
      function ya(e4) {
        return e4 == null ? [] : Hs(e4, ca(e4));
      }
      var _a2 = ur(function(e4, t4, r4) {
        return t4 = t4.toLowerCase(), e4 + (r4 ? ba(t4) : t4);
      });
      function ba(e4) {
        return Aa(Zi(e4).toLowerCase());
      }
      function xa(e4) {
        return (e4 = Zi(e4)) && e4.replace(Jo, Ys).replace(rs, "");
      }
      var wa = ur(function(e4, t4, r4) {
        return e4 + (r4 ? "-" : "") + t4.toLowerCase();
      }), Sa = ur(function(e4, t4, r4) {
        return e4 + (r4 ? " " : "") + t4.toLowerCase();
      }), Ma = cr("toLowerCase");
      var Ea = ur(function(e4, t4, r4) {
        return e4 + (r4 ? "_" : "") + t4.toLowerCase();
      });
      var Ta = ur(function(e4, t4, r4) {
        return e4 + (r4 ? " " : "") + Aa(t4);
      });
      var ka = ur(function(e4, t4, r4) {
        return e4 + (r4 ? " " : "") + t4.toUpperCase();
      }), Aa = cr("toUpperCase");
      function Ca(e4, t4, r4) {
        return e4 = Zi(e4), (t4 = r4 ? Ua : t4) === Ua ? (r4 = e4, is.test(r4) ? e4.match(ns) || [] : e4.match(Vo) || []) : e4.match(t4) || [];
      }
      var $a = Mt(function(e4, t4) {
        try {
          return _s(e4, Ua, t4);
        } catch (e5) {
          return Ai(e5) ? e5 : new h3(e5);
        }
      }), n3 = Lr(function(t4, e4) {
        return xs(e4, function(e5) {
          e5 = mn(e5), Oe(t4, e5, si(t4[e5], t4));
        }), t4;
      });
      function Ra(e4) {
        return function() {
          return e4;
        };
      }
      var La = fr(), w3 = fr(true);
      function Oa(e4) {
        return e4;
      }
      function Pa(e4) {
        return ct(typeof e4 == "function" ? e4 : De(e4, 1));
      }
      r3 = Mt(function(t4, r4) {
        return function(e4) {
          return it(e4, t4, r4);
        };
      }), t3 = Mt(function(t4, r4) {
        return function(e4) {
          return it(t4, e4, r4);
        };
      });
      function Ia(n4, t4, e4) {
        var r4 = ca(t4), i4 = Ze(t4, r4);
        e4 != null || Li(t4) && (i4.length || !r4.length) || (e4 = t4, t4 = n4, n4 = this, i4 = Ze(t4, ca(t4)));
        var a4 = !(Li(e4) && "chain" in e4 && !e4.chain), o4 = Ci(n4);
        return xs(i4, function(e5) {
          var r5 = t4[e5];
          n4[e5] = r5, o4 && (n4.prototype[e5] = function() {
            var e6 = this.__chain__;
            if (a4 || e6) {
              var t5 = n4(this.__wrapped__);
              return (t5.__actions__ = nr(this.__actions__)).push({ func: r5, args: arguments, thisArg: n4 }), t5.__chain__ = e6, t5;
            }
            return r5.apply(n4, As([this.value()], arguments));
          });
        }), n4;
      }
      function Da() {
      }
      M3 = yr(ks), ue = yr(Ss), I2 = yr(Rs);
      function Na(e4) {
        return Zr(e4) ? Bs(mn(e4)) : (t4 = e4, function(e5) {
          return Ke(e5, t4);
        });
        var t4;
      }
      K = xr(), Q = xr(true);
      function Ba() {
        return [];
      }
      function Fa() {
        return false;
      }
      te = vr(function(e4, t4) {
        return e4 + t4;
      }, 0), o3 = Mr("ceil"), N2 = vr(function(e4, t4) {
        return e4 / t4;
      }, 1), Ct = Mr("floor");
      var ja, D = vr(function(e4, t4) {
        return e4 * t4;
      }, 1), Yt = Mr("round"), U = vr(function(e4, t4) {
        return e4 - t4;
      }, 0);
      return pe.after = function(e4, t4) {
        if (typeof t4 != "function")
          throw new y2(Va);
        return e4 = Wi(e4), function() {
          if (--e4 < 1)
            return t4.apply(this, arguments);
        };
      }, pe.ary = ai, pe.assign = Ki, pe.assignIn = Ji, pe.assignInWith = Qi, pe.assignWith = ea, pe.at = ta, pe.before = oi, pe.bind = si, pe.bindAll = n3, pe.bindKey = li, pe.castArray = function() {
        if (!arguments.length)
          return [];
        var e4 = arguments[0];
        return wi(e4) ? e4 : [e4];
      }, pe.chain = Hn, pe.chunk = function(e4, t4, r4) {
        t4 = (r4 ? Xr(e4, t4, r4) : t4 === Ua) ? 1 : G(Wi(t4), 0);
        var n4 = e4 == null ? 0 : e4.length;
        if (!n4 || t4 < 1)
          return [];
        for (var i4 = 0, a4 = 0, o4 = S3(B(n4 / t4)); i4 < n4; )
          o4[a4++] = Rt(e4, i4, i4 += t4);
        return o4;
      }, pe.compact = function(e4) {
        for (var t4 = -1, r4 = e4 == null ? 0 : e4.length, n4 = 0, i4 = []; ++t4 < r4; ) {
          var a4 = e4[t4];
          a4 && (i4[n4++] = a4);
        }
        return i4;
      }, pe.concat = function() {
        var e4 = arguments.length;
        if (!e4)
          return [];
        for (var t4 = S3(e4 - 1), r4 = arguments[0], n4 = e4; n4--; )
          t4[n4 - 1] = arguments[n4];
        return As(wi(r4) ? nr(r4) : [r4], Ge(t4, 1));
      }, pe.cond = function(n4) {
        var i4 = n4 == null ? 0 : n4.length, t4 = Br();
        return n4 = i4 ? ks(n4, function(e4) {
          if (typeof e4[1] != "function")
            throw new y2(Va);
          return [t4(e4[0]), e4[1]];
        }) : [], Mt(function(e4) {
          for (var t5 = -1; ++t5 < i4; ) {
            var r4 = n4[t5];
            if (_s(r4[0], this, e4))
              return _s(r4[1], this, e4);
          }
        });
      }, pe.conforms = function(e4) {
        return t4 = De(e4, 1), r4 = ca(t4), function(e5) {
          return Ne(e5, t4, r4);
        };
        var t4, r4;
      }, pe.constant = Ra, pe.countBy = qn, pe.create = function(e4, t4) {
        return e4 = fe(e4), t4 == null ? e4 : Le(e4, t4);
      }, pe.curry = function e4(t4, r4, n4) {
        r4 = kr(t4, 8, Ua, Ua, Ua, Ua, Ua, r4 = n4 ? Ua : r4);
        return r4.placeholder = e4.placeholder, r4;
      }, pe.curryRight = function e4(t4, r4, n4) {
        r4 = kr(t4, 16, Ua, Ua, Ua, Ua, Ua, r4 = n4 ? Ua : r4);
        return r4.placeholder = e4.placeholder, r4;
      }, pe.debounce = ci, pe.defaults = ra, pe.defaultsDeep = na, pe.defer = ui, pe.delay = hi, pe.difference = yn, pe.differenceBy = _n, pe.differenceWith = bn, pe.drop = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        return n4 ? Rt(e4, (t4 = r4 || t4 === Ua ? 1 : Wi(t4)) < 0 ? 0 : t4, n4) : [];
      }, pe.dropRight = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        return n4 ? Rt(e4, 0, (t4 = n4 - (t4 = r4 || t4 === Ua ? 1 : Wi(t4))) < 0 ? 0 : t4) : [];
      }, pe.dropRightWhile = function(e4, t4) {
        return e4 && e4.length ? Ut(e4, Br(t4, 3), true, true) : [];
      }, pe.dropWhile = function(e4, t4) {
        return e4 && e4.length ? Ut(e4, Br(t4, 3), true) : [];
      }, pe.fill = function(e4, t4, r4, n4) {
        var i4 = e4 == null ? 0 : e4.length;
        return i4 ? (r4 && typeof r4 != "number" && Xr(e4, t4, r4) && (r4 = 0, n4 = i4), function(e5, t5, r5, n5) {
          var i5 = e5.length;
          for ((r5 = Wi(r5)) < 0 && (r5 = i5 < -r5 ? 0 : i5 + r5), (n5 = n5 === Ua || i5 < n5 ? i5 : Wi(n5)) < 0 && (n5 += i5), n5 = n5 < r5 ? 0 : qi(n5); r5 < n5; )
            e5[r5++] = t5;
          return e5;
        }(e4, t4, r4, n4)) : [];
      }, pe.filter = function(e4, t4) {
        return (wi(e4) ? Ms : He)(e4, Br(t4, 3));
      }, pe.flatMap = function(e4, t4) {
        return Ge(ti(e4, t4), 1);
      }, pe.flatMapDeep = function(e4, t4) {
        return Ge(ti(e4, t4), 1 / 0);
      }, pe.flatMapDepth = function(e4, t4, r4) {
        return r4 = r4 === Ua ? 1 : Wi(r4), Ge(ti(e4, t4), r4);
      }, pe.flatten = Sn, pe.flattenDeep = function(e4) {
        return (e4 == null ? 0 : e4.length) ? Ge(e4, 1 / 0) : [];
      }, pe.flattenDepth = function(e4, t4) {
        return (e4 == null ? 0 : e4.length) ? Ge(e4, t4 = t4 === Ua ? 1 : Wi(t4)) : [];
      }, pe.flip = function(e4) {
        return kr(e4, 512);
      }, pe.flow = La, pe.flowRight = w3, pe.fromPairs = function(e4) {
        for (var t4 = -1, r4 = e4 == null ? 0 : e4.length, n4 = {}; ++t4 < r4; ) {
          var i4 = e4[t4];
          n4[i4[0]] = i4[1];
        }
        return n4;
      }, pe.functions = function(e4) {
        return e4 == null ? [] : Ze(e4, ca(e4));
      }, pe.functionsIn = function(e4) {
        return e4 == null ? [] : Ze(e4, ua(e4));
      }, pe.groupBy = Jn, pe.initial = function(e4) {
        return (e4 == null ? 0 : e4.length) ? Rt(e4, 0, -1) : [];
      }, pe.intersection = En, pe.intersectionBy = Tn, pe.intersectionWith = kn, pe.invert = oa, pe.invertBy = sa, pe.invokeMap = Qn, pe.iteratee = Pa, pe.keyBy = ei, pe.keys = ca, pe.keysIn = ua, pe.map = ti, pe.mapKeys = function(e4, n4) {
        var i4 = {};
        return n4 = Br(n4, 3), Ye(e4, function(e5, t4, r4) {
          Oe(i4, n4(e5, t4, r4), e5);
        }), i4;
      }, pe.mapValues = function(e4, n4) {
        var i4 = {};
        return n4 = Br(n4, 3), Ye(e4, function(e5, t4, r4) {
          Oe(i4, t4, n4(e5, t4, r4));
        }), i4;
      }, pe.matches = function(e4) {
        return ft(De(e4, 1));
      }, pe.matchesProperty = function(e4, t4) {
        return mt(e4, De(t4, 1));
      }, pe.memoize = di, pe.merge = ha, pe.mergeWith = da, pe.method = r3, pe.methodOf = t3, pe.mixin = Ia, pe.negate = pi, pe.nthArg = function(t4) {
        return t4 = Wi(t4), Mt(function(e4) {
          return vt(e4, t4);
        });
      }, pe.omit = pa, pe.omitBy = function(e4, t4) {
        return ma(e4, pi(Br(t4)));
      }, pe.once = function(e4) {
        return oi(2, e4);
      }, pe.orderBy = function(e4, t4, r4, n4) {
        return e4 == null ? [] : yt(e4, t4 = !wi(t4) ? t4 == null ? [] : [t4] : t4, r4 = !wi(r4 = n4 ? Ua : r4) ? r4 == null ? [] : [r4] : r4);
      }, pe.over = M3, pe.overArgs = fi, pe.overEvery = ue, pe.overSome = I2, pe.partial = mi, pe.partialRight = gi, pe.partition = ri, pe.pick = fa, pe.pickBy = ma, pe.property = Na, pe.propertyOf = function(t4) {
        return function(e4) {
          return t4 == null ? Ua : Ke(t4, e4);
        };
      }, pe.pull = Cn, pe.pullAll = $n, pe.pullAllBy = function(e4, t4, r4) {
        return e4 && e4.length && t4 && t4.length ? bt(e4, t4, Br(r4, 2)) : e4;
      }, pe.pullAllWith = function(e4, t4, r4) {
        return e4 && e4.length && t4 && t4.length ? bt(e4, t4, Ua, r4) : e4;
      }, pe.pullAt = Rn, pe.range = K, pe.rangeRight = Q, pe.rearg = vi, pe.reject = function(e4, t4) {
        return (wi(e4) ? Ms : He)(e4, pi(Br(t4, 3)));
      }, pe.remove = function(e4, t4) {
        var r4 = [];
        if (!e4 || !e4.length)
          return r4;
        var n4 = -1, i4 = [], a4 = e4.length;
        for (t4 = Br(t4, 3); ++n4 < a4; ) {
          var o4 = e4[n4];
          t4(o4, n4, e4) && (r4.push(o4), i4.push(n4));
        }
        return xt(e4, i4), r4;
      }, pe.rest = function(e4, t4) {
        if (typeof e4 != "function")
          throw new y2(Va);
        return Mt(e4, t4 = t4 === Ua ? t4 : Wi(t4));
      }, pe.reverse = Ln, pe.sampleSize = function(e4, t4, r4) {
        return t4 = (r4 ? Xr(e4, t4, r4) : t4 === Ua) ? 1 : Wi(t4), (wi(e4) ? Te : Tt)(e4, t4);
      }, pe.set = function(e4, t4, r4) {
        return e4 == null ? e4 : kt(e4, t4, r4);
      }, pe.setWith = function(e4, t4, r4, n4) {
        return n4 = typeof n4 == "function" ? n4 : Ua, e4 == null ? e4 : kt(e4, t4, r4, n4);
      }, pe.shuffle = function(e4) {
        return (wi(e4) ? ke : $t)(e4);
      }, pe.slice = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        return n4 ? (r4 = r4 && typeof r4 != "number" && Xr(e4, t4, r4) ? (t4 = 0, n4) : (t4 = t4 == null ? 0 : Wi(t4), r4 === Ua ? n4 : Wi(r4)), Rt(e4, t4, r4)) : [];
      }, pe.sortBy = ni, pe.sortedUniq = function(e4) {
        return e4 && e4.length ? It(e4) : [];
      }, pe.sortedUniqBy = function(e4, t4) {
        return e4 && e4.length ? It(e4, Br(t4, 2)) : [];
      }, pe.split = function(e4, t4, r4) {
        return r4 && typeof r4 != "number" && Xr(e4, t4, r4) && (t4 = r4 = Ua), (r4 = r4 === Ua ? qa : r4 >>> 0) ? (e4 = Zi(e4)) && (typeof t4 == "string" || t4 != null && !Ni(t4)) && !(t4 = Nt(t4)) && Ks(e4) ? Xt(nl(e4), 0, r4) : e4.split(t4, r4) : [];
      }, pe.spread = function(r4, n4) {
        if (typeof r4 != "function")
          throw new y2(Va);
        return n4 = n4 == null ? 0 : G(Wi(n4), 0), Mt(function(e4) {
          var t4 = e4[n4], e4 = Xt(e4, 0, n4);
          return t4 && As(e4, t4), _s(r4, this, e4);
        });
      }, pe.tail = function(e4) {
        var t4 = e4 == null ? 0 : e4.length;
        return t4 ? Rt(e4, 1, t4) : [];
      }, pe.take = function(e4, t4, r4) {
        return e4 && e4.length ? Rt(e4, 0, (t4 = r4 || t4 === Ua ? 1 : Wi(t4)) < 0 ? 0 : t4) : [];
      }, pe.takeRight = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        return n4 ? Rt(e4, (t4 = n4 - (t4 = r4 || t4 === Ua ? 1 : Wi(t4))) < 0 ? 0 : t4, n4) : [];
      }, pe.takeRightWhile = function(e4, t4) {
        return e4 && e4.length ? Ut(e4, Br(t4, 3), false, true) : [];
      }, pe.takeWhile = function(e4, t4) {
        return e4 && e4.length ? Ut(e4, Br(t4, 3)) : [];
      }, pe.tap = function(e4, t4) {
        return t4(e4), e4;
      }, pe.throttle = function(e4, t4, r4) {
        var n4 = true, i4 = true;
        if (typeof e4 != "function")
          throw new y2(Va);
        return Li(r4) && (n4 = "leading" in r4 ? !!r4.leading : n4, i4 = "trailing" in r4 ? !!r4.trailing : i4), ci(e4, t4, { leading: n4, maxWait: t4, trailing: i4 });
      }, pe.thru = Gn, pe.toArray = Hi, pe.toPairs = ga, pe.toPairsIn = va, pe.toPath = function(e4) {
        return wi(e4) ? ks(e4, mn) : ji(e4) ? [e4] : nr(fn2(Zi(e4)));
      }, pe.toPlainObject = Xi, pe.transform = function(e4, n4, i4) {
        var t4, r4 = wi(e4), a4 = r4 || Ti(e4) || Ui(e4);
        return n4 = Br(n4, 4), i4 == null && (t4 = e4 && e4.constructor, i4 = a4 ? r4 ? new t4() : [] : Li(e4) && Ci(t4) ? fe(k3(e4)) : {}), (a4 ? xs : Ye)(e4, function(e5, t5, r5) {
          return n4(i4, e5, t5, r5);
        }), i4;
      }, pe.unary = function(e4) {
        return ai(e4, 1);
      }, pe.union = On, pe.unionBy = Pn, pe.unionWith = In, pe.uniq = function(e4) {
        return e4 && e4.length ? Bt(e4) : [];
      }, pe.uniqBy = function(e4, t4) {
        return e4 && e4.length ? Bt(e4, Br(t4, 2)) : [];
      }, pe.uniqWith = function(e4, t4) {
        return t4 = typeof t4 == "function" ? t4 : Ua, e4 && e4.length ? Bt(e4, Ua, t4) : [];
      }, pe.unset = function(e4, t4) {
        return e4 == null || Ft(e4, t4);
      }, pe.unzip = Dn, pe.unzipWith = Nn, pe.update = function(e4, t4, r4) {
        return e4 == null ? e4 : jt(e4, t4, Wt(r4));
      }, pe.updateWith = function(e4, t4, r4, n4) {
        return n4 = typeof n4 == "function" ? n4 : Ua, e4 == null ? e4 : jt(e4, t4, Wt(r4), n4);
      }, pe.values = ya, pe.valuesIn = function(e4) {
        return e4 == null ? [] : Hs(e4, ua(e4));
      }, pe.without = Bn, pe.words = Ca, pe.wrap = function(e4, t4) {
        return mi(Wt(t4), e4);
      }, pe.xor = Fn, pe.xorBy = jn, pe.xorWith = Un, pe.zip = Vn, pe.zipObject = function(e4, t4) {
        return Ht(e4 || [], t4 || [], Ce);
      }, pe.zipObjectDeep = function(e4, t4) {
        return Ht(e4 || [], t4 || [], kt);
      }, pe.zipWith = zn, pe.entries = ga, pe.entriesIn = va, pe.extend = Ji, pe.extendWith = Qi, Ia(pe, pe), pe.add = te, pe.attempt = $a, pe.camelCase = _a2, pe.capitalize = ba, pe.ceil = o3, pe.clamp = function(e4, t4, r4) {
        return r4 === Ua && (r4 = t4, t4 = Ua), r4 !== Ua && (r4 = (r4 = Yi(r4)) == r4 ? r4 : 0), t4 !== Ua && (t4 = (t4 = Yi(t4)) == t4 ? t4 : 0), Ie(Yi(e4), t4, r4);
      }, pe.clone = function(e4) {
        return De(e4, 4);
      }, pe.cloneDeep = function(e4) {
        return De(e4, 5);
      }, pe.cloneDeepWith = function(e4, t4) {
        return De(e4, 5, t4 = typeof t4 == "function" ? t4 : Ua);
      }, pe.cloneWith = function(e4, t4) {
        return De(e4, 4, t4 = typeof t4 == "function" ? t4 : Ua);
      }, pe.conformsTo = function(e4, t4) {
        return t4 == null || Ne(e4, t4, ca(t4));
      }, pe.deburr = xa, pe.defaultTo = function(e4, t4) {
        return e4 == null || e4 != e4 ? t4 : e4;
      }, pe.divide = N2, pe.endsWith = function(e4, t4, r4) {
        e4 = Zi(e4), t4 = Nt(t4);
        var n4 = e4.length, n4 = r4 = r4 === Ua ? n4 : Ie(Wi(r4), 0, n4);
        return 0 <= (r4 -= t4.length) && e4.slice(r4, n4) == t4;
      }, pe.eq = yi, pe.escape = function(e4) {
        return (e4 = Zi(e4)) && Co.test(e4) ? e4.replace(ko, Xs) : e4;
      }, pe.escapeRegExp = function(e4) {
        return (e4 = Zi(e4)) && No.test(e4) ? e4.replace(Do, "\\$&") : e4;
      }, pe.every = function(e4, t4, r4) {
        return (wi(e4) ? Ss : Ve)(e4, Br(t4 = r4 && Xr(e4, t4, r4) ? Ua : t4, 3));
      }, pe.find = Yn, pe.findIndex = xn, pe.findKey = function(e4, t4) {
        return Ls(e4, Br(t4, 3), Ye);
      }, pe.findLast = Xn, pe.findLastIndex = wn, pe.findLastKey = function(e4, t4) {
        return Ls(e4, Br(t4, 3), Xe);
      }, pe.floor = Ct, pe.forEach = Zn, pe.forEachRight = Kn, pe.forIn = function(e4, t4) {
        return e4 == null ? e4 : We(e4, Br(t4, 3), ua);
      }, pe.forInRight = function(e4, t4) {
        return e4 == null ? e4 : qe(e4, Br(t4, 3), ua);
      }, pe.forOwn = function(e4, t4) {
        return e4 && Ye(e4, Br(t4, 3));
      }, pe.forOwnRight = function(e4, t4) {
        return e4 && Xe(e4, Br(t4, 3));
      }, pe.get = ia, pe.gt = _i, pe.gte = bi, pe.has = function(e4, t4) {
        return e4 != null && Gr(e4, t4, tt);
      }, pe.hasIn = aa, pe.head = Mn, pe.identity = Oa, pe.includes = function(e4, t4, r4, n4) {
        return e4 = Mi(e4) ? e4 : ya(e4), r4 = r4 && !n4 ? Wi(r4) : 0, n4 = e4.length, r4 < 0 && (r4 = G(n4 + r4, 0)), Fi(e4) ? r4 <= n4 && -1 < e4.indexOf(t4, r4) : !!n4 && -1 < Ps(e4, t4, r4);
      }, pe.indexOf = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        return n4 ? (r4 = r4 == null ? 0 : Wi(r4), Ps(e4, t4, r4 = r4 < 0 ? G(n4 + r4, 0) : r4)) : -1;
      }, pe.inRange = function(e4, t4, r4) {
        return t4 = Gi(t4), r4 === Ua ? (r4 = t4, t4 = 0) : r4 = Gi(r4), (e4 = e4 = Yi(e4)) >= W(t4 = t4, r4 = r4) && e4 < G(t4, r4);
      }, pe.invoke = la, pe.isArguments = xi, pe.isArray = wi, pe.isArrayBuffer = Si, pe.isArrayLike = Mi, pe.isArrayLikeObject = Ei, pe.isBoolean = function(e4) {
        return e4 === true || e4 === false || Oi(e4) && Qe(e4) == Ka;
      }, pe.isBuffer = Ti, pe.isDate = ki, pe.isElement = function(e4) {
        return Oi(e4) && e4.nodeType === 1 && !Di(e4);
      }, pe.isEmpty = function(e4) {
        if (e4 == null)
          return true;
        if (Mi(e4) && (wi(e4) || typeof e4 == "string" || typeof e4.splice == "function" || Ti(e4) || Ui(e4) || xi(e4)))
          return !e4.length;
        var t4, r4 = Hr(e4);
        if (r4 == ro || r4 == so)
          return !e4.size;
        if (Qr(e4))
          return !ut(e4).length;
        for (t4 in e4)
          if (_3.call(e4, t4))
            return false;
        return true;
      }, pe.isEqual = function(e4, t4) {
        return ot(e4, t4);
      }, pe.isEqualWith = function(e4, t4, r4) {
        var n4 = (r4 = typeof r4 == "function" ? r4 : Ua) ? r4(e4, t4) : Ua;
        return n4 === Ua ? ot(e4, t4, Ua, r4) : !!n4;
      }, pe.isError = Ai, pe.isFinite = function(e4) {
        return typeof e4 == "number" && V2(e4);
      }, pe.isFunction = Ci, pe.isInteger = $i, pe.isLength = Ri, pe.isMap = Pi, pe.isMatch = function(e4, t4) {
        return e4 === t4 || st(e4, t4, jr(t4));
      }, pe.isMatchWith = function(e4, t4, r4) {
        return r4 = typeof r4 == "function" ? r4 : Ua, st(e4, t4, jr(t4), r4);
      }, pe.isNaN = function(e4) {
        return Ii(e4) && e4 != +e4;
      }, pe.isNative = function(e4) {
        if (Jr(e4))
          throw new h3("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
        return lt(e4);
      }, pe.isNil = function(e4) {
        return e4 == null;
      }, pe.isNull = function(e4) {
        return e4 === null;
      }, pe.isNumber = Ii, pe.isObject = Li, pe.isObjectLike = Oi, pe.isPlainObject = Di, pe.isRegExp = Ni, pe.isSafeInteger = function(e4) {
        return $i(e4) && -Ga2 <= e4 && e4 <= Ga2;
      }, pe.isSet = Bi, pe.isString = Fi, pe.isSymbol = ji, pe.isTypedArray = Ui, pe.isUndefined = function(e4) {
        return e4 === Ua;
      }, pe.isWeakMap = function(e4) {
        return Oi(e4) && Hr(e4) == uo;
      }, pe.isWeakSet = function(e4) {
        return Oi(e4) && Qe(e4) == "[object WeakSet]";
      }, pe.join = function(e4, t4) {
        return e4 == null ? "" : z.call(e4, t4);
      }, pe.kebabCase = wa, pe.last = An, pe.lastIndexOf = function(e4, t4, r4) {
        var n4 = e4 == null ? 0 : e4.length;
        if (!n4)
          return -1;
        var i4 = n4;
        return r4 !== Ua && (i4 = (i4 = Wi(r4)) < 0 ? G(n4 + i4, 0) : W(i4, n4 - 1)), t4 == t4 ? function(e5, t5, r5) {
          for (var n5 = r5 + 1; n5--; )
            if (e5[n5] === t5)
              return n5;
          return n5;
        }(e4, t4, i4) : Os(e4, Ds, i4, true);
      }, pe.lowerCase = Sa, pe.lowerFirst = Ma, pe.lt = Vi, pe.lte = zi, pe.max = function(e4) {
        return e4 && e4.length ? ze(e4, Oa, et) : Ua;
      }, pe.maxBy = function(e4, t4) {
        return e4 && e4.length ? ze(e4, Br(t4, 2), et) : Ua;
      }, pe.mean = function(e4) {
        return Ns(e4, Oa);
      }, pe.meanBy = function(e4, t4) {
        return Ns(e4, Br(t4, 2));
      }, pe.min = function(e4) {
        return e4 && e4.length ? ze(e4, Oa, dt) : Ua;
      }, pe.minBy = function(e4, t4) {
        return e4 && e4.length ? ze(e4, Br(t4, 2), dt) : Ua;
      }, pe.stubArray = Ba, pe.stubFalse = Fa, pe.stubObject = function() {
        return {};
      }, pe.stubString = function() {
        return "";
      }, pe.stubTrue = function() {
        return true;
      }, pe.multiply = D, pe.nth = function(e4, t4) {
        return e4 && e4.length ? vt(e4, Wi(t4)) : Ua;
      }, pe.noConflict = function() {
        return hs._ === this && (hs._ = b3), this;
      }, pe.noop = Da, pe.now = ii, pe.pad = function(e4, t4, r4) {
        e4 = Zi(e4);
        var n4 = (t4 = Wi(t4)) ? rl(e4) : 0;
        return !t4 || t4 <= n4 ? e4 : _r(F(n4 = (t4 - n4) / 2), r4) + e4 + _r(B(n4), r4);
      }, pe.padEnd = function(e4, t4, r4) {
        e4 = Zi(e4);
        var n4 = (t4 = Wi(t4)) ? rl(e4) : 0;
        return t4 && n4 < t4 ? e4 + _r(t4 - n4, r4) : e4;
      }, pe.padStart = function(e4, t4, r4) {
        e4 = Zi(e4);
        var n4 = (t4 = Wi(t4)) ? rl(e4) : 0;
        return t4 && n4 < t4 ? _r(t4 - n4, r4) + e4 : e4;
      }, pe.parseInt = function(e4, t4, r4) {
        return t4 = r4 || t4 == null ? 0 : t4 && +t4, Y(Zi(e4).replace(Bo, ""), t4 || 0);
      }, pe.random = function(e4, t4, r4) {
        var n4;
        if (r4 && typeof r4 != "boolean" && Xr(e4, t4, r4) && (t4 = r4 = Ua), r4 === Ua && (typeof t4 == "boolean" ? (r4 = t4, t4 = Ua) : typeof e4 == "boolean" && (r4 = e4, e4 = Ua)), e4 === Ua && t4 === Ua ? (e4 = 0, t4 = 1) : (e4 = Gi(e4), t4 === Ua ? (t4 = e4, e4 = 0) : t4 = Gi(t4)), t4 < e4 && (n4 = e4, e4 = t4, t4 = n4), r4 || e4 % 1 || t4 % 1) {
          r4 = X();
          return W(e4 + r4 * (t4 - e4 + cs("1e-" + ((r4 + "").length - 1))), t4);
        }
        return wt(e4, t4);
      }, pe.reduce = function(e4, t4, r4) {
        var n4 = wi(e4) ? Cs : Fs, i4 = arguments.length < 3;
        return n4(e4, Br(t4, 4), r4, i4, je);
      }, pe.reduceRight = function(e4, t4, r4) {
        var n4 = wi(e4) ? $s : Fs, i4 = arguments.length < 3;
        return n4(e4, Br(t4, 4), r4, i4, Ue);
      }, pe.repeat = function(e4, t4, r4) {
        return t4 = (r4 ? Xr(e4, t4, r4) : t4 === Ua) ? 1 : Wi(t4), St(Zi(e4), t4);
      }, pe.replace = function() {
        var e4 = arguments, t4 = Zi(e4[0]);
        return e4.length < 3 ? t4 : t4.replace(e4[1], e4[2]);
      }, pe.result = function(e4, t4, r4) {
        var n4 = -1, i4 = (t4 = qt(t4, e4)).length;
        for (i4 || (i4 = 1, e4 = Ua); ++n4 < i4; ) {
          var a4 = e4 == null ? Ua : e4[mn(t4[n4])];
          a4 === Ua && (n4 = i4, a4 = r4), e4 = Ci(a4) ? a4.call(e4) : a4;
        }
        return e4;
      }, pe.round = Yt, pe.runInContext = e3, pe.sample = function(e4) {
        return (wi(e4) ? Ee : Et)(e4);
      }, pe.size = function(e4) {
        if (e4 == null)
          return 0;
        if (Mi(e4))
          return Fi(e4) ? rl(e4) : e4.length;
        var t4 = Hr(e4);
        return t4 == ro || t4 == so ? e4.size : ut(e4).length;
      }, pe.snakeCase = Ea, pe.some = function(e4, t4, r4) {
        return (wi(e4) ? Rs : Lt)(e4, Br(t4 = r4 && Xr(e4, t4, r4) ? Ua : t4, 3));
      }, pe.sortedIndex = function(e4, t4) {
        return Ot(e4, t4);
      }, pe.sortedIndexBy = function(e4, t4, r4) {
        return Pt(e4, t4, Br(r4, 2));
      }, pe.sortedIndexOf = function(e4, t4) {
        var r4 = e4 == null ? 0 : e4.length;
        if (r4) {
          var n4 = Ot(e4, t4);
          if (n4 < r4 && yi(e4[n4], t4))
            return n4;
        }
        return -1;
      }, pe.sortedLastIndex = function(e4, t4) {
        return Ot(e4, t4, true);
      }, pe.sortedLastIndexBy = function(e4, t4, r4) {
        return Pt(e4, t4, Br(r4, 2), true);
      }, pe.sortedLastIndexOf = function(e4, t4) {
        if (e4 == null ? 0 : e4.length) {
          var r4 = Ot(e4, t4, true) - 1;
          if (yi(e4[r4], t4))
            return r4;
        }
        return -1;
      }, pe.startCase = Ta, pe.startsWith = function(e4, t4, r4) {
        return e4 = Zi(e4), r4 = r4 == null ? 0 : Ie(Wi(r4), 0, e4.length), t4 = Nt(t4), e4.slice(r4, r4 + t4.length) == t4;
      }, pe.subtract = U, pe.sum = function(e4) {
        return e4 && e4.length ? js(e4, Oa) : 0;
      }, pe.sumBy = function(e4, t4) {
        return e4 && e4.length ? js(e4, Br(t4, 2)) : 0;
      }, pe.template = function(o4, e4, t4) {
        var r4 = pe.templateSettings;
        t4 && Xr(o4, e4, t4) && (e4 = Ua), o4 = Zi(o4), e4 = Qi({}, e4, r4, Ar);
        var s4, l4, n4 = ca(r4 = Qi({}, e4.imports, r4.imports, Ar)), i4 = Hs(r4, n4), c4 = 0, r4 = e4.interpolate || Qo, u4 = "__p += '", r4 = p3((e4.escape || Qo).source + "|" + r4.source + "|" + (r4 === Lo ? Go : Qo).source + "|" + (e4.evaluate || Qo).source + "|$", "g"), a4 = "//# sourceURL=" + (_3.call(e4, "sourceURL") ? (e4.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++os + "]") + "\n";
        if (o4.replace(r4, function(e5, t5, r5, n5, i5, a5) {
          return r5 = r5 || n5, u4 += o4.slice(c4, a5).replace(es, Zs), t5 && (s4 = true, u4 += "' +\n__e(" + t5 + ") +\n'"), i5 && (l4 = true, u4 += "';\n" + i5 + ";\n__p += '"), r5 && (u4 += "' +\n((__t = (" + r5 + ")) == null ? '' : __t) +\n'"), c4 = a5 + e5.length, e5;
        }), u4 += "';\n", e4 = _3.call(e4, "variable") && e4.variable) {
          if (zo.test(e4))
            throw new h3("Invalid `variable` option passed into `_.template`");
        } else
          u4 = "with (obj) {\n" + u4 + "\n}\n";
        if (u4 = (l4 ? u4.replace(So, "") : u4).replace(Mo, "$1").replace(Eo, "$1;"), u4 = "function(" + (e4 || "obj") + ") {\n" + (e4 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (s4 ? ", __e = _.escape" : "") + (l4 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + u4 + "return __p\n}", (e4 = $a(function() {
          return d3(n4, a4 + "return " + u4).apply(Ua, i4);
        })).source = u4, Ai(e4))
          throw e4;
        return e4;
      }, pe.times = function(e4, t4) {
        if ((e4 = Wi(e4)) < 1 || Ga2 < e4)
          return [];
        var r4 = qa, n4 = W(e4, qa);
        for (t4 = Br(t4), e4 -= qa, n4 = Us(n4, t4); ++r4 < e4; )
          t4(r4);
        return n4;
      }, pe.toFinite = Gi, pe.toInteger = Wi, pe.toLength = qi, pe.toLower = function(e4) {
        return Zi(e4).toLowerCase();
      }, pe.toNumber = Yi, pe.toSafeInteger = function(e4) {
        return e4 ? Ie(Wi(e4), -Ga2, Ga2) : e4 === 0 ? e4 : 0;
      }, pe.toString = Zi, pe.toUpper = function(e4) {
        return Zi(e4).toUpperCase();
      }, pe.trim = function(e4, t4, r4) {
        return (e4 = Zi(e4)) && (r4 || t4 === Ua) ? Vs(e4) : e4 && (t4 = Nt(t4)) ? (e4 = nl(e4), t4 = nl(t4), Xt(e4, Ws(e4, t4), qs2(e4, t4) + 1).join("")) : e4;
      }, pe.trimEnd = function(e4, t4, r4) {
        return (e4 = Zi(e4)) && (r4 || t4 === Ua) ? e4.slice(0, il(e4) + 1) : e4 && (t4 = Nt(t4)) ? Xt(e4 = nl(e4), 0, qs2(e4, nl(t4)) + 1).join("") : e4;
      }, pe.trimStart = function(e4, t4, r4) {
        return (e4 = Zi(e4)) && (r4 || t4 === Ua) ? e4.replace(Bo, "") : e4 && (t4 = Nt(t4)) ? Xt(e4 = nl(e4), Ws(e4, nl(t4))).join("") : e4;
      }, pe.truncate = function(e4, t4) {
        var r4, n4 = 30, i4 = "...";
        Li(t4) && (r4 = "separator" in t4 ? t4.separator : r4, n4 = "length" in t4 ? Wi(t4.length) : n4, i4 = "omission" in t4 ? Nt(t4.omission) : i4);
        var a4, t4 = (e4 = Zi(e4)).length;
        if ((t4 = Ks(e4) ? (a4 = nl(e4)).length : t4) <= n4)
          return e4;
        if ((t4 = n4 - rl(i4)) < 1)
          return i4;
        if (n4 = a4 ? Xt(a4, 0, t4).join("") : e4.slice(0, t4), r4 === Ua)
          return n4 + i4;
        if (a4 && (t4 += n4.length - t4), Ni(r4)) {
          if (e4.slice(t4).search(r4)) {
            var o4, s4 = n4;
            for ((r4 = !r4.global ? p3(r4.source, Zi(Wo.exec(r4)) + "g") : r4).lastIndex = 0; o4 = r4.exec(s4); )
              var l4 = o4.index;
            n4 = n4.slice(0, l4 === Ua ? t4 : l4);
          }
        } else
          e4.indexOf(Nt(r4), t4) == t4 || -1 < (t4 = n4.lastIndexOf(r4)) && (n4 = n4.slice(0, t4));
        return n4 + i4;
      }, pe.unescape = function(e4) {
        return (e4 = Zi(e4)) && Ao.test(e4) ? e4.replace(To, al) : e4;
      }, pe.uniqueId = function(e4) {
        var t4 = ++l3;
        return Zi(e4) + t4;
      }, pe.upperCase = ka, pe.upperFirst = Aa, pe.each = Zn, pe.eachRight = Kn, pe.first = Mn, Ia(pe, (ja = {}, Ye(pe, function(e4, t4) {
        _3.call(pe.prototype, t4) || (ja[t4] = e4);
      }), ja), { chain: false }), pe.VERSION = "4.17.21", xs(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e4) {
        pe[e4].placeholder = pe;
      }), xs(["drop", "take"], function(r4, n4) {
        ye.prototype[r4] = function(e4) {
          e4 = e4 === Ua ? 1 : G(Wi(e4), 0);
          var t4 = this.__filtered__ && !n4 ? new ye(this) : this.clone();
          return t4.__filtered__ ? t4.__takeCount__ = W(e4, t4.__takeCount__) : t4.__views__.push({ size: W(e4, qa), type: r4 + (t4.__dir__ < 0 ? "Right" : "") }), t4;
        }, ye.prototype[r4 + "Right"] = function(e4) {
          return this.reverse()[r4](e4).reverse();
        };
      }), xs(["filter", "map", "takeWhile"], function(e4, t4) {
        var r4 = t4 + 1, n4 = r4 == 1 || r4 == 3;
        ye.prototype[e4] = function(e5) {
          var t5 = this.clone();
          return t5.__iteratees__.push({ iteratee: Br(e5, 3), type: r4 }), t5.__filtered__ = t5.__filtered__ || n4, t5;
        };
      }), xs(["head", "last"], function(e4, t4) {
        var r4 = "take" + (t4 ? "Right" : "");
        ye.prototype[e4] = function() {
          return this[r4](1).value()[0];
        };
      }), xs(["initial", "tail"], function(e4, t4) {
        var r4 = "drop" + (t4 ? "" : "Right");
        ye.prototype[e4] = function() {
          return this.__filtered__ ? new ye(this) : this[r4](1);
        };
      }), ye.prototype.compact = function() {
        return this.filter(Oa);
      }, ye.prototype.find = function(e4) {
        return this.filter(e4).head();
      }, ye.prototype.findLast = function(e4) {
        return this.reverse().find(e4);
      }, ye.prototype.invokeMap = Mt(function(t4, r4) {
        return typeof t4 == "function" ? new ye(this) : this.map(function(e4) {
          return it(e4, t4, r4);
        });
      }), ye.prototype.reject = function(e4) {
        return this.filter(pi(Br(e4)));
      }, ye.prototype.slice = function(e4, t4) {
        e4 = Wi(e4);
        var r4 = this;
        return r4.__filtered__ && (0 < e4 || t4 < 0) ? new ye(r4) : (e4 < 0 ? r4 = r4.takeRight(-e4) : e4 && (r4 = r4.drop(e4)), t4 !== Ua ? (t4 = Wi(t4)) < 0 ? r4.dropRight(-t4) : r4.take(t4 - e4) : r4);
      }, ye.prototype.takeRightWhile = function(e4) {
        return this.reverse().takeWhile(e4).reverse();
      }, ye.prototype.toArray = function() {
        return this.take(qa);
      }, Ye(ye.prototype, function(c4, e4) {
        var u4 = /^(?:filter|find|map|reject)|While$/.test(e4), h4 = /^(?:head|last)$/.test(e4), d4 = pe[h4 ? "take" + (e4 == "last" ? "Right" : "") : e4], p4 = h4 || /^find/.test(e4);
        d4 && (pe.prototype[e4] = function() {
          function e5(e6) {
            return e6 = d4.apply(pe, As([e6], r4)), h4 && o4 ? e6[0] : e6;
          }
          var t4 = this.__wrapped__, r4 = h4 ? [1] : arguments, n4 = t4 instanceof ye, i4 = r4[0], a4 = n4 || wi(t4);
          a4 && u4 && typeof i4 == "function" && i4.length != 1 && (n4 = a4 = false);
          var o4 = this.__chain__, s4 = !!this.__actions__.length, i4 = p4 && !o4, s4 = n4 && !s4;
          if (p4 || !a4)
            return i4 && s4 ? c4.apply(this, r4) : (l4 = this.thru(e5), i4 ? h4 ? l4.value()[0] : l4.value() : l4);
          var t4 = s4 ? t4 : new ye(this), l4 = c4.apply(t4, r4);
          return l4.__actions__.push({ func: Gn, args: [e5], thisArg: Ua }), new ve(l4, o4);
        });
      }), xs(["pop", "push", "shift", "sort", "splice", "unshift"], function(e4) {
        var r4 = a3[e4], n4 = /^(?:push|sort|unshift)$/.test(e4) ? "tap" : "thru", i4 = /^(?:pop|shift)$/.test(e4);
        pe.prototype[e4] = function() {
          var t4 = arguments;
          if (!i4 || this.__chain__)
            return this[n4](function(e6) {
              return r4.apply(wi(e6) ? e6 : [], t4);
            });
          var e5 = this.value();
          return r4.apply(wi(e5) ? e5 : [], t4);
        };
      }), Ye(ye.prototype, function(e4, t4) {
        var r4, n4 = pe[t4];
        n4 && (r4 = n4.name + "", _3.call(ie, r4) || (ie[r4] = []), ie[r4].push({ name: t4, func: n4 }));
      }), ie[mr(Ua, 2).name] = [{ name: "wrapper", func: Ua }], ye.prototype.clone = function() {
        var e4 = new ye(this.__wrapped__);
        return e4.__actions__ = nr(this.__actions__), e4.__dir__ = this.__dir__, e4.__filtered__ = this.__filtered__, e4.__iteratees__ = nr(this.__iteratees__), e4.__takeCount__ = this.__takeCount__, e4.__views__ = nr(this.__views__), e4;
      }, ye.prototype.reverse = function() {
        var e4;
        return this.__filtered__ ? ((e4 = new ye(this)).__dir__ = -1, e4.__filtered__ = true) : (e4 = this.clone()).__dir__ *= -1, e4;
      }, ye.prototype.value = function() {
        var e4 = this.__wrapped__.value(), t4 = this.__dir__, r4 = wi(e4), n4 = t4 < 0, i4 = r4 ? e4.length : 0, a4 = function(e5, t5, r5) {
          var n5 = -1, i5 = r5.length;
          for (; ++n5 < i5; ) {
            var a5 = r5[n5], o5 = a5.size;
            switch (a5.type) {
              case "drop":
                e5 += o5;
                break;
              case "dropRight":
                t5 -= o5;
                break;
              case "take":
                t5 = W(t5, e5 + o5);
                break;
              case "takeRight":
                e5 = G(e5, t5 - o5);
            }
          }
          return { start: e5, end: t5 };
        }(0, i4, this.__views__), o4 = a4.start, s4 = (a4 = a4.end) - o4, l4 = n4 ? a4 : o4 - 1, c4 = this.__iteratees__, u4 = c4.length, h4 = 0, d4 = W(s4, this.__takeCount__);
        if (!r4 || !n4 && i4 == s4 && d4 == s4)
          return Vt(e4, this.__actions__);
        var p4 = [];
        e:
          for (; s4-- && h4 < d4; ) {
            for (var f4 = -1, m4 = e4[l4 += t4]; ++f4 < u4; ) {
              var g4 = c4[f4], v5 = g4.iteratee, g4 = g4.type, v5 = v5(m4);
              if (g4 == 2)
                m4 = v5;
              else if (!v5) {
                if (g4 == 1)
                  continue e;
                break e;
              }
            }
            p4[h4++] = m4;
          }
        return p4;
      }, pe.prototype.at = Wn, pe.prototype.chain = function() {
        return Hn(this);
      }, pe.prototype.commit = function() {
        return new ve(this.value(), this.__chain__);
      }, pe.prototype.next = function() {
        this.__values__ === Ua && (this.__values__ = Hi(this.value()));
        var e4 = this.__index__ >= this.__values__.length;
        return { done: e4, value: e4 ? Ua : this.__values__[this.__index__++] };
      }, pe.prototype.plant = function(e4) {
        for (var t4, r4 = this; r4 instanceof ge; ) {
          var n4 = vn(r4);
          n4.__index__ = 0, n4.__values__ = Ua, t4 ? i4.__wrapped__ = n4 : t4 = n4;
          var i4 = n4, r4 = r4.__wrapped__;
        }
        return i4.__wrapped__ = e4, t4;
      }, pe.prototype.reverse = function() {
        var e4 = this.__wrapped__;
        if (e4 instanceof ye) {
          e4 = e4;
          return (e4 = (e4 = this.__actions__.length ? new ye(this) : e4).reverse()).__actions__.push({ func: Gn, args: [Ln], thisArg: Ua }), new ve(e4, this.__chain__);
        }
        return this.thru(Ln);
      }, pe.prototype.toJSON = pe.prototype.valueOf = pe.prototype.value = function() {
        return Vt(this.__wrapped__, this.__actions__);
      }, pe.prototype.first = pe.prototype.head, L && (pe.prototype[L] = function() {
        return this;
      }), pe;
    }();
    M2 ? ((M2.exports = ol)._ = ol, o2._ = ol) : hs._ = ol;
  }.call(commonjsGlobal);
  var __assign$5 = globalThis && globalThis.__assign || function() {
    return (__assign$5 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function hslaToRgba(e2) {
    if (!isHsla(e2))
      throw new Error(notValidHslaMessage("hslaToRgba", e2));
    var t2 = e2.h, r2 = e2.s, n2 = e2.l, e2 = e2.a, n2 = hslToRgb({ h: t2, s: r2, l: n2 });
    return __assign$5(__assign$5({}, n2), { a: e2 });
  }
  var __assign$4 = globalThis && globalThis.__assign || function() {
    return (__assign$4 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function hslToRgb(e2) {
    if (!isHsl(e2))
      throw new Error(notValidHslMessage("hslToRgb", e2));
    var t2 = e2.h, r2 = e2.s / 100, n2 = e2.l / 100;
    if (r2 == 0) {
      var i2 = 255 * n2;
      return { r: i2, g: i2, b: i2 };
    }
    var a2 = t2 / 60 % 6, e2 = Math.floor(a2), i2 = a2 - e2, t2 = r2 * (1 - Math.abs(2 * n2 - 1)), a2 = n2 + t2 / 2, r2 = n2 - t2 / 2, n2 = a2 - t2 * i2, i2 = r2 + t2 * i2;
    return applyFnToEachObjValue(e2 === 0 ? { r: a2, g: i2, b: r2 } : e2 === 1 ? { r: n2, g: a2, b: r2 } : e2 === 2 ? { r: r2, g: a2, b: i2 } : e2 === 3 ? { r: r2, g: n2, b: a2 } : e2 === 4 ? { r: i2, g: r2, b: a2 } : { r: a2, g: r2, b: n2 }, function(e3) {
      return lodash.exports.round(255 * e3);
    });
  }
  var __assign$3 = globalThis && globalThis.__assign || function() {
    return (__assign$3 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  }, __assign$2 = globalThis && globalThis.__assign || function() {
    return (__assign$2 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function rgbaToHex(e2) {
    if (!isRgba(e2))
      throw new Error(notValidRgbaMessage("rgbaToHex", e2));
    var t2 = e2.r, r2 = e2.g, n2 = e2.b, e2 = e2.a;
    return "" + rgbToHex({ r: t2, g: r2, b: n2 }) + alphaToHex(e2);
  }
  function rgbaToHsl(e2) {
    if (!isRgba(e2))
      throw new Error(notValidRgbaMessage("rgbaToHsl", e2));
    return rgbToHsl({ r: e2.r, g: e2.g, b: e2.b });
  }
  function rgbaToHsla(e2) {
    if (!isRgba(e2))
      throw new Error(notValidRgbaMessage("rgbaToHsla", e2));
    return __assign$2(__assign$2({}, rgbaToHsl(e2)), { a: e2.a });
  }
  var ALPHA_PRECISION = 4, __assign$1 = globalThis && globalThis.__assign || function() {
    return (__assign$1 = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function hexToRgbOrRgba(e2) {
    if (!isHex(e2))
      throw new Error(notValidHexMessage("hexToRgbOrRgba", e2));
    var t2 = chunkString(shortToLongHex(e2).substring(1), 2), r2 = t2[0], n2 = t2[1], e2 = t2[2], t2 = t2[3], e2 = { r: hexAlphaTo0255(r2), g: hexAlphaTo0255(n2), b: hexAlphaTo0255(e2) };
    return t2 ? __assign$1(__assign$1({}, e2), { a: hexToAlpha(t2, ALPHA_PRECISION) }) : e2;
  }
  function hexToRgba(e2, t2) {
    if (t2 === void 0 && (t2 = 1), !isHex(e2))
      throw new Error(notValidHexMessage("hex2rgba", e2));
    if (!between(t2, [0, 1]))
      throw new Error(notValidAlphaValueMessage("hex2rgba", t2));
    e2 = hexToRgbOrRgba(e2);
    return isRgb(e2) ? __assign$1(__assign$1({}, e2), { a: t2 }) : e2;
  }
  function shortToLongHex(e2) {
    if (!isHex(e2))
      throw new Error(notValidHexMessage("shortToLongHex", e2));
    if (!HEX_REGEX.short.test(e2))
      return e2;
    var t2 = Array.from(e2), r2 = t2[0], n2 = t2[1], i2 = t2[2], e2 = t2[3], t2 = t2[4];
    return t2 ? "" + r2 + n2 + n2 + i2 + i2 + e2 + e2 + t2 + t2 : "" + r2 + n2 + n2 + i2 + i2 + e2 + e2;
  }
  var __assign = globalThis && globalThis.__assign || function() {
    return (__assign = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function rgbToHex(e2) {
    if (!isRgb(e2))
      throw new Error(notValidRgbMessage("rgbToHex", e2));
    return "#" + Object.values(e2).map(function(e3) {
      return number0255ToHex(e3);
    }).join("");
  }
  function rgbToHsl(e2) {
    if (!isRgb(e2))
      throw new Error(notValidRgbMessage("rgbToHsl", e2));
    var t2 = e2.r, r2 = e2.g, n2 = e2.b, i2 = Math.max(t2, r2, n2), a2 = Math.min(t2, r2, n2), e2 = (i2 + a2) / 2;
    if (i2 === a2)
      return { h: 0, s: 0, l: e2 / 255 * 100 };
    var o2, s2 = i2 - a2, a2 = 100 * Math.abs(s2 / (1 - Math.abs(2 * e2 - 1))) - 1;
    switch (i2) {
      case t2:
        o2 = (r2 - n2) / s2 * 60 + (r2 < n2 ? 360 : 0);
        break;
      case r2:
        o2 = 120 + 60 * (n2 - t2) / s2;
        break;
      case n2:
        o2 = 240 + 60 * (t2 - r2) / s2;
    }
    return applyFnToEachObjValue({ h: o2, s: a2, l: e2 / 255 * 100 }, function(e3) {
      return lodash.exports.round(e3);
    });
  }
  function hsla2rgba(e2, t2, r2, n2 = 1) {
    return typeof e2 == "object" && (t2 = (e2 = e2.h).s, r2 = e2.l, n2 = e2.a), hslaToRgba({ h: e2, s: t2, l: r2, a: n2 });
  }
  function hex2rgba(e2) {
    return hexToRgba(e2, 1);
  }
  function rgba2hsla(e2, t2, r2, n2 = 1) {
    return typeof e2 == "object" && (t2 = e2.g, r2 = e2.b, n2 = e2.a, e2 = e2.r), rgbaToHsla({ r: e2, g: t2, b: r2, a: n2 });
  }
  function parse(e2, t2 = "rgba") {
    switch ((e2 = e2.replace(/\s/g, "")).indexOf("rgb") != -1 ? e2 = parseRgba(e2) : e2.indexOf("hsl") != -1 ? e2 = hsla2rgba((e2 = parseHsl(e2)).h, e2.s, e2.l) : e2.substring(0, 1) == "#" && (e2 = hex2rgba(e2)), t2) {
      case "hsla":
      case "hsl":
        return rgba2hsla(e2);
      default:
        return e2;
    }
  }
  function rgba2hex(e2, t2, r2, n2 = 1) {
    typeof e2 == "object" && (t2 = e2.g, r2 = e2.b, n2 = e2.a, e2 = e2.r);
    let i2 = rgbaToHex({ r: e2, g: t2, b: r2, a: n2 });
    return i2.length === 9 && (i2 = i2.slice(0, -2)), i2;
  }
  function convert(e2, t2 = "rgba") {
    let r2 = {};
    switch (typeof e2 == "string" ? r2 = parse(e2, "rgba") : typeof e2 == "object" && (e2.r !== void 0 && e2.g !== void 0 && e2.b !== void 0 ? r2 = e2 : e2.h !== void 0 && e2.s !== void 0 && e2.l !== void 0 && (r2 = hsla2rgba(e2))), t2) {
      case "rgba":
        return r2;
      case "hsl":
        return rgba2hsla(r2);
      case "hex":
      case "hexString":
        return rgba2hex(r2);
      case "rgbaString":
        return `rgba(${r2.r},${r2.g},${r2.b},${r2.a})`;
      case "hslString":
        var n2 = convert(r2, "hsl");
        return `hsl(${n2.h},${n2.s},${n2.l})`;
    }
  }
  class SColorApplyParamsInterface extends SInterface {
    static get _definition() {
      return { desaturate: { type: "Number", default: 0, alias: "d", description: "Allows you to desaturate the color using a percentage" }, saturate: { type: "Number", default: 0, alias: "s", description: "Allows you to saturate the color using a percentage" }, greyscale: { type: "Boolean", default: false, alias: "g", description: "Allows you to get back the grayscale version of your color" }, spin: { type: "Number", default: 0, description: "Spin the hue on the passed value (max 360)" }, transparentize: { type: "Number", default: 0, description: "The amount of transparency to apply between 0-100|0-1" }, alpha: { type: "Number", default: 0, alias: "a", description: "The new alpha value to apply between 0-100|0-1" }, opacity: { type: "Number", default: 0, alias: "o", description: "The new alpha value to apply between 0-100|0-1" }, opacify: { type: "Number", default: 0, description: "The amount of transparence to remove between 0-100|0-1" }, darken: { type: "Number", default: 0, description: "The amount of darkness (of the nightmare of the shadow) to apply between 0-100" }, lighten: { type: "Number", default: 0, alias: "l", description: "The amount of lightness (of the sky of the angels) to apply between 0-100" }, invert: { type: "Boolean", default: false, alias: "i", description: "Specify if you want to invert the color to keep a good contrast ratio with a background for example" } };
    }
  }
  class SColor extends SClass {
    constructor(e2, t2 = {}) {
      super(__deepMerge$7({ color: { returnNewInstance: false, defaultFormat: "hex" } }, t2)), this._originalSColor = null, this._r = null, this._g = null, this._b = null, this._a = 1, e2 = this.getColor(e2), this._originalSColor = e2, this._parse(e2);
    }
    get colorSettings() {
      return this._settings.color;
    }
    getColor(e2) {
      return typeof e2 == "string" && SColor.colors[e2.toLowerCase()] ? SColor.colors[e2.toLowerCase()] : e2;
    }
    _parse(e2) {
      return e2 = convert(e2, "rgba"), this.r = e2.r, this.g = e2.g, this.b = e2.b, this.a = e2.a, e2;
    }
    _convert2(e2) {
      switch (e2) {
        case "rgba":
        case "rgb":
          return { r: this.r, g: this.g, b: this.b, a: this.a };
        case "hsla":
        case "hsl":
          return rgba2hsla(this.r, this.g, this.b, this.a);
        case "hex":
          return rgba2hex(this.r, this.g, this.b, this.a);
      }
    }
    toHex() {
      return this._convert2("hex");
    }
    toHsl() {
      return this._convert2("hsl");
    }
    toRgba() {
      return this._convert2("rgba");
    }
    get r() {
      return this._r;
    }
    set r(e2) {
      e2 = parseInt(e2), this._r = e2 = 255 < e2 ? 255 : e2 < 0 ? 0 : e2;
    }
    get g() {
      return this._g;
    }
    set g(e2) {
      e2 = parseInt(e2), this._g = e2 = 255 < e2 ? 255 : e2 < 0 ? 0 : e2;
    }
    get b() {
      return this._b;
    }
    set b(e2) {
      e2 = parseInt(e2), this._b = e2 = 255 < e2 ? 255 : e2 < 0 ? 0 : e2;
    }
    get a() {
      return this._a;
    }
    set a(e2) {
      e2 = parseFloat(e2), this._a = e2 = 1 < e2 ? 1 : e2 < 0 ? 0 : e2;
    }
    get l() {
      return this._convert2("hsl").l;
    }
    set l(e2) {
      const t2 = this._convert2("hsl");
      e2 = 100 < (e2 = parseInt(e2)) ? 100 : e2 < 0 ? 0 : e2, t2.l = e2;
      e2 = hsla2rgba(t2.h, t2.s, t2.l);
      this.r = e2.r, this.g = e2.g, this.b = e2.b;
    }
    get s() {
      return this._convert2("hsl").s;
    }
    set s(e2) {
      const t2 = this._convert2("hsl");
      e2 = 100 < (e2 = parseInt(e2)) ? 100 : e2 < 0 ? 0 : e2, t2.s = e2;
      e2 = hsla2rgba(t2.h, t2.s, t2.l);
      this.r = e2.r, this.g = e2.g, this.b = e2.b;
    }
    get h() {
      return this._convert2("hsl").h;
    }
    set h(e2) {
      const t2 = this._convert2("hsl");
      e2 = 360 < (e2 = parseInt(e2)) ? 360 : e2 < 0 ? 0 : e2, t2.h = e2;
      e2 = hsla2rgba(t2.h, t2.s, t2.l);
      this.r = e2.r, this.g = e2.g, this.b = e2.b;
    }
    reset() {
      this._parse(this._originalSColor);
    }
    apply(r2, e2 = this.colorSettings.returnNewInstance) {
      var t2 = SColorApplyParamsInterface.apply(r2);
      r2 = t2;
      let n2 = this;
      return e2 && (n2 = new SColor(this.toHex())), Object.keys(r2).forEach((e3) => {
        var t3 = r2[e3];
        t3 && n2[e3] && typeof n2[e3] == "function" && (e3 === "invert" ? n2.invert() : n2[e3](t3));
      }), n2;
    }
    desaturate(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseInt(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.s -= e2, r2;
      }
      return this.s -= e2, this;
    }
    saturate(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseInt(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.s += e2, r2;
      }
      return this.s += e2, this;
    }
    grayscale(e2 = this.colorSettings.returnNewInstance) {
      if (e2) {
        const t2 = new SColor(this.toHex());
        return t2.s = 0, t2;
      }
      return this.s = 0, this;
    }
    spin(e2, t2 = this.colorSettings.returnNewInstance) {
      e2 = parseInt(e2);
      let r2 = this.h + e2;
      if (360 < r2 && (r2 -= 360), t2) {
        const n2 = new SColor(this.toHex());
        return n2.h = r2, n2;
      }
      return this.h = r2, this;
    }
    transparentize(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseFloat(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.a -= e2, r2;
      }
      return this.a -= e2, this;
    }
    alpha(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseFloat(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.a = e2, r2;
      }
      return this.a = e2, this;
    }
    opacity(e2, t2 = this.colorSettings.returnNewInstance) {
      return this.alpha(e2, t2);
    }
    opacify(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseFloat(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.a += e2, r2;
      }
      return this.a += e2, (this.a < 0 || 1 < this.a) && (this.a = 0), this;
    }
    darken(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseInt(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.l -= e2, r2;
      }
      return this.l -= e2, this.l < 0 ? this.l = 0 : 100 < this.l && (this.l = 100), this;
    }
    lighten(e2, t2 = this.colorSettings.returnNewInstance) {
      if (e2 = parseInt(e2), t2) {
        const r2 = new SColor(this.toHex());
        return r2.l += e2, r2;
      }
      return this.l += e2, this.l < 0 ? this.l = 0 : 100 < this.l && (this.l = 100), this;
    }
    invert(e2 = this.colorSettings.returnNewInstance) {
      let t2 = this.l;
      if (50 <= this.l ? t2 -= 50 : t2 += 50, e2) {
        const r2 = new SColor(this.toHex());
        return r2.l = t2, r2;
      }
      return this.l = t2, this.l < 0 ? this.l = 0 : 100 < this.l && (this.l = 100), this;
    }
    toHexString() {
      return this._convert2("hex");
    }
    toRgbaString() {
      return `rgba(${this._r},${this._g},${this._b},${this._a})`;
    }
    toHslString() {
      var e2 = this._convert2("hsl");
      return `hsl(${e2.h},${e2.s},${e2.l})`;
    }
    toString(e2 = this.colorSettings.defaultFormat) {
      switch (e2) {
        case "hex":
          return this.toHexString();
        case "hsl":
          return this.toHslString();
        default:
          return this.toRgbaString();
      }
    }
  }
  function flatten(e2, t2 = {}) {
    const r2 = {};
    if (!Array.isArray(e2) && !plainObject$7(e2))
      return e2;
    t2 = Object.assign({ separator: ".", array: false, quoteSeparatedProperties: true, quoteCharacter: '"', excludeProps: [], keepLastIntact: false }, t2);
    for (const a2 in e2)
      if (e2[a2] !== void 0)
        if (e2[a2] !== null)
          if (t2.excludeProps.indexOf(a2) === -1)
            if (Array.isArray(e2[a2]) && t2.array || (!Array.isArray(e2[a2]) && typeof e2[a2]) == "object") {
              var n2 = Array.isArray(e2[a2]), i2 = flatten(e2[a2], Object.assign(Object.assign({}, t2), { keepLastIntact: false }));
              for (const o2 in i2)
                if (i2[o2] !== void 0)
                  if (n2)
                    r2[`${a2}[${o2}]`] = i2[o2];
                  else {
                    const s2 = a2;
                    t2.quoteSeparatedProperties && s2.includes(t2.separator) ? r2["" + t2.quoteCharacter + a2 + t2.quoteCharacter + t2.separator + o2] = i2[o2] : r2[a2 + t2.separator + o2] = i2[o2];
                  }
            } else
              r2[a2] = e2[a2];
          else
            r2[a2] = e2[a2];
        else
          r2[a2] = null;
    return r2;
  }
  SColor.colors = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
  var knownCssProperties = {};
  const properties = ["accelerator", "accent-color", "-wap-accesskey", "additive-symbols", "align-content", "-webkit-align-content", "align-items", "-webkit-align-items", "align-self", "-webkit-align-self", "alignment-baseline", "all", "alt", "-webkit-alt", "animation", "animation-delay", "-moz-animation-delay", "-ms-animation-delay", "-webkit-animation-delay", "animation-direction", "-moz-animation-direction", "-ms-animation-direction", "-webkit-animation-direction", "animation-duration", "-moz-animation-duration", "-ms-animation-duration", "-webkit-animation-duration", "animation-fill-mode", "-moz-animation-fill-mode", "-ms-animation-fill-mode", "-webkit-animation-fill-mode", "animation-iteration-count", "-moz-animation-iteration-count", "-ms-animation-iteration-count", "-webkit-animation-iteration-count", "-moz-animation", "-ms-animation", "animation-name", "-moz-animation-name", "-ms-animation-name", "-webkit-animation-name", "animation-play-state", "-moz-animation-play-state", "-ms-animation-play-state", "-webkit-animation-play-state", "animation-timing-function", "-moz-animation-timing-function", "-ms-animation-timing-function", "-webkit-animation-timing-function", "-webkit-animation-trigger", "-webkit-animation", "-webkit-app-region", "appearance", "-moz-appearance", "-webkit-appearance", "ascent-override", "aspect-ratio", "-webkit-aspect-ratio", "audio-level", "azimuth", "backdrop-filter", "-webkit-backdrop-filter", "backface-visibility", "-moz-backface-visibility", "-ms-backface-visibility", "-webkit-backface-visibility", "background", "background-attachment", "-webkit-background-attachment", "background-blend-mode", "background-clip", "-moz-background-clip", "-webkit-background-clip", "background-color", "-webkit-background-color", "-webkit-background-composite", "background-image", "-webkit-background-image", "-moz-background-inline-policy", "background-origin", "-moz-background-origin", "-webkit-background-origin", "background-position", "-webkit-background-position", "background-position-x", "-webkit-background-position-x", "background-position-y", "-webkit-background-position-y", "background-repeat", "-webkit-background-repeat", "background-repeat-x", "background-repeat-y", "background-size", "-moz-background-size", "-webkit-background-size", "-webkit-background", "baseline-shift", "baseline-source", "behavior", "-moz-binding", "block-ellipsis", "-ms-block-progression", "block-size", "block-step", "block-step-align", "block-step-insert", "block-step-round", "block-step-size", "bookmark-label", "bookmark-level", "bookmark-state", "border", "-webkit-border-after-color", "-webkit-border-after-style", "-webkit-border-after", "-webkit-border-after-width", "-webkit-border-before-color", "-webkit-border-before-style", "-webkit-border-before", "-webkit-border-before-width", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "-moz-border-bottom-colors", "border-bottom-left-radius", "-webkit-border-bottom-left-radius", "border-bottom-right-radius", "-webkit-border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-boundary", "border-collapse", "border-color", "-moz-border-end-color", "-webkit-border-end-color", "border-end-end-radius", "-moz-border-end", "border-end-start-radius", "-moz-border-end-style", "-webkit-border-end-style", "-webkit-border-end", "-moz-border-end-width", "-webkit-border-end-width", "-webkit-border-fit", "-webkit-border-horizontal-spacing", "border-image", "-moz-border-image", "-o-border-image", "border-image-outset", "-webkit-border-image-outset", "border-image-repeat", "-webkit-border-image-repeat", "border-image-slice", "-webkit-border-image-slice", "border-image-source", "-webkit-border-image-source", "-webkit-border-image", "border-image-width", "-webkit-border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "-moz-border-left-colors", "border-left-style", "border-left-width", "border-radius", "-moz-border-radius-bottomleft", "-moz-border-radius-bottomright", "-moz-border-radius", "-moz-border-radius-topleft", "-moz-border-radius-topright", "-webkit-border-radius", "border-right", "border-right-color", "-moz-border-right-colors", "border-right-style", "border-right-width", "border-spacing", "-moz-border-start-color", "-webkit-border-start-color", "border-start-end-radius", "-moz-border-start", "border-start-start-radius", "-moz-border-start-style", "-webkit-border-start-style", "-webkit-border-start", "-moz-border-start-width", "-webkit-border-start-width", "border-style", "border-top", "border-top-color", "-moz-border-top-colors", "border-top-left-radius", "-webkit-border-top-left-radius", "border-top-right-radius", "-webkit-border-top-right-radius", "border-top-style", "border-top-width", "-webkit-border-vertical-spacing", "border-width", "bottom", "-moz-box-align", "-webkit-box-align", "box-decoration-break", "-webkit-box-decoration-break", "-moz-box-direction", "-webkit-box-direction", "-webkit-box-flex-group", "-moz-box-flex", "-webkit-box-flex", "-webkit-box-lines", "-moz-box-ordinal-group", "-webkit-box-ordinal-group", "-moz-box-orient", "-webkit-box-orient", "-moz-box-pack", "-webkit-box-pack", "-webkit-box-reflect", "box-shadow", "-moz-box-shadow", "-webkit-box-shadow", "box-sizing", "-moz-box-sizing", "-webkit-box-sizing", "box-snap", "break-after", "break-before", "break-inside", "buffered-rendering", "caption-side", "caret", "caret-color", "caret-shape", "chains", "clear", "clip", "clip-path", "-webkit-clip-path", "clip-rule", "color", "color-adjust", "-webkit-color-correction", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "color-scheme", "-webkit-column-axis", "-webkit-column-break-after", "-webkit-column-break-before", "-webkit-column-break-inside", "column-count", "-moz-column-count", "-webkit-column-count", "column-fill", "-moz-column-fill", "-webkit-column-fill", "column-gap", "-moz-column-gap", "-webkit-column-gap", "column-progression", "-webkit-column-progression", "column-rule", "column-rule-color", "-moz-column-rule-color", "-webkit-column-rule-color", "-moz-column-rule", "column-rule-style", "-moz-column-rule-style", "-webkit-column-rule-style", "-webkit-column-rule", "column-rule-width", "-moz-column-rule-width", "-webkit-column-rule-width", "column-span", "-moz-column-span", "-webkit-column-span", "column-width", "-moz-column-width", "-webkit-column-width", "columns", "-moz-columns", "-webkit-columns", "-webkit-composition-fill-color", "-webkit-composition-frame-color", "contain", "contain-intrinsic-block-size", "contain-intrinsic-height", "contain-intrinsic-inline-size", "contain-intrinsic-size", "contain-intrinsic-width", "content", "content-visibility", "-ms-content-zoom-chaining", "-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min", "-ms-content-zoom-limit", "-ms-content-zoom-snap", "-ms-content-zoom-snap-points", "-ms-content-zoom-snap-type", "-ms-content-zooming", "continue", "counter-increment", "counter-reset", "counter-set", "cue", "cue-after", "cue-before", "cursor", "-webkit-cursor-visibility", "cx", "cy", "d", "-apple-dashboard-region", "-webkit-dashboard-region", "descent-override", "direction", "display", "display-align", "dominant-baseline", "elevation", "empty-cells", "enable-background", "fallback", "fill", "fill-break", "fill-color", "fill-image", "fill-opacity", "fill-origin", "fill-position", "fill-repeat", "fill-rule", "fill-size", "filter", "-ms-filter", "-webkit-filter", "flex", "-ms-flex-align", "-webkit-flex-align", "flex-basis", "-webkit-flex-basis", "flex-direction", "-ms-flex-direction", "-webkit-flex-direction", "flex-flow", "-ms-flex-flow", "-webkit-flex-flow", "flex-grow", "-webkit-flex-grow", "-ms-flex-item-align", "-webkit-flex-item-align", "-ms-flex-line-pack", "-webkit-flex-line-pack", "-ms-flex", "-ms-flex-negative", "-ms-flex-order", "-webkit-flex-order", "-ms-flex-pack", "-webkit-flex-pack", "-ms-flex-positive", "-ms-flex-preferred-size", "flex-shrink", "-webkit-flex-shrink", "-webkit-flex", "flex-wrap", "-ms-flex-wrap", "-webkit-flex-wrap", "float", "float-defer", "-moz-float-edge", "float-offset", "float-reference", "flood-color", "flood-opacity", "flow", "flow-from", "-ms-flow-from", "-webkit-flow-from", "flow-into", "-ms-flow-into", "-webkit-flow-into", "font", "font-display", "font-family", "font-feature-settings", "-moz-font-feature-settings", "-ms-font-feature-settings", "-webkit-font-feature-settings", "font-kerning", "-webkit-font-kerning", "font-language-override", "-moz-font-language-override", "font-optical-sizing", "font-palette", "font-size", "font-size-adjust", "-webkit-font-size-delta", "-webkit-font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-synthesis-small-caps", "font-synthesis-style", "font-synthesis-weight", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-emoji", "font-variant-ligatures", "-webkit-font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "footnote-display", "footnote-policy", "-moz-force-broken-image-icon", "forced-color-adjust", "gap", "glyph-orientation-horizontal", "glyph-orientation-vertical", "grid", "-webkit-grid-after", "grid-area", "grid-auto-columns", "-webkit-grid-auto-columns", "grid-auto-flow", "-webkit-grid-auto-flow", "grid-auto-rows", "-webkit-grid-auto-rows", "-webkit-grid-before", "grid-column", "-ms-grid-column-align", "grid-column-end", "grid-column-gap", "-ms-grid-column", "-ms-grid-column-span", "grid-column-start", "-webkit-grid-column", "-ms-grid-columns", "-webkit-grid-columns", "-webkit-grid-end", "grid-gap", "grid-row", "-ms-grid-row-align", "grid-row-end", "grid-row-gap", "-ms-grid-row", "-ms-grid-row-span", "grid-row-start", "-webkit-grid-row", "-ms-grid-rows", "-webkit-grid-rows", "-webkit-grid-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "-ms-high-contrast-adjust", "-webkit-highlight", "hyphenate-character", "-webkit-hyphenate-character", "-webkit-hyphenate-limit-after", "-webkit-hyphenate-limit-before", "hyphenate-limit-chars", "-ms-hyphenate-limit-chars", "hyphenate-limit-last", "hyphenate-limit-lines", "-ms-hyphenate-limit-lines", "-webkit-hyphenate-limit-lines", "hyphenate-limit-zone", "-ms-hyphenate-limit-zone", "hyphens", "-moz-hyphens", "-ms-hyphens", "-webkit-hyphens", "image-orientation", "-moz-image-region", "image-rendering", "image-resolution", "-ms-ime-align", "ime-mode", "inherits", "initial-letter", "initial-letter-align", "-webkit-initial-letter", "initial-letter-wrap", "initial-value", "inline-size", "inline-sizing", "input-format", "-wap-input-format", "-wap-input-required", "input-security", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "-ms-interpolation-mode", "isolation", "justify-content", "-webkit-justify-content", "justify-items", "justify-self", "-webkit-justify-self", "kerning", "layout-flow", "layout-grid", "layout-grid-char", "layout-grid-line", "layout-grid-mode", "layout-grid-type", "leading-trim", "left", "letter-spacing", "lighting-color", "-webkit-line-align", "-webkit-line-box-contain", "line-break", "-webkit-line-break", "line-clamp", "-webkit-line-clamp", "line-gap-override", "line-grid", "-webkit-line-grid-snap", "-webkit-line-grid", "line-height", "line-height-step", "line-increment", "line-padding", "line-snap", "-webkit-line-snap", "-o-link", "-o-link-source", "list-style", "list-style-image", "list-style-position", "list-style-type", "-webkit-locale", "-webkit-logical-height", "-webkit-logical-width", "margin", "-webkit-margin-after-collapse", "-webkit-margin-after", "-webkit-margin-before-collapse", "-webkit-margin-before", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "-webkit-margin-bottom-collapse", "margin-break", "-webkit-margin-collapse", "-moz-margin-end", "-webkit-margin-end", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "-moz-margin-start", "-webkit-margin-start", "margin-top", "-webkit-margin-top-collapse", "margin-trim", "marker", "marker-end", "marker-knockout-left", "marker-knockout-right", "marker-mid", "marker-offset", "marker-pattern", "marker-segment", "marker-side", "marker-start", "marks", "-wap-marquee-dir", "-webkit-marquee-direction", "-webkit-marquee-increment", "-wap-marquee-loop", "-webkit-marquee-repetition", "-wap-marquee-speed", "-webkit-marquee-speed", "-wap-marquee-style", "-webkit-marquee-style", "-webkit-marquee", "mask", "-webkit-mask-attachment", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "-webkit-mask-box-image-outset", "-webkit-mask-box-image-repeat", "-webkit-mask-box-image-slice", "-webkit-mask-box-image-source", "-webkit-mask-box-image", "-webkit-mask-box-image-width", "mask-clip", "-webkit-mask-clip", "mask-composite", "-webkit-mask-composite", "mask-image", "-webkit-mask-image", "mask-mode", "mask-origin", "-webkit-mask-origin", "mask-position", "-webkit-mask-position", "mask-position-x", "-webkit-mask-position-x", "mask-position-y", "-webkit-mask-position-y", "mask-repeat", "-webkit-mask-repeat", "-webkit-mask-repeat-x", "-webkit-mask-repeat-y", "mask-size", "-webkit-mask-size", "mask-source-type", "-webkit-mask-source-type", "mask-type", "-webkit-mask", "-webkit-match-nearest-mail-blockquote-color", "math-style", "max-block-size", "max-height", "max-inline-size", "max-lines", "-webkit-max-logical-height", "-webkit-max-logical-width", "max-width", "max-zoom", "min-block-size", "min-height", "min-inline-size", "min-intrinsic-sizing", "-webkit-min-logical-height", "-webkit-min-logical-width", "min-width", "min-zoom", "mix-blend-mode", "motion", "motion-offset", "motion-path", "motion-rotation", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "-webkit-nbsp-mode", "negative", "object-fit", "-o-object-fit", "object-position", "-o-object-position", "offset", "offset-anchor", "offset-block-end", "offset-block-start", "offset-distance", "offset-inline-end", "offset-inline-start", "offset-path", "offset-position", "offset-rotate", "offset-rotation", "opacity", "-moz-opacity", "-webkit-opacity", "order", "-webkit-order", "-moz-orient", "orientation", "orphans", "-moz-osx-font-smoothing", "outline", "outline-color", "-moz-outline-color", "-moz-outline", "outline-offset", "-moz-outline-offset", "-moz-outline-radius-bottomleft", "-moz-outline-radius-bottomright", "-moz-outline-radius", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "outline-style", "-moz-outline-style", "outline-width", "-moz-outline-width", "overflow", "overflow-anchor", "overflow-block", "overflow-clip-margin", "overflow-inline", "-webkit-overflow-scrolling", "-ms-overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "overscroll-behavior", "overscroll-behavior-block", "overscroll-behavior-inline", "overscroll-behavior-x", "overscroll-behavior-y", "pad", "padding", "-webkit-padding-after", "-webkit-padding-before", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "-moz-padding-end", "-webkit-padding-end", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "-moz-padding-start", "-webkit-padding-start", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-orientation", "paint-order", "pause", "pause-after", "pause-before", "pen-action", "perspective", "-moz-perspective", "-ms-perspective", "perspective-origin", "-moz-perspective-origin", "-ms-perspective-origin", "-webkit-perspective-origin", "perspective-origin-x", "-webkit-perspective-origin-x", "perspective-origin-y", "-webkit-perspective-origin-y", "-webkit-perspective", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "pointer-events", "position", "prefix", "print-color-adjust", "-webkit-print-color-adjust", "property-name", "quotes", "r", "range", "-webkit-region-break-after", "-webkit-region-break-before", "-webkit-region-break-inside", "region-fragment", "-webkit-region-fragment", "-webkit-region-overflow", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotate", "row-gap", "-webkit-rtl-ordering", "ruby-align", "ruby-merge", "ruby-overhang", "ruby-position", "-webkit-ruby-position", "running", "rx", "ry", "scale", "scroll-behavior", "-ms-scroll-chaining", "-ms-scroll-limit", "-ms-scroll-limit-x-max", "-ms-scroll-limit-x-min", "-ms-scroll-limit-y-max", "-ms-scroll-limit-y-min", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "-ms-scroll-rails", "scroll-snap-align", "scroll-snap-coordinate", "-webkit-scroll-snap-coordinate", "scroll-snap-destination", "-webkit-scroll-snap-destination", "scroll-snap-margin", "scroll-snap-margin-bottom", "scroll-snap-margin-left", "scroll-snap-margin-right", "scroll-snap-margin-top", "scroll-snap-points-x", "-ms-scroll-snap-points-x", "-webkit-scroll-snap-points-x", "scroll-snap-points-y", "-ms-scroll-snap-points-y", "-webkit-scroll-snap-points-y", "scroll-snap-stop", "scroll-snap-type", "-ms-scroll-snap-type", "-webkit-scroll-snap-type", "scroll-snap-type-x", "scroll-snap-type-y", "-ms-scroll-snap-x", "-ms-scroll-snap-y", "-ms-scroll-translation", "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-color", "scrollbar-dark-shadow-color", "scrollbar-darkshadow-color", "scrollbar-face-color", "scrollbar-gutter", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-track-color", "scrollbar-width", "scrollbar3d-light-color", "scrollbar3dlight-color", "shape-image-threshold", "-webkit-shape-image-threshold", "shape-inside", "-webkit-shape-inside", "shape-margin", "-webkit-shape-margin", "shape-outside", "-webkit-shape-outside", "-webkit-shape-padding", "shape-rendering", "size", "snap-height", "solid-color", "solid-opacity", "spatial-navigation-action", "spatial-navigation-contain", "spatial-navigation-function", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "src", "-moz-stack-sizing", "stop-color", "stop-opacity", "stress", "string-set", "stroke", "stroke-align", "stroke-alignment", "stroke-break", "stroke-color", "stroke-dash-corner", "stroke-dash-justify", "stroke-dashadjust", "stroke-dasharray", "stroke-dashcorner", "stroke-dashoffset", "stroke-image", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-origin", "stroke-position", "stroke-repeat", "stroke-size", "stroke-width", "suffix", "supported-color-schemes", "-webkit-svg-shadow", "symbols", "syntax", "system", "tab-size", "-moz-tab-size", "-o-tab-size", "-o-table-baseline", "table-layout", "-webkit-tap-highlight-color", "text-align", "text-align-all", "text-align-last", "-moz-text-align-last", "text-anchor", "text-autospace", "-moz-text-blink", "-ms-text-combine-horizontal", "text-combine-upright", "-webkit-text-combine", "text-decoration", "text-decoration-blink", "text-decoration-color", "-moz-text-decoration-color", "-webkit-text-decoration-color", "text-decoration-line", "-moz-text-decoration-line", "text-decoration-line-through", "-webkit-text-decoration-line", "text-decoration-none", "text-decoration-overline", "text-decoration-skip", "text-decoration-skip-box", "text-decoration-skip-ink", "text-decoration-skip-inset", "text-decoration-skip-self", "text-decoration-skip-spaces", "-webkit-text-decoration-skip", "text-decoration-style", "-moz-text-decoration-style", "-webkit-text-decoration-style", "text-decoration-thickness", "text-decoration-underline", "-webkit-text-decoration", "-webkit-text-decorations-in-effect", "text-edge", "text-emphasis", "text-emphasis-color", "-webkit-text-emphasis-color", "text-emphasis-position", "-webkit-text-emphasis-position", "text-emphasis-skip", "text-emphasis-style", "-webkit-text-emphasis-style", "-webkit-text-emphasis", "-webkit-text-fill-color", "text-group-align", "text-indent", "text-justify", "text-justify-trim", "text-kashida", "text-kashida-space", "text-line-through", "text-line-through-color", "text-line-through-mode", "text-line-through-style", "text-line-through-width", "text-orientation", "-webkit-text-orientation", "text-overflow", "text-overline", "text-overline-color", "text-overline-mode", "text-overline-style", "text-overline-width", "text-rendering", "-webkit-text-security", "text-shadow", "text-size-adjust", "-moz-text-size-adjust", "-ms-text-size-adjust", "-webkit-text-size-adjust", "text-space-collapse", "text-space-trim", "text-spacing", "-webkit-text-stroke-color", "-webkit-text-stroke", "-webkit-text-stroke-width", "text-transform", "text-underline", "text-underline-color", "text-underline-mode", "text-underline-offset", "text-underline-position", "-webkit-text-underline-position", "text-underline-style", "text-underline-width", "text-wrap", "-webkit-text-zoom", "top", "touch-action", "touch-action-delay", "-ms-touch-action", "-webkit-touch-callout", "-ms-touch-select", "transform", "transform-box", "-moz-transform", "-ms-transform", "-o-transform", "transform-origin", "-moz-transform-origin", "-ms-transform-origin", "-o-transform-origin", "-webkit-transform-origin", "transform-origin-x", "-webkit-transform-origin-x", "transform-origin-y", "-webkit-transform-origin-y", "transform-origin-z", "-webkit-transform-origin-z", "transform-style", "-moz-transform-style", "-ms-transform-style", "-webkit-transform-style", "-webkit-transform", "transition", "transition-delay", "-moz-transition-delay", "-ms-transition-delay", "-o-transition-delay", "-webkit-transition-delay", "transition-duration", "-moz-transition-duration", "-ms-transition-duration", "-o-transition-duration", "-webkit-transition-duration", "-moz-transition", "-ms-transition", "-o-transition", "transition-property", "-moz-transition-property", "-ms-transition-property", "-o-transition-property", "-webkit-transition-property", "transition-timing-function", "-moz-transition-timing-function", "-ms-transition-timing-function", "-o-transition-timing-function", "-webkit-transition-timing-function", "-webkit-transition", "translate", "uc-alt-skin", "uc-skin", "unicode-bidi", "unicode-range", "-webkit-user-drag", "-moz-user-focus", "-moz-user-input", "-moz-user-modify", "-webkit-user-modify", "user-select", "-moz-user-select", "-ms-user-select", "-webkit-user-select", "user-zoom", "vector-effect", "vertical-align", "viewport-fill", "viewport-fill-opacity", "viewport-fit", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "-webkit-widget-region", "widows", "width", "will-change", "-moz-window-dragging", "-moz-window-shadow", "word-boundary-detection", "word-boundary-expansion", "word-break", "word-spacing", "word-wrap", "wrap-after", "wrap-before", "wrap-flow", "-ms-wrap-flow", "-webkit-wrap-flow", "wrap-inside", "-ms-wrap-margin", "-webkit-wrap-margin", "-webkit-wrap-padding", "-webkit-wrap-shape-inside", "-webkit-wrap-shape-outside", "wrap-through", "-ms-wrap-through", "-webkit-wrap-through", "-webkit-wrap", "writing-mode", "-webkit-writing-mode", "x", "y", "z-index", "zoom"];
  var require$$0 = { properties };
  knownCssProperties.all = require$$0.properties;
  var object_hash = { exports: {} };
  object_hash.exports = function n2(i2, a2, o2) {
    function s2(t2, e3) {
      if (!a2[t2]) {
        if (!i2[t2]) {
          var r2 = typeof commonjsRequire == "function" && commonjsRequire;
          if (!e3 && r2)
            return r2(t2, true);
          if (l2)
            return l2(t2, true);
          throw new Error("Cannot find module '" + t2 + "'");
        }
        r2 = a2[t2] = { exports: {} };
        i2[t2][0].call(r2.exports, function(e4) {
          return s2(i2[t2][1][e4] || e4);
        }, r2, r2.exports, n2, i2, a2, o2);
      }
      return a2[t2].exports;
    }
    for (var l2 = typeof commonjsRequire == "function" && commonjsRequire, e2 = 0; e2 < o2.length; e2++)
      s2(o2[e2]);
    return s2;
  }({ 1: [function(v2, y, _2) {
    !function(e2, t2, s2, r2, n2, i2, a2, o2, l2) {
      var c2 = v2("crypto");
      function u2(e3, t3) {
        return function(e4, t4) {
          var r3 = t4.algorithm !== "passthrough" ? c2.createHash(t4.algorithm) : new g2();
          if (r3.write === void 0 && (r3.write = r3.update, r3.end = r3.update), m2(t4, r3).dispatch(e4), r3.update || r3.end(""), r3.digest)
            return r3.digest(t4.encoding === "buffer" ? void 0 : t4.encoding);
          r3 = r3.read();
          return t4.encoding !== "buffer" ? r3.toString(t4.encoding) : r3;
        }(e3, t3 = p2(e3, t3));
      }
      (_2 = y.exports = u2).sha1 = function(e3) {
        return u2(e3);
      }, _2.keys = function(e3) {
        return u2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
      }, _2.MD5 = function(e3) {
        return u2(e3, { algorithm: "md5", encoding: "hex" });
      }, _2.keysMD5 = function(e3) {
        return u2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
      };
      var h2 = c2.getHashes ? c2.getHashes().slice() : ["sha1", "md5"];
      h2.push("passthrough");
      var d2 = ["buffer", "hex", "binary", "base64"];
      function p2(e3, t3) {
        var r3 = {};
        if (r3.algorithm = (t3 = t3 || {}).algorithm || "sha1", r3.encoding = t3.encoding || "hex", r3.excludeValues = !!t3.excludeValues, r3.algorithm = r3.algorithm.toLowerCase(), r3.encoding = r3.encoding.toLowerCase(), r3.ignoreUnknown = t3.ignoreUnknown === true, r3.respectType = t3.respectType !== false, r3.respectFunctionNames = t3.respectFunctionNames !== false, r3.respectFunctionProperties = t3.respectFunctionProperties !== false, r3.unorderedArrays = t3.unorderedArrays === true, r3.unorderedSets = t3.unorderedSets !== false, r3.unorderedObjects = t3.unorderedObjects !== false, r3.replacer = t3.replacer || void 0, r3.excludeKeys = t3.excludeKeys || void 0, e3 === void 0)
          throw new Error("Object argument required.");
        for (var n3 = 0; n3 < h2.length; ++n3)
          h2[n3].toLowerCase() === r3.algorithm.toLowerCase() && (r3.algorithm = h2[n3]);
        if (h2.indexOf(r3.algorithm) === -1)
          throw new Error('Algorithm "' + r3.algorithm + '"  not supported. supported values: ' + h2.join(", "));
        if (d2.indexOf(r3.encoding) === -1 && r3.algorithm !== "passthrough")
          throw new Error('Encoding "' + r3.encoding + '"  not supported. supported values: ' + d2.join(", "));
        return r3;
      }
      function f2(e3) {
        return typeof e3 == "function" && /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3)) != null;
      }
      function m2(i3, t3, a3) {
        function o3(e3) {
          return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
        }
        return a3 = a3 || [], { dispatch: function(e3) {
          return this["_" + ((e3 = i3.replacer ? i3.replacer(e3) : e3) === null ? "null" : typeof e3)](e3);
        }, _object: function(t4) {
          var e3 = Object.prototype.toString.call(t4), r3 = (r3 = (r3 = /\[object (.*)\]/i.exec(e3)) ? r3[1] : "unknown:[" + e3 + "]").toLowerCase();
          if (0 <= (e3 = a3.indexOf(t4)))
            return this.dispatch("[CIRCULAR:" + e3 + "]");
          if (a3.push(t4), s2 !== void 0 && s2.isBuffer && s2.isBuffer(t4))
            return o3("buffer:"), o3(t4);
          if (r3 === "object" || r3 === "function" || r3 === "asyncfunction") {
            e3 = Object.keys(t4);
            i3.unorderedObjects && (e3 = e3.sort()), i3.respectType === false || f2(t4) || e3.splice(0, 0, "prototype", "__proto__", "constructor"), o3("object:" + (e3 = i3.excludeKeys ? e3.filter(function(e4) {
              return !i3.excludeKeys(e4);
            }) : e3).length + ":");
            var n3 = this;
            return e3.forEach(function(e4) {
              n3.dispatch(e4), o3(":"), i3.excludeValues || n3.dispatch(t4[e4]), o3(",");
            });
          }
          if (!this["_" + r3]) {
            if (i3.ignoreUnknown)
              return o3("[" + r3 + "]");
            throw new Error('Unknown object type "' + r3 + '"');
          }
          this["_" + r3](t4);
        }, _array: function(e3, t4) {
          t4 = t4 !== void 0 ? t4 : i3.unorderedArrays !== false;
          var r3 = this;
          if (o3("array:" + e3.length + ":"), !t4 || e3.length <= 1)
            return e3.forEach(function(e4) {
              return r3.dispatch(e4);
            });
          var n3 = [], e3 = e3.map(function(e4) {
            var t5 = new g2(), r4 = a3.slice();
            return m2(i3, t5, r4).dispatch(e4), n3 = n3.concat(r4.slice(a3.length)), t5.read().toString();
          });
          return a3 = a3.concat(n3), e3.sort(), this._array(e3, false);
        }, _date: function(e3) {
          return o3("date:" + e3.toJSON());
        }, _symbol: function(e3) {
          return o3("symbol:" + e3.toString());
        }, _error: function(e3) {
          return o3("error:" + e3.toString());
        }, _boolean: function(e3) {
          return o3("bool:" + e3.toString());
        }, _string: function(e3) {
          o3("string:" + e3.length + ":"), o3(e3.toString());
        }, _function: function(e3) {
          o3("fn:"), f2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), i3.respectFunctionNames !== false && this.dispatch("function-name:" + String(e3.name)), i3.respectFunctionProperties && this._object(e3);
        }, _number: function(e3) {
          return o3("number:" + e3.toString());
        }, _xml: function(e3) {
          return o3("xml:" + e3.toString());
        }, _null: function() {
          return o3("Null");
        }, _undefined: function() {
          return o3("Undefined");
        }, _regexp: function(e3) {
          return o3("regex:" + e3.toString());
        }, _uint8array: function(e3) {
          return o3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _uint8clampedarray: function(e3) {
          return o3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _int8array: function(e3) {
          return o3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _uint16array: function(e3) {
          return o3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _int16array: function(e3) {
          return o3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _uint32array: function(e3) {
          return o3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _int32array: function(e3) {
          return o3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _float32array: function(e3) {
          return o3("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _float64array: function(e3) {
          return o3("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
        }, _arraybuffer: function(e3) {
          return o3("arraybuffer:"), this.dispatch(new Uint8Array(e3));
        }, _url: function(e3) {
          return o3("url:" + e3.toString());
        }, _map: function(e3) {
          o3("map:");
          e3 = Array.from(e3);
          return this._array(e3, i3.unorderedSets !== false);
        }, _set: function(e3) {
          o3("set:");
          e3 = Array.from(e3);
          return this._array(e3, i3.unorderedSets !== false);
        }, _file: function(e3) {
          return o3("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
        }, _blob: function() {
          if (i3.ignoreUnknown)
            return o3("[blob]");
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        }, _domwindow: function() {
          return o3("domwindow");
        }, _bigint: function(e3) {
          return o3("bigint:" + e3.toString());
        }, _process: function() {
          return o3("process");
        }, _timer: function() {
          return o3("timer");
        }, _pipe: function() {
          return o3("pipe");
        }, _tcp: function() {
          return o3("tcp");
        }, _udp: function() {
          return o3("udp");
        }, _tty: function() {
          return o3("tty");
        }, _statwatcher: function() {
          return o3("statwatcher");
        }, _securecontext: function() {
          return o3("securecontext");
        }, _connection: function() {
          return o3("connection");
        }, _zlib: function() {
          return o3("zlib");
        }, _context: function() {
          return o3("context");
        }, _nodescript: function() {
          return o3("nodescript");
        }, _httpparser: function() {
          return o3("httpparser");
        }, _dataview: function() {
          return o3("dataview");
        }, _signal: function() {
          return o3("signal");
        }, _fsevent: function() {
          return o3("fsevent");
        }, _tlswrap: function() {
          return o3("tlswrap");
        } };
      }
      function g2() {
        return { buf: "", write: function(e3) {
          this.buf += e3;
        }, end: function(e3) {
          this.buf += e3;
        }, read: function() {
          return this.buf;
        } };
      }
      _2.writeToStream = function(e3, t3, r3) {
        return r3 === void 0 && (r3 = t3, t3 = {}), m2(t3 = p2(e3, t3), r3).dispatch(e3);
      };
    }.call(this, v2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
  }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e2, t2, _2) {
    !function(e3, t3, r2, n2, i2, a2, o2, s2, l2) {
      function c2(e4) {
        e4 = e4.charCodeAt(0);
        return e4 === d2 || e4 === v2 ? 62 : e4 === p2 || e4 === y ? 63 : e4 < f2 ? -1 : e4 < f2 + 10 ? e4 - f2 + 26 + 26 : e4 < g2 + 26 ? e4 - g2 : e4 < m2 + 26 ? e4 - m2 + 26 : void 0;
      }
      var u2, h2, d2, p2, f2, m2, g2, v2, y;
      u2 = _2 === void 0 ? this.base64js = {} : _2, h2 = typeof Uint8Array != "undefined" ? Uint8Array : Array, d2 = "+".charCodeAt(0), p2 = "/".charCodeAt(0), f2 = "0".charCodeAt(0), m2 = "a".charCodeAt(0), g2 = "A".charCodeAt(0), v2 = "-".charCodeAt(0), y = "_".charCodeAt(0), u2.toByteArray = function(e4) {
        var t4, r3;
        if (0 < e4.length % 4)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var n3 = e4.length, n3 = e4.charAt(n3 - 2) === "=" ? 2 : e4.charAt(n3 - 1) === "=" ? 1 : 0, i3 = new h2(3 * e4.length / 4 - n3), a3 = 0 < n3 ? e4.length - 4 : e4.length, o3 = 0;
        function s3(e5) {
          i3[o3++] = e5;
        }
        for (t4 = 0; t4 < a3; t4 += 4)
          s3((16711680 & (r3 = c2(e4.charAt(t4)) << 18 | c2(e4.charAt(t4 + 1)) << 12 | c2(e4.charAt(t4 + 2)) << 6 | c2(e4.charAt(t4 + 3)))) >> 16), s3((65280 & r3) >> 8), s3(255 & r3);
        return n3 == 2 ? s3(255 & (r3 = c2(e4.charAt(t4)) << 2 | c2(e4.charAt(t4 + 1)) >> 4)) : n3 == 1 && (s3((r3 = c2(e4.charAt(t4)) << 10 | c2(e4.charAt(t4 + 1)) << 4 | c2(e4.charAt(t4 + 2)) >> 2) >> 8 & 255), s3(255 & r3)), i3;
      }, u2.fromByteArray = function(e4) {
        var t4, r3, n3, i3, a3 = e4.length % 3, o3 = "";
        function s3(e5) {
          return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
        }
        for (t4 = 0, n3 = e4.length - a3; t4 < n3; t4 += 3)
          o3 += s3((i3 = r3 = (e4[t4] << 16) + (e4[t4 + 1] << 8) + e4[t4 + 2]) >> 18 & 63) + s3(i3 >> 12 & 63) + s3(i3 >> 6 & 63) + s3(63 & i3);
        switch (a3) {
          case 1:
            o3 += s3((r3 = e4[e4.length - 1]) >> 2), o3 += s3(r3 << 4 & 63), o3 += "==";
            break;
          case 2:
            o3 += s3((r3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10), o3 += s3(r3 >> 4 & 63), o3 += s3(r3 << 2 & 63), o3 += "=";
        }
        return o3;
      };
    }.call(this, e2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
  }, { buffer: 3, lYpoI2: 10 }], 3: [function(D, e2, N2) {
    !function(e3, t2, h2, r2, n2, i2, a2, o2, s2) {
      var l2 = D("base64-js"), c2 = D("ieee754");
      function h2(e4, t3, r3) {
        if (!(this instanceof h2))
          return new h2(e4, t3, r3);
        var n3, i3, a3, o3, s3 = typeof e4;
        if (t3 === "base64" && s3 == "string")
          for (e4 = (o3 = e4).trim ? o3.trim() : o3.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; )
            e4 += "=";
        if (s3 == "number")
          n3 = E2(e4);
        else if (s3 == "string")
          n3 = h2.byteLength(e4, t3);
        else {
          if (s3 != "object")
            throw new Error("First argument needs to be a number, array or string.");
          n3 = E2(e4.length);
        }
        if (h2._useTypedArrays ? i3 = h2._augment(new Uint8Array(n3)) : ((i3 = this).length = n3, i3._isBuffer = true), h2._useTypedArrays && typeof e4.byteLength == "number")
          i3._set(e4);
        else if (T2(o3 = e4) || h2.isBuffer(o3) || o3 && typeof o3 == "object" && typeof o3.length == "number")
          for (a3 = 0; a3 < n3; a3++)
            h2.isBuffer(e4) ? i3[a3] = e4.readUInt8(a3) : i3[a3] = e4[a3];
        else if (s3 == "string")
          i3.write(e4, 0, t3);
        else if (s3 == "number" && !h2._useTypedArrays && !r3)
          for (a3 = 0; a3 < n3; a3++)
            i3[a3] = 0;
        return i3;
      }
      function u2(e4, t3, r3, n3) {
        n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 != null, "missing offset"), I2(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
        var i3, n3 = e4.length;
        if (!(n3 <= t3))
          return r3 ? (i3 = e4[t3], t3 + 1 < n3 && (i3 |= e4[t3 + 1] << 8)) : (i3 = e4[t3] << 8, t3 + 1 < n3 && (i3 |= e4[t3 + 1])), i3;
      }
      function d2(e4, t3, r3, n3) {
        n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 != null, "missing offset"), I2(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
        var i3, n3 = e4.length;
        if (!(n3 <= t3))
          return r3 ? (t3 + 2 < n3 && (i3 = e4[t3 + 2] << 16), t3 + 1 < n3 && (i3 |= e4[t3 + 1] << 8), i3 |= e4[t3], t3 + 3 < n3 && (i3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < n3 && (i3 = e4[t3 + 1] << 16), t3 + 2 < n3 && (i3 |= e4[t3 + 2] << 8), t3 + 3 < n3 && (i3 |= e4[t3 + 3]), i3 += e4[t3] << 24 >>> 0), i3;
      }
      function p2(e4, t3, r3, n3) {
        if (n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 != null, "missing offset"), I2(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
          r3 = u2(e4, t3, r3, true);
          return 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
        }
      }
      function f2(e4, t3, r3, n3) {
        if (n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 != null, "missing offset"), I2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
          r3 = d2(e4, t3, r3, true);
          return 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
        }
      }
      function m2(e4, t3, r3, n3) {
        return n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), c2.read(e4, t3, r3, 23, 4);
      }
      function g2(e4, t3, r3, n3) {
        return n3 || (I2(typeof r3 == "boolean", "missing or invalid endian"), I2(t3 + 7 < e4.length, "Trying to read beyond buffer length")), c2.read(e4, t3, r3, 52, 8);
      }
      function v2(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 1 < e4.length, "trying to write beyond buffer length"), L(t3, 65535));
        i3 = e4.length;
        if (!(i3 <= r3))
          for (var a3 = 0, o3 = Math.min(i3 - r3, 2); a3 < o3; a3++)
            e4[r3 + a3] = (t3 & 255 << 8 * (n3 ? a3 : 1 - a3)) >>> 8 * (n3 ? a3 : 1 - a3);
      }
      function y(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 3 < e4.length, "trying to write beyond buffer length"), L(t3, 4294967295));
        i3 = e4.length;
        if (!(i3 <= r3))
          for (var a3 = 0, o3 = Math.min(i3 - r3, 4); a3 < o3; a3++)
            e4[r3 + a3] = t3 >>> 8 * (n3 ? a3 : 3 - a3) & 255;
      }
      function _2(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 1 < e4.length, "Trying to write beyond buffer length"), O(t3, 32767, -32768)), e4.length <= r3 || v2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, r3, n3, i3);
      }
      function b2(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 3 < e4.length, "Trying to write beyond buffer length"), O(t3, 2147483647, -2147483648)), e4.length <= r3 || y(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, r3, n3, i3);
      }
      function x2(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 3 < e4.length, "Trying to write beyond buffer length"), P2(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= r3 || c2.write(e4, t3, r3, n3, 23, 4);
      }
      function w2(e4, t3, r3, n3, i3) {
        i3 || (I2(t3 != null, "missing value"), I2(typeof n3 == "boolean", "missing or invalid endian"), I2(r3 != null, "missing offset"), I2(r3 + 7 < e4.length, "Trying to write beyond buffer length"), P2(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= r3 || c2.write(e4, t3, r3, n3, 52, 8);
      }
      N2.Buffer = h2, N2.SlowBuffer = h2, N2.INSPECT_MAX_BYTES = 50, h2.poolSize = 8192, h2._useTypedArrays = function() {
        try {
          var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
          return t3.foo = function() {
            return 42;
          }, t3.foo() === 42 && typeof t3.subarray == "function";
        } catch (e5) {
          return false;
        }
      }(), h2.isEncoding = function(e4) {
        switch (String(e4).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "raw":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, h2.isBuffer = function(e4) {
        return !(e4 == null || !e4._isBuffer);
      }, h2.byteLength = function(e4, t3) {
        var r3;
        switch (e4 += "", t3 || "utf8") {
          case "hex":
            r3 = e4.length / 2;
            break;
          case "utf8":
          case "utf-8":
            r3 = A2(e4).length;
            break;
          case "ascii":
          case "binary":
          case "raw":
            r3 = e4.length;
            break;
          case "base64":
            r3 = C2(e4).length;
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            r3 = 2 * e4.length;
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return r3;
      }, h2.concat = function(e4, t3) {
        if (I2(T2(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), e4.length === 0)
          return new h2(0);
        if (e4.length === 1)
          return e4[0];
        if (typeof t3 != "number")
          for (i3 = t3 = 0; i3 < e4.length; i3++)
            t3 += e4[i3].length;
        for (var r3 = new h2(t3), n3 = 0, i3 = 0; i3 < e4.length; i3++) {
          var a3 = e4[i3];
          a3.copy(r3, n3), n3 += a3.length;
        }
        return r3;
      }, h2.prototype.write = function(e4, s3, t3, r3) {
        isFinite(s3) ? isFinite(t3) || (r3 = t3, t3 = void 0) : (u3 = r3, r3 = s3, s3 = t3, t3 = u3), s3 = Number(s3) || 0;
        var n3, i3, a3, o3, l3, c3, u3 = this.length - s3;
        switch ((!t3 || u3 < (t3 = Number(t3))) && (t3 = u3), r3 = String(r3 || "utf8").toLowerCase()) {
          case "hex":
            n3 = function(e5, t4, r4, n4) {
              r4 = Number(s3) || 0;
              var i4 = e5.length - r4;
              (!n4 || i4 < (n4 = Number(n4))) && (n4 = i4);
              i4 = t4.length;
              I2(i4 % 2 == 0, "Invalid hex string"), i4 / 2 < n4 && (n4 = i4 / 2);
              for (var a4 = 0; a4 < n4; a4++) {
                var o4 = parseInt(t4.substr(2 * a4, 2), 16);
                I2(!isNaN(o4), "Invalid hex string"), e5[r4 + a4] = o4;
              }
              return h2._charsWritten = 2 * a4, a4;
            }(this, e4, 0, t3);
            break;
          case "utf8":
          case "utf-8":
            o3 = s3, l3 = t3, n3 = h2._charsWritten = $2(A2(e4), this, o3, l3);
            break;
          case "ascii":
          case "binary":
            o3 = this, l3 = s3, c3 = t3, n3 = h2._charsWritten = $2(function(e5) {
              for (var t4 = [], r4 = 0; r4 < e5.length; r4++)
                t4.push(255 & e5.charCodeAt(r4));
              return t4;
            }(e4), o3, l3, c3);
            break;
          case "base64":
            i3 = s3, a3 = t3, n3 = h2._charsWritten = $2(C2(e4), this, i3, a3);
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            c3 = this, i3 = s3, a3 = t3, n3 = h2._charsWritten = $2(function(e5) {
              for (var t4, r4, n4 = [], i4 = 0; i4 < e5.length; i4++)
                r4 = (t4 = e5.charCodeAt(i4)) >> 8, n4.push(t4 % 256), n4.push(r4);
              return n4;
            }(e4), c3, i3, a3);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return n3;
      }, h2.prototype.toString = function(e4, t3, r3) {
        var n3, i3, a3, o3, s3 = this;
        if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (r3 = r3 !== void 0 ? Number(r3) : this.length) === t3)
          return "";
        switch (e4) {
          case "hex":
            n3 = function(e5, t4, r4) {
              var n4 = e5.length;
              (!r4 || r4 < 0 || n4 < r4) && (r4 = n4);
              for (var i4 = "", a4 = t4 = !t4 || t4 < 0 ? 0 : t4; a4 < r4; a4++)
                i4 += k2(e5[a4]);
              return i4;
            }(this, t3, r3);
            break;
          case "utf8":
          case "utf-8":
            n3 = function(e5, t4, r4) {
              var n4 = "", i4 = "";
              r4 = Math.min(e5.length, r4);
              for (var a4 = t4; a4 < r4; a4++)
                e5[a4] <= 127 ? (n4 += R2(i4) + String.fromCharCode(e5[a4]), i4 = "") : i4 += "%" + e5[a4].toString(16);
              return n4 + R2(i4);
            }(this, t3, r3);
            break;
          case "ascii":
          case "binary":
            n3 = function(e5, t4, r4) {
              var n4 = "";
              r4 = Math.min(e5.length, r4);
              for (var i4 = t4; i4 < r4; i4++)
                n4 += String.fromCharCode(e5[i4]);
              return n4;
            }(this, t3, r3);
            break;
          case "base64":
            i3 = this, o3 = r3, n3 = (a3 = t3) === 0 && o3 === i3.length ? l2.fromByteArray(i3) : l2.fromByteArray(i3.slice(a3, o3));
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            n3 = function(e5, t4) {
              for (var r4 = s3.slice(e5, t4), n4 = "", i4 = 0; i4 < r4.length; i4 += 2)
                n4 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
              return n4;
            }(t3, r3);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return n3;
      }, h2.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      }, h2.prototype.copy = function(e4, t3, r3, n3) {
        if (t3 = t3 || 0, (n3 = !n3 && n3 !== 0 ? this.length : n3) !== (r3 = r3 || 0) && e4.length !== 0 && this.length !== 0) {
          I2(r3 <= n3, "sourceEnd < sourceStart"), I2(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), I2(0 <= r3 && r3 < this.length, "sourceStart out of bounds"), I2(0 <= n3 && n3 <= this.length, "sourceEnd out of bounds"), n3 > this.length && (n3 = this.length);
          var i3 = (n3 = e4.length - t3 < n3 - r3 ? e4.length - t3 + r3 : n3) - r3;
          if (i3 < 100 || !h2._useTypedArrays)
            for (var a3 = 0; a3 < i3; a3++)
              e4[a3 + t3] = this[a3 + r3];
          else
            e4._set(this.subarray(r3, r3 + i3), t3);
        }
      }, h2.prototype.slice = function(e4, t3) {
        var r3 = this.length;
        if (e4 = M2(e4, r3, 0), t3 = M2(t3, r3, r3), h2._useTypedArrays)
          return h2._augment(this.subarray(e4, t3));
        for (var n3 = t3 - e4, i3 = new h2(n3, void 0, true), a3 = 0; a3 < n3; a3++)
          i3[a3] = this[a3 + e4];
        return i3;
      }, h2.prototype.get = function(e4) {
        return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
      }, h2.prototype.set = function(e4, t3) {
        return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
      }, h2.prototype.readUInt8 = function(e4, t3) {
        if (t3 || (I2(e4 != null, "missing offset"), I2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
          return this[e4];
      }, h2.prototype.readUInt16LE = function(e4, t3) {
        return u2(this, e4, true, t3);
      }, h2.prototype.readUInt16BE = function(e4, t3) {
        return u2(this, e4, false, t3);
      }, h2.prototype.readUInt32LE = function(e4, t3) {
        return d2(this, e4, true, t3);
      }, h2.prototype.readUInt32BE = function(e4, t3) {
        return d2(this, e4, false, t3);
      }, h2.prototype.readInt8 = function(e4, t3) {
        if (t3 || (I2(e4 != null, "missing offset"), I2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
          return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
      }, h2.prototype.readInt16LE = function(e4, t3) {
        return p2(this, e4, true, t3);
      }, h2.prototype.readInt16BE = function(e4, t3) {
        return p2(this, e4, false, t3);
      }, h2.prototype.readInt32LE = function(e4, t3) {
        return f2(this, e4, true, t3);
      }, h2.prototype.readInt32BE = function(e4, t3) {
        return f2(this, e4, false, t3);
      }, h2.prototype.readFloatLE = function(e4, t3) {
        return m2(this, e4, true, t3);
      }, h2.prototype.readFloatBE = function(e4, t3) {
        return m2(this, e4, false, t3);
      }, h2.prototype.readDoubleLE = function(e4, t3) {
        return g2(this, e4, true, t3);
      }, h2.prototype.readDoubleBE = function(e4, t3) {
        return g2(this, e4, false, t3);
      }, h2.prototype.writeUInt8 = function(e4, t3, r3) {
        r3 || (I2(e4 != null, "missing value"), I2(t3 != null, "missing offset"), I2(t3 < this.length, "trying to write beyond buffer length"), L(e4, 255)), t3 >= this.length || (this[t3] = e4);
      }, h2.prototype.writeUInt16LE = function(e4, t3, r3) {
        v2(this, e4, t3, true, r3);
      }, h2.prototype.writeUInt16BE = function(e4, t3, r3) {
        v2(this, e4, t3, false, r3);
      }, h2.prototype.writeUInt32LE = function(e4, t3, r3) {
        y(this, e4, t3, true, r3);
      }, h2.prototype.writeUInt32BE = function(e4, t3, r3) {
        y(this, e4, t3, false, r3);
      }, h2.prototype.writeInt8 = function(e4, t3, r3) {
        r3 || (I2(e4 != null, "missing value"), I2(t3 != null, "missing offset"), I2(t3 < this.length, "Trying to write beyond buffer length"), O(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, r3) : this.writeUInt8(255 + e4 + 1, t3, r3));
      }, h2.prototype.writeInt16LE = function(e4, t3, r3) {
        _2(this, e4, t3, true, r3);
      }, h2.prototype.writeInt16BE = function(e4, t3, r3) {
        _2(this, e4, t3, false, r3);
      }, h2.prototype.writeInt32LE = function(e4, t3, r3) {
        b2(this, e4, t3, true, r3);
      }, h2.prototype.writeInt32BE = function(e4, t3, r3) {
        b2(this, e4, t3, false, r3);
      }, h2.prototype.writeFloatLE = function(e4, t3, r3) {
        x2(this, e4, t3, true, r3);
      }, h2.prototype.writeFloatBE = function(e4, t3, r3) {
        x2(this, e4, t3, false, r3);
      }, h2.prototype.writeDoubleLE = function(e4, t3, r3) {
        w2(this, e4, t3, true, r3);
      }, h2.prototype.writeDoubleBE = function(e4, t3, r3) {
        w2(this, e4, t3, false, r3);
      }, h2.prototype.fill = function(e4, t3, r3) {
        if (t3 = t3 || 0, r3 = r3 || this.length, I2(typeof (e4 = typeof (e4 = e4 || 0) == "string" ? e4.charCodeAt(0) : e4) == "number" && !isNaN(e4), "value is not a number"), I2(t3 <= r3, "end < start"), r3 !== t3 && this.length !== 0) {
          I2(0 <= t3 && t3 < this.length, "start out of bounds"), I2(0 <= r3 && r3 <= this.length, "end out of bounds");
          for (var n3 = t3; n3 < r3; n3++)
            this[n3] = e4;
        }
      }, h2.prototype.inspect = function() {
        for (var e4 = [], t3 = this.length, r3 = 0; r3 < t3; r3++)
          if (e4[r3] = k2(this[r3]), r3 === N2.INSPECT_MAX_BYTES) {
            e4[r3 + 1] = "...";
            break;
          }
        return "<Buffer " + e4.join(" ") + ">";
      }, h2.prototype.toArrayBuffer = function() {
        if (typeof Uint8Array == "undefined")
          throw new Error("Buffer.toArrayBuffer not supported in this browser");
        if (h2._useTypedArrays)
          return new h2(this).buffer;
        for (var e4 = new Uint8Array(this.length), t3 = 0, r3 = e4.length; t3 < r3; t3 += 1)
          e4[t3] = this[t3];
        return e4.buffer;
      };
      var S2 = h2.prototype;
      function M2(e4, t3, r3) {
        return typeof e4 != "number" ? r3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
      }
      function E2(e4) {
        return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
      }
      function T2(e4) {
        return (Array.isArray || function(e5) {
          return Object.prototype.toString.call(e5) === "[object Array]";
        })(e4);
      }
      function k2(e4) {
        return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
      }
      function A2(e4) {
        for (var t3 = [], r3 = 0; r3 < e4.length; r3++) {
          var n3 = e4.charCodeAt(r3);
          if (n3 <= 127)
            t3.push(e4.charCodeAt(r3));
          else {
            var i3 = r3;
            55296 <= n3 && n3 <= 57343 && r3++;
            for (var a3 = encodeURIComponent(e4.slice(i3, r3 + 1)).substr(1).split("%"), o3 = 0; o3 < a3.length; o3++)
              t3.push(parseInt(a3[o3], 16));
          }
        }
        return t3;
      }
      function C2(e4) {
        return l2.toByteArray(e4);
      }
      function $2(e4, t3, r3, n3) {
        for (var i3 = 0; i3 < n3 && !(i3 + r3 >= t3.length || i3 >= e4.length); i3++)
          t3[i3 + r3] = e4[i3];
        return i3;
      }
      function R2(e4) {
        try {
          return decodeURIComponent(e4);
        } catch (e5) {
          return String.fromCharCode(65533);
        }
      }
      function L(e4, t3) {
        I2(typeof e4 == "number", "cannot write a non-number as a number"), I2(0 <= e4, "specified a negative value for writing an unsigned value"), I2(e4 <= t3, "value is larger than maximum value for type"), I2(Math.floor(e4) === e4, "value has a fractional component");
      }
      function O(e4, t3, r3) {
        I2(typeof e4 == "number", "cannot write a non-number as a number"), I2(e4 <= t3, "value larger than maximum allowed value"), I2(r3 <= e4, "value smaller than minimum allowed value"), I2(Math.floor(e4) === e4, "value has a fractional component");
      }
      function P2(e4, t3, r3) {
        I2(typeof e4 == "number", "cannot write a non-number as a number"), I2(e4 <= t3, "value larger than maximum allowed value"), I2(r3 <= e4, "value smaller than minimum allowed value");
      }
      function I2(e4, t3) {
        if (!e4)
          throw new Error(t3 || "Failed assertion");
      }
      h2._augment = function(e4) {
        return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = S2.get, e4.set = S2.set, e4.write = S2.write, e4.toString = S2.toString, e4.toLocaleString = S2.toString, e4.toJSON = S2.toJSON, e4.copy = S2.copy, e4.slice = S2.slice, e4.readUInt8 = S2.readUInt8, e4.readUInt16LE = S2.readUInt16LE, e4.readUInt16BE = S2.readUInt16BE, e4.readUInt32LE = S2.readUInt32LE, e4.readUInt32BE = S2.readUInt32BE, e4.readInt8 = S2.readInt8, e4.readInt16LE = S2.readInt16LE, e4.readInt16BE = S2.readInt16BE, e4.readInt32LE = S2.readInt32LE, e4.readInt32BE = S2.readInt32BE, e4.readFloatLE = S2.readFloatLE, e4.readFloatBE = S2.readFloatBE, e4.readDoubleLE = S2.readDoubleLE, e4.readDoubleBE = S2.readDoubleBE, e4.writeUInt8 = S2.writeUInt8, e4.writeUInt16LE = S2.writeUInt16LE, e4.writeUInt16BE = S2.writeUInt16BE, e4.writeUInt32LE = S2.writeUInt32LE, e4.writeUInt32BE = S2.writeUInt32BE, e4.writeInt8 = S2.writeInt8, e4.writeInt16LE = S2.writeInt16LE, e4.writeInt16BE = S2.writeInt16BE, e4.writeInt32LE = S2.writeInt32LE, e4.writeInt32BE = S2.writeInt32BE, e4.writeFloatLE = S2.writeFloatLE, e4.writeFloatBE = S2.writeFloatBE, e4.writeDoubleLE = S2.writeDoubleLE, e4.writeDoubleBE = S2.writeDoubleBE, e4.fill = S2.fill, e4.inspect = S2.inspect, e4.toArrayBuffer = S2.toArrayBuffer, e4;
      };
    }.call(this, D("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, D("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
  }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(u2, h2, e2) {
    !function(e3, t2, o2, r2, n2, i2, a2, s2, l2) {
      var o2 = u2("buffer").Buffer, c2 = new o2(4);
      c2.fill(0), h2.exports = { hash: function(e4, t3, a3, r3) {
        return function(e5, t4) {
          for (var r4 = new o2(a3), n3 = t4 ? r4.writeInt32BE : r4.writeInt32LE, i3 = 0; i3 < e5.length; i3++)
            n3.call(r4, e5[i3], 4 * i3, true);
          return r4;
        }(t3(function(e5, t4) {
          var r4;
          e5.length % 4 != 0 && (r4 = e5.length + (4 - e5.length % 4), e5 = o2.concat([e5, c2], r4));
          for (var n3 = [], i3 = t4 ? e5.readInt32BE : e5.readInt32LE, a4 = 0; a4 < e5.length; a4 += 4)
            n3.push(i3.call(e5, a4));
          return n3;
        }(e4 = !o2.isBuffer(e4) ? new o2(e4) : e4, r3), 8 * e4.length), r3);
      } };
    }.call(this, u2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, u2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 5: [function(g2, e2, v2) {
    !function(e3, t2, o2, r2, n2, i2, a2, s2, l2) {
      var o2 = g2("buffer").Buffer, c2 = g2("./sha"), u2 = g2("./sha256"), h2 = g2("./rng"), d2 = { sha1: c2, sha256: u2, md5: g2("./md5") }, p2 = new o2(64);
      function f2(e4, r3) {
        var n3 = d2[e4 = e4 || "sha1"], i3 = [];
        return n3 || m2("algorithm:", e4, "is not yet supported"), { update: function(e5) {
          return o2.isBuffer(e5) || (e5 = new o2(e5)), i3.push(e5), e5.length, this;
        }, digest: function(e5) {
          var t3 = o2.concat(i3), t3 = r3 ? function(e6, t4, r4) {
            o2.isBuffer(t4) || (t4 = new o2(t4)), o2.isBuffer(r4) || (r4 = new o2(r4)), 64 < t4.length ? t4 = e6(t4) : t4.length < 64 && (t4 = o2.concat([t4, p2], 64));
            for (var n4 = new o2(64), i4 = new o2(64), a3 = 0; a3 < 64; a3++)
              n4[a3] = 54 ^ t4[a3], i4[a3] = 92 ^ t4[a3];
            r4 = e6(o2.concat([n4, r4]));
            return e6(o2.concat([i4, r4]));
          }(n3, r3, t3) : n3(t3);
          return i3 = null, e5 ? t3.toString(e5) : t3;
        } };
      }
      function m2() {
        var e4 = [].slice.call(arguments).join(" ");
        throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
      }
      p2.fill(0), v2.createHash = function(e4) {
        return f2(e4);
      }, v2.createHmac = f2, v2.randomBytes = function(e4, t3) {
        if (!t3 || !t3.call)
          return new o2(h2(e4));
        try {
          t3.call(this, void 0, new o2(h2(e4)));
        } catch (e5) {
          t3(e5);
        }
      }, function(e4) {
        for (var t3 in e4)
          !function(e5) {
            v2[e5] = function() {
              m2("sorry,", e5, "is not implemented yet");
            };
          }(e4[t3]);
      }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"]);
    }.call(this, g2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, g2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(v2, y, e2) {
    !function(e3, t2, r2, n2, i2, a2, o2, s2, l2) {
      var c2 = v2("./helpers");
      function u2(e4, t3) {
        e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
        for (var r3 = 1732584193, n3 = -271733879, i3 = -1732584194, a3 = 271733878, o3 = 0; o3 < e4.length; o3 += 16) {
          var s3 = r3, l3 = n3, c3 = i3, u3 = a3, r3 = d2(r3, n3, i3, a3, e4[o3 + 0], 7, -680876936), a3 = d2(a3, r3, n3, i3, e4[o3 + 1], 12, -389564586), i3 = d2(i3, a3, r3, n3, e4[o3 + 2], 17, 606105819), n3 = d2(n3, i3, a3, r3, e4[o3 + 3], 22, -1044525330);
          r3 = d2(r3, n3, i3, a3, e4[o3 + 4], 7, -176418897), a3 = d2(a3, r3, n3, i3, e4[o3 + 5], 12, 1200080426), i3 = d2(i3, a3, r3, n3, e4[o3 + 6], 17, -1473231341), n3 = d2(n3, i3, a3, r3, e4[o3 + 7], 22, -45705983), r3 = d2(r3, n3, i3, a3, e4[o3 + 8], 7, 1770035416), a3 = d2(a3, r3, n3, i3, e4[o3 + 9], 12, -1958414417), i3 = d2(i3, a3, r3, n3, e4[o3 + 10], 17, -42063), n3 = d2(n3, i3, a3, r3, e4[o3 + 11], 22, -1990404162), r3 = d2(r3, n3, i3, a3, e4[o3 + 12], 7, 1804603682), a3 = d2(a3, r3, n3, i3, e4[o3 + 13], 12, -40341101), i3 = d2(i3, a3, r3, n3, e4[o3 + 14], 17, -1502002290), r3 = p2(r3, n3 = d2(n3, i3, a3, r3, e4[o3 + 15], 22, 1236535329), i3, a3, e4[o3 + 1], 5, -165796510), a3 = p2(a3, r3, n3, i3, e4[o3 + 6], 9, -1069501632), i3 = p2(i3, a3, r3, n3, e4[o3 + 11], 14, 643717713), n3 = p2(n3, i3, a3, r3, e4[o3 + 0], 20, -373897302), r3 = p2(r3, n3, i3, a3, e4[o3 + 5], 5, -701558691), a3 = p2(a3, r3, n3, i3, e4[o3 + 10], 9, 38016083), i3 = p2(i3, a3, r3, n3, e4[o3 + 15], 14, -660478335), n3 = p2(n3, i3, a3, r3, e4[o3 + 4], 20, -405537848), r3 = p2(r3, n3, i3, a3, e4[o3 + 9], 5, 568446438), a3 = p2(a3, r3, n3, i3, e4[o3 + 14], 9, -1019803690), i3 = p2(i3, a3, r3, n3, e4[o3 + 3], 14, -187363961), n3 = p2(n3, i3, a3, r3, e4[o3 + 8], 20, 1163531501), r3 = p2(r3, n3, i3, a3, e4[o3 + 13], 5, -1444681467), a3 = p2(a3, r3, n3, i3, e4[o3 + 2], 9, -51403784), i3 = p2(i3, a3, r3, n3, e4[o3 + 7], 14, 1735328473), r3 = f2(r3, n3 = p2(n3, i3, a3, r3, e4[o3 + 12], 20, -1926607734), i3, a3, e4[o3 + 5], 4, -378558), a3 = f2(a3, r3, n3, i3, e4[o3 + 8], 11, -2022574463), i3 = f2(i3, a3, r3, n3, e4[o3 + 11], 16, 1839030562), n3 = f2(n3, i3, a3, r3, e4[o3 + 14], 23, -35309556), r3 = f2(r3, n3, i3, a3, e4[o3 + 1], 4, -1530992060), a3 = f2(a3, r3, n3, i3, e4[o3 + 4], 11, 1272893353), i3 = f2(i3, a3, r3, n3, e4[o3 + 7], 16, -155497632), n3 = f2(n3, i3, a3, r3, e4[o3 + 10], 23, -1094730640), r3 = f2(r3, n3, i3, a3, e4[o3 + 13], 4, 681279174), a3 = f2(a3, r3, n3, i3, e4[o3 + 0], 11, -358537222), i3 = f2(i3, a3, r3, n3, e4[o3 + 3], 16, -722521979), n3 = f2(n3, i3, a3, r3, e4[o3 + 6], 23, 76029189), r3 = f2(r3, n3, i3, a3, e4[o3 + 9], 4, -640364487), a3 = f2(a3, r3, n3, i3, e4[o3 + 12], 11, -421815835), i3 = f2(i3, a3, r3, n3, e4[o3 + 15], 16, 530742520), r3 = m2(r3, n3 = f2(n3, i3, a3, r3, e4[o3 + 2], 23, -995338651), i3, a3, e4[o3 + 0], 6, -198630844), a3 = m2(a3, r3, n3, i3, e4[o3 + 7], 10, 1126891415), i3 = m2(i3, a3, r3, n3, e4[o3 + 14], 15, -1416354905), n3 = m2(n3, i3, a3, r3, e4[o3 + 5], 21, -57434055), r3 = m2(r3, n3, i3, a3, e4[o3 + 12], 6, 1700485571), a3 = m2(a3, r3, n3, i3, e4[o3 + 3], 10, -1894986606), i3 = m2(i3, a3, r3, n3, e4[o3 + 10], 15, -1051523), n3 = m2(n3, i3, a3, r3, e4[o3 + 1], 21, -2054922799), r3 = m2(r3, n3, i3, a3, e4[o3 + 8], 6, 1873313359), a3 = m2(a3, r3, n3, i3, e4[o3 + 15], 10, -30611744), i3 = m2(i3, a3, r3, n3, e4[o3 + 6], 15, -1560198380), n3 = m2(n3, i3, a3, r3, e4[o3 + 13], 21, 1309151649), r3 = m2(r3, n3, i3, a3, e4[o3 + 4], 6, -145523070), a3 = m2(a3, r3, n3, i3, e4[o3 + 11], 10, -1120210379), i3 = m2(i3, a3, r3, n3, e4[o3 + 2], 15, 718787259), n3 = m2(n3, i3, a3, r3, e4[o3 + 9], 21, -343485551), r3 = g2(r3, s3), n3 = g2(n3, l3), i3 = g2(i3, c3), a3 = g2(a3, u3);
        }
        return Array(r3, n3, i3, a3);
      }
      function h2(e4, t3, r3, n3, i3, a3) {
        return g2((a3 = g2(g2(t3, e4), g2(n3, a3))) << i3 | a3 >>> 32 - i3, r3);
      }
      function d2(e4, t3, r3, n3, i3, a3, o3) {
        return h2(t3 & r3 | ~t3 & n3, e4, t3, i3, a3, o3);
      }
      function p2(e4, t3, r3, n3, i3, a3, o3) {
        return h2(t3 & n3 | r3 & ~n3, e4, t3, i3, a3, o3);
      }
      function f2(e4, t3, r3, n3, i3, a3, o3) {
        return h2(t3 ^ r3 ^ n3, e4, t3, i3, a3, o3);
      }
      function m2(e4, t3, r3, n3, i3, a3, o3) {
        return h2(r3 ^ (t3 | ~n3), e4, t3, i3, a3, o3);
      }
      function g2(e4, t3) {
        var r3 = (65535 & e4) + (65535 & t3);
        return (e4 >> 16) + (t3 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      y.exports = function(e4) {
        return c2.hash(e4, u2, 16);
      };
    }.call(this, v2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e2, c2, t2) {
    !function(e3, t3, r2, n2, i2, a2, o2, s2, l2) {
      c2.exports = function(e4) {
        for (var t4, r3 = new Array(e4), n3 = 0; n3 < e4; n3++)
          (3 & n3) == 0 && (t4 = 4294967296 * Math.random()), r3[n3] = t4 >>> ((3 & n3) << 3) & 255;
        return r3;
      };
    }.call(this, e2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 8: [function(h2, d2, e2) {
    !function(e3, t2, r2, n2, i2, a2, o2, s2, l2) {
      var c2 = h2("./helpers");
      function u2(e4, t3) {
        e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
        for (var r3 = Array(80), n3 = 1732584193, i3 = -271733879, a3 = -1732584194, o3 = 271733878, s3 = -1009589776, l3 = 0; l3 < e4.length; l3 += 16) {
          for (var c3 = n3, u3 = i3, h3 = a3, d3 = o3, p2 = s3, f2 = 0; f2 < 80; f2++) {
            r3[f2] = f2 < 16 ? e4[l3 + f2] : v2(r3[f2 - 3] ^ r3[f2 - 8] ^ r3[f2 - 14] ^ r3[f2 - 16], 1);
            var m2 = g2(g2(v2(n3, 5), f2 < 20 ? i3 & a3 | ~i3 & o3 : !(f2 < 40) && f2 < 60 ? i3 & a3 | i3 & o3 | a3 & o3 : i3 ^ a3 ^ o3), g2(g2(s3, r3[f2]), f2 < 20 ? 1518500249 : f2 < 40 ? 1859775393 : f2 < 60 ? -1894007588 : -899497514)), s3 = o3, o3 = a3, a3 = v2(i3, 30), i3 = n3, n3 = m2;
          }
          n3 = g2(n3, c3), i3 = g2(i3, u3), a3 = g2(a3, h3), o3 = g2(o3, d3), s3 = g2(s3, p2);
        }
        return Array(n3, i3, a3, o3, s3);
      }
      function g2(e4, t3) {
        var r3 = (65535 & e4) + (65535 & t3);
        return (e4 >> 16) + (t3 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      function v2(e4, t3) {
        return e4 << t3 | e4 >>> 32 - t3;
      }
      d2.exports = function(e4) {
        return c2.hash(e4, u2, 20, true);
      };
    }.call(this, h2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, h2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(h2, d2, e2) {
    !function(e3, t2, r2, n2, i2, a2, o2, s2, l2) {
      function v2(e4, t3) {
        var r3 = (65535 & e4) + (65535 & t3);
        return (e4 >> 16) + (t3 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      function y(e4, t3) {
        return e4 >>> t3 | e4 << 32 - t3;
      }
      function c2(e4, t3) {
        var r3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), n3 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), i3 = new Array(64);
        e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
        for (var a3, o3, s3 = 0; s3 < e4.length; s3 += 16) {
          for (var l3 = n3[0], c3 = n3[1], u3 = n3[2], h3 = n3[3], d3 = n3[4], p2 = n3[5], f2 = n3[6], m2 = n3[7], g2 = 0; g2 < 64; g2++)
            i3[g2] = g2 < 16 ? e4[g2 + s3] : v2(v2(v2(y(o3 = i3[g2 - 2], 17) ^ y(o3, 19) ^ o3 >>> 10, i3[g2 - 7]), y(a3 = i3[g2 - 15], 7) ^ y(a3, 18) ^ a3 >>> 3), i3[g2 - 16]), a3 = v2(v2(v2(v2(m2, y(o3 = d3, 6) ^ y(o3, 11) ^ y(o3, 25)), d3 & p2 ^ ~d3 & f2), r3[g2]), i3[g2]), o3 = v2(y(o3 = l3, 2) ^ y(o3, 13) ^ y(o3, 22), l3 & c3 ^ l3 & u3 ^ c3 & u3), m2 = f2, f2 = p2, p2 = d3, d3 = v2(h3, a3), h3 = u3, u3 = c3, c3 = l3, l3 = v2(a3, o3);
          n3[0] = v2(l3, n3[0]), n3[1] = v2(c3, n3[1]), n3[2] = v2(u3, n3[2]), n3[3] = v2(h3, n3[3]), n3[4] = v2(d3, n3[4]), n3[5] = v2(p2, n3[5]), n3[6] = v2(f2, n3[6]), n3[7] = v2(m2, n3[7]);
        }
        return n3;
      }
      var u2 = h2("./helpers");
      d2.exports = function(e4) {
        return u2.hash(e4, c2, 32, true);
      };
    }.call(this, h2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, h2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e2, u2, t2) {
    !function(e3, t3, r2, n2, i2, a2, o2, s2, l2) {
      function c2() {
      }
      (e3 = u2.exports = {}).nextTick = function() {
        var e4 = typeof window != "undefined" && window.setImmediate, t4 = typeof window != "undefined" && window.postMessage && window.addEventListener;
        if (e4)
          return function(e5) {
            return window.setImmediate(e5);
          };
        if (t4) {
          var r3 = [];
          return window.addEventListener("message", function(e5) {
            var t5 = e5.source;
            t5 !== window && t5 !== null || e5.data !== "process-tick" || (e5.stopPropagation(), 0 < r3.length && r3.shift()());
          }, true), function(e5) {
            r3.push(e5), window.postMessage("process-tick", "*");
          };
        }
        return function(e5) {
          setTimeout(e5, 0);
        };
      }(), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = c2, e3.addListener = c2, e3.once = c2, e3.off = c2, e3.removeListener = c2, e3.removeAllListeners = c2, e3.emit = c2, e3.binding = function(e4) {
        throw new Error("process.binding is not supported");
      }, e3.cwd = function() {
        return "/";
      }, e3.chdir = function(e4) {
        throw new Error("process.chdir is not supported");
      };
    }.call(this, e2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
  }, { buffer: 3, lYpoI2: 10 }], 11: [function(e2, t2, c2) {
    !function(e3, t3, r2, n2, i2, a2, o2, s2, l2) {
      c2.read = function(e4, t4, r3, n3, i3) {
        var a3, o3, s3 = 8 * i3 - n3 - 1, l3 = (1 << s3) - 1, c3 = l3 >> 1, u2 = -7, h2 = r3 ? i3 - 1 : 0, d2 = r3 ? -1 : 1, r3 = e4[t4 + h2];
        for (h2 += d2, a3 = r3 & (1 << -u2) - 1, r3 >>= -u2, u2 += s3; 0 < u2; a3 = 256 * a3 + e4[t4 + h2], h2 += d2, u2 -= 8)
          ;
        for (o3 = a3 & (1 << -u2) - 1, a3 >>= -u2, u2 += n3; 0 < u2; o3 = 256 * o3 + e4[t4 + h2], h2 += d2, u2 -= 8)
          ;
        if (a3 === 0)
          a3 = 1 - c3;
        else {
          if (a3 === l3)
            return o3 ? NaN : 1 / 0 * (r3 ? -1 : 1);
          o3 += Math.pow(2, n3), a3 -= c3;
        }
        return (r3 ? -1 : 1) * o3 * Math.pow(2, a3 - n3);
      }, c2.write = function(e4, t4, r3, n3, i3, a3) {
        var o3, s3, l3 = 8 * a3 - i3 - 1, c3 = (1 << l3) - 1, u2 = c3 >> 1, h2 = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n3 ? 0 : a3 - 1, p2 = n3 ? 1 : -1, a3 = t4 < 0 || t4 === 0 && 1 / t4 < 0 ? 1 : 0;
        for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (s3 = isNaN(t4) ? 1 : 0, o3 = c3) : (o3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (n3 = Math.pow(2, -o3)) < 1 && (o3--, n3 *= 2), 2 <= (t4 += 1 <= o3 + u2 ? h2 / n3 : h2 * Math.pow(2, 1 - u2)) * n3 && (o3++, n3 /= 2), c3 <= o3 + u2 ? (s3 = 0, o3 = c3) : 1 <= o3 + u2 ? (s3 = (t4 * n3 - 1) * Math.pow(2, i3), o3 += u2) : (s3 = t4 * Math.pow(2, u2 - 1) * Math.pow(2, i3), o3 = 0)); 8 <= i3; e4[r3 + d2] = 255 & s3, d2 += p2, s3 /= 256, i3 -= 8)
          ;
        for (o3 = o3 << i3 | s3, l3 += i3; 0 < l3; e4[r3 + d2] = 255 & o3, d2 += p2, o3 /= 256, l3 -= 8)
          ;
        e4[r3 + d2 - p2] |= 128 * a3;
      };
    }.call(this, e2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
  }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
  var __objectHash = object_hash.exports, __awaiter$2 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class SThemeBase extends SClass {
    constructor(e2, t2) {
      if (super({}), this.name = e2 != null ? e2 : SSugarConfig.get("theme.theme"), this.variant = t2 != null ? t2 : SSugarConfig.get("theme.variant"), !SSugarConfig.get(`theme.themes.${this.name}-` + this.variant))
        throw new Error(`Sorry but the requested theme "<yellow>${this.name}-${this.variant}</yellow>" does not exists...`);
    }
    get id() {
      return this.name + "-" + this.variant;
    }
    static get theme() {
      return SSugarConfig.get("theme.theme");
    }
    static get variant() {
      return SSugarConfig.get("theme.variant");
    }
    static get themes() {
      return Object.keys(SSugarConfig.get("theme.themes"));
    }
    static getTheme(e2, t2) {
      if (e2 = e2 != null ? e2 : SSugarConfig.get("theme.theme"), t2 = t2 != null ? t2 : SSugarConfig.get("theme.variant"), e2 = e2 != null ? e2 : SSugarConfig.get("theme.theme"), this._instanciatedThemes[e2 + "-" + t2])
        return this._instanciatedThemes[e2 + "-" + t2];
      var r2 = SSugarConfig.get("theme.themes");
      if (!r2[e2 + "-" + t2])
        throw new Error(`<red>[${this.name}]</red> Sorry but the requested theme "<yellow>${e2}-${t2}</yellow>" does not exists. Here's the available themes: <green>${Object.keys(r2).join(",")}</green>`);
      return this._instanciatedThemes[e2 + "-" + t2] = new this(e2, t2), this._instanciatedThemes[e2 + "-" + t2];
    }
    static hash(e2 = "") {
      e2 = this.config(e2);
      return __objectHash(e2);
    }
    static cssVar(e2, t2 = true) {
      let r2 = this.getTheme().config(e2);
      return (!t2 || typeof r2 == "string" && r2.includes(",")) && (r2 = 0), `var(${"--s-theme-" + e2.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-")}, ${r2})`;
    }
    static jsObjectToCssProperties(t2, e2) {
      const a2 = __deepMerge$7({ exclude: [], only: [] }, e2), o2 = [];
      return Object.keys(t2).forEach((r2) => {
        if (a2.exclude.indexOf(r2) === -1 && a2.exclude.indexOf(dashCase(r2)) === -1) {
          var e3 = r2;
          if (r2 = dashCase(r2).trim(), !(a2.exclude.length && a2.exclude.indexOf(r2) !== -1 || a2.only.length && a2.only.indexOf(r2) === -1)) {
            var n2 = t2[e3];
            if (n2) {
              let e4, t3;
              switch (r2) {
                case "font-family":
                  o2.push(`@sugar.font.family(${n2});`);
                  break;
                case "font-size":
                  o2.push(`@sugar.font.size(${n2});`);
                  break;
                case "color":
                  e4 = n2, t3 = "", Array.isArray(n2) && (e4 = n2[0], t3 = n2[1]), o2.push(`color: sugar.color(${e4}, ${t3});`);
                  break;
                case "background-color":
                  e4 = n2, t3 = "", Array.isArray(n2) && (e4 = n2[0], t3 = n2[1]), o2.push(`background-color: sugar.color(${e4}, ${t3});`);
                  break;
                case "border-radius":
                case "border-top-left-radius":
                case "border-top-right-radius":
                case "border-bottom-right-radius":
                case "border-bottom-left-radius":
                  o2.push(`border-radius: sugar.border.radius(${n2});`);
                  break;
                case "border-width":
                  o2.push(`border-width: sugar.border.width(${n2});`);
                  break;
                case "transition":
                  o2.push(`transition: sugar.transition(${n2});`);
                  break;
                case "margin-inline":
                case "margin-block":
                case "margin-inline-start":
                case "margin-inline-end":
                case "margin-block-start":
                case "margin-block-end":
                case "margin":
                case "margin-top":
                case "margin-bottom":
                case "margin-left":
                case "margin-right":
                  o2.push(r2 + `: sugar.margin(${n2});`);
                  break;
                case "padding-inline":
                case "padding-block":
                case "padding-inline-start":
                case "padding-inline-end":
                case "padding-block-start":
                case "padding-block-end":
                case "padding":
                case "padding-top":
                case "padding-bottom":
                case "padding-left":
                case "padding-right":
                  o2.push(r2 + `: sugar.padding(${n2});`);
                  break;
                case "depth":
                  o2.push(`@sugar.depth(${n2});`);
                  break;
                case "default-color":
                  o2.push(`@sugar.color(${n2});`);
                  break;
                default:
                  const i2 = knownCssProperties.all;
                  if (i2.indexOf(r2) === -1)
                    return;
                  o2.push(r2 + `: ${n2};`);
              }
            }
          }
        }
      }), o2.join("\n");
    }
    static remapCssColorVars(e2, t2) {
      let r2 = [];
      const n2 = t2.split("-").slice(0, 1)[0], i2 = e2.split("-").slice(0, 1)[0];
      let a2 = t2.split("-").pop();
      e2.split("-").pop(), n2 === a2 && (a2 = void 0);
      let o2 = "--s-theme-color-" + i2, s2 = "--s-theme-color-" + n2;
      return this.getTheme().loopOnColors((e3) => {
        e3.name === n2 && (a2 ? e3.variant === a2 && (r2.push(o2 + `-saturation-offset: var(${s2}-${e3.variant}-saturation-offset, 0);`), r2.push(o2 + `-lightness-offset: var(${s2}-${e3.variant}-lightness-offset, 0);`), r2.push(o2 + `-a: var(${s2}-a, 1);`)) : e3.state || e3.variant || !e3.value.color ? e3.value.color || (r2.push(o2 + `-${e3.variant}-saturation-offset: var(${s2}-${e3.variant}-saturation-offset, 0);`), r2.push(o2 + `-${e3.variant}-lightness-offset: var(${s2}-${e3.variant}-lightness-offset, 0);`), r2.push(o2 + `-a: var(${s2}-a, 1);`)) : (r2.push(o2 + `-h: var(${s2}-h);`), r2.push(o2 + `-s: var(${s2}-s);`), r2.push(o2 + `-l: var(${s2}-l);`)));
      }), r2;
    }
    static toCssVars(e2, t2) {
      const r2 = this.getTheme(e2, t2);
      if (!r2)
        throw new Error(`Sorry but the requested theme "<yellow>${e2}-${t2}</yellow>" does not exists...`);
      r2.themesConfig();
      let n2 = [];
      r2.loopOnColors((e3) => {
        var t3 = e3.value.variable;
        e3.state || e3.variant || !e3.value.color ? e3.value.color || (e3.value.saturate ? n2.push(`${t3}-saturation-offset: ${e3.value.saturate};`) : e3.value.desaturate ? n2.push(`${t3}-saturation-offset: ${-1 * e3.value.desaturate};`) : n2.push(t3 + "-saturation-offset: 0;"), e3.value.lighten ? n2.push(`${t3}-lightness-offset: ${e3.value.lighten};`) : e3.value.darken ? n2.push(`${t3}-lightness-offset: ${-1 * e3.value.darken};`) : n2.push(t3 + "-lightness-offset: 0;"), 0 <= e3.value.alpha && e3.value.alpha <= 1 && n2.push(`${t3}-a: ${e3.value.alpha};`)) : (n2.push(`${t3}-h: ${e3.value.h};`), n2.push(`${t3}-s: ${e3.value.s};`), n2.push(`${t3}-l: ${e3.value.l};`), n2.push(`${t3}-a: ${e3.value.a};`), n2.push(`${t3}-origin-h: ${e3.value.h};`), n2.push(`${t3}-origin-s: ${e3.value.s};`), n2.push(`${t3}-origin-l: ${e3.value.l};`), n2.push(`${t3}-origin-a: ${e3.value.a};`));
      });
      const i2 = Object.assign({}, r2.config("."));
      delete i2.color;
      const a2 = flatten(i2);
      return Object.keys(a2).forEach((e3) => {
        var t3 = a2[e3], r3 = "--s-theme-" + e3.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-");
        ("" + t3).match(/:/) ? n2.push(r3 + `: "${a2[e3]}";`) : n2.push(r3 + `: ${a2[e3]};`);
      }), n2;
    }
    static config(e2, t2, r2) {
      const n2 = this.getTheme(t2, r2);
      return n2.config(e2);
    }
    get themes() {
      return SSugarConfig.get("theme.themes");
    }
    get _config() {
      return SSugarConfig.get("theme.themes")[this.id];
    }
    config(e2) {
      var t2 = get$3(this._config, e2);
      if (t2 === void 0)
        throw new Error(`<red>[${this.constructor.name}]</red> Sorry but the requested "<yellow>${this.id}</yellow>" theme config "<cyan>${e2}</cyan>" does not exists...`);
      return t2;
    }
    hash(e2 = "") {
      e2 = this.config(e2);
      return __objectHash(e2);
    }
    themesConfig() {
      return SSugarConfig.get("theme");
    }
    baseColors() {
      const n2 = {};
      return Object.keys(this._config.color).forEach((e2) => {
        var t2, r2 = this._config.color[e2];
        r2.color && (t2 = new SColor(r2.color), n2[e2] = { color: r2.color, variable: "--s-theme-color-" + e2, r: t2.r, g: t2.g, b: t2.b, h: t2.h, s: t2.s, l: t2.l, a: t2.a });
      }), n2;
    }
    loopOnColors(h2) {
      return __awaiter$2(this, void 0, void 0, function* () {
        const r2 = this.config("color");
        let u2 = false;
        return Object.keys(r2).forEach((o2, e2) => {
          var t2;
          if (!u2) {
            const s2 = r2[o2], l2 = Object.assign({}, (t2 = s2.default) !== null && t2 !== void 0 ? t2 : {});
            if (!s2.color)
              throw new Error(`Sorry but your color "<yellow>${o2}</yellow>" does not provide a "<cyan>color</cyan>" property and this is required...`);
            const c2 = new SColor(s2.color);
            h2({ name: o2, variant: "", state: "", value: { color: s2.color, variable: "--s-theme-color-" + o2, r: c2.r, g: c2.g, b: c2.b, h: c2.h, s: c2.s, l: c2.l, a: c2.a } }), Object.keys(s2).forEach((t3, e3) => {
              if (!u2) {
                var a2 = t3;
                let r3 = (t3 = t3 === "default" ? ":default" : t3).match(/^:/) ? t3.slice(1) : "", e4 = t3.match(/^:/) ? "" : t3, n2, i2 = Object.assign({}, s2[a2]);
                r3 !== "default" && (i2 = Object.assign(Object.assign({}, l2), i2)), t3 === "color" || (t3.match(/^:/) ? Object.keys(i2).forEach((e5) => {
                  var t4 = c2.apply(i2[e5], true);
                  n2 = h2({ name: o2, state: r3 === "default" ? "" : r3, variant: e5, value: Object.assign(Object.assign({ variable: r3 && r3 !== "default" ? `--s-theme-color-${o2}-${r3}-` + e5 : `--s-theme-color-${o2}-` + e5 }, i2[e5]), { r: t4.r, g: t4.g, b: t4.b, h: t4.h, s: t4.s, l: t4.l, a: t4.a }) }), n2 !== false && n2 !== -1 || (u2 = true);
                }) : (t3 = c2.apply(i2, true), n2 = h2({ name: o2, variant: e4, state: r3, value: Object.assign(Object.assign({ variable: r3 ? `--s-theme-color-${o2}-${r3}-` + e4 : `--s-theme-color-${o2}-` + e4 }, i2), { r: t3.r, g: t3.g, b: t3.b, h: t3.h, s: t3.s, l: t3.l, a: t3.a }) }), n2 !== false && n2 !== -1 || (u2 = true)));
              }
            });
          }
        }), true;
      });
    }
  }
  SThemeBase._instanciatedThemes = {};
  class STheme extends SThemeBase {
    static setTheme(e2, t2, r2 = document.body) {
      return r2.setAttribute("theme", e2), r2.setAttribute("variant", t2), this.getCurrentTheme(r2);
    }
    static getCurrentTheme(e2 = document.body) {
      var t2 = (t2 = e2.getAttribute("theme")) !== null && t2 !== void 0 ? t2 : SSugarConfig.get("theme.theme"), e2 = (e2 = e2.getAttribute("variant")) !== null && e2 !== void 0 ? e2 : SSugarConfig.get("theme.variant");
      return this.getTheme(t2, e2);
    }
    constructor(e2, t2) {
      super(e2, t2);
    }
    setColor(e2, t2, r2 = document.body) {
      t2 = new SColor(t2);
      r2.style.setProperty(`--s-theme-color-${e2}-h`, t2.h), r2.style.setProperty(`--s-theme-color-${e2}-s`, t2.s), r2.style.setProperty(`--s-theme-color-${e2}-l`, t2.l);
    }
    color(e2, t2, r2 = document.body) {
      const n2 = document.createElement("p");
      n2.classList.add("s-bg--" + e2 + (t2 ? "-" + t2 : ""));
      const i2 = document.createElement("div");
      i2.setAttribute("hidden", "true"), i2.setAttribute("theme", this.name), i2.setAttribute("variant", this.variant), i2.appendChild(n2), r2.appendChild(i2);
      r2 = getComputedStyle(n2), r2 = new SColor(r2.backgroundColor);
      return i2.remove(), r2;
    }
  }
  var __awaiter$1 = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class CkSettings extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false } }), this._settings = { darkMode: true, colors: { accent: void 0, complementary: void 0 } }, this._state = getState(), this._theme = STheme.getCurrentTheme();
    }
    firstUpdated() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const e2 = this.querySelector("#setting-main-color"), t2 = this.querySelector("#setting-accent-color"), r2 = this.querySelector("#setting-complementary-color");
        e2.addEventListener("change", (e3) => {
          this._theme.setColor("main", e3.detail.hex);
        }), t2.addEventListener("change", (e3) => {
          this._theme.setColor("accent", e3.detail.hex);
        }), r2.addEventListener("change", (e3) => {
          console.log("com", e3.detail.hex), this._theme.setColor("complementary", e3.detail.hex);
        });
      });
    }
    toggleMode(e2) {
      this._state.darkMode = e2, this._theme = e2 ? STheme.setTheme("default", "dark") : STheme.setTheme("default", "light"), setState(this._state);
    }
    render() {
      return p`
            <div class="ck-settings">
                <div class="s-p:40 s-mbe:40">
                    <h1 class="s-typo:h3 s-mbe:40">Settings</h1>
                    <p class="s-typo:p">
                        These settings allows you to customize your Coffeekraken
                        experience as well as feature some of the capabilities
                        that our toolkit has to offer.
                    </p>
                </div>

                <ul class="__settings s-bg:odd">
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="theme-switcher"
                        >
                            Dark mode
                            <input
                                class="s-switch"
                                type="checkbox"
                                id="theme-switcher"
                                ?checked="${this._state.darkMode}"
                                @change="${(e2) => {
        this.toggleMode(e2.target.checked);
      }}"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-main-color"
                        >
                            Main color
                            <s-color-picker id="setting-main-color">
                                <input
                                    type="text"
                                    class="s-input"
                                    value="${this._theme.color("main").toHex()}"
                                />
                            </s-color-picker>
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-accent-color"
                        >
                            Accent color
                            <s-color-picker id="setting-accent-color">
                                <input
                                    type="text"
                                    class="s-input"
                                    value="${this._theme.color("accent").toHex()}"
                                />
                            </s-color-picker>
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-complementary-color"
                        >
                            Complementary color
                            <s-color-picker id="setting-complementary-color">
                                <input
                                    type="text"
                                    class="s-input"
                                    value="${this._theme.color("complementary").toHex()}"
                                />
                            </s-color-picker>
                        </label>
                    </li>
                </ul>
            </div>
        `;
    }
  }
  function define$1(e2 = {}, t2 = "ck-settings") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, CkSettings);
  }
  var __decorate = globalThis && globalThis.__decorate || function(e2, t2, r2, n2) {
    var i2, a2 = arguments.length, o2 = a2 < 3 ? t2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var s2 = e2.length - 1; 0 <= s2; s2--)
        (i2 = e2[s2]) && (o2 = (a2 < 3 ? i2(o2) : 3 < a2 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return 3 < a2 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }, __awaiter = globalThis && globalThis.__awaiter || function(e2, o2, s2, l2) {
    return new (s2 = s2 || Promise)(function(r2, t2) {
      function n2(e3) {
        try {
          a2(l2.next(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function i2(e3) {
        try {
          a2(l2.throw(e3));
        } catch (e4) {
          t2(e4);
        }
      }
      function a2(e3) {
        var t3;
        e3.done ? r2(e3.value) : ((t3 = e3.value) instanceof s2 ? t3 : new s2(function(e4) {
          e4(t3);
        })).then(n2, i2);
      }
      a2((l2 = l2.apply(e2, o2 || [])).next());
    });
  };
  class VersionSelector extends SLitComponent {
    constructor() {
      super({ litComponent: { shadowDom: false } }), this._versions = [], __awaiter(this, void 0, void 0, function* () {
        var e2 = yield loadDocmap();
        this._versions = e2.snapshots || [];
      });
    }
    _change(t2) {
      setTimeout(() => {
        let e2 = document.location.href;
        e2 = document.location.href.match(/^https?:\/\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\./) ? document.location.href.replace(/^(https?:\/\/v)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.(.*)/, `$1${t2.target.value}.$2`) : document.location.href.replace(/^(https?:\/\/)(.*)/, `$1v${t2.target.value}.$2`), document.location = e2;
      });
    }
    render() {
      return p`
            <label class="s-select s-color:accent">
                <select @change="${this._change}">
                    ${this._versions.map((e2) => p`
                            <option
                                ?selected="${this._currentVersion === e2}"
                                value="${e2}"
                            >
                                ${e2}
                            </option>
                        `)}
                </select>
            </label>
        `;
    }
  }
  function define(e2 = {}, t2 = "version-selector") {
    SLitComponent.setDefaultProps(t2, e2), customElements.define(t2, VersionSelector);
  }
  __decorate([e()], VersionSelector.prototype, "_currentVersion", void 0), __decorate([e()], VersionSelector.prototype, "_versions", void 0), window.env || (window.env = { SUGAR: {} }), window.env.SUGAR = JSON.parse('{"platform":"browser","env":"dev","config":{"contact":{"discord":{"url":"https://discord.gg/ERsX54UE","shield":"https://img.shields.io/badge/Join%20us%20on%20discord-Join-blueviolet?style=for-the-badge&logo=discord"},"email":{"url":"olivier.bossel@gmail.com","shield":"https://img.shields.io/badge/Email%20us-Go-green?style=for-the-badge&logo=Mail.Ru"}},"datetime":{"dateFormat":"YYYY-MM-DD","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"log":{"types":["info","warning","error"]},"serve":{"img":{"url":"/src/img"},"js":{"url":"/src/js"},"css":{"url":"/src/css"},"icons":{"url":"/src/icons"},"fonts":{"url":"/src/fonts"}},"env":{"env":"development"},"theme":{"theme":"default","variant":"light","cssVariables":["*"],"themes":{"coffeekraken-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#776D91","...":"[extends.colorSchemas]"},"ui":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#7a738c","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":15},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"primary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"secondary":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}},"default-light":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50,"darken":20},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"primary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"secondary":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0,"darken":10},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"darken":50},"5":{"darken":45},"10":{"darken":40},"15":{"darken":35},"20":{"darken":30},"25":{"darken":25},"30":{"darken":20},"35":{"darken":15},"40":{"darken":10},"45":{"darken":5},"50":{"darken":0},"55":{"lighten":5},"60":{"lighten":10},"65":{"lighten":15},"70":{"lighten":20},"75":{"lighten":25},"80":{"lighten":30},"85":{"lighten":35},"90":{"lighten":40},"95":{"lighten":48},"100":{"lighten":50},"text":{"lighten":0},"placeholder":{"darken":45,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"backgroundForeground":{"darken":45},"surface":{"lighten":48},"surfaceForeground":{"darken":45},"ui":{"lighten":50},"uiForeground":{"darken":25},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"defaultColor":"main"},"default-dark":{"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"helpers":{"clearfix":{"default":"overflow"},"disabled":{"opacity":0.3},"truncate":{"count":10}},"layout":{"container":{"default":{"max-width":"1280px"},"full":{"max-width":"none"}},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","112":"1 1 2","122":"1 2 2","123":"1 2 3","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6"}},"ratio":{"1":1,"21-9":2.3333333333333335,"16-9":1.7777777777777777,"2-3":0.6666666666666666,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)"},"color":{"extension":{"color":"#ffbb00","blade":"#ff2d20","php":"#8892BF","js":"#f7df1e","ts":"#0374C1","node":"#68A063","css":"#498FE1","scss":"#CF649A","sass":"#CF649A","json":"#000000","jpg":"#B2C0E1","jpeg":"#B2C0E1","pdf":"#E7786E","doc":"#60D7FD","psd":"#F9D659","mp3":"#E98C61","png":"#C29DFB","aac":"#B1C5C9","zip":"#9CC04E","dmg":"#E36E4B"},"main":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"accent":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffbb00","...":"[extends.colorSchemas]"},"complementary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":15},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#5100ff","...":"[extends.colorSchemas]"},"success":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#91ff00","...":"[extends.colorSchemas]"},"warning":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ffd500","...":"[extends.colorSchemas]"},"error":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#ff003b","...":"[extends.colorSchemas]"},"info":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"#00ffff","...":"[extends.colorSchemas]"},"current":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"primary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"},"secondary":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":46},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}},"color":"hsla(198,10,50,1)","...":"[extends.colorSchemas]"}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"},"font":{"family":{"default":{"font-family":"\\"Titillium Web\\"","font-weight":400,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400&display=swap"},"title":{"font-family":"\\"Titillium Web\\"","font-weight":600,"import":"https://fonts.googleapis.com/css2?family=Titillium+Web:wght@600&display=swap"},"quote":{"font-family":"\\"Palatino, Times, Georgia, serif\\"","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65},"code":{"font-family":"Menlo, Monaco, Consolas, Courier New, monospace","font-weight":"normal","font-style":"normal","font-display":"auto","cap-height":0.65}},"size":{"0":"0.25rem","5":"0.5rem","10":"0.65rem","20":"0.75rem","30":"1rem","40":"1.25rem","50":"1.50em","60":"2rem","70":"2.5rem","80":"3rem","90":"4rem","100":"5rem","default":"16px"}},"border":{"width":{"0":"0px","10":"1px","20":"2px","30":"4px","40":"6px","50":"8px","60":"12px","70":"16px","80":"20px","90":"24px","100":"30px","default":"1px"},"radius":{"0":"0","10":"4px","20":"8px","30":"12px","40":"16px","50":"20px","60":"26px","70":"32px","80":"40px","90":"50px","100":"60px","default":"10px"}},"space":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"margin":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"padding":{"0":"0","10":"0.375rem","20":"0.75rem","30":"1.5rem","40":"2.25rem","50":"3rem","60":"3.75rem","70":"4.5rem","80":"5.25","90":"6rem","100":"6.75rem","default":"3rem"},"media":{"defaultAction":">=","defaultQuery":"screen","queries":{"mobile":{"min-width":0,"max-width":639},"tablet":{"min-width":640,"max-width":1279},"desktop":{"min-width":1280,"max-width":null}}},"components":{"s-code-example":{"rhythmVertical":{"margin-bottom":60}}},"ui":{"filtrableInput":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":60}},"default":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"form":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"defaultColor":"accent","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":"10px","transition":"all .2s ease-out"},"scrollbar":{"size":"2px","defaultColor":"main"},"button":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"avatar":{"borderRadius":"10px","borderWidth":"2px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":60}},"colorPicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"accent","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"datePicker":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":["theme.ui.form.defaultColor"],"defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"input":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"radio":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.5em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"defaultStyle":"solid","defaultShape":"default","rhythmVertical":{"margin-bottom":40}},"checkbox":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"0.2em","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"range":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true,"rhythmVertical":{"margin-bottom":40}},"label":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"inline","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":40}},"select":{"paddingInline":"0.75em","paddingBlock":"0.375em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"switch":{"borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","defaultStyle":"solid","defaultShape":"default","outline":true,"rhythmVertical":{"margin-bottom":40}},"dropdown":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","outline":true},"list":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"dl","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"fsTree":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","bulletChar":"\u25CF","rhythmVertical":{"margin-bottom":60}},"tabs":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"outline":true,"rhythmVertical":{"margin-bottom":60}},"terminal":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"tooltip":{"paddingInline":"0.75em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","arrowSize":"20px"},"code":{"paddingInline":"3rem","paddingBlock":"3rem","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultColor":"main","defaultStyle":"solid","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"blockquote":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":60}},"table":{"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"badge":{"paddingInline":".65em","paddingBlock":".35em","borderRadius":"10px","borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultStyle":"solid","defaultShape":"default","depth":0,"rhythmVertical":{"margin-bottom":60}},"loader":{"duration":"1s","easing":"linear"},"loaderSpinner":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"font-family":"title","font-size":90,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h2":{"font-family":"title","font-size":80,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h3":{"font-family":"title","font-size":70,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h4":{"font-family":"title","font-size":60,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"h5":{"font-family":"title","font-size":50,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"h6":{"font-family":"title","font-size":40,"line-height":1.3,"max-width":"55ch","rhythmVertical":{"margin-bottom":40}},"p":{"font-family":"default","font-size":30,"line-height":1.8,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"lead":{"font-family":"default","font-size":50,"line-height":1.6,"max-width":"55ch","rhythmVertical":{"margin-bottom":50}},"hr":{"color":"hsla(198,10,50,1)","opacity":0.2,"rhythmVertical":{"margin-bottom":50}},"pre":{"font-family":"code","color":["main","text"],"background-color":["main","surface"],"line-height":1.5,"paddingInline":"1.5em","paddingBlock":"0.75em","borderRadius":"10px","depth":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","rhythmVertical":{"margin-bottom":50}},"code:not(pre > code)":{"display":"inline-block","font-family":"code","color":["main","text"],"background-color":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0},"a":{"color":"accent"},"quote":{"font-family":"quote"},"b":{"font-weight":"bold"},"bold":{"font-weight":"bold"},"strong":{"font-weight":"bold"},"i":{"font-style":"italic"},"italic":{"font-style":"italic"},"em":{"font-style":"italic"},"small":{"font-size":"0.5em"},"mark":{"background-color":"#ffbb00"},"del":{"text-decoration":"line-through"},"ins":{"text-decoration":"underline"},"sub":{"vertical-align":"sub","font-size":"0.6em"},"sup":{"vertical-align":"sup","font-size":"0.6em"}},"colorSchemas":{"default":{"0":{"lighten":50},"5":{"lighten":45},"10":{"lighten":40},"15":{"lighten":35},"20":{"lighten":30},"25":{"lighten":25},"30":{"lighten":20},"35":{"lighten":15},"40":{"lighten":10},"45":{"lighten":5},"50":{"lighten":0},"55":{"darken":5},"60":{"darken":10},"65":{"darken":15},"70":{"darken":20},"75":{"darken":25},"80":{"darken":30},"85":{"darken":35},"90":{"darken":40},"95":{"darken":48},"100":{"darken":50},"text":{"lighten":0},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"backgroundForeground":{"lighten":50},"surface":{"darken":25},"surfaceForeground":{"lighten":50},"ui":{"darken":20},"uiForeground":{"lighten":50},"border":{"alpha":0.2},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"defaultColor":"main"}}}}}'), SConductor.setup({ log: true }), (() => __async(this, null, function* () {
    SLitComponent.setDefaultProps("*", { mountWhen: "nearViewport" }), SLitComponent.setDefaultProps(["s-side-panel", "ck-settings"], { mountWhen: "direct" }), expandPleasantCssClassnamesLive(), define$f(), define(), define$2(), define$5(), smoothScroll({ scroll: { offset: 188 } }), linksStateAttributes(), define$4(), define$1(), define$d(), define$6(), define$c(), define$b(), define$7(), define$9(), define$8(), define$a({ customValidations: { coffeekraken: (e2, t2) => e2 === "coffeekraken" ? t2.message("Are you sure? Krakens are dangerous...") : e2 } });
  }))();
}(OrbitControls_js);
